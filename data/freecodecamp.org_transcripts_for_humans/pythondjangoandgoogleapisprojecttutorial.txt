With timestamps:

00:00 - Learn to use a Django with six different Google 
API's in this core from Bobby Stearman. Hey,  
00:06 - everyone is Bobby from decoding here. And in 
this course, I will be walking you through and  
00:11 - showing you how to build a Django app that uses 
six different Google API's. So let's start with  
00:18 - the walkthrough. If you look at my screen, you can 
see that I've got the app open already on the sign  
00:25 - in page. So if we click on sign up, because we 
don't currently have a user account, there's Bobby  
00:34 - stemmen. And we'll have a username This must be 
an email, Bobby at did demo.com. password, I will  
00:45 - use Fred Fred one. Confirm Password, Fred, Fred 
one, we have also got a show passwords toggle,  
00:54 - it converts a password input to a text input. 
So you can see they match. If I click Sign up,  
01:00 - when I click Sign up, we will be using the 
recapture version three software. This is a  
01:05 - Google product that scores a form submission. And 
the higher the score, the more likely it is that  
01:12 - is a real human being that is actually submitting 
the form is great. The fact we've got this element  
01:18 - in the bottom right of the screen would suggest 
that the software is working. So this sign up  
01:24 - should get a message that says thank you for 
signing up and will then be redirected to to  
01:30 - the user account page. The user account, the user 
can then update their profile with an address.  
01:37 - And this is where we use the Google Places API. 
So it is predictive. So as I type into the input,  
01:45 - Google will predict the address in the country 
that is predefined in settings, dot p y, and  
01:51 - give you a number of different addresses 
that meet the search. So let's go with 123.  
01:59 - And that's coming up with a few different 
addresses this go 123 Victoria Street,  
02:03 - as I click it, it will pre populate some hidden 
inputs. And then I have the option to update.  
02:11 - Your profile has been updated. Okay, so that's 
one of the API's. The other one is in route. So  
02:17 - this app will allow you to put a starting point, 
so an origin, a waypoint, one, a waypoint, two  
02:24 - and the destination. And when we submit this, or 
actually, when we finished the fourth input here,  
02:31 - programmatically, it will create a parameter 
string and redirect us to a different URL,  
02:35 - and it will render the map. So let's add a 
few addresses. So we'll go one, high streets,  
02:44 - Sutton eally, they'll have 
another one high one High Street,  
02:52 - had them easily. So this is all 
around my local area. Then we go one,  
02:59 - High Street, stratum ealey. And then 
lastly, we'll do one marketplace.  
03:10 - easily. There we have it. When I click this, 
it will then say right, you have completed  
03:16 - all four waypoints. And if you look at the 
top here is create a fancy parameter string,  
03:22 - but the URL is map. So it shows the start and 
destination longitude and latitude, the duration  
03:29 - from the origin to the destination, the distance 
between origin and destination, and then it will  
03:35 - render a map, which is brilliant. And if I then 
click, click here for directions, it will then  
03:41 - unhide some elements in HTML. And it will show you 
every single step that is required from the origin  
03:49 - to the destination. So that is the application 
that I've built. This is the one that we're going  
03:55 - to go through in this course, I will go through 
every single step that is necessary, right from  
04:02 - enabling API's at Google and recapture starting 
a new project, building the back end building the  
04:07 - front end and fully testing the application. So 
without further ado, let's jump into section one.  
04:22 - Hey, everyone is Bobby from decode in 
here and in this segment, we will be  
04:26 - setting up to Google API keys. These API keys 
will allow us to interact with six Google API's.  
04:35 - The first one we'll be looking at today is 
something called google recaptcha. Now, this  
04:40 - is software that stops malicious software from 
interacting with your website. So essentially,  
04:47 - it keeps the riffraff out, and allows real human 
beings to submit forms. Now you will have come  
04:52 - across this before in other people's websites, 
you will complete a form and when submitting that  
04:58 - form, you'll be presented with Nine images and 
asked to select any image that may contain a bus,  
05:06 - or a plane or a motorcycle. And if you select the 
right images, you can then submit the form that  
05:11 - is a challenge based form submission. And this 
is version two, we won't be using version two,  
05:18 - today, we'll be using version three. Now this 
is not challenged based. Instead, Google scores  
05:25 - each spawn submission against certain criteria. 
Now, the higher the score, the higher chance it  
05:30 - is, that is a real, live human being some in the 
form and not some malicious software. So that's  
05:37 - what we'll be setting up today. And after that, we 
will then go to Google Cloud, and we'll be setting  
05:43 - up another API key that will allow us to set up by 
an enable five API's places, directions, Distance  
05:50 - Matrix, geocoding, and Maps JavaScript. So let's 
jump straight into it and set up recapture. So if  
05:56 - you look at my screen, it opens up in google.com, 
slash recapture slash about on this page, you will  
06:02 - find all the information that you need to find 
out a little bit more about recapture. But what it  
06:06 - does some use cases and also the history because 
it has evolved over the years, when on this site,  
06:13 - ensure that you've got a Google account, you will 
need one, click on the V three admin console.  
06:19 - You can see here that I've got six sites, I've 
been using this for some time, and a lot of my  
06:23 - clients like to use recapture. But whether or not 
you've got this set up on your machine already,  
06:29 - you do need to follow this process. So you need 
to click the little plus button here, which,  
06:33 - which is to create a new site. So let's create 
your site. And we will call it Google Django  
06:45 - tutorial, we will nkuku reCAPTCHA version three. 
Again, it says verify request with a score. This  
06:52 - is what we want version two verifies request with 
a challenge. So we'll click on version three. And  
06:58 - then you need to add the domain. So we're doing 
this in a development environment. So it's on my  
07:03 - local machine, and we'll be using Django. So the 
domain in this case is localhost. You don't need  
07:09 - to put the port of a spa that right now I have 
a local post. And then click Accept. And submit.  
07:22 - There we have it. So it creates a key and 
a secret key are working with API's. If  
07:29 - you've done this before, you will know but if you 
haven't, I like to look at the API keys as this.  
07:34 - an API key is the equivalent of a username. And 
API secret key is an equivalent of a password,  
07:41 - just try to keep them secret, because you don't 
want people getting hold of your keys and making  
07:46 - calls fictitiously. So there's copy the site 
key, I like to just dump these in a notepad so I  
07:51 - can use them later. I've got one open here. So we 
capture underscore key equals, and we'll paste in  
07:57 - the key back to the website. We'll copy the 
secret key. And we'll dump that here as well.  
08:08 - You can see here I've got another one called 
Google equals that's the API key we're  
08:12 - now about to set up. That is all 
we need to do to set up recapture.  
08:16 - The rest is done in the code in Python, 
or in this case, the Django web framework,  
08:22 - which we'll be setting up in the next segment. 
So we'll continue now. And we will set up the  
08:28 - Google API key that will allow us to work with 
places directions Distance Matrix geocoding,  
08:33 - and Maps JavaScript, what you need to do 
is visit the website cloud.google.com.  
08:41 - And this is the website. You will need a Google 
account. You can see I've got my icon there,  
08:47 - my logo, and setup is decoding. When set 
up on Google, you need to click on console.  
08:55 - It will take you to your console home. 
And then you need to set up a new  
09:02 - project. So if you just sit Look what I did 
there. on here, just click the pulldown list.  
09:08 - And then you can set up a new project. And 
we will call this Google Django tutorial.  
09:18 - Click Create. And then when 
it's finished doing that,  
09:23 - you can then select the new I was just doing 
it's doing its magic. only take a second.  
09:34 - Okay, that's complete. So now click 
the project that we just set up.  
09:41 - And this is the new Google Django tutorial home. 
You now need to click on API's and services.  
09:52 - When in there, you do have the option to click 
Enable API's and services. But first off,  
09:56 - we need to click on credentials we need to set up 
the API key click on click banjos. This will be an  
10:02 - empty blank slate, we now need to quit click on 
Create credentials. This will allow us to select  
10:09 - different options. But the one we want today is 
API key, click on the API key. There we have it,  
10:16 - copy the API key. And save that in the notepad. 
There we have it back to the website. Close. Now,  
10:26 - we haven't named it, we can name it by clicking 
this little pen here to edit the API key. And in  
10:32 - here, you can restrict the API key to certain IP 
addresses. Change the name, which we will this is  
10:39 - Google Django. tutorial key. And save. By the time 
you see this tutorial, This tutorial will be dead,  
10:54 - ie will be removed from Google. So there's no risk 
here. That is the key, we've set up the key now we  
10:59 - now need to enable the API's. So if we go into 
the dashboard, again, this option here, so plus,  
11:08 - enable API services there. And because maps are 
the most popular API service that Google provide,  
11:16 - it's right at the top, click on View All 17 
there's quite a few of them. The scroll down is a  
11:21 - whole bunch of different API's here. The first one 
that we need to look at is Places API. I won't go  
11:28 - through what each of them do, specifically, but 
each of these in your own time, click on them,  
11:35 - and it gives you an overview of exactly what 
they do. Now places will be using that to  
11:40 - pre populate addresses when creating an account 
in our project. So you start typing an address,  
11:47 - and it will predict what the address is that 
you're looking for. And you can just select it,  
11:52 - and it pre fills all of the address, the town, 
the city, the county and postcode, and so on  
11:56 - and so forth. And you can always pull from that 
the longitude and latitude, which is very, very  
12:01 - helpful. So let's click Enable. That will take a 
second. And now that that's completed and enabled,  
12:10 - we now need to look for the Directions API. So 
you can go back to the overview and click on  
12:16 - enable API's and go back to the main dashboard. 
But because we've enabled one now, it then gives  
12:20 - you some options of other API's that you can 
work with. So let's look look at Directions API.  
12:32 - click enable these next API, so the 
directions the distance, the geocoding,  
12:39 - and the maps, JavaScript, these are 
the API's that we're going to use when  
12:43 - working out different routes and 
distances between two geo points,  
12:48 - so to longitude and latitudes. So that is the 
Directions API, we now need the distance matrix.  
12:56 - We'll enable that quickly. Some of them 
are quite self explanatory, to be fair.  
13:02 - The next one is Google geocoding. Well, lo and 
behold, that allows us to geocode certain points.  
13:09 - So geocoding API will enable this. Lastly, 
we need to find the Maps JavaScript API,  
13:16 - and enable that. And that will allow us to 
write some JavaScript to actually make the calls  
13:20 - themselves because we won't be making API calls 
from Django, the calls themselves will be handled  
13:25 - in JavaScript. So let's click the Maps JavaScript 
API. Enable. There we have it. So just to recap,  
13:38 - In this segment, we have created two API keys. One 
of them is with google recaptcha version three,  
13:46 - this will allow us to ensure that real human 
beings are submitting forms on our project  
13:53 - and stop the riffraff from submitting those forms. 
And then we've created another API on Google Cloud  
13:59 - and enabled Google Places Google directions Google 
Distance Matrix, Google geocoding, and Google Maps  
14:05 - JavaScript API's. This will allow us to have our 
users complete or start typing their address,  
14:13 - and it will predict where they live and they 
can select an address. And also they can then  
14:17 - add two different points. So two locations in 
any given country, and our project will then  
14:25 - calculate the route and distance between those 
points. Okay, that's the end of this segment.  
14:31 - Thanks for watching. That starts setting up the 
project in the next segment. Thank you. Bye, bye.  
14:42 - Hey, everyone, it's Bobby from 
decoded here. And in this segment,  
14:45 - I'm going to show you everything that you need 
to do to start building this Google API app.  
14:50 - So we will be using a Python web framework called 
Django and we'll be working through how to start a  
14:56 - new project how to create an app, how to configure 
Get some settings and static files such as CSS,  
15:03 - JavaScript and images, and also playing around 
with the URL comp. Now, if you're familiar with  
15:10 - Django, you will know what that all means. 
However, if you are an absolute newbie,  
15:14 - I will just show you quickly, a little bit about 
Python and Django, and a library that we'll be  
15:21 - using, which is virtual MV wrapper dash when in 
my case, because I'm using a Windows machine,  
15:28 - so if you look on my screen, I've got the 
Python website open on their downloads page.  
15:34 - If you haven't got Python downloaded on your 
machine, you will need to do it, I do have a link  
15:40 - to a video there's at the top of the screen now 
that will show you exactly what you've got to do  
15:44 - to install Python and also configure a library 
called Virtual envy wrapper. And that is this page  
15:54 - here. So it is on a repository in pyp.org. Like I 
say, look at the video, walk through all of those  
16:00 - steps, get Python installed on your machine, get 
virtually a V wrapper installed on your machine,  
16:04 - and you'll be good to go. The third tab here is 
the Django project.com website. So this is Django  
16:12 - web framework. So it says here that Django makes 
it easy to build web applications more quickly  
16:16 - with less code, that is exactly what it does. And 
that is what attracted me to Django about five or  
16:22 - six years ago, I've been using it for quite some 
time, it's easy to learn the documentation is  
16:28 - absolutely fantastic. And they've got quite a good 
tutorial on the actual website we need to do is  
16:33 - click on the Get Started with Django, link here, 
and away you go. But that's what we'll be using in  
16:39 - today's segment to get started. So what we'll do, 
we'll start off by opening up a command prompt.  
16:49 - And if you've already set up virtually a and 
V wrapper, then you can start using certain  
16:55 - commands. That's why I asked you to follow that 
video. Because if you hadn't set up virtually a V  
17:02 - wrapper, then you wouldn't be able to use the 
same commands that I'm going to use today.  
17:06 - So what I'll do straightaway, I will 
CD into my development directory.  
17:12 - And what I would do is I set up a new 
virtual E and V. And the way you do that is  
17:19 - MK virtual e m v. And then with a space, you 
then name this E and V. So we'll call this  
17:29 - the same as the project. So we'll 
go did Django Google API tutorial.  
17:42 - Okay, click Enter. And that will outdo all of 
the necessary configuration on your machine.  
17:46 - And it will set up a virtual E and V. 
So what I'll do, I'll show you quickly  
17:51 - was that that has just done. So if I click 
on my directories here, we go into my own.  
17:58 - So if we're going to Bobby, which this is 
the default configuration that will set  
18:01 - up an E and V file in your user directory. 
So you can see here that I've got envies,  
18:07 - and I've just set up did Django Google API 
tutorial. If I open that open lib site packages,  
18:14 - these are all of the site packages that we Python 
will need to work. So these just come straight out  
18:23 - of the box. So when you set up a virtual E and V, 
this is what you get. We will then be installing  
18:29 - Django and a few other libraries and they just 
get added every time we pip install a library.  
18:34 - It gets added into our virtual E and V. So that's 
what we've just done by adding by using make  
18:40 - virtual E and V. Go back into our command prompt. 
And what will now do is we will pip install Django  
18:57 - for plus enter was asked, so I probably glossed 
over that what but the command PIP is essentially  
19:04 - as a standard package manager, and allows you 
to install and maintain packages for Python. So  
19:09 - we use pip install to install certain packages 
from public repository such as p ypi. And I've  
19:16 - just pip install Django. If I go back into my 
envy directory that I've shown you a moment ago,  
19:21 - you can see now that we've got Django 
package here, and within Django, it comes  
19:25 - straight out of the box, it comes with a whole 
bunch of different directories, and models and  
19:31 - views and all sorts and that is essentially how 
Django works. So we'll be making calls, creating  
19:36 - models, creating views and forms. And it all 
interacts with these directories and files here.  
19:43 - So we've now got a virtual environment 
all configured and Django installed,  
19:47 - we can now start a new project. So you need 
to type Django dash admin, and then call start  
19:56 - project and then you need to name the project. 
So we'll call it exactly this. Same as the  
20:01 - development environment or virtual 
environment sorry, did Django  
20:08 - Google API tutorial? Okay, that should have 
done it. So if I open up my directory again,  
20:20 - there we go Bobby development. And in here 
we've got did Django Google API tutorial,  
20:24 - open that up. And this is what comes straight 
out of the box, we've got a manage.py  
20:29 - file. And then we've got the main comp 
directory here, enable settings URLs,  
20:35 - you got ASCII or whiskey and you've got an init, 
Dunder init file there. So that worked very,  
20:40 - very well, we now need to create our first app. So 
Django will allow us to have numerous apps running  
20:48 - within a project. So what we need to do is open 
our command prompt back up, and we now need to  
20:56 - CD into did Jango. Google API tutorial. 
And now that we've got the project there,  
21:09 - we can now access the manage.py file. And that 
is the manage.py file that is in a main project  
21:17 - here. So we make a call to 
manage dot p y. So we say Python,  
21:27 - manage dot p y start app. And we'll call this one 
main. Okay, great. I opened up my directory again,  
21:36 - we now have an app in here called main. And 
straight out of the box, it comes with a few  
21:41 - files. So you have an empty migrations directory. 
That is what's used when we're creating models.  
21:48 - And you migrate those models to a database, 
we've got an admin file an X file, we've got  
21:55 - models file, this is where you house all 
the models for the project, tests and views,  
22:00 - we will we'll create one or two other files, 
but this is what comes straight out of the box.  
22:06 - We're now at the point where we're gonna start 
writing some code. To do that, we will need  
22:10 - a text editor, I use Sublime Text. But there's 
so many different text editors out there,  
22:16 - use the one that you like the best, and 
then you can start coding. So what we'll do,  
22:22 - we will open up Sublime Text in our directory that 
we just created did Django Google API tutorial.  
22:28 - So there we have it. This is the project 
in Sublime Text, you can see we've got our  
22:32 - manage.py file here, we've got the main project 
directory, which we can open up and you can have  
22:37 - a look at these files. And then we've got the main 
app that we've got here, we will be focusing our  
22:42 - time in settings dot p y, and you are ELLs 
dot p y today, which is the URL comp file.  
22:48 - So we'll open up the settings dot p y, first and 
foremost. And if I scroll down, you've got whole  
22:54 - bunch of code here that comes straight out of 
the box of Django, this is very, very standard.  
22:59 - We do however, need to change some of this code. 
And that's what we're going to do right now. So at  
23:06 - the top of the settings.py file, here, you have 
from path lib import path that is required. But  
23:12 - we also need another import. This is import 
OS for operating system. This library allows  
23:19 - us to access things like environment variables, 
okay, and we'll scroll down a little bit further.  
23:26 - If this if we were building this in a production 
environment or for a production app, then I would  
23:31 - do something with a secret key here, I would 
use libraries such as Django decoupled to remove  
23:36 - sensitive information from the project. But as we 
are not doing anything like that, and this is just  
23:40 - a tutorial, I will just leave that as it is. So 
if you scroll down further, again, we've allowed  
23:45 - hosts that is something more for production. 
You've then got installed apps. Now these are  
23:49 - the installed apps that come straight out of the 
box. But we have created an app here called may  
23:57 - have you look in apps, the name of this is main. 
Okay, so that's what we need to reference in  
24:03 - settings dot p y. So if we enter a couple of 
times, just add a little bit of whitespace.  
24:10 - Just add a string called main, and then a comma, 
a trailing comma. So that is selling Django  
24:16 - that the app that we've just created is actually 
included in the project. Then if you scroll down  
24:23 - a little bit further, we've got middleware. 
We won't be playing with that here. But  
24:28 - there are some libraries that we require or other 
applications require. And they do need you to have  
24:34 - some middleware alterations. Routes URL comp, 
don't need to change that templates. We won't  
24:40 - be changing that whiskey application, no change, 
no change with database either. Now, if I was to  
24:47 - make this app for a production application, I 
would probably use database such as PostgreSQL.  
24:55 - But we would just be using the database 
that comes straight out of the box is no  
24:59 - harm in that So, language code, it defaults 
to en us, I am in Great Britain, so en GB.  
25:06 - And then at the bottom here we've got 
a variable here called static URL.  
25:11 - Now we will be creating this app and it will 
be looking fantastic. To do that, we need to be  
25:20 - using files such as Cascading Style Sheets, or 
CSS and Java scripts or j s files, and also images  
25:27 - such as logos and things like that. So we do need 
to configure static files in the settings dot p y.  
25:35 - And how we do that is we add a variable called 
static files underscore does. This is a list.  
25:47 - And in here, we have we call the OS library 
that we just imported. path, which was also  
25:55 - important at the top of the page. And then 
we joined, and we joined the base directory.  
26:04 - And we call it static. That is the only change 
we need to add here for static files does  
26:10 - the static URL remains the same, but we 
also need one in here called static route.  
26:20 - There we go. And this is OS dot path,  
26:25 - dot join dot, then bracket and then this is 
again based Dir. But this one is static. CDN.  
26:39 - Okay, they are the only changes we need to make to 
Settings dot p y in regards to static files. You  
26:45 - need these variables for it to work and serve CSS 
and JavaScript files to the project to the front  
26:50 - end, I won't do any more of a deeper dive than 
that. We do now need three more variables. The  
26:56 - first one will be called Google API key. have that 
as an empty string for now we need re recapture.  
27:09 - Cool, that recapture key again, empty, and 
we'll have recapture cool, his secret key  
27:23 - secret saved with a secret key. There we go. And 
what I'll do, I'll open up the notes that I made  
27:29 - in the last segment. And we need our it looks like 
I didn't say the secret key. But we will get that.  
27:41 - We'll save that now. This was the Google API key.  
27:51 - There we have it. And the secret 
key I'll have to get from recapture  
27:55 - in a couple of moments. In 
fact, let's do that now.  
28:06 - Capture. One of the sites that we were 
doing was this one here, Google Django.  
28:13 - And I believe we're going to settings keys 
that we have. Okay, we copy the secret key.  
28:24 - Go back into our project. And we save that 
and recapture secret key. There we go. That  
28:30 - is settings dot p y file complete, we don't 
need to do any more configuration in there.  
28:36 - The next change is in URLs dot p y. And what 
we need to do in this file is we need to  
28:46 - have the path we need to bring it 
include we need from django.com.  
28:53 - Now when I'm referencing Django directories, I'm 
quite literally referencing them in the MV file.  
29:01 - So go back in here, lib site packages. Remember 
when we were setting up the virtual environment,  
29:07 - if we now go into Django, and in the project 
here, Django dot URLs. We go into Django and  
29:17 - go into URLs. We're referencing these files 
here and functions and classes within these  
29:24 - files. That is exactly what we're doing. That's 
how we're importing them into the project. Okay.  
29:29 - So from django.com import settings. So we're now 
importing, amongst other things, everything that  
29:37 - we've got in this file here. Then from Django, 
dot content, dot URLs dot static, import, static  
29:53 - that looks right. Okay, so we need Django 
comes with admin. And I've been paid already  
30:01 - straight out the box. But we do need to add a 
another path here. And that will be to our main  
30:08 - app URLs that we haven't added that file yet, 
but we will reference it now. So is path.  
30:17 - And what we need to do is use that 
include that we've just imported.  
30:22 - And its main, and we'll have a 
file in that main app called URLs.  
30:30 - And then we'll use namespace 
equals, this will be called main.  
30:38 - Wonderful, they're the URL patterns that we 
need. We also need one other setting in here  
30:43 - for the static files. And 
what we do is if settings dot  
30:49 - debug, we're referencing debug, which is 
in settings.py, at the top, so it defaults  
30:55 - to true. So when when in development, when debug 
is true, when you have a problem with your code,  
31:00 - or come up with the error on the screen, 
which is very handy, but you don't have this,  
31:07 - you would not have debug set as true in 
production. So if it is set to true, which  
31:12 - it currently is that we need to add to the URL 
patterns. And how you do that is URL add equals  
31:21 - static, that is the library that we've 
got here. And then we want settings  
31:28 - dot static URL. And then we want document route.  
31:38 - Equals settings dot static route. And that 
is it. So the settings dot static URL,  
31:50 - that's what we set up in the settings.py file. So 
the static URL, and the static route is also this  
31:56 - one here that we set up as well. So we have now 
set up the settings dot p y, and the URLs comp  
32:04 - file correctly. And that should now work. One 
last thing before we close off this segment.  
32:11 - And that is the we're referencing a URL file 
that is not there. So if we go into main,  
32:18 - new file, and we'll call this you are ours dot  
32:24 - p y, we will create the necessary list that is 
required for URL convert. So we'll say from Django  
32:39 - dot URLs, import path from Dart, so this will 
be referencing a views file, which is here.  
32:52 - Import views, so we'll be 
importing everything from views.  
32:57 - app name. So this is what we called 
the app as a namespace in the URL comp,  
33:05 - main. And then we want you are l patterns 
equals, and that's an empty list. We will  
33:14 - add to that in another section. Okay, so just 
a recap on what we've gone through today.  
33:21 - We have set up a new Django project, we've created 
a new app, we have adjusted the settings.py file,  
33:28 - we've configured static files in the settings and 
URL Comm. And we then added the URL patterns in  
33:35 - the URL conf as well. So we are now good to go. 
We are ready to start coding this application.  
33:41 - And we'll be doing that in the next segment. 
So thanks for watching. See you soon. Bye.  
33:53 - Everyone is published and decoded here. 
And in this section we'll be following  
33:56 - on where we left off from the last one where we 
started a new Django project. In this section,  
34:00 - we will be fleshing out the back end. What I 
mean by that is we'll be creating some models,  
34:04 - or one model, actually, you know, we use 
a profile model that extends the built in  
34:09 - user model that comes straight out of the box of 
Django. The reason we're doing this is because  
34:12 - we want our users to have the ability to sign up 
and sign in and create your profile. This is how  
34:18 - we will be using the recapture API and the Google 
Places API. Okay, we'll also be creating some form  
34:25 - some views and URLs and some mix ins for views. 
those meetings will essentially help us make  
34:31 - our code look a little bit easier to read. And 
those mixings will be recyclable. We can use them  
34:36 - in other apps as well which is great. And then 
we'll also be creating the template directories  
34:41 - so this will be regarded as the back end. In the 
next section, we'll be looking at the front end  
34:46 - which is all about HTML files, CSS, Cascading 
Style Sheets, and JavaScript. So without further  
34:52 - ado, let's jump straight into it. You can see on 
my screen here that I've got four tabs open all  
34:58 - of them on Doc's dot Django calm dot com. Like I 
said in the last section, the Django documentation  
35:03 - is second to none. And I wanted to just go through 
this quickly because we are working with models,  
35:08 - we're working with signals, model forms and 
views. So for those that are absolutely,  
35:14 - well, they're newbies at Django, this is going to 
be quite helpful. So what is a model, a model is a  
35:19 - single definitive source of information about 
your data contains the essential fields and  
35:23 - behaviors of the data you're storing. Generally, 
each model maps to a single database table. So  
35:28 - models translate to database tables. Like I 
said, in the last video, we'll be using SQL lite,  
35:36 - that comes straight out of the box of Django, 
you can upgrade to something like PostgreSQL. But  
35:40 - we're not in this app. So when we're building our 
user profile model, we'll be using things called  
35:45 - model fields. And the most important one, we'll be 
using char fields and float fields and things like  
35:50 - that. But the most important one that we're using 
is the one to one field, which links the user  
35:55 - profile to the built in user model, which comes 
straight out of the box with Django. And we'll be  
36:01 - creating the user profile using signals. So that's 
models, very, very quick top down view models.  
36:08 - And by all means, have a good read of these docs 
pages when you have a bit more time signals. So  
36:15 - we'll be creating a signals.py file. This will 
be handling the logic of creating the user  
36:21 - profile when a user is created. So we'll be using 
post save and receive a decorator. To do that.  
36:28 - I'll show you what that all means when we get 
into it. Next, we've got model forms. So we  
36:33 - are creating model form. So this will be a model 
form linked directly to the user profile model.  
36:40 - We will also be creating two other forms these 
forms will inherit from some built in class forms  
36:47 - that Django has straight out the box, one of 
them is a user creation form. And the other one  
36:51 - is an authentication form. These forms handle the 
logic of signing up and signing in perfectly. So  
36:59 - it just means that we haven't got to handle all 
of that logic, we can just call form dot save.  
37:05 - And it does all of that in the background, which 
is great. Django is all about getting as much  
37:10 - output with as little input as possible. So if 
we can get away with using some built in models  
37:16 - and classes and forms and things like that, 
we will. So yeah, like I say, we'll be using  
37:20 - the user creation form to build a user form. And 
we'll be using the authentication form to build an  
37:25 - auth form. And then we'll be looking at view. So 
we'll be creating class based views and function  
37:32 - based views, I do find that some tutorials online 
focus on one or the other. And when you're new to  
37:36 - Django can be quite confusing, especially 
if you've been focusing your attention on  
37:40 - function based views. class based views then look 
a little bit alien. So I'm doing a bit of both in  
37:45 - this tutorial, just to help you new newbies 
out there. So let's jump straight into it.  
37:50 - You can see that is that is where we left off. 
Yeah. Okay. So if we open up our command prompt,  
37:54 - you can see that I've got my virtual environment 
fired up, and I'm in the correct file.  
38:01 - Now, we will be working with API's. As you 
know, that's the whole point in this tutorial.  
38:06 - And in Django, there's a great library called 
requests that help us out massively with API  
38:11 - calls. So all you need to do to install it is 
use the PIP command. So pip install requests.  
38:20 - Great. And that will now be in our E and V file 
that I showed you two videos ago. Now what we  
38:25 - need to do is start a new app. So we go Python 
manage.py start app, and we'll call this users.  
38:36 - That's great. If I now look in Sublime 
Text, you should now see a user's directory,  
38:41 - which is great. It's pretty much blank, 
but we'll start fleshing out in a second.  
38:46 - So the first thing we need to do when we start a 
new app is going to set this dot p y and register  
38:50 - that app in the installed apps. So users training 
comm comma, and there are a few other variables  
38:58 - that we need in settings dot p y that I forgot 
about in the last section. So we'll do that now.  
39:05 - I will be copying a lot of code from my 
other screen in this section, because  
39:10 - it will save a lot of time it will make for 
a much shorter section and I will hopefully  
39:16 - be able to hold your attention for a little bit 
longer. So as we are using sign up, sign out,  
39:23 - sign up sign in and sign out logic, we will add 
some variables in settings dot p y is a login URL.  
39:30 - So this is where users will sign in. So we haven't 
created this URL yet. But we will in this section,  
39:36 - we've got a login redirect URL, which is 
account, this will act as the home page. Now,  
39:43 - there will be a decorator. So a login 
required decorator on that view.  
39:47 - So when somebody visits the homepage or index 
page, it will redirect them to this sign in page.  
39:54 - But that works for this app. So I've kept in 
here. And lastly, we've got a logout redirect.  
39:58 - So when somebody signs up it redirects that 
user to sign in. So they're the three variables  
40:04 - that we need in settings, dot p y. And there's 
one last variable before we move on to the URL  
40:08 - comp, and its base country. So the 
JavaScript that I've got in his project  
40:14 - uses a country code. And it uses that code when 
predicting addresses for the Places API. So you  
40:22 - can change that to something like fr for France, 
and other country codes. But it just means that  
40:28 - we can change it in the settings without having 
to change it in the JavaScript. So now we need  
40:32 - to go to the URL comp file and add users to 
the URL pattern. So we'll do that quickly.  
40:40 - Just copy it down, there's no need to always 
type it from scratch, or though it does help  
40:45 - when learning Django. But my typing is terrible. 
So I tend to litter this, these apps with typos  
40:54 - and it causes a whole range of issues. So that 
is all we need to add into the URL comp file  
40:59 - that's saved. So it's setting so we're close 
those. And now what we need to do is go into  
41:07 - main URLs, and what what 
they will copy this across  
41:12 - to users into a new file, we'll 
change the app name to users.  
41:18 - And we'll save this as URLs dot p y, 
because we're referencing that in URL comp,  
41:28 - p y. There we have it. Okay, so now we're good 
to go, we are good to start the models now.  
41:34 - So we are not creating any models in Maine, 
Maine is going to be used for a few views,  
41:40 - such as routes and map. And users will be 
handling all of the authentication logic.  
41:45 - So we'll add the models in here. So if I just take 
my code, and I will copy and I'll quite literally  
41:52 - dump it in here, and then walk you through 
what I'm doing. So the from django.db import  
41:58 - models that come straight out of the box, and then 
we're installed. So we were importing user, which  
42:03 - is the built in user model that I keep talking 
about. So you will get used to right in there.  
42:07 - So Django dot contrib dot auth dot models import 
user, I normally have that in every one of my  
42:14 - views. So so you get used to write that 
quite a lot. We then have the user profile,  
42:19 - which is a class and any password models dot 
model. In my models, I generally have a timestamp  
42:26 - and an updated this allows me to track when a 
model has been created. So we use the auto add  
42:31 - also in auto now add equals true. And the updated 
is also now so every time a profile is created,  
42:39 - this will capture the date time. And every time 
a profile is updated, it will also create the  
42:47 - it will keep updating this field with the new 
date time when it was when it was updated,  
42:53 - then what user This is the important and this is 
the one to one field that I was talking about,  
42:57 - you pass through the user model. And then you 
also have underlay equals models dot cascade,  
43:03 - I move this across it, you can read everything. 
So that means if the user was deleted,  
43:08 - then this user profile would subsequently be 
deleted as well. So there's no profile in the  
43:13 - database that isn't linked to an actual user, 
you can also have something like set null in  
43:18 - there. So if the user was deleted, this would 
still be in the database, but it would be null.  
43:23 - Next, whole bunch of char fields. With left, these 
are these will be created as nouns analogous to  
43:30 - blank users equals true because users will add an 
address once they've signed up. So we have a char  
43:36 - field for address, Max length 100, you have to 
have that in there a max length keyword, because  
43:44 - otherwise it just won't work. And we have town 
County, postcode, country longitude and latitude.  
43:50 - They're all populated when a form is submitted 
from the front end, which we will be looking  
43:55 - at shortly. Capture score that is the recapture 
score. So when it for me, when somebody signs up,  
44:02 - we will be using the recapture API to 
score the submission, the higher the score,  
44:08 - the more likely it is that is a real human 
being that score is pass through and save  
44:13 - to this field as a float field. The highest 
you can get is 1.0. So it defaults to 0.0  
44:19 - has profile is a Boolean field. So it's a simple 
true false, it defaults to false. So when a user  
44:26 - signs up, they do not have a profile when they 
add an address and longitude and latitude.  
44:31 - This will then be changed to true. 
Lastly, we have an inactive Boolean.  
44:36 - I always have this in my models is defaults 
to true but we it gives you the option to  
44:40 - change this to false If ever you want to close a 
model down. And lastly, we've got a Dunder string  
44:45 - function, pass resell from was returning an 
F string self dot user. Okay, so that is the  
44:50 - model. Like I say that translates straight to the 
database. So when we make migrations and migrate,  
44:56 - that will become a database table. So that's our 
model. We now need to create some forms. So if I  
45:03 - click add new file, and save as, 
and we'll call this forms dot p y.  
45:11 - There we have it. So we've got three forms a 
user form, an off form, and a user profile form.  
45:17 - So we're important a few bits and pieces here, 
let me make it a bit easier for you to see.  
45:20 - So we're importing model form, like 
I say, we've got a couple of built in  
45:25 - class forms that, that come straight out of the 
box user creation form and authentication form.  
45:30 - Again, we're importing the built in user model, 
and then we're importing form from Django, and  
45:35 - lastly, the user profile for models that we just 
created. So that's all we need in this file, we've  
45:40 - then got the first user form, this is inheriting 
the user creation form. Okay. So you what you need  
45:47 - to do is create a few variables. So first name 
is forms, character fields. So as a char field,  
45:54 - Max length 30. This is exactly what the field 
is like in the built in user model. In fact,  
46:02 - then we start with the user profile form, it might 
make a little bit more sense. So this is just a  
46:08 - model form, but they're more or less exactly 
the same. So address, you can see here, this  
46:13 - address is relates directly to the user profile 
address field. And again, it's a character field,  
46:19 - which is the same as in the model, the max length 
is 100, that matches what the max length is in the  
46:24 - model. So we tried to keep model forms identical 
to what they would be in the model themselves,  
46:30 - we've got required true, so this field must 
be completed for the form to be submitted.  
46:35 - And then we use visit a socket widget equals 
form. And this is going to be a hidden input.  
46:40 - So the widget in a model form that kind of 
translates through to HTML elements. So this  
46:47 - will create an hidden input element, and it 
will be rendered through on the HTML file.  
46:54 - So you could also have text input, you could have 
password input, or you could have a whole range of  
47:01 - different things. And you can also pass through 
things like classes, and placeholders and things  
47:06 - like that. And that's how we can change the way 
the form looks on the front end. Because a very,  
47:11 - very basic form from Django doesn't look too good 
unless you actually add some bits and pieces,  
47:16 - such as classes and IDs and names and then add 
some CSS. So this is the user profile form,  
47:22 - aka says a model form, we've got address, town, 
county, postcode, country, longitude and latitude,  
47:27 - they will be the input elements that 
will actually be hidden on the HTML file,  
47:31 - then we've got class matter, the model that we're 
linking this to is user profile, and then we have  
47:35 - a tuple in fields with all of the field names. 
Okay, so that's the user profile. So I'll start  
47:41 - there. And then it will let make a little bit 
more sense when we look at uniform. So like I say,  
47:45 - inherits from the user creation form. So the 
first name very much like the user profile form,  
47:51 - we're using a char field max length is 30. Because 
the built in user model, first name field has a  
47:57 - max length of 30. Again, rich required True, and 
in this widget is a text input, and we're passing  
48:05 - through as an attribute placeholder is your first 
name, we're doing the same for last name, except  
48:10 - we're changing the placeholder, the username is 
actually an email field in this case, so when  
48:14 - somebody signs up, the username is an email rather 
than just a normal username. And then we've got  
48:20 - password one and password two. So in this, you can 
see we're actually we're passing through a class  
48:26 - as well to the attributes as because we can then 
toggle between a password input and a text input.  
48:33 - So there we have it, we are then adding a 
token field. So this for the reCAPTCHA token,  
48:39 - it will be a hidden input, but that will be 
capturing the token when we're processing the  
48:43 - form using reCAPTCHA. version three, then we've 
got meta class models, user and fields are,  
48:49 - as you can see, here, they're the same as what 
we've got above, then we've got your form,  
48:54 - your form is a little bit shorter with a username 
and password, email field, which we have a text  
48:59 - input and a char field with a password input. And 
again, by inheriting from the authentication form,  
49:06 - that means that when we call form dot save, it 
does all of the logic in the background, which  
49:12 - is fantastic. So these are all forms, we don't 
need to mess around with them anymore. That is,  
49:16 - that is it for this project. We don't need any 
more forms than that Figes, open that up there.  
49:24 - The next thing we need to do really is create the 
mix ins. So let's go ahead and do that. And we'll  
49:28 - add them to the main directory to a new 
file. And we'll save that as mixings dot p y.  
49:39 - Again, I'll bring it straight from my other 
screen here. And paste. Okay, there's some pretty  
49:49 - one of these is called directions is a function 
that we're going to be using to make API calls. So  
49:54 - these are quite important. So we'll 
go through these we're bringing few  
49:58 - through a few things are From Django, one of 
them is a well from the EU, this is from URL lib  
50:04 - dot pass where important URL encode this is for a 
redirect function of God, which I'll go for in a  
50:11 - second. But you can see we're importing requests, 
because we'll be making an API call. And as a few  
50:16 - other bits got Jason daytime got format, timespan 
for the Directions API, and also JSON response,  
50:23 - because we're making a mixin. For Ajax. So this is 
the form errors. function. Now I use this kind of  
50:30 - default that I use when I'm processing forms. 
So if I ever overwrite the form valid method  
50:36 - there, and if there's an error, then we call the 
form errors. And it essentially returns a string  
50:42 - of all of the errors that you can pass through 
to the front end, which is quite handy with Ajax.  
50:46 - The next one is a function called reCAPTCHA. 
validation. And we pass through the token,  
50:51 - this is the API call to recapture. So the token 
is passed through from the front end in the view.  
50:59 - And we create a variable called results. And we're 
doing a POST request to this URL. Okay, so it's  
51:08 - google.com reCAPTCHA, API site verify. And then we 
create a data dictionary. And in that dictionary,  
51:15 - we pass through the secret as a keyword. And this 
is the recapture private key that we've got in our  
51:20 - settings. And also the response, we pass through 
a token. That is the API call is very, very easy.  
51:26 - And then we return result dot Jason. So we just 
saw notify the response. And that's what we use  
51:32 - when we're creating views and a few minutes. 
This is a great function. So what this does,  
51:37 - it uses the URL in code. But if you pass through 
parameters, and the URL to this function,  
51:44 - essentially returns a string that can be appended 
to a URL, and the string will look something like  
51:52 - color equals blue. And size equals large, 
okay, and that that parameter string can go,  
52:03 - you can have a whole range of different 
parameters in there. But it just means it can  
52:06 - be appended to a URL, and then when redirected 
to that URL, you can do something with those  
52:11 - parameters using request dot get dot get. And we 
are actually using that in this app. So that's a  
52:18 - great little function that we use. So this is 
the AJAX for mixin have gotten this is kind of  
52:25 - the default mixing that we use, although I do 
overwrite the form valid function quite a lot.  
52:31 - But I've written this for AJAX call, so we can 
Ajax or five form submissions. This means that  
52:38 - on a front end, the HTML doesn't need to reload. 
So you submit the form, you get the response,  
52:44 - and then do something with it. And you can change 
bits and pieces using JavaScript. So I've got this  
52:49 - as a way of Ajax of fire in Django forms. So we've 
got form invalid method, and we've got form valid.  
52:56 - And both of them are returning JSON responses 
to the views that we will be using it.  
53:02 - Lastly, we've got the directions function, 
passing through arcs and keyword arguments.  
53:08 - Then we've got a whole bunch of variables 
here. So from the keywords, we're getting lat,  
53:12 - a long a and a whole bunch of other longitude 
and latitudes. So lat a and long a, that's our  
53:18 - origin. So that's where we start in terms of 
waypoints. B is where we end up so this is our  
53:26 - destination. And then we've got C and D. These 
are the waypoints now I've limited this to two  
53:33 - waypoints. So in total, you've got four different 
destinations. But there's no reason why you can't  
53:37 - have more, just in this app, we've got two. So 
we've got a start two waypoints and a destination.  
53:44 - And these three variables are using f string 
to create strings from these variables here.  
53:52 - So that origin will look something like five 7.17 
4.6. Yeah, that would be the string for origin.  
54:04 - Okay, same with destination. But with waypoint, 
you can see we're connecting with a bar,  
54:10 - then we are using requests dot get. So this 
is a get request. And we're saving this in a  
54:16 - results variable. So we're making a get request to 
this URL. And then we're passing for a parameter  
54:22 - dictionary. We pass through origin, password 
destination, and the waypoints. And then lastly,  
54:28 - the key. So this is the Google API key that we 
looked at in the first section. Okay, directions,  
54:34 - this is just trying to find the results and saving 
it in a new variable. If directions has a status  
54:41 - of Okay, then we work through this logic here. 
And then we would turn all of this so it returns  
54:48 - origin so the origin is actually outside of the 
if statement there. So it returns them regardless.  
54:54 - So if it's okay, we look for the roots and legs 
keywords in the Jason file. We won't go through  
55:00 - that yet. But during this, one of the sections, I 
might show you what the JSON response looks like.  
55:06 - Then we, we stipulate a distance, a duration 
and a route list here. And then we cycle through  
55:13 - all of the legs. And we keep adding and adding and 
adding the distance, the same duration. And that's  
55:18 - what we're passing through to return statement 
here, the duration here, you can see actually,  
55:23 - that we're using format timespan to reformat 
the duration into something we can actually do  
55:28 - something with. Okay, so that is all they are all 
of the mixings. We don't need to look at them in  
55:36 - any more detail, but we will be using them in 
the views. So if we go back to users in views,  
55:43 - if I now copy all of my views. So we've 
got a few views here, let me minimize them  
55:53 - to make it a little bit easier on the eye. Like I 
say, I've got some class based views. And I've got  
55:58 - some function based views. These are class based 
views. This is inheriting from template view,  
56:03 - you've got sign up view is also a class based 
view. And we're using form view with the AJAX  
56:07 - mixin. Same as sign in, sign out, that's just 
a function based view, and so is profile view.  
56:12 - So it's right mixed bag really. And hopefully, 
you can understand the different logic. We're  
56:18 - bringing in a whole bunch of bits and pieces from 
Django. So we've got render redirect, reverse,  
56:23 - we are using the login required decorator. So 
that stops people that haven't been authenticated  
56:28 - from seeing certain things in views, import 
bringing in user the built in user model.  
56:33 - We're then using login, logout on authenticate, 
these are fantastic. They does all of the  
56:39 - heavy lifting with the authentication 
of users. We're bringing in settings,  
56:43 - settings, JSON response. And then these are the 
built in generic views. We've got form view,  
56:49 - template view. And lastly, because we're using 
login required on a class based view, we need to  
56:54 - bring in method decorator, we're then bringing in 
that's the wrong name that needs to be tutorial.  
57:02 - We're now then bringing in the mix ins 
that we just built, and forms. Okay,  
57:07 - so let's start quickly with account view. 
This is the home view that it will be.  
57:12 - And it's inheriting from the template view. So 
this is a template class view, we need to call  
57:18 - the template name or create template name 
variable and stipulate exactly where this  
57:23 - what the where we're going to render this 
view. And this is going to be in the users  
57:29 - account that HTML, we haven't created that 
HTML file yet, but we will in the next  
57:33 - video. Then as the next segment, then what 
we're doing we're overriding the dispatch method  
57:40 - using the method decorator and passing through 
login required. So this by this little piece here,  
57:47 - the three lines of code here, what that will 
do that will stop anyone that hasn't been  
57:50 - authenticated from seeing this view. And if they 
haven't been authenticated, because we've got  
57:58 - this in view settings.py. So 
we've got log, login redirect URL,  
58:04 - sorry, the login URL, it will be read, 
the user will be redirected to this URL.  
58:11 - So if somebody goes to account and they're not 
signed in, they will be redirected to sign in when  
58:16 - they sign in, and it works, they'll be redirected 
back to account. Okay, so that's how that works.  
58:20 - So that's the account view. We then got profile 
view, which is function based view, what we're  
58:26 - doing, we're creating a couple of variables, 
we got user and user profile from request.  
58:30 - The form is the user profile form, and 
we password instance equals user profile.  
58:36 - These two here, I will remove and I'll add at the 
top of the screen, so they're kind of global. And  
58:43 - we'll make that capital. So these are the default 
messages and results because we're Ajax refine the  
58:49 - forms. So this will be password, if ever, there's 
an error, and that will be shown on a front end.  
58:54 - So as we use an Ajax to submit the form, we've 
got f request.is. ajax, then we do something else.  
59:02 - It's a get request. And then we pass through 
context, a context dictionary. So we've got form,  
59:07 - which is a user profile form. And then we add a 
couple of key words. The first one is Google API  
59:12 - key, and the second one is based country from 
settings, okay. And then we return render the  
59:18 - profile HTML file, and we pass through the context 
dictionary. That's how you pass the context in a  
59:24 - function based view, slightly different in a class 
based view, but I'll come on to that in a second.  
59:29 - But if it is Ajax, then the form is user 
profile form, and the data equals the post  
59:36 - data from the request. And the instance is user 
profile. If the form is valid, you save the form.  
59:42 - And remember, when I said we were going to add 
when we add a profile, we then toggle the Hasbro  
59:50 - profile field to true. So that's what we're 
doing there. So once we've added the address  
59:54 - and longitude latitude, we then save has profile 
is true, and we save the object again, we pass  
59:59 - through Success, the message is your profile has 
been updated. If elsif is not valid, we call the  
60:05 - form error function that we created a moment ago. 
Then we create a data dictionary result equals  
60:12 - result and message keyword is message, we pass it 
through back to the front end as a JSON response,  
60:17 - passing through the data whistlestop tour of the 
profile view, but that that is essentially how we  
60:25 - are handled in the setting up of a profile against 
an account. Then we've got a sign up view. Look,  
60:36 - we've got Ajax mixing, let me just bring this 
across a little bit, but the AJAX mixin. And  
60:41 - we've also got the form view. So as a form view, 
you need to say what the template is that we need  
60:45 - to render to, which is a sign up HTML. The form 
class is the user form that we built a moment ago,  
60:50 - and a success URL can just be a slash, 
we are using Ajax to submit the form.  
60:56 - And depending on the response we get from the back 
end, we will then redirect or not. So we won't be  
61:02 - using the success URL, actually, but you do need 
one because we're using form view. Again, we don't  
61:08 - need that I've already got that at the top of 
the screen, then what we've got is recapture. So  
61:13 - remember, I said we were looking at we password 
context and function based view like this.  
61:17 - Yeah, as a dictionary, in a class based view, 
you need to call the get context data method.  
61:22 - And then once you've called that, you then can 
add a keyword to context and return context.  
61:26 - So we're adding recapture psyching to 
context, and that is the key in settings.  
61:33 - And then we overwrite the form valid, the form 
valid method in the AJAX mixin. And we do that  
61:40 - because we need some new logic here, because 
we're dealing with recapture. So we, we call this  
61:48 - if self dot request is Ajax. So if this is an AJAX 
call, then what we do is we get the token from the  
61:53 - clean data from the form. So this is the hidden 
input that we had in the form, then we call the  
61:58 - recapture validation function that we created 
in mixins. And we pass through that token, okay.  
62:05 - So depending on the response, if it is a success, 
then we sign that user up. Okay, so we save the  
62:12 - form, remember is, the form has the user creation 
form, which does all the heavy lifting, like  
62:19 - I say, so we just need to save the form and it 
creates that user and user profile with a signal,  
62:25 - we save the email. So we save the 
username to the email field, because  
62:31 - we use an email as a username, and we save the 
profile the object, then, we've used a profile,  
62:37 - we save the catcher score to the user profile 
capture score field, and then we save the user  
62:42 - profile. So that's what we do. Lastly, 
we call login. Okay, so we've logged in,  
62:47 - you pass the request, we pass through the object, 
which is the user building user model. And then  
62:55 - this isn't necessary. If you're using something 
like all off where you've got multiple backends,  
63:01 - then you need to stipulate what back end you're 
using. But you can have that in there anyway,  
63:05 - it doesn't really matter. The result is success. 
And the messages, thank you for signing up,  
63:10 - we create a data dictionary and pass it through a 
JSON response. Okay, so that is the sign up view.  
63:17 - Sign in view, again, Ajax form view, form view, 
again, we do all of this logic, like we did above,  
63:22 - it's just a slightly different because 
the templates are slightly different.  
63:26 - We haven't we don't need to pass any context 
through. But we do need to overwrite the form  
63:30 - valid. So again, very similar to above, just we've 
got the username and a password. And what we need  
63:36 - to do is call user equals authenticate. And then 
we authenticate that user, if user is not none,  
63:45 - we log them in. Okay. And if not, we then call 
a form error. So we don't necessarily need this  
63:51 - because we are using the authentication form. 
But because we're also calling the form area,  
63:58 - I've just left that in there, it's probably 
surplus to requirements to be fair,  
64:01 - but that is the sign in view. And last, we got 
sign up view, which is a function based view.  
64:07 - And all it's doing is logging out and put, and 
we pass through your request. And then once it's  
64:12 - logged out, you redirect to the sign in page. They 
are our views. I am trying to flow through these,  
64:22 - but be as detailed as I can. So you actually 
understand the logic of what I've done here.  
64:27 - Like I say, I've just identified in the sign of 
view that it doesn't necessarily need to look  
64:30 - like that you could technically technically, you 
could just use the AJAX form mixin and it will  
64:38 - save the form. But one of the main reasons 
is that we can have this success message  
64:44 - because the the mix ins if you look on the mixin 
here, there is no message is very, very basic.  
64:51 - Okay, next URLs. At the minute we've got 
bugger all in there, but what we need to do is  
64:59 - copy And paste all of this. So we're 
importing the views that we just created,  
65:06 - the app name is users and in the Euro patterns, 
remember, account is home. So it is a class based  
65:12 - view. So you need to call the as view method. 
So as views dot account, account view.as view,  
65:18 - you don't need to do that for profile, 
because this is a function based view.  
65:22 - But normally, and I don't know why 
I've done that, but we'll go profile  
65:28 - underscore view, normally, on a function 
based view, I do this and I think that  
65:33 - is the normal syntax. So we'll go back into 
view, which means that else it won't like it.  
65:40 - So go back into URLs, and I'll save that. So 
the profile views that profile view don't need  
65:45 - to call as view because it is a function based 
view and the name is profile, got a sign up,  
65:49 - sign in and sign out. These are two, both 
class based and this is function based. So  
65:53 - that's the syntax that you need. Okay. So if 
it's a class based view, you call the AZ view,  
65:58 - this is a function based view, 
you don't need to, and they are  
66:02 - our URLs. And we're already pulling from these 
URLs in the URL comp, with this line here. Okay.  
66:10 - I've just noticed that I've forgotten something 
fundamental. So we need a signals py file. So  
66:17 - New File, Save as this will be signals 
dot p y. And what we need in here is  
66:30 - all of this. So we're important posts, 
save from signals, they use up model,  
66:35 - we need to receive a decorator. And we also need 
the user profile that we've created in models.  
66:40 - So the receiver decorator needs post save and 
the sender to do anything. So the sender is user  
66:47 - in this case. So what we're listening for is 
a signal from the user model. And the function  
66:52 - is create profile, we pass through the sender, 
which is user, the instance of the user created  
66:58 - and keyword arguments, if created. So if user 
is created, we then create a user profile. And  
67:06 - the user because it's a one to one field equals 
instance, okay, that's what we put in signals.  
67:11 - But to make sure that actually fires up when we 
fire the local server up, we need to go into apps.  
67:19 - And deaf, ready parser itself. 
And we import users dot signals.  
67:34 - And that's all we need to do. So this, these 
two lines of code will be responsible for  
67:39 - firing up this signal. Okay. And now we need 
to focus on the main app. So if I go into  
67:48 - here, and look at the URLs we do about face, we 
do the URLs first. So main is just responsible for  
67:56 - two URLs, one of them is root, this is where 
you will be adding the different addresses for  
68:02 - your directions. And when you complete the fourth 
direction, it then picks up all four redirects,  
68:09 - you redirect you to this URL, which is 
map. Okay. So then we'll go to View.  
68:20 - Okay, so we're just looking at render, redirect 
and reverse, we're importing settings. And that is  
68:31 - wrong. There we go. And we just need directions. 
Remember, that makes them we created earlier?  
68:39 - Well, that is what we're bringing in here. And 
then we've got a function based view, both of them  
68:43 - are function based views. So def route, and we 
create a context dictionary here and we pass that  
68:48 - through to the root HTML file. Very, very basic 
view is not doing too much. Most of it will be or  
68:57 - most of the heavy lifting in on that view will be 
done using the API and the JavaScript, which we'll  
69:02 - come on to in the next section. So then, the 
last view that we're going to look at today is  
69:08 - map this is where we have our map and route 
directions rendered. So this is the fun bit.  
69:15 - So, we will be passing through a whole bunch of 
parameters. So if you remember in our mixing,  
69:22 - if you remembered on mixing, we've got this the 
redirect params that will be responsible for  
69:27 - creating a parameter string that will be passed 
through to the main view and it will contain all  
69:36 - of the so it will contain keywords such as lat, a 
long a lat, B Long Bay and so on and so forth. We  
69:42 - know that that am long a or both that Origin 
The starting point, B is the destination and  
69:50 - C and D are the waypoints okay? We know that 
because that's how we created up directions,  
69:54 - the function is also in mixing. So we say that 
if there is a lat, a that B that's Seeing that D,  
70:01 - then do this call of directions, okay, 
else. So if if somebody tries to visit  
70:07 - maps without those parameter strings, it will 
just redirect them to main route. So go back  
70:12 - to the route and say Do it again. Okay, but 
if there is a lot A, B, C, and D, it will try  
70:18 - to call directions from the mixin. And it 
just passes through the A, B, you know,  
70:23 - and so on and so forth. Okay. And that's what we 
built into mix ins, if you remember, there we go.  
70:28 - So these are the keyword arguments. So this 
is what we're passing through from the view,  
70:33 - like a lot, a lot, B, B, C, C, D, D, okay.  
70:40 - And that is the F, that is the L. So this will 
redirect. But if it doesn't redirect, then  
70:44 - it'll create a context dictionary. There's a lot 
going on here, we're passing through the API key,  
70:50 - base count country, this is all required for the 
API call that we're going to make. And we will all  
70:56 - become clear, when we start writing the JavaScript 
passes through all of the longitude and latitude,  
71:00 - and so on and so forth. Plus, it passes through 
the origin, the destination and directions,  
71:05 - because we need that to render onto the HTML 
file, which is mapped dot htm, l. So they are the  
71:15 - all of the views, they are the URLs, 
the models, and so on and so forth.  
71:20 - That just leaves us with creating a templates 
directory. So we haven't got anything in there.  
71:26 - There's a couple of ways of doing this. 
Now, if you're creating reusable apps,  
71:31 - ie those sort of apps that you can, you can 
upload onto p IP is that other people can actually  
71:38 - install them, then it's it's probably best for 
you to have templates in the actual app. So it's  
71:44 - all contained in one. But as we're not doing that, 
you don't need to do that. So all you need to do  
71:49 - is add a directory in here in the main directory, 
which be new folder. We'll call this templates.  
71:59 - And all we'll need is a new directory in there 
for users. And we'll need one in there for Maine.  
72:12 - So when we're referencing Maine slash 
map dot html, we'll be looking for  
72:18 - a file in here, if I save this as map dot html,  
72:30 - this view will be looking in main format HTML. So 
we'll be looking for that. That's how that works.  
72:35 - The only thing is, this project isn't geared 
up to look for templates in that directory,  
72:40 - we need to go into settings.py and tell it where 
to look. You do that by going to templates you're  
72:47 - going to does, and all you need to do because it's 
in the main directory, you need to put templates.  
72:55 - And that is it. Okay, I hope that that was a 
good balance of firing through everything. So  
73:05 - you can get through it nice and quickly, without 
skipping over kind of some fundamental stuff.  
73:11 - We've got covered a lot of ground, we have 
started a new user app, we've built a model,  
73:17 - some model forms and views from URLs, you know, 
we've reconfigured settings, the URL comp,  
73:23 - we've configured templates, we've covered a lot 
of ground, but that is in terms of the back end  
73:28 - in terms of Django, that's this app is complete. 
It won't work. However, because we haven't got  
73:35 - anything, such as CSS, HTML, or JavaScript. 
That's what we look at in the next section.  
73:41 - But one thing actually, I've just noticed 
also is that in our settings.py file,  
73:46 - we're referencing a directory that's not 
there for static. Now, that's an easy fix.  
73:53 - New Folder, and we'll just call this static. 
Great. That is our static directory. And that  
74:00 - is what this is referring to. Okay, good. That is 
the end of this section. I hope you've enjoyed it.  
74:07 - And I look forward to going through the next 
few bits and pieces. Thank you. And goodbye.  
74:19 - Everyone, it's probably from decoded here, and in 
this section we'll be following on from where we  
74:22 - left off in the last one where we fleshed out the 
back end of this Django project. In this section,  
74:28 - we will be playing with the front end. So we'll 
be creating HTML files, CSS, JavaScript, jQuery,  
74:35 - Ajax, and Google API's. So this is the fun bit 
of the project actually, because this is where  
74:41 - all kinds of strings gets strung together. So 
without further ado, let's jump straight into  
74:46 - it. If you look on the screen here, I'm open 
on the Django Doc's for template tags. Now I  
74:51 - have created a video on my decoding channel that 
does a deep dive on tag template tags and filters.  
74:57 - So if you want to understand what they are then 
by all means, have a look at that rather than me  
75:02 - going through this page. But we'll be working 
with a lot of template tags today. So have a  
75:07 - read and have a watch and then come back I guess. 
But this go jump straight into the Sublime Text.  
75:15 - This is the project where we left off. On the last 
section, you can see here that we created a static  
75:21 - directory, and a templates directory. This is what 
was the last couple of two or three minutes of the  
75:27 - last section. This is what we did. And we've got 
main other users in there. So what we'll do now  
75:32 - is we will create the first HTML file, 
and that needs to be in templates as a  
75:38 - base. So new file, and we will call this Save as 
base dot html. Okay, and I'm not going to write  
75:48 - this from scratch, because it will take forever, 
I didn't design this app to be kind of basic,  
75:54 - you know, it looks pretty actually works, 
you could done it resizes is responsive.  
75:59 - So there's a lot going on. So what 
I'll do, I will quite simply copy,  
76:07 - copy and paste it all across. And 
I'll walk you through what I'm doing.  
76:12 - Let's move this over here a little bit. So 
first and foremost, there's a template tag here,  
76:17 - which says load static. This is a template 
tag that allows us to access our static files.  
76:24 - Now static files, as configured in 
settings dot P, while p y are all  
76:28 - going to be in this directory here, as we're in 
development. However, if we were in production,  
76:33 - then you would set up static files in a 
slightly different way, and maybe have them  
76:36 - served up to the project via an s3 bucket or 
something like that, or digitalocean spaces.  
76:43 - So this load static template tag allows us to 
access files in static directory, we've got some  
76:49 - basic HTML here, I'm not going to do a deep dive 
at all. But we've got this is the main that all  
76:58 - these links here, these are my fonts. So we 
use Korea prymatt decoding, we then got a  
77:02 - stylesheet that we're referencing main dot CSS, 
we'll be playing around with that in a second.  
77:08 - So this bit here is calling a CDN, essentially. 
And this is for toaster. So we'll be using toaster  
77:12 - alerts to display messages from the back end. So 
if you remember, in views, we've got this message,  
77:19 - defaults to there was an error. And result is 
error. Well, that's going to show a red toaster  
77:23 - message. If you don't know what it is, if I go 
back into my browser, I've got toaster examples  
77:28 - here. So this is a success. top right. But we can 
have a bottom right, which I believe have gotten  
77:34 - this project, show toast There you go. And it can 
you can have whatever you like in there, you can  
77:39 - test show toast, there you go test. Okay, so 
that's what we use in this project. Go back  
77:46 - into the project here go back in a base. So that's 
the CSS that's required for toaster and we always  
77:53 - stick that in the head, you've then got block, 
extend head, so we use a block template tag. Okay,  
77:58 - so this allows us to extend head scripts that 
under the law, so I've got some notes in here  
78:02 - as well. body. So we've then got nav, we're using 
an include template tag, we haven't even created  
78:11 - this yet. So I'll do that now quickly. So new 
folder, and this needs to be called partials.  
78:19 - And in partials we need a 
new file called nav HTML.  
78:31 - Okay, so that will now be 
picking up from this one here.  
78:36 - Go back to the base. And so this include 
template tag, rather than having all of the  
78:41 - code is going to be in nav HTML, use the include 
the kind of interjects that HTML element into it,  
78:47 - then we've got this div. So don't worry about 
these too much. The classes, I will be creating  
78:54 - some CSS, because I've named these specifically 
in certain ways so that they get rendered  
78:59 - nicely and looks great on the front end. If you 
remember when we looked through the the demo of  
79:04 - the app, it looks pretty good, right? So we've 
then got include partials logo, hate logo, HTML.  
79:10 - So let's create that. I can't talk today, let's 
create that quickly. New File. More, save that  
79:18 - as logo dot html. I'll bring across 
that code in a second. Anyway,  
79:26 - save, and then we've got a block. So these blocks 
allow us to extend certain parts of this base. In  
79:32 - other templates, it will make more sense in a 
second. And it's called content. So we've got  
79:37 - block, extent head block content, and we've got 
another one here, extend footer. So these are our  
79:43 - footer scripts. So first and foremost, we're using 
something called jQuery. This is a, I believe,  
79:50 - the most popular JavaScript library, and it allows 
us to access things such as Ajax so we can make an  
79:57 - asynchronous form submission for For instance, 
we submit the form and we get the response and  
80:03 - nothing reloads on the HTML page at all. It's all 
done asynchronously. So that's why we need jQuery.  
80:09 - But you can get this code from code.jquery.com. 
And you get the most recent version.  
80:15 - Then we've got the toaster JavaScript, which 
is all this again, you can get visit this  
80:20 - CDN JS calm and get the latest version from there, 
then we've got a block for extend the footer,  
80:25 - again, it allows us to extend this part of this 
HTML into another document. And then lastly,  
80:31 - we're referencing main dot j s. So there's 
two files in static that we do need.  
80:36 - So new file, and we'll save this as main dot j, 
s, that'll be a JavaScript file was Save as again,  
80:48 - and we'll call this main No, we weren't. 
New File. Save as this will be main dot CSS.  
81:02 - So there we have it, we've now got the main CSS 
and main JavaScript, so we're referencing them in  
81:06 - base HTML. So even if we were to not pay anything, 
those files, we're not going to come across  
81:12 - any errors. And then we close up the body in 
HTML. So that is base HTML, we don't need to  
81:18 - do anything else in that file, all we 
now need to do is create the documents  
81:21 - that will be extending these blocks. Okay, 
so the first one we'll look at is the index  
81:28 - or in this case, it will be 
account, which is in users.  
81:35 - So create a new file. As we save, as 
we'll call this count, dot html, in fact,  
81:47 - was Save As we need another 
one in here called profile,  
81:55 - save as another one in here 
called sign in as underscore,  
82:02 - save as another one called sign out. 
And whilst I'm at it, I will also  
82:10 - do the map. So templates kind of main 
overall to get map in there and will route  
82:20 - safe, good, that may close some of these 
down got far too much going on up here.  
82:27 - As a real bad habit I have.  
82:31 - There we go. Right. So then what we'll do, we'll 
look at account. Okay, so this is our homepage.  
82:38 - So I will copy. And I'll paste this across. So 
extends the base dot html. So it's extending this,  
82:48 - okay, as another template tag that Django has load 
static. Okay, so we've now access static again,  
82:56 - we're not adding it that doesn't necessarily 
need to be there, but it's not hurting anyone. So  
83:00 - we'll add that if I wanted to add a script in 
there, for instance. Yeah, so with ADD script,  
83:06 - you could then add something in there. But 
we're not so we won't. But this is a block  
83:13 - content. So this is the content that 
will be injected, if you like, into  
83:21 - this section here. Okay, so block content. 
So block content, block content, okay.  
83:30 - So we just save this. So got h3 tag, as you know, 
is a Django Google API course. And this is the  
83:38 - user account. And then we've got a div, which is 
container. So we'll be referencing these classes  
83:42 - in the CSS, but I'm not going to dwell too much on 
CSS. This is more about the API's and JavaScript.  
83:49 - So we'll quickly do that in a second. Then 
we've got h4 tags, so user account details,  
83:54 - and then we've got a table, okay. And in 
that table, we've got a table head, it's got  
84:00 - a head, and then blank, sorry, a field and then 
a blank field. So there's no header there at all.  
84:04 - Now we've got a table body, and then for each 
row, so we've got user name, request dot user,  
84:11 - dot username. So Django uses something called 
context processes that always pass through request  
84:17 - to HTML, so you can always access 
request. Therefore, you can always  
84:22 - access request dot user. And fields such as user 
dot user name, you can access things like in our  
84:29 - case will be request dot user dot user profile 
dot address, things like that make queries such as  
84:35 - if request.user.is authenticated. So it's really 
really handy that context processor is used more  
84:42 - than anything else. The next row, we've got name. 
And then we've got so we use a filter. So this is  
84:49 - a template filter, request dot user dot first 
name, title. So this will put a capital letter  
84:54 - at the front of the name and then space last name. 
So first name, last name. And then we're doing an  
85:01 - if statement here. So an if else. So if request 
dot user dot user profile dot has profile. So  
85:08 - if they've added an address, display this, 
which is a table row, details, our address,  
85:15 - then I'll show address, town county postcode 
else. So if they haven't, so if they're  
85:21 - just newly signed up, then it'll show us a 
profile, and it will have an a tag with a href  
85:27 - and a link. So we use an a URL template tag to 
user's profile. So it would just be a hyperlink  
85:34 - where they can click it, and it will take 
it to the profile, so they can then select  
85:37 - that address. So this is why I've got that has 
profile in as a field on the user profile model.  
85:45 - That's it. That's all what's going on in account. 
Not much else. So let's build out the profile.  
85:54 - Paste and save as bit more going on in this 
Gannett extends base called load static. Now  
86:00 - we've got the block content. So again, this 
is the block, then we've got extend footer.  
86:06 - So if we remember in base, we've got this extend 
extend footer here. The main j s is always the  
86:11 - last JavaScript that we load, it's just the way I 
do it. That means that anything above this I can  
86:16 - reference. So I can definitively know that any 
Ajax I'm writing in main dot j. s, it will work  
86:23 - because jQuery is loaded first, okay. And a block 
extends footer. This is all loaded before my day.  
86:31 - So I can actually reference any variables that are 
stated in the extend footer block. So in profile,  
86:38 - we've got extend footer. And then we've got a 
script. So this is a JavaScript script. And we're  
86:43 - creating two variables. one variable is Google API 
key. If you remember, we're passing this through.  
86:50 - Let me remind you profile view. in context, 
we're passing Google API key and base country  
86:56 - through to the context. That's how we were 
accessing it here. Okay. So we'll create a  
87:02 - JavaScript variable. So we can access this in the 
main j. s file. We're calling it Google API key.  
87:08 - And we are, and we're using the safe filter. So 
that will just create a string of that API key.  
87:16 - Same goes for base country, the next script 
is a file called Google Places, dot j. s. We  
87:22 - haven't got that yet. So we will create 
that now. So it's Google Places. Save as  
87:34 - API dot j. s. Great. Go back into profile. So 
that's now referencing a file that is there  
87:42 - that will work. Go into the containers, this 
is the main main bits and pieces. So we've  
87:47 - got an if statement here with an else so if the 
request dot user dot user profile has profile,  
87:52 - show all of this else, add address, 
okay? And if case so we have got,  
88:04 - and if I okay, just trying to figure out what 
I've done here. So this is input Google address,  
88:09 - right? Okay. So this here is that the 
main input for the Google Places API.  
88:15 - So this input here is the input where the user 
starts typing an address. And Google API predicts  
88:21 - what they're trying to type. And then it returns 
the address, they select it, when they select it,  
88:27 - it then populates all of these inputs here, 
which I'll show you what I'm doing in a second,  
88:31 - let me just cover this off first. So if they 
have a profile, it will display the profile.  
88:37 - Okay, so it will display the address, and then 
it will have a change address. And then it will  
88:45 - have or else it will have add an address. So 
if it changes the address, you can then change  
88:49 - the address to the new one, you'll type away in 
any address you select, it will change. If not,  
88:53 - you just added an address. So this is the main 
input you see here we've got name Google address,  
88:58 - ID is ID Google address, we will be 
referencing them in the Google a Places API,  
89:05 - just for reference, then we got a form. And then 
that is the end of that, really. So we'll look  
89:10 - at this form. So the idea is profile form, we 
will be creating an AJAX call using jQuery on  
89:17 - that. So that is the name we'll be referencing 
profile form. The method is post and the action  
89:22 - is for slash profile. So that's essentially 
the URL we will be firing the AJAX call to,  
89:27 - which is, if we look in URLs is 
here. So as the profile is the name,  
89:35 - and that is assigned to views dot profile 
view. Oh, okay, so let's look at the form.  
89:42 - So as it's a form, we need to use another 
template tag and this will add a hidden  
89:48 - input with CSRF token. So CSRF token means cross 
site request forgery token and it's a token as  
89:57 - applied to a forms when you submit the form. 
It knows That is actually you doing it and no  
90:02 - toe rag doing it from somewhere else. And what 
we're then doing is we're creating these labels.  
90:08 - So address is actually now these are hidden, 
right? So that class is hidden L. And it's hidden.  
90:16 - Okay. And the reason we're doing this is 
because in the JavaScript in the main j s, we  
90:19 - write a function to display these hidden 
elements, when we select an address, and  
90:26 - this is why we're doing it. So the label itself 
is hidden, class hidden L, and is hidden. And  
90:32 - form dot address, if you remember, that 
is a hidden input. So we're gonna forms  
90:38 - hidden input form, sorry, hidden input. So all 
of these are hidden. So they will be rendered as  
90:44 - hidden inputs in here, as is the label. So label 
and input hidden, then you got town, county,  
90:52 - postcode, country, longitude, latitude, none of 
these will be displayed until the user selects  
90:58 - the address. And then we've got a JavaScript 
function that will unhide all of these elements,  
91:03 - the button to submit is disabled. So you can't 
submit the form until an address has been  
91:09 - selected. And we add an ID to this Profile 
button, because we referenced that and we  
91:15 - programmatically click it when the address has 
been selected. Okay, so that's the profile HTML.  
91:22 - Next, let's look at sign in a gay and let 
me get my notes. And sign in. Copy across.  
91:35 - Paste extends base, same as we load static, always 
the same, then we've got the block content. Okay,  
91:44 - not much else going on in this. But we've got 
an h3 tag, and then we've got to contain here.  
91:48 - So this is, again, is a form. Yeah, so 
against CSRF CSRF token, the ID sign in form,  
91:55 - post sign in. Okay, so I'm having 
the ID, the method and the action,  
91:59 - always in the form as attributes. That way we 
can when we're making the call in the JavaScript  
92:05 - is a lot easier to understand what's going on. 
Label again, right, so we're creating a label.  
92:10 - The difference is this isn't hidden in the form 
dot username, because we use in a form view,  
92:16 - you access the form from the form object, 
so it's form dot username, and as the  
92:21 - the input. So if you look at forms, username, 
password, fields, username, password, that's how  
92:29 - we reference the number in sign in a case, that's 
why we got form dot username, form dot password,  
92:35 - then we've got label. So this is show password. So 
if you remember in the forms, we have got a class.  
92:46 - Let me show you. Class password. 
Okay. So what I'm doing in signing is  
92:53 - on click, so this is a little checkbox, right. So 
the CSS will make it look pretty, but essentially,  
92:58 - is a checkbox. So if it's unchecked, it will 
be a password input. But when they click it,  
93:05 - it becomes checked for starters. And it calls 
a function called show password or show p word.  
93:11 - Now this function, I'm going to write in 
the main JavaScript file, and that will  
93:15 - essentially swap that password input to a text 
input. So you can actually see the password,  
93:20 - okay, which is quite standard on on websites. 
And then a button is submit and sign in. Okay,  
93:25 - nice and easy. Next one, sign out. Sorry, 
sign up. Now, that should be sign up, we know.  
93:36 - There we go. Sign up. So we will copy and 
we will paste. Like we more going on in this  
93:43 - one. So extending base HTML, and we're loading 
static, free standard stuff. And this one, we  
93:48 - are extending the head, we'll come back to that in 
a second. We've got block tank, we've got a form.  
93:55 - And we're extending the footer. So 
if you remember in the sign up view,  
93:59 - we're playing around with the contacts 
using the get context data method.  
94:03 - And we pass in three recapture site key, 
okay, which is the recapture public key.  
94:09 - And we're creating a variable recapture site key 
that we can reference in the JavaScript that we  
94:16 - haven't written yet. Okay. The form is pretty 
standard, similar to what we just done CSRF  
94:22 - token. Then we've got the first name, last name, 
username, password, one password, two differences.  
94:27 - We've got token in this one. So the token if you 
remember in the forms we added as a hidden input,  
94:33 - and that is how we're going to be handling the 
reCAPTCHA token. Okay, so that's a hidden input,  
94:38 - you won't see that when it's rendered. Then we've 
got this little checkbox box to show the password  
94:42 - again and a sign up Submit button. Okay, so that 
is the form. And what we've got at the top here is  
94:51 - a script. So this is the source is the url 
https google.com reCAPTCHA. api.js JavaScript.  
95:01 - So this is the JavaScript that we're pulling 
straight from Google. And we're passing through  
95:07 - the, our reCAPTCHA. psyche. So that's how it 
knows that it's us making the call to recapture.  
95:14 - Because the psyche that we set up when 
we set up recapture in the first section,  
95:20 - we're linking it to that API key. So and that is 
the JavaScript call as the script we sit in the  
95:25 - extend head. So essentially, this script, being in 
that extend head is the equivalent of it being in  
95:36 - well, it'll be there but without the 
head. So imagine, imagine that Okay,  
95:40 - so that's what we're doing by adding that to the 
extent head. So that's the JavaScript as long  
95:48 - as content happy days. That is the signup 
page. So now let's look at the main map.  
95:59 - Actually, let's look at the parcels quickly. 
Copy partials. Okay, so this is the logo. So  
96:07 - it's just an a tag, essentially. And if I 
save that, so if you click on the logo take  
96:12 - you to a user's account, which is the homepage, 
and it's referencing, I think that's the first  
96:15 - time you've seen this in this tutorial, load 
static. So this is how you reference the static.  
96:21 - When you load static, you can then use the 
static template tag. If you didn't load it,  
96:25 - it wouldn't work. And we're looking in 
branding. So in static, new folder, branding,  
96:34 - and is trying to find a GIF, which is a 
dead logo GIF, we'll add that in a second,  
96:40 - which won't be a problem at all. And then we will 
add the Nef got a lot of if statements in this.  
96:51 - nothing too fancy To be fair, it's got an if 
statement if else. So if the request dot user is  
96:56 - authenticated, so if they're signed in, they 
will see this now. If they're not, they will see  
97:01 - this nav, okay. So this look at if so when you 
first enter the site, if you're not signed in,  
97:06 - you'll add if signing in path. So if the URL is 
sign in, then this will sign in will be active.  
97:16 - Okay. So on the side now there'll be 
glowing up purple, if not, it will be blank.  
97:21 - If it's sign up, it will be glowing up purple, 
if not blank, that's what these if statements  
97:25 - are doing is just basically showing whether or 
not is active or not. If they are authenticated,  
97:30 - and the request path equals equals slash, 
which is home. Again, active if not Same goes  
97:36 - for profile, route map. Okay, so it just shows 
different, different navigations. To be fair,  
97:43 - let's close that. Let's close that. Let's 
close sign up, sign in profile and account  
97:48 - or keep base open. We'll close that. And now 
we will do map. So copy. It's going to map  
97:56 - or paste this a lot more going on in this. Save. 
Okay, so map extends the base HTML load static.  
98:08 - In this one. Again, we're passing through 
recapture. So recapture site key, okay. And  
98:15 - then to be fair, we probably don't need to, that's 
probably a hangover, but I leave it in there.  
98:21 - Because we're not making a reCAPTCHA call in 
map. We're only making it in, sign up. Okay,  
98:26 - so we've then got h3 tag, and we've got a 
container. So what's going on here? We've got  
98:34 - I'm going, do you know what? Let's 
do root first. Nasty read first.  
98:45 - Okay, this is right. Yeah. So route is 
the the URL where we add the longitude  
98:50 - and latitude for the origin, the 
waypoints and the destination.  
98:54 - And map is what's rendered says the last point in 
time, actually, so let me look at real quickly.  
99:00 - So I've just pasted that all in that 
extends base load static. And then again,  
99:04 - we've got recapture. We don't need that. I'm sure 
I can remove that. But I'm not going to because  
99:08 - I haven't tested it. And I know that it works in 
in the other project. But we're not technically  
99:13 - making a recapture call. So I'm, you know 
what I'm saying that doesn't need to be.  
99:19 - Okay, then we've got the h3 tag, 
and then we've got the inputs. So  
99:26 - this is the same as account, no profile. So in 
profile, if you remember, we have this input here.  
99:32 - And we call it ID Google address difference 
here in roots is that we've got four.  
99:39 - So if you look here, I've got ID Google address, 
dash a, dash B. So remember, start and end.  
99:47 - Don't ask me why I didn't go ABCD. It 
seemed logical at the time but looking back,  
99:52 - I probably should, should have gone a B, C and 
D instead of going to a and b, that is point A,  
99:57 - B is the destination and a waypoint system. 
In day, a guess, because you can do more  
100:02 - waypoints. So it'd be C, D, E, F, G that way, but 
hey, the logic was there when I was building it.  
100:08 - So these are the inputs. So as you type in here, 
it will predict the address as you type in C, it  
100:14 - will predict the address, and so on and so forth. 
And when you select each of them, it then adds the  
100:22 - geo coordinates the longitude and latitude to each 
of these hidden inputs here. So this class is geo  
100:29 - ideas lat a long a, okay, and then it adds a 
value. I'll be using JavaScript to add that value.  
100:38 - Yeah, we didn't need that. reCAPTCHA at the top 
of the screen, because even passing through the  
100:45 - reCAPTCHA key, so I can remove that from map as 
well. Let's, let's remove that. There's no point  
100:50 - in it, bns. So save back to root. So this is 
the extend footer. So we've got a script here,  
100:56 - a couple of variables, Google API key and base 
country. And also we are then referencing the  
101:02 - Google Places, waypoints j s, because in this 
we have to. So that's add another one. And  
101:11 - save us. And this was Google waypoints  
101:21 - API dot j, s, waypoints API. Let's have a look 
was probably wrong. Google Places, waypoints,  
101:38 - points. And then if we delete that, there 
we have it, we've now got that file.  
101:43 - So that's referencing a file that is actually 
there. Okay, so now we'll look at the final  
101:49 - HTML document, which is map dot html. So if we go 
in here, I did paste this a moment ago. Anyway,  
101:57 - you can see that we've got quite a lot going on. 
This is where we render the map from Google. So  
102:03 - let's look at this look at the footer first. 
So we pass in through if you look at the map,  
102:11 - view, in the context, we're passing through all 
of this, okay, so we're passing through the key,  
102:18 - the base country lat long the data that the 
data in maps, we are getting all of those. And  
102:24 - we're creating, in this case, we're creating 
a string, we're always using the same filter,  
102:30 - else, JavaScript doesn't like it. And then you got 
we're creating variables a lot, a lot longer a an  
102:36 - NBC D, origin, destination and directions, we're 
going to need those in the Google Places API,  
102:43 - and Google Places, waypoints. And also, Google 
Maps JavaScript, which we haven't created yet.  
102:52 - So New File, Save as Google Maps dot j s. Okay, 
so we'll be needing all of that in Google Maps,  
103:04 - okay. Then got another h3 tag. And we'll focus on 
this. First of all, we look at the table in the  
103:11 - container. So this is the map container. This is 
the map route. So we will be referenced in this ID  
103:17 - map, right? Because Google that the Java scripts 
in the Google j s files that we're just creating,  
103:23 - they will essentially be rendering the maps and 
everything else, all of the routing and stuff  
103:29 - into this element called a map route and will 
be referenced in map pre in the JavaScript.  
103:34 - Then if we look at things insane, I've got another 
table. So we've got to start the destination,  
103:40 - a duration and the distance, that's 
kind of the header of the table.  
103:43 - And we're pulling from directions, origin, 
directions, destination. So that is what  
103:48 - comes through when we call. If you remember, 
we've got directions here. So we're passing  
103:54 - directions through to the context. And that is 
essentially a dictionary. So we're referencing  
104:00 - keywords in that dictionary directions, such as 
origin, destination, duration, and distance. And  
104:05 - that's what's being rendered here. Then we've 
got directions, and we've got ID dir toggle,  
104:12 - so this is JavaScript void, h ref. And then we've 
got on click directions toggle. So this is how you  
104:18 - view the directions, it doesn't show the 
directions in tissue until you toggle it. Okay,  
104:23 - so that's just a little little link that we've got 
there. And then we've got another table. So we've  
104:28 - got table head directions, distance duration, 
and this is where it renders the whole route.  
104:34 - So for each leg, in directions dot route, we do 
a for loop and a counter. And then we do this for  
104:43 - loop here. With dist duration text, we're creating 
those variables that we can reference down here.  
104:49 - And they are in leg dot steps within a foot 
we're doing a for loop in leg dot steps,  
104:54 - create three variables, distance, that 
duration is there and text say Is that  
105:01 - because that is raw HTML that comes through 
from Google. And that's why we need save,  
105:06 - because it will actually render that HTML properly 
in the website. And that's it. That is maps. Okay,  
105:14 - the next thing we need to do there, all our 
HTML is complete, we now need to add some CSS.  
105:22 - Which would do, I am not going to 
waste your time on CSS, this app  
105:26 - tutorial was all about showing 
you Google API's and Django.  
105:30 - CSS is not an afterthought. It's very, 
very important. It makes it look fantastic.  
105:34 - But you know, we could spend an hour going 
through CSS, which isn't necessarily important.  
105:39 - But you can see, I'm referencing body. I'm saying 
that the font family for this particular file  
105:45 - is Korea prime, which is correct. The map root 
element. So this is what we just looked at here.  
105:54 - Where is it? So map route, so we're referencing 
different elements in each of the HTML files.  
106:00 - So we've got map container. So I've 
probably got one for if I search.  
106:07 - There we go body HTML map container height 
100%. After they need to search flowers right  
106:12 - at the top, but then got logo got a side now. 
So this tells you this shows you what the sign  
106:16 - level look like, then we've got some some media 
screen. So it depends on how big the screen is,  
106:21 - is how it gets rendered. These are how the inputs 
look. So a text input an email, password input,  
106:28 - we've got select text area, this is how it's 
rendered this how it looks, we've got width, 100%,  
106:33 - padding, 12, so on and so forth. Okay, so we don't 
need to waste our time on this, which so we won't.  
106:41 - The next thing is the main JavaScript. So if I go 
into main, paste this, right at the bottom here,  
106:50 - we've got code straight from Django. This is a 
JavaScript function to get the CSRF token from  
106:55 - a cookie to and then it passes that through with 
an AJAX call, this is a way to work around to make  
107:02 - sure that the right CSRF token is passed through 
when a form is submitted. Okay, so it's very  
107:08 - important you have that in your JavaScript file, 
when you submit an Ajax. So let's go right at the  
107:13 - top of the file, there's open up a little bit, 
like directions toggle, if you remember, in maps,  
107:19 - I saw that directions toggle somewhere Hey, guy, 
so we've got a little link here. And it says,  
107:26 - click here to open up the route basically. So you 
can see the route for the map. And it's unclick,  
107:32 - you called direction toggle. And all it does is it 
opens up a removes the hidden attribute and adds a  
107:40 - new element. So we don't need to necessarily go 
through the JavaScript itself. But that is what  
107:45 - is doing. When you click that toggle is calling 
this JavaScript function. And it's fading in the  
107:51 - directions table, else you fade out. So you either 
display it, or you hide it, one or the other.  
108:00 - Show it up. This is for toaster. So we call Shola. 
Every time we make an AJAX call. And it depends on  
108:08 - if it's a success. Or if there's a redirect, for 
instance, we pass through all of these keywords,  
108:16 - all of these keywords here. If there's a redirect 
URL, and we call this toaster, house, we call  
108:23 - this toaster. So what what is doing is picking up 
the title. So in that case, it could be success,  
108:30 - that message could be thanks for signing in. And 
it's creating a toaster. So if you look at the  
108:37 - examples, again, is creating a toaster based on 
all of this. So if we add a close button in the  
108:43 - progress bar, and then tap show test, says 
creating a unique toaster and that's what  
108:48 - I'm doing in the JavaScript there. Okay? So that's 
the function called show that show password. Okay?  
108:55 - This is what's being called when you click on me 
open up sign up. is they go so show p word. Okay.  
109:08 - So this is a JavaScript function has been called. 
And what it's doing is if the type is password,  
109:14 - change it to text, if not change back to password, 
just a little toggle. Okay, we create a variable  
109:20 - called temp button text. So this is the text 
that's on a submit button. So it could be sign  
109:26 - up sign in. So it kind of stores or this will 
be used to store what a button is currently  
109:31 - named. And then you've got a custom form submit 
post. So when we submit a form, what it does,  
109:36 - it disables the button, it adds a spinner, 
and it saves the current text to this element.  
109:44 - And then when it's complete when the form 
is submitted, and everything's gone, well,  
109:49 - then we then call this so as custom form, 
submit response. And what it does, it removes  
109:54 - the attribute disabled and it adds the text, which 
used to be so the idea is when you submit a form  
110:00 - It adds a spinner saying loading, and then when 
the form submit in, it goes back to sign up.  
110:05 - That's all it's doing. And we just call custom 
form submit post and custom form submit response  
110:11 - when we call an Ajax. And then we've got form 
controls. So we use strict, but this is variable  
110:16 - form controls and is equals function. So this 
is kind of a general JavaScript function that  
110:21 - we're doing here. And underneath here is when 
we initiate the form controls. So it's a jQuery  
110:29 - document ready. So when for when the HTML has been 
rendered, then we call the format controls, and we  
110:36 - initiate them. So everything within here will win 
work. So format controls, we've got a few forms.  
110:43 - First one is user sign up, we've got sign 
in user profile, and we return and we in  
110:49 - initiate and function, we initiate these forms. So 
each of them certainly work. So we'll focus on one  
110:56 - of them. So these we've got one of these for each 
of the forms that we've created. Okay. So forms,  
111:01 - so we're looking at user is the user form, which 
is the signup form, right? Yeah. And we call  
111:12 - that in, so we're looking sign up, we'll look 
at the form. So sign up form. Okay. So that's  
111:17 - what we're referencing. Now, this is what we're 
trying to submit from the front end, this is us  
111:22 - submitting a form from the front end, processing 
it in the back end, and, and then changing the  
111:29 - page as necessary. We're not reloading, which is 
an AJAX call. So this is the user signup form,  
111:35 - the form, so we're creating a variable form, let 
me make this a little bit easier for you to see.  
111:42 - here as well. So we create a variable 
form. So that form is we're using Ajax  
111:49 - function. So your little dollar sign, Id signup 
form. So the form is the signup form that is  
111:56 - in the signup, HTML, this was one here. Then 
we've got form dot submit function. So this is  
112:02 - when we submit the form, this is what we do, we 
prevent default. So if we click Submit on HTML,  
112:10 - submit on an HTML form, it would just do its 
default function, which is to submit the form to  
112:16 - the back end by adding event dot prevent default, 
it stops that from occurring. So it kind of  
112:23 - completely stops that from happening. And 
then it goes through this piece of code here.  
112:28 - Okay, so we've got custom form, submit post, 
we're calling this, remember, we added a little  
112:36 - loader to the button. And then we've got google 
recaptcha. Ready. So we have already loaded  
112:43 - that in this particular HTML document as this 
script here. So we can now access g recapture.  
112:53 - So g recapture dot ready function. So then 
what we do is G recapture dot execute. So  
112:59 - we pass through the reCAPTCHA psyche that is 
passed through at the bottom of this page,  
113:04 - okay? The action is slash, because this 
is the homepage, right? So this is the  
113:12 - index. So dot then function. So this is the 
token, this is the token that we get from  
113:17 - G recapture the google recaptcha. So document 
dot get element by ID, ID token dot value. So  
113:24 - this is the value of the token 
equals token. So that hidden element  
113:30 - now has a value of the token, and 
then we submit that to the back end,  
113:35 - so var form data equals form, which is here 
serialize. We call it a serialized function that,  
113:43 - and then we call an, we make an AJAX call. 
Okay. So the URL is the form attribute action.  
113:52 - Over the form attribute is a sign up. Okay?  
113:56 - main, then our wet sorry, methods. So the form 
attribute method, we've then got post. So this  
114:03 - is a post call. post request, sorry. And then 
data, we're passing through the serialized  
114:11 - form data. We've got a success method and an 
error method. So if anything goes wrong, right,  
114:17 - we call the custom response. So form submit 
response. So the button on the form will go  
114:22 - back to normal, then we'll show an alert, which 
be error, there was an error, please try again.  
114:27 - And then we do a console log that will only 
display if default, sorry, debug is true. Okay,  
114:33 - if it's false, it won't show anything. But 
this will show an error if there is a problem.  
114:38 - However, if it's a success, can 
we call custom forms and met  
114:43 - if the result equals success, because we're, 
if you remember, in the logic in the view,  
114:49 - where we're overriding the form valid 
function, and if we show sign up view,  
114:58 - so it's a success. If recapture works, then 
respond with success. If it doesn't, then  
115:04 - we will call. So it has a form invalid, 
we'll call a form error method in the mixing.  
115:13 - So if it's a success, we redirect to 
homepage. If not, we redirect false.  
115:19 - We basically don't do anything. So then we what 
we do is we call a show alert, you can't really  
115:26 - see that, can you, we show alert, and we pass 
through the result of the call the message,  
115:30 - and then the result to lower case. And then with 
that, we pass through the redirect, because we are  
115:38 - redirecting to the homepage. Okay, so that is 
the signup form logic in JavaScript. This is how  
115:46 - we're processing the form on the front end, we're 
doing the same. So the reason I went through that  
115:50 - and quite a lot of details, because we're using 
recapture, whereas these other forms, were not  
115:56 - a case. So there's no gv capture at all. 
It's just basic, we're getting the form  
116:01 - we're creating form day, it will make an AJAX 
call with the attributes, action method and  
116:05 - form data. We have got console log Jason, we 
don't necessarily need that. That's for testing.  
116:11 - So this is the sign in function, the sign in form 
submission, then we've got user profile. Okay, so  
116:19 - this will be called when we click programmatically 
the submit button on the form in route. Sorry,  
116:29 - sorry, it's in profile, my apologies. So it's the 
foreman profile with a profile form. If you look,  
116:35 - the button is disabled. If you can't, you can't 
actually click the submit button. So what we do  
116:40 - is we actually programmatically click that Submit 
button when we get the response from Google. So  
116:45 - we'll be submitting this form in JavaScript from 
the Google. Where is it the in static from one of  
116:54 - these, probably Google Places API. So when we get 
the result back from Google, we will then remove  
117:00 - the disabled attribute from the Form button. And 
then we will click the button programmatically,  
117:06 - like I say, so it's there's no different, 
nothing fancy going on here. They're all very,  
117:10 - very similar. But they're the three forms and they 
are in the main js. So let's save that. We've done  
117:16 - the CSS, we've done the JavaScript now we now 
need to focus our time on the Google Maps, Google  
117:23 - Places and waypoints. Okay, now, what we need 
to do is add the JavaScript to the Google Maps.  
117:33 - Copy, Paste. So let me open that up a little 
bit. Okay, so right at the top of the page here,  
117:41 - we call this so is it get script and we call maps 
dot Google API's comm we pass through the Google  
117:48 - API key. And then at the end of that we plus an S, 
and libraries equals places. So this is the call  
117:55 - that you need to make to have access to everything 
we need in Google Maps. And this is what's going  
118:00 - to be used to render the map in map dot html. 
So this will be the map with the route across  
118:07 - the waypoints. Okay? So when done, so once you've 
got that script done, and does this function here,  
118:14 - so is Google dot maps dot event, add Dom listener, 
window load, and then you initiate the map. Okay,  
118:22 - so this is just a standard get script call for 
Google API's, then gone in its map function. Okay.  
118:30 - So we have a variable of direction service and 
directions display. And then a very variable  
118:36 - of map. So we make a new Google Maps. And we're 
looking for map route. So this is the element that  
118:43 - I showed you in the map HTML. So it's actually 
looking for this, this is where the map will  
118:49 - be rendered. Okay. Zoom is seven. I can't even 
remember what that means. And then we center the  
118:58 - map against the latitude and longitude. So that is 
the start point. So that is the center of the map.  
119:05 - And then directions display, you set map, and 
you set the variable map. And then you calculate  
119:11 - and display route. So this is the direction 
service and directions display that we'll  
119:15 - be referencing in this function down here called 
calculate display route. You got some constants,  
119:21 - so waypoints This is the C and D. Okay, stop over 
true. So this is how we're creating waypoints.  
119:28 - And then we calculate the route using this 
function here. So we pass through direction,  
119:33 - service and direction to display. Okay, and 
that's what we call in here actually. So when  
119:37 - we calculate display route, this, these are 
the two bits we're calling, which are here.  
119:42 - They knew straight from Google Maps direction 
service. So we're pulling them through in here,  
119:47 - direction, service dot route. Origin, is 
origin. And they'll pass in through the  
119:52 - destination and waypoints these are the variables 
that we pass through, if you remember to here,  
119:58 - okay, so origin destination and the 
waypoints the constants here. Okay?  
120:05 - That's what Google requires to render this map. 
So optimize waypoints equals true. Travel mode  
120:12 - is driving. And then we've got function response 
status. So if the status is okay, so if it works,  
120:19 - then directions display set directions 
response else, fire off an alert. Okay.  
120:26 - So that's how that works. And that is the 
Google Maps JavaScript. So we need to look at  
120:34 - Google Places API. we'll paste that in 
there. Let's open it up a wee little smidge.  
120:44 - Again, we're doing another get script, same 
thing, no difference. The only difference is  
120:49 - rather than in it map we're using in it or a 
complete, which is just a different service.  
120:54 - Okay, so we let autocomplete so we have that 
here. And then we have an in it autocomplete  
121:00 - function. So autocomplete equals, so we do a 
new Google dot maps dot places autocomplete. And  
121:06 - then we're looking for a, an element in the HTML, 
which is ID Google address, if we look at profile  
121:18 - is here, Id Google address. So we're 
looking for that element. Okay.  
121:23 - types, his address and component restrictions. 
So the country this is where we pass through  
121:28 - the base country. Okay. So this is settings dot 
bass country, and this is currently set to UK,  
121:34 - but if you set it, send it in settings dot p y to 
a different country, then it should technically  
121:39 - work. Okay. So we have autocomplete, add listener 
change places, so every time you change the  
121:45 - address in the input, it will autocomplete. 
Okay, so on place changed. So if you click  
121:54 - there different address, then it will 
run through this piece of logic here.  
121:58 - Okay, so the autocomplete This is as you're 
typing, it will change and predict the addresses.  
122:03 - But if you click the address, it will run 
through this code. So you've got a place  
122:06 - so it's a complete get the place geocoder, you're 
doing some geocoding there. This is why we enabled  
122:13 - that API, the address. So again, we're getting 
the value from the inputs that we just selected.  
122:20 - And then we've got geo coder dot geo code, pass 
through the address. And then if the status is  
122:26 - okay, so if the address is fine, then we get the 
longitude and latitude from the response. And we  
122:34 - add those to the elements that have the ID of ID 
underscore latitude and longitude. Okay, so those  
122:42 - two inputs are now been populated. And then we 
go through this logic to get the street address,  
122:47 - the route the postal code and everything else. And 
we add those to the corresponding elements, okay,  
122:54 - so I won't necessarily need to go through them. 
But with with doing a for loop on a response from  
122:59 - Google, and we're pulling through the street 
number, that route, and saving it to the ID  
123:03 - town, the county, the country, so on 
and so forth. Then we add the address  
123:10 - to, we add the value to the ID address, and 
then we unhide all of the elements. So remember  
123:17 - those everything with a hidden element class gets 
unhidden. Lastly, we fade in. So I do apologize.  
123:28 - You find all of the hidden elements and ignore 
the CSRF CSRF token, and then you fade them in.  
123:34 - That's how that works. I do apologize. And 
then what you do you get the Profile button,  
123:38 - you remove the attribute disabled. And 
then what you do is you submit the form,  
123:44 - okay. So we don't programmatically submit the 
form, we remove the disabled, and then the user  
123:48 - can submit the form. That's how that works. 
So okay, Google Places API j. s, that is that.  
123:55 - And then if we copy over the waypoints 
quickly, we'll just fly through that.  
124:05 - Happy Days, right? Again, another Git script 
difference being here, it's actually is exactly  
124:10 - the same as Google Places API. Okay, very, very, 
very similar. It just this is slightly different  
124:16 - because we are using this JavaScript 
for four different inputs. So had to  
124:23 - manipulate the JavaScript slightly to work. So 
instead of Google Places API, s, j, s, where  
124:30 - there is no auto fields, I've just got A, B, C, 
and D, because we just use them for waypoints.  
124:36 - So again, in autocomplete, so I won't go through 
the logic of adding the address in town and county  
124:42 - to the hidden elements, if you don't need to, 
or getting a longitude and latitude. But you  
124:46 - will see here that what we're doing is, we're 
going through a for loop of the auto fields.  
124:52 - And we're getting a and we're Len looking for the 
ID Google address and we're appending the fields  
124:59 - So this then becomes the, if it's a, it becomes 
the destination, sorry, the origin, if it's B is  
125:06 - waypoint one, if it's C is waypoint two, and if 
it's D is the destination. So this is the logic I  
125:13 - had to put in here to use the Google API on four 
different autocomplete fields. So that's the in  
125:21 - it's autocomplete. And then we've got on 
place change. So again, it's the same as  
125:26 - Google Places API is just I've had to adapt the 
logic to work through and identify the correct  
125:35 - input element based on the field from the or a 
field. Okay, so we're passing through the A, B, C,  
125:41 - or D. And we're looking for ID Google address, 
Addy. Okay. So that's what I'm doing is no,  
125:46 - no different, massive, no massive change 
to Google Places API j s, but then we're  
125:53 - calling calc route, which is down here. So 
this is the function that we're calling.  
125:59 - And this is what we're using to create the URL 
query. Okay. So we're doing an encode you are I  
126:06 - component, so we, what we're doing is, when we 
select those four waypoints, we end up creating  
126:12 - a URL parameter, and we append it to the URL. And 
then we this is actually quite key. And then what  
126:20 - we do is we call window dot location, assign, and 
then we redirect the user to the root URL, sorry,  
126:27 - the map URL, and then we append the query. So the 
query would be something like, boop boop, lat a,  
126:42 - there'll be question I'll start with a question 
mark, and it will be lat, a equals 57.4.  
126:53 - And lasts so long, I hope this makes sense. 
Wood equals four is 5.666312, whatever.  
127:04 - And then it will be joined with a bar. And then 
you do another one and another one and another  
127:11 - one. So the parameter string will end up being 
quite cumbersome. But it will be appended to  
127:15 - the URL and the user is then assigned to the new 
URL with a parameter string. And then in the map.  
127:24 - View, let's review the main, where are we main 
views, you can see that we're actually trying  
127:30 - to pick up that parameter string. So if lat 
a is found in request dot get dot get, then  
127:36 - we can do something with it. So that's 
what we're trying to do in waypoints.  
127:41 - Again, this code is going to be in GitHub so 
you can have a good look. And make sure you know  
127:46 - you're familiar with it. But I hope that I've now 
gone through is deep enough so that you understand  
127:51 - it without going too deep, but I've actually lost 
you. So I will end this section here. And in the  
127:57 - next section, we will test the app and make sure 
it works perfectly. And that will be the end of  
128:03 - the tutorial. So thanks for watching, and I'll 
see you in the next segment. Thank you. Bye.  
128:15 - Everyone is probably from decoded here. And 
in this section, which is the final section,  
128:19 - I will be running through some debugging and 
just general testing of the application to  
128:25 - make sure it works as planned. So that's jumped 
straight into it. If you look on the screen,  
128:31 - I've got my command prompt open I got my virtual 
environment fired up and I'm in the correct  
128:36 - directory. So to the at this point, if you 
were to follow the tutorial on Django Doc's,  
128:42 - you would have been making some of these 
commands right at the start of the project, but  
128:46 - I haven't done them yet. I haven't done it 
for a reason, actually. So I what I like to  
128:51 - do is get my teeth into a project and then start 
making the migrations rather than doing it right  
128:56 - at the start. It's just personal preference 
really. So what we need to do is we need to  
129:02 - make a few commands here. So first and foremost, 
we need to make migrations. So Python managed.py  
129:12 - make migrations these will this will make 
some migration piwi files and a cache  
129:19 - of the model migrations and other bits and pieces 
if it will work. Help us out was a full stop  
129:31 - I Chi so from human friendly import format 
timespan no model names human friendly so  
129:39 - is that let me have a look quickly. I have 
a funny feeling that we need to install  
129:47 - is it's just called human friendly. 
So let's go pip install human friendly  
129:57 - brilliant Make migrations. There we go, that 
worked, then what we'll do is we will migrate.  
130:11 - So if we now open up Sublime Text, you'll see 
that we have a few extra files in here now. So  
130:18 - we've got db.sq, light three. So that's for the 
database. So in users, when I've got a PI cache,  
130:25 - and in migrations, we should have a guy, so 
you got initial. So if we were to make a change  
130:29 - to the model, and then run migrations, again, it 
would then essentially, we just create a new file.  
130:35 - And it will make it make a list of all of the 
changes you're making. And all of the amendments,  
130:39 - all of the creates and updates and things like 
that. Main won't have it will have the poi cache,  
130:44 - but migrations will be blank, because we don't 
have any models. Okay. So these are the migrations  
130:48 - we made, you'd expect it to look like this. So 
we've got dependencies of the off user model,  
130:53 - which we have, you know, that's the one to one 
field. And then you've got the ID, timestamp  
130:58 - Date field, dadda, dadda, dadda, that, okay, 
so that's what we're done by making migrations.  
131:04 - If we now run server, say Python manage.py  
131:11 - run server, hopefully, we'll be able to see 
what the project looks like on our browser.  
131:21 - So let's go Ctrl Shift and 
open up an incognito screen.  
131:29 - Just to level it off a little bit. And 
if we go, local host with Port 1000.  
131:37 - Wonderful, I was hoping that was like that. 
So you can see here that it's gone. Sign in  
131:44 - question mark next. Okay, so the accounts 
page has redirected us to sign in. Okay. So  
131:53 - we haven't got an account. So we will sign 
up. There we go. So object has no attribute  
132:00 - recapture public key. So what have we 
done here? So if we go back into settings,  
132:12 - rights, okay, so we'll call this public key.  
132:18 - And we have a look at my other project 
to see what I did call it. This,  
132:25 - so as weak, there we go. So and that one isn't 
secret key, we need to call that private key.  
132:32 - So okay, so that will now reset the server 
thing that's now working. And if we go back,  
132:39 - this is what you see on the screen here, 
because we've got debug set to true. If  
132:42 - that was set to false, you won't be 
seeing it. There we have it. Right.  
132:46 - That's all our work. And so this is the 
sign up page. Okay, so let's go Bobby  
132:53 - Stearman, username, Bobby at did coding.com 
password, this guy. P word. Let's go.  
133:08 - Password 123455, click Show 
password, it will show that, okay.  
133:18 - 12345. And the reason it's showing that it's 
because I'm toggling between a password field  
133:23 - and a text field. Okay. So that's click Sign up, 
you can see here, the fact that we've got this  
133:28 - reCAPTCHA element at the bottom of the screen, 
which suggests that it's actually working. So  
133:31 - let's click Sign up. I was too common. So you 
need to have a good password. So let's go.  
133:38 - Let's go. Fred. Fred, one. can't assume that's 
going to be very There we go. Thank you for  
133:47 - signing up. So the fact that come up with an error 
and it come up with a message shows that the form  
133:51 - errors actually work in a mixin, which is 
fantastic. So now that we're signed in, we're  
133:56 - now in the accounts page, which is the homepage 
right? If we're not signed in, it will redirect us  
134:02 - to the sign in page. So the username decoding user 
name is Bobby Stearman. Let's create a profile.  
134:10 - So this is the recap, not the recapture. This 
is the Google Places, JavaScript. So Viper  
134:19 - 123. All Okay, that's not working. Okay, 
that's not working inspect, console.  
134:26 - Failed to load resource. The server responded with 
status of 404. So Google Places dot j s cannot  
134:32 - be found. Okay, interesting. So static Google 
Places because it's not get this Google Places.  
134:45 - That right, is that we're referencing 
and let's look at the templates.  
134:52 - And we'll look at profile and what are we looking 
for here? Google Places JavaScript. So that was  
135:01 - a mistake on my part. Okay. So this is all 
part of debugging. So if we refresh the page  
135:07 - that will now go because that file has 
been changed, the name has been changed.  
135:10 - So if we now go 123, this page cannot load maps 
correctly, do you own this website? Interesting.  
135:21 - Then you just keep debug this quickly. Okay, I 
figured out what it was, it was because I hadn't  
135:28 - enabled billing on the API. And you have to do 
that for it to work. So go ahead and do that on  
135:33 - your API keys. So if I now go, 123, there you go. 
And then we'll click Buckingham Palace. And then  
135:40 - we'll unhide all of those hidden elements, and 
we'll click Update. Your profile has been updated.  
135:47 - Wonderful. It should now There we go. Brilliant. 
So use a profile. If we click to that you can  
135:53 - change the address. So as create or update, which 
is great. We then got root. So these are the four  
136:02 - so this is the start address, waypoint. One, 
two in destination. Let's see if this works. So  
136:07 - I'm going to go with Okay, I know that 
address. I'm gonna go with one. Cherry Orchard.  
136:25 - There we go. I will do another.  
136:29 - Okay, one High Street Stretton. There we 
go. No, not that one. One high streets.  
136:42 - Stress him, or click on that one. And lastly, 
we'll go with one marketplace eally. uk.  
136:54 - And now that I've completed all four waypoints. 
Can you see this? So we've got map question mark,  
137:01 - then we've got lat a, and there's got long a, that 
B, long B, C has created that parameter string,  
137:08 - that's what's being used in the view. 
Okay, so we go into the view in Maine.  
137:19 - There we go. So it's picking up all of 
those from the parameter string. Okay.  
137:26 - So we've got start destination, 
duration, distance direction,  
137:29 - that's about right. To be fair, if you're gonna 
do that little route, that's exactly how far  
137:33 - I'd expect it to be. This is the 
map. Sutton had them stratum eally.  
137:39 - Brilliant. If we click on this will this 
work? Happy Days, and that's the directions.  
137:46 - Let's just double check the sign out works. 
There we go. So site this check sign in,  
137:53 - as well. So as Bobby did coding.com was it Fred, 
Fred one, I think our use check show passwords.  
138:03 - Sign In. You're now logged in. Everything works 
to plan on over the moon. So there we have it.  
138:10 - There's your Django app that works with two 
Google API keys, and six different Google API's,  
138:17 - one of which is recapture. And the others are a 
whole bunch of maps API's. So we can do predictive  
138:23 - addresses. We can use maps, we can use waypoints. 
It's fantastic. And it looks pretty good as well.  
138:31 - So you can find this code on my GitHub, the 
GitHub repository link will be in the description.  
138:38 - Thank you for watching, and I will be seeing 
you in the next tutorial. Thank you. Bye bye.

Cleaned transcript:

Learn to use a Django with six different Google API's in this core from Bobby Stearman. Hey, everyone is Bobby from decoding here. And in this course, I will be walking you through and showing you how to build a Django app that uses six different Google API's. So let's start with the walkthrough. If you look at my screen, you can see that I've got the app open already on the sign in page. So if we click on sign up, because we don't currently have a user account, there's Bobby stemmen. And we'll have a username This must be an email, Bobby at did demo.com. password, I will use Fred Fred one. Confirm Password, Fred, Fred one, we have also got a show passwords toggle, it converts a password input to a text input. So you can see they match. If I click Sign up, when I click Sign up, we will be using the recapture version three software. This is a Google product that scores a form submission. And the higher the score, the more likely it is that is a real human being that is actually submitting the form is great. The fact we've got this element in the bottom right of the screen would suggest that the software is working. So this sign up should get a message that says thank you for signing up and will then be redirected to to the user account page. The user account, the user can then update their profile with an address. And this is where we use the Google Places API. So it is predictive. So as I type into the input, Google will predict the address in the country that is predefined in settings, dot p y, and give you a number of different addresses that meet the search. So let's go with 123. And that's coming up with a few different addresses this go 123 Victoria Street, as I click it, it will pre populate some hidden inputs. And then I have the option to update. Your profile has been updated. Okay, so that's one of the API's. The other one is in route. So this app will allow you to put a starting point, so an origin, a waypoint, one, a waypoint, two and the destination. And when we submit this, or actually, when we finished the fourth input here, programmatically, it will create a parameter string and redirect us to a different URL, and it will render the map. So let's add a few addresses. So we'll go one, high streets, Sutton eally, they'll have another one high one High Street, had them easily. So this is all around my local area. Then we go one, High Street, stratum ealey. And then lastly, we'll do one marketplace. easily. There we have it. When I click this, it will then say right, you have completed all four waypoints. And if you look at the top here is create a fancy parameter string, but the URL is map. So it shows the start and destination longitude and latitude, the duration from the origin to the destination, the distance between origin and destination, and then it will render a map, which is brilliant. And if I then click, click here for directions, it will then unhide some elements in HTML. And it will show you every single step that is required from the origin to the destination. So that is the application that I've built. This is the one that we're going to go through in this course, I will go through every single step that is necessary, right from enabling API's at Google and recapture starting a new project, building the back end building the front end and fully testing the application. So without further ado, let's jump into section one. Hey, everyone is Bobby from decode in here and in this segment, we will be setting up to Google API keys. These API keys will allow us to interact with six Google API's. The first one we'll be looking at today is something called google recaptcha. Now, this is software that stops malicious software from interacting with your website. So essentially, it keeps the riffraff out, and allows real human beings to submit forms. Now you will have come across this before in other people's websites, you will complete a form and when submitting that form, you'll be presented with Nine images and asked to select any image that may contain a bus, or a plane or a motorcycle. And if you select the right images, you can then submit the form that is a challenge based form submission. And this is version two, we won't be using version two, today, we'll be using version three. Now this is not challenged based. Instead, Google scores each spawn submission against certain criteria. Now, the higher the score, the higher chance it is, that is a real, live human being some in the form and not some malicious software. So that's what we'll be setting up today. And after that, we will then go to Google Cloud, and we'll be setting up another API key that will allow us to set up by an enable five API's places, directions, Distance Matrix, geocoding, and Maps JavaScript. So let's jump straight into it and set up recapture. So if you look at my screen, it opens up in google.com, slash recapture slash about on this page, you will find all the information that you need to find out a little bit more about recapture. But what it does some use cases and also the history because it has evolved over the years, when on this site, ensure that you've got a Google account, you will need one, click on the V three admin console. You can see here that I've got six sites, I've been using this for some time, and a lot of my clients like to use recapture. But whether or not you've got this set up on your machine already, you do need to follow this process. So you need to click the little plus button here, which, which is to create a new site. So let's create your site. And we will call it Google Django tutorial, we will nkuku reCAPTCHA version three. Again, it says verify request with a score. This is what we want version two verifies request with a challenge. So we'll click on version three. And then you need to add the domain. So we're doing this in a development environment. So it's on my local machine, and we'll be using Django. So the domain in this case is localhost. You don't need to put the port of a spa that right now I have a local post. And then click Accept. And submit. There we have it. So it creates a key and a secret key are working with API's. If you've done this before, you will know but if you haven't, I like to look at the API keys as this. an API key is the equivalent of a username. And API secret key is an equivalent of a password, just try to keep them secret, because you don't want people getting hold of your keys and making calls fictitiously. So there's copy the site key, I like to just dump these in a notepad so I can use them later. I've got one open here. So we capture underscore key equals, and we'll paste in the key back to the website. We'll copy the secret key. And we'll dump that here as well. You can see here I've got another one called Google equals that's the API key we're now about to set up. That is all we need to do to set up recapture. The rest is done in the code in Python, or in this case, the Django web framework, which we'll be setting up in the next segment. So we'll continue now. And we will set up the Google API key that will allow us to work with places directions Distance Matrix geocoding, and Maps JavaScript, what you need to do is visit the website cloud.google.com. And this is the website. You will need a Google account. You can see I've got my icon there, my logo, and setup is decoding. When set up on Google, you need to click on console. It will take you to your console home. And then you need to set up a new project. So if you just sit Look what I did there. on here, just click the pulldown list. And then you can set up a new project. And we will call this Google Django tutorial. Click Create. And then when it's finished doing that, you can then select the new I was just doing it's doing its magic. only take a second. Okay, that's complete. So now click the project that we just set up. And this is the new Google Django tutorial home. You now need to click on API's and services. When in there, you do have the option to click Enable API's and services. But first off, we need to click on credentials we need to set up the API key click on click banjos. This will be an empty blank slate, we now need to quit click on Create credentials. This will allow us to select different options. But the one we want today is API key, click on the API key. There we have it, copy the API key. And save that in the notepad. There we have it back to the website. Close. Now, we haven't named it, we can name it by clicking this little pen here to edit the API key. And in here, you can restrict the API key to certain IP addresses. Change the name, which we will this is Google Django. tutorial key. And save. By the time you see this tutorial, This tutorial will be dead, ie will be removed from Google. So there's no risk here. That is the key, we've set up the key now we now need to enable the API's. So if we go into the dashboard, again, this option here, so plus, enable API services there. And because maps are the most popular API service that Google provide, it's right at the top, click on View All 17 there's quite a few of them. The scroll down is a whole bunch of different API's here. The first one that we need to look at is Places API. I won't go through what each of them do, specifically, but each of these in your own time, click on them, and it gives you an overview of exactly what they do. Now places will be using that to pre populate addresses when creating an account in our project. So you start typing an address, and it will predict what the address is that you're looking for. And you can just select it, and it pre fills all of the address, the town, the city, the county and postcode, and so on and so forth. And you can always pull from that the longitude and latitude, which is very, very helpful. So let's click Enable. That will take a second. And now that that's completed and enabled, we now need to look for the Directions API. So you can go back to the overview and click on enable API's and go back to the main dashboard. But because we've enabled one now, it then gives you some options of other API's that you can work with. So let's look look at Directions API. click enable these next API, so the directions the distance, the geocoding, and the maps, JavaScript, these are the API's that we're going to use when working out different routes and distances between two geo points, so to longitude and latitudes. So that is the Directions API, we now need the distance matrix. We'll enable that quickly. Some of them are quite self explanatory, to be fair. The next one is Google geocoding. Well, lo and behold, that allows us to geocode certain points. So geocoding API will enable this. Lastly, we need to find the Maps JavaScript API, and enable that. And that will allow us to write some JavaScript to actually make the calls themselves because we won't be making API calls from Django, the calls themselves will be handled in JavaScript. So let's click the Maps JavaScript API. Enable. There we have it. So just to recap, In this segment, we have created two API keys. One of them is with google recaptcha version three, this will allow us to ensure that real human beings are submitting forms on our project and stop the riffraff from submitting those forms. And then we've created another API on Google Cloud and enabled Google Places Google directions Google Distance Matrix, Google geocoding, and Google Maps JavaScript API's. This will allow us to have our users complete or start typing their address, and it will predict where they live and they can select an address. And also they can then add two different points. So two locations in any given country, and our project will then calculate the route and distance between those points. Okay, that's the end of this segment. Thanks for watching. That starts setting up the project in the next segment. Thank you. Bye, bye. Hey, everyone, it's Bobby from decoded here. And in this segment, I'm going to show you everything that you need to do to start building this Google API app. So we will be using a Python web framework called Django and we'll be working through how to start a new project how to create an app, how to configure Get some settings and static files such as CSS, JavaScript and images, and also playing around with the URL comp. Now, if you're familiar with Django, you will know what that all means. However, if you are an absolute newbie, I will just show you quickly, a little bit about Python and Django, and a library that we'll be using, which is virtual MV wrapper dash when in my case, because I'm using a Windows machine, so if you look on my screen, I've got the Python website open on their downloads page. If you haven't got Python downloaded on your machine, you will need to do it, I do have a link to a video there's at the top of the screen now that will show you exactly what you've got to do to install Python and also configure a library called Virtual envy wrapper. And that is this page here. So it is on a repository in pyp.org. Like I say, look at the video, walk through all of those steps, get Python installed on your machine, get virtually a V wrapper installed on your machine, and you'll be good to go. The third tab here is the Django project.com website. So this is Django web framework. So it says here that Django makes it easy to build web applications more quickly with less code, that is exactly what it does. And that is what attracted me to Django about five or six years ago, I've been using it for quite some time, it's easy to learn the documentation is absolutely fantastic. And they've got quite a good tutorial on the actual website we need to do is click on the Get Started with Django, link here, and away you go. But that's what we'll be using in today's segment to get started. So what we'll do, we'll start off by opening up a command prompt. And if you've already set up virtually a and V wrapper, then you can start using certain commands. That's why I asked you to follow that video. Because if you hadn't set up virtually a V wrapper, then you wouldn't be able to use the same commands that I'm going to use today. So what I'll do straightaway, I will CD into my development directory. And what I would do is I set up a new virtual E and V. And the way you do that is MK virtual e m v. And then with a space, you then name this E and V. So we'll call this the same as the project. So we'll go did Django Google API tutorial. Okay, click Enter. And that will outdo all of the necessary configuration on your machine. And it will set up a virtual E and V. So what I'll do, I'll show you quickly was that that has just done. So if I click on my directories here, we go into my own. So if we're going to Bobby, which this is the default configuration that will set up an E and V file in your user directory. So you can see here that I've got envies, and I've just set up did Django Google API tutorial. If I open that open lib site packages, these are all of the site packages that we Python will need to work. So these just come straight out of the box. So when you set up a virtual E and V, this is what you get. We will then be installing Django and a few other libraries and they just get added every time we pip install a library. It gets added into our virtual E and V. So that's what we've just done by adding by using make virtual E and V. Go back into our command prompt. And what will now do is we will pip install Django for plus enter was asked, so I probably glossed over that what but the command PIP is essentially as a standard package manager, and allows you to install and maintain packages for Python. So we use pip install to install certain packages from public repository such as p ypi. And I've just pip install Django. If I go back into my envy directory that I've shown you a moment ago, you can see now that we've got Django package here, and within Django, it comes straight out of the box, it comes with a whole bunch of different directories, and models and views and all sorts and that is essentially how Django works. So we'll be making calls, creating models, creating views and forms. And it all interacts with these directories and files here. So we've now got a virtual environment all configured and Django installed, we can now start a new project. So you need to type Django dash admin, and then call start project and then you need to name the project. So we'll call it exactly this. Same as the development environment or virtual environment sorry, did Django Google API tutorial? Okay, that should have done it. So if I open up my directory again, there we go Bobby development. And in here we've got did Django Google API tutorial, open that up. And this is what comes straight out of the box, we've got a manage.py file. And then we've got the main comp directory here, enable settings URLs, you got ASCII or whiskey and you've got an init, Dunder init file there. So that worked very, very well, we now need to create our first app. So Django will allow us to have numerous apps running within a project. So what we need to do is open our command prompt back up, and we now need to CD into did Jango. Google API tutorial. And now that we've got the project there, we can now access the manage.py file. And that is the manage.py file that is in a main project here. So we make a call to manage dot p y. So we say Python, manage dot p y start app. And we'll call this one main. Okay, great. I opened up my directory again, we now have an app in here called main. And straight out of the box, it comes with a few files. So you have an empty migrations directory. That is what's used when we're creating models. And you migrate those models to a database, we've got an admin file an X file, we've got models file, this is where you house all the models for the project, tests and views, we will we'll create one or two other files, but this is what comes straight out of the box. We're now at the point where we're gonna start writing some code. To do that, we will need a text editor, I use Sublime Text. But there's so many different text editors out there, use the one that you like the best, and then you can start coding. So what we'll do, we will open up Sublime Text in our directory that we just created did Django Google API tutorial. So there we have it. This is the project in Sublime Text, you can see we've got our manage.py file here, we've got the main project directory, which we can open up and you can have a look at these files. And then we've got the main app that we've got here, we will be focusing our time in settings dot p y, and you are ELLs dot p y today, which is the URL comp file. So we'll open up the settings dot p y, first and foremost. And if I scroll down, you've got whole bunch of code here that comes straight out of the box of Django, this is very, very standard. We do however, need to change some of this code. And that's what we're going to do right now. So at the top of the settings.py file, here, you have from path lib import path that is required. But we also need another import. This is import OS for operating system. This library allows us to access things like environment variables, okay, and we'll scroll down a little bit further. If this if we were building this in a production environment or for a production app, then I would do something with a secret key here, I would use libraries such as Django decoupled to remove sensitive information from the project. But as we are not doing anything like that, and this is just a tutorial, I will just leave that as it is. So if you scroll down further, again, we've allowed hosts that is something more for production. You've then got installed apps. Now these are the installed apps that come straight out of the box. But we have created an app here called may have you look in apps, the name of this is main. Okay, so that's what we need to reference in settings dot p y. So if we enter a couple of times, just add a little bit of whitespace. Just add a string called main, and then a comma, a trailing comma. So that is selling Django that the app that we've just created is actually included in the project. Then if you scroll down a little bit further, we've got middleware. We won't be playing with that here. But there are some libraries that we require or other applications require. And they do need you to have some middleware alterations. Routes URL comp, don't need to change that templates. We won't be changing that whiskey application, no change, no change with database either. Now, if I was to make this app for a production application, I would probably use database such as PostgreSQL. But we would just be using the database that comes straight out of the box is no harm in that So, language code, it defaults to en us, I am in Great Britain, so en GB. And then at the bottom here we've got a variable here called static URL. Now we will be creating this app and it will be looking fantastic. To do that, we need to be using files such as Cascading Style Sheets, or CSS and Java scripts or j s files, and also images such as logos and things like that. So we do need to configure static files in the settings dot p y. And how we do that is we add a variable called static files underscore does. This is a list. And in here, we have we call the OS library that we just imported. path, which was also important at the top of the page. And then we joined, and we joined the base directory. And we call it static. That is the only change we need to add here for static files does the static URL remains the same, but we also need one in here called static route. There we go. And this is OS dot path, dot join dot, then bracket and then this is again based Dir. But this one is static. CDN. Okay, they are the only changes we need to make to Settings dot p y in regards to static files. You need these variables for it to work and serve CSS and JavaScript files to the project to the front end, I won't do any more of a deeper dive than that. We do now need three more variables. The first one will be called Google API key. have that as an empty string for now we need re recapture. Cool, that recapture key again, empty, and we'll have recapture cool, his secret key secret saved with a secret key. There we go. And what I'll do, I'll open up the notes that I made in the last segment. And we need our it looks like I didn't say the secret key. But we will get that. We'll save that now. This was the Google API key. There we have it. And the secret key I'll have to get from recapture in a couple of moments. In fact, let's do that now. Capture. One of the sites that we were doing was this one here, Google Django. And I believe we're going to settings keys that we have. Okay, we copy the secret key. Go back into our project. And we save that and recapture secret key. There we go. That is settings dot p y file complete, we don't need to do any more configuration in there. The next change is in URLs dot p y. And what we need to do in this file is we need to have the path we need to bring it include we need from django.com. Now when I'm referencing Django directories, I'm quite literally referencing them in the MV file. So go back in here, lib site packages. Remember when we were setting up the virtual environment, if we now go into Django, and in the project here, Django dot URLs. We go into Django and go into URLs. We're referencing these files here and functions and classes within these files. That is exactly what we're doing. That's how we're importing them into the project. Okay. So from django.com import settings. So we're now importing, amongst other things, everything that we've got in this file here. Then from Django, dot content, dot URLs dot static, import, static that looks right. Okay, so we need Django comes with admin. And I've been paid already straight out the box. But we do need to add a another path here. And that will be to our main app URLs that we haven't added that file yet, but we will reference it now. So is path. And what we need to do is use that include that we've just imported. And its main, and we'll have a file in that main app called URLs. And then we'll use namespace equals, this will be called main. Wonderful, they're the URL patterns that we need. We also need one other setting in here for the static files. And what we do is if settings dot debug, we're referencing debug, which is in settings.py, at the top, so it defaults to true. So when when in development, when debug is true, when you have a problem with your code, or come up with the error on the screen, which is very handy, but you don't have this, you would not have debug set as true in production. So if it is set to true, which it currently is that we need to add to the URL patterns. And how you do that is URL add equals static, that is the library that we've got here. And then we want settings dot static URL. And then we want document route. Equals settings dot static route. And that is it. So the settings dot static URL, that's what we set up in the settings.py file. So the static URL, and the static route is also this one here that we set up as well. So we have now set up the settings dot p y, and the URLs comp file correctly. And that should now work. One last thing before we close off this segment. And that is the we're referencing a URL file that is not there. So if we go into main, new file, and we'll call this you are ours dot p y, we will create the necessary list that is required for URL convert. So we'll say from Django dot URLs, import path from Dart, so this will be referencing a views file, which is here. Import views, so we'll be importing everything from views. app name. So this is what we called the app as a namespace in the URL comp, main. And then we want you are l patterns equals, and that's an empty list. We will add to that in another section. Okay, so just a recap on what we've gone through today. We have set up a new Django project, we've created a new app, we have adjusted the settings.py file, we've configured static files in the settings and URL Comm. And we then added the URL patterns in the URL conf as well. So we are now good to go. We are ready to start coding this application. And we'll be doing that in the next segment. So thanks for watching. See you soon. Bye. Everyone is published and decoded here. And in this section we'll be following on where we left off from the last one where we started a new Django project. In this section, we will be fleshing out the back end. What I mean by that is we'll be creating some models, or one model, actually, you know, we use a profile model that extends the built in user model that comes straight out of the box of Django. The reason we're doing this is because we want our users to have the ability to sign up and sign in and create your profile. This is how we will be using the recapture API and the Google Places API. Okay, we'll also be creating some form some views and URLs and some mix ins for views. those meetings will essentially help us make our code look a little bit easier to read. And those mixings will be recyclable. We can use them in other apps as well which is great. And then we'll also be creating the template directories so this will be regarded as the back end. In the next section, we'll be looking at the front end which is all about HTML files, CSS, Cascading Style Sheets, and JavaScript. So without further ado, let's jump straight into it. You can see on my screen here that I've got four tabs open all of them on Doc's dot Django calm dot com. Like I said in the last section, the Django documentation is second to none. And I wanted to just go through this quickly because we are working with models, we're working with signals, model forms and views. So for those that are absolutely, well, they're newbies at Django, this is going to be quite helpful. So what is a model, a model is a single definitive source of information about your data contains the essential fields and behaviors of the data you're storing. Generally, each model maps to a single database table. So models translate to database tables. Like I said, in the last video, we'll be using SQL lite, that comes straight out of the box of Django, you can upgrade to something like PostgreSQL. But we're not in this app. So when we're building our user profile model, we'll be using things called model fields. And the most important one, we'll be using char fields and float fields and things like that. But the most important one that we're using is the one to one field, which links the user profile to the built in user model, which comes straight out of the box with Django. And we'll be creating the user profile using signals. So that's models, very, very quick top down view models. And by all means, have a good read of these docs pages when you have a bit more time signals. So we'll be creating a signals.py file. This will be handling the logic of creating the user profile when a user is created. So we'll be using post save and receive a decorator. To do that. I'll show you what that all means when we get into it. Next, we've got model forms. So we are creating model form. So this will be a model form linked directly to the user profile model. We will also be creating two other forms these forms will inherit from some built in class forms that Django has straight out the box, one of them is a user creation form. And the other one is an authentication form. These forms handle the logic of signing up and signing in perfectly. So it just means that we haven't got to handle all of that logic, we can just call form dot save. And it does all of that in the background, which is great. Django is all about getting as much output with as little input as possible. So if we can get away with using some built in models and classes and forms and things like that, we will. So yeah, like I say, we'll be using the user creation form to build a user form. And we'll be using the authentication form to build an auth form. And then we'll be looking at view. So we'll be creating class based views and function based views, I do find that some tutorials online focus on one or the other. And when you're new to Django can be quite confusing, especially if you've been focusing your attention on function based views. class based views then look a little bit alien. So I'm doing a bit of both in this tutorial, just to help you new newbies out there. So let's jump straight into it. You can see that is that is where we left off. Yeah. Okay. So if we open up our command prompt, you can see that I've got my virtual environment fired up, and I'm in the correct file. Now, we will be working with API's. As you know, that's the whole point in this tutorial. And in Django, there's a great library called requests that help us out massively with API calls. So all you need to do to install it is use the PIP command. So pip install requests. Great. And that will now be in our E and V file that I showed you two videos ago. Now what we need to do is start a new app. So we go Python manage.py start app, and we'll call this users. That's great. If I now look in Sublime Text, you should now see a user's directory, which is great. It's pretty much blank, but we'll start fleshing out in a second. So the first thing we need to do when we start a new app is going to set this dot p y and register that app in the installed apps. So users training comm comma, and there are a few other variables that we need in settings dot p y that I forgot about in the last section. So we'll do that now. I will be copying a lot of code from my other screen in this section, because it will save a lot of time it will make for a much shorter section and I will hopefully be able to hold your attention for a little bit longer. So as we are using sign up, sign out, sign up sign in and sign out logic, we will add some variables in settings dot p y is a login URL. So this is where users will sign in. So we haven't created this URL yet. But we will in this section, we've got a login redirect URL, which is account, this will act as the home page. Now, there will be a decorator. So a login required decorator on that view. So when somebody visits the homepage or index page, it will redirect them to this sign in page. But that works for this app. So I've kept in here. And lastly, we've got a logout redirect. So when somebody signs up it redirects that user to sign in. So they're the three variables that we need in settings, dot p y. And there's one last variable before we move on to the URL comp, and its base country. So the JavaScript that I've got in his project uses a country code. And it uses that code when predicting addresses for the Places API. So you can change that to something like fr for France, and other country codes. But it just means that we can change it in the settings without having to change it in the JavaScript. So now we need to go to the URL comp file and add users to the URL pattern. So we'll do that quickly. Just copy it down, there's no need to always type it from scratch, or though it does help when learning Django. But my typing is terrible. So I tend to litter this, these apps with typos and it causes a whole range of issues. So that is all we need to add into the URL comp file that's saved. So it's setting so we're close those. And now what we need to do is go into main URLs, and what what they will copy this across to users into a new file, we'll change the app name to users. And we'll save this as URLs dot p y, because we're referencing that in URL comp, p y. There we have it. Okay, so now we're good to go, we are good to start the models now. So we are not creating any models in Maine, Maine is going to be used for a few views, such as routes and map. And users will be handling all of the authentication logic. So we'll add the models in here. So if I just take my code, and I will copy and I'll quite literally dump it in here, and then walk you through what I'm doing. So the from django.db import models that come straight out of the box, and then we're installed. So we were importing user, which is the built in user model that I keep talking about. So you will get used to right in there. So Django dot contrib dot auth dot models import user, I normally have that in every one of my views. So so you get used to write that quite a lot. We then have the user profile, which is a class and any password models dot model. In my models, I generally have a timestamp and an updated this allows me to track when a model has been created. So we use the auto add also in auto now add equals true. And the updated is also now so every time a profile is created, this will capture the date time. And every time a profile is updated, it will also create the it will keep updating this field with the new date time when it was when it was updated, then what user This is the important and this is the one to one field that I was talking about, you pass through the user model. And then you also have underlay equals models dot cascade, I move this across it, you can read everything. So that means if the user was deleted, then this user profile would subsequently be deleted as well. So there's no profile in the database that isn't linked to an actual user, you can also have something like set null in there. So if the user was deleted, this would still be in the database, but it would be null. Next, whole bunch of char fields. With left, these are these will be created as nouns analogous to blank users equals true because users will add an address once they've signed up. So we have a char field for address, Max length 100, you have to have that in there a max length keyword, because otherwise it just won't work. And we have town County, postcode, country longitude and latitude. They're all populated when a form is submitted from the front end, which we will be looking at shortly. Capture score that is the recapture score. So when it for me, when somebody signs up, we will be using the recapture API to score the submission, the higher the score, the more likely it is that is a real human being that score is pass through and save to this field as a float field. The highest you can get is 1.0. So it defaults to 0.0 has profile is a Boolean field. So it's a simple true false, it defaults to false. So when a user signs up, they do not have a profile when they add an address and longitude and latitude. This will then be changed to true. Lastly, we have an inactive Boolean. I always have this in my models is defaults to true but we it gives you the option to change this to false If ever you want to close a model down. And lastly, we've got a Dunder string function, pass resell from was returning an F string self dot user. Okay, so that is the model. Like I say that translates straight to the database. So when we make migrations and migrate, that will become a database table. So that's our model. We now need to create some forms. So if I click add new file, and save as, and we'll call this forms dot p y. There we have it. So we've got three forms a user form, an off form, and a user profile form. So we're important a few bits and pieces here, let me make it a bit easier for you to see. So we're importing model form, like I say, we've got a couple of built in class forms that, that come straight out of the box user creation form and authentication form. Again, we're importing the built in user model, and then we're importing form from Django, and lastly, the user profile for models that we just created. So that's all we need in this file, we've then got the first user form, this is inheriting the user creation form. Okay. So you what you need to do is create a few variables. So first name is forms, character fields. So as a char field, Max length 30. This is exactly what the field is like in the built in user model. In fact, then we start with the user profile form, it might make a little bit more sense. So this is just a model form, but they're more or less exactly the same. So address, you can see here, this address is relates directly to the user profile address field. And again, it's a character field, which is the same as in the model, the max length is 100, that matches what the max length is in the model. So we tried to keep model forms identical to what they would be in the model themselves, we've got required true, so this field must be completed for the form to be submitted. And then we use visit a socket widget equals form. And this is going to be a hidden input. So the widget in a model form that kind of translates through to HTML elements. So this will create an hidden input element, and it will be rendered through on the HTML file. So you could also have text input, you could have password input, or you could have a whole range of different things. And you can also pass through things like classes, and placeholders and things like that. And that's how we can change the way the form looks on the front end. Because a very, very basic form from Django doesn't look too good unless you actually add some bits and pieces, such as classes and IDs and names and then add some CSS. So this is the user profile form, aka says a model form, we've got address, town, county, postcode, country, longitude and latitude, they will be the input elements that will actually be hidden on the HTML file, then we've got class matter, the model that we're linking this to is user profile, and then we have a tuple in fields with all of the field names. Okay, so that's the user profile. So I'll start there. And then it will let make a little bit more sense when we look at uniform. So like I say, inherits from the user creation form. So the first name very much like the user profile form, we're using a char field max length is 30. Because the built in user model, first name field has a max length of 30. Again, rich required True, and in this widget is a text input, and we're passing through as an attribute placeholder is your first name, we're doing the same for last name, except we're changing the placeholder, the username is actually an email field in this case, so when somebody signs up, the username is an email rather than just a normal username. And then we've got password one and password two. So in this, you can see we're actually we're passing through a class as well to the attributes as because we can then toggle between a password input and a text input. So there we have it, we are then adding a token field. So this for the reCAPTCHA token, it will be a hidden input, but that will be capturing the token when we're processing the form using reCAPTCHA. version three, then we've got meta class models, user and fields are, as you can see, here, they're the same as what we've got above, then we've got your form, your form is a little bit shorter with a username and password, email field, which we have a text input and a char field with a password input. And again, by inheriting from the authentication form, that means that when we call form dot save, it does all of the logic in the background, which is fantastic. So these are all forms, we don't need to mess around with them anymore. That is, that is it for this project. We don't need any more forms than that Figes, open that up there. The next thing we need to do really is create the mix ins. So let's go ahead and do that. And we'll add them to the main directory to a new file. And we'll save that as mixings dot p y. Again, I'll bring it straight from my other screen here. And paste. Okay, there's some pretty one of these is called directions is a function that we're going to be using to make API calls. So these are quite important. So we'll go through these we're bringing few through a few things are From Django, one of them is a well from the EU, this is from URL lib dot pass where important URL encode this is for a redirect function of God, which I'll go for in a second. But you can see we're importing requests, because we'll be making an API call. And as a few other bits got Jason daytime got format, timespan for the Directions API, and also JSON response, because we're making a mixin. For Ajax. So this is the form errors. function. Now I use this kind of default that I use when I'm processing forms. So if I ever overwrite the form valid method there, and if there's an error, then we call the form errors. And it essentially returns a string of all of the errors that you can pass through to the front end, which is quite handy with Ajax. The next one is a function called reCAPTCHA. validation. And we pass through the token, this is the API call to recapture. So the token is passed through from the front end in the view. And we create a variable called results. And we're doing a POST request to this URL. Okay, so it's google.com reCAPTCHA, API site verify. And then we create a data dictionary. And in that dictionary, we pass through the secret as a keyword. And this is the recapture private key that we've got in our settings. And also the response, we pass through a token. That is the API call is very, very easy. And then we return result dot Jason. So we just saw notify the response. And that's what we use when we're creating views and a few minutes. This is a great function. So what this does, it uses the URL in code. But if you pass through parameters, and the URL to this function, essentially returns a string that can be appended to a URL, and the string will look something like color equals blue. And size equals large, okay, and that that parameter string can go, you can have a whole range of different parameters in there. But it just means it can be appended to a URL, and then when redirected to that URL, you can do something with those parameters using request dot get dot get. And we are actually using that in this app. So that's a great little function that we use. So this is the AJAX for mixin have gotten this is kind of the default mixing that we use, although I do overwrite the form valid function quite a lot. But I've written this for AJAX call, so we can Ajax or five form submissions. This means that on a front end, the HTML doesn't need to reload. So you submit the form, you get the response, and then do something with it. And you can change bits and pieces using JavaScript. So I've got this as a way of Ajax of fire in Django forms. So we've got form invalid method, and we've got form valid. And both of them are returning JSON responses to the views that we will be using it. Lastly, we've got the directions function, passing through arcs and keyword arguments. Then we've got a whole bunch of variables here. So from the keywords, we're getting lat, a long a and a whole bunch of other longitude and latitudes. So lat a and long a, that's our origin. So that's where we start in terms of waypoints. B is where we end up so this is our destination. And then we've got C and D. These are the waypoints now I've limited this to two waypoints. So in total, you've got four different destinations. But there's no reason why you can't have more, just in this app, we've got two. So we've got a start two waypoints and a destination. And these three variables are using f string to create strings from these variables here. So that origin will look something like five 7.17 4.6. Yeah, that would be the string for origin. Okay, same with destination. But with waypoint, you can see we're connecting with a bar, then we are using requests dot get. So this is a get request. And we're saving this in a results variable. So we're making a get request to this URL. And then we're passing for a parameter dictionary. We pass through origin, password destination, and the waypoints. And then lastly, the key. So this is the Google API key that we looked at in the first section. Okay, directions, this is just trying to find the results and saving it in a new variable. If directions has a status of Okay, then we work through this logic here. And then we would turn all of this so it returns origin so the origin is actually outside of the if statement there. So it returns them regardless. So if it's okay, we look for the roots and legs keywords in the Jason file. We won't go through that yet. But during this, one of the sections, I might show you what the JSON response looks like. Then we, we stipulate a distance, a duration and a route list here. And then we cycle through all of the legs. And we keep adding and adding and adding the distance, the same duration. And that's what we're passing through to return statement here, the duration here, you can see actually, that we're using format timespan to reformat the duration into something we can actually do something with. Okay, so that is all they are all of the mixings. We don't need to look at them in any more detail, but we will be using them in the views. So if we go back to users in views, if I now copy all of my views. So we've got a few views here, let me minimize them to make it a little bit easier on the eye. Like I say, I've got some class based views. And I've got some function based views. These are class based views. This is inheriting from template view, you've got sign up view is also a class based view. And we're using form view with the AJAX mixin. Same as sign in, sign out, that's just a function based view, and so is profile view. So it's right mixed bag really. And hopefully, you can understand the different logic. We're bringing in a whole bunch of bits and pieces from Django. So we've got render redirect, reverse, we are using the login required decorator. So that stops people that haven't been authenticated from seeing certain things in views, import bringing in user the built in user model. We're then using login, logout on authenticate, these are fantastic. They does all of the heavy lifting with the authentication of users. We're bringing in settings, settings, JSON response. And then these are the built in generic views. We've got form view, template view. And lastly, because we're using login required on a class based view, we need to bring in method decorator, we're then bringing in that's the wrong name that needs to be tutorial. We're now then bringing in the mix ins that we just built, and forms. Okay, so let's start quickly with account view. This is the home view that it will be. And it's inheriting from the template view. So this is a template class view, we need to call the template name or create template name variable and stipulate exactly where this what the where we're going to render this view. And this is going to be in the users account that HTML, we haven't created that HTML file yet, but we will in the next video. Then as the next segment, then what we're doing we're overriding the dispatch method using the method decorator and passing through login required. So this by this little piece here, the three lines of code here, what that will do that will stop anyone that hasn't been authenticated from seeing this view. And if they haven't been authenticated, because we've got this in view settings.py. So we've got log, login redirect URL, sorry, the login URL, it will be read, the user will be redirected to this URL. So if somebody goes to account and they're not signed in, they will be redirected to sign in when they sign in, and it works, they'll be redirected back to account. Okay, so that's how that works. So that's the account view. We then got profile view, which is function based view, what we're doing, we're creating a couple of variables, we got user and user profile from request. The form is the user profile form, and we password instance equals user profile. These two here, I will remove and I'll add at the top of the screen, so they're kind of global. And we'll make that capital. So these are the default messages and results because we're Ajax refine the forms. So this will be password, if ever, there's an error, and that will be shown on a front end. So as we use an Ajax to submit the form, we've got f request.is. ajax, then we do something else. It's a get request. And then we pass through context, a context dictionary. So we've got form, which is a user profile form. And then we add a couple of key words. The first one is Google API key, and the second one is based country from settings, okay. And then we return render the profile HTML file, and we pass through the context dictionary. That's how you pass the context in a function based view, slightly different in a class based view, but I'll come on to that in a second. But if it is Ajax, then the form is user profile form, and the data equals the post data from the request. And the instance is user profile. If the form is valid, you save the form. And remember, when I said we were going to add when we add a profile, we then toggle the Hasbro profile field to true. So that's what we're doing there. So once we've added the address and longitude latitude, we then save has profile is true, and we save the object again, we pass through Success, the message is your profile has been updated. If elsif is not valid, we call the form error function that we created a moment ago. Then we create a data dictionary result equals result and message keyword is message, we pass it through back to the front end as a JSON response, passing through the data whistlestop tour of the profile view, but that that is essentially how we are handled in the setting up of a profile against an account. Then we've got a sign up view. Look, we've got Ajax mixing, let me just bring this across a little bit, but the AJAX mixin. And we've also got the form view. So as a form view, you need to say what the template is that we need to render to, which is a sign up HTML. The form class is the user form that we built a moment ago, and a success URL can just be a slash, we are using Ajax to submit the form. And depending on the response we get from the back end, we will then redirect or not. So we won't be using the success URL, actually, but you do need one because we're using form view. Again, we don't need that I've already got that at the top of the screen, then what we've got is recapture. So remember, I said we were looking at we password context and function based view like this. Yeah, as a dictionary, in a class based view, you need to call the get context data method. And then once you've called that, you then can add a keyword to context and return context. So we're adding recapture psyching to context, and that is the key in settings. And then we overwrite the form valid, the form valid method in the AJAX mixin. And we do that because we need some new logic here, because we're dealing with recapture. So we, we call this if self dot request is Ajax. So if this is an AJAX call, then what we do is we get the token from the clean data from the form. So this is the hidden input that we had in the form, then we call the recapture validation function that we created in mixins. And we pass through that token, okay. So depending on the response, if it is a success, then we sign that user up. Okay, so we save the form, remember is, the form has the user creation form, which does all the heavy lifting, like I say, so we just need to save the form and it creates that user and user profile with a signal, we save the email. So we save the username to the email field, because we use an email as a username, and we save the profile the object, then, we've used a profile, we save the catcher score to the user profile capture score field, and then we save the user profile. So that's what we do. Lastly, we call login. Okay, so we've logged in, you pass the request, we pass through the object, which is the user building user model. And then this isn't necessary. If you're using something like all off where you've got multiple backends, then you need to stipulate what back end you're using. But you can have that in there anyway, it doesn't really matter. The result is success. And the messages, thank you for signing up, we create a data dictionary and pass it through a JSON response. Okay, so that is the sign up view. Sign in view, again, Ajax form view, form view, again, we do all of this logic, like we did above, it's just a slightly different because the templates are slightly different. We haven't we don't need to pass any context through. But we do need to overwrite the form valid. So again, very similar to above, just we've got the username and a password. And what we need to do is call user equals authenticate. And then we authenticate that user, if user is not none, we log them in. Okay. And if not, we then call a form error. So we don't necessarily need this because we are using the authentication form. But because we're also calling the form area, I've just left that in there, it's probably surplus to requirements to be fair, but that is the sign in view. And last, we got sign up view, which is a function based view. And all it's doing is logging out and put, and we pass through your request. And then once it's logged out, you redirect to the sign in page. They are our views. I am trying to flow through these, but be as detailed as I can. So you actually understand the logic of what I've done here. Like I say, I've just identified in the sign of view that it doesn't necessarily need to look like that you could technically technically, you could just use the AJAX form mixin and it will save the form. But one of the main reasons is that we can have this success message because the the mix ins if you look on the mixin here, there is no message is very, very basic. Okay, next URLs. At the minute we've got bugger all in there, but what we need to do is copy And paste all of this. So we're importing the views that we just created, the app name is users and in the Euro patterns, remember, account is home. So it is a class based view. So you need to call the as view method. So as views dot account, account view.as view, you don't need to do that for profile, because this is a function based view. But normally, and I don't know why I've done that, but we'll go profile underscore view, normally, on a function based view, I do this and I think that is the normal syntax. So we'll go back into view, which means that else it won't like it. So go back into URLs, and I'll save that. So the profile views that profile view don't need to call as view because it is a function based view and the name is profile, got a sign up, sign in and sign out. These are two, both class based and this is function based. So that's the syntax that you need. Okay. So if it's a class based view, you call the AZ view, this is a function based view, you don't need to, and they are our URLs. And we're already pulling from these URLs in the URL comp, with this line here. Okay. I've just noticed that I've forgotten something fundamental. So we need a signals py file. So New File, Save as this will be signals dot p y. And what we need in here is all of this. So we're important posts, save from signals, they use up model, we need to receive a decorator. And we also need the user profile that we've created in models. So the receiver decorator needs post save and the sender to do anything. So the sender is user in this case. So what we're listening for is a signal from the user model. And the function is create profile, we pass through the sender, which is user, the instance of the user created and keyword arguments, if created. So if user is created, we then create a user profile. And the user because it's a one to one field equals instance, okay, that's what we put in signals. But to make sure that actually fires up when we fire the local server up, we need to go into apps. And deaf, ready parser itself. And we import users dot signals. And that's all we need to do. So this, these two lines of code will be responsible for firing up this signal. Okay. And now we need to focus on the main app. So if I go into here, and look at the URLs we do about face, we do the URLs first. So main is just responsible for two URLs, one of them is root, this is where you will be adding the different addresses for your directions. And when you complete the fourth direction, it then picks up all four redirects, you redirect you to this URL, which is map. Okay. So then we'll go to View. Okay, so we're just looking at render, redirect and reverse, we're importing settings. And that is wrong. There we go. And we just need directions. Remember, that makes them we created earlier? Well, that is what we're bringing in here. And then we've got a function based view, both of them are function based views. So def route, and we create a context dictionary here and we pass that through to the root HTML file. Very, very basic view is not doing too much. Most of it will be or most of the heavy lifting in on that view will be done using the API and the JavaScript, which we'll come on to in the next section. So then, the last view that we're going to look at today is map this is where we have our map and route directions rendered. So this is the fun bit. So, we will be passing through a whole bunch of parameters. So if you remember in our mixing, if you remembered on mixing, we've got this the redirect params that will be responsible for creating a parameter string that will be passed through to the main view and it will contain all of the so it will contain keywords such as lat, a long a lat, B Long Bay and so on and so forth. We know that that am long a or both that Origin The starting point, B is the destination and C and D are the waypoints okay? We know that because that's how we created up directions, the function is also in mixing. So we say that if there is a lat, a that B that's Seeing that D, then do this call of directions, okay, else. So if if somebody tries to visit maps without those parameter strings, it will just redirect them to main route. So go back to the route and say Do it again. Okay, but if there is a lot A, B, C, and D, it will try to call directions from the mixin. And it just passes through the A, B, you know, and so on and so forth. Okay. And that's what we built into mix ins, if you remember, there we go. So these are the keyword arguments. So this is what we're passing through from the view, like a lot, a lot, B, B, C, C, D, D, okay. And that is the F, that is the L. So this will redirect. But if it doesn't redirect, then it'll create a context dictionary. There's a lot going on here, we're passing through the API key, base count country, this is all required for the API call that we're going to make. And we will all become clear, when we start writing the JavaScript passes through all of the longitude and latitude, and so on and so forth. Plus, it passes through the origin, the destination and directions, because we need that to render onto the HTML file, which is mapped dot htm, l. So they are the all of the views, they are the URLs, the models, and so on and so forth. That just leaves us with creating a templates directory. So we haven't got anything in there. There's a couple of ways of doing this. Now, if you're creating reusable apps, ie those sort of apps that you can, you can upload onto p IP is that other people can actually install them, then it's it's probably best for you to have templates in the actual app. So it's all contained in one. But as we're not doing that, you don't need to do that. So all you need to do is add a directory in here in the main directory, which be new folder. We'll call this templates. And all we'll need is a new directory in there for users. And we'll need one in there for Maine. So when we're referencing Maine slash map dot html, we'll be looking for a file in here, if I save this as map dot html, this view will be looking in main format HTML. So we'll be looking for that. That's how that works. The only thing is, this project isn't geared up to look for templates in that directory, we need to go into settings.py and tell it where to look. You do that by going to templates you're going to does, and all you need to do because it's in the main directory, you need to put templates. And that is it. Okay, I hope that that was a good balance of firing through everything. So you can get through it nice and quickly, without skipping over kind of some fundamental stuff. We've got covered a lot of ground, we have started a new user app, we've built a model, some model forms and views from URLs, you know, we've reconfigured settings, the URL comp, we've configured templates, we've covered a lot of ground, but that is in terms of the back end in terms of Django, that's this app is complete. It won't work. However, because we haven't got anything, such as CSS, HTML, or JavaScript. That's what we look at in the next section. But one thing actually, I've just noticed also is that in our settings.py file, we're referencing a directory that's not there for static. Now, that's an easy fix. New Folder, and we'll just call this static. Great. That is our static directory. And that is what this is referring to. Okay, good. That is the end of this section. I hope you've enjoyed it. And I look forward to going through the next few bits and pieces. Thank you. And goodbye. Everyone, it's probably from decoded here, and in this section we'll be following on from where we left off in the last one where we fleshed out the back end of this Django project. In this section, we will be playing with the front end. So we'll be creating HTML files, CSS, JavaScript, jQuery, Ajax, and Google API's. So this is the fun bit of the project actually, because this is where all kinds of strings gets strung together. So without further ado, let's jump straight into it. If you look on the screen here, I'm open on the Django Doc's for template tags. Now I have created a video on my decoding channel that does a deep dive on tag template tags and filters. So if you want to understand what they are then by all means, have a look at that rather than me going through this page. But we'll be working with a lot of template tags today. So have a read and have a watch and then come back I guess. But this go jump straight into the Sublime Text. This is the project where we left off. On the last section, you can see here that we created a static directory, and a templates directory. This is what was the last couple of two or three minutes of the last section. This is what we did. And we've got main other users in there. So what we'll do now is we will create the first HTML file, and that needs to be in templates as a base. So new file, and we will call this Save as base dot html. Okay, and I'm not going to write this from scratch, because it will take forever, I didn't design this app to be kind of basic, you know, it looks pretty actually works, you could done it resizes is responsive. So there's a lot going on. So what I'll do, I will quite simply copy, copy and paste it all across. And I'll walk you through what I'm doing. Let's move this over here a little bit. So first and foremost, there's a template tag here, which says load static. This is a template tag that allows us to access our static files. Now static files, as configured in settings dot P, while p y are all going to be in this directory here, as we're in development. However, if we were in production, then you would set up static files in a slightly different way, and maybe have them served up to the project via an s3 bucket or something like that, or digitalocean spaces. So this load static template tag allows us to access files in static directory, we've got some basic HTML here, I'm not going to do a deep dive at all. But we've got this is the main that all these links here, these are my fonts. So we use Korea prymatt decoding, we then got a stylesheet that we're referencing main dot CSS, we'll be playing around with that in a second. So this bit here is calling a CDN, essentially. And this is for toaster. So we'll be using toaster alerts to display messages from the back end. So if you remember, in views, we've got this message, defaults to there was an error. And result is error. Well, that's going to show a red toaster message. If you don't know what it is, if I go back into my browser, I've got toaster examples here. So this is a success. top right. But we can have a bottom right, which I believe have gotten this project, show toast There you go. And it can you can have whatever you like in there, you can test show toast, there you go test. Okay, so that's what we use in this project. Go back into the project here go back in a base. So that's the CSS that's required for toaster and we always stick that in the head, you've then got block, extend head, so we use a block template tag. Okay, so this allows us to extend head scripts that under the law, so I've got some notes in here as well. body. So we've then got nav, we're using an include template tag, we haven't even created this yet. So I'll do that now quickly. So new folder, and this needs to be called partials. And in partials we need a new file called nav HTML. Okay, so that will now be picking up from this one here. Go back to the base. And so this include template tag, rather than having all of the code is going to be in nav HTML, use the include the kind of interjects that HTML element into it, then we've got this div. So don't worry about these too much. The classes, I will be creating some CSS, because I've named these specifically in certain ways so that they get rendered nicely and looks great on the front end. If you remember when we looked through the the demo of the app, it looks pretty good, right? So we've then got include partials logo, hate logo, HTML. So let's create that. I can't talk today, let's create that quickly. New File. More, save that as logo dot html. I'll bring across that code in a second. Anyway, save, and then we've got a block. So these blocks allow us to extend certain parts of this base. In other templates, it will make more sense in a second. And it's called content. So we've got block, extent head block content, and we've got another one here, extend footer. So these are our footer scripts. So first and foremost, we're using something called jQuery. This is a, I believe, the most popular JavaScript library, and it allows us to access things such as Ajax so we can make an asynchronous form submission for For instance, we submit the form and we get the response and nothing reloads on the HTML page at all. It's all done asynchronously. So that's why we need jQuery. But you can get this code from code.jquery.com. And you get the most recent version. Then we've got the toaster JavaScript, which is all this again, you can get visit this CDN JS calm and get the latest version from there, then we've got a block for extend the footer, again, it allows us to extend this part of this HTML into another document. And then lastly, we're referencing main dot j s. So there's two files in static that we do need. So new file, and we'll save this as main dot j, s, that'll be a JavaScript file was Save as again, and we'll call this main No, we weren't. New File. Save as this will be main dot CSS. So there we have it, we've now got the main CSS and main JavaScript, so we're referencing them in base HTML. So even if we were to not pay anything, those files, we're not going to come across any errors. And then we close up the body in HTML. So that is base HTML, we don't need to do anything else in that file, all we now need to do is create the documents that will be extending these blocks. Okay, so the first one we'll look at is the index or in this case, it will be account, which is in users. So create a new file. As we save, as we'll call this count, dot html, in fact, was Save As we need another one in here called profile, save as another one in here called sign in as underscore, save as another one called sign out. And whilst I'm at it, I will also do the map. So templates kind of main overall to get map in there and will route safe, good, that may close some of these down got far too much going on up here. As a real bad habit I have. There we go. Right. So then what we'll do, we'll look at account. Okay, so this is our homepage. So I will copy. And I'll paste this across. So extends the base dot html. So it's extending this, okay, as another template tag that Django has load static. Okay, so we've now access static again, we're not adding it that doesn't necessarily need to be there, but it's not hurting anyone. So we'll add that if I wanted to add a script in there, for instance. Yeah, so with ADD script, you could then add something in there. But we're not so we won't. But this is a block content. So this is the content that will be injected, if you like, into this section here. Okay, so block content. So block content, block content, okay. So we just save this. So got h3 tag, as you know, is a Django Google API course. And this is the user account. And then we've got a div, which is container. So we'll be referencing these classes in the CSS, but I'm not going to dwell too much on CSS. This is more about the API's and JavaScript. So we'll quickly do that in a second. Then we've got h4 tags, so user account details, and then we've got a table, okay. And in that table, we've got a table head, it's got a head, and then blank, sorry, a field and then a blank field. So there's no header there at all. Now we've got a table body, and then for each row, so we've got user name, request dot user, dot username. So Django uses something called context processes that always pass through request to HTML, so you can always access request. Therefore, you can always access request dot user. And fields such as user dot user name, you can access things like in our case will be request dot user dot user profile dot address, things like that make queries such as if request.user.is authenticated. So it's really really handy that context processor is used more than anything else. The next row, we've got name. And then we've got so we use a filter. So this is a template filter, request dot user dot first name, title. So this will put a capital letter at the front of the name and then space last name. So first name, last name. And then we're doing an if statement here. So an if else. So if request dot user dot user profile dot has profile. So if they've added an address, display this, which is a table row, details, our address, then I'll show address, town county postcode else. So if they haven't, so if they're just newly signed up, then it'll show us a profile, and it will have an a tag with a href and a link. So we use an a URL template tag to user's profile. So it would just be a hyperlink where they can click it, and it will take it to the profile, so they can then select that address. So this is why I've got that has profile in as a field on the user profile model. That's it. That's all what's going on in account. Not much else. So let's build out the profile. Paste and save as bit more going on in this Gannett extends base called load static. Now we've got the block content. So again, this is the block, then we've got extend footer. So if we remember in base, we've got this extend extend footer here. The main j s is always the last JavaScript that we load, it's just the way I do it. That means that anything above this I can reference. So I can definitively know that any Ajax I'm writing in main dot j. s, it will work because jQuery is loaded first, okay. And a block extends footer. This is all loaded before my day. So I can actually reference any variables that are stated in the extend footer block. So in profile, we've got extend footer. And then we've got a script. So this is a JavaScript script. And we're creating two variables. one variable is Google API key. If you remember, we're passing this through. Let me remind you profile view. in context, we're passing Google API key and base country through to the context. That's how we were accessing it here. Okay. So we'll create a JavaScript variable. So we can access this in the main j. s file. We're calling it Google API key. And we are, and we're using the safe filter. So that will just create a string of that API key. Same goes for base country, the next script is a file called Google Places, dot j. s. We haven't got that yet. So we will create that now. So it's Google Places. Save as API dot j. s. Great. Go back into profile. So that's now referencing a file that is there that will work. Go into the containers, this is the main main bits and pieces. So we've got an if statement here with an else so if the request dot user dot user profile has profile, show all of this else, add address, okay? And if case so we have got, and if I okay, just trying to figure out what I've done here. So this is input Google address, right? Okay. So this here is that the main input for the Google Places API. So this input here is the input where the user starts typing an address. And Google API predicts what they're trying to type. And then it returns the address, they select it, when they select it, it then populates all of these inputs here, which I'll show you what I'm doing in a second, let me just cover this off first. So if they have a profile, it will display the profile. Okay, so it will display the address, and then it will have a change address. And then it will have or else it will have add an address. So if it changes the address, you can then change the address to the new one, you'll type away in any address you select, it will change. If not, you just added an address. So this is the main input you see here we've got name Google address, ID is ID Google address, we will be referencing them in the Google a Places API, just for reference, then we got a form. And then that is the end of that, really. So we'll look at this form. So the idea is profile form, we will be creating an AJAX call using jQuery on that. So that is the name we'll be referencing profile form. The method is post and the action is for slash profile. So that's essentially the URL we will be firing the AJAX call to, which is, if we look in URLs is here. So as the profile is the name, and that is assigned to views dot profile view. Oh, okay, so let's look at the form. So as it's a form, we need to use another template tag and this will add a hidden input with CSRF token. So CSRF token means cross site request forgery token and it's a token as applied to a forms when you submit the form. It knows That is actually you doing it and no toe rag doing it from somewhere else. And what we're then doing is we're creating these labels. So address is actually now these are hidden, right? So that class is hidden L. And it's hidden. Okay. And the reason we're doing this is because in the JavaScript in the main j s, we write a function to display these hidden elements, when we select an address, and this is why we're doing it. So the label itself is hidden, class hidden L, and is hidden. And form dot address, if you remember, that is a hidden input. So we're gonna forms hidden input form, sorry, hidden input. So all of these are hidden. So they will be rendered as hidden inputs in here, as is the label. So label and input hidden, then you got town, county, postcode, country, longitude, latitude, none of these will be displayed until the user selects the address. And then we've got a JavaScript function that will unhide all of these elements, the button to submit is disabled. So you can't submit the form until an address has been selected. And we add an ID to this Profile button, because we referenced that and we programmatically click it when the address has been selected. Okay, so that's the profile HTML. Next, let's look at sign in a gay and let me get my notes. And sign in. Copy across. Paste extends base, same as we load static, always the same, then we've got the block content. Okay, not much else going on in this. But we've got an h3 tag, and then we've got to contain here. So this is, again, is a form. Yeah, so against CSRF CSRF token, the ID sign in form, post sign in. Okay, so I'm having the ID, the method and the action, always in the form as attributes. That way we can when we're making the call in the JavaScript is a lot easier to understand what's going on. Label again, right, so we're creating a label. The difference is this isn't hidden in the form dot username, because we use in a form view, you access the form from the form object, so it's form dot username, and as the the input. So if you look at forms, username, password, fields, username, password, that's how we reference the number in sign in a case, that's why we got form dot username, form dot password, then we've got label. So this is show password. So if you remember in the forms, we have got a class. Let me show you. Class password. Okay. So what I'm doing in signing is on click, so this is a little checkbox, right. So the CSS will make it look pretty, but essentially, is a checkbox. So if it's unchecked, it will be a password input. But when they click it, it becomes checked for starters. And it calls a function called show password or show p word. Now this function, I'm going to write in the main JavaScript file, and that will essentially swap that password input to a text input. So you can actually see the password, okay, which is quite standard on on websites. And then a button is submit and sign in. Okay, nice and easy. Next one, sign out. Sorry, sign up. Now, that should be sign up, we know. There we go. Sign up. So we will copy and we will paste. Like we more going on in this one. So extending base HTML, and we're loading static, free standard stuff. And this one, we are extending the head, we'll come back to that in a second. We've got block tank, we've got a form. And we're extending the footer. So if you remember in the sign up view, we're playing around with the contacts using the get context data method. And we pass in three recapture site key, okay, which is the recapture public key. And we're creating a variable recapture site key that we can reference in the JavaScript that we haven't written yet. Okay. The form is pretty standard, similar to what we just done CSRF token. Then we've got the first name, last name, username, password, one password, two differences. We've got token in this one. So the token if you remember in the forms we added as a hidden input, and that is how we're going to be handling the reCAPTCHA token. Okay, so that's a hidden input, you won't see that when it's rendered. Then we've got this little checkbox box to show the password again and a sign up Submit button. Okay, so that is the form. And what we've got at the top here is a script. So this is the source is the url https google.com reCAPTCHA. api.js JavaScript. So this is the JavaScript that we're pulling straight from Google. And we're passing through the, our reCAPTCHA. psyche. So that's how it knows that it's us making the call to recapture. Because the psyche that we set up when we set up recapture in the first section, we're linking it to that API key. So and that is the JavaScript call as the script we sit in the extend head. So essentially, this script, being in that extend head is the equivalent of it being in well, it'll be there but without the head. So imagine, imagine that Okay, so that's what we're doing by adding that to the extent head. So that's the JavaScript as long as content happy days. That is the signup page. So now let's look at the main map. Actually, let's look at the parcels quickly. Copy partials. Okay, so this is the logo. So it's just an a tag, essentially. And if I save that, so if you click on the logo take you to a user's account, which is the homepage, and it's referencing, I think that's the first time you've seen this in this tutorial, load static. So this is how you reference the static. When you load static, you can then use the static template tag. If you didn't load it, it wouldn't work. And we're looking in branding. So in static, new folder, branding, and is trying to find a GIF, which is a dead logo GIF, we'll add that in a second, which won't be a problem at all. And then we will add the Nef got a lot of if statements in this. nothing too fancy To be fair, it's got an if statement if else. So if the request dot user is authenticated, so if they're signed in, they will see this now. If they're not, they will see this nav, okay. So this look at if so when you first enter the site, if you're not signed in, you'll add if signing in path. So if the URL is sign in, then this will sign in will be active. Okay. So on the side now there'll be glowing up purple, if not, it will be blank. If it's sign up, it will be glowing up purple, if not blank, that's what these if statements are doing is just basically showing whether or not is active or not. If they are authenticated, and the request path equals equals slash, which is home. Again, active if not Same goes for profile, route map. Okay, so it just shows different, different navigations. To be fair, let's close that. Let's close that. Let's close sign up, sign in profile and account or keep base open. We'll close that. And now we will do map. So copy. It's going to map or paste this a lot more going on in this. Save. Okay, so map extends the base HTML load static. In this one. Again, we're passing through recapture. So recapture site key, okay. And then to be fair, we probably don't need to, that's probably a hangover, but I leave it in there. Because we're not making a reCAPTCHA call in map. We're only making it in, sign up. Okay, so we've then got h3 tag, and we've got a container. So what's going on here? We've got I'm going, do you know what? Let's do root first. Nasty read first. Okay, this is right. Yeah. So route is the the URL where we add the longitude and latitude for the origin, the waypoints and the destination. And map is what's rendered says the last point in time, actually, so let me look at real quickly. So I've just pasted that all in that extends base load static. And then again, we've got recapture. We don't need that. I'm sure I can remove that. But I'm not going to because I haven't tested it. And I know that it works in in the other project. But we're not technically making a recapture call. So I'm, you know what I'm saying that doesn't need to be. Okay, then we've got the h3 tag, and then we've got the inputs. So this is the same as account, no profile. So in profile, if you remember, we have this input here. And we call it ID Google address difference here in roots is that we've got four. So if you look here, I've got ID Google address, dash a, dash B. So remember, start and end. Don't ask me why I didn't go ABCD. It seemed logical at the time but looking back, I probably should, should have gone a B, C and D instead of going to a and b, that is point A, B is the destination and a waypoint system. In day, a guess, because you can do more waypoints. So it'd be C, D, E, F, G that way, but hey, the logic was there when I was building it. So these are the inputs. So as you type in here, it will predict the address as you type in C, it will predict the address, and so on and so forth. And when you select each of them, it then adds the geo coordinates the longitude and latitude to each of these hidden inputs here. So this class is geo ideas lat a long a, okay, and then it adds a value. I'll be using JavaScript to add that value. Yeah, we didn't need that. reCAPTCHA at the top of the screen, because even passing through the reCAPTCHA key, so I can remove that from map as well. Let's, let's remove that. There's no point in it, bns. So save back to root. So this is the extend footer. So we've got a script here, a couple of variables, Google API key and base country. And also we are then referencing the Google Places, waypoints j s, because in this we have to. So that's add another one. And save us. And this was Google waypoints API dot j, s, waypoints API. Let's have a look was probably wrong. Google Places, waypoints, points. And then if we delete that, there we have it, we've now got that file. So that's referencing a file that is actually there. Okay, so now we'll look at the final HTML document, which is map dot html. So if we go in here, I did paste this a moment ago. Anyway, you can see that we've got quite a lot going on. This is where we render the map from Google. So let's look at this look at the footer first. So we pass in through if you look at the map, view, in the context, we're passing through all of this, okay, so we're passing through the key, the base country lat long the data that the data in maps, we are getting all of those. And we're creating, in this case, we're creating a string, we're always using the same filter, else, JavaScript doesn't like it. And then you got we're creating variables a lot, a lot longer a an NBC D, origin, destination and directions, we're going to need those in the Google Places API, and Google Places, waypoints. And also, Google Maps JavaScript, which we haven't created yet. So New File, Save as Google Maps dot j s. Okay, so we'll be needing all of that in Google Maps, okay. Then got another h3 tag. And we'll focus on this. First of all, we look at the table in the container. So this is the map container. This is the map route. So we will be referenced in this ID map, right? Because Google that the Java scripts in the Google j s files that we're just creating, they will essentially be rendering the maps and everything else, all of the routing and stuff into this element called a map route and will be referenced in map pre in the JavaScript. Then if we look at things insane, I've got another table. So we've got to start the destination, a duration and the distance, that's kind of the header of the table. And we're pulling from directions, origin, directions, destination. So that is what comes through when we call. If you remember, we've got directions here. So we're passing directions through to the context. And that is essentially a dictionary. So we're referencing keywords in that dictionary directions, such as origin, destination, duration, and distance. And that's what's being rendered here. Then we've got directions, and we've got ID dir toggle, so this is JavaScript void, h ref. And then we've got on click directions toggle. So this is how you view the directions, it doesn't show the directions in tissue until you toggle it. Okay, so that's just a little little link that we've got there. And then we've got another table. So we've got table head directions, distance duration, and this is where it renders the whole route. So for each leg, in directions dot route, we do a for loop and a counter. And then we do this for loop here. With dist duration text, we're creating those variables that we can reference down here. And they are in leg dot steps within a foot we're doing a for loop in leg dot steps, create three variables, distance, that duration is there and text say Is that because that is raw HTML that comes through from Google. And that's why we need save, because it will actually render that HTML properly in the website. And that's it. That is maps. Okay, the next thing we need to do there, all our HTML is complete, we now need to add some CSS. Which would do, I am not going to waste your time on CSS, this app tutorial was all about showing you Google API's and Django. CSS is not an afterthought. It's very, very important. It makes it look fantastic. But you know, we could spend an hour going through CSS, which isn't necessarily important. But you can see, I'm referencing body. I'm saying that the font family for this particular file is Korea prime, which is correct. The map root element. So this is what we just looked at here. Where is it? So map route, so we're referencing different elements in each of the HTML files. So we've got map container. So I've probably got one for if I search. There we go body HTML map container height 100%. After they need to search flowers right at the top, but then got logo got a side now. So this tells you this shows you what the sign level look like, then we've got some some media screen. So it depends on how big the screen is, is how it gets rendered. These are how the inputs look. So a text input an email, password input, we've got select text area, this is how it's rendered this how it looks, we've got width, 100%, padding, 12, so on and so forth. Okay, so we don't need to waste our time on this, which so we won't. The next thing is the main JavaScript. So if I go into main, paste this, right at the bottom here, we've got code straight from Django. This is a JavaScript function to get the CSRF token from a cookie to and then it passes that through with an AJAX call, this is a way to work around to make sure that the right CSRF token is passed through when a form is submitted. Okay, so it's very important you have that in your JavaScript file, when you submit an Ajax. So let's go right at the top of the file, there's open up a little bit, like directions toggle, if you remember, in maps, I saw that directions toggle somewhere Hey, guy, so we've got a little link here. And it says, click here to open up the route basically. So you can see the route for the map. And it's unclick, you called direction toggle. And all it does is it opens up a removes the hidden attribute and adds a new element. So we don't need to necessarily go through the JavaScript itself. But that is what is doing. When you click that toggle is calling this JavaScript function. And it's fading in the directions table, else you fade out. So you either display it, or you hide it, one or the other. Show it up. This is for toaster. So we call Shola. Every time we make an AJAX call. And it depends on if it's a success. Or if there's a redirect, for instance, we pass through all of these keywords, all of these keywords here. If there's a redirect URL, and we call this toaster, house, we call this toaster. So what what is doing is picking up the title. So in that case, it could be success, that message could be thanks for signing in. And it's creating a toaster. So if you look at the examples, again, is creating a toaster based on all of this. So if we add a close button in the progress bar, and then tap show test, says creating a unique toaster and that's what I'm doing in the JavaScript there. Okay? So that's the function called show that show password. Okay? This is what's being called when you click on me open up sign up. is they go so show p word. Okay. So this is a JavaScript function has been called. And what it's doing is if the type is password, change it to text, if not change back to password, just a little toggle. Okay, we create a variable called temp button text. So this is the text that's on a submit button. So it could be sign up sign in. So it kind of stores or this will be used to store what a button is currently named. And then you've got a custom form submit post. So when we submit a form, what it does, it disables the button, it adds a spinner, and it saves the current text to this element. And then when it's complete when the form is submitted, and everything's gone, well, then we then call this so as custom form, submit response. And what it does, it removes the attribute disabled and it adds the text, which used to be so the idea is when you submit a form It adds a spinner saying loading, and then when the form submit in, it goes back to sign up. That's all it's doing. And we just call custom form submit post and custom form submit response when we call an Ajax. And then we've got form controls. So we use strict, but this is variable form controls and is equals function. So this is kind of a general JavaScript function that we're doing here. And underneath here is when we initiate the form controls. So it's a jQuery document ready. So when for when the HTML has been rendered, then we call the format controls, and we initiate them. So everything within here will win work. So format controls, we've got a few forms. First one is user sign up, we've got sign in user profile, and we return and we in initiate and function, we initiate these forms. So each of them certainly work. So we'll focus on one of them. So these we've got one of these for each of the forms that we've created. Okay. So forms, so we're looking at user is the user form, which is the signup form, right? Yeah. And we call that in, so we're looking sign up, we'll look at the form. So sign up form. Okay. So that's what we're referencing. Now, this is what we're trying to submit from the front end, this is us submitting a form from the front end, processing it in the back end, and, and then changing the page as necessary. We're not reloading, which is an AJAX call. So this is the user signup form, the form, so we're creating a variable form, let me make this a little bit easier for you to see. here as well. So we create a variable form. So that form is we're using Ajax function. So your little dollar sign, Id signup form. So the form is the signup form that is in the signup, HTML, this was one here. Then we've got form dot submit function. So this is when we submit the form, this is what we do, we prevent default. So if we click Submit on HTML, submit on an HTML form, it would just do its default function, which is to submit the form to the back end by adding event dot prevent default, it stops that from occurring. So it kind of completely stops that from happening. And then it goes through this piece of code here. Okay, so we've got custom form, submit post, we're calling this, remember, we added a little loader to the button. And then we've got google recaptcha. Ready. So we have already loaded that in this particular HTML document as this script here. So we can now access g recapture. So g recapture dot ready function. So then what we do is G recapture dot execute. So we pass through the reCAPTCHA psyche that is passed through at the bottom of this page, okay? The action is slash, because this is the homepage, right? So this is the index. So dot then function. So this is the token, this is the token that we get from G recapture the google recaptcha. So document dot get element by ID, ID token dot value. So this is the value of the token equals token. So that hidden element now has a value of the token, and then we submit that to the back end, so var form data equals form, which is here serialize. We call it a serialized function that, and then we call an, we make an AJAX call. Okay. So the URL is the form attribute action. Over the form attribute is a sign up. Okay? main, then our wet sorry, methods. So the form attribute method, we've then got post. So this is a post call. post request, sorry. And then data, we're passing through the serialized form data. We've got a success method and an error method. So if anything goes wrong, right, we call the custom response. So form submit response. So the button on the form will go back to normal, then we'll show an alert, which be error, there was an error, please try again. And then we do a console log that will only display if default, sorry, debug is true. Okay, if it's false, it won't show anything. But this will show an error if there is a problem. However, if it's a success, can we call custom forms and met if the result equals success, because we're, if you remember, in the logic in the view, where we're overriding the form valid function, and if we show sign up view, so it's a success. If recapture works, then respond with success. If it doesn't, then we will call. So it has a form invalid, we'll call a form error method in the mixing. So if it's a success, we redirect to homepage. If not, we redirect false. We basically don't do anything. So then we what we do is we call a show alert, you can't really see that, can you, we show alert, and we pass through the result of the call the message, and then the result to lower case. And then with that, we pass through the redirect, because we are redirecting to the homepage. Okay, so that is the signup form logic in JavaScript. This is how we're processing the form on the front end, we're doing the same. So the reason I went through that and quite a lot of details, because we're using recapture, whereas these other forms, were not a case. So there's no gv capture at all. It's just basic, we're getting the form we're creating form day, it will make an AJAX call with the attributes, action method and form data. We have got console log Jason, we don't necessarily need that. That's for testing. So this is the sign in function, the sign in form submission, then we've got user profile. Okay, so this will be called when we click programmatically the submit button on the form in route. Sorry, sorry, it's in profile, my apologies. So it's the foreman profile with a profile form. If you look, the button is disabled. If you can't, you can't actually click the submit button. So what we do is we actually programmatically click that Submit button when we get the response from Google. So we'll be submitting this form in JavaScript from the Google. Where is it the in static from one of these, probably Google Places API. So when we get the result back from Google, we will then remove the disabled attribute from the Form button. And then we will click the button programmatically, like I say, so it's there's no different, nothing fancy going on here. They're all very, very similar. But they're the three forms and they are in the main js. So let's save that. We've done the CSS, we've done the JavaScript now we now need to focus our time on the Google Maps, Google Places and waypoints. Okay, now, what we need to do is add the JavaScript to the Google Maps. Copy, Paste. So let me open that up a little bit. Okay, so right at the top of the page here, we call this so is it get script and we call maps dot Google API's comm we pass through the Google API key. And then at the end of that we plus an S, and libraries equals places. So this is the call that you need to make to have access to everything we need in Google Maps. And this is what's going to be used to render the map in map dot html. So this will be the map with the route across the waypoints. Okay? So when done, so once you've got that script done, and does this function here, so is Google dot maps dot event, add Dom listener, window load, and then you initiate the map. Okay, so this is just a standard get script call for Google API's, then gone in its map function. Okay. So we have a variable of direction service and directions display. And then a very variable of map. So we make a new Google Maps. And we're looking for map route. So this is the element that I showed you in the map HTML. So it's actually looking for this, this is where the map will be rendered. Okay. Zoom is seven. I can't even remember what that means. And then we center the map against the latitude and longitude. So that is the start point. So that is the center of the map. And then directions display, you set map, and you set the variable map. And then you calculate and display route. So this is the direction service and directions display that we'll be referencing in this function down here called calculate display route. You got some constants, so waypoints This is the C and D. Okay, stop over true. So this is how we're creating waypoints. And then we calculate the route using this function here. So we pass through direction, service and direction to display. Okay, and that's what we call in here actually. So when we calculate display route, this, these are the two bits we're calling, which are here. They knew straight from Google Maps direction service. So we're pulling them through in here, direction, service dot route. Origin, is origin. And they'll pass in through the destination and waypoints these are the variables that we pass through, if you remember to here, okay, so origin destination and the waypoints the constants here. Okay? That's what Google requires to render this map. So optimize waypoints equals true. Travel mode is driving. And then we've got function response status. So if the status is okay, so if it works, then directions display set directions response else, fire off an alert. Okay. So that's how that works. And that is the Google Maps JavaScript. So we need to look at Google Places API. we'll paste that in there. Let's open it up a wee little smidge. Again, we're doing another get script, same thing, no difference. The only difference is rather than in it map we're using in it or a complete, which is just a different service. Okay, so we let autocomplete so we have that here. And then we have an in it autocomplete function. So autocomplete equals, so we do a new Google dot maps dot places autocomplete. And then we're looking for a, an element in the HTML, which is ID Google address, if we look at profile is here, Id Google address. So we're looking for that element. Okay. types, his address and component restrictions. So the country this is where we pass through the base country. Okay. So this is settings dot bass country, and this is currently set to UK, but if you set it, send it in settings dot p y to a different country, then it should technically work. Okay. So we have autocomplete, add listener change places, so every time you change the address in the input, it will autocomplete. Okay, so on place changed. So if you click there different address, then it will run through this piece of logic here. Okay, so the autocomplete This is as you're typing, it will change and predict the addresses. But if you click the address, it will run through this code. So you've got a place so it's a complete get the place geocoder, you're doing some geocoding there. This is why we enabled that API, the address. So again, we're getting the value from the inputs that we just selected. And then we've got geo coder dot geo code, pass through the address. And then if the status is okay, so if the address is fine, then we get the longitude and latitude from the response. And we add those to the elements that have the ID of ID underscore latitude and longitude. Okay, so those two inputs are now been populated. And then we go through this logic to get the street address, the route the postal code and everything else. And we add those to the corresponding elements, okay, so I won't necessarily need to go through them. But with with doing a for loop on a response from Google, and we're pulling through the street number, that route, and saving it to the ID town, the county, the country, so on and so forth. Then we add the address to, we add the value to the ID address, and then we unhide all of the elements. So remember those everything with a hidden element class gets unhidden. Lastly, we fade in. So I do apologize. You find all of the hidden elements and ignore the CSRF CSRF token, and then you fade them in. That's how that works. I do apologize. And then what you do you get the Profile button, you remove the attribute disabled. And then what you do is you submit the form, okay. So we don't programmatically submit the form, we remove the disabled, and then the user can submit the form. That's how that works. So okay, Google Places API j. s, that is that. And then if we copy over the waypoints quickly, we'll just fly through that. Happy Days, right? Again, another Git script difference being here, it's actually is exactly the same as Google Places API. Okay, very, very, very similar. It just this is slightly different because we are using this JavaScript for four different inputs. So had to manipulate the JavaScript slightly to work. So instead of Google Places API, s, j, s, where there is no auto fields, I've just got A, B, C, and D, because we just use them for waypoints. So again, in autocomplete, so I won't go through the logic of adding the address in town and county to the hidden elements, if you don't need to, or getting a longitude and latitude. But you will see here that what we're doing is, we're going through a for loop of the auto fields. And we're getting a and we're Len looking for the ID Google address and we're appending the fields So this then becomes the, if it's a, it becomes the destination, sorry, the origin, if it's B is waypoint one, if it's C is waypoint two, and if it's D is the destination. So this is the logic I had to put in here to use the Google API on four different autocomplete fields. So that's the in it's autocomplete. And then we've got on place change. So again, it's the same as Google Places API is just I've had to adapt the logic to work through and identify the correct input element based on the field from the or a field. Okay, so we're passing through the A, B, C, or D. And we're looking for ID Google address, Addy. Okay. So that's what I'm doing is no, no different, massive, no massive change to Google Places API j s, but then we're calling calc route, which is down here. So this is the function that we're calling. And this is what we're using to create the URL query. Okay. So we're doing an encode you are I component, so we, what we're doing is, when we select those four waypoints, we end up creating a URL parameter, and we append it to the URL. And then we this is actually quite key. And then what we do is we call window dot location, assign, and then we redirect the user to the root URL, sorry, the map URL, and then we append the query. So the query would be something like, boop boop, lat a, there'll be question I'll start with a question mark, and it will be lat, a equals 57.4. And lasts so long, I hope this makes sense. Wood equals four is 5.666312, whatever. And then it will be joined with a bar. And then you do another one and another one and another one. So the parameter string will end up being quite cumbersome. But it will be appended to the URL and the user is then assigned to the new URL with a parameter string. And then in the map. View, let's review the main, where are we main views, you can see that we're actually trying to pick up that parameter string. So if lat a is found in request dot get dot get, then we can do something with it. So that's what we're trying to do in waypoints. Again, this code is going to be in GitHub so you can have a good look. And make sure you know you're familiar with it. But I hope that I've now gone through is deep enough so that you understand it without going too deep, but I've actually lost you. So I will end this section here. And in the next section, we will test the app and make sure it works perfectly. And that will be the end of the tutorial. So thanks for watching, and I'll see you in the next segment. Thank you. Bye. Everyone is probably from decoded here. And in this section, which is the final section, I will be running through some debugging and just general testing of the application to make sure it works as planned. So that's jumped straight into it. If you look on the screen, I've got my command prompt open I got my virtual environment fired up and I'm in the correct directory. So to the at this point, if you were to follow the tutorial on Django Doc's, you would have been making some of these commands right at the start of the project, but I haven't done them yet. I haven't done it for a reason, actually. So I what I like to do is get my teeth into a project and then start making the migrations rather than doing it right at the start. It's just personal preference really. So what we need to do is we need to make a few commands here. So first and foremost, we need to make migrations. So Python managed.py make migrations these will this will make some migration piwi files and a cache of the model migrations and other bits and pieces if it will work. Help us out was a full stop I Chi so from human friendly import format timespan no model names human friendly so is that let me have a look quickly. I have a funny feeling that we need to install is it's just called human friendly. So let's go pip install human friendly brilliant Make migrations. There we go, that worked, then what we'll do is we will migrate. So if we now open up Sublime Text, you'll see that we have a few extra files in here now. So we've got db.sq, light three. So that's for the database. So in users, when I've got a PI cache, and in migrations, we should have a guy, so you got initial. So if we were to make a change to the model, and then run migrations, again, it would then essentially, we just create a new file. And it will make it make a list of all of the changes you're making. And all of the amendments, all of the creates and updates and things like that. Main won't have it will have the poi cache, but migrations will be blank, because we don't have any models. Okay. So these are the migrations we made, you'd expect it to look like this. So we've got dependencies of the off user model, which we have, you know, that's the one to one field. And then you've got the ID, timestamp Date field, dadda, dadda, dadda, that, okay, so that's what we're done by making migrations. If we now run server, say Python manage.py run server, hopefully, we'll be able to see what the project looks like on our browser. So let's go Ctrl Shift and open up an incognito screen. Just to level it off a little bit. And if we go, local host with Port 1000. Wonderful, I was hoping that was like that. So you can see here that it's gone. Sign in question mark next. Okay, so the accounts page has redirected us to sign in. Okay. So we haven't got an account. So we will sign up. There we go. So object has no attribute recapture public key. So what have we done here? So if we go back into settings, rights, okay, so we'll call this public key. And we have a look at my other project to see what I did call it. This, so as weak, there we go. So and that one isn't secret key, we need to call that private key. So okay, so that will now reset the server thing that's now working. And if we go back, this is what you see on the screen here, because we've got debug set to true. If that was set to false, you won't be seeing it. There we have it. Right. That's all our work. And so this is the sign up page. Okay, so let's go Bobby Stearman, username, Bobby at did coding.com password, this guy. P word. Let's go. Password 123455, click Show password, it will show that, okay. 12345. And the reason it's showing that it's because I'm toggling between a password field and a text field. Okay. So that's click Sign up, you can see here, the fact that we've got this reCAPTCHA element at the bottom of the screen, which suggests that it's actually working. So let's click Sign up. I was too common. So you need to have a good password. So let's go. Let's go. Fred. Fred, one. can't assume that's going to be very There we go. Thank you for signing up. So the fact that come up with an error and it come up with a message shows that the form errors actually work in a mixin, which is fantastic. So now that we're signed in, we're now in the accounts page, which is the homepage right? If we're not signed in, it will redirect us to the sign in page. So the username decoding user name is Bobby Stearman. Let's create a profile. So this is the recap, not the recapture. This is the Google Places, JavaScript. So Viper 123. All Okay, that's not working. Okay, that's not working inspect, console. Failed to load resource. The server responded with status of 404. So Google Places dot j s cannot be found. Okay, interesting. So static Google Places because it's not get this Google Places. That right, is that we're referencing and let's look at the templates. And we'll look at profile and what are we looking for here? Google Places JavaScript. So that was a mistake on my part. Okay. So this is all part of debugging. So if we refresh the page that will now go because that file has been changed, the name has been changed. So if we now go 123, this page cannot load maps correctly, do you own this website? Interesting. Then you just keep debug this quickly. Okay, I figured out what it was, it was because I hadn't enabled billing on the API. And you have to do that for it to work. So go ahead and do that on your API keys. So if I now go, 123, there you go. And then we'll click Buckingham Palace. And then we'll unhide all of those hidden elements, and we'll click Update. Your profile has been updated. Wonderful. It should now There we go. Brilliant. So use a profile. If we click to that you can change the address. So as create or update, which is great. We then got root. So these are the four so this is the start address, waypoint. One, two in destination. Let's see if this works. So I'm going to go with Okay, I know that address. I'm gonna go with one. Cherry Orchard. There we go. I will do another. Okay, one High Street Stretton. There we go. No, not that one. One high streets. Stress him, or click on that one. And lastly, we'll go with one marketplace eally. uk. And now that I've completed all four waypoints. Can you see this? So we've got map question mark, then we've got lat a, and there's got long a, that B, long B, C has created that parameter string, that's what's being used in the view. Okay, so we go into the view in Maine. There we go. So it's picking up all of those from the parameter string. Okay. So we've got start destination, duration, distance direction, that's about right. To be fair, if you're gonna do that little route, that's exactly how far I'd expect it to be. This is the map. Sutton had them stratum eally. Brilliant. If we click on this will this work? Happy Days, and that's the directions. Let's just double check the sign out works. There we go. So site this check sign in, as well. So as Bobby did coding.com was it Fred, Fred one, I think our use check show passwords. Sign In. You're now logged in. Everything works to plan on over the moon. So there we have it. There's your Django app that works with two Google API keys, and six different Google API's, one of which is recapture. And the others are a whole bunch of maps API's. So we can do predictive addresses. We can use maps, we can use waypoints. It's fantastic. And it looks pretty good as well. So you can find this code on my GitHub, the GitHub repository link will be in the description. Thank you for watching, and I will be seeing you in the next tutorial. Thank you. Bye bye.
