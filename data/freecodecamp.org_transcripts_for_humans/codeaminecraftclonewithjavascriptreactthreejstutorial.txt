With timestamps:

00:00 - in this course daniel bark will teach
00:02 - you how to code a fully functional
00:03 - minecraft clone using react javascript
00:06 - and 3js
00:08 - daniel is a senior software engineer
00:10 - from sweden you will create a game that
00:12 - supports 5 minecraft block types it will
00:15 - include moving jumping switching and
00:17 - placing blocks saving and more you will
00:20 - learn about mini react concepts such as
00:22 - ustay use effect use ref and custom
00:25 - hooks for state management and you'll be
00:27 - able to apply the principles to create
00:29 - other 3d games in javascript alright so
00:32 - let's get on with the tutorial and to
00:33 - begin with let's have an overview of the
00:36 - steps we're going to take in this
00:38 - tutorial to build a minecraft clone
00:41 - so first we'll look through the code
00:43 - that we're starting out with and the
00:45 - packages that we're going to use
00:48 - then we'll add our first 3d element
00:50 - which is a skybox that will wrap the
00:52 - entire world
00:54 - we need some images that will be used as
00:57 - textures on the ground and on the cubes
01:01 - and next up we'll use a plane as the
01:04 - ground
01:05 - and our player is going to interact with
01:07 - that ground
01:09 - and so the player is going to get a
01:11 - first person view will
01:14 - mount a camera to a sphere
01:16 - and that will feel like a first person
01:18 - game
01:20 - then we need to have some gravity we
01:21 - need to make sure that the player cannot
01:23 - fall through the ground and when you
01:25 - jump you should fall back to the ground
01:28 - and so on
01:29 - we need some movement to go back and
01:32 - forward and to the sides
01:36 - and then we need some state management
01:38 - because we need to keep track of all the
01:40 - cubes in the world so you need to be
01:42 - able to add and remove cubes in a global
01:46 - state
01:46 - so we need to keep track of that
01:49 - and then we also need to keep track of
01:52 - what type of cube the player want to add
01:55 - to the world
01:57 - so we also need some type of ui that
01:59 - indicates what cube texture is active
02:04 - it would also be nice if we can save our
02:06 - world so we don't have to start from
02:08 - scratch every time we come to the app so
02:11 - we'll implement a button to store the
02:13 - world in the local storage
02:16 - and also to
02:18 - reset the world if we want to start over
02:21 - we'll have a reset button for that
02:23 - and in the end
02:25 - we should build ourselves something fun
02:28 - like a house or
02:29 - we'll see what we come up with all right
02:31 - so let's look through the code that
02:32 - we're starting with so we have a
02:35 - package.json
02:37 - so we have react3 fiber the the main
02:40 - package and then we're going to use some
02:42 - nice functions from canon and dry
02:46 - we have react we have three
02:48 - we have a way to generate ids and we
02:51 - have the state manager zoo stand now
02:54 - let's jump to the components folder is
02:57 - empty right now but we will populate it
03:00 - inside images we have
03:02 - small images like this we have dirt
03:05 - glass grass
03:07 - logs and wood
03:09 - and i already created a javascript file
03:11 - that just imports these images and then
03:14 - exports them in an object like this
03:19 - let's go to the index
03:22 - so here
03:23 - not much is going on quite standard
03:27 - we have
03:29 - an index.css file
03:31 - with not much in it i just added some
03:33 - helper classes and we'll probably add
03:35 - some more later on and inside the app
03:38 - here we have
03:40 - just a div that says outside canvas and
03:43 - then we have canvas from reactory fiber
03:46 - and we have nothing inside the canvas
03:48 - right now so we see a text here that is
03:51 - outside the canvas and the rest of the
03:54 - screen is covered by the canvas alright
03:56 - so we are done with looking through the
03:58 - boilerplate
04:00 - so onwards towards the sky
04:04 - so the sky we will import from
04:07 - let's see if we get some help here
04:09 - sky from react 3 dry
04:12 - and let's see if something happened
04:15 - yes we got a sky
04:18 - so for now we can remove this div that
04:20 - says outside canvas what i wanted to
04:23 - show with that is that you can add
04:25 - normal html as long as it's outside of
04:28 - the canvas because if i move this into
04:31 - the canvas
04:32 - we get some errors because
04:35 - react3 fiber doesn't know what to do
04:37 - with the div it has all kinds of other
04:40 - primitives it can render like meshes and
04:43 - geometries and so on
04:45 - but it cannot handle divs but we can
04:47 - place them outside and then we can mix
04:49 - the 3d stuff and the normal html stuff
04:53 - so i'll remove outside canvas for now
04:56 - so we get a full view of the 3d content
04:59 - here
05:01 - for on the sky we can set
05:04 - sun position
05:06 - and that takes an array
05:09 - of xyz
05:11 - so i'll do
05:13 - 120 or something
05:17 - it doesn't matter too much but now we
05:19 - see that the sky got a bit brighter and
05:22 - i cannot really look at the
05:25 - any other part of the sky because the
05:27 - camera is now static
05:30 - and so we can adjust the sun position
05:32 - later if we're not happy with it but at
05:35 - least now we have a
05:37 - sky in the day and not an evening sky
05:40 - like it was before
05:42 - so i think we'll leave the sky like this
05:44 - for now and jump onwards to the next
05:46 - step alright so let's prepare our images
05:50 - and turn them into 3js textures
05:54 - so first i'm going to change actually
05:56 - this images file
05:59 - so that we can
06:03 - destructure them when we import them
06:05 - directly
06:06 - so i will clean it up like this
06:09 - let's create a new file
06:14 - and call it
06:16 - textures
06:20 - so then we can import
06:24 - from
06:26 - images
06:28 - so what we need to do here is create
06:30 - textures so let's start with the dirt
06:35 - texture
06:38 - so we need to import
06:40 - from 3js
06:44 - the texture
06:46 - loader
06:50 - so we say new
06:52 - texture loader and we give it the dirt
06:56 - image
06:58 - so we just repeat this
07:01 - there we go and
07:04 - we create a separate texture also for
07:06 - the ground
07:09 - even though we're going to use the same
07:14 - image so we'll call that ground texture
07:17 - and uses the grass image
07:20 - so now we want to export these
07:25 - there we go
07:27 - so now we have a file that exports the
07:30 - textures
07:32 - so i think we can cross off textures and
07:35 - images
07:38 - so our next step in the list is to work
07:40 - with the ground
07:43 - so let's before we create the ground
07:45 - let's add a few things in here
07:47 - let's add an ambient light so that is a
07:50 - light that will
07:51 - light up every
07:53 - 3d surface
07:57 - and that one takes a prop
07:59 - intensity
08:01 - so let's do one 0.5
08:04 - and before we
08:06 - include the ground
08:08 - we need to add a physics container
08:10 - because we're going to use a hook from
08:12 - canon to create our plane that will be
08:15 - the ground
08:16 - and that needs to be within a physics
08:19 - boundary
08:20 - so the physics from canon
08:24 - and inside here is where we can create
08:26 - the ground
08:28 - so let's create that component now
08:33 - ground
08:52 - okay
08:53 - so here to create our ground plane we're
08:56 - going to use a hook from canon
08:59 - called use plane
09:04 - so this plane will give us an array
09:07 - where the
09:08 - reference comes first and that is a
09:10 - reference that we will place on the mesh
09:13 - that we
09:14 - let canon control
09:18 - so use plane
09:20 - so it takes a callback function that
09:22 - returns an object
09:26 - so here we can set some properties of
09:28 - this plane like rotation and position
09:30 - and so on
09:32 - so we'll do rotation and here we have an
09:36 - array of three
09:38 - and position also
09:40 - an array of three
09:47 - so now we're going to return some
09:48 - elements here
09:51 - so
09:53 - we will take a mesh
09:56 - first we will reference this mesh so
09:58 - we'll set ref is ref
10:02 - and then we have the geometry so we'll
10:05 - have a
10:07 - plane buffer geometry
10:09 - and we'll attach
10:14 - this as a geometry
10:18 - and here we can set the size of the
10:20 - plane
10:21 - with the args prop
10:23 - so since it since it is a plane it has
10:26 - two dimensions
10:28 - so we'll set it 100 by 100
10:31 - and we also need to add a material here
10:33 - so we'll do a mesh
10:35 - standard material
10:40 - and this should attach
10:43 - as a material
10:45 - and here is where we want to add a
10:47 - texture
10:49 - but first we can just set a color
10:52 - let's do hot pink
10:56 - all right so if we look at the browser
10:58 - now we have something hot pink that is
11:00 - covering
11:01 - the entire
11:04 - screen
11:05 - so we don't want to have color hot pink
11:07 - here we want to attach the ground
11:10 - texture
11:12 - so let's import
11:15 - the ground
11:17 - texture
11:19 - so we just say
11:21 - map is
11:23 - ground texture
11:25 - okay so we got an error because we
11:29 - forgot one step in the texture loader
11:33 - we need to call it and then
11:35 - call the load function
11:41 - okay so we instantiate a texture loader
11:44 - and on that we call the load function
11:47 - for each image that's important to
11:49 - remember
11:52 - so now we can continue debugging this
11:57 - okay so now we have a new texture here
12:00 - so we
12:02 - as we can see it doesn't really look
12:05 - like
12:06 - the
12:07 - the grass image which has
12:11 - these small pixels on it
12:13 - so what i suspect is happening now is
12:16 - that the image is being stretched out
12:20 - so we want this texture to be repeating
12:22 - we want this small image to repeat over
12:25 - and over
12:26 - so we can do ground texture
12:29 - dot
12:30 - wrap s
12:34 - and we'll do repeat wrapping and import
12:36 - that from three and the same for
12:41 - t
12:42 - and then we'll do repeat dot set
12:46 - and we'll set this to the same as our
12:49 - size
12:50 - hundred hundred
12:54 - there we go so now we have it repeating
12:57 - but as we can see the it looks very
13:00 - blurry
13:01 - and that has to do with
13:03 - how
13:04 - the texture is being stretched and how
13:09 - essentially how the rendering engine
13:11 - figures out how to display these colors
13:15 - so
13:16 - with this setting it's like smearing
13:18 - them
13:19 - and we
13:20 - can change that if we do ground texture
13:24 - dot
13:25 - mag filter
13:29 - nearest filter instead
13:31 - so let's see what happens now
13:35 - that looks much better now it looks
13:36 - pixelated as it should
13:40 - so our next step would be
13:42 - to flatten or lay down the ground
13:45 - because right now the ground is standing
13:47 - up
13:49 - so we can play with this rotation here
13:52 - so i will rotate the x-axis
13:55 - and we want to rotate it 90 degrees but
13:58 - in radians
14:00 - so 2 pi would be 360 degrees
14:05 - which means that 1 pi is 180 degrees
14:08 - and half of a pi is 90 degrees
14:11 - so i will do math dot pi divided by 2 to
14:15 - rotate it 90 degrees
14:19 - and it might be that we're seeing it
14:21 - from behind now
14:23 - so i will flip it 180 degrees
14:29 - so
14:31 - it folded over maybe so that we
14:33 - can no longer see it with the camera
14:36 - so let's do it a little bit less
14:39 - okay there we go so now we can see that
14:41 - it lays
14:43 - down
14:44 - but not completely 90 degrees
14:47 - but for now we can keep it like this for
14:50 - a while we can see that
14:52 - it's almost correct
14:55 - because once we can move the camera
14:57 - around it's going to be easier for us to
15:01 - to flip it back then because then we
15:03 - will add gravity and we will fall down
15:05 - onto the ground but let's keep it like
15:07 - this just that we at least at least can
15:09 - see that we have the ground there
15:11 - alright so we have the ground
15:15 - let's start to work on the player
15:20 - so our player needs to have a camera
15:24 - so we can the structure
15:27 - camera
15:28 - from
15:30 - a hook
15:34 - called use
15:36 - three
15:39 - so that hook is from reactory fiber
15:42 - so we also need some type of geometry to
15:45 - represent the player the geometry that
15:48 - can collide with other geometries and so
15:50 - on
15:52 - so for that we can use a sphere so this
15:55 - will be similar to what we did to the
15:57 - plane for the ground
15:59 - so we'll do use
16:01 - sphere
16:04 - and we call
16:06 - we call use sphere
16:09 - and it takes a function
16:11 - that returns back an object
16:16 - so here we can set
16:19 - mass we'll set that to one
16:21 - we'll set type to be
16:23 - dynamic
16:25 - and we'll return a mesh
16:32 - and attach the ref
16:38 - and then let's add
16:40 - our player
16:55 - all right
16:59 - so we we should have a player now
17:03 - so the next thing
17:05 - so we won't see that anything change yet
17:09 - so we need
17:10 - somewhere to store the position of our
17:13 - player
17:17 - so let's create a variable called
17:19 - position
17:22 - and we'll do a reference
17:28 - and it has x y z coordinates so we'll do
17:31 - zero zero zero
17:33 - to begin with
17:35 - now we will call the use frame hook
17:41 - so this hook will run on every frame
17:45 - so what we want to do now is attach the
17:48 - camera to this
17:50 - position that we're going to connect to
17:54 - our player
17:58 - so what we can do is that we can take
18:02 - the camera
18:03 - which is from use three
18:06 - and we take the position
18:10 - and we copy
18:15 - and we pass in a new
18:18 - vector 3
18:22 - and this vector we give
18:24 - position dot current
18:29 - and we give it the x and then we do the
18:31 - same for y and set
18:38 - position.current.1 which is y
18:40 - and position dot current
18:44 - two
18:48 - so now we should have a camera that
18:50 - follows
18:52 - this reference to a position here
18:55 - okay we can set the console log here
18:58 - just to see that
19:00 - our frame is running
19:02 - okay so we see that
19:04 - we no longer see the ground and we have
19:06 - frame console login here so we can see
19:08 - that it runs on every frame
19:13 - so let's remove this so
19:14 - we did something to the camera at least
19:16 - that is good so if we uncomment this
19:19 - line
19:20 - we should see the ground again
19:23 - and we do
19:25 - so that's good
19:27 - so we were able to move the camera we
19:29 - copy it to this position
19:32 - every frame
19:34 - so our next step is
19:36 - to have this position
19:40 - follow the position of this sphere
19:44 - because this sphere will be affected by
19:47 - physics and gravity
19:50 - so we can do a use effect
19:58 - and this
19:59 - use
20:00 - effect
20:02 - will need to re-run every time the
20:05 - sphere changes position
20:07 - so we can
20:08 - take out element number two here from u
20:11 - sphere which is the api
20:13 - an api towards the sphere
20:16 - so we'll say that
20:18 - rerun this effect every time the sphere
20:22 - api position changes
20:25 - and what we want to do when the position
20:27 - changes
20:28 - we want
20:30 - api dot position dot subscribe
20:36 - and subscribe takes a call back
20:40 - where we get
20:42 - call it p and we'll say
20:45 - position dot
20:47 - current is equal to p
20:52 - so p is a triplet
20:54 - so it will look
20:56 - like this
20:57 - so now we have a sphere that is
21:00 - connected to this reference
21:02 - or let's say this reference follows the
21:04 - sphere
21:06 - and
21:07 - we can get the camera to follow this
21:10 - reference so our goal is to get this
21:13 - camera to follow the sphere
21:20 - okay so now i added back the camera
21:24 - so we can see that something
21:26 - happens we get ejected i don't know if
21:29 - we may be colliding with the ground
21:33 - and then to handle that collision we
21:35 - just get ejected
21:37 - if i change the set value here
21:39 - so if i do 10 and i reload i land on the
21:43 - ground but because remember what what
21:47 - technical depth we had from the ground
21:49 - we didn't flatten it to 90 degrees
21:51 - properly
21:52 - so now would be a good time to fix that
21:55 - so like i said to to rotate 90 degrees
21:59 - that is half of a pie
22:01 - so now we flatten the ground out
22:07 - so we fly up and then we land on the
22:09 - ground we have
22:12 - taken the camera
22:15 - we
22:16 - glue the camera to our position
22:18 - reference
22:20 - and then we subscribe to
22:24 - api position changes of the sphere
22:27 - so we have a rift that tracks the sphere
22:29 - and then we glue the camera to a
22:31 - reference hopefully that makes sense so
22:33 - we need to do
22:35 - similar things to the velocity
22:39 - so let's copy
22:40 - this position code here
22:43 - i will call it
22:44 - call this vel
22:48 - and here we track api dot velocity
22:56 - api dot velocity
23:03 - so here we get v
23:07 - and we'll set
23:09 - vel dot current
23:11 - to v
23:13 - so now we have
23:15 - a reference of the velocity
23:20 - that subscribes to the velocity of the
23:22 - sphere
23:24 - okay so let's fix this catapult effect
23:26 - thing
23:28 - so what i suspect happens is that when
23:30 - the sphere is inside of the ground plane
23:35 - they that state cannot exist so we just
23:38 - get
23:40 - flung out so that there's no collision
23:42 - anymore
23:44 - so we need to lift up the sphere a bit
23:47 - so let's try five
23:53 - so now we
23:54 - start from above
23:56 - the plane and then we fall down to it
23:59 - so let's see how close we can get
24:06 - so if we put one we seem to be standing
24:09 - on the ground as we start so that's
24:11 - great
24:12 - let's see if we can actually trigger
24:16 - some movement on the sphere
24:19 - so we
24:21 - have the api
24:23 - so we can do api dot velocity dot
24:29 - set
24:31 - so here we can give it the x y and z
24:33 - velocities
24:36 - so we can do 0 1 0 then we should be
24:39 - constantly lifted upwards
24:42 - so we'll do something similar to this
24:44 - when we implement jumping because then
24:46 - we want to set velocity upwards but just
24:50 - for a short while so it so you fall back
24:52 - down so it's a normal jump
24:54 - all right so i think before we can move
24:56 - with before we can
24:58 - move forward pun intended with the
25:00 - player
25:02 - we should make a hook for the keyboard
25:04 - inputs so that we can register different
25:07 - key presses
25:09 - that we're going to use to control this
25:11 - sphere that is the player
25:13 - so let's
25:15 - add this
25:16 - to our to-do list
25:18 - keyboard
25:20 - inputs
25:23 - so the player
25:25 - is not yet done
25:27 - we'll move to the keyboard inputs first
25:33 - so the keyboard input is actually a hook
25:36 - so let's do a hooks folder
25:40 - and we'll call it use
25:42 - keyboard
25:44 - export const use
25:48 - keyboard
25:49 - so we'll need to have some state here to
25:53 - keep track of what keys are pressed
25:57 - so we'll do
25:59 - we call it
26:01 - movement
26:04 - set
26:05 - movement
26:09 - use state
26:11 - so let's set up this initial state
26:14 - right so we need to map out all the keys
26:17 - and call them things that we understand
26:20 - so one action is move forward
26:23 - move backward we also have move left
26:27 - and move
26:30 - right we have jump
26:32 - and then we have
26:34 - texture one
26:35 - [Music]
26:37 - two three
26:39 - four five i think that should be
26:42 - all the
26:43 - now that we have textures we should
26:45 - maybe call it actions so now we need to
26:48 - have a use effect
26:52 - and inside here we do document dot add
26:55 - event listener
26:59 - listen for key down
27:03 - then
27:07 - we need to create some functions to
27:09 - handle this
27:12 - key up
27:14 - and since we're adding
27:16 - event listeners we also need to return a
27:19 - function that removes them
27:22 - otherwise we will add endless
27:25 - event listeners
27:27 - handle key down
27:31 - we wrap this in the use callback
27:35 - so inside here we get
27:37 - the key
27:38 - down event so let's create some helper
27:41 - function to determine
27:43 - what key maps to what
27:46 - so we'll do
27:48 - function
27:49 - action
27:50 - by key
27:52 - so here we get a key
27:55 - key map
27:58 - key action map
28:00 - so here we say key
28:04 - here we need to type it as they
28:06 - as they are called in the key event so
28:11 - key w like this
28:14 - we'll call it move forward and we have
28:18 - space
28:21 - for jump
28:24 - and then we have
28:25 - digit one
28:27 - and now we can say what texture it
28:30 - corresponds to we'll say it's dirt
28:37 - and the last one is
28:41 - log
28:42 - so now we mapped out what keys belongs
28:44 - to what actions
28:47 - and then we just return
28:49 - key action map
28:52 - with key of course we need to check
28:55 - so that only we only react to the keys
28:58 - that we are listening for
29:02 - action by key e dot code
29:07 - so now we can do
29:09 - set
29:10 - movement and of course we need to
29:13 - preserve the previous state
29:20 - so we
29:21 - spread the previous date and then we set
29:38 - we can do action equals action by key
29:43 - e dot code
29:45 - now we can just say
29:48 - if action
29:56 - action
29:58 - is true
29:59 - and this is now called
30:02 - set action
30:04 - actions
30:06 - okay so
30:07 - it will be very similar for a handle key
30:10 - up
30:16 - just that we set this to false
30:20 - so here we need to handle key down and
30:23 - handle key up
30:26 - and then we just return
30:29 - the actions
30:33 - let's try this hook from the player
30:35 - component
30:37 - i'll do like this so we'll just see
30:39 - those that are true
30:48 - key and value and we
30:51 - return
30:53 - those that have true
30:55 - all right so now we should be able to
30:58 - see in the console log when we press
31:01 - these different keys that we are looking
31:03 - for
31:05 - okay so we have no actions when we start
31:08 - that's good so now i press w
31:11 - because i'm not getting anything so
31:13 - let's debug
31:16 - let's see if we are here
31:23 - yes we get the keyboard event action by
31:26 - key action by key is a function not a
31:29 - map
31:31 - so this should fix that and same thing
31:34 - here
31:38 - so i'm pressing w
31:41 - s
31:42 - a d
31:44 - jump
31:45 - spacebar
31:46 - and the digits one two three four five
31:50 - okay so we have everything working so
31:52 - now we can react to these actions
31:57 - and control the movement of the sphere
32:00 - by looking at what key process we're
32:03 - doing so we can cross off the keyboard
32:06 - inputs alright so let's control the
32:09 - player using the keyboard inputs and i
32:12 - think an easy one to start with
32:14 - is the jumping
32:16 - because
32:17 - this requires some vector math
32:20 - so it will be a little bit
32:22 - tricky but i think we'll manage it
32:25 - so first we can look at
32:30 - if
32:31 - actions dot
32:33 - jump
32:36 - that means that we are jumping
32:39 - we can reuse this code
32:46 - here we can for the x we just
32:50 - keep the value
32:51 - and for said we'll just keep the value
32:57 - and here
32:58 - this is
33:00 - a constant that will use for
33:03 - the jumping so let's store it
33:08 - jump
33:12 - jump
33:15 - force
33:17 - let's try 10.
33:26 - jump
33:28 - jump force
33:31 - okay
33:32 - let's try it out
33:34 - spacebar
33:35 - alright so we achieved the jump
33:38 - it felt a little bit too high
33:42 - and also
33:43 - we can jump indefinitely which is wrong
33:48 - so first let's fix the jump height let's
33:51 - try three
33:58 - yeah that's better
34:00 - i'll try four for now
34:04 - so we need to do another if check here
34:06 - if we can jump again and one easy way
34:11 - of
34:12 - eliminating all these extra jumps
34:14 - is that we make sure that our y
34:17 - velocity is zero make sure that we're
34:19 - not moving up and down because whenever
34:22 - we are moving up and down it means that
34:24 - we are falling through the sky or
34:27 - already jumped and we are on our way up
34:29 - so we need to make sure
34:31 - that
34:32 - the velocity in the y direction is
34:36 - really close to zero
34:39 - so let's do
34:41 - since we we care about positive and
34:43 - negative we can do
34:45 - absolute value
34:47 - and we have it on velocity dot
34:52 - current
34:56 - it's vel right
35:02 - current one
35:03 - should be smaller than zero dot
35:08 - let's do zero dot
35:10 - zero five maybe
35:12 - okay so let's try
35:14 - good we can still jump
35:17 - i'm pressing it
35:19 - continuously but we we're only allowed
35:21 - to jump once we've landed
35:26 - there's one bug that we should fix
35:28 - and that is that we can
35:31 - we can jump if we hit right in the
35:34 - moment when we're actually slowing down
35:37 - from going up to going down again
35:40 - so it's uh
35:42 - the the velocity there becomes almost
35:44 - zero
35:46 - at a certain frame
35:48 - so if i can time that frame
35:50 - you can see that i can jump two times in
35:53 - a row
35:54 - but we'll leave it like that
35:56 - for now so we can start to think about
35:59 - how we move
36:01 - in a direction and
36:04 - the tricky part about it is that
36:07 - later on we will be able to turn around
36:10 - so w will always take us in the camera
36:14 - direction
36:15 - so we need one vector to represent what
36:18 - direction we are facing
36:19 - another vector for the forwards and
36:22 - backwards speed and the other one for
36:24 - this
36:25 - side speed
36:26 - so let's create those vectors
36:29 - one
36:30 - direction vector
36:37 - vector three
36:41 - and
36:41 - [Music]
36:45 - call it front
36:47 - vector
36:50 - also a vector 3
36:52 - and a side vector
36:55 - so the front vector
36:57 - it's this said axis here that will
36:59 - determine
37:00 - us going forwards and backwards
37:04 - so both the move forward and move
37:07 - backwards should affect this
37:09 - force here
37:11 - so one way of doing it is
37:14 - we check
37:15 - actions dot move backwards
37:20 - and we set it to one
37:23 - if we're moving backwards
37:25 - or zero
37:28 - and then we subtract
37:30 - the same thing
37:32 - but for moving forward
37:37 - so if we press them at the same time
37:39 - they cancel out we could actually
37:41 - destructure
37:43 - here
37:44 - move four backwards move forward move
37:48 - right move left jump
37:52 - then we can clean this up
37:57 - like this
37:58 - and like this
38:01 - all right so we have this one one or
38:04 - zero and this one one or zero and if
38:06 - they are both one
38:08 - they cancel out which is a good thing
38:10 - because if you
38:11 - go forward and then you start to hold
38:13 - backwards also
38:16 - then you should stop right that's what
38:18 - we see in games
38:21 - so then we've taken care of the front
38:23 - vector
38:25 - so let's do something similar for the
38:27 - side vector
38:30 - so we'll copy this
38:34 - so now we're not moving in the set
38:35 - direction anymore
38:38 - i think this should be the
38:40 - x direction
38:44 - and here it's moved
38:47 - left
38:50 - and here it's move right
38:53 - so we get the same behavior there if
38:55 - you're holding both at the same time
38:58 - you should go nowhere
39:03 - there we go
39:04 - so now we're going to do some
39:06 - calculations
39:08 - and we'll we will originate from the
39:10 - direction vector so the direction
39:14 - dot
39:15 - subtract
39:17 - vectors
39:19 - and those
39:20 - vectors are the front vector and the
39:22 - side vector
39:24 - and then we'll chain on some more
39:26 - operations
39:27 - we normalize
39:30 - and then we
39:32 - multiply scalar
39:36 - and here we need to
39:38 - determine how fast we want to go
39:41 - so let's
39:42 - also make a
39:45 - variable for that or as constant
39:48 - we'll try 4 for speed as well
39:50 - so we'll multiply the speed
39:54 - and then finally
39:56 - we apply euler
40:02 - and this is where we
40:04 - get
40:05 - the correct facing direction from the
40:07 - camera
40:08 - so we have a reference to the camera and
40:10 - its rotation
40:12 - so this is where we make sure that the
40:14 - front and side vectors are correct
40:17 - in relation to the camera
40:20 - so now we can take this direction vector
40:23 - and apply it to the sphere
40:26 - so api dot velocity
40:31 - dot set
40:33 - and then we
40:34 - do the direction dot x
40:38 - direction dot y
40:41 - and
40:44 - direction.
40:46 - but that's not completely true because
40:49 - the y axis is not controlled by these
40:52 - front and side vectors this is just for
40:54 - moving backwards and forwards and to the
40:56 - sides so the y should actually stay
41:00 - the same
41:02 - so the vel dot current
41:05 - one
41:07 - so that should be enough in the best of
41:09 - worlds we would be able to move at this
41:12 - point
41:16 - see if we need to refresh
41:20 - all right i think we're missing the new
41:22 - keyword here
41:24 - for the vectors
41:26 - there we go
41:27 - all right so we have a typo here
41:31 - okay so let's try i'm pressing forward
41:35 - all right so forward is working
41:38 - backward is working
41:39 - now we'll try backwards and forwards at
41:42 - the same time
41:44 - and it stops that's great let's try left
41:48 - and right at the same time and i let go
41:50 - of left
41:52 - alright
41:54 - so that seems to be working
41:57 - so we cannot yet test that it will be
42:00 - still correct when we turn the camera
42:03 - that we will do once we
42:06 - once we build out the
42:09 - the pointer lock controls
42:12 - where we can control the camera with the
42:14 - mouse alright so i think
42:17 - we are done with the player for now
42:20 - let's move forwards with the first
42:23 - person view
42:25 - so we'll create a component
42:27 - fpv
42:31 - this one is actually quite simple
42:33 - because we get a lot of help from
42:37 - react 3 fiber here
42:38 - ok so we need of course to connect this
42:42 - to the
42:42 - camera so we need use
42:45 - three
42:50 - where we can get the camera
42:58 - okay so we return
43:04 - pointer lock controls
43:09 - args is
43:12 - camera
43:13 - destruction gl here
43:17 - passing that
43:18 - as gl dom element
43:23 - fpv
43:25 - from fpv
43:28 - and just render it
43:35 - all right so when i click here now
43:39 - it should lock the camera
43:41 - to how i move the mouse
43:43 - so now i can look around
43:45 - so now we can see that if i'm facing
43:47 - left i can move straight ahead and if i
43:50 - turn a bit
43:51 - i can still move straight ahead so our
43:53 - player movement seemed to work fine
43:56 - and the pointer lock controls seem to
43:58 - work as well
44:00 - there's one thing we should do with the
44:02 - first person view is that we should add
44:05 - a small cursor to
44:09 - the middle of the screen so outside of
44:11 - the canvas let's add a div
44:15 - class name
44:17 - cursor
44:19 - and let's put just a plus there and
44:22 - let's position it absolute
44:26 - and we're going to center this on the
44:28 - screen so let's make a class called
44:31 - centered
44:32 - so this is position absolute so we do
44:36 - top
44:36 - fifty percent
44:38 - left
44:39 - fifty percent
44:41 - we need to add a transform
44:43 - translate
44:48 - minus fifty
44:49 - and minus 50
44:52 - so that is just because if we
44:55 - if we center it 50 50
44:58 - without doing this transform translate
45:01 - then
45:03 - it will not actually be in the middle
45:05 - because
45:07 - i think i can show you this background
45:11 - hot pink if we make this bigger
45:16 - we see that it is in fact centered but
45:18 - if we don't have this translate
45:20 - this is what will happen the top left
45:22 - corner of the square will be in the
45:24 - center
45:25 - so what we're adjusting for with 50 is
45:28 - 50
45:29 - of the width and height of the square
45:33 - so then it would move to the middle
45:35 - but this one doesn't need to be big at
45:38 - all so we'll remove these two
45:41 - that looks good and then remove the
45:43 - background
45:46 - so move the the color styling to cursor
45:55 - there we go
45:56 - now we have a marker to indicate the
45:59 - center of where we are watching great i
46:01 - think we are done with
46:04 - the player for now so we will cross out
46:06 - first person view we're also done with
46:10 - gravity
46:11 - and we are done with the movement our
46:14 - next item on the agenda is to add a
46:17 - state manager
46:19 - we can add a hook called use store that
46:22 - keeps track of the game state let's
46:25 - create our hook
46:27 - use store
46:29 - so we'll need
46:31 - create from
46:33 - sue stand
46:35 - use
46:36 - store
46:40 - we can wrap this in create
46:44 - and we get a setter method here as an
46:48 - input parameter so we will return an
46:51 - object so we call create we pass it a
46:53 - function that returns an object
46:56 - so in this object we can declare our
46:59 - state
47:00 - so we need to keep track of a texture
47:04 - and we can default the texture to
47:08 - dirt we need to keep track of the cubes
47:12 - that the player is going to be able to
47:14 - place
47:16 - so we can just default that to an array
47:18 - and now we're going to declare our
47:21 - methods that you can use to interact
47:23 - with the state so we'll of course have
47:25 - add cube remove cube you need to be able
47:28 - to set the texture and for later we want
47:31 - to be able to save the world reset world
47:35 - these are all the operations that we
47:37 - need to support
47:38 - in our
47:39 - store so when we add a cube
47:43 - all we need to know is
47:45 - where to place it
47:47 - because the texture we already know
47:49 - since we are in the store so when when
47:52 - someone calls add cube
47:55 - we need to call set
47:58 - and in set we pass it a callback
48:01 - function and we get back
48:04 - the previous state so here we can return
48:06 - an object so here we just want to affect
48:09 - the cubes which is an array
48:12 - so we spread in
48:14 - the previous
48:16 - cubes
48:19 - and then
48:20 - at the end we add a new cube and
48:24 - every cube needs to have
48:26 - a key
48:28 - and then we can use nano id for that
48:35 - we have a position
48:36 - that we get from xyz that's being passed
48:39 - in and then we have the texture
48:41 - which we can get from priv
48:46 - so that should be all it takes for us to
48:48 - add a cube but before we
48:51 - do that we need a way to render cubes so
48:54 - i suggest that we leave the store like
48:57 - this for now with just a method of
48:59 - adding cubes and then we create the
49:02 - component to render a cube
49:04 - and then we can start to
49:07 - render them out we can actually
49:09 - initialize the state
49:11 - with one cube just for debugging let's
49:13 - do one one one so now we always have
49:17 - one cube initially that we can
49:20 - quickly see
49:21 - if when we start to rendering the cubes
49:24 - if they come out
49:26 - so i suggest i suggest that we leave the
49:28 - store like this before we finish the
49:30 - rest of the store functions
49:34 - and then start to working on rendering
49:36 - our first cube so let's add a new
49:38 - component
49:40 - before we create the cube we should have
49:42 - a
49:44 - component that is taking care of
49:46 - rendering all the cubes essentially
49:48 - consuming the store and mapping out the
49:51 - cubes
49:53 - so we'll make a component called cubes
49:55 - so we need
49:57 - definitely to have
49:59 - used the use store
50:05 - from hooks
50:11 - so our use door hook
50:14 - we can
50:16 - we get the state back and then we can
50:18 - return an array where we can place
50:21 - different things from the state in
50:22 - whatever order we want
50:25 - so we want state dot cubes
50:29 - so then the first element here will be
50:32 - the cubes so if we do console
50:35 - log
50:36 - cubes we can return nothing here let's
50:39 - add cubes
50:41 - cubes
50:46 - so since the player needs to be able to
50:48 - stand on the cubes the cubes need to be
50:51 - within the physics
50:54 - slide it like that
50:57 - okay so we consoled out the cubes and
51:00 - this is our debugging cube that we added
51:02 - a dirt cube on position one one one so
51:05 - now we can start working on
51:08 - mapping out those cubes so we return
51:22 - here we're going to use the cube
51:24 - component
51:25 - so let's create that one first
51:37 - since we're doing a mapping we need to
51:39 - use the key
51:42 - which is something that we have on the
51:44 - cube already
51:45 - we have key we have x y zed
51:49 - texture so here we can use the key this
51:52 - is actually position
52:02 - so we receive position
52:06 - and texture
52:08 - so to create the cube we're going to use
52:10 - the
52:11 - the canon use
52:13 - box
52:14 - hook
52:30 - so we'll set type is
52:33 - static
52:36 - and we have the position from the
52:38 - incoming prop
52:42 - so here we return a mesh
52:46 - and to the mesh we connect the ref
52:49 - here we need a box
52:51 - buffer geometry
52:54 - and we also need
52:55 - a mesh standard material
53:00 - attach
53:01 - as
53:03 - geometry
53:10 - color is hot pink
53:13 - do we have a cube anywhere okay so i see
53:16 - we called it position in the store
53:20 - and here we're destruction
53:23 - position
53:28 - so we need to call it puss here
53:42 - oh
53:45 - okay
53:46 - so the reason i couldn't find the cube
53:48 - was because i was standing on it i feel
53:51 - very stupid now
53:54 - that's good so let's play around with
53:57 - these values
53:59 - see if we can get get it up in the air
54:07 - all right
54:08 - so there we have our first cube
54:37 - right so we have the cube standing on
54:39 - the ground
54:40 - so now let's fix
54:42 - the texture of the cube
55:07 - so let's pass in the texture
55:14 - in the store we just call it
55:17 - dirt and in textures we call it dirt
55:20 - texture
55:21 - so let's do texture plus
55:25 - texture
55:27 - so we import all the textures as
55:29 - textures
55:31 - and then
55:33 - we map it by
55:34 - the texture in the store plus texture
55:37 - and then we get our active texture
55:40 - then we can do map
55:43 - active texture
55:47 - and remove the color
55:50 - there we go we get the dirt texture on
55:53 - the cube
55:54 - let's move it a bit closer to us
56:06 - so as we can see it doesn't
56:08 - look so good so we need to do the same
56:11 - treatment we did to the grass to every
56:14 - cube texture so we'll test it with dirt
56:17 - dirt texture
56:21 - mag filter
56:25 - nearest filter
56:28 - let's see if that helped yeah now it
56:30 - looks good and pixelated and not
56:33 - smooshed
56:40 - let's do it to ground texture in here as
56:42 - well since we are already here and then
56:44 - we don't have to do it
56:47 - in here let's
56:49 - move these out as well
56:53 - there we go so now we fixed it for all
56:56 - the textures inside of the texture file
56:58 - instead to keep our components more
57:00 - clean i was thinking to maybe keep this
57:03 - in ground because it correlates to the
57:06 - size of it
57:08 - so we'll keep it here
57:10 - so now we should be able to add a second
57:12 - cube with another texture
57:22 - i will pick another position
57:25 - texture
57:28 - would
57:32 - all right so now we can render cubes
57:33 - with different textures and this one
57:35 - looks nice as well since it's been fixed
57:38 - alright so now we have a way of
57:40 - rendering cubes once they are added to
57:42 - the store all right so we have the
57:45 - basics of the state management and we
57:48 - have the cube's
57:51 - basics as well
57:55 - something that is missing in this list
57:57 - is
57:59 - adding
58:01 - cubes
58:02 - so one way of adding a cube is to click
58:05 - the
58:06 - ground so let's open the ground
58:09 - so we need to get the add cube
58:13 - method from use store
58:22 - add cube
58:31 - and return an array with state dot add
58:34 - cube all right so we had have the add
58:37 - cube
58:38 - method
58:40 - uh but we need to figure out the x y and
58:43 - z coordinates to
58:45 - uh to pass to this function so let's add
58:47 - an on click to this mesh
58:59 - let's do e dot stop propagation
59:04 - so that the click cannot be passed
59:06 - through the ground so on the event we
59:09 - have something called e dot point
59:13 - so we want to get x y and z
59:18 - we can do object
59:20 - dot
59:22 - values
59:23 - from e dot point
59:27 - so let's stop here to check out what
59:29 - happens when we click the ground
59:32 - so we have e
59:37 - let's look at point
59:41 - so we have
59:43 - a vector 3.
59:46 - so we just want to get
59:48 - the values of this vector we don't want
59:50 - to pass the whole object
59:53 - so if we do object.values we just get
59:56 - these three values and we destructure
59:58 - them out here
60:00 - so if we hover
60:03 - the xy and said we see that we do in
60:05 - fact get the values here as you saw
60:07 - there are
60:08 - a lot of decimals here we want
60:11 - the cubes to end up on fixed location
60:15 - according to this grid that we can see
60:17 - here in full numbers
60:19 - so we need to round this so we need to
60:22 - do a mapping of these values
60:25 - and return math math.c
60:28 - of the value
60:30 - and then we should be able to call
60:32 - addcube with x y and zed
60:36 - right so let's try this out
60:39 - let's reload and we click the ground
60:44 - and we do get a cube
60:50 - so as we can see
60:52 - the seal function made it
60:55 - round up so let's try with floor instead
60:58 - so as we can see i think we should try
61:01 - moving the ground
61:03 - down
61:05 - by half a unit and see if that will make
61:08 - the cubes
61:11 - lay flat on the ground so let's try that
61:16 - so now that we fix the ground
61:20 - we can go back to seal here
61:25 - math.seal and when i click the ground we
61:29 - actually get cubes added pretty cool
61:32 - so now let's lower these default cubes
61:35 - or we can actually remove these default
61:38 - cubes now that we have a way of adding
61:40 - cues for real okay so we handle the case
61:43 - where you click the ground and you want
61:45 - to add a cube but what about when you
61:47 - click the surface of a cube to add a
61:50 - cube next to it
61:52 - okay so let's handle the clicking of
61:56 - cubes so we can copy this
61:59 - state call here because we want to do
62:02 - the same
62:03 - inside of cube
62:08 - but we also want to have remove cube
62:11 - later on so let's add that straight away
62:17 - so my plan is that if you hold in the
62:19 - modifier key and click then
62:22 - you can remove cubes as well
62:30 - so let's add an on click
62:41 - we stop propagation
62:45 - so here we need to handle a few things
62:49 - a cube has six sides and the side that
62:53 - you actually click
62:55 - needs to get another cube
62:57 - next to it
63:00 - so we'll create a variable clicked face
63:06 - and a face of a cube actually has
63:11 - two triangular shapes that covers the
63:14 - face so it's not a full square it's two
63:19 - triangles
63:21 - that together cover the square face
63:25 - so instead of six faces it has 12 faces
63:29 - but that is pretty
63:31 - easy to fix
63:33 - so we can just take take e dot phase
63:36 - index
63:38 - and divide this by two
63:40 - and then we will be in the range between
63:43 - 0 and 5 instead of 0 and 11.
63:48 - and we will of course need to math dot
63:51 - floor it
63:53 - because
63:54 - there's no
63:55 - 0.5 phase index so now clicked face
63:59 - should be between 0 and 5. so let's
64:01 - console log
64:05 - face
64:06 - click face
64:08 - so let's add a cube
64:10 - here phase four
64:13 - phase one
64:15 - phase five
64:17 - phase zero
64:20 - top is phase two and the bottom should
64:22 - be phase three then
64:25 - so now we just need to write if
64:26 - statements to cover all these clicked
64:29 - faces
64:30 - so if it's zero
64:32 - and cube so we have a ref to the box
64:35 - that has a position so we can do
64:40 - x y set
64:42 - from
64:43 - ref
64:45 - current position so we can pass in x y
64:49 - set
64:51 - and then we need to on one of them
64:54 - maybe subtract one to the x
64:57 - and for another face we need to do x
64:59 - plus one but it's a little bit of
65:00 - guesswork to figure out what phase is
65:03 - what direction if you understand what i
65:05 - mean
65:08 - one two three four five
65:10 - six
65:20 - so something like that this will most
65:22 - likely be wrong all right so we add a
65:24 - cube we click one face
65:27 - so here we see that it was
65:30 - the opposite
65:35 - all right so now we have logging as well
65:39 - so if i click this face we see that it
65:41 - was four and the cube was added on the
65:44 - other side
65:45 - so clicked phase four
65:48 - just needs to flip
65:50 - and then let's flip this one
65:53 - if i click
65:55 - this face
65:58 - that was
65:59 - phase one and that was also flipped
66:04 - so
66:04 - this should probably minus one
66:07 - and maybe plus one here
66:11 - let's try the top
66:17 - so
66:18 - phase two nothing happened so i'm
66:20 - suspecting that there's a cube
66:22 - underneath
66:24 - so this should probably be plus one and
66:27 - this should be minus one
66:30 - so let's try again to click the top yeah
66:32 - now that was correct
66:37 - so i think we might have it
66:41 - nice
66:42 - now we can click a cube to add another
66:44 - cube next to it so now now it starts to
66:47 - become fun
66:48 - so we can return if we are done with the
66:51 - operation
66:56 - so now we can handle the removal of
66:58 - cubes
66:59 - if e dot alt key
67:02 - remove cube
67:04 - x y set
67:06 - and return
67:08 - and of course we haven't implemented the
67:10 - remove cube function yet
67:15 - so what we can do just to try it
67:17 - quickly is to just console.log here
67:23 - x
67:25 - y zed
67:27 - x y said
67:31 - remove
67:33 - all right so i'm holding down the alt
67:34 - key and i'm clicking it and we get a
67:37 - call to remove cube
67:39 - with x y said so that's great
67:42 - so now we can implement the remove cube
67:45 - function
67:48 - so we can
67:50 - borrow some code
67:52 - from ad cube
67:54 - we'll still call set
67:57 - but instead of
67:59 - adding to this array
68:02 - we can take pre-dot
68:05 - cubes dot filter
68:08 - cube or we keep all the cubes where
68:12 - x
68:13 - y and z are not
68:16 - equal to the xyz being passed in so with
68:18 - the structure
68:22 - x y and z
68:26 - from the cube
68:28 - then we return
68:30 - x not equal to x
68:35 - y not equal to y
68:39 - and said
68:41 - not equal to set
68:42 - so let's see if we can filter out the
68:45 - cube that we're clicking on
68:49 - let's add a few
68:56 - so here we need to say cube
69:00 - cube dot pulse all right let's try again
69:05 - so add a few cubes
69:07 - and then alt key
69:10 - and they were all removed i think the
69:12 - issue is that this should be or
69:15 - because if any coordinate is not correct
69:18 - it's not the the right box to filter out
69:22 - so let's try again
69:27 - there we go
69:29 - one cube being removed at a time great
69:31 - now we can remove cubes
69:33 - great progress
69:35 - alright so we are done with adding cubes
69:38 - and removing cubes
69:40 - so let's continue with
69:43 - the cube type selector so we should
69:46 - create some ui that indicates
69:49 - what
69:50 - selections there are and what is
69:52 - currently active so let's create a
69:54 - component
69:56 - texture
69:57 - selector
70:07 - and this one will not be a three
70:10 - component this will just be html and
70:12 - this one should just be visible when
70:15 - we're actually changing the texture so
70:17 - we need some state here
70:21 - let's determine if it's visible right
70:23 - now or not
70:26 - we'll default it to false
70:29 - we need to get
70:31 - the texture from
70:33 - from the store
70:35 - active texture
70:42 - state and we get
70:44 - an array back where we take state dot
70:48 - we just call it texture
70:54 - texture
71:04 - so let's
71:05 - call create a use effect that runs
71:07 - whenever the active texture changes
71:15 - active texture
71:18 - so if the active texture changes we want
71:21 - to have this texture selector visible
71:24 - for like two seconds and then we want it
71:26 - to disappear
71:27 - so we need a visibility timeout
71:32 - that is set timeout
71:41 - for two seconds
71:42 - so after two seconds we want to set
71:44 - visible false
71:46 - and immediately we want to set visible
71:50 - true
71:52 - and then we need to clear the timeout
71:59 - clear timeout visibility
72:05 - like this
72:08 - so we only want to show something is if
72:11 - visible is true
72:26 - so let's do class name
72:29 - absolute and
72:33 - centered
72:35 - so now we we also need to handle so that
72:38 - the texture is actually changed
72:41 - when we press the digits
72:44 - actions from use keyboard
72:57 - so in the store we have a set texture
73:00 - method
73:02 - so let's finish that we take a texture
73:06 - we call set
73:12 - we don't care about the previous
73:14 - we just want to set
73:16 - texture based on the incoming texture so
73:20 - let's look at use keyboard
73:22 - we have texture one to five
73:25 - this is what we want to
73:28 - dig out here
73:34 - so let's do a use effect again
73:37 - that will run for
73:38 - texture 1 texture
73:41 - 2.
73:46 - if texture won so now we need the set
73:49 - texture from the store
74:01 - set texture
74:03 - dirt
74:05 - okay we'll call this
74:07 - dirt
74:10 - grass
74:15 - glass
74:17 - wood and
74:19 - log
74:20 - so the actions will now contain props
74:23 - that are the actual names of the
74:25 - textures
74:34 - so we'll call it pressed texture
74:39 - so if any of these textures are true
74:43 - then that texture will be the pressed
74:45 - texture and then we can do
74:48 - if
74:50 - pressed texture
74:53 - set texture
74:55 - to pressed texture
74:57 - let's see pressed
75:00 - pressed texture
75:02 - so let's see if it works
75:07 - if i press
75:08 - one all right let's debug
75:15 - so if i press one there to be true so
75:18 - that's great
75:19 - so it works correctly in use keyboard
75:22 - and in the texture selector let's
75:25 - console log
75:27 - dirt
75:30 - let's see if we can get there to be one
75:32 - so one thing what we must do is add the
75:35 - texture selector to our app before we
75:38 - started looking for console logs in it
75:40 - so let's add it here
75:43 - texture
75:48 - all right so we get dirt falls
75:50 - we saw it there and as i press one
75:53 - we got dirt true
75:54 - and texture selector appears for two
75:57 - seconds and then gets removed
75:59 - so it looks very promising after texture
76:03 - all right so here we have our textures
76:05 - as
76:06 - booleans
76:08 - so let's create a mapping
76:11 - that will set
76:12 - the prop which is the name of the
76:14 - texture
76:16 - that will map from the name to the
76:18 - booleans
76:20 - so then we can do
76:22 - object dot entries
76:27 - find
76:31 - key value so we want to find
76:35 - a texture where the value is true if we
76:38 - have such a pressed texture we'll take
76:41 - the value
76:42 - from that all right
76:45 - so we get
76:47 - five booleans here
76:49 - and
76:50 - we put them in a mapping
76:54 - so we'll get dirt falls grass falls
76:56 - maybe glass true
76:58 - and if glass is true we will find the
77:01 - true texture
77:04 - store that in press texture so if we
77:07 - found a pressed texture
77:09 - we get
77:11 - the key of that
77:13 - by taking
77:15 - the first
77:17 - element in that tuple
77:20 - so let's see if it actually worked
77:24 - gr pressed grass pressed dirt pressed
77:27 - wood
77:28 - and press log so now i press glass
77:34 - so this is the glass cube
77:36 - pressing dirt
77:38 - and i get a dirt cube
77:41 - so cool we have
77:42 - a way of selecting
77:44 - different textures just using the
77:46 - keyboard i know what happened with this
77:48 - cube
77:50 - but let's continue building the ui
77:53 - to show the actual selections
77:58 - so we already have a list of images
78:01 - with these so let's import those images
78:10 - okay so let's create a mapping here
78:14 - images
78:18 - so we keep the name that they are called
78:21 - in the store
78:24 - to the actual image
78:33 - so we need to loop this
78:36 - in a map here images
78:38 - i will do object dot entries
78:42 - images so here we get
78:45 - key and
78:47 - source image
78:50 - so we can return an image
78:54 - image tag
78:58 - source is
79:00 - source
79:02 - key is
79:04 - okay
79:08 - and now we need to check
79:11 - which one is the active one
79:14 - and that we can do by adding a class
79:16 - name
79:17 - so here we can do
79:19 - k
79:20 - equals
79:21 - active texture if that is true if that
79:24 - is true we add active
79:26 - otherwise
79:28 - nothing
79:29 - and let's have an alt prop
79:31 - put the
79:32 - the name of the texture all right so
79:35 - let's see if anything happened so when i
79:38 - change the texture now
79:40 - here we have an error this should be
79:43 - an array
79:46 - so now let's see oh we got it
79:50 - so when i change texture
79:53 - the texture selector appears
79:56 - so we should just make it bigger
80:01 - let's add a class
80:08 - texture
80:09 - select
80:13 - so we can do transform
80:16 - scale
80:18 - 10
80:19 - it should be select door
80:23 - there we go that's bigger
80:28 - let's do maybe five
80:30 - and then let's handle
80:33 - the active also
80:35 - so if we have an image.active there
80:40 - let's do a border
80:43 - of
80:44 - two pixels solid
80:47 - red
80:49 - so let's see if we can see which one is
80:51 - active
80:52 - yes we can
81:01 - okay so we
81:02 - between the four and the five we have
81:04 - the wrong digits
81:06 - so that is probably because i typed them
81:09 - in the wrong order here
81:16 - all right now they work correctly
81:18 - all right let's see all our cues
81:22 - we have
81:23 - wood or log we have wood
81:27 - we have glass
81:28 - we have grass and we have dirt
81:31 - really nice
81:32 - let's remove this console log all right
81:35 - so our cube type selector is done
81:38 - the next thing on the agenda would be to
81:41 - save the world in local storage so that
81:45 - is something that we can do inside of
81:48 - our store so let's create some helper
81:51 - functions
81:53 - to talk to the local storage so what we
81:56 - want to store
81:57 - in the local storage is an array
82:00 - so we need to do json parse and json
82:02 - stringify
82:04 - to talk to the local storage
82:06 - so let's call create a helper function
82:08 - get local storage
82:15 - so we take in a key and we return
82:18 - json.parse
82:22 - window local storage
82:26 - get item of key
82:29 - so all we're doing is json parsing what
82:31 - we get from local storage
82:33 - and let's do
82:35 - a similar function
82:37 - with
82:38 - set local storage we take in a key
82:42 - and of course the value that we want to
82:44 - set
82:45 - and then we do json stringify
82:55 - set item
82:58 - and then we set
83:00 - we pass the key
83:02 - actually this json string if i should be
83:06 - just wrapping the value
83:12 - value
83:14 - right so now we have our helper
83:16 - functions
83:18 - so when we first create
83:21 - this date we want to do get local
83:24 - storage
83:26 - and we can just make up a key here we'll
83:29 - call it cubes
83:31 - so we'll either get something
83:35 - or it will be empty
83:37 - so we'll fall back to the empty array so
83:39 - now we can implement
83:42 - these two functions let's start with
83:43 - just resetting the world
83:46 - that would just be set
83:51 - and then we just set the cubes
83:55 - to be
83:56 - empty ray
83:57 - like that that should reset the world
84:00 - and then we have say world so we call
84:02 - set just to get the current state
84:06 - and inside here we just call set local
84:09 - storage the key was cubes
84:12 - and we store
84:14 - red dot cubes
84:17 - so we don't need a load world function
84:19 - because
84:20 - that happens when we just reload the
84:23 - page
84:24 - but we we also need to create some
84:26 - buttons on the ui for this let's create
84:30 - a component called menu
84:41 - so we want to access save world and
84:45 - reset world
84:48 - from use
84:49 - store
84:54 - so
84:55 - state
85:00 - reset world all right
85:05 - so let's create some ui
85:12 - last name of
85:15 - menu
85:16 - and
85:17 - absolute
85:21 - we need save
85:24 - and we need
85:26 - reset
85:31 - on
85:32 - click
85:36 - save
85:38 - world
85:47 - reset world all right
85:49 - let's import menu
85:58 - so let's see where we have our menu
86:00 - we have it but it's down there so we
86:02 - need to style it so it becomes in the
86:04 - top
86:10 - so we'll do top
86:12 - 10 pixels
86:14 - left
86:15 - 10 pixels
86:18 - there we have them
86:22 - all right so let's
86:24 - try them out
86:25 - we'll place a few cubes of different
86:28 - types
86:32 - all right we have a nice line here
86:34 - let's save it
86:37 - so now it should be in local storage we
86:39 - can verify that application
86:42 - local storage we have cubes and there we
86:45 - have the cubes
86:46 - so now when i reload the page
86:50 - we have any cubes oh here they are
86:53 - really cool so now we can persist it of
86:56 - course we can also reset
86:59 - but they are still in local storage so
87:01 - if i just reload
87:04 - the cubes
87:05 - will be there alright we are done with
87:08 - saving the world in local storage but we
87:11 - have one more thing that would be nice
87:12 - to have
87:14 - hover state on cubes
87:19 - i think it would be nice if when the
87:22 - cursor hovers the cube that they become
87:24 - a bit darker so that you indicate what
87:27 - cube you're actually hovering on right
87:29 - let's keep track if a
87:32 - cube is hovered
87:36 - set is hovered
87:39 - we use state
87:41 - from react
87:44 - false we can add some pointer events
87:47 - here on
87:49 - pointer
87:51 - move
87:55 - and we take the event
87:58 - stop propagation
88:02 - set
88:03 - is hovered true
88:07 - and then we just do the same for
88:13 - on pointer out
88:17 - and now we need to adjust
88:19 - the appearance based on the hover
88:23 - so let's add color here
88:26 - is hovered
88:30 - let's make it gray if they're hovered we
88:33 - make them gray otherwise we keep them
88:35 - white
88:42 - but one thing that would be nice is if
88:44 - the glass cube would actually be a bit
88:47 - transparent so we add
88:50 - transparent
88:51 - true to all the cubes
88:53 - and then we do opacity
88:57 - active texture
88:59 - equals
89:01 - glass then we do
89:03 - 0.5
89:06 - otherwise
89:08 - we do one and this should be
89:11 - just texture
89:15 - all right so there we have transparent
89:18 - glass and maybe it's a bit too
89:21 - transparent
89:22 - let's do 0.6
89:27 - really nice
89:30 - very cool
89:33 - all right so we're getting close to
89:35 - being able to build that house and of
89:38 - course transparent glass is a must for
89:41 - building houses
89:47 - so you can watch outside
89:54 - all right i will quickly finish this
89:56 - house
89:57 - just to check it off the list
90:10 - should probably have a door
90:15 - all right we're inside the house
90:25 - i think we can check it off the list
90:28 - all right we can say actually right now
90:31 - that we have fixed everything on our
90:34 - to-do list and even some more things
90:36 - that we had to add as we went on
90:39 - for those of you that got this far kudos
90:42 - to you it's quite a long project if you
90:45 - want to submit pull requests to this
90:47 - project feel free i will look at them
90:49 - and probably pull in
90:52 - many of them so thank you so much
90:54 - everyone that watched i hope you learned
90:56 - a thing or two about
90:57 - building 3d things on the web and i hope
91:01 - you got inspired to try out to build
91:03 - something on your own so please keep
91:06 - watching free code camp continue to
91:08 - learn and also you can check out
91:11 - my channel if you should want to bye now
91:14 - thanks a lot for watching

Cleaned transcript:

in this course daniel bark will teach you how to code a fully functional minecraft clone using react javascript and 3js daniel is a senior software engineer from sweden you will create a game that supports 5 minecraft block types it will include moving jumping switching and placing blocks saving and more you will learn about mini react concepts such as ustay use effect use ref and custom hooks for state management and you'll be able to apply the principles to create other 3d games in javascript alright so let's get on with the tutorial and to begin with let's have an overview of the steps we're going to take in this tutorial to build a minecraft clone so first we'll look through the code that we're starting out with and the packages that we're going to use then we'll add our first 3d element which is a skybox that will wrap the entire world we need some images that will be used as textures on the ground and on the cubes and next up we'll use a plane as the ground and our player is going to interact with that ground and so the player is going to get a first person view will mount a camera to a sphere and that will feel like a first person game then we need to have some gravity we need to make sure that the player cannot fall through the ground and when you jump you should fall back to the ground and so on we need some movement to go back and forward and to the sides and then we need some state management because we need to keep track of all the cubes in the world so you need to be able to add and remove cubes in a global state so we need to keep track of that and then we also need to keep track of what type of cube the player want to add to the world so we also need some type of ui that indicates what cube texture is active it would also be nice if we can save our world so we don't have to start from scratch every time we come to the app so we'll implement a button to store the world in the local storage and also to reset the world if we want to start over we'll have a reset button for that and in the end we should build ourselves something fun like a house or we'll see what we come up with all right so let's look through the code that we're starting with so we have a package.json so we have react3 fiber the the main package and then we're going to use some nice functions from canon and dry we have react we have three we have a way to generate ids and we have the state manager zoo stand now let's jump to the components folder is empty right now but we will populate it inside images we have small images like this we have dirt glass grass logs and wood and i already created a javascript file that just imports these images and then exports them in an object like this let's go to the index so here not much is going on quite standard we have an index.css file with not much in it i just added some helper classes and we'll probably add some more later on and inside the app here we have just a div that says outside canvas and then we have canvas from reactory fiber and we have nothing inside the canvas right now so we see a text here that is outside the canvas and the rest of the screen is covered by the canvas alright so we are done with looking through the boilerplate so onwards towards the sky so the sky we will import from let's see if we get some help here sky from react 3 dry and let's see if something happened yes we got a sky so for now we can remove this div that says outside canvas what i wanted to show with that is that you can add normal html as long as it's outside of the canvas because if i move this into the canvas we get some errors because react3 fiber doesn't know what to do with the div it has all kinds of other primitives it can render like meshes and geometries and so on but it cannot handle divs but we can place them outside and then we can mix the 3d stuff and the normal html stuff so i'll remove outside canvas for now so we get a full view of the 3d content here for on the sky we can set sun position and that takes an array of xyz so i'll do 120 or something it doesn't matter too much but now we see that the sky got a bit brighter and i cannot really look at the any other part of the sky because the camera is now static and so we can adjust the sun position later if we're not happy with it but at least now we have a sky in the day and not an evening sky like it was before so i think we'll leave the sky like this for now and jump onwards to the next step alright so let's prepare our images and turn them into 3js textures so first i'm going to change actually this images file so that we can destructure them when we import them directly so i will clean it up like this let's create a new file and call it textures so then we can import from images so what we need to do here is create textures so let's start with the dirt texture so we need to import from 3js the texture loader so we say new texture loader and we give it the dirt image so we just repeat this there we go and we create a separate texture also for the ground even though we're going to use the same image so we'll call that ground texture and uses the grass image so now we want to export these there we go so now we have a file that exports the textures so i think we can cross off textures and images so our next step in the list is to work with the ground so let's before we create the ground let's add a few things in here let's add an ambient light so that is a light that will light up every 3d surface and that one takes a prop intensity so let's do one 0.5 and before we include the ground we need to add a physics container because we're going to use a hook from canon to create our plane that will be the ground and that needs to be within a physics boundary so the physics from canon and inside here is where we can create the ground so let's create that component now ground okay so here to create our ground plane we're going to use a hook from canon called use plane so this plane will give us an array where the reference comes first and that is a reference that we will place on the mesh that we let canon control so use plane so it takes a callback function that returns an object so here we can set some properties of this plane like rotation and position and so on so we'll do rotation and here we have an array of three and position also an array of three so now we're going to return some elements here so we will take a mesh first we will reference this mesh so we'll set ref is ref and then we have the geometry so we'll have a plane buffer geometry and we'll attach this as a geometry and here we can set the size of the plane with the args prop so since it since it is a plane it has two dimensions so we'll set it 100 by 100 and we also need to add a material here so we'll do a mesh standard material and this should attach as a material and here is where we want to add a texture but first we can just set a color let's do hot pink all right so if we look at the browser now we have something hot pink that is covering the entire screen so we don't want to have color hot pink here we want to attach the ground texture so let's import the ground texture so we just say map is ground texture okay so we got an error because we forgot one step in the texture loader we need to call it and then call the load function okay so we instantiate a texture loader and on that we call the load function for each image that's important to remember so now we can continue debugging this okay so now we have a new texture here so we as we can see it doesn't really look like the the grass image which has these small pixels on it so what i suspect is happening now is that the image is being stretched out so we want this texture to be repeating we want this small image to repeat over and over so we can do ground texture dot wrap s and we'll do repeat wrapping and import that from three and the same for t and then we'll do repeat dot set and we'll set this to the same as our size hundred hundred there we go so now we have it repeating but as we can see the it looks very blurry and that has to do with how the texture is being stretched and how essentially how the rendering engine figures out how to display these colors so with this setting it's like smearing them and we can change that if we do ground texture dot mag filter nearest filter instead so let's see what happens now that looks much better now it looks pixelated as it should so our next step would be to flatten or lay down the ground because right now the ground is standing up so we can play with this rotation here so i will rotate the xaxis and we want to rotate it 90 degrees but in radians so 2 pi would be 360 degrees which means that 1 pi is 180 degrees and half of a pi is 90 degrees so i will do math dot pi divided by 2 to rotate it 90 degrees and it might be that we're seeing it from behind now so i will flip it 180 degrees so it folded over maybe so that we can no longer see it with the camera so let's do it a little bit less okay there we go so now we can see that it lays down but not completely 90 degrees but for now we can keep it like this for a while we can see that it's almost correct because once we can move the camera around it's going to be easier for us to to flip it back then because then we will add gravity and we will fall down onto the ground but let's keep it like this just that we at least at least can see that we have the ground there alright so we have the ground let's start to work on the player so our player needs to have a camera so we can the structure camera from a hook called use three so that hook is from reactory fiber so we also need some type of geometry to represent the player the geometry that can collide with other geometries and so on so for that we can use a sphere so this will be similar to what we did to the plane for the ground so we'll do use sphere and we call we call use sphere and it takes a function that returns back an object so here we can set mass we'll set that to one we'll set type to be dynamic and we'll return a mesh and attach the ref and then let's add our player all right so we we should have a player now so the next thing so we won't see that anything change yet so we need somewhere to store the position of our player so let's create a variable called position and we'll do a reference and it has x y z coordinates so we'll do zero zero zero to begin with now we will call the use frame hook so this hook will run on every frame so what we want to do now is attach the camera to this position that we're going to connect to our player so what we can do is that we can take the camera which is from use three and we take the position and we copy and we pass in a new vector 3 and this vector we give position dot current and we give it the x and then we do the same for y and set position.current.1 which is y and position dot current two so now we should have a camera that follows this reference to a position here okay we can set the console log here just to see that our frame is running okay so we see that we no longer see the ground and we have frame console login here so we can see that it runs on every frame so let's remove this so we did something to the camera at least that is good so if we uncomment this line we should see the ground again and we do so that's good so we were able to move the camera we copy it to this position every frame so our next step is to have this position follow the position of this sphere because this sphere will be affected by physics and gravity so we can do a use effect and this use effect will need to rerun every time the sphere changes position so we can take out element number two here from u sphere which is the api an api towards the sphere so we'll say that rerun this effect every time the sphere api position changes and what we want to do when the position changes we want api dot position dot subscribe and subscribe takes a call back where we get call it p and we'll say position dot current is equal to p so p is a triplet so it will look like this so now we have a sphere that is connected to this reference or let's say this reference follows the sphere and we can get the camera to follow this reference so our goal is to get this camera to follow the sphere okay so now i added back the camera so we can see that something happens we get ejected i don't know if we may be colliding with the ground and then to handle that collision we just get ejected if i change the set value here so if i do 10 and i reload i land on the ground but because remember what what technical depth we had from the ground we didn't flatten it to 90 degrees properly so now would be a good time to fix that so like i said to to rotate 90 degrees that is half of a pie so now we flatten the ground out so we fly up and then we land on the ground we have taken the camera we glue the camera to our position reference and then we subscribe to api position changes of the sphere so we have a rift that tracks the sphere and then we glue the camera to a reference hopefully that makes sense so we need to do similar things to the velocity so let's copy this position code here i will call it call this vel and here we track api dot velocity api dot velocity so here we get v and we'll set vel dot current to v so now we have a reference of the velocity that subscribes to the velocity of the sphere okay so let's fix this catapult effect thing so what i suspect happens is that when the sphere is inside of the ground plane they that state cannot exist so we just get flung out so that there's no collision anymore so we need to lift up the sphere a bit so let's try five so now we start from above the plane and then we fall down to it so let's see how close we can get so if we put one we seem to be standing on the ground as we start so that's great let's see if we can actually trigger some movement on the sphere so we have the api so we can do api dot velocity dot set so here we can give it the x y and z velocities so we can do 0 1 0 then we should be constantly lifted upwards so we'll do something similar to this when we implement jumping because then we want to set velocity upwards but just for a short while so it so you fall back down so it's a normal jump all right so i think before we can move with before we can move forward pun intended with the player we should make a hook for the keyboard inputs so that we can register different key presses that we're going to use to control this sphere that is the player so let's add this to our todo list keyboard inputs so the player is not yet done we'll move to the keyboard inputs first so the keyboard input is actually a hook so let's do a hooks folder and we'll call it use keyboard export const use keyboard so we'll need to have some state here to keep track of what keys are pressed so we'll do we call it movement set movement use state so let's set up this initial state right so we need to map out all the keys and call them things that we understand so one action is move forward move backward we also have move left and move right we have jump and then we have texture one two three four five i think that should be all the now that we have textures we should maybe call it actions so now we need to have a use effect and inside here we do document dot add event listener listen for key down then we need to create some functions to handle this key up and since we're adding event listeners we also need to return a function that removes them otherwise we will add endless event listeners handle key down we wrap this in the use callback so inside here we get the key down event so let's create some helper function to determine what key maps to what so we'll do function action by key so here we get a key key map key action map so here we say key here we need to type it as they as they are called in the key event so key w like this we'll call it move forward and we have space for jump and then we have digit one and now we can say what texture it corresponds to we'll say it's dirt and the last one is log so now we mapped out what keys belongs to what actions and then we just return key action map with key of course we need to check so that only we only react to the keys that we are listening for action by key e dot code so now we can do set movement and of course we need to preserve the previous state so we spread the previous date and then we set we can do action equals action by key e dot code now we can just say if action action is true and this is now called set action actions okay so it will be very similar for a handle key up just that we set this to false so here we need to handle key down and handle key up and then we just return the actions let's try this hook from the player component i'll do like this so we'll just see those that are true key and value and we return those that have true all right so now we should be able to see in the console log when we press these different keys that we are looking for okay so we have no actions when we start that's good so now i press w because i'm not getting anything so let's debug let's see if we are here yes we get the keyboard event action by key action by key is a function not a map so this should fix that and same thing here so i'm pressing w s a d jump spacebar and the digits one two three four five okay so we have everything working so now we can react to these actions and control the movement of the sphere by looking at what key process we're doing so we can cross off the keyboard inputs alright so let's control the player using the keyboard inputs and i think an easy one to start with is the jumping because this requires some vector math so it will be a little bit tricky but i think we'll manage it so first we can look at if actions dot jump that means that we are jumping we can reuse this code here we can for the x we just keep the value and for said we'll just keep the value and here this is a constant that will use for the jumping so let's store it jump jump force let's try 10. jump jump force okay let's try it out spacebar alright so we achieved the jump it felt a little bit too high and also we can jump indefinitely which is wrong so first let's fix the jump height let's try three yeah that's better i'll try four for now so we need to do another if check here if we can jump again and one easy way of eliminating all these extra jumps is that we make sure that our y velocity is zero make sure that we're not moving up and down because whenever we are moving up and down it means that we are falling through the sky or already jumped and we are on our way up so we need to make sure that the velocity in the y direction is really close to zero so let's do since we we care about positive and negative we can do absolute value and we have it on velocity dot current it's vel right current one should be smaller than zero dot let's do zero dot zero five maybe okay so let's try good we can still jump i'm pressing it continuously but we we're only allowed to jump once we've landed there's one bug that we should fix and that is that we can we can jump if we hit right in the moment when we're actually slowing down from going up to going down again so it's uh the the velocity there becomes almost zero at a certain frame so if i can time that frame you can see that i can jump two times in a row but we'll leave it like that for now so we can start to think about how we move in a direction and the tricky part about it is that later on we will be able to turn around so w will always take us in the camera direction so we need one vector to represent what direction we are facing another vector for the forwards and backwards speed and the other one for this side speed so let's create those vectors one direction vector vector three and call it front vector also a vector 3 and a side vector so the front vector it's this said axis here that will determine us going forwards and backwards so both the move forward and move backwards should affect this force here so one way of doing it is we check actions dot move backwards and we set it to one if we're moving backwards or zero and then we subtract the same thing but for moving forward so if we press them at the same time they cancel out we could actually destructure here move four backwards move forward move right move left jump then we can clean this up like this and like this all right so we have this one one or zero and this one one or zero and if they are both one they cancel out which is a good thing because if you go forward and then you start to hold backwards also then you should stop right that's what we see in games so then we've taken care of the front vector so let's do something similar for the side vector so we'll copy this so now we're not moving in the set direction anymore i think this should be the x direction and here it's moved left and here it's move right so we get the same behavior there if you're holding both at the same time you should go nowhere there we go so now we're going to do some calculations and we'll we will originate from the direction vector so the direction dot subtract vectors and those vectors are the front vector and the side vector and then we'll chain on some more operations we normalize and then we multiply scalar and here we need to determine how fast we want to go so let's also make a variable for that or as constant we'll try 4 for speed as well so we'll multiply the speed and then finally we apply euler and this is where we get the correct facing direction from the camera so we have a reference to the camera and its rotation so this is where we make sure that the front and side vectors are correct in relation to the camera so now we can take this direction vector and apply it to the sphere so api dot velocity dot set and then we do the direction dot x direction dot y and direction. but that's not completely true because the y axis is not controlled by these front and side vectors this is just for moving backwards and forwards and to the sides so the y should actually stay the same so the vel dot current one so that should be enough in the best of worlds we would be able to move at this point see if we need to refresh all right i think we're missing the new keyword here for the vectors there we go all right so we have a typo here okay so let's try i'm pressing forward all right so forward is working backward is working now we'll try backwards and forwards at the same time and it stops that's great let's try left and right at the same time and i let go of left alright so that seems to be working so we cannot yet test that it will be still correct when we turn the camera that we will do once we once we build out the the pointer lock controls where we can control the camera with the mouse alright so i think we are done with the player for now let's move forwards with the first person view so we'll create a component fpv this one is actually quite simple because we get a lot of help from react 3 fiber here ok so we need of course to connect this to the camera so we need use three where we can get the camera okay so we return pointer lock controls args is camera destruction gl here passing that as gl dom element fpv from fpv and just render it all right so when i click here now it should lock the camera to how i move the mouse so now i can look around so now we can see that if i'm facing left i can move straight ahead and if i turn a bit i can still move straight ahead so our player movement seemed to work fine and the pointer lock controls seem to work as well there's one thing we should do with the first person view is that we should add a small cursor to the middle of the screen so outside of the canvas let's add a div class name cursor and let's put just a plus there and let's position it absolute and we're going to center this on the screen so let's make a class called centered so this is position absolute so we do top fifty percent left fifty percent we need to add a transform translate minus fifty and minus 50 so that is just because if we if we center it 50 50 without doing this transform translate then it will not actually be in the middle because i think i can show you this background hot pink if we make this bigger we see that it is in fact centered but if we don't have this translate this is what will happen the top left corner of the square will be in the center so what we're adjusting for with 50 is 50 of the width and height of the square so then it would move to the middle but this one doesn't need to be big at all so we'll remove these two that looks good and then remove the background so move the the color styling to cursor there we go now we have a marker to indicate the center of where we are watching great i think we are done with the player for now so we will cross out first person view we're also done with gravity and we are done with the movement our next item on the agenda is to add a state manager we can add a hook called use store that keeps track of the game state let's create our hook use store so we'll need create from sue stand use store we can wrap this in create and we get a setter method here as an input parameter so we will return an object so we call create we pass it a function that returns an object so in this object we can declare our state so we need to keep track of a texture and we can default the texture to dirt we need to keep track of the cubes that the player is going to be able to place so we can just default that to an array and now we're going to declare our methods that you can use to interact with the state so we'll of course have add cube remove cube you need to be able to set the texture and for later we want to be able to save the world reset world these are all the operations that we need to support in our store so when we add a cube all we need to know is where to place it because the texture we already know since we are in the store so when when someone calls add cube we need to call set and in set we pass it a callback function and we get back the previous state so here we can return an object so here we just want to affect the cubes which is an array so we spread in the previous cubes and then at the end we add a new cube and every cube needs to have a key and then we can use nano id for that we have a position that we get from xyz that's being passed in and then we have the texture which we can get from priv so that should be all it takes for us to add a cube but before we do that we need a way to render cubes so i suggest that we leave the store like this for now with just a method of adding cubes and then we create the component to render a cube and then we can start to render them out we can actually initialize the state with one cube just for debugging let's do one one one so now we always have one cube initially that we can quickly see if when we start to rendering the cubes if they come out so i suggest i suggest that we leave the store like this before we finish the rest of the store functions and then start to working on rendering our first cube so let's add a new component before we create the cube we should have a component that is taking care of rendering all the cubes essentially consuming the store and mapping out the cubes so we'll make a component called cubes so we need definitely to have used the use store from hooks so our use door hook we can we get the state back and then we can return an array where we can place different things from the state in whatever order we want so we want state dot cubes so then the first element here will be the cubes so if we do console log cubes we can return nothing here let's add cubes cubes so since the player needs to be able to stand on the cubes the cubes need to be within the physics slide it like that okay so we consoled out the cubes and this is our debugging cube that we added a dirt cube on position one one one so now we can start working on mapping out those cubes so we return here we're going to use the cube component so let's create that one first since we're doing a mapping we need to use the key which is something that we have on the cube already we have key we have x y zed texture so here we can use the key this is actually position so we receive position and texture so to create the cube we're going to use the the canon use box hook so we'll set type is static and we have the position from the incoming prop so here we return a mesh and to the mesh we connect the ref here we need a box buffer geometry and we also need a mesh standard material attach as geometry color is hot pink do we have a cube anywhere okay so i see we called it position in the store and here we're destruction position so we need to call it puss here oh okay so the reason i couldn't find the cube was because i was standing on it i feel very stupid now that's good so let's play around with these values see if we can get get it up in the air all right so there we have our first cube right so we have the cube standing on the ground so now let's fix the texture of the cube so let's pass in the texture in the store we just call it dirt and in textures we call it dirt texture so let's do texture plus texture so we import all the textures as textures and then we map it by the texture in the store plus texture and then we get our active texture then we can do map active texture and remove the color there we go we get the dirt texture on the cube let's move it a bit closer to us so as we can see it doesn't look so good so we need to do the same treatment we did to the grass to every cube texture so we'll test it with dirt dirt texture mag filter nearest filter let's see if that helped yeah now it looks good and pixelated and not smooshed let's do it to ground texture in here as well since we are already here and then we don't have to do it in here let's move these out as well there we go so now we fixed it for all the textures inside of the texture file instead to keep our components more clean i was thinking to maybe keep this in ground because it correlates to the size of it so we'll keep it here so now we should be able to add a second cube with another texture i will pick another position texture would all right so now we can render cubes with different textures and this one looks nice as well since it's been fixed alright so now we have a way of rendering cubes once they are added to the store all right so we have the basics of the state management and we have the cube's basics as well something that is missing in this list is adding cubes so one way of adding a cube is to click the ground so let's open the ground so we need to get the add cube method from use store add cube and return an array with state dot add cube all right so we had have the add cube method uh but we need to figure out the x y and z coordinates to uh to pass to this function so let's add an on click to this mesh let's do e dot stop propagation so that the click cannot be passed through the ground so on the event we have something called e dot point so we want to get x y and z we can do object dot values from e dot point so let's stop here to check out what happens when we click the ground so we have e let's look at point so we have a vector 3. so we just want to get the values of this vector we don't want to pass the whole object so if we do object.values we just get these three values and we destructure them out here so if we hover the xy and said we see that we do in fact get the values here as you saw there are a lot of decimals here we want the cubes to end up on fixed location according to this grid that we can see here in full numbers so we need to round this so we need to do a mapping of these values and return math math.c of the value and then we should be able to call addcube with x y and zed right so let's try this out let's reload and we click the ground and we do get a cube so as we can see the seal function made it round up so let's try with floor instead so as we can see i think we should try moving the ground down by half a unit and see if that will make the cubes lay flat on the ground so let's try that so now that we fix the ground we can go back to seal here math.seal and when i click the ground we actually get cubes added pretty cool so now let's lower these default cubes or we can actually remove these default cubes now that we have a way of adding cues for real okay so we handle the case where you click the ground and you want to add a cube but what about when you click the surface of a cube to add a cube next to it okay so let's handle the clicking of cubes so we can copy this state call here because we want to do the same inside of cube but we also want to have remove cube later on so let's add that straight away so my plan is that if you hold in the modifier key and click then you can remove cubes as well so let's add an on click we stop propagation so here we need to handle a few things a cube has six sides and the side that you actually click needs to get another cube next to it so we'll create a variable clicked face and a face of a cube actually has two triangular shapes that covers the face so it's not a full square it's two triangles that together cover the square face so instead of six faces it has 12 faces but that is pretty easy to fix so we can just take take e dot phase index and divide this by two and then we will be in the range between 0 and 5 instead of 0 and 11. and we will of course need to math dot floor it because there's no 0.5 phase index so now clicked face should be between 0 and 5. so let's console log face click face so let's add a cube here phase four phase one phase five phase zero top is phase two and the bottom should be phase three then so now we just need to write if statements to cover all these clicked faces so if it's zero and cube so we have a ref to the box that has a position so we can do x y set from ref current position so we can pass in x y set and then we need to on one of them maybe subtract one to the x and for another face we need to do x plus one but it's a little bit of guesswork to figure out what phase is what direction if you understand what i mean one two three four five six so something like that this will most likely be wrong all right so we add a cube we click one face so here we see that it was the opposite all right so now we have logging as well so if i click this face we see that it was four and the cube was added on the other side so clicked phase four just needs to flip and then let's flip this one if i click this face that was phase one and that was also flipped so this should probably minus one and maybe plus one here let's try the top so phase two nothing happened so i'm suspecting that there's a cube underneath so this should probably be plus one and this should be minus one so let's try again to click the top yeah now that was correct so i think we might have it nice now we can click a cube to add another cube next to it so now now it starts to become fun so we can return if we are done with the operation so now we can handle the removal of cubes if e dot alt key remove cube x y set and return and of course we haven't implemented the remove cube function yet so what we can do just to try it quickly is to just console.log here x y zed x y said remove all right so i'm holding down the alt key and i'm clicking it and we get a call to remove cube with x y said so that's great so now we can implement the remove cube function so we can borrow some code from ad cube we'll still call set but instead of adding to this array we can take predot cubes dot filter cube or we keep all the cubes where x y and z are not equal to the xyz being passed in so with the structure x y and z from the cube then we return x not equal to x y not equal to y and said not equal to set so let's see if we can filter out the cube that we're clicking on let's add a few so here we need to say cube cube dot pulse all right let's try again so add a few cubes and then alt key and they were all removed i think the issue is that this should be or because if any coordinate is not correct it's not the the right box to filter out so let's try again there we go one cube being removed at a time great now we can remove cubes great progress alright so we are done with adding cubes and removing cubes so let's continue with the cube type selector so we should create some ui that indicates what selections there are and what is currently active so let's create a component texture selector and this one will not be a three component this will just be html and this one should just be visible when we're actually changing the texture so we need some state here let's determine if it's visible right now or not we'll default it to false we need to get the texture from from the store active texture state and we get an array back where we take state dot we just call it texture texture so let's call create a use effect that runs whenever the active texture changes active texture so if the active texture changes we want to have this texture selector visible for like two seconds and then we want it to disappear so we need a visibility timeout that is set timeout for two seconds so after two seconds we want to set visible false and immediately we want to set visible true and then we need to clear the timeout clear timeout visibility like this so we only want to show something is if visible is true so let's do class name absolute and centered so now we we also need to handle so that the texture is actually changed when we press the digits actions from use keyboard so in the store we have a set texture method so let's finish that we take a texture we call set we don't care about the previous we just want to set texture based on the incoming texture so let's look at use keyboard we have texture one to five this is what we want to dig out here so let's do a use effect again that will run for texture 1 texture 2. if texture won so now we need the set texture from the store set texture dirt okay we'll call this dirt grass glass wood and log so the actions will now contain props that are the actual names of the textures so we'll call it pressed texture so if any of these textures are true then that texture will be the pressed texture and then we can do if pressed texture set texture to pressed texture let's see pressed pressed texture so let's see if it works if i press one all right let's debug so if i press one there to be true so that's great so it works correctly in use keyboard and in the texture selector let's console log dirt let's see if we can get there to be one so one thing what we must do is add the texture selector to our app before we started looking for console logs in it so let's add it here texture all right so we get dirt falls we saw it there and as i press one we got dirt true and texture selector appears for two seconds and then gets removed so it looks very promising after texture all right so here we have our textures as booleans so let's create a mapping that will set the prop which is the name of the texture that will map from the name to the booleans so then we can do object dot entries find key value so we want to find a texture where the value is true if we have such a pressed texture we'll take the value from that all right so we get five booleans here and we put them in a mapping so we'll get dirt falls grass falls maybe glass true and if glass is true we will find the true texture store that in press texture so if we found a pressed texture we get the key of that by taking the first element in that tuple so let's see if it actually worked gr pressed grass pressed dirt pressed wood and press log so now i press glass so this is the glass cube pressing dirt and i get a dirt cube so cool we have a way of selecting different textures just using the keyboard i know what happened with this cube but let's continue building the ui to show the actual selections so we already have a list of images with these so let's import those images okay so let's create a mapping here images so we keep the name that they are called in the store to the actual image so we need to loop this in a map here images i will do object dot entries images so here we get key and source image so we can return an image image tag source is source key is okay and now we need to check which one is the active one and that we can do by adding a class name so here we can do k equals active texture if that is true if that is true we add active otherwise nothing and let's have an alt prop put the the name of the texture all right so let's see if anything happened so when i change the texture now here we have an error this should be an array so now let's see oh we got it so when i change texture the texture selector appears so we should just make it bigger let's add a class texture select so we can do transform scale 10 it should be select door there we go that's bigger let's do maybe five and then let's handle the active also so if we have an image.active there let's do a border of two pixels solid red so let's see if we can see which one is active yes we can okay so we between the four and the five we have the wrong digits so that is probably because i typed them in the wrong order here all right now they work correctly all right let's see all our cues we have wood or log we have wood we have glass we have grass and we have dirt really nice let's remove this console log all right so our cube type selector is done the next thing on the agenda would be to save the world in local storage so that is something that we can do inside of our store so let's create some helper functions to talk to the local storage so what we want to store in the local storage is an array so we need to do json parse and json stringify to talk to the local storage so let's call create a helper function get local storage so we take in a key and we return json.parse window local storage get item of key so all we're doing is json parsing what we get from local storage and let's do a similar function with set local storage we take in a key and of course the value that we want to set and then we do json stringify set item and then we set we pass the key actually this json string if i should be just wrapping the value value right so now we have our helper functions so when we first create this date we want to do get local storage and we can just make up a key here we'll call it cubes so we'll either get something or it will be empty so we'll fall back to the empty array so now we can implement these two functions let's start with just resetting the world that would just be set and then we just set the cubes to be empty ray like that that should reset the world and then we have say world so we call set just to get the current state and inside here we just call set local storage the key was cubes and we store red dot cubes so we don't need a load world function because that happens when we just reload the page but we we also need to create some buttons on the ui for this let's create a component called menu so we want to access save world and reset world from use store so state reset world all right so let's create some ui last name of menu and absolute we need save and we need reset on click save world reset world all right let's import menu so let's see where we have our menu we have it but it's down there so we need to style it so it becomes in the top so we'll do top 10 pixels left 10 pixels there we have them all right so let's try them out we'll place a few cubes of different types all right we have a nice line here let's save it so now it should be in local storage we can verify that application local storage we have cubes and there we have the cubes so now when i reload the page we have any cubes oh here they are really cool so now we can persist it of course we can also reset but they are still in local storage so if i just reload the cubes will be there alright we are done with saving the world in local storage but we have one more thing that would be nice to have hover state on cubes i think it would be nice if when the cursor hovers the cube that they become a bit darker so that you indicate what cube you're actually hovering on right let's keep track if a cube is hovered set is hovered we use state from react false we can add some pointer events here on pointer move and we take the event stop propagation set is hovered true and then we just do the same for on pointer out and now we need to adjust the appearance based on the hover so let's add color here is hovered let's make it gray if they're hovered we make them gray otherwise we keep them white but one thing that would be nice is if the glass cube would actually be a bit transparent so we add transparent true to all the cubes and then we do opacity active texture equals glass then we do 0.5 otherwise we do one and this should be just texture all right so there we have transparent glass and maybe it's a bit too transparent let's do 0.6 really nice very cool all right so we're getting close to being able to build that house and of course transparent glass is a must for building houses so you can watch outside all right i will quickly finish this house just to check it off the list should probably have a door all right we're inside the house i think we can check it off the list all right we can say actually right now that we have fixed everything on our todo list and even some more things that we had to add as we went on for those of you that got this far kudos to you it's quite a long project if you want to submit pull requests to this project feel free i will look at them and probably pull in many of them so thank you so much everyone that watched i hope you learned a thing or two about building 3d things on the web and i hope you got inspired to try out to build something on your own so please keep watching free code camp continue to learn and also you can check out my channel if you should want to bye now thanks a lot for watching
