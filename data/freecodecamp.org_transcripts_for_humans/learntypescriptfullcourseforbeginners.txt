With timestamps:

00:00 - learn the basic building blocks of
00:01 - typescript while discovering firsthand
00:04 - how typescript can make your life easier
00:06 - and your code less air prone popular
00:09 - instructor Bob zeroll teaches this
00:10 - course typescript is a superet of
00:13 - JavaScript meaning all valid JavaScript
00:15 - code is also valid in typescript however
00:18 - typescript enhances your coding
00:20 - experience by enabling you to write code
00:22 - with greater confidence in the stability
00:25 - and longevity of your projects
00:30 - hi there and welcome to this
00:32 - introductory course on typescript my
00:34 - name is Bob Zol and I'll be your teacher
00:36 - through this course guiding you through
00:37 - learning one of the most important
00:39 - things you can learn as a front-end web
00:41 - developer now there might be a lot of
00:43 - reasons why you're here in this course
00:45 - trying to learn typescript but I'm going
00:46 - to give you three of the most important
00:48 - reasons you can learn typescript the
00:50 - headliner reason for learning typescript
00:52 - that I would offer is the confidence
00:54 - that it gives you as a developer
00:56 - typescripts ability to check your code
00:58 - during compile time or using modern
01:00 - idees essentially in real time as you're
01:03 - typing your code dramatically reduces
01:05 - the number of app crashing runtime
01:07 - errors that would normally only be
01:09 - caught after your app is running and
01:11 - possibly even deployed live to
01:13 - production because typescript can catch
01:15 - a lot of those errors before anything
01:17 - gets pushed up live your confidence as a
01:19 - developer in the stability of your code
01:22 - will be through the roof another reason
01:24 - I would offer it's important to learn
01:25 - typescript is the added productivity
01:27 - that it brings to you as the developer
01:29 - sure typescript does take a bit more
01:32 - time to write than just slinging regular
01:34 - JavaScript code around but there are a
01:36 - number of really neat features that make
01:39 - your life as a developer a lot easier by
01:42 - simply using typescript in your project
01:44 - in vs code for example yes in JavaScript
01:47 - you'll get some autocomplete but you'll
01:49 - see as you're using typescript
01:50 - autocomplete turns up to a completely
01:52 - different level in modern typescript
01:54 - enabled idees there's also refactoring
01:57 - capabilities immediate error checking as
01:59 - we talked about in point number one and
02:01 - a bunch of other things that you'll find
02:03 - as you're using typescript that just
02:05 - greatly improve your developer
02:07 - experience and thus your productivity
02:09 - and a third reason I would offer that
02:11 - it's really helpful to learn typescript
02:13 - is that it will improve your
02:14 - employability assuming you are a junior
02:17 - or maybe even a mid-level developer that
02:19 - is on the job market or will be on the
02:21 - job market in the future learning
02:23 - typescript is oftentimes considered
02:25 - table Stakes by many companies even if
02:27 - it's not explicitly listed in their job
02:29 - description
02:30 - as such knowing even a little bit of
02:32 - typescript can really set you apart from
02:33 - other Junior developer candidates so
02:36 - what exactly will we be covering in this
02:37 - course well this is an introductory
02:39 - course and by the end of the course you
02:41 - will have an understanding of the
02:42 - fundamentals of typescript and we'll be
02:44 - talking quite a bit about why typescript
02:46 - is so useful as far as the topics goes
02:49 - we're going to cover the basic literal
02:51 - and custom types we'll talk briefly
02:53 - about optional properties unions type
02:56 - narrowing some built-in utility types
02:58 - that exist already in typescript and
03:01 - generics which essentially allow you to
03:03 - create your own utility types or to make
03:05 - your functions and other types more
03:07 - flexible by understanding these
03:09 - fundamentals of typescript I truly
03:10 - believe that typescript can be a
03:12 - catalyst that helps train your brain to
03:14 - think like a senior developer as such
03:16 - there's one thing in particular that I
03:18 - remember when I first started learning
03:20 - typescript and that is that it can be
03:22 - challenging to learn at first you have
03:24 - nothing to worry about because you're
03:26 - here on scrimba you're going to be
03:27 - getting your hands on the keyboard quite
03:29 - a bit throughout this course practicing
03:31 - really understanding what you're
03:33 - learning and I've tried my best to
03:34 - really break down the topics into
03:36 - bite-sized chunks that are really easy
03:38 - to comprehend still one of the
03:40 - challenges I have heard from a number of
03:42 - people who are learning typescript for
03:43 - the first time is that it feels like
03:45 - we're just adding a bunch of extra work
03:47 - without any additional benefit
03:50 - especially if you're trying to convert
03:52 - an existing codebase into typescript it
03:54 - can be quite overwhelming to see all of
03:56 - the errors pop up when you change your
03:58 - file to a typescript file however as my
04:01 - friend keny dods puts it typescript is
04:03 - not going to be making your life
04:04 - terrible it's simply going to be showing
04:06 - you how terrible your life already is
04:08 - it's really important to remember that
04:10 - the errors that you see show up in
04:11 - typescript they're not there to bug you
04:13 - or be annoying they're really there to
04:15 - protect you against some of the Loosey
04:17 - Goosey typing that happens in vanilla
04:19 - JavaScript an analogy that I thought of
04:22 - that kind of helps me understand this
04:23 - better is the concept of building a
04:25 - blueprint or a sketch of a project
04:27 - before you actually start building it on
04:29 - a large scale if you can imagine someone
04:31 - trying to just walk up to a pile of
04:33 - lumber and start building a house
04:35 - without a plan you can tell that that's
04:37 - probably not going to end very well yes
04:39 - drawing out a blueprint planning ahead
04:41 - it takes a lot of additional work Beyond
04:44 - just building your house but the
04:46 - benefits are obvious and I believe after
04:48 - you've been exposed to typescript and
04:50 - you've built some projects using
04:51 - typescript you'll probably see it in a
04:53 - very similar way maybe to get a little
04:55 - bit more specific let me talk about what
04:57 - this item is right here this is called a
04:59 - stud guard and it's an example of
05:02 - planning ahead of time to avoid
05:04 - catastrophic issues in the future now
05:06 - the idea of a stud guard is often times
05:08 - homeowners will try to find a stud and
05:10 - nail or screw something into that stud
05:13 - maybe to install some kind of Hardware
05:15 - or hang something heavy or whatever it
05:16 - might be however in certain parts of our
05:19 - house it's really important that we
05:20 - don't nail through the stud if I had a
05:23 - screw that was too long and right here
05:24 - tried to screw into this section I would
05:27 - hit this waterline or even worse it
05:29 - could be electrical line or even worse
05:31 - could be a gas line and so these stud
05:33 - guards which are made of 16 gauge steel
05:36 - make it so that it would be really
05:38 - difficult to get through this section of
05:40 - the stud and accidentally cause
05:41 - something terrible to happen a little
05:43 - bit of extra work planning ahead just
05:45 - like using typescript can save you big
05:48 - headaches in the future Now typescript
05:50 - does not solve every programming problem
05:53 - like this meme might suggest the main
05:55 - focus of typescript is on fixing
05:57 - possible runtime errors more spefic
05:59 - specifically anything that would be a
06:01 - type error and as I'm sure you've
06:03 - experienced not every error in your code
06:05 - is a runtime type error typescript can
06:07 - do quite a bit to protect you against
06:09 - the most common errors that people write
06:11 - into their JavaScript code but it won't
06:13 - protect you against certain things like
06:15 - logical errors that said we're about to
06:17 - see firsthand just how many errors we
06:20 - can fix by simply changing a file from a
06:23 - JavaScript extension to a typescript
06:25 - extension I'm really excited to jump
06:27 - into this code my name is Bob zero as I
06:29 - mentioned I'm most active these days on
06:31 - X you can click my username here to go
06:33 - directly to my profile I'd appreciate a
06:35 - follow so without further Ado let's jump
06:37 - right into learning
06:42 - typescript when I first started learning
06:44 - about typescript a number of years ago I
06:47 - really struggled with understanding what
06:48 - benefit I was actually going to get by
06:50 - using typescript instead of vanilla
06:52 - JavaScript writing your code in
06:54 - typescript does require a relatively
06:57 - significant overhead in terms of extra
06:59 - lines of code that you have to write and
07:01 - considerations that you have to take and
07:03 - so for this course I really wanted to
07:04 - demonstrate the improvements that your
07:06 - code will receive by using typescript
07:09 - instead of JavaScript just by itself so
07:11 - the approach I'm going to take might be
07:13 - a little bit different but stick with me
07:14 - it's going to be fun and I really think
07:16 - it's going to highlight the benefits
07:17 - that you'll get out of using typescript
07:19 - the way I'm going to approach this is by
07:21 - building a really simple restaurant app
07:23 - it's just going to be console based so
07:26 - we won't be worrying about HTML or
07:27 - anything like that and we're going to
07:28 - start by writing wrting it in regular
07:30 - JavaScript and I'm going to give you a
07:32 - couple really simple challenges but
07:34 - again stick with me this is going to be
07:35 - really fun okay so we're going to create
07:37 - a pizza restaurant and the first thing I
07:39 - want to do is create a menu it'll be an
07:42 - array of items each of those items will
07:45 - have a name and let's go ahead and add a
07:48 - couple pizzas here we'll say a margarita
07:50 - pizza
07:52 - margarita and we'll give it a price and
07:55 - let's go ahead and add four different
07:56 - pizzas and for the sake of time I'll
07:58 - speed through adding different pizzas to
08:00 - our menu all right in our pizza
08:02 - restaurant we also are going to want to
08:04 - keep track of the cash in the register
08:08 - let's say we start each day with $100
08:11 - and we'll also want to keep track of all
08:12 - of our pizzas in the queue as people are
08:15 - placing orders for pizzas this way the
08:17 - workers in the kitchen can know what
08:19 - needs to happen next so let's say we
08:21 - have an order que and we'll just
08:23 - initialize that as an empty array okay
08:26 - let's do a quick series of challenges
08:28 - this is mostly just going to be a way to
08:30 - get your brain and your fingers working
08:32 - right away so let me type out your first
08:35 - challenge okay this is about as simple
08:37 - as it'll get your challenge is to add a
08:39 - little utility helper function for us
08:42 - that's called add new pizza it should
08:44 - take a pizza object that's just like the
08:46 - shape of this object up here in our menu
08:49 - and it's going to just add that object
08:51 - to the menu pause now and work on this
08:53 - challenge
09:00 - okay let's add a function called add new
09:03 - pizza it's going to take a pizza object
09:06 - and simply enough it's going to do menu.
09:08 - push the pizza object Perfect all right
09:12 - we're really on a roll here let's get
09:14 - rid of this challenge text and already
09:16 - it's time for another challenge okay
09:18 - this one's a little more involved but
09:20 - still very doable your task is to write
09:22 - another utility function we'll call it
09:24 - place order that takes a pizza name so
09:27 - pepperoni for example as a string and
09:30 - first finds that pizza object in the
09:32 - menu so this whole object then it adds
09:34 - the new price that you just generated as
09:37 - a business to your cash in the register
09:39 - then it should create a new order object
09:41 - which is going to be just like this one
09:43 - that you see here it'll have a pizza
09:45 - property whose value is the object that
09:47 - you got from step one and then a status
09:49 - which we will set to the string ordered
09:52 - and then it will push this order object
09:54 - to the order Q array and then just for
09:56 - good measure we'll go ahead and return
09:58 - that New Order object object just in
10:00 - case we need it in the future okay pause
10:02 - now and work on this
10:08 - challenge all right let's do it we'll
10:10 - have a function that's called place
10:12 - order it's going to take a pizza name as
10:15 - a string there's a few different ways
10:17 - that you could do this but I'm going to
10:19 - grab the selected pizza and that's going
10:22 - to be the returned result from calling
10:24 - menu doind doind is an array method menu
10:29 - is an array of course and find is a
10:31 - method on all arrays where you provide a
10:33 - callback function find will iterate over
10:36 - all of the items in your array in this
10:39 - case we'll call it a pizza object and
10:41 - from this callback function that I get
10:44 - to write if I return true at some point
10:46 - then find will return the object that it
10:48 - found and that's what I'm saving as
10:51 - selected pizza so in this case I'm
10:52 - looking for the pizza in my array with
10:55 - the pizza name that was passed in here
10:57 - so with pizza object I'll say if Pizza
11:00 - object. name is equal to Pizza name the
11:04 - parameter passed into this function then
11:06 - it will return true and I have correctly
11:08 - found my pizza okay then we'll go ahead
11:10 - and increment our cache and register so
11:12 - we'll say that plus equals the selected
11:16 - pizza. price okay and that does it for
11:19 - steps one and two then we're going to
11:21 - create a new order and this will be an
11:25 - object that has a pizza property that's
11:27 - going to be our selected Pizza object
11:30 - and a status which we will default to
11:32 - ordered then we will push into our order
11:35 - Q so we'll say order q. push our new
11:38 - order and return the uh let's new order
11:42 - here okay one more quick challenge and
11:44 - then I promise we're going to get to the
11:45 - point okay in this challenge we have one
11:48 - more utility function to write we'll
11:50 - call it complete order it's going to
11:52 - take an order ID which will be a string
11:54 - as a parameter it will look in our order
11:57 - Q array for the order with that ID and
12:00 - then simply Mark its status as completed
12:03 - instead of ordered and then for good
12:05 - measure just like we did with place
12:06 - order we'll return the found order from
12:09 - the order queue as a note you'll need to
12:11 - make sure that you're adding an ID to
12:13 - the orders whenever you create new
12:14 - orders right here we're not including
12:16 - IDs so that's an improvement or a
12:18 - modification that you'll have to also
12:20 - make to the place order function and
12:22 - since we're not using a real database
12:24 - here you'll just create a global
12:25 - variable called Next order ID that you
12:28 - can start at one let's say and increment
12:30 - every time a new order is placed all
12:33 - right pause now and work on this
12:40 - challenge right let's create a function
12:42 - called complete order this is going to
12:45 - take an order ID and then before we get
12:48 - too far down that rabbit hole we'll go
12:50 - ahead and create a new variable we'll
12:52 - call it next uh order ID and I'll set it
12:55 - equal to one to start here when I'm
12:58 - creating my new order I'll go ahead and
13:00 - add an ID property and I'm going to use
13:02 - this trick where I can say next order ID
13:05 - Plus+ this will return the original next
13:08 - order ID before it gets incremented
13:10 - that's the value that will be set to the
13:12 - ID here and then once it's done doing
13:14 - that it will increment it so that in the
13:16 - future when I do this again it will have
13:18 - already changed from 1 to two and it
13:20 - will then increment it from 2 to 3 for
13:22 - the next time that it gets used by the
13:23 - way for anybody that's shouting at your
13:25 - screen and was probably shouting at your
13:27 - screen when I was doing this line L of
13:29 - code as well I know that there's bugs in
13:31 - here we're going to talk more about that
13:33 - very soon so don't worry about me I know
13:34 - that there's problems to fix down in our
13:36 - complete order function we can do the
13:38 - find method that we used before so let's
13:40 - go ahead and say this is our order we're
13:43 - going to use order q. find we'll say for
13:48 - each order that we're looking at we're
13:49 - looking that the ID is equal to the
13:52 - order ID that was passed into this
13:54 - function we will then change the ORD
13:57 - status to completed and return the order
14:01 - now I do want you to use your
14:02 - imagination a little bit here of course
14:04 - we're talking about creating a
14:06 - console-based pizza restaurant which is
14:08 - of course delicious but also a bit
14:10 - contrived as it stands but imagine that
14:12 - you've spent the last 30 or 60 Minutes
14:14 - or maybe even a full day or two working
14:16 - on some new feature for the app that
14:18 - you're currently building and you now
14:20 - feel like you're ready to start testing
14:22 - things out so let's go ahead and let me
14:24 - clear up this challenge text and we'll
14:27 - just test a few things out we'll add a
14:28 - couple new pizzas and let's add one of
14:31 - my personal favorites this is going to
14:33 - be a chicken bacon ranch and we'll say
14:36 - that the cost is $112 we'll add another
14:40 - pizza and let's call it a maybe a
14:42 - barbecue chicken that'll also be 12 and
14:45 - then maybe let's add something a little
14:47 - spicy in here we'll call it a spicy
14:49 - sausage pizza and maybe this one's $11
14:53 - okay and then we will place an order and
14:55 - this will be for a chicken bacon ranch
14:58 - and we know I Hadad of time that our
14:59 - first order ID is going to be starting
15:01 - with a one so we'll go ahead and test
15:03 - our complete order and we'll test the
15:06 - order with the ID of one and then in
15:09 - true fashion let's go ahead and console
15:11 - log everything that we have so we'll
15:12 - console log our menu just to see if our
15:15 - add new pizza is working we'll console
15:17 - log our cache in the cach in
15:22 - register and let's check out our order Q
15:26 - all right now if you've actually been
15:27 - following along You' know that this code
15:29 - is pretty full of some minor bugs when
15:32 - you wrote the challenges you may or may
15:34 - not have introduced similar bugs but at
15:36 - a glance if you were to run through this
15:38 - program just reading through the code I
15:40 - don't think it's that much of a stretch
15:42 - to think well this looks pretty good
15:43 - yeah let's push this up to production
15:45 - we'll run a couple tests and see if it
15:46 - works and then push everything up if you
15:48 - took the chance to pause and run this
15:50 - code you'll know that we're going to be
15:52 - running into all kinds of little
15:53 - problems first of all we have this type
15:56 - error assignment to a constant variable
15:58 - well a type error this is actually
15:59 - something that would crash our program
16:01 - if somehow this made it past testing or
16:03 - didn't involve any kind of manual
16:05 - testing it would have gotten pushed to
16:06 - production and our app would have
16:08 - crashed there's also a bug in the way
16:10 - that I'm testing my complete order of
16:11 - course I used a string this is again a
16:14 - bit on the nose because we know that
16:16 - this should be a number but this would
16:18 - have probably crashed our program as
16:19 - well now before taking a bunch of time
16:21 - and fixing these errors this is the
16:23 - perfect opportunity for us to move this
16:25 - project over to typescript and first of
16:27 - all see what errors typescript script is
16:29 - able to pick up without us making any
16:31 - other changes to the code and then to
16:32 - dive deeper into typescript and see how
16:34 - we can augment our code so we can teach
16:36 - typescript how things are supposed to
16:38 - look so that it can catch other bugs
16:40 - that it otherwise wouldn't be able to so
16:43 - before this bug Laden code gives me any
16:45 - more anxiety let's move over to
16:47 - typescript and see how we can fix
16:52 - everything okay let's shift things over
16:55 - and start using typescript for this
16:56 - project and see what typescript is is
16:58 - going to be able to offer us immediately
17:01 - out of the box in scrimba the way
17:03 - typescript is running under the hood is
17:05 - a little bit different than if you were
17:06 - following Along on your local machine
17:08 - normally I would be able to just change
17:10 - my Javascript file to a TS file
17:13 - extension and set typescript up as a
17:15 - dependency of my app but with typescript
17:18 - running in the background on scrimba I
17:19 - need to make sure that I actually create
17:21 - a brand new file called
17:23 - index.ts we'll talk a little bit more
17:25 - about setting up typescript in a local
17:26 - environment so this isn't a big deal
17:28 - that we have to worry too much about now
17:30 - but another scrimba specific thing I
17:32 - need to change this tots and we'll go
17:34 - ahead and copy all of our code over from
17:37 - JS to TS and look at that we get a bunch
17:41 - of red squigglies of course JavaScript
17:43 - was perfectly happy to let us write the
17:45 - code that we had before but out of the
17:47 - box typescript is able to warn us ahead
17:50 - of time of any potential errors that we
17:52 - might have now I want to reiterate that
17:54 - throughout this course anytime you see
17:56 - these red squigglies I want you to
17:58 - actively move your Mouse hover over the
17:59 - word that has the red squiggly and see
18:01 - the intellisense popup that shows up I
18:04 - can see it on my end but it's not
18:06 - something that scrio records into the
18:07 - scrim so very often I'll be saying if
18:10 - you hover your mouse over this item and
18:12 - look at the popup I actually want you to
18:14 - do that in fact I want you to do that
18:16 - pause now start hovering over some of
18:18 - the red squiggly words that you see here
18:20 - see if there's any bugs that you can fix
18:21 - right off the
18:27 - bat well some of these are giving us
18:30 - errors about the variable implicitly
18:32 - having an any type that's something
18:34 - we're going to talk about in the future
18:36 - but if you came down here to cach and
18:38 - register you can see that it says you
18:39 - cannot assign to cach and register
18:41 - because it is a constant or a readon
18:44 - property and assuming at this point you
18:45 - know the difference between a const and
18:47 - a let that should be a pretty obvious
18:50 - fix maybe out of habit I initialized
18:52 - this as a const but I'm trying to assign
18:55 - a new value to it in the future and I
18:57 - can't do that with a const so let's go
18:59 - ahead and change this to a let and by
19:01 - making that very simple change
19:02 - typescript is now satisfied when it
19:04 - comes to this cach and register variable
19:06 - let's come here to next order ID and we
19:08 - have the exact same problem this needs
19:10 - to be a let instead of a const by doing
19:13 - that now typescript is satisfied about
19:15 - next order ID at first glance using
19:18 - typescript can be a bit intimidating
19:20 - because of all of these red squigglies
19:21 - that show up and because of the
19:23 - additional code that you will have to
19:25 - write to fix the errors that it's
19:26 - warning you about but I think a better
19:28 - better approach or a better lens to look
19:30 - at this through is that typescript is
19:32 - showing us the problems in our code
19:34 - nothing about using typescript here is
19:37 - introducing new bugs it's just showing
19:39 - me where the bugs already existed this
19:41 - means I can find them immediately as I'm
19:44 - typing my code instead of having to wait
19:45 - till it crashes for our users so over
19:48 - the next few scrims we're going to fix
19:50 - the bugs that are already here we'll be
19:51 - adding new features to our app and
19:53 - seeing where typescript is and isn't
19:55 - happy all while using that to drive
19:57 - forward our knowledge of typ
20:02 - script there's one more era in here that
20:04 - we're able to fix before we even start
20:06 - writing typescript specific code and
20:08 - that's here on line 18 go ahead and
20:11 - hover your mouse over selected pizza
20:13 - here and you'll see the popup says the
20:15 - object is possibly undefined this is a
20:18 - great example of a time where typescript
20:20 - is able to warn us ahead of time that we
20:22 - have a potential problem and this brings
20:24 - me to a point that I will likely
20:26 - reiterate in the future in this course
20:28 - and that's the difference between coding
20:29 - on the happy path and the sad path now
20:32 - the happy path is when we are writing
20:34 - our code and we just assume that
20:35 - everything is going to work out
20:36 - perfectly this does tend to be the code
20:39 - that people who are new to coding will
20:41 - write I would say mostly because they
20:43 - haven't been hurt in the past by code
20:45 - push to production that didn't account
20:47 - for the edge cases that can pop up when
20:49 - you run code in production and that's
20:51 - because this is the easiest code to
20:53 - write we have a task that we're trying
20:54 - to solve we write the code that solves
20:57 - that task and then the temp ation
20:59 - sometimes is just to move on however
21:01 - typescript forces us to take a step back
21:03 - and consider the sad path the sad path
21:06 - is when we account for or assume that
21:08 - problems may occur it forces us to think
21:11 - of those edge cases where problems can
21:13 - arise and address them in our code the
21:15 - first time before we have complaints
21:17 - from our users in the live production
21:19 - version of our code telling us that the
21:21 - code is crashing their browsers in a way
21:23 - you can think of this as being a more
21:24 - defensive way to write your code and
21:27 - truly it's not asy easy you really have
21:29 - to think about all of the edge cases
21:31 - that can occur when your code is running
21:33 - in a live environment and it can be
21:35 - difficult to imagine the sometimes weird
21:37 - ways that our users might use our code
21:39 - in unexpected ways now typescript is not
21:42 - perfect for this but it makes writing
21:43 - for the sad path significantly easier
21:46 - and a perfect example here is with
21:48 - selected Pizza when it tells us that
21:50 - this object is possibly undefined and
21:52 - I'm sure that you've run into the error
21:54 - that happens when you try to access a
21:56 - property of undefined you'll see
21:58 - something like cannot access property
22:00 - price of undefined what's happening and
22:03 - what typescript can foresee being a
22:05 - potential issue is that we're trying to
22:07 - find an item in our menu array based on
22:10 - the pizza name String and typescript can
22:12 - see that it's possible this may come
22:14 - back as undefined if we're searching for
22:16 - a pizza that maybe we misspell or is
22:19 - some nonsense Pizza that doesn't exist
22:21 - inside of our menu then selected Pizza
22:23 - is going to be undefined and typescript
22:25 - says that would crash your program to
22:27 - satisfy typescript script in this case
22:29 - we can code a bit more defensively and
22:31 - say if there is no selected pizza then
22:34 - first let's go ahead and run a console.
22:36 - error we'll maybe say something simple
22:39 - like the current Pizza name that you're
22:41 - trying to search for does not exist in
22:44 - the menu then to satisfy typescript we
22:46 - need to return from this function or
22:49 - alternatively we could throw an error
22:51 - but the point is we want to stop
22:53 - execution of this function and by adding
22:55 - this return in here now typescript knows
22:57 - that this L of code will never get
22:59 - reached if selected Pizza is some falsy
23:02 - value like undefined I guess I could be
23:04 - a little bit more specific and say
23:06 - something like if selected Pizza is
23:08 - equal to undefined notice that that also
23:11 - satisfies typescript in this case I'll
23:13 - go ahead and just leave it as a check
23:15 - for the falsy value okay now it does
23:17 - feel a bit ridiculous that we haven't
23:19 - actually run our code yet the reason is
23:21 - because I knew there was a bunch of
23:23 - errors in here that we had to start
23:24 - fixing but now it's time for us to
23:26 - finally run our code and we can see that
23:28 - we do get a type error that says cannot
23:30 - set properties of undefined I thought
23:32 - this is what we just fixed this one
23:33 - though is talking about setting the
23:35 - status property now where is that
23:37 - happening that is happening where we
23:39 - complete the order order. status now
23:41 - there's a few points to be made here
23:43 - first of all it might seems strange that
23:45 - typescript is not warning us that order
23:47 - is potentially undefined in the same way
23:49 - that it was warning us that with
23:51 - selected Pizza there actually is a
23:53 - reason for this we're going to address
23:55 - it a little bit later on but secondly
23:57 - and I'm sure this was dri a bunch of
23:59 - people crazy when I'm calling complete
24:01 - order I'm passing in a string ID instead
24:04 - of a number ID and typescript isn't
24:06 - warning me about this at this point in
24:08 - this particular program we've reached
24:10 - the limit where typescript is able to
24:12 - help us without us going out of our way
24:13 - to write typescript specific code it's
24:16 - really nice that we able to fix a couple
24:17 - bugs and we can see that there are
24:19 - potential other bugs simply by including
24:22 - typescript in our project and using a TS
24:24 - extension on our file instead but since
24:27 - we've reached that limit where typt SCP
24:28 - is no longer willing to help us without
24:30 - defining specific types in our program
24:32 - let's finally jump in and start learning
24:34 - some typescript specific code starting
24:36 - from the
24:40 - basics we're starting to see some of the
24:42 - benefits of using typescript but I think
24:45 - they will really start to sink in as
24:46 - we're building a real project in order
24:49 - for us to do that we have to learn some
24:50 - of the very basics of typescript and
24:53 - that is how to type a variable when I'm
24:55 - writing vanilla JavaScript I can say
24:57 - something like let my name equal Bob and
25:02 - because typescript is a superet of
25:04 - JavaScript any JavaScript code that we
25:06 - have will be legitimate typescript code
25:09 - now perhaps unconventionally I'm going
25:11 - to start this lesson by saying when you
25:13 - write a line of code like this
25:15 - typescript is very smart and it's able
25:17 - to infer what data type is being used
25:20 - for the variable that you just created
25:22 - so go ahead and hover your mouse over
25:24 - this variable my name let it sit there
25:26 - for just a second and you'll see a
25:27 - really small pop up that says Let My
25:29 - Name colon string here what typescript
25:32 - has done is it has inferred or derived
25:36 - what data type my name is supposed to be
25:38 - now while we are about to learn how we
25:40 - can manually provide different data
25:42 - types to our variables I do think it's
25:44 - important to note that the work that
25:46 - we're about to do is busy work it's not
25:48 - something that typescript requires you
25:50 - to do because it's able to figure out
25:52 - the data types simply by the data type
25:54 - that you assign to it to demonstrate
25:56 - that if I then try to say my name equals
25:59 - a number we get a red squiggly and if
26:02 - you hover your mouse over my name we'll
26:04 - see that it says the type of five is not
26:06 - assignable to the type of string in
26:08 - other words typescript is angry that
26:10 - we're trying to reassign a number value
26:13 - to a variable that was originally set to
26:16 - be a string as a side note sometimes
26:18 - people talk about javascript's Dynamic
26:21 - typing nature where in regular
26:22 - JavaScript this operation is not a
26:24 - problem at all they talk about it being
26:26 - a strength in the flexibility JavaScript
26:29 - but in practice in the real world off
26:31 - the top of my head I can't think of a
26:32 - reason why this would be a beneficial
26:34 - feature for us to be able to reassign a
26:37 - string value to something that's a
26:38 - completely different data type it's a
26:40 - code smell to me which means that if I
26:42 - see something like this or I'm
26:44 - attempting to do this in my code then
26:46 - I'm probably structuring my code in a
26:48 - bad way so typescript forces us to think
26:50 - of better ways to organize our code
26:52 - anyway let's get back to manual typing
26:54 - now although typescript has correctly
26:56 - derived that this is going to be a
26:57 - string type I can manually give a type
27:00 - by typing a colon immediately after my
27:03 - variable name and then typing out the
27:05 - lowercase version of what data type I
27:07 - want this to be so this might look a
27:09 - little strange this is one of those
27:10 - instances where the typescript syntax is
27:12 - different from JavaScript syntax this
27:14 - would not be correct syntax in vanilla
27:16 - JavaScript but it is something that
27:18 - you'll see all throughout typescript and
27:19 - you'll just get used to typing it now
27:21 - let's get our hands on the keyboard and
27:23 - do an admittedly really simple challenge
27:26 - we've already used the Primitive dat
27:28 - data type of string lowercase s string
27:30 - and in typescript the other two
27:32 - primitive data types that we'll use are
27:34 - number lowercase n and bullion with a
27:36 - lowercase b the reason I'm creating a
27:39 - distinction between the uppercase and
27:40 - lowercase is because in JavaScript there
27:42 - is an uppercase s string Constructor and
27:45 - uppercase n number Constructor and the
27:48 - same with Boolean but that's not what
27:49 - we're accessing when we're doing these
27:51 - types okay should be super easy pause
27:53 - now and work on the challenge of
27:55 - explicitly typing these variables below
28:03 - well if we hover over number of Wheels
28:05 - again we can see that typescript derived
28:07 - the data type of number I guess this
28:09 - could be an easy way to cheat into
28:11 - knowing exactly what to be there but
28:13 - this is so straightforward I'm not
28:14 - concerned about that we're going to add
28:16 - colon number and colon Boolean in order
28:19 - to explicitly type these variables okay
28:22 - there's a little bit more syntax that
28:24 - we're going to learn when it comes to
28:25 - manually providing some types so once
28:27 - you feel feel pretty good about what
28:28 - we've done here let's keep moving
28:33 - forward we'll be talking about typing
28:36 - inside of functions really soon but I
28:38 - thought it would be a good chance to
28:39 - apply what we've learned to our pizza
28:41 - restaurant app so your challenge is to
28:43 - teach typescript what data type should
28:45 - be used for the order ID parameter here
28:47 - in our complete order function then once
28:50 - you've added that keep a close eye on
28:51 - the rest of the program to see if
28:53 - typescript has any new warnings and if
28:55 - something pops up go ahead and fix that
28:57 - pause now and work on this
29:04 - challenge again this is a bit on the
29:06 - nose because we know that this is not
29:08 - supposed to be a string but let's just
29:10 - assume that we missed that little error
29:12 - and we'll say that this order ID is
29:14 - supposed to be of a number type and sure
29:17 - enough because we've gone out of our way
29:18 - to add just a few additional characters
29:20 - to our complete order function
29:22 - typescript now knows that we're using
29:24 - this function incorrectly we're passing
29:26 - in a string where it shouldn't be if you
29:28 - cover your mouse over the one it says
29:30 - that the argument of type string one is
29:32 - not assignable to a parameter of type
29:34 - number and great yes that should be a
29:37 - number let's go ahead and make that a
29:38 - number and let's hit save and look at
29:41 - that there are other potential issues in
29:43 - our program but because we're using
29:45 - typescript we are no longer crashing
29:47 - with type errors all right now at this
29:49 - point our app would benefit from us
29:51 - starting to write what's called custom
29:53 - types so that's what we'll start
29:54 - learning in the next lesson
30:00 - we've talked about a few primitive types
30:02 - like string number and Boolean but in
30:04 - typescript we also can create our own
30:06 - custom types at first this isn't going
30:08 - to seem super useful but just bear with
30:10 - me we can create new types by using the
30:13 - type keyword this is something that
30:15 - exists only in typescript and by
30:17 - convention the name that we give our
30:19 - type is going to start with a capital
30:21 - letter for example I could say type food
30:24 - is equal to string by doing this I now
30:27 - could use the capital F food as my way
30:30 - of providing a new type to this favorite
30:33 - food variable now doing this with
30:34 - primitive types like strings numbers and
30:36 - booleans won't make a whole lot of sense
30:38 - until we talk later down the road about
30:40 - something called unions or intersections
30:43 - but this can come in handy for creating
30:44 - custom types around objects let me show
30:47 - you what I mean I have this person
30:49 - object with three properties name age
30:51 - and is student a pretty common thing
30:54 - with objects is that you might have
30:55 - multiple of the same kind of object so
30:58 - let's say we have a person two which
31:01 - looks very similar we're going to have
31:03 - Jill age know 66 and we'll go ahead and
31:07 - say is student is false as it stands
31:11 - there's no problem with this code
31:13 - however you might have noticed that I
31:14 - used a lowercase in this is student
31:16 - property and an uppercase s in this one
31:19 - one of the benefits of using typescript
31:21 - is that it forces us to stay consistent
31:23 - and although this may not cause a bug
31:25 - the way it's written currently it seems
31:27 - pretty ripe for a bug down the road what
31:29 - we can do is create a custom type of an
31:32 - object that defines the shape of the
31:35 - object where we can give it exactly what
31:37 - the property names are I can create my
31:39 - custom type by using the type keyword
31:41 - I'll use capital P person as my type and
31:43 - I'll set it equal to an object and what
31:46 - I'm doing inside of this object type is
31:48 - telling it what properties it will have
31:50 - like name but then instead of providing
31:53 - a value I'm going to give it a type I
31:55 - want my name to be a string type one
31:58 - quick side note about custom object
32:00 - types in a regular JavaScript object
32:02 - it's syntactically correct to have a
32:04 - comma to separate each one of your
32:06 - property names however when you're
32:08 - creating an object type like this you
32:10 - can use commas you also can use
32:13 - semicolons you also can just leave them
32:15 - out so for me personally I'm probably
32:17 - going to just leave out anything at the
32:19 - end here but you can choose whatever you
32:21 - want and it's most important just to
32:23 - stay consistent within the project that
32:24 - you're working in okay just so we can
32:26 - avoid some passive list listening here
32:28 - I'm going to include a really simple
32:30 - challenge here I know it's a little bit
32:32 - of busy work but getting your hands on
32:34 - the keyboard is always a win when you're
32:35 - learning to code so your challenge is to
32:37 - finish the object type definition so
32:39 - let's say so that it looks like person
32:41 - and you know what let's call this person
32:42 - one so that this type is the same shape
32:45 - as person one pause now and work on the
32:49 - challenge okay well we're going to put
32:51 - age is a number and is student is a
32:55 - Boolean simple enough now let's take a
32:57 - step back obviously writing this out has
32:59 - cost us more work it's used up five more
33:01 - lines of code frankly it doesn't take
33:03 - very long but it can feel like it's
33:05 - breaking your flow however by doing this
33:07 - we've added an extra degree of type
33:09 - safety when I'm defining person one I
33:12 - can use my colon and set it equal to my
33:15 - custom type person and I can do the same
33:17 - thing for person 2 we'll say this is
33:19 - capital P person and check it out even
33:22 - though we had to go out of our way to
33:23 - define this custom object type by doing
33:26 - that little extra work we have already
33:28 - been able to identify a potential
33:30 - problem we know that these two objects
33:33 - should be the same but we might have
33:34 - just missed it because we're fallible
33:36 - humans let's put in a capital S and
33:39 - satisfy typescript spend some time
33:41 - playing with this code and when you're
33:42 - ready we'll move on and talk really
33:44 - briefly about nested object
33:48 - types let's set a standard in our pizza
33:51 - restaurant app as to the shape our pizza
33:54 - objects should have and I'll have you do
33:56 - that through a challenge your task is to
33:59 - create a pizza object type it should
34:01 - include a name and a price property and
34:04 - that'll be the extent of the challenge
34:05 - for now we'll apply that in just a
34:07 - minute so pause now and work on this
34:14 - challenge okay this should be pretty
34:17 - straightforward we'll say we have a new
34:19 - object type called pizza and it needs to
34:22 - have a string name and a price which is
34:25 - a number okay easy easy enough now what
34:28 - I want you to do is to pause look
34:30 - through our code and see if there's
34:32 - anything obvious that you can enhance
34:34 - with typescript by telling it that the
34:36 - type should be of this pizza object type
34:38 - so pause now peruse through the code
34:40 - experiment a little bit see what happens
34:42 - and then I'll have an official challenge
34:43 - for
34:48 - you well if you're anything like me you
34:51 - probably went through and started
34:52 - looking at the different red squigglies
34:54 - that we have and right here in our add
34:56 - new pizza we have this pizza object
34:58 - which if you hover over it typescript
35:00 - warns us that it implicitly has an any
35:02 - type that term any type isn't
35:04 - necessarily supposed to make any sense
35:06 - to you yet so don't worry about that we
35:07 - will be covering that soon but this
35:09 - brings us to the next challenge all
35:12 - right your challenge is to teach
35:13 - typescript that this pizza object in
35:15 - this add new pizza function is supposed
35:17 - to be of type pizza then like before
35:20 - once you've done that look through the
35:22 - code and see if there are any new
35:23 - warnings you need to deal with of course
35:25 - there are going to be and fix those
35:27 - issues pause now and work on this
35:35 - challenge all we have to do is put a
35:37 - colon and then a capital P Pizza after
35:40 - this typescript is no longer warning us
35:42 - that pizza object is implicitly in any
35:44 - type and in fact if you hover your mouse
35:46 - over Pizza object here it will
35:48 - specifically tell you it's a parameter
35:50 - and it's of type capital P Pizza all
35:52 - right let me clean up this text and
35:54 - we'll just go ahead and peruse down here
35:57 - in our code
35:58 - and check it out down here when we were
36:00 - adding a new pizza we have these three
36:02 - new errors over cost if you didn't have
36:04 - a chance to do this already have your
36:06 - mouse over cost and you'll see that it
36:08 - tells you that the argument of type Nam
36:10 - string cost number is not assignable to
36:13 - the parameter of type Pizza okay well
36:16 - that's interesting the next thing it
36:17 - says is that the object literal may only
36:19 - specify known properties and cost does
36:22 - not exist in type pizza and sure enough
36:25 - when we wrote this we might have
36:26 - forgotten that it actually is supposed
36:29 - to be price not cost typescript saving
36:31 - us again you can go ahead and change
36:33 - these to price instead of cost and hit
36:36 - save and sure enough everything is
36:38 - working as we'd expect now I assume a
36:40 - number of you were probably screaming at
36:42 - me this whole time when I first wrote
36:44 - cost here in the beginning I promise it
36:46 - was all planned out and staged but
36:48 - notice that without writing our pizza
36:50 - type and specifically telling add new
36:52 - pizza is supposed to be taking a pizza
36:54 - object that our program wasn't
36:56 - necessarily crashing if you looked at
36:58 - our menu before we had an array of the
37:01 - items that we initialized in the
37:03 - beginning but then we also had added
37:05 - items with a name and a cost property
37:08 - and I don't know about you but that
37:09 - makes me feel gross to know that we have
37:11 - these mixed types in our menu that's
37:14 - just asking for crashing bugs down the
37:16 - road by adding just a few lines of
37:18 - really simple typescript we were able to
37:20 - defend against that problem that not
37:22 - only would never have shown up in
37:23 - regular JavaScript but also wasn't even
37:26 - showing up as issues here in typescript
37:28 - until we went out of our way to create
37:30 - this pizza type okay we're making good
37:32 - progress on fixing up the bugs in this
37:34 - app before we move forward there's one
37:36 - really easy update that we can make and
37:38 - it's so easy I'm not even going to make
37:40 - it a challenge here in our place order
37:42 - function if we hover over Pizza name
37:44 - which typescript is warning us about it
37:46 - says that it implicitly has an any type
37:48 - let's go ahead and type that as a string
37:51 - and get rid of that warning great well
37:53 - it looks like the majority of the issues
37:55 - actually all of the issues that we have
37:57 - left have to do with this variable order
37:59 - CU so let's go ahead and Tackle this
38:01 - issue
38:05 - next let's say we want to build out our
38:07 - person object a little bit more and we
38:09 - want to include an address property well
38:12 - typically something like an address
38:13 - wouldn't simply be represented by a
38:15 - string but instead by a nested object
38:18 - the most straightforward way to do this
38:20 - is to Simply type it out as if I were
38:22 - typing out a regular object I can put my
38:24 - curly braces there and just like I did
38:27 - with the rest of my type I can say maybe
38:29 - there's a street portion of my address
38:31 - and this is going to be a string we'll
38:33 - just stick to Street city which is a
38:36 - string and then we'll also say uh let's
38:38 - do country and that'll also be a string
38:41 - okay what do you notice about our code
38:42 - now well our objects below are typed as
38:45 - person objects or person types but we
38:48 - just changed the definition for person
38:50 - to say that it must include an address
38:52 - if we hover over the red squiggly which
38:54 - you should also do right now as you're
38:56 - watching this it tells us that the type
38:58 - of this person one with the object as it
39:01 - currently stands is not assignable to
39:03 - the type of person in other words
39:05 - there's a mismatch between the derived
39:07 - type of this variable that we've just
39:09 - set which typescript can see is a name
39:11 - with a string and age with the number
39:13 - and a is student with a Boolean and it
39:15 - sees that that doesn't accurately match
39:17 - the person type that we just redefined
39:20 - with the address property assuming we do
39:22 - actually want every one of our objects
39:24 - to have an address property we would
39:26 - need to make sure that we update our
39:28 - objects to include an address property
39:30 - that includes all of the subproperties
39:32 - of the person type definition under
39:34 - address so that means I would have to
39:36 - have a street let's just put something
39:39 - generic in here a city we'll say this is
39:42 - any town and the country we'll say is
39:46 - USA I'm sure you noticed as soon as I
39:49 - added country to my address it then
39:51 - satisfied the definition for this person
39:53 - type and typescript stopped complaining
39:56 - removing any one of these properties is
39:58 - going to make typescript complain
39:59 - because it doesn't perfectly match the
40:01 - type that was up there now I can guess
40:03 - what some of you might be thinking at
40:05 - this point because this is exactly what
40:07 - I thought at this point in my learning
40:09 - of typescript is that typescript feels
40:11 - so extremely rigid we've become very
40:14 - accustomed to writing JavaScript where
40:16 - essentially anything goes and we fix the
40:19 - bugs that we have while we're testing
40:20 - out our app and we kind of hope that we
40:22 - fix it all but at least we get some
40:24 - freedom and flexibility I have two
40:26 - things to say to that first of all we
40:28 - are going to learn a way in which we can
40:29 - make these properties optional so that
40:32 - typescript won't scream at us if for
40:34 - example we don't want person one to have
40:36 - an address but secondly I would say that
40:39 - you should work really hard to force
40:40 - yourself to become comfortable with that
40:43 - extra rigidity that's offered by
40:45 - typescript at first you might think that
40:47 - it's sort of stealing the fun of
40:49 - slinging JavaScript code and building
40:51 - projects on the Fly really quickly
40:53 - however when you're working in a real
40:55 - production environment at a company
40:57 - you're going to find it less fun when
40:58 - you have to fix bugs in production
41:00 - because you didn't have the extra
41:02 - rigidity and type safety that comes by
41:04 - using typescript all right I'll get off
41:06 - my high horse now one last thing before
41:08 - we move on another common way that you
41:10 - will see this nested object structured
41:13 - is by not necessarily defining the types
41:15 - right here in line with our person
41:17 - object but instead simply creating a
41:20 - separate type for the address alone and
41:22 - so I'm going to turn this into a
41:24 - challenge your challenge is to try and
41:26 - figure out how to move the nested
41:28 - address object that we have here into
41:31 - its own type like we see here and once
41:33 - you've done this correctly there should
41:34 - be no red errors in the editor below I
41:37 - do want to point out that I haven't
41:39 - explicitly taught how to do this what
41:41 - I'm trying to accomplish here is getting
41:43 - your brain thinking get your hands on
41:44 - the keyboard and see if you can put two
41:46 - and two together to figure out exactly
41:48 - what this would look like if you're
41:50 - feeling stuck rather than just hitting
41:52 - play and moving forward I would
41:53 - recommend searching on Google or opening
41:56 - chat GPT and formulating your question
41:58 - specifically so that you can be engaging
42:00 - your mind and really going out of your
42:02 - way to try and learn these things when
42:04 - you just push forward and watch me do it
42:06 - it doesn't sink in quite the same way as
42:08 - when you are more engaged okay getting
42:10 - off my soap box now pause now and work
42:12 - on this
42:18 - challenge well I should be able to just
42:21 - take the properties of my address here
42:23 - I'll cut those out I'll put them into
42:25 - their own address type up here and then
42:28 - instead of doing an inline object here I
42:31 - can simply refer to the capital A
42:34 - address type that we defined above and
42:36 - after I've done that you can see there
42:38 - are no more errors in the editor either
42:40 - of the two ways that we just saw it is
42:42 - completely fine if you think that you
42:44 - are going to be using this address type
42:46 - elsewhere in your code as a standalone
42:49 - type then it makes sense to separate it
42:51 - into its own address type like we just
42:53 - did or if you already know that address
42:56 - is only ever going to exist as an object
42:59 - in the context of a person object then
43:01 - you can just leave it nested inside of
43:03 - the person object and that will work
43:05 - just fine as well once you've had enough
43:07 - time to play around with this and feel
43:08 - pretty comfortable with it then you'll
43:10 - be ready to move on to the next Grim
43:12 - where we will talk about how we can make
43:13 - some of these properties optional if we
43:15 - need
43:19 - to something that might put your mind at
43:21 - ease regarding typescript rigidity is
43:24 - knowing that when you're creating object
43:25 - types like we see here with person you
43:27 - can Define some of these properties to
43:29 - be optional now this comes with a caveat
43:32 - when you're making decisions about
43:33 - whether something should be optional
43:35 - typescript comes with a number of ways
43:37 - that you can relax that rigid nature but
43:39 - you should learn to force yourself to
43:41 - really ask the question do I really need
43:43 - this to be flexible we're going to see
43:45 - multiple different ways in which
43:47 - typescript offers that flexibility
43:49 - however they always come with the
43:50 - trade-off of reduced type safety let's
43:52 - get the syntax out of the way for doing
43:54 - this because it's really simple for
43:56 - example if don't necessarily want every
43:58 - person to have an address you can see
44:01 - removing address gives me some
44:02 - typescript warnings when I'm defining my
44:04 - type I can simply put a question mark
44:06 - after the property name that's going to
44:08 - be optional you can see as soon as I
44:10 - typed that question mark the warning
44:12 - under person one went away and that's
44:14 - because now the address property is
44:16 - optional this has offered me a bit of
44:18 - flexibility however as I mentioned it
44:20 - does reduce my type safety we'll be
44:22 - talking more about adding type safety to
44:25 - functions soon but let's say I have a
44:27 - function that's called display info and
44:30 - this function is going to take a person
44:32 - as a parameter and in it it's going to
44:34 - console log and let me use a template
44:36 - string here we'll say person. name lives
44:39 - at and then we'll stick in person.
44:43 - address. Street okay so now later in my
44:46 - code or maybe in another module I import
44:49 - display info and I'm going to call
44:51 - display info and pass person one to it
44:54 - well this is a bit on the nose I'm sure
44:56 - that you can see what this this problem
44:57 - is going to be let's hit save check our
45:00 - console and sure enough cannot read
45:02 - properties of undefined that dreaded
45:04 - error that we see notice that it says
45:06 - it's a type error this is an error that
45:08 - was introduced well really for two
45:10 - reasons one because we chose to make
45:12 - this an optional property but in truth
45:14 - maybe more importantly because we didn't
45:16 - add any type safety to our function I
45:18 - can technically get rid of this error by
45:20 - using optional chaining right here on
45:22 - address one thing to note is that
45:23 - currently scrimba doesn't understand
45:25 - optional chaining but trust me this is
45:27 - going to work just fine however this
45:28 - solution isn't great because if I hit
45:31 - save we see that we get Joe lives at
45:33 - undefined not a program crashing type
45:36 - error but still not a great experience
45:38 - now don't let me get in your head too
45:40 - much adding an optional property is a
45:41 - completely legitimate and fairly common
45:43 - thing to do in typescript I'm just
45:45 - making sure I do my due diligence and
45:47 - letting you know that every time you add
45:49 - one of these sort of flexibility
45:51 - enhancing features of typescript you are
45:52 - going to reduce your type safety by a
45:54 - little bit okay let's move on and apply
45:57 - what we've learned to our pizza
45:59 - restaurant
46:03 - app okay let's Jump Right In with the
46:05 - challenge your task is to create a new
46:07 - order type in that type it should have
46:09 - an ID pizza and Status properties I
46:12 - won't to explicitly give you what data
46:14 - type those should be but just look
46:16 - through the code if you need some hints
46:17 - as to what it will be pause now and work
46:19 - on the
46:25 - challenge okay let's let's create a new
46:28 - type called order and this will be an
46:31 - object it's going to have an ID which is
46:34 - going to be a number remember down here
46:36 - we have our order numbers that we're
46:37 - keeping track of and so that will be a
46:39 - number the pizza property is going to be
46:42 - a pizza type which makes sense because
46:44 - it's a nested object inside there and
46:47 - the status property for now is just
46:49 - going to be a string we're going to talk
46:51 - about this a little bit later let's
46:52 - clean up the challenge text and
46:54 - hopefully that was pretty
46:56 - straightforward now this wasn't
46:57 - explicitly part of the challenge there's
46:59 - a chance that you came to the order
47:01 - queue and decided to try and make this
47:03 - of type order and you'll notice that
47:05 - that doesn't fix the warning that
47:06 - typescript is giving us and that's
47:08 - because the order Q is an array it's not
47:11 - a single object so before we can fix
47:13 - this we need to learn about typing
47:14 - arrays it's fairly straightforward so
47:17 - we'll do that in a quick scrim after
47:18 - this and then we'll come back to our
47:20 - pizza restaurant and fix these
47:25 - issues we've learned about how to
47:27 - manually type the Primitive types in
47:29 - typescript for example if you have
47:31 - something like let age equal 100 you can
47:35 - manually tell typescript that age is
47:37 - going to be a number like this and
47:39 - there's a similar syntax when we are
47:41 - typing arrays so if I have an array and
47:44 - maybe we'll just call this ages so that
47:46 - it makes a little more sense maybe 100
47:48 - and 101 notice that typescript is
47:51 - complaining about the type of Ages hover
47:53 - your mouse over the variable ages here
47:55 - and you'll see that it says the type
47:56 - type number square brackets is not
47:59 - assignable to type number well it kind
48:01 - of gives away the Syntax for typing
48:03 - arrays all we have to do is simply put a
48:05 - set of square brackets as if this were
48:08 - the array syntax with an empty array
48:10 - right after the type and this is how we
48:12 - teach typescript that ages should always
48:15 - be an array that consists only of number
48:17 - elements if we were to try and put
48:21 - another thing in here maybe the string
48:23 - one then we get an error again it tells
48:25 - us that there's a problem with this last
48:27 - element because it is not a number
48:29 - inside of this array the same will
48:30 - happen if I try to push something to the
48:33 - array that isn't of the correct data
48:35 - type like ages. push true red squiggly
48:38 - shows up here under true and it says
48:39 - that it's not assignable to the
48:41 - parameter of type number this should all
48:43 - be pretty straightforward for you at
48:44 - this point I think it's important to
48:46 - note that in the same way that
48:47 - typescript is able to infer a regular
48:50 - number typescript is also able to infer
48:53 - the data type of an array of numbers so
48:55 - when it's an array with some simple
48:57 - primitive data types in there we don't
48:59 - have to manually put colon number square
49:02 - brackets or string square brackets or
49:04 - anything like that we can just let
49:05 - typescript do its job and we're going to
49:07 - get the same benefits in the end however
49:09 - when we have a custom data type like a
49:12 - person data type that we've seen before
49:14 - let me fill this out again we have a
49:16 - name String we'll say an age is a number
49:19 - and is student is a Boolean when we want
49:22 - to create an array of these people
49:24 - objects well actually I think you'll be
49:26 - able to figure this one out let's make
49:27 - it a
49:29 - challenge okay I took away some of the
49:31 - busy work here for you by creating a
49:33 - couple of person objects I've already
49:35 - typed them as a type person and your
49:37 - challenge simply enough is to create an
49:39 - array with person one and person two in
49:41 - it and then to manually type this array
49:43 - as an array of person types pause now
49:46 - and work on the
49:52 - challenge okay let's go ahead and set
49:55 - this equal to an array we will will
49:56 - stick person one and person two in there
49:59 - and before I manually type this as an
50:01 - array of person types I'm going to hover
50:02 - over this variable people and you should
50:05 - do this as well and you'll notice the
50:06 - popup does correctly type this as a
50:09 - person array because every item in this
50:12 - array conforms to the person type it
50:15 - knows that this people array should
50:17 - continue to be an array of person type
50:20 - but that's not what the challenge says
50:21 - the challenge says to manually do it so
50:23 - we'll put colon person and then the
50:26 - array bracket syntax now normally as
50:28 - I've said it's good to let typescript do
50:31 - as much inference as it can especially
50:33 - when it comes to primitive types like
50:35 - numbers and booleans however I'm a
50:37 - little bit more torn here yes typescript
50:39 - is able to infer that people is an array
50:41 - of person types however adding it here
50:44 - explicitly does make it a little bit
50:46 - easier for myself or other developers to
50:48 - read in the future so in this case I'm
50:50 - just going to leave this here we also
50:52 - can note that if I don't manually type
50:54 - it and then I remove the person type
50:57 - declarations here and hover over let
51:00 - people we can see that now it has
51:02 - inferred the type to be an object
51:04 - literal with all of the properties
51:06 - instead of having the person type as an
51:08 - array here but we're using typescript I
51:11 - can't think of a good reason to not type
51:13 - these as person objects so we'll just
51:15 - leave it like that and maybe I'll go
51:16 - ahead and put back my colon person array
51:18 - as well really quickly there is another
51:20 - syntax which you may see floating around
51:23 - and we will talk a little bit more about
51:24 - it later in this course when we talk
51:26 - about about the concept of generics but
51:28 - for now it's enough to know that there
51:30 - is a syntax where you can use capital A
51:32 - array a set of angle brackets and then
51:36 - put your type inside of the angle
51:38 - brackets and I could use this in place
51:40 - of my person with square brackets just
51:42 - like this this is going to do the exact
51:44 - same thing you can hover over people and
51:46 - see that it is correctly knowing that
51:48 - it's an array of person types so I'm
51:50 - just covering my bases here don't worry
51:52 - too much about that we're going to stick
51:54 - with this syntax for now and talk more
51:56 - about that other syntax when we talk
51:57 - about generics okay let's get back to
51:59 - our pizza restaurant and apply what
52:01 - we've learned to our code over
52:05 - there here we are back in our pizza
52:07 - restaurant and your challenge is to fix
52:09 - the typescript warnings that we have
52:11 - throughout our code about order Q pause
52:13 - now and work on this
52:19 - challenge okay well we already have our
52:22 - order type that we wrote previously and
52:24 - we know that the order CU should should
52:26 - always be an array of order objects so
52:30 - by doing that typescript is no longer
52:32 - complaining about order q and if we come
52:34 - down we only have one more typescript
52:36 - warning here and this is awesome this is
52:38 - actually a really helpful warning but
52:40 - everything else has resolved itself now
52:43 - that typescript knows that order Q
52:45 - should be an array of orders it's able
52:47 - to ensure that we won't have any type
52:49 - errors in our program because we've
52:51 - generally written everything okay now
52:53 - there is this one new warning here under
52:55 - order. status order says that it's an
52:58 - object that is possibly undefined and
53:01 - this should look familiar this is
53:02 - exactly the warning we were getting
53:04 - above when we were writing selected
53:06 - pizza. price it was telling us that
53:08 - selected Pizza is possibly undefined so
53:11 - that brings us to the next challenge
53:14 - okay now your challenge is to fix this
53:15 - warning below by handling the sad path
53:18 - scenario notice I'm being a little bit
53:19 - vague here I do want this to be a chance
53:21 - for you to engage your brain try to
53:23 - remember what we've learned before look
53:25 - through the rest of the code that should
53:27 - help you out quite a bit pause now and
53:29 - work on this
53:35 - challenge when we're running order q.
53:38 - find if we provide an order ID that does
53:40 - not exist in the order Q then this order
53:43 - is going to be an undefined value in
53:46 - fact if you hover over order here you'll
53:48 - see the intellisense popup it says const
53:51 - order Colon capital O order and then a
53:54 - pipe character or a line and and then
53:56 - undefined similar to JavaScript with the
53:59 - double pipe operator indicating an or
54:01 - logical operator I like to read this
54:04 - single pipe in typescript like the word
54:06 - or as well in other words const order is
54:09 - either going to be a capital O order
54:11 - object or it will be undefined and
54:14 - that's because typescript knows if it's
54:16 - not able to find something with the
54:18 - finded method it will return undefined
54:20 - and in this case we're not handling that
54:22 - in our code typescript saves us again so
54:25 - if there is no order then maybe we'll
54:28 - just do what we did above where we
54:30 - console error let's say order
54:34 - ID was not found in the order que and
54:39 - then we'll go ahead and return although
54:41 - as I mentioned before this could be an
54:42 - opportunity for us to throw an error if
54:45 - we were to throw a new error and then
54:48 - maybe put this message in there that
54:50 - would work just as well because it halts
54:52 - the execution of this function and
54:54 - therefore typescript is now satisfied
54:56 - that order. status is never going to get
54:58 - reached if order is non-existent but
55:01 - just to stay consistent I'll go ahead
55:03 - and keep my return here clean up the
55:05 - challenge text and look at that all the
55:07 - typescript warnings in our app are gone
55:09 - now I do think it's important to note
55:11 - that the lack of typescript warnings
55:13 - doesn't automatically mean that our
55:15 - program will function exactly as we
55:17 - expect it doesn't mean that we've
55:18 - handled every Edge case but it does mean
55:20 - with relatively little amount of effort
55:22 - we have a much greater degree of
55:24 - confidence that our app is going to work
55:26 - as as we would expect speaking of which
55:28 - we haven't run this code in a while
55:30 - let's run it and open our console and
55:32 - Awesome everything looks the way that we
55:34 - would expect in order for us to touch on
55:36 - a few more topics in typescript we are
55:38 - going to start building out new features
55:40 - in our pizza restaurant app but before
55:42 - we do that I do want to encourage you to
55:43 - get your hands on this code play around
55:45 - with this try adding some new functions
55:48 - or making some kind of change it doesn't
55:50 - even have to be significant for example
55:52 - when I was first writing this I decided
55:54 - I actually wanted to rename the to order
55:57 - history and if I do that suddenly we get
55:59 - some errors immediately showing up in
56:01 - our typescript that are super helpful
56:03 - they help us know exactly what needs to
56:05 - change in fact I'm going to leave this
56:07 - as order history so that I can bug some
56:09 - of you into fixing this error and
56:10 - getting your hands on the code once you
56:12 - feel pretty comfortable with everything
56:13 - that we've written so far let's keep
56:15 - moving
56:19 - forward hopefully you've had a chance to
56:21 - play around with the intellisense popups
56:23 - that happen when you hover over
56:25 - different variables that you deare with
56:26 - typescript and something you might have
56:28 - noticed is the difference between how
56:30 - typescript infers different types for
56:32 - example if I were to say let my name
56:36 - equal the string Bob go ahead and hover
56:38 - your mouse over my name okay you'll see
56:41 - that it says Let My Name colon string so
56:44 - typescript has correctly inferred that
56:46 - my name is of type string and it will
56:48 - warn me if I were to ever try and change
56:50 - it to a different data type you can see
56:52 - here typescript is saying that you can't
56:54 - assign the value true to a string type
56:57 - variable okay let's see how that differs
56:59 - however when we use const to declare our
57:02 - variables so if I say const my name
57:04 - equals Bob and I need a different
57:06 - variable name let's say my name 2 cuz
57:08 - I'm really original right now C your
57:10 - mouse over my name 2 this time the popup
57:13 - doesn't show the type as a string but
57:15 - instead it shows the type as the string
57:18 - Bob this is called a literal type and
57:20 - it's when you tell typescript that the
57:22 - type isn't a generic string which would
57:25 - allow that variable to be become any
57:26 - string but instead it's a literal type
57:29 - an actual value type of the string Bob
57:32 - with a capital B at the beginning if you
57:34 - put a little bit of thought into it then
57:36 - this will make sense because with let I
57:38 - am allowed to change the value of this
57:41 - variable and typescript logically
57:43 - restricts the data type of the value I'm
57:45 - allowed to change it to to a string and
57:47 - with const I'm not allowed to reassign
57:50 - this value and so it makes sense for
57:52 - typescript to say this value has to be
57:54 - the string Bob from here on out I can't
57:57 - say my name to equals bill this not only
58:02 - makes sense in typescript but also
58:03 - JavaScript we would get warned in
58:05 - regular JavaScript saying we can't
58:06 - reassign a const and if you hover over
58:09 - my name 2 here it says cannot assign my
58:11 - name 2 because it is a constant or a
58:13 - readon property just for the sake of
58:16 - completeness I can manually type
58:17 - something to be a literal type so I
58:20 - could say const my name to colon the
58:23 - string Bob equals the string Bob of
58:25 - course typescript already inferred this
58:27 - but this is what that syntax would look
58:29 - like I could do the same thing with my
58:31 - let I could say Let My Name colon the
58:34 - string Bob equals Bob and if I were to
58:37 - try and change this to anything else
58:39 - like Bobby then I get a typescript
58:41 - warning the same thing would happen down
58:43 - here now there are times where you may
58:45 - see this being useful in typescript but
58:47 - more often than not the concept of using
58:49 - literal types is much more commonly
58:51 - found when you pair it with a concept
58:53 - called unions so feel free to around
58:56 - with this code and in the next Grim
58:58 - we'll learn about what unions
59:03 - are as I mentioned there certainly are
59:05 - going to be times when a literal type by
59:07 - itself can be useful however you will
59:10 - often times see them being used combined
59:12 - with a concept called unions let's start
59:14 - with an example let's say we are working
59:17 - on an application and we want to
59:19 - maintain a different kind of user role
59:22 - for the sake of our database and our
59:24 - application we're going to be saving
59:25 - that user role either as guest or member
59:29 - or admin and in our app we don't want
59:32 - someone to be some kind of user R like a
59:35 - hacker or something completely gibberish
59:37 - that doesn't make sense to our
59:39 - application in this kind of scenario we
59:41 - can use a combination of literal types
59:43 - and this concept called unions to teach
59:45 - typescript that this variable user role
59:48 - should only be allowed to be one of a
59:50 - certain number of strings if you're
59:52 - familiar with the concept of enums in
59:54 - other languages this is essentially the
59:57 - same idea as an enum there's a little
59:59 - bit more to be said about that because
60:00 - typescript does have something called
60:02 - enums but let's not get bogged down by
60:04 - that topic for now if you're not
60:06 - familiar with the concept of enums well
60:08 - you already are familiar with the
60:09 - concept of an enum because you know what
60:11 - a Boolean is a Boolean can only either
60:14 - be true or false it has to be one of
60:17 - those two values and it can't be
60:18 - something like yes or no at least not in
60:21 - JavaScript so if we have our user role
60:25 - and we want this to only ever be guest
60:27 - member or admin we can use Union types
60:30 - in order to accomplish this I'm going to
60:33 - create a new type called user Ro and I'm
60:36 - going to set it equal to the literal
60:38 - value of guest and then I can make a
60:41 - union by using the single pipe character
60:44 - you can essentially read this just like
60:46 - you would the double pipe character in
60:48 - JavaScript as the English word or so I
60:50 - can say that type user Ro is either
60:53 - going to be the string literal guest or
60:56 - the string literal member or the string
60:59 - literal admin and now that I've defined
61:02 - what a user roll type is allowed to be I
61:04 - can tell my variable that it has to
61:07 - conform to the user Ro type and from
61:09 - then on if I were to ever change this to
61:11 - some gibberish typescript would give me
61:13 - a warning this literal Union type that
61:15 - we have here doesn't just need to be its
61:18 - own Standalone thing I might have it
61:20 - nested inside of another type so I might
61:22 - have a user type which has all of the
61:25 - other properties that we might normally
61:27 - see like a username of string blah blah
61:29 - blah and then I might say user r or
61:32 - let's just call it role and we can just
61:34 - copy what we have here and say that the
61:37 - user. roll property has to be one of
61:40 - these three string literals I won't
61:42 - necessarily go down and show an example
61:44 - because I think you get the idea let's
61:46 - go ahead and satisfy typescript by
61:48 - making this one of the available options
61:50 - inside of our user roll Union and
61:52 - typescript is satisfied okay let's jump
61:55 - back to our p a restaurant app there's a
61:57 - really small update that we can make now
61:58 - that we understand literal types and
62:03 - unions we can add a little bit of extra
62:06 - type safety to our orders by teaching
62:09 - typescript that an order type is allowed
62:11 - to not just be any string but it either
62:13 - has to be the string ordered or the
62:16 - string completed this should be pretty
62:18 - straightforward will make this a quick
62:20 - challenge go ahead and update our order
62:23 - type so that the status property can
62:25 - only ever be the string ordered or the
62:28 - string completed then once you've done
62:29 - that try to make a change in our code
62:31 - maybe change this status to something
62:34 - other than ordered or completed some
62:36 - gibberish will do and make sure that
62:37 - typescript is complaining about that
62:39 - change pause now and work on this
62:46 - challenge okay we'll just make this so
62:48 - that it can't be any string but it only
62:51 - can be the literal value ordered or the
62:55 - literal value completed now that we've
62:57 - made this change we can actually see
62:59 - there's a new typescript warning and
63:01 - that has to do with this line 35 where
63:03 - we have new order this one can be a
63:05 - little bit confusing to understand but
63:07 - let's walk through it step by step here
63:09 - we're creating a new order variable and
63:11 - we're setting it equal to this object
63:13 - literal when I hover over New Order we
63:16 - can see from the intellisense popup that
63:18 - it was able to infer essentially the
63:20 - shape of the object as having an ID
63:23 - that's a number a pizza which is a
63:25 - object with a name that's a string and a
63:27 - price that's a number and then a status
63:29 - that's a string however now that we have
63:32 - gotten more specific in what our order
63:35 - should look like up here where it has to
63:37 - be the string ordered or completed not
63:39 - just any kind of string the object that
63:41 - we're trying to push into our order
63:43 - queue which if you remember we specified
63:46 - needs to be an array of orders the data
63:49 - type that typescript inferred for our
63:51 - status right here is just a generic
63:53 - string I know this can be a little bit
63:55 - confusing don't fret too much if none of
63:58 - that is making any sense but the way
64:00 - that we can fix this error is by saying
64:02 - when we are instantiating a new order we
64:04 - can tell typescript specifically this is
64:06 - going to be of an order type by manually
64:09 - typing this as a type of order it now
64:12 - knows that the status of ordered here is
64:15 - not just any old string it is conforming
64:18 - to the status literal Union type that we
64:21 - defined up here and because of that
64:22 - order Q which needs to be an array of
64:25 - orders is okay with us pushing in a new
64:28 - order and if I were to try and change
64:31 - this to something like blah blah blah
64:33 - now typescript is complaining again
64:35 - because it knows that that's not okay it
64:37 - can't just be any string it has to be
64:39 - one of either ordered or completed so
64:43 - let's go ahead and change this back the
64:45 - same thing would happen if I come down
64:47 - here and I change this to blah blah now
64:49 - typescript is not going to be happy with
64:51 - me updating order. status because it
64:54 - knows that blah blah is not one of the
64:56 - legitimate statuses for our order object
64:59 - as always play around with this code and
65:01 - once you're ready we'll keep moving
65:05 - forward as we've talked about typescript
65:08 - is great at inferring primitive types
65:10 - and other more complex types that don't
65:12 - necessarily hold a lot of weight in the
65:15 - functionality of our app however there
65:16 - are certain times when we would really
65:18 - want to make sure we manually include
65:21 - the type of something for example here
65:23 - in our menu we're defining the menu as
65:25 - an array of these objects and these
65:28 - objects just so happen to conform to our
65:31 - type of pizza but we haven't actually
65:33 - told typescript that our menu should be
65:35 - an array of pizza items this becomes a
65:38 - lot more apparent when we try to make a
65:39 - definition change to our type of pizza
65:42 - Let's see we were tasked with creating a
65:44 - new helper function called get pizza
65:46 - detail which allows us to find one of
65:49 - the pizzas in the menu either by its ID
65:52 - or by its name well currently we don't
65:55 - have IDs in our pizzas and so we might
65:57 - think to come up to pizza and say this
65:59 - should also have an ID that's a number
66:01 - and doing this because it's typescript
66:03 - really helps us out further down the
66:05 - road when we find out some of our code
66:07 - is not going to work the way we think
66:09 - because they don't have IDs when we're
66:11 - trying to add new pizza and so forth but
66:13 - I'm not concerned about this quite yet
66:15 - we'll get to that later but notice that
66:17 - our menu does not have a problem with
66:19 - the change that we made to our pizza
66:20 - type definition because it doesn't know
66:23 - that it's an array of pizzas so let's go
66:26 - ahead and type it as an array of pizzas
66:28 - okay now typescript is warning us hover
66:30 - your mouse over menu and you'll see that
66:32 - it's complaining about how there's an ID
66:34 - property missing in these objects here
66:36 - great that's a good warning that just
66:37 - saved us some trouble so I'm going to go
66:40 - ahead and add a manual ID property here
66:44 - and we'll just kind of make them
66:45 - increment
66:47 - manually notice if we scroll down we
66:50 - used to have an error I think it was
66:52 - here on New Order because the pizza we
66:54 - were adding did not have an ID and
66:56 - pizzas now need IDs but we are correctly
66:59 - getting errors down here with add new
67:01 - pizza because these ones don't include
67:03 - IDs for now I'm just going to manually
67:06 - add IDs here as well this is just a
67:08 - temporary fix until we figure something
67:10 - else out what we just saw is a perfect
67:13 - example of how typescript doesn't make
67:15 - your job harder as a developer it
67:18 - actually significantly improves your
67:19 - ability to add new features and to debug
67:22 - your code in the process all I had to do
67:25 - was make an an update to my pizza type
67:26 - and typescript immediately showed me
67:28 - where all of the problems with that
67:30 - change would happen and I was able to
67:32 - pretty quickly go in and fix them
67:34 - granted the fix will not always be quite
67:35 - this easy but hopefully you're seeing
67:37 - the benefits nonetheless next we'll move
67:39 - on to a concept called type narrowing
67:41 - and we'll do that through a series of
67:47 - challenges to start us off on a lesson
67:49 - about type narrowing I'm going to give
67:51 - you a challenge I want you to create a
67:53 - new utility function called get Pizza
67:55 - detail it's going to take a single
67:58 - parameter called identifier but there's
68:00 - a little twist to this we want to allow
68:02 - this identifier either to be the string
68:04 - name of the pizza like the string
68:06 - pepperoni or it could be the ID number
68:09 - of the pizza for example the pizza with
68:12 - the ID of the number two you don't have
68:14 - to worry about the code inside of the
68:16 - function just yet I just want you to
68:18 - create the function signature and just
68:20 - make sure that you type the identifier
68:22 - parameter correctly so that typescript
68:24 - is okay with it either being a string or
68:26 - a number type I haven't taught how to
68:28 - very specifically do this one thing but
68:30 - assuming you've been following along and
68:32 - doing the challenges I think you'll be
68:33 - able to put this one together pause now
68:36 - and work on this
68:42 - challenge okay let's create a function
68:44 - called get pizza detail it's going to
68:48 - take identifier as a parameter and we're
68:52 - going to type this identifier as either
68:54 - a string
68:56 - or a number and this is what I meant by
68:58 - saying we haven't specifically taught
69:00 - this thing we talked about doing it with
69:02 - string literals if we wanted it to
69:04 - literally be one value or another value
69:07 - but we can also use unions with more
69:09 - generic types like you see here okay
69:12 - let's start working on the internals of
69:14 - this function and really what I mean is
69:16 - I want you to do this I'll make this
69:17 - into a challenge I'm getting a little
69:20 - bit more vague with the details of how
69:22 - to accomplish this challenge but that's
69:24 - okay cuz I know you're to the task I
69:26 - want you to write the code for our get
69:28 - pizza detail function so that it's able
69:30 - to use the identifier whether it's a
69:33 - string or a number and use the menu.
69:35 - find method accordingly once one of the
69:38 - pizzas from the menu has been found it
69:40 - should return that pizza for now you can
69:42 - just assume that it will find something
69:44 - in menu. find you don't have to handle
69:46 - the instance where it might not find
69:47 - something pause now and work on this
69:49 - challenge
69:56 - okay let's get started on this in
69:58 - JavaScript we can determine what kind of
70:01 - data type identifier has by using the
70:03 - type of keyword and so I'll use an if
70:06 - statement that says if the type of
70:08 - identifier is a string then I can assume
70:12 - that it's going to be the name of the
70:13 - pizza and so I will return whatever
70:16 - comes back from menu. find and we'll say
70:20 - for every Pizza that we're looking
70:22 - through if pizza. name is equal to to
70:26 - the identifier then it will find the
70:28 - correct pizza and return it one little
70:30 - feature I think I'm going to add is I'm
70:32 - going to lower case both of these just
70:35 - so that if they put in the wrong
70:38 - capitalization for the pizza name or
70:40 - something like that then it will still
70:42 - be able to find the correct pizza now
70:43 - for the next part I'm going to just use
70:45 - an else instead of an else if checking
70:48 - the type of the identifier to be a
70:50 - number but I'm doing this specifically
70:52 - so that I can show a limitation of being
70:54 - less specific for now we'll essentially
70:56 - return this exact same line except
70:59 - instead of name we're going to check the
71:02 - ID and uh we don't need a to lowercase
71:05 - because that's going to be a number and
71:07 - actually check this out if we hover over
71:09 - to lowercase typescript is able to tell
71:11 - us that do to lowercase does not exist
71:14 - on type number this is super interesting
71:16 - because it highlights the fact that
71:18 - typescript is able to parse and
71:20 - understand our code and it knows that we
71:22 - have already handled the instance where
71:24 - the ident ifier might be a string and
71:27 - because we've told typescript that the
71:28 - identifier is either a string or a
71:31 - number it knows that in this case
71:33 - according to what we have told
71:35 - typescript the type of the identifier
71:37 - will be in this else statement it has
71:39 - been able to narrow the type down to be
71:42 - a number also if we were to have copied
71:45 - this line of code down and simply
71:47 - removed the dot to lowercase but forgot
71:49 - to change this from name to ID
71:52 - typescript warns us that we can't use
71:54 - the trip equals to compare a string
71:57 - which it knows pizza. name is and a
71:59 - number which now that we have narrowed
72:01 - the type down we know that it is no
72:03 - longer going to be a string if it's
72:05 - reaching this code and so it's able to
72:07 - warn us that these things aren't going
72:09 - to equate correctly so just another
72:11 - instance of typescript helping us out so
72:13 - this is just one example of this concept
72:15 - called type narrowing where when we're
72:17 - writing a function and we don't
72:19 - necessarily know what the data type of
72:21 - that function is typescript will expect
72:23 - us to narrow down the type and handle
72:26 - each use case or potentially provide a
72:29 - default for all other use cases if it
72:31 - isn't in the if or else if statements
72:33 - soon we're going to see another example
72:36 - of where type narrowing is really
72:37 - important but first I want to address
72:40 - this lse statement that we have as I
72:41 - mentioned I would we'll do that in the
72:43 - next
72:46 - scrim although this isn't a specific
72:49 - benefit created by using typescript one
72:52 - thing that writing your projects in
72:53 - typescript will help you do is remember
72:55 - to be as explicit as you can when you're
72:58 - writing your code for example I have
73:00 - told typescript that my identifier is
73:02 - either going to be a string or a number
73:05 - and I've handled the case where the type
73:07 - is going to be a string and therefore
73:09 - typescript can assume that inside of my
73:11 - else Clause here the type will be a
73:13 - number however in some instances you may
73:15 - be working in a project where the code
73:17 - you're writing will end up being used in
73:19 - a plain Javascript file and the
73:22 - protection that other file would
73:23 - normally get if it were used using
73:25 - typescript won't exist so I've added
73:27 - this export in front of our function and
73:30 - I'm going to use this index.js file to
73:33 - import our get pizza detail function
73:37 - from our index.ts file and I can show
73:41 - that this is working so I can say get
73:43 - pizza detail with the ID of one and
73:46 - we'll console log the result and sure
73:48 - enough we get our margarita pizza with
73:50 - the idea of one however Nothing is
73:51 - Stopping this Javascript file from doing
73:54 - something weird like saying get pizza
73:56 - detail false because it's JavaScript
73:59 - we're not going to get any compile time
74:01 - warnings here and so I can run the code
74:03 - and get the value of undefined which in
74:06 - all honesty our function is pretty okay
74:08 - with returning anyway but we could get a
74:10 - little bit better of a user or I guess
74:13 - not a user but another developer's
74:15 - experience can be improved if we're just
74:17 - a little bit more explicit here and we
74:19 - say something like if the type of
74:23 - identifier is equal to a number then we
74:26 - can run this code and then we could
74:28 - include another else that maybe throws a
74:30 - new type error that says the
74:34 - parameter identifier must be either a
74:38 - string or a number okay so let's hit
74:41 - save and now by trying to use false in
74:44 - get pizza detail we get our type error
74:47 - thrown so that the developer using a
74:49 - Javascript file can get a little bit
74:50 - more of an intentional feedback loop so
74:53 - long story short when you're writing
74:54 - your typescript code try to be as
74:56 - explicit as you can within
75:01 - reason staying on the theme of being
75:03 - explicit with your typescript code
75:05 - whenever you can I want to talk about
75:07 - function return types before we jump
75:10 - into that though I did want to note that
75:11 - we previously talked about composing
75:13 - together different object types but here
75:16 - we can see we have this type user and
75:18 - for the RO property of that user object
75:21 - we're using the user R type that we
75:24 - created up above so we can compose types
75:26 - together however we want it doesn't just
75:29 - have to be when we're talking about
75:30 - nested objects like we saw at the
75:32 - beginning of the course okay so here we
75:34 - have a users array and we have a
75:37 - function called Fetch user details which
75:39 - takes a parameter of username and sends
75:42 - back the user in its return value go
75:45 - ahead and hover your mouse over the name
75:47 - of this function fetch user details and
75:49 - you'll see that in the popup it says
75:51 - function fetch user details parentheses
75:54 - username colon string exactly what we
75:56 - have in the beginning of our function
75:58 - here in our code but then it says colon
76:01 - capital u user the colon that we put
76:04 - after the arguments of our function
76:06 - gives us a chance to specify what type
76:09 - of data should be returned from our
76:11 - function now typescript was able to
76:14 - infer that as we see it put a colon user
76:17 - there but in a lot of instances it can
76:19 - be really helpful to explicitly type
76:21 - what should be returned from your
76:23 - function so I would put a colon and this
76:26 - is between the arguments of my function
76:28 - and the opening curly brace and then I
76:30 - would just put capital u user here to
76:33 - teach typescript that this function
76:34 - should always return a user object so if
76:37 - it was able to infer that it's returning
76:40 - a user why is it helpful to explicitly
76:42 - put a capital u user here well one of
76:45 - the major reasons I think for doing this
76:47 - is that it helps whenever we're
76:48 - refactoring our code if myself or some
76:51 - other developer were to find this
76:53 - function and say I don't know why it's
76:55 - returning a user it should be returning
76:57 - the user. username instead well if they
76:59 - try to do that then they will get a
77:01 - warning from typescript saying that it's
77:03 - trying to return a string instead of
77:06 - explicitly a user object if I don't
77:08 - include this explicit typee declaration
77:11 - then typescript has no problem with me
77:13 - completely changing the return value of
77:15 - this function which assuming this
77:17 - function is used throughout my codebase
77:19 - would likely cause some other problems
77:21 - so this is an opportunity for us to be a
77:23 - little bit more explicit and to specify
77:26 - that we want this to be a user object
77:28 - that gets returned and if someone is
77:30 - going to change the return value of this
77:32 - function they would have to come up and
77:34 - explicitly change this to something like
77:36 - string and this would be the dot
77:38 - username which theoretically would be a
77:40 - prompt to that other developer or myself
77:43 - in the future to then go throughout my
77:44 - codebase and make changes every time
77:47 - we're calling this fetch user details
77:48 - function let's keep this returning a
77:50 - user for now okay it's been a minute
77:52 - since we've had a challenge so let's go
77:54 - back to the the pizza restaurant app and
77:55 - try your hand at a quick
78:00 - challenge we just talked about the
78:03 - typescript specific type called void and
78:05 - there are actually a few other
78:07 - typescript specific types that I think
78:10 - would be worth taking a little tangent
78:12 - to talk about at this time we'll start
78:14 - with a rather notorious type in
78:16 - typescript called any the easiest way to
78:19 - think about any is to know that if you
78:21 - type something with any you're
78:23 - essentially turning off typescript
78:24 - checking for that value so if I have a
78:28 - value and let's set it equal to one
78:30 - typescript is able to infer that this
78:32 - should be of type number you can hover
78:34 - your mouse over value to see that and it
78:37 - gives me warnings if I ever try to do
78:39 - something like reassign it to a string
78:41 - it tells me that you can't do that or if
78:44 - I try to run an operation on it like to
78:47 - uppercase which only works for Strings
78:50 - it tells me that you can't run this
78:51 - method on a number These Warnings of
78:53 - course as we've seen up until now are
78:55 - very useful to us but let's see what
78:57 - happens if I manually type this as an
78:59 - any type suddenly the warnings go away
79:02 - as I mentioned we've turned off
79:04 - typescript checking so I can tell value
79:06 - that it's going to be a string now I can
79:09 - try to call say an array method on it
79:12 - and typescript isn't going to warn me at
79:14 - all essentially it's a way to say in
79:15 - your code I know better than typescript
79:18 - how this thing should be typed and I
79:20 - don't want typescript to help me at all
79:22 - I think you can probably see maybe from
79:24 - my tone or just from the lack of
79:26 - warnings here that this is not a good
79:28 - idea so when really should you use any
79:31 - well in short you shouldn't it can be
79:32 - tempting when you're looking at your
79:34 - code that has a bunch of typescript
79:36 - Errors to just throw your hands in the
79:37 - air type things manually as any so that
79:40 - the warnings go away and then continue
79:42 - on with your code but in that case why
79:44 - did you choose typescript in the first
79:46 - place now that's not entirely fair I
79:48 - think there is at least one legitimate
79:50 - use case and I think that would be if
79:51 - you're in the process of transitioning
79:53 - your code base from JavaScript to
79:55 - typescript and you don't have the time
79:57 - right now to write all of the complex
80:00 - types and update all of your code to
80:02 - satisfy the typescript warnings and you
80:04 - just need a temporary that's the
80:06 - important part here temporary way to get
80:09 - around typescripts just for now but be
80:11 - warned as soon as you start adding any
80:14 - to your code base and the warnings go
80:16 - away it might be a bit difficult to go
80:18 - back and force yourself to bring those
80:20 - warnings back by removing the any types
80:22 - in fact it might be better if you just
80:24 - left the warnings there and turned off
80:26 - the configuration in typescript that
80:28 - forces you to satisfy the typescript
80:31 - warnings before your code will compile
80:33 - we're venturing into territory outside
80:34 - the scope of this course so if there's
80:37 - just one thing I want you to take away
80:38 - from this lesson just don't use any if
80:41 - you do have a scenario where there's a
80:42 - value where you legitimately don't know
80:44 - the type of it there's another
80:46 - typescript specific type that is much
80:48 - better suited for that scenario and it's
80:49 - called unknown that's what we're going
80:51 - to be looking at next
80:57 - okay we're going to do this in a couple
80:58 - parts the first part of your challenge
81:00 - is to add a return type to the get pizza
81:03 - detail function this should take you all
81:05 - of about 2 seconds to do but once you do
81:07 - it as it says in the note you are very
81:09 - likely going to get a giant typescript
81:11 - warning but don't worry about that we're
81:13 - going to address that in part two of The
81:15 - Challenge pause now and add a return
81:17 - type to our get pizza detail function
81:25 - simply enough we can come between where
81:28 - the closing parenthese is in our
81:30 - parameters and the opening curly brace
81:32 - we can just put a colon and say that
81:34 - this is supposed to return a pizza and
81:37 - look at that we get those giant
81:38 - typescript warnings and if we hover over
81:40 - it it tells us that type pizza or
81:43 - undefined is not assignable to type
81:45 - pizza now before I explain exactly
81:47 - what's going on here I want you to think
81:49 - about it try and figure out why is it
81:51 - saying that the type pizza or undefined
81:54 - is not assignable to type Pizza in fact
81:56 - if you want to pause to spend a little
81:58 - bit of time playing with the code or
81:59 - thinking about that go ahead and do so
82:04 - now we talked about this briefly when we
82:07 - first wrote this code but remember that
82:09 - menu. find potentially returns an
82:11 - undefined value if it's not able to find
82:14 - the pizza that you specified let me get
82:16 - rid of my explicit declaration here and
82:19 - for a kind of unrelated reason I need to
82:21 - get rid of my challenge text and now
82:23 - hover your mouth Mouse over get pizza
82:25 - detail and you'll see that it did infer
82:27 - what data type would get returned from
82:30 - this function it's either going to be
82:31 - pizza or undefined typescript was smart
82:34 - enough to read through the code and know
82:36 - that we are returning potentially an
82:38 - undefined value or rather a value of
82:40 - undefined inside of our code here and so
82:43 - it inferred the return value as either
82:45 - pizza or undefined this is where things
82:48 - can get a little bit hazy you may want
82:49 - to rewrite your code a little bit
82:51 - differently to either throw an error if
82:54 - it was able to find the pizza or you can
82:56 - just expect that whatever code is
82:58 - calling get pizza detail will handle the
83:00 - instance where it gets an undefined
83:02 - value returned but since this course
83:04 - isn't about how to architect this
83:06 - particular function we'll go ahead and
83:08 - do another really simple challenge okay
83:11 - again really easy but I want you to
83:13 - explicitly type the return value of this
83:15 - function so that typescript knows it
83:17 - could either be a pizza object or the
83:19 - value of undefined pause now and work on
83:22 - this challenge
83:28 - again simply enough we can just put a
83:31 - colon right here and say it's either
83:33 - going to be pizza or we will include the
83:35 - union of undefined like we saw before
83:38 - this doesn't necessarily change the way
83:41 - that the function works or the way that
83:42 - typescript sees the function but it does
83:45 - help us or other developers in the
83:47 - future know that when we're messing with
83:49 - this code and doing some kind of
83:51 - refactor we need to either make sure
83:53 - that we continue to return a pizza or a
83:56 - value of undefined or we need to
83:58 - explicitly change this value and then
84:00 - change our code everywhere else that's
84:02 - depending on get pizza detail either
84:04 - returning a pizza or undefined let's
84:06 - clean up the challenge text all right
84:08 - well we're not quite done talking about
84:10 - return types with functions so feel free
84:12 - to play with the code as always and when
84:14 - you're ready we'll keep moving
84:19 - forward there's another return type that
84:21 - isn't quite as obvious as something like
84:24 - pizza or undefined was down here and
84:26 - that is when you have a function that
84:28 - doesn't return anything look through the
84:30 - code on your screen here see if you can
84:32 - find a function that doesn't currently
84:33 - return
84:37 - anything hopefully you found this add
84:39 - new pizza function in fact if you hover
84:42 - your mouse over it you'll see that the
84:44 - inferred return type is called void this
84:47 - function modifies the menu by pushing
84:49 - new objects to it but then there's no
84:51 - return from it there's not going to be a
84:53 - value that we can get from it so one way
84:55 - we can be a bit more explicit almost
84:57 - like documenting our code in line is by
85:00 - explicitly typing this as returning void
85:02 - it doesn't change the way that the
85:04 - function operates if you try to save the
85:07 - return value from calling add new pizza
85:09 - you would get the value of undefined but
85:11 - it helps us or other developers in the
85:13 - future reviewing through this code to
85:15 - know that we knew this wouldn't return
85:17 - anything it's just performing an
85:18 - operation outside of itself and then not
85:21 - returning anything that's about all
85:23 - there is for me to say about void it's
85:25 - pretty straightforward but since that
85:26 - was pretty quick I want to give you a
85:28 - relatively unrelated
85:31 - challenge okay your challenge is to add
85:33 - explicit return types to the rest of our
85:35 - functions so really just the place order
85:38 - function and the complete order function
85:39 - pause now and work on this
85:46 - challenge a really easy way to do this
85:49 - is for us to hover our Mouse over the
85:51 - name of the function and see what
85:53 - typescript has already inferred is going
85:55 - to be the return type here we can see
85:57 - that it's either going to be an order
85:59 - type or undefined and if we go to
86:02 - complete order it's actually going to be
86:04 - the exact same thing order or undefined
86:07 - so really just getting our repetitions
86:09 - in with the muscle memory in typing
86:11 - these functions out okay nice work let's
86:13 - move
86:17 - on let's take some time to do a really
86:19 - simple refactor to our code and see how
86:22 - typescript helps us do that currently
86:24 - when we're creating the menu we are
86:25 - manually adding our IDs here with 1 2 3
86:29 - 4 and I brought the calls that we had
86:31 - down at the bottom up a little bit to
86:33 - add new pizza and we were manually doing
86:36 - IDs of 5 six and 7even let's go ahead
86:38 - and use the same trick that we're using
86:40 - with next order ID right here where when
86:43 - we are creating an order we are creating
86:45 - an object right here where we're using
86:47 - next order ID ++ if you run into any
86:50 - typescript errors make sure to hover
86:52 - your mouse over them and see if you can
86:54 - figure out how to fix them as a little
86:56 - peek into the future for now we will
86:58 - still keep the IDS here inside of our
87:01 - add new pizza call but my goal is to get
87:03 - us to a point where we can submit a
87:05 - partial Pizza object without the ID and
87:07 - have the function handle adding the ID
87:10 - for us but for now we'll skip that part
87:12 - pause now and work on the
87:18 - challenge so I might want to come here
87:21 - and say let's call it next Pizza ID and
87:26 - we'll start it off at 1 and then up here
87:28 - instead of one I can say next Pizza ID
87:31 - plus plus and check it out we're getting
87:33 - an error from typescript you probably
87:36 - already know what this is but if we
87:37 - hover over this it says the block scoped
87:40 - variable next Pizza ID is used before
87:43 - its declaration variable next Pizza ID
87:45 - is used before being assigned and yes it
87:47 - is down here on line 22 we are defining
87:50 - that and because of the way hoisting and
87:53 - everything happens in JavaScript this
87:55 - would actually need to be above where
87:57 - we're using it so let's just move all of
88:00 - these Global variable declarations up
88:02 - here to the top and then we should be
88:03 - fine typescript is already helping us
88:05 - out okay we'll do the same thing here
88:08 - and there and down here when we're
88:10 - adding new pizzas we will go ahead and
88:12 - do the same thing down here at the
88:15 - bottom I am still console logging the
88:17 - menu and then a couple other things that
88:19 - we actually don't care too much about
88:20 - right now okay so I'm adding three new
88:23 - pizzas down below I am still console
88:25 - logging the menu we'll comment these
88:27 - other ones out for now and let's open
88:29 - our console and hit save and perfect we
88:32 - have our menu with all seven items in it
88:34 - now let's address this issue where it
88:36 - seems a little strange that we are
88:38 - providing a pizza object but we are in
88:41 - charge of ensuring that the ID is being
88:44 - handled correctly it seems like the add
88:46 - new pizza function should be able to
88:48 - handle that for us so I want you to test
88:50 - that out I'm going to write this in as a
88:53 - challenge okay I'm calling this
88:54 - challenge part 1.5 because there's a
88:57 - topic in typescript we still have to
88:59 - learn in order to do this without
89:01 - typescript complaining at us so as
89:03 - you'll see in the note you're still
89:04 - going to run into typescript warnings
89:06 - that we are going to address soon but
89:08 - the code should still run if you do it
89:10 - correctly the goal is to make it so that
89:12 - we don't have to provide this ID
89:14 - property when we're adding a new pizza
89:15 - we just have to provide the information
89:17 - that's specific to the pizza and we can
89:19 - move the assigning of the next Pizza ID
89:22 - inside of the add new pizza function as
89:24 - an implementation detail of this
89:26 - function it's not really something that
89:28 - we should have to think about when we're
89:29 - adding a new pizza to our menu we really
89:31 - only want to provide the details that
89:33 - are specific to the pizza okay I think
89:35 - you should be ready pause now and work
89:37 - on this
89:43 - challenge okay well the pizza object
89:45 - that we are about to receive will be
89:48 - essentially the same as before but
89:50 - without an ID and so I'm going to before
89:53 - I push it to the menu we're going to say
89:56 - pizza object. ID is equal to next Pizza
90:00 - ID and then we'll use the plus plus
90:02 - trick to increment it to the next number
90:04 - so that the next time it runs it's
90:06 - already changed and then this is where
90:08 - typescript is going to yell at me I'm
90:10 - going to get rid of these ID properties
90:12 - in the objects that I'm passing and sure
90:14 - enough typescript is screaming at me
90:16 - here it says that I'm missing a property
90:18 - in the pizza object and I'm typing this
90:20 - as a pizza object but let's go ahead and
90:22 - hit save and we open up our console and
90:25 - sure enough we get the same results that
90:26 - we had before we have the seven pizzas
90:28 - in our menu and they have an
90:30 - incrementing ID just as we would expect
90:32 - okay next let's address why typescript
90:34 - is screaming at us and how we can fix
90:39 - it in this lesson we're going to talk
90:42 - about something called utility types but
90:44 - in order to set this up I'm going to
90:46 - have just a really quick challenge for
90:47 - you you can see here we have a user type
90:50 - this is something we've seen before we
90:52 - have an array of users that are typed as
90:54 - an array of users and your task is to
90:57 - create this update user function and
90:59 - what it should do is take a number ID as
91:02 - its first parameter and the second
91:03 - parameter is an object that we're
91:05 - calling updates and this object will not
91:08 - be a full user object it's going to only
91:11 - contain the properties that you want to
91:13 - change I've explicitly typed these as
91:16 - any just so that for now we can turn off
91:18 - typescript then we're going to learn
91:20 - about utility types so that we can type
91:22 - these the correct way and actually you
91:24 - know what just to follow my own advice
91:26 - this should be typed as a number because
91:28 - that's not really what we're going to be
91:29 - talking about in utility types now I've
91:31 - given you the instructions on how to do
91:33 - this this is intended less to be about
91:36 - doing algorithmic thinking and more to
91:38 - just get your hands on the keyboard and
91:39 - make sure that you're staying active in
91:41 - this course so you'll simply use the
91:43 - array. find method to get the correct
91:45 - one based on its ID then you'll use
91:47 - object. assign so that you can update
91:49 - the found user just right there in place
91:52 - if you aren't familiar with object. sign
91:54 - or you're a little bit resy on it you
91:55 - can do a quick Google search to find how
91:58 - to use it okay pause now and work on
91:59 - this
92:06 - challenge okay let's go to we'll say
92:09 - users. find and this is going to return
92:12 - a user we'll call it found user and this
92:15 - will take a function a callback function
92:17 - will say for every user that we're
92:19 - looking through we want to find the one
92:22 - that has the user ID that's equal to the
92:25 - ID that's passed in here in the update
92:27 - user function okay we can move this
92:30 - comment up there let's go ahead and
92:32 - handle the scenario if there is no user
92:34 - so if there's not a user and this should
92:37 - be a found user let's just put something
92:40 - in the console we'll say user not found
92:43 - and then we'll make sure to return so
92:45 - the rest of the code can't run okay and
92:47 - then we'll use object. assign this will
92:49 - just change the object directly in place
92:52 - this may or may not be the best way to
92:54 - handle it but it's the most
92:55 - straightforward way so we'll set the
92:57 - found user as the starting object and
92:59 - then we'll replace any of the properties
93:02 - that are found in this updates object we
93:04 - can get rid of this comment and yeah
93:07 - we're console logging users down here
93:08 - let's run this code and let's see we're
93:10 - specifically looking for the user with
93:12 - the ID of one and sure enough the
93:14 - username is now new John do and the last
93:16 - one with the username of Charlie Brown
93:18 - does have the role of contributor
93:20 - instead of member perfect okay why are
93:22 - we talking about this well obviously as
93:25 - I've mentioned we shouldn't be using the
93:26 - any type here however we're not able to
93:29 - use user as our type here because we're
93:32 - not providing a full user object it's
93:34 - also important to know that because we
93:36 - don't know which property is going to be
93:38 - passed to this function or potentially
93:40 - multiple properties we can't come up and
93:42 - just create a new type like an updated
93:45 - user because what exactly are we going
93:48 - to put here we could say that it's going
93:50 - to be a username that's a string but
93:52 - then what are we going to do if it's a
93:53 - Ro change instead well you might be
93:55 - thinking well what if we just take every
93:57 - property from user and we make it
93:59 - optional so we say I don't know maybe
94:01 - there's a way that we'd ever want to
94:03 - update an ID we'll say well the ID could
94:05 - be a number and we'll put the question
94:06 - mark here to say that that's an optional
94:08 - update and we might have a username so
94:11 - we'll set that as optional and we'll say
94:13 - that's going to also be a string and you
94:15 - know what this is pretty much a lot of
94:16 - duplicated stuff so I'll just go ahead
94:18 - copy this one down put a question mark
94:20 - there okay great well we've done quite a
94:22 - bit of extra work here we would then be
94:24 - able to say this isn't going to be a
94:26 - user it's going to be an updated user
94:28 - now we come down and we can see that
94:30 - typescript is no longer complaining not
94:32 - only that but we run our code and things
94:34 - are working like they were before well
94:36 - this was a lot of busy work imagine if
94:38 - we had a type that had 15 properties on
94:41 - it that'll be a bit annoying to have to
94:43 - copy those over and just make everything
94:45 - optional and at least as far as this
94:47 - code is concerned we're only using this
94:49 - type in one place right here for our
94:51 - update user function so this is where
94:53 - the ccept of built-in utility types
94:55 - comes from in typescript there are a
94:58 - number of types that like a function
95:00 - they can take other types in as a
95:02 - parameter and they will return a new
95:04 - type that you can use with a few changes
95:06 - made to it and these are things that are
95:08 - built directly into typescript their
95:10 - whole goal is to perform some commonly
95:12 - needed modifications to existing types
95:15 - so that you can continue to work within
95:16 - the typescript system kind of like we
95:18 - did here instead of creating updated
95:20 - user manually by copying all of the
95:22 - properties and then making them optional
95:25 - we can use a utility type to accomplish
95:27 - this we're going to talk about that in
95:28 - just a second the other thing to know
95:30 - about utility types is that they use
95:32 - something called generic syntax which
95:34 - uses angle brackets now this is just
95:36 - touching the surface of that we are
95:37 - going to talk about generics very soon
95:39 - in our case here with the update user
95:41 - function we can use a built-in utility
95:43 - type called partial and what the partial
95:46 - type does is it takes in the type that
95:48 - you pass to it in our case we want to
95:50 - make a modification to our user type
95:52 - that we built and it returns turns a new
95:54 - type that has all of the properties set
95:56 - as optional that should sound familiar
95:58 - cuz that's exactly what we just did
95:59 - manually if you want to learn more about
96:01 - the partial type click on the screenshot
96:02 - here this will take you to the
96:04 - typescript documentation specifically on
96:06 - the partial type okay what does that
96:08 - look like well instead of manually
96:10 - typing this out I'm going to use the
96:13 - built-in type called partial it's got a
96:15 - capital P and I use that angle bracket
96:18 - syntax that we saw right here because
96:20 - this partial uses something called
96:22 - generics again we're going to talk about
96:24 - that in the future but you can kind of
96:26 - think of it like if partial were a
96:28 - function you would normally put
96:29 - parentheses but because it's a utility
96:31 - type and not a function we use angle
96:33 - brackets instead and we pass our user
96:36 - type in as a you could call it a
96:38 - parameter or in this case it's really a
96:40 - generic type to this partial and as we
96:43 - saw what it does is it takes this user
96:45 - in and it returns a new type which we're
96:47 - calling updated user and if you go ahead
96:49 - and hover your mouse here over updated
96:51 - user you will see that it has a type
96:54 - already defined for us where all of the
96:56 - properties ID username and role are set
96:59 - as optional this way when our update
97:01 - user function takes an updates object
97:03 - and its type is updated user we can
97:05 - provide an object that is missing some
97:07 - of the properties from a user object
97:09 - we've used this partial utility type to
97:12 - minimize some of the boilerplate code
97:13 - that we would have had to write manually
97:15 - ourselves if you take the time to go
97:17 - over to the documentation by clicking
97:19 - the screenshot you will see that there
97:21 - are a ton of built-in utility types tyes
97:23 - in typescript and so this might be a
97:25 - good time to click this if you didn't
97:27 - already just peruse those play around
97:29 - with the code that you see here feel
97:31 - free to come up with different examples
97:33 - we are going to talk about one other
97:34 - utility type because it's going to
97:36 - directly relate to what we're working on
97:38 - with the pizza restaurant app but there
97:40 - is a small caveat that we'll need to
97:42 - work around we'll talk about that in the
97:43 - next
97:47 - lesson this lesson's going to be nearly
97:50 - identical to the one we had before but
97:52 - as another way to to drive forward the
97:54 - curriculum in learning a new utility
97:56 - type to start off to make sure your
97:58 - hands are on the keyboard and that
97:59 - you're awake as you're going through
98:01 - this course I'm going to have you create
98:03 - the logic for a new add new user
98:05 - function it's going to take a new user
98:07 - object and in this case the new user
98:10 - object will not have an ID provided to
98:12 - it as you can see in the example usage
98:14 - down here it will have all of the
98:16 - properties except for ID so for now I've
98:19 - typed this as any and the return for
98:21 - this function needs to return an actual
98:23 - user object that does have an ID read
98:25 - through the comments here to see the
98:26 - specifics on how to create that it
98:28 - basically tells you exactly what to do
98:30 - and when you're done the typescript
98:32 - errors should go away but then we'll
98:33 - address this issue with having an any
98:35 - type here also for Simplicity I've added
98:37 - this next user ID variable and added it
98:40 - to our users array just so that you can
98:42 - continue to use next user ID Plus+ like
98:45 - we were doing in the Pizza app and I've
98:47 - also shortened this users array just so
98:49 - that there's not quite as much clutter
98:51 - when we're console logging the array of
98:52 - users okay you should be set up pause
98:54 - now and work on this
99:01 - challenge we can pretty much just follow
99:03 - these steps exactly as they're said so
99:06 - we'll call a new variable user and I'm
99:08 - actually going to type this as a capital
99:11 - u user the goal is to make sure that it
99:13 - conforms to the user object type okay
99:16 - this is going to be an object and the
99:18 - first thing I'll do is add an ID
99:19 - property to it we'll use the next user
99:22 - ID Plus+ to get that in there and then
99:25 - I'm just going to spread all of the
99:26 - properties of new user into this object
99:30 - now that I have a new user object or a
99:32 - user object that is new let's go ahead
99:34 - and push it to the array of users we'll
99:37 - say this is users. push user and return
99:41 - the user objects okay now the typescript
99:43 - warning under user is gone because now
99:45 - this function is returning a user as the
99:47 - type would indicate it's supposed to
99:49 - let's clear out the comments here and do
99:52 - just a quick test we're pushing Joe
99:53 - Schmo who is a role of member and sure
99:56 - enough there he is at the end of our
99:58 - users array with I might add the ID of
100:01 - three which is what we wanted this might
100:02 - be a good time to remind everybody
100:04 - watching this that this whole next user
100:06 - ID thing that we're doing it's really
100:08 - just to drive our curriculum forward
100:10 - you're very likely to have your database
100:12 - handling the whole ID assigning thing
100:15 - okay now let's address this any type
100:17 - here we don't really want this to be in
100:19 - any type because as it currently stands
100:21 - we've disabled typescript checking for
100:23 - this and I could just add a blah blah
100:26 - category or property to this object and
100:28 - typescripts not going to warn us that
100:30 - this isn't going to work or rather that
100:32 - it could really screw up our code so
100:34 - what exactly can we do well we just
100:36 - learned about the partial type and it
100:37 - might seem at first glance that we could
100:39 - make this into a partial of user however
100:42 - the problem with the logic here is we
100:44 - want to make sure that all of the
100:45 - properties exist and with partial it
100:48 - turns everything into an optional
100:50 - property let me get rid of this blob
100:52 - property here if I submit this as a
100:54 - partial like this of user and then for
100:58 - some reason I don't Supply one of the
101:00 - properties here I have a problem I've
101:02 - taught this function that it's going to
101:03 - return a full user and as you saw even
101:06 - before I deleted the RO property here we
101:08 - have a warning and it essentially tells
101:10 - us that these are not going to be
101:12 - compatible that's because we need to
101:14 - return a user and our user property
101:16 - needs to have up here it's not optional
101:19 - to have an ID a username and a role but
101:22 - our partial user type here it is
101:24 - possible to not have one of those things
101:26 - because all of the properties are
101:28 - optional okay so partial is not really
101:30 - going to work for us there is a way
101:32 - clearly that we could make partial work
101:34 - but we would have to do a bunch of extra
101:36 - checking inside of the body of our
101:38 - function and that's not really the road
101:40 - that I want to go down enter the omit
101:42 - type what does the omit type do well it
101:45 - takes in a type just like partial but it
101:47 - also takes you could call it a second
101:49 - parameter to that utility type which
101:51 - will be a string or potentially a union
101:54 - of strings we'll see what I'm talking
101:55 - about in just a second and those strings
101:57 - are the property names that we want to
101:59 - Omit from this type it's going to return
102:02 - a brand new type with the properties
102:04 - that we specified removed it would
102:06 - probably be a great idea to go to the
102:08 - documentation on the typescript docs you
102:10 - can click the screenshot that you see
102:12 - here which should take you directly to
102:13 - the omit type docs so what does this
102:16 - look like for us well often times
102:18 - especially if you're only going to be
102:20 - using this utility type once in your
102:22 - code you can just do it right in line so
102:24 - I can use capital O omit a set of angle
102:27 - brackets and I first need to provide as
102:29 - the first parameter you could say the
102:31 - user type or the type that I'm trying to
102:33 - modify and then just like in function
102:35 - parameters I'm going to add a second
102:37 - parameter here and that is going to be a
102:39 - string of the properties that I want to
102:41 - Omit from the user type so that the type
102:44 - that omit returns will not have the ID
102:47 - property in it okay why is typescript
102:49 - warning us about capital O omit well we
102:52 - come to another point of some irony the
102:54 - omit utility type is currently omitted
102:57 - by scrimba well more specifically in
102:59 - reality it's just that omit was
103:01 - introduced in typescript version 3.5
103:03 - scrimba is currently running on an older
103:05 - version that doesn't yet know what omit
103:07 - is in the future I'm going to be able to
103:09 - remove this whole caveat but for now I'm
103:11 - just going to show you a screenshot of
103:13 - what it should look like so we have our
103:15 - code exactly like we see here and notice
103:17 - that typescript is not warning us about
103:19 - anything I guess as a reminder
103:21 - typescript doesn't stop us from running
103:23 - running our code there are ways to set
103:24 - it up to do so but I can hit save I can
103:26 - open my console we can see that our joeo
103:29 - user has been successfully added to our
103:31 - array but let's look at what it's
103:33 - supposed to look like if I were to for
103:35 - example comment out the ID property we
103:37 - can see that we have an error on the
103:39 - user object if we hover our Mouse over
103:41 - it we can see that the property ID is
103:44 - missing that's exactly what we would
103:46 - expect now I don't have a screenshot of
103:48 - this but if we were to take away one of
103:50 - the properties when we're calling add
103:51 - new user we would also get a typescript
103:53 - warning that tells us that we're not
103:55 - providing the correct type to our add
103:57 - new user function it's going to have all
103:59 - of the properties of user just minus the
104:02 - ID property that way our function can be
104:04 - in charge of creating the ID for our
104:06 - user object really quick I did mention
104:09 - that you can provide either a single
104:11 - string or a union of strings if for some
104:13 - reason I wanted to Omit both the ID and
104:16 - the username I would use a union
104:19 - character which is the single pipe and I
104:21 - would do another string literal of user
104:23 - which tells it that I don't want this
104:25 - new type that omit is creating to
104:27 - contain either the ID or the user in our
104:30 - case that means it would just be an
104:32 - object with a ro property again
104:35 - typescript would be warning us here but
104:37 - because it's not currently recognized by
104:39 - scrimba it's not giving me any other
104:40 - warnings okay it's time for us to get
104:42 - back to our Pizza app and apply what
104:44 - we've learned specifically about omit so
104:47 - that's what we'll do
104:51 - next let's apply what we just learned
104:53 - about omit to our pizza restaurant app
104:56 - specifically the add new pizza function
104:58 - your task is to fix it so that we use
105:00 - the omit utility type just like we did
105:02 - in the previous lesson we want the user
105:04 - of this function to provide a pizza
105:06 - object that does have a name and a price
105:09 - we don't want those to be optional
105:10 - because we need that information in our
105:12 - menu but the add new pizza function will
105:14 - be in charge of adding the ID to it
105:17 - while we're at it let's go ahead and
105:18 - change this function so that it Returns
105:20 - the new pizza object instead of void I'm
105:23 - just going to add that here to the
105:25 - requirements okay so make sure that you
105:27 - return the new pizza object with the ID
105:29 - added from the function which means
105:31 - you'll have to change the types here as
105:32 - well as a quick reminder at the time of
105:34 - recording this the scribit environment
105:36 - doesn't understand the omit utility type
105:38 - so you will get a little red squiggly
105:40 - under the word omit but you can safely
105:42 - ignore that and essentially any other
105:44 - typescript warnings you see here in the
105:46 - very near future scribo will know about
105:48 - omit so I'll be able to just remove this
105:50 - caveat the time is yours pause now and
105:53 - on this
105:58 - challenge again the reason we want to
106:01 - use omit and not partial is because we
106:03 - want to require that the person submit a
106:06 - pizza object with all of the other
106:08 - information except for this one property
106:11 - of course with omit you can omit more
106:13 - than one property but in our case we
106:15 - just want to Omit from the pizza type we
106:18 - want to omit the ID property like that
106:21 - and while we're up on this line we
106:23 - decided we're going to return a full
106:25 - Pizza object from this function
106:27 - currently we're not doing that so
106:28 - typescript is warning us now we have an
106:31 - issue with the way that our code
106:32 - currently is set up because we just told
106:34 - typescript that this pizza object will
106:37 - have all of the properties of pizza but
106:39 - not the ID property in other words it's
106:41 - going to have a name and a price and
106:44 - then we're trying to add an ID property
106:46 - on top of it well we can't do that so
106:48 - let's go ahead and create a new pizza
106:50 - object we'll call this new pizza we're
106:52 - going to to type it as a full Pizza
106:54 - object and we'll set it equal to an
106:57 - object we'll give it an ID property
106:59 - we'll use the next Pizza ID and then add
107:02 - the Plus+ for the next time around and
107:04 - then we'll spread in all of the
107:06 - properties of pizza object we'll get rid
107:08 - of this line of code and instead of
107:11 - pushing Pizza object we will push new
107:13 - pizza I can hardly believe how many
107:16 - times I've said the word pizza and then
107:18 - as we described up above we need to make
107:20 - sure we return the new pizza object
107:23 - let's hit save and we are adding a few
107:25 - new pizzas up here we're console logging
107:27 - the menu and sure enough we have the
107:29 - chicken bacon ranch the barbecue chicken
107:31 - and the spicy sausage pizzas added for
107:33 - the time being while scrimba doesn't
107:35 - understand the omit utility type I have
107:38 - a couple screenshots here so this is
107:39 - from VSS code we can see when we add the
107:42 - omit Pizza type up above typescript is
107:44 - happy with everything the exact way that
107:46 - it is if we comment out ID then
107:49 - typescript isn't happy if you hover over
107:51 - new pizza it tells you that you're not
107:52 - allowed to push this object to the menu
107:55 - because menu requires Pizza objects and
107:57 - this object that you're trying to push
107:59 - does not have an ID so let's go ahead
108:01 - and put that back in similarly if we
108:03 - were to come down and say remove the
108:05 - price from this first pizza that we're
108:07 - adding we get a typescript warning that
108:09 - is a little bit cluttered here but
108:11 - essentially tells you that the property
108:13 - price is missing now for the sake of
108:15 - this course I've decided that it isn't
108:17 - my objective to teach every single
108:19 - utility type that exists because the
108:21 - documentation is very straightforward if
108:23 - you want to peruse and see the different
108:25 - types that there are again you can click
108:27 - this link this will specifically take
108:29 - you to the omit type but it's all one
108:31 - long page in the typescript docks so you
108:33 - can scroll around and see all of the
108:34 - different types there but hopefully the
108:36 - idea is starting to be clear these
108:38 - utility types perform really common
108:40 - operations on your existing types so
108:42 - that you don't have to do this work by
108:44 - yourself and introduce a bunch of
108:46 - repetitive code now I did promise
108:48 - earlier that we would address this issue
108:50 - here where we have these angle brackets
108:52 - and I think this would be as good a time
108:54 - as any to jump into that which is a
108:56 - topic called generics so that's what
108:57 - we'll be learning about
109:02 - next I've mentioned this term generics a
109:05 - couple times throughout this course and
109:06 - so it's finally time for us to learn
109:08 - what generics are generics and
109:10 - typescript are a really powerful tool
109:12 - that allow us to add some flexibility to
109:15 - the types of our existing functions are
109:18 - already existing types and other aspects
109:20 - of typescript code you can kind of think
109:23 - of it like a function parameter a
109:24 - function parameter is a placeholder for
109:26 - a real value that you use throughout
109:28 - your function and a generic is a
109:31 - placeholder for a type that you can use
109:33 - throughout your function or whatever
109:35 - aspect of typescript you're using your
109:37 - genericon this will make a lot more
109:39 - sense when we see an example and
109:40 - generics use this bracket syntax with
109:42 - the angle brackets that we've seen a few
109:44 - times already in our code let's see a
109:46 - bit of a contrived example here and then
109:48 - we'll apply what we've learned to our
109:50 - pizza restaurant app let's say we have a
109:52 - few different arrays like we have on
109:54 - lines 1 2 and 3 and we want to create a
109:56 - really simple utility function that's
109:58 - called get last item it takes an array
110:00 - as a parameter and since this isn't
110:02 - really part of this challenge I'm just
110:04 - going to say in order to access the last
110:06 - item of an array in JavaScript we can
110:08 - just return the array at the index of
110:11 - array. length
110:13 - minus1 Okay we can see there's a red
110:15 - squiggly here for array hover your mouse
110:17 - over the word array and you'll see that
110:19 - it says the parameter array implicitly
110:22 - has an any type typescript doesn't like
110:24 - when we have implicit any types and so
110:26 - one cheater solution could be to
110:28 - explicitly type this as an any type and
110:30 - of course that makes the typescript
110:32 - warning go away but again that's because
110:34 - the any type basically turns off
110:36 - typescript this isn't exactly what we
110:38 - want the problem is we can't say that
110:40 - this is an array of strings or an array
110:43 - of numbers because we don't know that it
110:46 - could be an array of any item okay well
110:49 - what are we to do then this is where
110:51 - generics come in into play as I
110:53 - mentioned just like a function has
110:55 - parameters that are placeholders for
110:57 - values generics are a way for us to have
111:00 - placeholders for whatever a type is
111:02 - going to be okay let's check out the
111:04 - Syntax for generics when we're using it
111:06 - in a function like we're doing here
111:08 - right before our parentheses with our
111:10 - function parameters we're going to put
111:12 - in our angle brackets and inside those
111:15 - angle brackets similar to how we're
111:16 - doing with the function parameters
111:18 - inside the parenthesis we're going to
111:20 - put a placeholder for whatever type is
111:22 - going going to be used with this
111:23 - function a fairly strong convention for
111:26 - this is to use the capital letter T to
111:28 - represent type but just to make sure
111:30 - that we're being explicit I'm going to
111:31 - use the full word type with a capital T
111:34 - again this is a placeholder type the
111:36 - capital T type here is not referring to
111:39 - something that's built into typescript
111:40 - this is a name that I chose I could have
111:43 - just as easily chosen blah blah blah but
111:45 - let's not do that okay well what can I
111:48 - do with this now well just like in a
111:50 - function I can use the parameter through
111:52 - throughout the code to represent
111:54 - whatever value array represents when
111:56 - this function gets called I can use my
111:58 - generic type here to say the array is
112:01 - going to be of type capital T type and
112:04 - it's going to be an array of that type
112:07 - we've used the word type quite a bit
112:09 - here I think it actually might be useful
112:11 - for us to call this something totally
112:13 - different like let's call it placeholder
112:15 - and actually I'm going to call it
112:16 - placeholder type because truly it
112:18 - doesn't matter what it is just like the
112:20 - name of your variable doesn't matter
112:23 - what it is you can call it whatever you
112:25 - want as long as you're consistent
112:26 - throughout your code okay great let's
112:28 - get your hands on the keyboard this is
112:29 - going to be very simple with more like a
112:32 - mini challenge than anything this mini
112:34 - challenge is less about solving the
112:36 - issue and more about seeing what the
112:38 - intellisense popups are when you hover
112:40 - over the different values so call get
112:42 - last item on each of the three arrays
112:45 - that we have on lines 1 2 and 3 you'll
112:47 - probably want to console log The
112:49 - Returned value just so that something
112:50 - shows up in your console and then the
112:52 - main thing I want you to focus on is
112:53 - hovering your mouse over different
112:55 - values in the code just to see what the
112:57 - intellisense popup shows so that you can
112:59 - get a better idea of what's going on
113:00 - with generics pause now and work on this
113:02 - mini
113:08 - challenge okay so let's get our console
113:12 - logs in here we'll just do three of them
113:14 - I'm going to use multiple cursors to
113:16 - save some time we'll call get last item
113:18 - and then we will put in our three
113:21 - different raise okay we'll hit save just
113:24 - to make sure that's working the way we
113:26 - expect great we don't actually need to
113:28 - see the values right now but let's hover
113:29 - our Mouse over maybe game scores first
113:32 - okay we can see that it is typed as an
113:34 - array of numbers that's a type that was
113:36 - inferred by typescript because of course
113:38 - we didn't explicitly type it as an array
113:40 - of numbers we can see the same thing
113:42 - with favorite things it's an array of
113:44 - strings and with voters it's an array of
113:46 - object literals okay now let's hover
113:48 - over get last item for this first call
113:50 - with game scores it shows that that it's
113:52 - a function called get less item and as
113:54 - its type inside of the angle brackets it
113:57 - shows number and then it used that
113:59 - number type to infer that array the
114:02 - parameter array is an array of numbers
114:04 - it also inferred that it's going to be
114:06 - returning a number as well which we
114:08 - didn't explicitly place here we'll do
114:10 - that in just a second but if we hover
114:11 - over this second get last item we'll see
114:13 - it does the same thing but with strings
114:15 - and on the third one it does the same
114:17 - thing but with that object literal with
114:19 - a name property and an age property
114:21 - doing this allows us to write types and
114:23 - in this case functions that can be a lot
114:26 - more flexible and still have some type
114:28 - safety without us using that any type
114:30 - which just turns type safety off
114:32 - completely now this is bothering me a
114:34 - little bit that it says placeholder type
114:36 - I'm going to go back to say type and
114:39 - again a really strong convention is just
114:41 - to use the letter T and other single
114:43 - letter variables which is kind of funny
114:45 - now that I think about it because we
114:46 - tend to tell people not to use single
114:49 - letter variables for things if you want
114:51 - to dive a little bit deeper into
114:53 - generics there is quite a bit more than
114:55 - what we covered in this lesson and
114:57 - frankly more than we're going to cover
114:59 - in this introduction to typescript
115:00 - course but you can click on the
115:01 - screenshot here to go directly to the
115:03 - typescript docs and it will show you
115:05 - some additional examples there that
115:07 - might help solidify the concept in your
115:09 - mind okay now I mentioned that if you
115:11 - hover your mouse here it says that it
115:12 - inferred the return type as a number but
115:15 - we can also do that explicitly however I
115:17 - want this to be a challenge even though
115:19 - I haven't really taught it to you yet
115:21 - this will hearken back to when we talked
115:23 - about explicitly typing function return
115:25 - values but with a little extra twist as
115:28 - we are using generics as our type pause
115:30 - now and see if you can figure out how to
115:32 - explicitly type the return value of this
115:39 - function in any other kind of function
115:42 - we put a colon after the parentheses of
115:45 - our function definition and we specify
115:47 - that this for example would be a number
115:49 - or something like that in our case
115:51 - though because our function needs to be
115:52 - more generic than just using numbers we
115:55 - can use that placeholder type generic
115:57 - type here as our return value it's going
116:00 - to be a single item of whatever type
116:03 - this function is currently using when
116:04 - it's being called now if we're really
116:06 - covering our bases we might also want to
116:08 - ensure that we know this could
116:10 - potentially be undefined as long as we
116:12 - spell undefined correctly and that might
116:14 - happen if we have an array of length
116:16 - zero all right nice work let's move on
116:18 - to the pizza restaurant app and see how
116:21 - we might apply something like this to
116:22 - that
116:26 - app the challenge that we're going to do
116:28 - in this lesson is purely going to be for
116:31 - practices sake I had to make a few
116:33 - changes to other parts of our code so
116:34 - that this very generic add to array
116:37 - function would work for our purposes in
116:39 - learning generics so once we've
116:41 - completed this challenge we're going to
116:43 - revert back to the old code we can just
116:45 - think of it as a refactor that's gone
116:47 - wrong I know the Syntax for generics can
116:49 - be quite a bit confusing so I wanted to
116:51 - make sure you got your hands on the
116:52 - keyboard again to type this out your
116:54 - challenge is to add types to this add to
116:57 - array function as you can see from the
116:59 - example usage it's essentially replacing
117:01 - what we had before with add new pizza
117:03 - and place order this is primarily where
117:05 - I made the changes to our old code which
117:07 - was using the omit utility type now
117:10 - we're just going to call add to array
117:12 - we'll provide the array that we want to
117:14 - add to and then the object that we want
117:16 - to add to that array once you've added
117:18 - the generic types to this function the
117:20 - red squigglies under array and item
117:22 - should go away and you should be able to
117:24 - console log our menu and our order queue
117:26 - and see these new items added to those
117:28 - and actually that reminds me I'm going
117:30 - to get rid of these so we don't have any
117:32 - duplicates and yeah okay pause now and
117:34 - work on this
117:40 - challenge when we're adding generics to
117:43 - a function right before the parenthesis
117:45 - we will add our angle brackets and we'll
117:47 - put our generic type this time I am
117:49 - going to use the single letter T because
117:51 - that does tend to be a pretty strong
117:52 - convention that you'll see with our
117:54 - array we're going to assume that it is
117:56 - an array of type T whatever that is in
117:59 - our case it's either going to be a pizza
118:01 - object type or an order object type
118:03 - which we have right up here at the top
118:05 - and item is going to be a single item of
118:08 - that same type maybe you can see why I'm
118:11 - saying this gets a bit confusing because
118:13 - we have a bunch of new characters that
118:14 - usually we don't see in the middle of
118:16 - JavaScript functions and here we can see
118:18 - the code says we're returning an array I
118:20 - suppose that will just be the new array
118:23 - after it's been modified and so if we
118:25 - hover over add to array we can see that
118:27 - typescript is already inferring what it
118:29 - will return but if we want to be
118:31 - explicit we can say it's going to return
118:33 - an array of type T let's go ahead and
118:36 - console log our menu and we'll do the
118:39 - same thing for the order que and let's
118:41 - see what shows up okay it's a little
118:43 - hard to parse but the first one that
118:45 - shows up in the console shows that
118:47 - chicken bacon ranch was added as an
118:49 - option on our menu and our order CU has
118:51 - just one item in it that is the one with
118:54 - the pizza from the menu at index 2 let's
118:57 - see that is our Hawaiian perfect we can
118:59 - see that the generic add to array
119:01 - function is correctly passing this type
119:03 - on if we do something like trying to add
119:06 - another random property to this we will
119:09 - get warned and it says that the object
119:11 - literal can only specify known
119:12 - properties and the property blah does
119:14 - not exist in the type pizza now one
119:17 - thing before we move on I do want to
119:18 - point out a little bit of a shortcoming
119:20 - when it comes to using our fun functions
119:22 - that are using generics these example
119:24 - usages seem to be working fine but if
119:27 - you remember on our order type which we
119:30 - have up here the status is only allowed
119:32 - to be the string ordered or completed
119:35 - but check this out if I come and I
119:36 - change the status see right here to
119:39 - something like done well typescript
119:41 - isn't complaining the reason it's not
119:43 - complaining is pretty easy to understand
119:46 - so we'll touch on it and fix this
119:47 - problem really quickly in the next
119:49 - lesson
119:53 - we have a small bug in our code and
119:55 - typescript is not warning us about it
119:57 - that's where we added our status of done
119:59 - even though done is not supposed to be a
120:02 - valid status for order types so what
120:04 - exactly is going on here well when we
120:06 - defined our generic function and we told
120:09 - it it was going to have generic types
120:11 - that it needed to use as the type
120:13 - throughout the rest of the code for this
120:15 - function when we're calling add to array
120:18 - both here and here we are assuming that
120:20 - typescript is going to be bble to
120:22 - implicitly infer what type it needs to
120:25 - use as its generic type if you hover
120:27 - over add to array right here on line 49
120:30 - we can see that it says the generic type
120:33 - that it's going to take is an object
120:35 - literal with an ID that's a number a
120:37 - name that's a string a price that's a
120:38 - number and a bunch of other things that
120:40 - shows what the menu is typed as and
120:42 - everything like that let's do the same
120:43 - thing for the add to array on the order
120:45 - queue again make sure you're following
120:47 - along and hovering your mouse over this
120:49 - otherwise what I'm about to say will
120:50 - make absolutely no sense the
120:52 - intellisense popups shows that it's a
120:54 - function called add to array its type is
120:56 - an object with an ID number a pizza that
120:59 - is a pizza object type and a status
121:02 - that's a string interesting our status
121:05 - is a string but it's supposed to be the
121:07 - union of just these two literal strings
121:10 - and that doesn't seem to have come
121:11 - through when we're calling add to array
121:13 - with the order Q this is another case
121:15 - where it can be really helpful for us to
121:17 - explicitly type what the generic type
121:20 - we're passing into this function is to
121:22 - do that we essentially follow the same
121:24 - syntax that we had when we were defining
121:26 - the function right before the
121:28 - parentheses where we provide the
121:30 - parameters for this add to array
121:32 - function we can explicitly type it with
121:34 - the same generic syntax of angle
121:36 - brackets now this is where things can
121:38 - get a little tricky if this has been a
121:40 - bit of a challenge for you to understand
121:41 - so let's make this into a mini challenge
121:43 - just to help solidify it okay the mini
121:46 - challenge is to figure out what should
121:48 - be typed right here between the angle
121:50 - brackets as the generic type here here
121:52 - on line 53 pause now enter in the type
121:54 - you think should be put here between the
121:56 - angle brackets and when you do so the
121:58 - red squiggly should limit itself just to
122:00 - the object here at the end because done
122:03 - is not a correct property pause now and
122:05 - give that a
122:10 - try because in this version of add to
122:13 - array we are dealing with orders in the
122:15 - order CU we have a predefined capital O
122:18 - order object and when we add that in now
122:20 - typescript seems to be able to
122:23 - understand that something is not quite
122:24 - right with this object if we hover over
122:26 - add to array now instead of having an
122:29 - object literal as everything it has
122:31 - explicitly typed it as orders arrays of
122:33 - orders and so forth and if we hover over
122:36 - here we can see that the pop-up tells us
122:38 - the types of property status are
122:40 - incompatible specifically done is not
122:42 - allowed here it needs to be something
122:44 - like completed once we change it to that
122:46 - awesome everything is working and
122:48 - typescript is happy in fact if you typed
122:50 - this out yourself you you could start to
122:52 - see and this isn't going to be in the
122:54 - recording but if you pause it and start
122:55 - typing the word completed it does show
122:57 - up as an autocomplete option because
122:59 - typescript allows us to have these
123:01 - autocomplete options I can just hit
123:02 - enter and finish off the now valid
123:05 - completed string as our status it's
123:07 - probably not even worth making this a
123:09 - mini challenge if I do want to
123:11 - explicitly tell this add to array what
123:13 - type it should be I can again just put
123:15 - my angle brackets type in capital P
123:17 - Pizza and everything will be happy there
123:20 - if you want you can see the difference
123:21 - now hovering over add to array it tells
123:23 - us that the generic type is a pizza type
123:26 - whereas when it was gone it tried to
123:28 - infer exactly what that type should be
123:30 - and it had an object literal in our case
123:32 - I don't think it would make too much of
123:33 - a difference because we don't have
123:35 - anything in our pizza type like we have
123:37 - here with our status but once again I
123:39 - think both for your own readability the
123:41 - readability of other people looking at
123:43 - your code and to help typescript out a
123:46 - little bit it really does help to
123:47 - explicitly type your generic functions
123:49 - like this all right that was a lot of
123:51 - work you should give yourself a big
123:53 - round of applause pat yourself on the
123:55 - back do a little dance a little
123:57 - celebration we are just about at the end
123:58 - of this first section of this typescript
124:00 - course as always play around with the
124:02 - code I'm going to revert this back to
124:04 - the way it was as fun as adding this add
124:07 - to a ray generic function was I'm going
124:08 - to revert our code back to the way it
124:10 - was before because it was just better
124:12 - that way once you're feeling good let's
124:14 - keep moving
124:18 - forward and there we have it folks we
124:21 - are at the the end of this first section
124:23 - for this typescript introductory course
124:25 - obviously we haven't hit every last
124:27 - little aspect of typescript but let's
124:29 - recap what we have learned of course we
124:31 - started off by understanding basic
124:33 - literal and custom types in typescript
124:36 - then we moved on to how you can create
124:38 - optional properties in your typed
124:40 - objects we learned about unions and how
124:42 - you can combine multiple different types
124:44 - into a single type which naturally led
124:46 - us to learn about type narrowing so that
124:48 - we can narrow down which of those Union
124:51 - types we're using inside of our code as
124:53 - a side note I feel like the code we
124:55 - wrote when we were learning about type
124:56 - narrowing is a great example of how
124:58 - typescript really helps you learn to
125:00 - think more like a senior developer
125:02 - thinking of all the edge cases that you
125:04 - can while you're writing your code then
125:06 - we learned about a couple of the
125:07 - built-in utility types that give us some
125:10 - extra functionality in modifying our
125:12 - existing types in a really userfriendly
125:14 - way and we CT everything off by learning
125:16 - about generics which allow us to have
125:18 - additional flexibility inside of our
125:20 - typescript code now as I mentioned this
125:22 - doesn't represent everything that there
125:24 - is to learn about typescript and
125:25 - something that I'm going to be doing
125:27 - with this typescript course is adding to
125:29 - it over time so there actually is more
125:31 - to come at the time that I'm recording
125:33 - this what you've watched is everything
125:35 - that we have but I do plan on adding a
125:37 - few extra topics in this section that
125:39 - you just watched as well as adding
125:41 - entire new sections more specifically
125:43 - one that's focused on how you use
125:44 - typescript while you're writing
125:45 - JavaScript code that interacts with the
125:47 - document object model or the Dom so if
125:50 - you haven't already you should should
125:51 - subscribe to scrimba newsletter and
125:53 - whenever I make a major update to this
125:55 - course I'll make sure that we email out
125:57 - an announcement of those updates until
125:59 - then I've been your teacher Bob zero if
126:01 - you want to follow me on Twitter or X
126:03 - you can click the link that you see here
126:05 - my username is Bob zero so pretty easy
126:07 - to remember and until next time good
126:09 - luck and happy coding

Cleaned transcript:

learn the basic building blocks of typescript while discovering firsthand how typescript can make your life easier and your code less air prone popular instructor Bob zeroll teaches this course typescript is a superet of JavaScript meaning all valid JavaScript code is also valid in typescript however typescript enhances your coding experience by enabling you to write code with greater confidence in the stability and longevity of your projects hi there and welcome to this introductory course on typescript my name is Bob Zol and I'll be your teacher through this course guiding you through learning one of the most important things you can learn as a frontend web developer now there might be a lot of reasons why you're here in this course trying to learn typescript but I'm going to give you three of the most important reasons you can learn typescript the headliner reason for learning typescript that I would offer is the confidence that it gives you as a developer typescripts ability to check your code during compile time or using modern idees essentially in real time as you're typing your code dramatically reduces the number of app crashing runtime errors that would normally only be caught after your app is running and possibly even deployed live to production because typescript can catch a lot of those errors before anything gets pushed up live your confidence as a developer in the stability of your code will be through the roof another reason I would offer it's important to learn typescript is the added productivity that it brings to you as the developer sure typescript does take a bit more time to write than just slinging regular JavaScript code around but there are a number of really neat features that make your life as a developer a lot easier by simply using typescript in your project in vs code for example yes in JavaScript you'll get some autocomplete but you'll see as you're using typescript autocomplete turns up to a completely different level in modern typescript enabled idees there's also refactoring capabilities immediate error checking as we talked about in point number one and a bunch of other things that you'll find as you're using typescript that just greatly improve your developer experience and thus your productivity and a third reason I would offer that it's really helpful to learn typescript is that it will improve your employability assuming you are a junior or maybe even a midlevel developer that is on the job market or will be on the job market in the future learning typescript is oftentimes considered table Stakes by many companies even if it's not explicitly listed in their job description as such knowing even a little bit of typescript can really set you apart from other Junior developer candidates so what exactly will we be covering in this course well this is an introductory course and by the end of the course you will have an understanding of the fundamentals of typescript and we'll be talking quite a bit about why typescript is so useful as far as the topics goes we're going to cover the basic literal and custom types we'll talk briefly about optional properties unions type narrowing some builtin utility types that exist already in typescript and generics which essentially allow you to create your own utility types or to make your functions and other types more flexible by understanding these fundamentals of typescript I truly believe that typescript can be a catalyst that helps train your brain to think like a senior developer as such there's one thing in particular that I remember when I first started learning typescript and that is that it can be challenging to learn at first you have nothing to worry about because you're here on scrimba you're going to be getting your hands on the keyboard quite a bit throughout this course practicing really understanding what you're learning and I've tried my best to really break down the topics into bitesized chunks that are really easy to comprehend still one of the challenges I have heard from a number of people who are learning typescript for the first time is that it feels like we're just adding a bunch of extra work without any additional benefit especially if you're trying to convert an existing codebase into typescript it can be quite overwhelming to see all of the errors pop up when you change your file to a typescript file however as my friend keny dods puts it typescript is not going to be making your life terrible it's simply going to be showing you how terrible your life already is it's really important to remember that the errors that you see show up in typescript they're not there to bug you or be annoying they're really there to protect you against some of the Loosey Goosey typing that happens in vanilla JavaScript an analogy that I thought of that kind of helps me understand this better is the concept of building a blueprint or a sketch of a project before you actually start building it on a large scale if you can imagine someone trying to just walk up to a pile of lumber and start building a house without a plan you can tell that that's probably not going to end very well yes drawing out a blueprint planning ahead it takes a lot of additional work Beyond just building your house but the benefits are obvious and I believe after you've been exposed to typescript and you've built some projects using typescript you'll probably see it in a very similar way maybe to get a little bit more specific let me talk about what this item is right here this is called a stud guard and it's an example of planning ahead of time to avoid catastrophic issues in the future now the idea of a stud guard is often times homeowners will try to find a stud and nail or screw something into that stud maybe to install some kind of Hardware or hang something heavy or whatever it might be however in certain parts of our house it's really important that we don't nail through the stud if I had a screw that was too long and right here tried to screw into this section I would hit this waterline or even worse it could be electrical line or even worse could be a gas line and so these stud guards which are made of 16 gauge steel make it so that it would be really difficult to get through this section of the stud and accidentally cause something terrible to happen a little bit of extra work planning ahead just like using typescript can save you big headaches in the future Now typescript does not solve every programming problem like this meme might suggest the main focus of typescript is on fixing possible runtime errors more spefic specifically anything that would be a type error and as I'm sure you've experienced not every error in your code is a runtime type error typescript can do quite a bit to protect you against the most common errors that people write into their JavaScript code but it won't protect you against certain things like logical errors that said we're about to see firsthand just how many errors we can fix by simply changing a file from a JavaScript extension to a typescript extension I'm really excited to jump into this code my name is Bob zero as I mentioned I'm most active these days on X you can click my username here to go directly to my profile I'd appreciate a follow so without further Ado let's jump right into learning typescript when I first started learning about typescript a number of years ago I really struggled with understanding what benefit I was actually going to get by using typescript instead of vanilla JavaScript writing your code in typescript does require a relatively significant overhead in terms of extra lines of code that you have to write and considerations that you have to take and so for this course I really wanted to demonstrate the improvements that your code will receive by using typescript instead of JavaScript just by itself so the approach I'm going to take might be a little bit different but stick with me it's going to be fun and I really think it's going to highlight the benefits that you'll get out of using typescript the way I'm going to approach this is by building a really simple restaurant app it's just going to be console based so we won't be worrying about HTML or anything like that and we're going to start by writing wrting it in regular JavaScript and I'm going to give you a couple really simple challenges but again stick with me this is going to be really fun okay so we're going to create a pizza restaurant and the first thing I want to do is create a menu it'll be an array of items each of those items will have a name and let's go ahead and add a couple pizzas here we'll say a margarita pizza margarita and we'll give it a price and let's go ahead and add four different pizzas and for the sake of time I'll speed through adding different pizzas to our menu all right in our pizza restaurant we also are going to want to keep track of the cash in the register let's say we start each day with $100 and we'll also want to keep track of all of our pizzas in the queue as people are placing orders for pizzas this way the workers in the kitchen can know what needs to happen next so let's say we have an order que and we'll just initialize that as an empty array okay let's do a quick series of challenges this is mostly just going to be a way to get your brain and your fingers working right away so let me type out your first challenge okay this is about as simple as it'll get your challenge is to add a little utility helper function for us that's called add new pizza it should take a pizza object that's just like the shape of this object up here in our menu and it's going to just add that object to the menu pause now and work on this challenge okay let's add a function called add new pizza it's going to take a pizza object and simply enough it's going to do menu. push the pizza object Perfect all right we're really on a roll here let's get rid of this challenge text and already it's time for another challenge okay this one's a little more involved but still very doable your task is to write another utility function we'll call it place order that takes a pizza name so pepperoni for example as a string and first finds that pizza object in the menu so this whole object then it adds the new price that you just generated as a business to your cash in the register then it should create a new order object which is going to be just like this one that you see here it'll have a pizza property whose value is the object that you got from step one and then a status which we will set to the string ordered and then it will push this order object to the order Q array and then just for good measure we'll go ahead and return that New Order object object just in case we need it in the future okay pause now and work on this challenge all right let's do it we'll have a function that's called place order it's going to take a pizza name as a string there's a few different ways that you could do this but I'm going to grab the selected pizza and that's going to be the returned result from calling menu doind doind is an array method menu is an array of course and find is a method on all arrays where you provide a callback function find will iterate over all of the items in your array in this case we'll call it a pizza object and from this callback function that I get to write if I return true at some point then find will return the object that it found and that's what I'm saving as selected pizza so in this case I'm looking for the pizza in my array with the pizza name that was passed in here so with pizza object I'll say if Pizza object. name is equal to Pizza name the parameter passed into this function then it will return true and I have correctly found my pizza okay then we'll go ahead and increment our cache and register so we'll say that plus equals the selected pizza. price okay and that does it for steps one and two then we're going to create a new order and this will be an object that has a pizza property that's going to be our selected Pizza object and a status which we will default to ordered then we will push into our order Q so we'll say order q. push our new order and return the uh let's new order here okay one more quick challenge and then I promise we're going to get to the point okay in this challenge we have one more utility function to write we'll call it complete order it's going to take an order ID which will be a string as a parameter it will look in our order Q array for the order with that ID and then simply Mark its status as completed instead of ordered and then for good measure just like we did with place order we'll return the found order from the order queue as a note you'll need to make sure that you're adding an ID to the orders whenever you create new orders right here we're not including IDs so that's an improvement or a modification that you'll have to also make to the place order function and since we're not using a real database here you'll just create a global variable called Next order ID that you can start at one let's say and increment every time a new order is placed all right pause now and work on this challenge right let's create a function called complete order this is going to take an order ID and then before we get too far down that rabbit hole we'll go ahead and create a new variable we'll call it next uh order ID and I'll set it equal to one to start here when I'm creating my new order I'll go ahead and add an ID property and I'm going to use this trick where I can say next order ID Plus+ this will return the original next order ID before it gets incremented that's the value that will be set to the ID here and then once it's done doing that it will increment it so that in the future when I do this again it will have already changed from 1 to two and it will then increment it from 2 to 3 for the next time that it gets used by the way for anybody that's shouting at your screen and was probably shouting at your screen when I was doing this line L of code as well I know that there's bugs in here we're going to talk more about that very soon so don't worry about me I know that there's problems to fix down in our complete order function we can do the find method that we used before so let's go ahead and say this is our order we're going to use order q. find we'll say for each order that we're looking at we're looking that the ID is equal to the order ID that was passed into this function we will then change the ORD status to completed and return the order now I do want you to use your imagination a little bit here of course we're talking about creating a consolebased pizza restaurant which is of course delicious but also a bit contrived as it stands but imagine that you've spent the last 30 or 60 Minutes or maybe even a full day or two working on some new feature for the app that you're currently building and you now feel like you're ready to start testing things out so let's go ahead and let me clear up this challenge text and we'll just test a few things out we'll add a couple new pizzas and let's add one of my personal favorites this is going to be a chicken bacon ranch and we'll say that the cost is $112 we'll add another pizza and let's call it a maybe a barbecue chicken that'll also be 12 and then maybe let's add something a little spicy in here we'll call it a spicy sausage pizza and maybe this one's $11 okay and then we will place an order and this will be for a chicken bacon ranch and we know I Hadad of time that our first order ID is going to be starting with a one so we'll go ahead and test our complete order and we'll test the order with the ID of one and then in true fashion let's go ahead and console log everything that we have so we'll console log our menu just to see if our add new pizza is working we'll console log our cache in the cach in register and let's check out our order Q all right now if you've actually been following along You' know that this code is pretty full of some minor bugs when you wrote the challenges you may or may not have introduced similar bugs but at a glance if you were to run through this program just reading through the code I don't think it's that much of a stretch to think well this looks pretty good yeah let's push this up to production we'll run a couple tests and see if it works and then push everything up if you took the chance to pause and run this code you'll know that we're going to be running into all kinds of little problems first of all we have this type error assignment to a constant variable well a type error this is actually something that would crash our program if somehow this made it past testing or didn't involve any kind of manual testing it would have gotten pushed to production and our app would have crashed there's also a bug in the way that I'm testing my complete order of course I used a string this is again a bit on the nose because we know that this should be a number but this would have probably crashed our program as well now before taking a bunch of time and fixing these errors this is the perfect opportunity for us to move this project over to typescript and first of all see what errors typescript script is able to pick up without us making any other changes to the code and then to dive deeper into typescript and see how we can augment our code so we can teach typescript how things are supposed to look so that it can catch other bugs that it otherwise wouldn't be able to so before this bug Laden code gives me any more anxiety let's move over to typescript and see how we can fix everything okay let's shift things over and start using typescript for this project and see what typescript is is going to be able to offer us immediately out of the box in scrimba the way typescript is running under the hood is a little bit different than if you were following Along on your local machine normally I would be able to just change my Javascript file to a TS file extension and set typescript up as a dependency of my app but with typescript running in the background on scrimba I need to make sure that I actually create a brand new file called index.ts we'll talk a little bit more about setting up typescript in a local environment so this isn't a big deal that we have to worry too much about now but another scrimba specific thing I need to change this tots and we'll go ahead and copy all of our code over from JS to TS and look at that we get a bunch of red squigglies of course JavaScript was perfectly happy to let us write the code that we had before but out of the box typescript is able to warn us ahead of time of any potential errors that we might have now I want to reiterate that throughout this course anytime you see these red squigglies I want you to actively move your Mouse hover over the word that has the red squiggly and see the intellisense popup that shows up I can see it on my end but it's not something that scrio records into the scrim so very often I'll be saying if you hover your mouse over this item and look at the popup I actually want you to do that in fact I want you to do that pause now start hovering over some of the red squiggly words that you see here see if there's any bugs that you can fix right off the bat well some of these are giving us errors about the variable implicitly having an any type that's something we're going to talk about in the future but if you came down here to cach and register you can see that it says you cannot assign to cach and register because it is a constant or a readon property and assuming at this point you know the difference between a const and a let that should be a pretty obvious fix maybe out of habit I initialized this as a const but I'm trying to assign a new value to it in the future and I can't do that with a const so let's go ahead and change this to a let and by making that very simple change typescript is now satisfied when it comes to this cach and register variable let's come here to next order ID and we have the exact same problem this needs to be a let instead of a const by doing that now typescript is satisfied about next order ID at first glance using typescript can be a bit intimidating because of all of these red squigglies that show up and because of the additional code that you will have to write to fix the errors that it's warning you about but I think a better better approach or a better lens to look at this through is that typescript is showing us the problems in our code nothing about using typescript here is introducing new bugs it's just showing me where the bugs already existed this means I can find them immediately as I'm typing my code instead of having to wait till it crashes for our users so over the next few scrims we're going to fix the bugs that are already here we'll be adding new features to our app and seeing where typescript is and isn't happy all while using that to drive forward our knowledge of typ script there's one more era in here that we're able to fix before we even start writing typescript specific code and that's here on line 18 go ahead and hover your mouse over selected pizza here and you'll see the popup says the object is possibly undefined this is a great example of a time where typescript is able to warn us ahead of time that we have a potential problem and this brings me to a point that I will likely reiterate in the future in this course and that's the difference between coding on the happy path and the sad path now the happy path is when we are writing our code and we just assume that everything is going to work out perfectly this does tend to be the code that people who are new to coding will write I would say mostly because they haven't been hurt in the past by code push to production that didn't account for the edge cases that can pop up when you run code in production and that's because this is the easiest code to write we have a task that we're trying to solve we write the code that solves that task and then the temp ation sometimes is just to move on however typescript forces us to take a step back and consider the sad path the sad path is when we account for or assume that problems may occur it forces us to think of those edge cases where problems can arise and address them in our code the first time before we have complaints from our users in the live production version of our code telling us that the code is crashing their browsers in a way you can think of this as being a more defensive way to write your code and truly it's not asy easy you really have to think about all of the edge cases that can occur when your code is running in a live environment and it can be difficult to imagine the sometimes weird ways that our users might use our code in unexpected ways now typescript is not perfect for this but it makes writing for the sad path significantly easier and a perfect example here is with selected Pizza when it tells us that this object is possibly undefined and I'm sure that you've run into the error that happens when you try to access a property of undefined you'll see something like cannot access property price of undefined what's happening and what typescript can foresee being a potential issue is that we're trying to find an item in our menu array based on the pizza name String and typescript can see that it's possible this may come back as undefined if we're searching for a pizza that maybe we misspell or is some nonsense Pizza that doesn't exist inside of our menu then selected Pizza is going to be undefined and typescript says that would crash your program to satisfy typescript script in this case we can code a bit more defensively and say if there is no selected pizza then first let's go ahead and run a console. error we'll maybe say something simple like the current Pizza name that you're trying to search for does not exist in the menu then to satisfy typescript we need to return from this function or alternatively we could throw an error but the point is we want to stop execution of this function and by adding this return in here now typescript knows that this L of code will never get reached if selected Pizza is some falsy value like undefined I guess I could be a little bit more specific and say something like if selected Pizza is equal to undefined notice that that also satisfies typescript in this case I'll go ahead and just leave it as a check for the falsy value okay now it does feel a bit ridiculous that we haven't actually run our code yet the reason is because I knew there was a bunch of errors in here that we had to start fixing but now it's time for us to finally run our code and we can see that we do get a type error that says cannot set properties of undefined I thought this is what we just fixed this one though is talking about setting the status property now where is that happening that is happening where we complete the order order. status now there's a few points to be made here first of all it might seems strange that typescript is not warning us that order is potentially undefined in the same way that it was warning us that with selected Pizza there actually is a reason for this we're going to address it a little bit later on but secondly and I'm sure this was dri a bunch of people crazy when I'm calling complete order I'm passing in a string ID instead of a number ID and typescript isn't warning me about this at this point in this particular program we've reached the limit where typescript is able to help us without us going out of our way to write typescript specific code it's really nice that we able to fix a couple bugs and we can see that there are potential other bugs simply by including typescript in our project and using a TS extension on our file instead but since we've reached that limit where typt SCP is no longer willing to help us without defining specific types in our program let's finally jump in and start learning some typescript specific code starting from the basics we're starting to see some of the benefits of using typescript but I think they will really start to sink in as we're building a real project in order for us to do that we have to learn some of the very basics of typescript and that is how to type a variable when I'm writing vanilla JavaScript I can say something like let my name equal Bob and because typescript is a superet of JavaScript any JavaScript code that we have will be legitimate typescript code now perhaps unconventionally I'm going to start this lesson by saying when you write a line of code like this typescript is very smart and it's able to infer what data type is being used for the variable that you just created so go ahead and hover your mouse over this variable my name let it sit there for just a second and you'll see a really small pop up that says Let My Name colon string here what typescript has done is it has inferred or derived what data type my name is supposed to be now while we are about to learn how we can manually provide different data types to our variables I do think it's important to note that the work that we're about to do is busy work it's not something that typescript requires you to do because it's able to figure out the data types simply by the data type that you assign to it to demonstrate that if I then try to say my name equals a number we get a red squiggly and if you hover your mouse over my name we'll see that it says the type of five is not assignable to the type of string in other words typescript is angry that we're trying to reassign a number value to a variable that was originally set to be a string as a side note sometimes people talk about javascript's Dynamic typing nature where in regular JavaScript this operation is not a problem at all they talk about it being a strength in the flexibility JavaScript but in practice in the real world off the top of my head I can't think of a reason why this would be a beneficial feature for us to be able to reassign a string value to something that's a completely different data type it's a code smell to me which means that if I see something like this or I'm attempting to do this in my code then I'm probably structuring my code in a bad way so typescript forces us to think of better ways to organize our code anyway let's get back to manual typing now although typescript has correctly derived that this is going to be a string type I can manually give a type by typing a colon immediately after my variable name and then typing out the lowercase version of what data type I want this to be so this might look a little strange this is one of those instances where the typescript syntax is different from JavaScript syntax this would not be correct syntax in vanilla JavaScript but it is something that you'll see all throughout typescript and you'll just get used to typing it now let's get our hands on the keyboard and do an admittedly really simple challenge we've already used the Primitive dat data type of string lowercase s string and in typescript the other two primitive data types that we'll use are number lowercase n and bullion with a lowercase b the reason I'm creating a distinction between the uppercase and lowercase is because in JavaScript there is an uppercase s string Constructor and uppercase n number Constructor and the same with Boolean but that's not what we're accessing when we're doing these types okay should be super easy pause now and work on the challenge of explicitly typing these variables below well if we hover over number of Wheels again we can see that typescript derived the data type of number I guess this could be an easy way to cheat into knowing exactly what to be there but this is so straightforward I'm not concerned about that we're going to add colon number and colon Boolean in order to explicitly type these variables okay there's a little bit more syntax that we're going to learn when it comes to manually providing some types so once you feel feel pretty good about what we've done here let's keep moving forward we'll be talking about typing inside of functions really soon but I thought it would be a good chance to apply what we've learned to our pizza restaurant app so your challenge is to teach typescript what data type should be used for the order ID parameter here in our complete order function then once you've added that keep a close eye on the rest of the program to see if typescript has any new warnings and if something pops up go ahead and fix that pause now and work on this challenge again this is a bit on the nose because we know that this is not supposed to be a string but let's just assume that we missed that little error and we'll say that this order ID is supposed to be of a number type and sure enough because we've gone out of our way to add just a few additional characters to our complete order function typescript now knows that we're using this function incorrectly we're passing in a string where it shouldn't be if you cover your mouse over the one it says that the argument of type string one is not assignable to a parameter of type number and great yes that should be a number let's go ahead and make that a number and let's hit save and look at that there are other potential issues in our program but because we're using typescript we are no longer crashing with type errors all right now at this point our app would benefit from us starting to write what's called custom types so that's what we'll start learning in the next lesson we've talked about a few primitive types like string number and Boolean but in typescript we also can create our own custom types at first this isn't going to seem super useful but just bear with me we can create new types by using the type keyword this is something that exists only in typescript and by convention the name that we give our type is going to start with a capital letter for example I could say type food is equal to string by doing this I now could use the capital F food as my way of providing a new type to this favorite food variable now doing this with primitive types like strings numbers and booleans won't make a whole lot of sense until we talk later down the road about something called unions or intersections but this can come in handy for creating custom types around objects let me show you what I mean I have this person object with three properties name age and is student a pretty common thing with objects is that you might have multiple of the same kind of object so let's say we have a person two which looks very similar we're going to have Jill age know 66 and we'll go ahead and say is student is false as it stands there's no problem with this code however you might have noticed that I used a lowercase in this is student property and an uppercase s in this one one of the benefits of using typescript is that it forces us to stay consistent and although this may not cause a bug the way it's written currently it seems pretty ripe for a bug down the road what we can do is create a custom type of an object that defines the shape of the object where we can give it exactly what the property names are I can create my custom type by using the type keyword I'll use capital P person as my type and I'll set it equal to an object and what I'm doing inside of this object type is telling it what properties it will have like name but then instead of providing a value I'm going to give it a type I want my name to be a string type one quick side note about custom object types in a regular JavaScript object it's syntactically correct to have a comma to separate each one of your property names however when you're creating an object type like this you can use commas you also can use semicolons you also can just leave them out so for me personally I'm probably going to just leave out anything at the end here but you can choose whatever you want and it's most important just to stay consistent within the project that you're working in okay just so we can avoid some passive list listening here I'm going to include a really simple challenge here I know it's a little bit of busy work but getting your hands on the keyboard is always a win when you're learning to code so your challenge is to finish the object type definition so let's say so that it looks like person and you know what let's call this person one so that this type is the same shape as person one pause now and work on the challenge okay well we're going to put age is a number and is student is a Boolean simple enough now let's take a step back obviously writing this out has cost us more work it's used up five more lines of code frankly it doesn't take very long but it can feel like it's breaking your flow however by doing this we've added an extra degree of type safety when I'm defining person one I can use my colon and set it equal to my custom type person and I can do the same thing for person 2 we'll say this is capital P person and check it out even though we had to go out of our way to define this custom object type by doing that little extra work we have already been able to identify a potential problem we know that these two objects should be the same but we might have just missed it because we're fallible humans let's put in a capital S and satisfy typescript spend some time playing with this code and when you're ready we'll move on and talk really briefly about nested object types let's set a standard in our pizza restaurant app as to the shape our pizza objects should have and I'll have you do that through a challenge your task is to create a pizza object type it should include a name and a price property and that'll be the extent of the challenge for now we'll apply that in just a minute so pause now and work on this challenge okay this should be pretty straightforward we'll say we have a new object type called pizza and it needs to have a string name and a price which is a number okay easy easy enough now what I want you to do is to pause look through our code and see if there's anything obvious that you can enhance with typescript by telling it that the type should be of this pizza object type so pause now peruse through the code experiment a little bit see what happens and then I'll have an official challenge for you well if you're anything like me you probably went through and started looking at the different red squigglies that we have and right here in our add new pizza we have this pizza object which if you hover over it typescript warns us that it implicitly has an any type that term any type isn't necessarily supposed to make any sense to you yet so don't worry about that we will be covering that soon but this brings us to the next challenge all right your challenge is to teach typescript that this pizza object in this add new pizza function is supposed to be of type pizza then like before once you've done that look through the code and see if there are any new warnings you need to deal with of course there are going to be and fix those issues pause now and work on this challenge all we have to do is put a colon and then a capital P Pizza after this typescript is no longer warning us that pizza object is implicitly in any type and in fact if you hover your mouse over Pizza object here it will specifically tell you it's a parameter and it's of type capital P Pizza all right let me clean up this text and we'll just go ahead and peruse down here in our code and check it out down here when we were adding a new pizza we have these three new errors over cost if you didn't have a chance to do this already have your mouse over cost and you'll see that it tells you that the argument of type Nam string cost number is not assignable to the parameter of type Pizza okay well that's interesting the next thing it says is that the object literal may only specify known properties and cost does not exist in type pizza and sure enough when we wrote this we might have forgotten that it actually is supposed to be price not cost typescript saving us again you can go ahead and change these to price instead of cost and hit save and sure enough everything is working as we'd expect now I assume a number of you were probably screaming at me this whole time when I first wrote cost here in the beginning I promise it was all planned out and staged but notice that without writing our pizza type and specifically telling add new pizza is supposed to be taking a pizza object that our program wasn't necessarily crashing if you looked at our menu before we had an array of the items that we initialized in the beginning but then we also had added items with a name and a cost property and I don't know about you but that makes me feel gross to know that we have these mixed types in our menu that's just asking for crashing bugs down the road by adding just a few lines of really simple typescript we were able to defend against that problem that not only would never have shown up in regular JavaScript but also wasn't even showing up as issues here in typescript until we went out of our way to create this pizza type okay we're making good progress on fixing up the bugs in this app before we move forward there's one really easy update that we can make and it's so easy I'm not even going to make it a challenge here in our place order function if we hover over Pizza name which typescript is warning us about it says that it implicitly has an any type let's go ahead and type that as a string and get rid of that warning great well it looks like the majority of the issues actually all of the issues that we have left have to do with this variable order CU so let's go ahead and Tackle this issue next let's say we want to build out our person object a little bit more and we want to include an address property well typically something like an address wouldn't simply be represented by a string but instead by a nested object the most straightforward way to do this is to Simply type it out as if I were typing out a regular object I can put my curly braces there and just like I did with the rest of my type I can say maybe there's a street portion of my address and this is going to be a string we'll just stick to Street city which is a string and then we'll also say uh let's do country and that'll also be a string okay what do you notice about our code now well our objects below are typed as person objects or person types but we just changed the definition for person to say that it must include an address if we hover over the red squiggly which you should also do right now as you're watching this it tells us that the type of this person one with the object as it currently stands is not assignable to the type of person in other words there's a mismatch between the derived type of this variable that we've just set which typescript can see is a name with a string and age with the number and a is student with a Boolean and it sees that that doesn't accurately match the person type that we just redefined with the address property assuming we do actually want every one of our objects to have an address property we would need to make sure that we update our objects to include an address property that includes all of the subproperties of the person type definition under address so that means I would have to have a street let's just put something generic in here a city we'll say this is any town and the country we'll say is USA I'm sure you noticed as soon as I added country to my address it then satisfied the definition for this person type and typescript stopped complaining removing any one of these properties is going to make typescript complain because it doesn't perfectly match the type that was up there now I can guess what some of you might be thinking at this point because this is exactly what I thought at this point in my learning of typescript is that typescript feels so extremely rigid we've become very accustomed to writing JavaScript where essentially anything goes and we fix the bugs that we have while we're testing out our app and we kind of hope that we fix it all but at least we get some freedom and flexibility I have two things to say to that first of all we are going to learn a way in which we can make these properties optional so that typescript won't scream at us if for example we don't want person one to have an address but secondly I would say that you should work really hard to force yourself to become comfortable with that extra rigidity that's offered by typescript at first you might think that it's sort of stealing the fun of slinging JavaScript code and building projects on the Fly really quickly however when you're working in a real production environment at a company you're going to find it less fun when you have to fix bugs in production because you didn't have the extra rigidity and type safety that comes by using typescript all right I'll get off my high horse now one last thing before we move on another common way that you will see this nested object structured is by not necessarily defining the types right here in line with our person object but instead simply creating a separate type for the address alone and so I'm going to turn this into a challenge your challenge is to try and figure out how to move the nested address object that we have here into its own type like we see here and once you've done this correctly there should be no red errors in the editor below I do want to point out that I haven't explicitly taught how to do this what I'm trying to accomplish here is getting your brain thinking get your hands on the keyboard and see if you can put two and two together to figure out exactly what this would look like if you're feeling stuck rather than just hitting play and moving forward I would recommend searching on Google or opening chat GPT and formulating your question specifically so that you can be engaging your mind and really going out of your way to try and learn these things when you just push forward and watch me do it it doesn't sink in quite the same way as when you are more engaged okay getting off my soap box now pause now and work on this challenge well I should be able to just take the properties of my address here I'll cut those out I'll put them into their own address type up here and then instead of doing an inline object here I can simply refer to the capital A address type that we defined above and after I've done that you can see there are no more errors in the editor either of the two ways that we just saw it is completely fine if you think that you are going to be using this address type elsewhere in your code as a standalone type then it makes sense to separate it into its own address type like we just did or if you already know that address is only ever going to exist as an object in the context of a person object then you can just leave it nested inside of the person object and that will work just fine as well once you've had enough time to play around with this and feel pretty comfortable with it then you'll be ready to move on to the next Grim where we will talk about how we can make some of these properties optional if we need to something that might put your mind at ease regarding typescript rigidity is knowing that when you're creating object types like we see here with person you can Define some of these properties to be optional now this comes with a caveat when you're making decisions about whether something should be optional typescript comes with a number of ways that you can relax that rigid nature but you should learn to force yourself to really ask the question do I really need this to be flexible we're going to see multiple different ways in which typescript offers that flexibility however they always come with the tradeoff of reduced type safety let's get the syntax out of the way for doing this because it's really simple for example if don't necessarily want every person to have an address you can see removing address gives me some typescript warnings when I'm defining my type I can simply put a question mark after the property name that's going to be optional you can see as soon as I typed that question mark the warning under person one went away and that's because now the address property is optional this has offered me a bit of flexibility however as I mentioned it does reduce my type safety we'll be talking more about adding type safety to functions soon but let's say I have a function that's called display info and this function is going to take a person as a parameter and in it it's going to console log and let me use a template string here we'll say person. name lives at and then we'll stick in person. address. Street okay so now later in my code or maybe in another module I import display info and I'm going to call display info and pass person one to it well this is a bit on the nose I'm sure that you can see what this this problem is going to be let's hit save check our console and sure enough cannot read properties of undefined that dreaded error that we see notice that it says it's a type error this is an error that was introduced well really for two reasons one because we chose to make this an optional property but in truth maybe more importantly because we didn't add any type safety to our function I can technically get rid of this error by using optional chaining right here on address one thing to note is that currently scrimba doesn't understand optional chaining but trust me this is going to work just fine however this solution isn't great because if I hit save we see that we get Joe lives at undefined not a program crashing type error but still not a great experience now don't let me get in your head too much adding an optional property is a completely legitimate and fairly common thing to do in typescript I'm just making sure I do my due diligence and letting you know that every time you add one of these sort of flexibility enhancing features of typescript you are going to reduce your type safety by a little bit okay let's move on and apply what we've learned to our pizza restaurant app okay let's Jump Right In with the challenge your task is to create a new order type in that type it should have an ID pizza and Status properties I won't to explicitly give you what data type those should be but just look through the code if you need some hints as to what it will be pause now and work on the challenge okay let's let's create a new type called order and this will be an object it's going to have an ID which is going to be a number remember down here we have our order numbers that we're keeping track of and so that will be a number the pizza property is going to be a pizza type which makes sense because it's a nested object inside there and the status property for now is just going to be a string we're going to talk about this a little bit later let's clean up the challenge text and hopefully that was pretty straightforward now this wasn't explicitly part of the challenge there's a chance that you came to the order queue and decided to try and make this of type order and you'll notice that that doesn't fix the warning that typescript is giving us and that's because the order Q is an array it's not a single object so before we can fix this we need to learn about typing arrays it's fairly straightforward so we'll do that in a quick scrim after this and then we'll come back to our pizza restaurant and fix these issues we've learned about how to manually type the Primitive types in typescript for example if you have something like let age equal 100 you can manually tell typescript that age is going to be a number like this and there's a similar syntax when we are typing arrays so if I have an array and maybe we'll just call this ages so that it makes a little more sense maybe 100 and 101 notice that typescript is complaining about the type of Ages hover your mouse over the variable ages here and you'll see that it says the type type number square brackets is not assignable to type number well it kind of gives away the Syntax for typing arrays all we have to do is simply put a set of square brackets as if this were the array syntax with an empty array right after the type and this is how we teach typescript that ages should always be an array that consists only of number elements if we were to try and put another thing in here maybe the string one then we get an error again it tells us that there's a problem with this last element because it is not a number inside of this array the same will happen if I try to push something to the array that isn't of the correct data type like ages. push true red squiggly shows up here under true and it says that it's not assignable to the parameter of type number this should all be pretty straightforward for you at this point I think it's important to note that in the same way that typescript is able to infer a regular number typescript is also able to infer the data type of an array of numbers so when it's an array with some simple primitive data types in there we don't have to manually put colon number square brackets or string square brackets or anything like that we can just let typescript do its job and we're going to get the same benefits in the end however when we have a custom data type like a person data type that we've seen before let me fill this out again we have a name String we'll say an age is a number and is student is a Boolean when we want to create an array of these people objects well actually I think you'll be able to figure this one out let's make it a challenge okay I took away some of the busy work here for you by creating a couple of person objects I've already typed them as a type person and your challenge simply enough is to create an array with person one and person two in it and then to manually type this array as an array of person types pause now and work on the challenge okay let's go ahead and set this equal to an array we will will stick person one and person two in there and before I manually type this as an array of person types I'm going to hover over this variable people and you should do this as well and you'll notice the popup does correctly type this as a person array because every item in this array conforms to the person type it knows that this people array should continue to be an array of person type but that's not what the challenge says the challenge says to manually do it so we'll put colon person and then the array bracket syntax now normally as I've said it's good to let typescript do as much inference as it can especially when it comes to primitive types like numbers and booleans however I'm a little bit more torn here yes typescript is able to infer that people is an array of person types however adding it here explicitly does make it a little bit easier for myself or other developers to read in the future so in this case I'm just going to leave this here we also can note that if I don't manually type it and then I remove the person type declarations here and hover over let people we can see that now it has inferred the type to be an object literal with all of the properties instead of having the person type as an array here but we're using typescript I can't think of a good reason to not type these as person objects so we'll just leave it like that and maybe I'll go ahead and put back my colon person array as well really quickly there is another syntax which you may see floating around and we will talk a little bit more about it later in this course when we talk about about the concept of generics but for now it's enough to know that there is a syntax where you can use capital A array a set of angle brackets and then put your type inside of the angle brackets and I could use this in place of my person with square brackets just like this this is going to do the exact same thing you can hover over people and see that it is correctly knowing that it's an array of person types so I'm just covering my bases here don't worry too much about that we're going to stick with this syntax for now and talk more about that other syntax when we talk about generics okay let's get back to our pizza restaurant and apply what we've learned to our code over there here we are back in our pizza restaurant and your challenge is to fix the typescript warnings that we have throughout our code about order Q pause now and work on this challenge okay well we already have our order type that we wrote previously and we know that the order CU should should always be an array of order objects so by doing that typescript is no longer complaining about order q and if we come down we only have one more typescript warning here and this is awesome this is actually a really helpful warning but everything else has resolved itself now that typescript knows that order Q should be an array of orders it's able to ensure that we won't have any type errors in our program because we've generally written everything okay now there is this one new warning here under order. status order says that it's an object that is possibly undefined and this should look familiar this is exactly the warning we were getting above when we were writing selected pizza. price it was telling us that selected Pizza is possibly undefined so that brings us to the next challenge okay now your challenge is to fix this warning below by handling the sad path scenario notice I'm being a little bit vague here I do want this to be a chance for you to engage your brain try to remember what we've learned before look through the rest of the code that should help you out quite a bit pause now and work on this challenge when we're running order q. find if we provide an order ID that does not exist in the order Q then this order is going to be an undefined value in fact if you hover over order here you'll see the intellisense popup it says const order Colon capital O order and then a pipe character or a line and and then undefined similar to JavaScript with the double pipe operator indicating an or logical operator I like to read this single pipe in typescript like the word or as well in other words const order is either going to be a capital O order object or it will be undefined and that's because typescript knows if it's not able to find something with the finded method it will return undefined and in this case we're not handling that in our code typescript saves us again so if there is no order then maybe we'll just do what we did above where we console error let's say order ID was not found in the order que and then we'll go ahead and return although as I mentioned before this could be an opportunity for us to throw an error if we were to throw a new error and then maybe put this message in there that would work just as well because it halts the execution of this function and therefore typescript is now satisfied that order. status is never going to get reached if order is nonexistent but just to stay consistent I'll go ahead and keep my return here clean up the challenge text and look at that all the typescript warnings in our app are gone now I do think it's important to note that the lack of typescript warnings doesn't automatically mean that our program will function exactly as we expect it doesn't mean that we've handled every Edge case but it does mean with relatively little amount of effort we have a much greater degree of confidence that our app is going to work as as we would expect speaking of which we haven't run this code in a while let's run it and open our console and Awesome everything looks the way that we would expect in order for us to touch on a few more topics in typescript we are going to start building out new features in our pizza restaurant app but before we do that I do want to encourage you to get your hands on this code play around with this try adding some new functions or making some kind of change it doesn't even have to be significant for example when I was first writing this I decided I actually wanted to rename the to order history and if I do that suddenly we get some errors immediately showing up in our typescript that are super helpful they help us know exactly what needs to change in fact I'm going to leave this as order history so that I can bug some of you into fixing this error and getting your hands on the code once you feel pretty comfortable with everything that we've written so far let's keep moving forward hopefully you've had a chance to play around with the intellisense popups that happen when you hover over different variables that you deare with typescript and something you might have noticed is the difference between how typescript infers different types for example if I were to say let my name equal the string Bob go ahead and hover your mouse over my name okay you'll see that it says Let My Name colon string so typescript has correctly inferred that my name is of type string and it will warn me if I were to ever try and change it to a different data type you can see here typescript is saying that you can't assign the value true to a string type variable okay let's see how that differs however when we use const to declare our variables so if I say const my name equals Bob and I need a different variable name let's say my name 2 cuz I'm really original right now C your mouse over my name 2 this time the popup doesn't show the type as a string but instead it shows the type as the string Bob this is called a literal type and it's when you tell typescript that the type isn't a generic string which would allow that variable to be become any string but instead it's a literal type an actual value type of the string Bob with a capital B at the beginning if you put a little bit of thought into it then this will make sense because with let I am allowed to change the value of this variable and typescript logically restricts the data type of the value I'm allowed to change it to to a string and with const I'm not allowed to reassign this value and so it makes sense for typescript to say this value has to be the string Bob from here on out I can't say my name to equals bill this not only makes sense in typescript but also JavaScript we would get warned in regular JavaScript saying we can't reassign a const and if you hover over my name 2 here it says cannot assign my name 2 because it is a constant or a readon property just for the sake of completeness I can manually type something to be a literal type so I could say const my name to colon the string Bob equals the string Bob of course typescript already inferred this but this is what that syntax would look like I could do the same thing with my let I could say Let My Name colon the string Bob equals Bob and if I were to try and change this to anything else like Bobby then I get a typescript warning the same thing would happen down here now there are times where you may see this being useful in typescript but more often than not the concept of using literal types is much more commonly found when you pair it with a concept called unions so feel free to around with this code and in the next Grim we'll learn about what unions are as I mentioned there certainly are going to be times when a literal type by itself can be useful however you will often times see them being used combined with a concept called unions let's start with an example let's say we are working on an application and we want to maintain a different kind of user role for the sake of our database and our application we're going to be saving that user role either as guest or member or admin and in our app we don't want someone to be some kind of user R like a hacker or something completely gibberish that doesn't make sense to our application in this kind of scenario we can use a combination of literal types and this concept called unions to teach typescript that this variable user role should only be allowed to be one of a certain number of strings if you're familiar with the concept of enums in other languages this is essentially the same idea as an enum there's a little bit more to be said about that because typescript does have something called enums but let's not get bogged down by that topic for now if you're not familiar with the concept of enums well you already are familiar with the concept of an enum because you know what a Boolean is a Boolean can only either be true or false it has to be one of those two values and it can't be something like yes or no at least not in JavaScript so if we have our user role and we want this to only ever be guest member or admin we can use Union types in order to accomplish this I'm going to create a new type called user Ro and I'm going to set it equal to the literal value of guest and then I can make a union by using the single pipe character you can essentially read this just like you would the double pipe character in JavaScript as the English word or so I can say that type user Ro is either going to be the string literal guest or the string literal member or the string literal admin and now that I've defined what a user roll type is allowed to be I can tell my variable that it has to conform to the user Ro type and from then on if I were to ever change this to some gibberish typescript would give me a warning this literal Union type that we have here doesn't just need to be its own Standalone thing I might have it nested inside of another type so I might have a user type which has all of the other properties that we might normally see like a username of string blah blah blah and then I might say user r or let's just call it role and we can just copy what we have here and say that the user. roll property has to be one of these three string literals I won't necessarily go down and show an example because I think you get the idea let's go ahead and satisfy typescript by making this one of the available options inside of our user roll Union and typescript is satisfied okay let's jump back to our p a restaurant app there's a really small update that we can make now that we understand literal types and unions we can add a little bit of extra type safety to our orders by teaching typescript that an order type is allowed to not just be any string but it either has to be the string ordered or the string completed this should be pretty straightforward will make this a quick challenge go ahead and update our order type so that the status property can only ever be the string ordered or the string completed then once you've done that try to make a change in our code maybe change this status to something other than ordered or completed some gibberish will do and make sure that typescript is complaining about that change pause now and work on this challenge okay we'll just make this so that it can't be any string but it only can be the literal value ordered or the literal value completed now that we've made this change we can actually see there's a new typescript warning and that has to do with this line 35 where we have new order this one can be a little bit confusing to understand but let's walk through it step by step here we're creating a new order variable and we're setting it equal to this object literal when I hover over New Order we can see from the intellisense popup that it was able to infer essentially the shape of the object as having an ID that's a number a pizza which is a object with a name that's a string and a price that's a number and then a status that's a string however now that we have gotten more specific in what our order should look like up here where it has to be the string ordered or completed not just any kind of string the object that we're trying to push into our order queue which if you remember we specified needs to be an array of orders the data type that typescript inferred for our status right here is just a generic string I know this can be a little bit confusing don't fret too much if none of that is making any sense but the way that we can fix this error is by saying when we are instantiating a new order we can tell typescript specifically this is going to be of an order type by manually typing this as a type of order it now knows that the status of ordered here is not just any old string it is conforming to the status literal Union type that we defined up here and because of that order Q which needs to be an array of orders is okay with us pushing in a new order and if I were to try and change this to something like blah blah blah now typescript is complaining again because it knows that that's not okay it can't just be any string it has to be one of either ordered or completed so let's go ahead and change this back the same thing would happen if I come down here and I change this to blah blah now typescript is not going to be happy with me updating order. status because it knows that blah blah is not one of the legitimate statuses for our order object as always play around with this code and once you're ready we'll keep moving forward as we've talked about typescript is great at inferring primitive types and other more complex types that don't necessarily hold a lot of weight in the functionality of our app however there are certain times when we would really want to make sure we manually include the type of something for example here in our menu we're defining the menu as an array of these objects and these objects just so happen to conform to our type of pizza but we haven't actually told typescript that our menu should be an array of pizza items this becomes a lot more apparent when we try to make a definition change to our type of pizza Let's see we were tasked with creating a new helper function called get pizza detail which allows us to find one of the pizzas in the menu either by its ID or by its name well currently we don't have IDs in our pizzas and so we might think to come up to pizza and say this should also have an ID that's a number and doing this because it's typescript really helps us out further down the road when we find out some of our code is not going to work the way we think because they don't have IDs when we're trying to add new pizza and so forth but I'm not concerned about this quite yet we'll get to that later but notice that our menu does not have a problem with the change that we made to our pizza type definition because it doesn't know that it's an array of pizzas so let's go ahead and type it as an array of pizzas okay now typescript is warning us hover your mouse over menu and you'll see that it's complaining about how there's an ID property missing in these objects here great that's a good warning that just saved us some trouble so I'm going to go ahead and add a manual ID property here and we'll just kind of make them increment manually notice if we scroll down we used to have an error I think it was here on New Order because the pizza we were adding did not have an ID and pizzas now need IDs but we are correctly getting errors down here with add new pizza because these ones don't include IDs for now I'm just going to manually add IDs here as well this is just a temporary fix until we figure something else out what we just saw is a perfect example of how typescript doesn't make your job harder as a developer it actually significantly improves your ability to add new features and to debug your code in the process all I had to do was make an an update to my pizza type and typescript immediately showed me where all of the problems with that change would happen and I was able to pretty quickly go in and fix them granted the fix will not always be quite this easy but hopefully you're seeing the benefits nonetheless next we'll move on to a concept called type narrowing and we'll do that through a series of challenges to start us off on a lesson about type narrowing I'm going to give you a challenge I want you to create a new utility function called get Pizza detail it's going to take a single parameter called identifier but there's a little twist to this we want to allow this identifier either to be the string name of the pizza like the string pepperoni or it could be the ID number of the pizza for example the pizza with the ID of the number two you don't have to worry about the code inside of the function just yet I just want you to create the function signature and just make sure that you type the identifier parameter correctly so that typescript is okay with it either being a string or a number type I haven't taught how to very specifically do this one thing but assuming you've been following along and doing the challenges I think you'll be able to put this one together pause now and work on this challenge okay let's create a function called get pizza detail it's going to take identifier as a parameter and we're going to type this identifier as either a string or a number and this is what I meant by saying we haven't specifically taught this thing we talked about doing it with string literals if we wanted it to literally be one value or another value but we can also use unions with more generic types like you see here okay let's start working on the internals of this function and really what I mean is I want you to do this I'll make this into a challenge I'm getting a little bit more vague with the details of how to accomplish this challenge but that's okay cuz I know you're to the task I want you to write the code for our get pizza detail function so that it's able to use the identifier whether it's a string or a number and use the menu. find method accordingly once one of the pizzas from the menu has been found it should return that pizza for now you can just assume that it will find something in menu. find you don't have to handle the instance where it might not find something pause now and work on this challenge okay let's get started on this in JavaScript we can determine what kind of data type identifier has by using the type of keyword and so I'll use an if statement that says if the type of identifier is a string then I can assume that it's going to be the name of the pizza and so I will return whatever comes back from menu. find and we'll say for every Pizza that we're looking through if pizza. name is equal to to the identifier then it will find the correct pizza and return it one little feature I think I'm going to add is I'm going to lower case both of these just so that if they put in the wrong capitalization for the pizza name or something like that then it will still be able to find the correct pizza now for the next part I'm going to just use an else instead of an else if checking the type of the identifier to be a number but I'm doing this specifically so that I can show a limitation of being less specific for now we'll essentially return this exact same line except instead of name we're going to check the ID and uh we don't need a to lowercase because that's going to be a number and actually check this out if we hover over to lowercase typescript is able to tell us that do to lowercase does not exist on type number this is super interesting because it highlights the fact that typescript is able to parse and understand our code and it knows that we have already handled the instance where the ident ifier might be a string and because we've told typescript that the identifier is either a string or a number it knows that in this case according to what we have told typescript the type of the identifier will be in this else statement it has been able to narrow the type down to be a number also if we were to have copied this line of code down and simply removed the dot to lowercase but forgot to change this from name to ID typescript warns us that we can't use the trip equals to compare a string which it knows pizza. name is and a number which now that we have narrowed the type down we know that it is no longer going to be a string if it's reaching this code and so it's able to warn us that these things aren't going to equate correctly so just another instance of typescript helping us out so this is just one example of this concept called type narrowing where when we're writing a function and we don't necessarily know what the data type of that function is typescript will expect us to narrow down the type and handle each use case or potentially provide a default for all other use cases if it isn't in the if or else if statements soon we're going to see another example of where type narrowing is really important but first I want to address this lse statement that we have as I mentioned I would we'll do that in the next scrim although this isn't a specific benefit created by using typescript one thing that writing your projects in typescript will help you do is remember to be as explicit as you can when you're writing your code for example I have told typescript that my identifier is either going to be a string or a number and I've handled the case where the type is going to be a string and therefore typescript can assume that inside of my else Clause here the type will be a number however in some instances you may be working in a project where the code you're writing will end up being used in a plain Javascript file and the protection that other file would normally get if it were used using typescript won't exist so I've added this export in front of our function and I'm going to use this index.js file to import our get pizza detail function from our index.ts file and I can show that this is working so I can say get pizza detail with the ID of one and we'll console log the result and sure enough we get our margarita pizza with the idea of one however Nothing is Stopping this Javascript file from doing something weird like saying get pizza detail false because it's JavaScript we're not going to get any compile time warnings here and so I can run the code and get the value of undefined which in all honesty our function is pretty okay with returning anyway but we could get a little bit better of a user or I guess not a user but another developer's experience can be improved if we're just a little bit more explicit here and we say something like if the type of identifier is equal to a number then we can run this code and then we could include another else that maybe throws a new type error that says the parameter identifier must be either a string or a number okay so let's hit save and now by trying to use false in get pizza detail we get our type error thrown so that the developer using a Javascript file can get a little bit more of an intentional feedback loop so long story short when you're writing your typescript code try to be as explicit as you can within reason staying on the theme of being explicit with your typescript code whenever you can I want to talk about function return types before we jump into that though I did want to note that we previously talked about composing together different object types but here we can see we have this type user and for the RO property of that user object we're using the user R type that we created up above so we can compose types together however we want it doesn't just have to be when we're talking about nested objects like we saw at the beginning of the course okay so here we have a users array and we have a function called Fetch user details which takes a parameter of username and sends back the user in its return value go ahead and hover your mouse over the name of this function fetch user details and you'll see that in the popup it says function fetch user details parentheses username colon string exactly what we have in the beginning of our function here in our code but then it says colon capital u user the colon that we put after the arguments of our function gives us a chance to specify what type of data should be returned from our function now typescript was able to infer that as we see it put a colon user there but in a lot of instances it can be really helpful to explicitly type what should be returned from your function so I would put a colon and this is between the arguments of my function and the opening curly brace and then I would just put capital u user here to teach typescript that this function should always return a user object so if it was able to infer that it's returning a user why is it helpful to explicitly put a capital u user here well one of the major reasons I think for doing this is that it helps whenever we're refactoring our code if myself or some other developer were to find this function and say I don't know why it's returning a user it should be returning the user. username instead well if they try to do that then they will get a warning from typescript saying that it's trying to return a string instead of explicitly a user object if I don't include this explicit typee declaration then typescript has no problem with me completely changing the return value of this function which assuming this function is used throughout my codebase would likely cause some other problems so this is an opportunity for us to be a little bit more explicit and to specify that we want this to be a user object that gets returned and if someone is going to change the return value of this function they would have to come up and explicitly change this to something like string and this would be the dot username which theoretically would be a prompt to that other developer or myself in the future to then go throughout my codebase and make changes every time we're calling this fetch user details function let's keep this returning a user for now okay it's been a minute since we've had a challenge so let's go back to the the pizza restaurant app and try your hand at a quick challenge we just talked about the typescript specific type called void and there are actually a few other typescript specific types that I think would be worth taking a little tangent to talk about at this time we'll start with a rather notorious type in typescript called any the easiest way to think about any is to know that if you type something with any you're essentially turning off typescript checking for that value so if I have a value and let's set it equal to one typescript is able to infer that this should be of type number you can hover your mouse over value to see that and it gives me warnings if I ever try to do something like reassign it to a string it tells me that you can't do that or if I try to run an operation on it like to uppercase which only works for Strings it tells me that you can't run this method on a number These Warnings of course as we've seen up until now are very useful to us but let's see what happens if I manually type this as an any type suddenly the warnings go away as I mentioned we've turned off typescript checking so I can tell value that it's going to be a string now I can try to call say an array method on it and typescript isn't going to warn me at all essentially it's a way to say in your code I know better than typescript how this thing should be typed and I don't want typescript to help me at all I think you can probably see maybe from my tone or just from the lack of warnings here that this is not a good idea so when really should you use any well in short you shouldn't it can be tempting when you're looking at your code that has a bunch of typescript Errors to just throw your hands in the air type things manually as any so that the warnings go away and then continue on with your code but in that case why did you choose typescript in the first place now that's not entirely fair I think there is at least one legitimate use case and I think that would be if you're in the process of transitioning your code base from JavaScript to typescript and you don't have the time right now to write all of the complex types and update all of your code to satisfy the typescript warnings and you just need a temporary that's the important part here temporary way to get around typescripts just for now but be warned as soon as you start adding any to your code base and the warnings go away it might be a bit difficult to go back and force yourself to bring those warnings back by removing the any types in fact it might be better if you just left the warnings there and turned off the configuration in typescript that forces you to satisfy the typescript warnings before your code will compile we're venturing into territory outside the scope of this course so if there's just one thing I want you to take away from this lesson just don't use any if you do have a scenario where there's a value where you legitimately don't know the type of it there's another typescript specific type that is much better suited for that scenario and it's called unknown that's what we're going to be looking at next okay we're going to do this in a couple parts the first part of your challenge is to add a return type to the get pizza detail function this should take you all of about 2 seconds to do but once you do it as it says in the note you are very likely going to get a giant typescript warning but don't worry about that we're going to address that in part two of The Challenge pause now and add a return type to our get pizza detail function simply enough we can come between where the closing parenthese is in our parameters and the opening curly brace we can just put a colon and say that this is supposed to return a pizza and look at that we get those giant typescript warnings and if we hover over it it tells us that type pizza or undefined is not assignable to type pizza now before I explain exactly what's going on here I want you to think about it try and figure out why is it saying that the type pizza or undefined is not assignable to type Pizza in fact if you want to pause to spend a little bit of time playing with the code or thinking about that go ahead and do so now we talked about this briefly when we first wrote this code but remember that menu. find potentially returns an undefined value if it's not able to find the pizza that you specified let me get rid of my explicit declaration here and for a kind of unrelated reason I need to get rid of my challenge text and now hover your mouth Mouse over get pizza detail and you'll see that it did infer what data type would get returned from this function it's either going to be pizza or undefined typescript was smart enough to read through the code and know that we are returning potentially an undefined value or rather a value of undefined inside of our code here and so it inferred the return value as either pizza or undefined this is where things can get a little bit hazy you may want to rewrite your code a little bit differently to either throw an error if it was able to find the pizza or you can just expect that whatever code is calling get pizza detail will handle the instance where it gets an undefined value returned but since this course isn't about how to architect this particular function we'll go ahead and do another really simple challenge okay again really easy but I want you to explicitly type the return value of this function so that typescript knows it could either be a pizza object or the value of undefined pause now and work on this challenge again simply enough we can just put a colon right here and say it's either going to be pizza or we will include the union of undefined like we saw before this doesn't necessarily change the way that the function works or the way that typescript sees the function but it does help us or other developers in the future know that when we're messing with this code and doing some kind of refactor we need to either make sure that we continue to return a pizza or a value of undefined or we need to explicitly change this value and then change our code everywhere else that's depending on get pizza detail either returning a pizza or undefined let's clean up the challenge text all right well we're not quite done talking about return types with functions so feel free to play with the code as always and when you're ready we'll keep moving forward there's another return type that isn't quite as obvious as something like pizza or undefined was down here and that is when you have a function that doesn't return anything look through the code on your screen here see if you can find a function that doesn't currently return anything hopefully you found this add new pizza function in fact if you hover your mouse over it you'll see that the inferred return type is called void this function modifies the menu by pushing new objects to it but then there's no return from it there's not going to be a value that we can get from it so one way we can be a bit more explicit almost like documenting our code in line is by explicitly typing this as returning void it doesn't change the way that the function operates if you try to save the return value from calling add new pizza you would get the value of undefined but it helps us or other developers in the future reviewing through this code to know that we knew this wouldn't return anything it's just performing an operation outside of itself and then not returning anything that's about all there is for me to say about void it's pretty straightforward but since that was pretty quick I want to give you a relatively unrelated challenge okay your challenge is to add explicit return types to the rest of our functions so really just the place order function and the complete order function pause now and work on this challenge a really easy way to do this is for us to hover our Mouse over the name of the function and see what typescript has already inferred is going to be the return type here we can see that it's either going to be an order type or undefined and if we go to complete order it's actually going to be the exact same thing order or undefined so really just getting our repetitions in with the muscle memory in typing these functions out okay nice work let's move on let's take some time to do a really simple refactor to our code and see how typescript helps us do that currently when we're creating the menu we are manually adding our IDs here with 1 2 3 4 and I brought the calls that we had down at the bottom up a little bit to add new pizza and we were manually doing IDs of 5 six and 7even let's go ahead and use the same trick that we're using with next order ID right here where when we are creating an order we are creating an object right here where we're using next order ID ++ if you run into any typescript errors make sure to hover your mouse over them and see if you can figure out how to fix them as a little peek into the future for now we will still keep the IDS here inside of our add new pizza call but my goal is to get us to a point where we can submit a partial Pizza object without the ID and have the function handle adding the ID for us but for now we'll skip that part pause now and work on the challenge so I might want to come here and say let's call it next Pizza ID and we'll start it off at 1 and then up here instead of one I can say next Pizza ID plus plus and check it out we're getting an error from typescript you probably already know what this is but if we hover over this it says the block scoped variable next Pizza ID is used before its declaration variable next Pizza ID is used before being assigned and yes it is down here on line 22 we are defining that and because of the way hoisting and everything happens in JavaScript this would actually need to be above where we're using it so let's just move all of these Global variable declarations up here to the top and then we should be fine typescript is already helping us out okay we'll do the same thing here and there and down here when we're adding new pizzas we will go ahead and do the same thing down here at the bottom I am still console logging the menu and then a couple other things that we actually don't care too much about right now okay so I'm adding three new pizzas down below I am still console logging the menu we'll comment these other ones out for now and let's open our console and hit save and perfect we have our menu with all seven items in it now let's address this issue where it seems a little strange that we are providing a pizza object but we are in charge of ensuring that the ID is being handled correctly it seems like the add new pizza function should be able to handle that for us so I want you to test that out I'm going to write this in as a challenge okay I'm calling this challenge part 1.5 because there's a topic in typescript we still have to learn in order to do this without typescript complaining at us so as you'll see in the note you're still going to run into typescript warnings that we are going to address soon but the code should still run if you do it correctly the goal is to make it so that we don't have to provide this ID property when we're adding a new pizza we just have to provide the information that's specific to the pizza and we can move the assigning of the next Pizza ID inside of the add new pizza function as an implementation detail of this function it's not really something that we should have to think about when we're adding a new pizza to our menu we really only want to provide the details that are specific to the pizza okay I think you should be ready pause now and work on this challenge okay well the pizza object that we are about to receive will be essentially the same as before but without an ID and so I'm going to before I push it to the menu we're going to say pizza object. ID is equal to next Pizza ID and then we'll use the plus plus trick to increment it to the next number so that the next time it runs it's already changed and then this is where typescript is going to yell at me I'm going to get rid of these ID properties in the objects that I'm passing and sure enough typescript is screaming at me here it says that I'm missing a property in the pizza object and I'm typing this as a pizza object but let's go ahead and hit save and we open up our console and sure enough we get the same results that we had before we have the seven pizzas in our menu and they have an incrementing ID just as we would expect okay next let's address why typescript is screaming at us and how we can fix it in this lesson we're going to talk about something called utility types but in order to set this up I'm going to have just a really quick challenge for you you can see here we have a user type this is something we've seen before we have an array of users that are typed as an array of users and your task is to create this update user function and what it should do is take a number ID as its first parameter and the second parameter is an object that we're calling updates and this object will not be a full user object it's going to only contain the properties that you want to change I've explicitly typed these as any just so that for now we can turn off typescript then we're going to learn about utility types so that we can type these the correct way and actually you know what just to follow my own advice this should be typed as a number because that's not really what we're going to be talking about in utility types now I've given you the instructions on how to do this this is intended less to be about doing algorithmic thinking and more to just get your hands on the keyboard and make sure that you're staying active in this course so you'll simply use the array. find method to get the correct one based on its ID then you'll use object. assign so that you can update the found user just right there in place if you aren't familiar with object. sign or you're a little bit resy on it you can do a quick Google search to find how to use it okay pause now and work on this challenge okay let's go to we'll say users. find and this is going to return a user we'll call it found user and this will take a function a callback function will say for every user that we're looking through we want to find the one that has the user ID that's equal to the ID that's passed in here in the update user function okay we can move this comment up there let's go ahead and handle the scenario if there is no user so if there's not a user and this should be a found user let's just put something in the console we'll say user not found and then we'll make sure to return so the rest of the code can't run okay and then we'll use object. assign this will just change the object directly in place this may or may not be the best way to handle it but it's the most straightforward way so we'll set the found user as the starting object and then we'll replace any of the properties that are found in this updates object we can get rid of this comment and yeah we're console logging users down here let's run this code and let's see we're specifically looking for the user with the ID of one and sure enough the username is now new John do and the last one with the username of Charlie Brown does have the role of contributor instead of member perfect okay why are we talking about this well obviously as I've mentioned we shouldn't be using the any type here however we're not able to use user as our type here because we're not providing a full user object it's also important to know that because we don't know which property is going to be passed to this function or potentially multiple properties we can't come up and just create a new type like an updated user because what exactly are we going to put here we could say that it's going to be a username that's a string but then what are we going to do if it's a Ro change instead well you might be thinking well what if we just take every property from user and we make it optional so we say I don't know maybe there's a way that we'd ever want to update an ID we'll say well the ID could be a number and we'll put the question mark here to say that that's an optional update and we might have a username so we'll set that as optional and we'll say that's going to also be a string and you know what this is pretty much a lot of duplicated stuff so I'll just go ahead copy this one down put a question mark there okay great well we've done quite a bit of extra work here we would then be able to say this isn't going to be a user it's going to be an updated user now we come down and we can see that typescript is no longer complaining not only that but we run our code and things are working like they were before well this was a lot of busy work imagine if we had a type that had 15 properties on it that'll be a bit annoying to have to copy those over and just make everything optional and at least as far as this code is concerned we're only using this type in one place right here for our update user function so this is where the ccept of builtin utility types comes from in typescript there are a number of types that like a function they can take other types in as a parameter and they will return a new type that you can use with a few changes made to it and these are things that are built directly into typescript their whole goal is to perform some commonly needed modifications to existing types so that you can continue to work within the typescript system kind of like we did here instead of creating updated user manually by copying all of the properties and then making them optional we can use a utility type to accomplish this we're going to talk about that in just a second the other thing to know about utility types is that they use something called generic syntax which uses angle brackets now this is just touching the surface of that we are going to talk about generics very soon in our case here with the update user function we can use a builtin utility type called partial and what the partial type does is it takes in the type that you pass to it in our case we want to make a modification to our user type that we built and it returns turns a new type that has all of the properties set as optional that should sound familiar cuz that's exactly what we just did manually if you want to learn more about the partial type click on the screenshot here this will take you to the typescript documentation specifically on the partial type okay what does that look like well instead of manually typing this out I'm going to use the builtin type called partial it's got a capital P and I use that angle bracket syntax that we saw right here because this partial uses something called generics again we're going to talk about that in the future but you can kind of think of it like if partial were a function you would normally put parentheses but because it's a utility type and not a function we use angle brackets instead and we pass our user type in as a you could call it a parameter or in this case it's really a generic type to this partial and as we saw what it does is it takes this user in and it returns a new type which we're calling updated user and if you go ahead and hover your mouse here over updated user you will see that it has a type already defined for us where all of the properties ID username and role are set as optional this way when our update user function takes an updates object and its type is updated user we can provide an object that is missing some of the properties from a user object we've used this partial utility type to minimize some of the boilerplate code that we would have had to write manually ourselves if you take the time to go over to the documentation by clicking the screenshot you will see that there are a ton of builtin utility types tyes in typescript and so this might be a good time to click this if you didn't already just peruse those play around with the code that you see here feel free to come up with different examples we are going to talk about one other utility type because it's going to directly relate to what we're working on with the pizza restaurant app but there is a small caveat that we'll need to work around we'll talk about that in the next lesson this lesson's going to be nearly identical to the one we had before but as another way to to drive forward the curriculum in learning a new utility type to start off to make sure your hands are on the keyboard and that you're awake as you're going through this course I'm going to have you create the logic for a new add new user function it's going to take a new user object and in this case the new user object will not have an ID provided to it as you can see in the example usage down here it will have all of the properties except for ID so for now I've typed this as any and the return for this function needs to return an actual user object that does have an ID read through the comments here to see the specifics on how to create that it basically tells you exactly what to do and when you're done the typescript errors should go away but then we'll address this issue with having an any type here also for Simplicity I've added this next user ID variable and added it to our users array just so that you can continue to use next user ID Plus+ like we were doing in the Pizza app and I've also shortened this users array just so that there's not quite as much clutter when we're console logging the array of users okay you should be set up pause now and work on this challenge we can pretty much just follow these steps exactly as they're said so we'll call a new variable user and I'm actually going to type this as a capital u user the goal is to make sure that it conforms to the user object type okay this is going to be an object and the first thing I'll do is add an ID property to it we'll use the next user ID Plus+ to get that in there and then I'm just going to spread all of the properties of new user into this object now that I have a new user object or a user object that is new let's go ahead and push it to the array of users we'll say this is users. push user and return the user objects okay now the typescript warning under user is gone because now this function is returning a user as the type would indicate it's supposed to let's clear out the comments here and do just a quick test we're pushing Joe Schmo who is a role of member and sure enough there he is at the end of our users array with I might add the ID of three which is what we wanted this might be a good time to remind everybody watching this that this whole next user ID thing that we're doing it's really just to drive our curriculum forward you're very likely to have your database handling the whole ID assigning thing okay now let's address this any type here we don't really want this to be in any type because as it currently stands we've disabled typescript checking for this and I could just add a blah blah category or property to this object and typescripts not going to warn us that this isn't going to work or rather that it could really screw up our code so what exactly can we do well we just learned about the partial type and it might seem at first glance that we could make this into a partial of user however the problem with the logic here is we want to make sure that all of the properties exist and with partial it turns everything into an optional property let me get rid of this blob property here if I submit this as a partial like this of user and then for some reason I don't Supply one of the properties here I have a problem I've taught this function that it's going to return a full user and as you saw even before I deleted the RO property here we have a warning and it essentially tells us that these are not going to be compatible that's because we need to return a user and our user property needs to have up here it's not optional to have an ID a username and a role but our partial user type here it is possible to not have one of those things because all of the properties are optional okay so partial is not really going to work for us there is a way clearly that we could make partial work but we would have to do a bunch of extra checking inside of the body of our function and that's not really the road that I want to go down enter the omit type what does the omit type do well it takes in a type just like partial but it also takes you could call it a second parameter to that utility type which will be a string or potentially a union of strings we'll see what I'm talking about in just a second and those strings are the property names that we want to Omit from this type it's going to return a brand new type with the properties that we specified removed it would probably be a great idea to go to the documentation on the typescript docs you can click the screenshot that you see here which should take you directly to the omit type docs so what does this look like for us well often times especially if you're only going to be using this utility type once in your code you can just do it right in line so I can use capital O omit a set of angle brackets and I first need to provide as the first parameter you could say the user type or the type that I'm trying to modify and then just like in function parameters I'm going to add a second parameter here and that is going to be a string of the properties that I want to Omit from the user type so that the type that omit returns will not have the ID property in it okay why is typescript warning us about capital O omit well we come to another point of some irony the omit utility type is currently omitted by scrimba well more specifically in reality it's just that omit was introduced in typescript version 3.5 scrimba is currently running on an older version that doesn't yet know what omit is in the future I'm going to be able to remove this whole caveat but for now I'm just going to show you a screenshot of what it should look like so we have our code exactly like we see here and notice that typescript is not warning us about anything I guess as a reminder typescript doesn't stop us from running running our code there are ways to set it up to do so but I can hit save I can open my console we can see that our joeo user has been successfully added to our array but let's look at what it's supposed to look like if I were to for example comment out the ID property we can see that we have an error on the user object if we hover our Mouse over it we can see that the property ID is missing that's exactly what we would expect now I don't have a screenshot of this but if we were to take away one of the properties when we're calling add new user we would also get a typescript warning that tells us that we're not providing the correct type to our add new user function it's going to have all of the properties of user just minus the ID property that way our function can be in charge of creating the ID for our user object really quick I did mention that you can provide either a single string or a union of strings if for some reason I wanted to Omit both the ID and the username I would use a union character which is the single pipe and I would do another string literal of user which tells it that I don't want this new type that omit is creating to contain either the ID or the user in our case that means it would just be an object with a ro property again typescript would be warning us here but because it's not currently recognized by scrimba it's not giving me any other warnings okay it's time for us to get back to our Pizza app and apply what we've learned specifically about omit so that's what we'll do next let's apply what we just learned about omit to our pizza restaurant app specifically the add new pizza function your task is to fix it so that we use the omit utility type just like we did in the previous lesson we want the user of this function to provide a pizza object that does have a name and a price we don't want those to be optional because we need that information in our menu but the add new pizza function will be in charge of adding the ID to it while we're at it let's go ahead and change this function so that it Returns the new pizza object instead of void I'm just going to add that here to the requirements okay so make sure that you return the new pizza object with the ID added from the function which means you'll have to change the types here as well as a quick reminder at the time of recording this the scribit environment doesn't understand the omit utility type so you will get a little red squiggly under the word omit but you can safely ignore that and essentially any other typescript warnings you see here in the very near future scribo will know about omit so I'll be able to just remove this caveat the time is yours pause now and on this challenge again the reason we want to use omit and not partial is because we want to require that the person submit a pizza object with all of the other information except for this one property of course with omit you can omit more than one property but in our case we just want to Omit from the pizza type we want to omit the ID property like that and while we're up on this line we decided we're going to return a full Pizza object from this function currently we're not doing that so typescript is warning us now we have an issue with the way that our code currently is set up because we just told typescript that this pizza object will have all of the properties of pizza but not the ID property in other words it's going to have a name and a price and then we're trying to add an ID property on top of it well we can't do that so let's go ahead and create a new pizza object we'll call this new pizza we're going to to type it as a full Pizza object and we'll set it equal to an object we'll give it an ID property we'll use the next Pizza ID and then add the Plus+ for the next time around and then we'll spread in all of the properties of pizza object we'll get rid of this line of code and instead of pushing Pizza object we will push new pizza I can hardly believe how many times I've said the word pizza and then as we described up above we need to make sure we return the new pizza object let's hit save and we are adding a few new pizzas up here we're console logging the menu and sure enough we have the chicken bacon ranch the barbecue chicken and the spicy sausage pizzas added for the time being while scrimba doesn't understand the omit utility type I have a couple screenshots here so this is from VSS code we can see when we add the omit Pizza type up above typescript is happy with everything the exact way that it is if we comment out ID then typescript isn't happy if you hover over new pizza it tells you that you're not allowed to push this object to the menu because menu requires Pizza objects and this object that you're trying to push does not have an ID so let's go ahead and put that back in similarly if we were to come down and say remove the price from this first pizza that we're adding we get a typescript warning that is a little bit cluttered here but essentially tells you that the property price is missing now for the sake of this course I've decided that it isn't my objective to teach every single utility type that exists because the documentation is very straightforward if you want to peruse and see the different types that there are again you can click this link this will specifically take you to the omit type but it's all one long page in the typescript docks so you can scroll around and see all of the different types there but hopefully the idea is starting to be clear these utility types perform really common operations on your existing types so that you don't have to do this work by yourself and introduce a bunch of repetitive code now I did promise earlier that we would address this issue here where we have these angle brackets and I think this would be as good a time as any to jump into that which is a topic called generics so that's what we'll be learning about next I've mentioned this term generics a couple times throughout this course and so it's finally time for us to learn what generics are generics and typescript are a really powerful tool that allow us to add some flexibility to the types of our existing functions are already existing types and other aspects of typescript code you can kind of think of it like a function parameter a function parameter is a placeholder for a real value that you use throughout your function and a generic is a placeholder for a type that you can use throughout your function or whatever aspect of typescript you're using your genericon this will make a lot more sense when we see an example and generics use this bracket syntax with the angle brackets that we've seen a few times already in our code let's see a bit of a contrived example here and then we'll apply what we've learned to our pizza restaurant app let's say we have a few different arrays like we have on lines 1 2 and 3 and we want to create a really simple utility function that's called get last item it takes an array as a parameter and since this isn't really part of this challenge I'm just going to say in order to access the last item of an array in JavaScript we can just return the array at the index of array. length minus1 Okay we can see there's a red squiggly here for array hover your mouse over the word array and you'll see that it says the parameter array implicitly has an any type typescript doesn't like when we have implicit any types and so one cheater solution could be to explicitly type this as an any type and of course that makes the typescript warning go away but again that's because the any type basically turns off typescript this isn't exactly what we want the problem is we can't say that this is an array of strings or an array of numbers because we don't know that it could be an array of any item okay well what are we to do then this is where generics come in into play as I mentioned just like a function has parameters that are placeholders for values generics are a way for us to have placeholders for whatever a type is going to be okay let's check out the Syntax for generics when we're using it in a function like we're doing here right before our parentheses with our function parameters we're going to put in our angle brackets and inside those angle brackets similar to how we're doing with the function parameters inside the parenthesis we're going to put a placeholder for whatever type is going going to be used with this function a fairly strong convention for this is to use the capital letter T to represent type but just to make sure that we're being explicit I'm going to use the full word type with a capital T again this is a placeholder type the capital T type here is not referring to something that's built into typescript this is a name that I chose I could have just as easily chosen blah blah blah but let's not do that okay well what can I do with this now well just like in a function I can use the parameter through throughout the code to represent whatever value array represents when this function gets called I can use my generic type here to say the array is going to be of type capital T type and it's going to be an array of that type we've used the word type quite a bit here I think it actually might be useful for us to call this something totally different like let's call it placeholder and actually I'm going to call it placeholder type because truly it doesn't matter what it is just like the name of your variable doesn't matter what it is you can call it whatever you want as long as you're consistent throughout your code okay great let's get your hands on the keyboard this is going to be very simple with more like a mini challenge than anything this mini challenge is less about solving the issue and more about seeing what the intellisense popups are when you hover over the different values so call get last item on each of the three arrays that we have on lines 1 2 and 3 you'll probably want to console log The Returned value just so that something shows up in your console and then the main thing I want you to focus on is hovering your mouse over different values in the code just to see what the intellisense popup shows so that you can get a better idea of what's going on with generics pause now and work on this mini challenge okay so let's get our console logs in here we'll just do three of them I'm going to use multiple cursors to save some time we'll call get last item and then we will put in our three different raise okay we'll hit save just to make sure that's working the way we expect great we don't actually need to see the values right now but let's hover our Mouse over maybe game scores first okay we can see that it is typed as an array of numbers that's a type that was inferred by typescript because of course we didn't explicitly type it as an array of numbers we can see the same thing with favorite things it's an array of strings and with voters it's an array of object literals okay now let's hover over get last item for this first call with game scores it shows that that it's a function called get less item and as its type inside of the angle brackets it shows number and then it used that number type to infer that array the parameter array is an array of numbers it also inferred that it's going to be returning a number as well which we didn't explicitly place here we'll do that in just a second but if we hover over this second get last item we'll see it does the same thing but with strings and on the third one it does the same thing but with that object literal with a name property and an age property doing this allows us to write types and in this case functions that can be a lot more flexible and still have some type safety without us using that any type which just turns type safety off completely now this is bothering me a little bit that it says placeholder type I'm going to go back to say type and again a really strong convention is just to use the letter T and other single letter variables which is kind of funny now that I think about it because we tend to tell people not to use single letter variables for things if you want to dive a little bit deeper into generics there is quite a bit more than what we covered in this lesson and frankly more than we're going to cover in this introduction to typescript course but you can click on the screenshot here to go directly to the typescript docs and it will show you some additional examples there that might help solidify the concept in your mind okay now I mentioned that if you hover your mouse here it says that it inferred the return type as a number but we can also do that explicitly however I want this to be a challenge even though I haven't really taught it to you yet this will hearken back to when we talked about explicitly typing function return values but with a little extra twist as we are using generics as our type pause now and see if you can figure out how to explicitly type the return value of this function in any other kind of function we put a colon after the parentheses of our function definition and we specify that this for example would be a number or something like that in our case though because our function needs to be more generic than just using numbers we can use that placeholder type generic type here as our return value it's going to be a single item of whatever type this function is currently using when it's being called now if we're really covering our bases we might also want to ensure that we know this could potentially be undefined as long as we spell undefined correctly and that might happen if we have an array of length zero all right nice work let's move on to the pizza restaurant app and see how we might apply something like this to that app the challenge that we're going to do in this lesson is purely going to be for practices sake I had to make a few changes to other parts of our code so that this very generic add to array function would work for our purposes in learning generics so once we've completed this challenge we're going to revert back to the old code we can just think of it as a refactor that's gone wrong I know the Syntax for generics can be quite a bit confusing so I wanted to make sure you got your hands on the keyboard again to type this out your challenge is to add types to this add to array function as you can see from the example usage it's essentially replacing what we had before with add new pizza and place order this is primarily where I made the changes to our old code which was using the omit utility type now we're just going to call add to array we'll provide the array that we want to add to and then the object that we want to add to that array once you've added the generic types to this function the red squigglies under array and item should go away and you should be able to console log our menu and our order queue and see these new items added to those and actually that reminds me I'm going to get rid of these so we don't have any duplicates and yeah okay pause now and work on this challenge when we're adding generics to a function right before the parenthesis we will add our angle brackets and we'll put our generic type this time I am going to use the single letter T because that does tend to be a pretty strong convention that you'll see with our array we're going to assume that it is an array of type T whatever that is in our case it's either going to be a pizza object type or an order object type which we have right up here at the top and item is going to be a single item of that same type maybe you can see why I'm saying this gets a bit confusing because we have a bunch of new characters that usually we don't see in the middle of JavaScript functions and here we can see the code says we're returning an array I suppose that will just be the new array after it's been modified and so if we hover over add to array we can see that typescript is already inferring what it will return but if we want to be explicit we can say it's going to return an array of type T let's go ahead and console log our menu and we'll do the same thing for the order que and let's see what shows up okay it's a little hard to parse but the first one that shows up in the console shows that chicken bacon ranch was added as an option on our menu and our order CU has just one item in it that is the one with the pizza from the menu at index 2 let's see that is our Hawaiian perfect we can see that the generic add to array function is correctly passing this type on if we do something like trying to add another random property to this we will get warned and it says that the object literal can only specify known properties and the property blah does not exist in the type pizza now one thing before we move on I do want to point out a little bit of a shortcoming when it comes to using our fun functions that are using generics these example usages seem to be working fine but if you remember on our order type which we have up here the status is only allowed to be the string ordered or completed but check this out if I come and I change the status see right here to something like done well typescript isn't complaining the reason it's not complaining is pretty easy to understand so we'll touch on it and fix this problem really quickly in the next lesson we have a small bug in our code and typescript is not warning us about it that's where we added our status of done even though done is not supposed to be a valid status for order types so what exactly is going on here well when we defined our generic function and we told it it was going to have generic types that it needed to use as the type throughout the rest of the code for this function when we're calling add to array both here and here we are assuming that typescript is going to be bble to implicitly infer what type it needs to use as its generic type if you hover over add to array right here on line 49 we can see that it says the generic type that it's going to take is an object literal with an ID that's a number a name that's a string a price that's a number and a bunch of other things that shows what the menu is typed as and everything like that let's do the same thing for the add to array on the order queue again make sure you're following along and hovering your mouse over this otherwise what I'm about to say will make absolutely no sense the intellisense popups shows that it's a function called add to array its type is an object with an ID number a pizza that is a pizza object type and a status that's a string interesting our status is a string but it's supposed to be the union of just these two literal strings and that doesn't seem to have come through when we're calling add to array with the order Q this is another case where it can be really helpful for us to explicitly type what the generic type we're passing into this function is to do that we essentially follow the same syntax that we had when we were defining the function right before the parentheses where we provide the parameters for this add to array function we can explicitly type it with the same generic syntax of angle brackets now this is where things can get a little tricky if this has been a bit of a challenge for you to understand so let's make this into a mini challenge just to help solidify it okay the mini challenge is to figure out what should be typed right here between the angle brackets as the generic type here here on line 53 pause now enter in the type you think should be put here between the angle brackets and when you do so the red squiggly should limit itself just to the object here at the end because done is not a correct property pause now and give that a try because in this version of add to array we are dealing with orders in the order CU we have a predefined capital O order object and when we add that in now typescript seems to be able to understand that something is not quite right with this object if we hover over add to array now instead of having an object literal as everything it has explicitly typed it as orders arrays of orders and so forth and if we hover over here we can see that the popup tells us the types of property status are incompatible specifically done is not allowed here it needs to be something like completed once we change it to that awesome everything is working and typescript is happy in fact if you typed this out yourself you you could start to see and this isn't going to be in the recording but if you pause it and start typing the word completed it does show up as an autocomplete option because typescript allows us to have these autocomplete options I can just hit enter and finish off the now valid completed string as our status it's probably not even worth making this a mini challenge if I do want to explicitly tell this add to array what type it should be I can again just put my angle brackets type in capital P Pizza and everything will be happy there if you want you can see the difference now hovering over add to array it tells us that the generic type is a pizza type whereas when it was gone it tried to infer exactly what that type should be and it had an object literal in our case I don't think it would make too much of a difference because we don't have anything in our pizza type like we have here with our status but once again I think both for your own readability the readability of other people looking at your code and to help typescript out a little bit it really does help to explicitly type your generic functions like this all right that was a lot of work you should give yourself a big round of applause pat yourself on the back do a little dance a little celebration we are just about at the end of this first section of this typescript course as always play around with the code I'm going to revert this back to the way it was as fun as adding this add to a ray generic function was I'm going to revert our code back to the way it was before because it was just better that way once you're feeling good let's keep moving forward and there we have it folks we are at the the end of this first section for this typescript introductory course obviously we haven't hit every last little aspect of typescript but let's recap what we have learned of course we started off by understanding basic literal and custom types in typescript then we moved on to how you can create optional properties in your typed objects we learned about unions and how you can combine multiple different types into a single type which naturally led us to learn about type narrowing so that we can narrow down which of those Union types we're using inside of our code as a side note I feel like the code we wrote when we were learning about type narrowing is a great example of how typescript really helps you learn to think more like a senior developer thinking of all the edge cases that you can while you're writing your code then we learned about a couple of the builtin utility types that give us some extra functionality in modifying our existing types in a really userfriendly way and we CT everything off by learning about generics which allow us to have additional flexibility inside of our typescript code now as I mentioned this doesn't represent everything that there is to learn about typescript and something that I'm going to be doing with this typescript course is adding to it over time so there actually is more to come at the time that I'm recording this what you've watched is everything that we have but I do plan on adding a few extra topics in this section that you just watched as well as adding entire new sections more specifically one that's focused on how you use typescript while you're writing JavaScript code that interacts with the document object model or the Dom so if you haven't already you should should subscribe to scrimba newsletter and whenever I make a major update to this course I'll make sure that we email out an announcement of those updates until then I've been your teacher Bob zero if you want to follow me on Twitter or X you can click the link that you see here my username is Bob zero so pretty easy to remember and until next time good luck and happy coding
