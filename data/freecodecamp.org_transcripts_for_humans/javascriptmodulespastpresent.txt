With timestamps:

00:04 - [Music]
00:07 - good evening everyone
00:09 - thank you first of all to vijay for
00:11 - having me back i was with a group of
00:13 - developers who worked on a react open
00:16 - source project having to do with server
00:17 - side rendering and we had a lot of fun
00:20 - speaking together it was five of us
00:22 - passing off the the speaking roles back
00:24 - and forth for the course of the meetup
00:27 - so this time i'm holding down the ford
00:29 - alone but i'm excited i'm very excited
00:32 - to have a chance to nerd out with you
00:34 - guys for a little bit about javascript
00:37 - modules
00:38 - and this is a top topic that i think is
00:40 - particularly fascinating because when we
00:43 - look at the history and the development
00:45 - of modules in javascript we're kind of
00:48 - going in parallel with
00:50 - we're tracing
00:51 - the history of javascript growing as a
00:54 - language from kind of humble origins as
00:57 - this lightweight scripting language that
00:59 - was running in netscape to really
01:02 - becoming a powerhouse that gives us the
01:04 - modern web with all of its interactivity
01:06 - and
01:07 - everything that we love about it so now
01:10 - we're basically in an era where
01:12 - we have javascript running everywhere
01:14 - universal javascript javascript on the
01:16 - client and on the server side um on
01:20 - we have it in our thermostats even
01:21 - flying drones for us so needless to say
01:24 - javascript has come a very long way
01:26 - and so have modules
01:30 - oh and the pronunciation of my name for
01:33 - uh anyone who might have been wondering
01:35 - is meijin rhymes with regen so
01:38 - just
01:38 - well anyway
01:41 - so the first thing that i would like to
01:43 - posit is that modules are a fundamental
01:46 - part of our lives as javascript
01:48 - developers they're kind of part of the
01:51 - scenery
01:52 - so i do a lot of my day-to-day work in a
01:54 - react code base so when i fire up my
01:56 - code editor many of the files i'm
01:59 - looking at have kind of a predictable
02:01 - structure
02:02 - i see some import statements at the top
02:04 - some export statements at the bottom
02:06 - i almost don't even think about them i
02:09 - mean unless i've
02:11 - put a typo in my file path or something
02:13 - and i then i am thinking about them but
02:15 - um i imagine there are other folks in
02:16 - the room working in other frameworks and
02:19 - working in other
02:21 - type code bases and environments
02:24 - so
02:25 - modules and modular thinking are kind of
02:28 - second nature to us and that's really
02:30 - how it should be modules are supposed to
02:33 - make our lives easier as developers they
02:36 - do this by giving our code
02:38 - structure
02:39 - and boundaries so that way we don't have
02:42 - to think about all of the moving parts
02:45 - i don't have to have the react source
02:46 - code mingling with my component logic i
02:49 - can take a grand take for granted that
02:51 - it's going to be available for me and do
02:54 - what i want it to do most of the time
02:57 - so for now it resides elsewhere out of
02:59 - sight
03:00 - and out of mind
03:02 - and this is especially important as code
03:04 - bases get bigger
03:06 - so when we hear about terms like
03:08 - modularity and separating concerns
03:11 - that's really
03:12 - about our sanity as developers who are
03:15 - working with each other and working with
03:16 - a lot of code
03:20 - so let's start out and get on the same
03:22 - page as far as our
03:24 - concepts and terminology we'll start
03:26 - with the basics what's a module anyway
03:29 - i like to think about modules as
03:31 - building blocks of data
03:34 - and functionality
03:35 - and
03:36 - we can bring them into a program
03:39 - and we can also make them available to
03:41 - other programs
03:42 - and ideally you can kind of treat them
03:44 - like you would building blocks and
03:46 - hopefully you can add or remove pieces
03:48 - from the hole without
03:50 - the whole structural integrity falling
03:52 - apart
03:54 - so when we're talking about modules
03:56 - we're really talking about the higher
03:57 - level design of our software we're often
04:00 - thinking about modules in terms of a
04:02 - single file because that's typically how
04:04 - we organize our modules one module
04:07 - one file
04:09 - we can also talk about modules in terms
04:11 - of their relationships to other modules
04:14 - so
04:14 - a module has an interface and that's
04:18 - its exposed bits
04:20 - that let us have data and functionality
04:22 - available for use in other programs
04:25 - i kind of like to think of the module
04:27 - interface
04:28 - as the little bumps on the top of a lego
04:31 - brick so
04:32 - you can try to put your lego bricks side
04:34 - by side and they won't really stick
04:36 - together but those little bumps which i
04:39 - actually just found out are called studs
04:41 - lego studs
04:43 - are how we actually get our structures
04:46 - to stick together and so module
04:47 - interfaces are a little bit like that
04:49 - and a module can also have dependencies
04:53 - and often that just means that we're
04:55 - dealing with other functionality that
04:57 - we're relying on
04:59 - to
04:59 - have the functionality of whatever
05:01 - module we're working in
05:05 - and so just to have a hammer at home in
05:07 - case there's any ambiguity about my
05:09 - personal position on this modules are
05:12 - awesome they help us to keep organized
05:14 - code bases especially as those code
05:17 - bases are growing in complexity
05:19 - they help us
05:21 - resolve our dependencies making sure
05:23 - that any pieces of code are supposed to
05:25 - be there and we don't have to worry
05:26 - about getting them all in the right
05:28 - order
05:29 - they also help us to share and reuse
05:31 - code so we have a wonderful thing called
05:35 - npm that gives us
05:37 - access to literally i think 700 000
05:39 - packages right now
05:41 - a lot of packages of code and we
05:43 - ourselves can be part of a community
05:45 - contributing to that global repository
05:48 - alongside others
05:49 - so kind of cool
05:53 - but
05:54 - before we go any further there is
05:57 - an elephant in the room and
06:00 - we should acknowledge it
06:02 - so these modules which i've been talking
06:03 - about and that are so fundamental to
06:05 - modular to modular and modern
06:08 - programming are actually
06:10 - just barely
06:12 - a part of javascript they weren't built
06:14 - into javascript pre es6
06:17 - so for most of its years
06:19 - as a language javascript didn't have any
06:22 - kind of built-in
06:24 - native module system so this is unlike
06:27 - python for example
06:29 - and so modules only really recently
06:32 - became part of the language and they've
06:34 - actually only just landed in modern
06:36 - browsers like as of this year
06:40 - so oftentimes when we're working with
06:42 - modules we're not working with the
06:44 - built-in module system at all
06:47 - we might be using require statements if
06:49 - we're working in node or com.js
06:52 - we might be using import statements like
06:55 - i showed earlier from react code we
06:57 - might be using valve to transpile them
06:59 - down to es5 and then
07:02 - to bundle those files that were all
07:05 - supposed to be separate into a single
07:06 - one for consumption by the browser um so
07:10 - what's going on
07:12 - well this is where i started getting
07:14 - curious like what how did we work for so
07:17 - long without modules in javascript
07:20 - and as i started to take a peek into the
07:21 - history i found that there was this
07:24 - overarching storyline that javascript
07:26 - was
07:27 - really built disadvantaged when it came
07:29 - to modules it wasn't built with any kind
07:31 - of modularity in mind
07:33 - when it was first invented it was just
07:35 - supposed to be lightweight scripting
07:37 - inline scripting
07:38 - and over time as
07:40 - more demands were made of javascript as
07:43 - a language to do more for us
07:45 - we see an increasing need
07:47 - so running in parallel for
07:49 - usable module systems
07:53 - so i like to think of the history of
07:56 - javascript as unfolding in four phases
08:00 - i made these up so
08:04 - i call it the pre-module era the
08:07 - do-it-yourself module phase the
08:09 - specification phase and the
08:10 - standardization phase and because it is
08:14 - something i made up and because it is a
08:16 - system of chronology it is not perfect
08:19 - not precise but what i was aiming to do
08:22 - and kind of
08:23 - splitting
08:24 - our timeline into these four segments
08:26 - was to bring some order
08:28 - to overall trends that we were that were
08:31 - taking place
08:32 - so i'll do a little fly over right now
08:35 - before we jump in and get into more
08:37 - detail for each of those phases but
08:40 - let's start at the beginning in the
08:42 - pre-module era when modules were not
08:45 - really a thing at all javascript didn't
08:47 - itself have much of an identity or much
08:50 - respect let's be honest at that point
08:52 - it was nothing like it is today
08:55 - that didn't last too long
08:57 - before we started realizing that we
08:58 - needed some kind of modules but in the
09:01 - absence of those built-in modules we
09:03 - were improvising we were making
09:06 - module type structures ourselves
09:09 - so
09:10 - uh
09:11 - roughly in 2011 we start to see module
09:14 - specifications growing in popularity
09:18 - the javascript community especially the
09:20 - service server side javascript community
09:22 - was really starting to take off
09:25 - and a lot of work had to be done just to
09:27 - make javascript the language people
09:28 - wanted to develop in
09:30 - and a big part of that was just coming
09:33 - onto the same page
09:35 - so that's also kind of our era of
09:39 - single page apps and frameworks like
09:41 - backbone and angular starting to come
09:43 - into vogue
09:45 - and finally today
09:47 - we have arrived
09:49 - in the era of standardization and that's
09:51 - the phase that is currently underway
09:54 - and i hate to spoil the plot
09:56 - right at the beginning but javascript is
09:59 - still pretty far from having a
10:00 - standardized module system
10:02 - we do have a standard system in place
10:04 - but we're still working out the kinks
10:06 - and we're still making things
10:08 - hold together in the ways that we hope
10:11 - that they will so that one day
10:13 - we will all be
10:16 - gloriously developing with modules and
10:19 - not having to think about all the uh the
10:22 - quirks that go with with trying to do
10:24 - that
10:26 - all right
10:28 - so
10:29 - let's begin our tour
10:31 - we begin
10:33 - in a time before modules
10:36 - javascript's age of innocence
10:40 - and as we peek into the yearbook
10:43 - dun
10:44 - dun we come across gems like this
10:49 - so totally 90s and i'm calling this the
10:51 - dark ages but really i think we were
10:54 - probably having a good time
10:56 - um
10:57 - anyone had a geocities
10:59 - website
11:02 - i sure did
11:04 - i think it was called like the raspberry
11:06 - garden or something
11:08 - it was like 12 anyway it had all these
11:10 - cool neighborhoods like soho and sunset
11:13 - strip and times square and i guess you
11:15 - can go to the wayback machine if you
11:17 - want to
11:17 - have some nostalgia but anyway
11:21 - as i'm looking at this specimen from the
11:24 - archives i think i'm seeing at least for
11:26 - sure
11:27 - one definite use of inline scripting
11:30 - which is probably like this fun little
11:32 - animated
11:33 - status bar that's going it's crossing
11:36 - the screen for your entertainment
11:38 - um
11:39 - anyone spot any others
11:42 - that's the only one that i feel like
11:44 - kind of confident on
11:48 - what a time
11:50 - what a time
11:52 - but
11:53 - anyway yes a wild west of inline
11:55 - scripting and script tags
11:57 - no modules to speak of really
12:00 - a question i want us to start thinking
12:02 - about is
12:04 - um
12:05 - is this scalable what are some of the
12:07 - problems we encounter in this wild west
12:11 - scenario
12:14 - well i'll say more about that in a
12:15 - moment
12:17 - but
12:18 - first let's get one thing straight
12:20 - at this stage in the game no one was
12:22 - really thinking about thinking about
12:24 - scalability that was not the name of the
12:26 - the game and if you don't take it from
12:28 - me take it from the inventor of
12:30 - javascript himself mr brendan ike i hope
12:34 - i
12:35 - hope he pronounces it that way too i
12:37 - could i could be butchering it but he
12:38 - did say in an interview with infoworld
12:42 - that no one thought
12:44 - javascript would be used at the wide
12:47 - scale that it is
12:49 - not just reaching lots of people on the
12:50 - web
12:51 - but large applications like gmail
12:55 - to write large code you don't just want
12:58 - this little snippet language that i made
13:00 - for beginners
13:02 - beginners
13:04 - you want strong apis and ways of saying
13:06 - hey this is my module and this is your
13:09 - module
13:10 - and you can throw your code over to me
13:12 - and i can use it safely
13:15 - so a quick trivia question does anyone
13:17 - know what your javascript was invented
13:24 - 95
13:25 - or did you say 95 that is exactly right
13:29 - over the course of 10 very intense days
13:32 - for
13:32 - mr ike and um
13:35 - i think his original instructions from
13:37 - netscape were actually to
13:39 - have a language that was a lot more like
13:42 - scheme for the browser
13:44 - so
13:45 - if anyone's worked with scheme which is
13:47 - kind of a dialective lisp you know it
13:49 - looks
13:50 - completely different from the javascript
13:52 - we know and love those instructions
13:54 - those marching orders changed
13:56 - significantly and
13:58 - i feel grateful for that
14:02 - so in the in 2006 we get the first of
14:05 - several manifestos that we will see
14:09 - um
14:10 - so this particular
14:12 - manifesto came from the yahoo user
14:14 - interface team in a blog post with the
14:17 - title
14:18 - global domination
14:21 - and they had a good point i would say
14:23 - and the point that they were trying to
14:25 - make is that global variables are
14:28 - a terrible risky practice that we're all
14:30 - engaging in
14:31 - this unsafe behavior that we're all
14:33 - engaging in
14:35 - but um
14:37 - in growing code bases we really had to
14:39 - cut cut cut that out
14:41 - and so what's the problem
14:44 - well
14:44 - global variables are notoriously
14:47 - unreliable and insecure and there are a
14:49 - few reasons for that and the first has
14:51 - to do with variable naming collisions
14:53 - so assuming mary and george
14:56 - on the u
14:57 - on the ue dev team are working on the
14:59 - same code and name to the very their
15:01 - variable the same thing
15:03 - they were likely to run into trouble
15:06 - pollution in the global name space
15:09 - and globally scoped variables are
15:12 - just well they're just really easy to
15:14 - break or to
15:15 - forget that they even exist
15:18 - and secondly because they're exposed
15:21 - they're not secure so it's not just
15:23 - co-workers who might innocently bump
15:24 - into each other in the global namespace
15:27 - dance floor
15:29 - third-party scripts and malicious code
15:31 - might join in the fun and
15:33 - global variables are a vulnerability
15:35 - that we generally want to avoid
15:37 - especially if we're yahoo and we're the
15:39 - big guns in the game in the mid 2000s
15:42 - so the ue team actually went as far as
15:44 - to say that an objective measure of the
15:48 - quality of a javascript program is
15:50 - how many global variables and global
15:52 - functions does it have
15:55 - a large number is bad because the chance
15:57 - of bad interactions with other
16:00 - programs goes up
16:04 - and a few other issues were cropping up
16:05 - in this era in this pre-module era
16:08 - whenever you wanted to reuse code you'd
16:10 - likely be doing some kind of copy-paste
16:12 - job and then following the trail of
16:14 - breadcrumbs wherever it led you and
16:17 - anytime you tried to update your code it
16:18 - would likely be a logistical nightmare
16:20 - as you tried to find all the pieces the
16:22 - places where you needed to update it
16:24 - dependencies were a hassle to manage
16:26 - especially if you were dealing with
16:28 - version control you had to worry about
16:30 - putting your script tags all in the
16:31 - right order
16:33 - and
16:34 - basically as code bases were getting
16:35 - more complex
16:38 - we needed a way to manage them better
16:42 - so let us set foot into the next era
16:47 - do-it-yourself modules and in the second
16:51 - phase of javascript history
16:53 - not all of the problems from the
16:55 - pre-module era were going to go away
16:58 - right off the bat
16:59 - but we'll start to see some of them
17:01 - being addressed particularly the problem
17:03 - of global variables because that was an
17:05 - immediate concern
17:07 - so this insight about needing to limit
17:10 - global variables actually spurred a ton
17:12 - of innovation um with
17:14 - an improvisation really with what was
17:16 - possible within the constraints and
17:19 - flexibilities
17:20 - of the javascript language
17:22 - and this was really an era of
17:24 - transformation for the web
17:26 - we're really moving away from the
17:28 - geocities model of static websites we're
17:30 - moving toward more interactivity and
17:33 - ajax requests were becoming more of a
17:35 - norm during this period
17:37 - jquery hit the scene during this time
17:38 - and the web was really starting to grow
17:41 - up a little bit from websites to web
17:44 - apps
17:45 - and so let's just keep that in mind as
17:47 - we start to look at some of the ways
17:49 - that people addressed
17:50 - the shortcomings of living in a world
17:53 - without modules
17:57 - we'll pick up the story where we left
17:59 - off with our friends at yahoo who had
18:01 - just declared that global variables are
18:04 - evil
18:05 - and their answer to this problem of
18:08 - global variables was actually just to
18:10 - restrict them let's let's stick with a
18:11 - single object
18:13 - with god-like status the yahoo object
18:16 - and the aim of the yahoo global object
18:18 - was
18:19 - literally to contain all of yahoo
18:23 - their state their and all of their
18:25 - webstate and being in all caps you can
18:27 - tell that it was
18:28 - very important it was the global
18:31 - so
18:32 - if you wanted to do anything you would
18:34 - say
18:36 - yahoo.util.dom.get or whatever it might
18:38 - have been you were somehow crawling
18:40 - through this object tree to find
18:43 - find what you wanted
18:45 - and
18:46 - jquery might be a more familiar example
18:48 - you might remember having to have the
18:50 - jquery object
18:52 - in available in globe global
18:56 - but as
18:58 - as much as this
19:00 - approach was touted as great practice
19:02 - there were definitely downsides to it
19:03 - too so
19:05 - it was still relying on a global
19:07 - variable a single one that could have
19:09 - been rewritten with a single line of
19:11 - code and then poof
19:12 - potentially everything could be gone
19:15 - there was still no code reusability
19:17 - and really no help with dependency
19:19 - management or versioning
19:22 - but you were starting to mitigate some
19:24 - of the risks of just having
19:26 - free range global variables
19:30 - so the basic structure of the namespace
19:33 - approach looks kind of like this
19:36 - we've got an object literal here and
19:38 - we've got some properties on it some
19:39 - data
19:40 - and some functionality
19:42 - and um
19:44 - we can assign those additional
19:46 - properties
19:47 - additional data
19:48 - um
19:50 - while we're declaring that namespace
19:53 - object or after the fact
19:55 - with our handy dandy dot notation
20:00 - and
20:02 - let's look at another approach that
20:04 - started coming up in this area era and
20:06 - that's the module pattern
20:08 - and the essence of the module pattern
20:10 - is
20:11 - being able to use
20:13 - an immediately invoked function
20:15 - expression
20:17 - with the power of closure so
20:20 - the power of closure is that it would
20:22 - shield private variables from being
20:24 - accessed outside of that function scope
20:27 - and as most of you know closure is what
20:30 - allows us to have access to the variable
20:32 - variable environment a function of a
20:34 - function
20:36 - even after we've exited its scope so
20:39 - you'll continue to see this pattern as
20:41 - we move along that function
20:43 - scoping is how we're going to start to
20:45 - get these boundaries and start to
20:48 - collect our variables in places where we
20:51 - can kind of protect them and not have
20:53 - them hanging loose
20:55 - everywhere
20:57 - control yourself javascript
20:59 - so
21:01 - here's a rather simple example
21:04 - of the module pattern in practice
21:08 - so this
21:09 - my do-it-yourself module we're assigning
21:12 - to it the return value of this
21:15 - iffy
21:16 - and
21:17 - in that iffy we've got in our closure
21:20 - scope some private variables and then
21:22 - we've got our exposed functions that are
21:24 - returned via an object with the
21:27 - increment and print properties
21:30 - and so as one might expect
21:33 - you can call the print
21:35 - function and find out what your counter
21:37 - variable's
21:38 - value is at any point you can call the
21:41 - increment function increment your
21:43 - counter
21:44 - if you printed it again its value is one
21:46 - but you cannot access that counter
21:48 - directly that is the important thing
21:50 - thanks to
21:51 - our
21:52 - function scoping it is
21:55 - it has lived it is gone you can't touch
21:58 - it
22:01 - and here's another popular
22:04 - implementation from back in the day
22:07 - also the module pattern just a flavor of
22:10 - it called the revealing module pattern
22:12 - which is almost exactly the same
22:14 - but in this case both our
22:16 - public and private variables are
22:18 - declared outside of the return statement
22:21 - so pretty much everything all of our
22:23 - variables are being defined in closure
22:25 - scope
22:27 - and
22:28 - we're selectively revealing what we want
22:31 - to
22:32 - and i my understanding is that this
22:35 - revealing module pattern was mostly just
22:38 - readable it was easy to use it was easy
22:40 - to work with
22:41 - you could
22:43 - work mainly within that returned object
22:46 - and decide what you wanted to have and
22:47 - what you didn't want to have included
22:50 - you didn't have to use
22:51 - this keyboard as much when you well oh
22:54 - at all really you could simply refer to
22:57 - variables by
22:58 - name
23:00 - potential disadvantages of this approach
23:03 - this was actually considered
23:05 - by people who were thinking about it one
23:07 - of the most fragile ways of actually
23:10 - implementing the module pattern
23:12 - you might imagine that if you had some
23:14 - public variable that you were trying to
23:17 - change
23:18 - say you were trying to reassign it
23:20 - after having declared it
23:23 - and
23:24 - suppose you also had a private variable
23:26 - in here which somehow used or depended
23:29 - on that public variable
23:31 - well
23:32 - you might have a little bit of trouble
23:33 - and not get what you expect because
23:36 - because these variables are defined
23:39 - in this function scope
23:42 - what's
23:43 - accessible to those private variables
23:45 - into private methods is the closure
23:48 - functionality is what was in this
23:51 - function scope at the time
23:54 - at the time
23:55 - this
23:56 - iffy was invoked and so you might
23:59 - basically this is just to say that you
24:00 - might get some unexpected
24:02 - results it wasn't
24:06 - wasn't the best of the module pattern
24:08 - but
24:10 - it was out there quite a bit in the wild
24:13 - and just so we're clear namespace
24:16 - namespaces and the module pattern are
24:18 - not mutually exclusive approaches they
24:20 - often
24:21 - did go hand in hand which is something
24:23 - the late doug crockford advised um so
24:26 - here we've got a variation of the module
24:29 - pattern that takes a namespace object as
24:32 - a parameter
24:34 - you can also sometimes find this out
24:36 - there with the dot call function and
24:39 - you're using the dot call function and
24:41 - passing in the
24:43 - namespace object and then you just use
24:45 - this keyword instead of having that
24:47 - namespace in there as a function
24:49 - parameter
24:51 - but anyway
24:52 - same kind of idea we pass in the
24:54 - namespace add some data and
24:56 - functionality to the namespace but we've
24:58 - got privacy we've got that privacy that
25:01 - that immediately invoked function scope
25:04 - provides us
25:06 - nice closure so javascript is kind of
25:08 - cool
25:10 - okay so that's a wrap on our quick
25:14 - blazing
25:16 - tour through the early module era
25:19 - and as you can see the tools within
25:20 - javascript did take us a long way
25:23 - towards solving
25:24 - the global namespace pollution problem
25:26 - but we still feel like it's
25:29 - we still weren't where we wanted to be
25:31 - iffy still felt a little like a hack job
25:34 - um
25:35 - we were still dealing with this
25:38 - giant global god object
25:40 - and we still had some problems that
25:42 - remained we never got to the point that
25:44 - we were able to actually swap modules
25:46 - with one another module sharing was not
25:49 - made any easier by this
25:52 - so
25:53 - and related to that the copy paste
25:55 - problem with reusing functionality um
25:58 - so even with a module pattern we didn't
26:01 - really get what we mean when we say
26:04 - modularity we didn't get all of those
26:05 - benefits that we wanted
26:07 - so that brings us to the next phase
26:12 - specification
26:15 - so
26:16 - what's getting specified here
26:18 - is a format a format that modules should
26:21 - take so we can consistently know and
26:24 - reliably know
26:25 - how we're going to load them
26:28 - and send them out into the world
26:31 - and as in the last era we start with a
26:34 - manifesto
26:36 - around 2009 or 2010
26:38 - people were feeling
26:40 - too
26:41 - strong emotions
26:43 - about javascript
26:46 - on one hand people were very excited
26:48 - about javascript's potential as a
26:50 - language and folks who were especially
26:52 - working on the server side were excited
26:54 - to see
26:55 - that javascript could be used on the on
26:57 - the server side
26:59 - so great excitement on one hand great
27:02 - frustration on the other
27:04 - frustration about the limitations of the
27:06 - language and all the things we wanted to
27:08 - do with it but remember little baby
27:10 - javascript coming from mr brendan ike's
27:13 - womb wasn't really built for any of the
27:16 - things any of these expectations that
27:18 - were piling onto javascript
27:21 - so kevin dengue
27:23 - another name that i may be butchering
27:26 - my respects to him
27:28 - wrote a blog post in january of 2009
27:31 - that was called
27:33 - what server-side javascript needs and he
27:36 - outlined a proposal that included among
27:38 - other things
27:40 - a model system
27:42 - so there are some other things that he
27:43 - proposed and many of them we actually
27:45 - know and love today so he talked about
27:47 - having a package system for deploying
27:49 - and distributing modules he talked about
27:52 - having some kind of package repository
27:54 - for finding and installing these
27:56 - distributed modules
27:58 - and none of this existed at the time
27:59 - this was all kind of a pipe dream like
28:01 - wouldn't it be nice wouldn't it be nice
28:04 - if we as a javascript community had
28:06 - these resources available to us
28:09 - he talked about cross interpreter
28:11 - standard libraries also being important
28:13 - so apis that could be used across
28:15 - different browsers like date and math
28:17 - already were at that time
28:19 - so he said you know wouldn't it be great
28:21 - if we had an api for the file system
28:23 - that was consistent across browsers
28:26 - anyway
28:28 - the bottom line is that
28:31 - dengue felt that what he was describing
28:33 - was not actually a technical problem it
28:36 - was an organizational problem it was
28:38 - about finding consensus among the
28:41 - javascript community
28:42 - bringing people together so they could
28:44 - make a decision and step forward and
28:46 - start building something bigger
28:48 - something better together
28:50 - so like adopting some a common currency
28:52 - or a common language
28:55 - his blog post
28:56 - which you're welcome to check out
28:58 - ultimately led to the formation of a
29:01 - grassroots group of
29:03 - similarly fed up developers who called
29:05 - themselves eventually or
29:08 - common js
29:10 - and they decided that they would start
29:11 - setting some standards for javascript
29:13 - including standardizing module loading
29:17 - so
29:20 - not too long after that node came out
29:22 - just a few months later so this was may
29:24 - 2009
29:25 - dangoor wrote his blog post in january
29:28 - and they created a module implementation
29:30 - which has since
29:32 - taken the name common js but it's
29:34 - distinct from that original group um as
29:36 - we'll see that original group
29:38 - didn't end up meeting all of their goals
29:41 - they kind of created some things that
29:42 - they didn't
29:43 - mean to
29:45 - but um anyway node had a number of
29:47 - competitors at the time that were also
29:49 - in the business of creating server-side
29:50 - environments for javascript but node one
29:53 - and the cjs the common js specification
29:57 - name stuck with that the node
29:59 - implementation so that's what we think
30:01 - of when we say commons as today we're
30:03 - talking about nodes implementation
30:06 - of modules
30:08 - and
30:09 - the common js spec stipulates support
30:11 - for module loading via a require method
30:15 - and assigning exports to this property
30:18 - on the module object called
30:21 - module.exports
30:24 - and this was really designed with server
30:27 - development
30:28 - in mind
30:29 - that will become important in a few
30:31 - minutes
30:33 - you might be working
30:35 - in node already but if you're not
30:38 - and if you're not hanging out in cjs
30:40 - regularly
30:42 - we'll have a quick look at the syntax
30:45 - we've got an awesome.js file here
30:48 - and
30:50 - we are attaching we are exporting
30:53 - as
30:54 - its module interface
30:56 - this awesome person function
30:59 - that says so and so is awesome
31:02 - i wish i had people affirming me like
31:04 - that all the time
31:06 - and
31:07 - in some other file we are using that
31:09 - wonderful require method
31:11 - to bring in
31:13 - that awesome person functionality
31:16 - and
31:18 - that required method is going to have
31:21 - you load a module and now you can have
31:23 - dependencies
31:28 - the require function is actually really
31:30 - powerful
31:31 - it is
31:32 - something that will block node's thread
31:35 - of execution
31:37 - module loading in node is synchronous
31:40 - not a big deal actually because on the
31:42 - server side you're working typically
31:44 - with file systems and your files are
31:46 - there already it's not a huge tax or a
31:48 - huge cost to be dealing with
31:51 - with synchronous module loading in node
31:54 - but i'll walk through a few fun pointers
31:57 - related to the
31:59 - require method one thing that i learned
32:01 - actually this year while working on that
32:03 - react
32:04 - project was that
32:06 - node actually caches
32:08 - its modules and it looks in the cache
32:10 - first to see if the module has already
32:12 - been created as a module instance
32:16 - and
32:17 - so the fun report repercussions of that
32:19 - are that you could potentially modify
32:22 - that module after caching it and then
32:25 - when you're working with that same
32:26 - module again it might have some
32:29 - additional
32:31 - properties that you might have assigned
32:32 - to it it may have
32:34 - it
32:35 - it can change or evolve and
32:38 - have
32:38 - all of those properties that you you
32:40 - give it
32:42 - and then this
32:44 - module dot underscore load function
32:46 - that's kind of under the hood of the
32:48 - require method
32:49 - then calls this module
32:51 - dot underscore compile function and
32:54 - that's where the magic happens
32:57 - this method creates a special require
33:00 - function actually it's specific to every
33:02 - module instance that's being created
33:05 - and it generates a wrapper function so
33:08 - remember just like with the module
33:09 - pattern where we had to scope
33:13 - things scope the contents that we wanted
33:16 - sort of protected in a module um within
33:19 - a function so that we could have that
33:21 - little pile of
33:22 - data and functionality and properly
33:24 - scoped variables
33:25 - same trick here a little more
33:27 - sophisticated but we're still using
33:29 - function scopes
33:30 - and then it actually runs that wrapper
33:32 - function on the spot
33:33 - and i think i want to highlight here
33:35 - that all of this kind of happens at once
33:38 - you
33:39 - start wherever your entry is into your
33:42 - you start wherever
33:44 - with whatever file you're entering into
33:46 - you hit your require statement
33:49 - node goes off to another file does its
33:51 - thing doesn't move on until it comes
33:53 - back and finishes
33:55 - its trail of dependency
33:58 - unwinding
34:00 - so
34:02 - anyway
34:03 - so
34:04 - in case you're curious here's what the
34:05 - wrapper function
34:07 - roughly looks like i just grabbed this
34:08 - from the node docs in github they've got
34:11 - a nice
34:12 - a nice little readme type page on
34:14 - modules
34:16 - and
34:17 - yeah kind of made this point already but
34:19 - function scoping is a powerful tool in
34:20 - javascript
34:21 - nothing outlives the
34:24 - execution of that wrapper function
34:26 - except what's actually exported from
34:28 - that module
34:29 - and that's
34:31 - i think i say that yeah
34:33 - so that function will
34:35 - that wrapper function will assign
34:37 - whatever is being exported to that file
34:39 - to the module.exports and off you go you
34:41 - have whatever you wanted that was
34:43 - exported from that file
34:45 - file name and dur name are just
34:46 - convenience variables so you don't have
34:48 - to type out the whole path and directory
34:51 - it's nice that node did that for us
34:55 - so there are of course options for using
34:57 - the commonjs module format on the
34:59 - browser many of us are again doing some
35:02 - kind of translation
35:04 - to whatever newfangled javascript code
35:06 - we're using so that we have
35:08 - continued compatibility
35:11 - anyway so cjs
35:13 - wanders beyond the server every now and
35:15 - again if we wanted to we can use those
35:17 - required methods if we want to
35:22 - so uh
35:23 - remember our friends at common js
35:26 - like the the group of
35:28 - fed up developers not the not the
35:30 - specification
35:32 - um so in a strange plot twist even
35:34 - though they were really talking about
35:35 - javascript for the server side
35:37 - they didn't succeed in offering any kind
35:40 - of usable spec for the server side but
35:42 - they did create one for the client
35:43 - called
35:45 - asynchronous module definition or amd
35:49 - quick look at the syntax there
35:52 - this define method
35:55 - takes as its
35:56 - first
35:58 - parameter this array
36:00 - of dependencies and then it has this
36:03 - function that it's going to
36:05 - fire off once those dependencies have
36:07 - been loaded
36:08 - true to its method it is asynchronous it
36:11 - is better suited
36:12 - to the browser
36:13 - and
36:14 - require.js is one of the more popular
36:17 - libraries folks are using with amd
36:20 - and then umd
36:22 - the universal module definition
36:25 - which i heard a developer or i read that
36:28 - a developer was joking that when you try
36:29 - to please everybody
36:31 - no one leaves happy
36:33 - so this was an attempt to support both
36:35 - the cjspec and the amd spec and
36:40 - with this hulk of
36:43 - boilerplate
36:45 - um as you might imagine it never really
36:47 - caught on no one wants to do that
36:50 - no one wants to do that so
36:52 - so um
36:55 - rest in peace umd i'm sure there are
36:57 - people or i'm sure there are some code
36:59 - bases that are using it
37:01 - anyway
37:02 - so we may say that specifications really
37:05 - flourished in the early part of this
37:07 - decade but
37:09 - while they were a wonderful thing and
37:10 - while there was a lot of innovation and
37:12 - a lot of effort to come up with
37:14 - specifications that we all use
37:17 - it is possible to have too much
37:20 - of a good thing
37:21 - um
37:22 - czech glow wacky
37:25 - man all these names are hard um
37:27 - he was a member of ember's core team and
37:29 - he wrote in 2014 that unless all
37:32 - dependencies use the same module format
37:36 - dependency tree of depth greater than
37:38 - one is so painful nobody does it
37:40 - nobody agrees on a solution to this
37:42 - problem we are all
37:45 - so anyway
37:47 - specification hell
37:52 - and finally
37:55 - that brings us to the last part of our
37:56 - tour where are we now
38:01 - well
38:02 - i really wish i could tie up this
38:04 - presentation in a nice bow but the fact
38:06 - is that we're still kind of in the
38:07 - awkward teenager phase of javascript
38:10 - really
38:11 - finding its adulthood and finding
38:14 - it its way of living up to the
38:16 - expectations we've put on it
38:20 - we've seen a lot of far from ideal
38:22 - solutions but
38:24 - we finally do have a built-in module
38:26 - system and that's a huge leap forward in
38:30 - the development of a language that was
38:31 - never supposed to come this far
38:34 - so
38:35 - think about where we started
38:38 - um
38:39 - es modules actually are supported by all
38:42 - major browsers as of this year i think
38:46 - it was last month actually that firefox
38:50 - just released their es modules
38:53 - compatible version
38:55 - and there's a lot of talk about how es
38:57 - modules are asynchronous that's not
38:59 - exactly right
39:01 - really depends on the loader
39:03 - we'll we can talk a little bit about
39:05 - that but i think that's probably beyond
39:07 - the scope of what we can talk about
39:09 - tonight
39:10 - but other cool cool things include
39:13 - support for cyclic dependencies so those
39:15 - are dependencies that either
39:17 - depend on each other directly or
39:20 - with a few degrees of separation in
39:22 - between
39:23 - um
39:24 - not going to go too
39:26 - deep under the hood with es modules
39:27 - today
39:28 - but
39:30 - let's at least look at this beautiful
39:32 - and consistent and concise syntax that
39:36 - it offers us
39:37 - we've got
39:39 - two export types
39:40 - on the left we can have default exports
39:44 - some of this may be review for those of
39:46 - you who are doing this on a daily basis
39:48 - we can have
39:49 - named exports so here
39:52 - i've got a default export coming from a
39:54 - message.js file i've got
39:57 - three little
39:58 - trivial arithmetic functions that are
40:00 - coming from a library.js file
40:03 - and then
40:05 - their corresponding import method so we
40:08 - can import whatever we
40:11 - exported as a default export using the
40:13 - import
40:14 - statement like so
40:16 - with the word from
40:18 - when we're dealing with a
40:21 - file that
40:22 - has multiple name to exports then we
40:24 - have the option of importing all of them
40:27 - we can even name
40:29 - give a name to the containing object so
40:32 - importing all of these little functions
40:34 - is
40:35 - live or i guess i could have called it
40:36 - arithmetic or something from
40:38 - lib.js
40:40 - we can selectively decide
40:43 - which
40:45 - parts of the interface that we want to
40:46 - bring in
40:47 - using i guess this is kind of it's not
40:50 - exactly i guess that's kind of objective
40:53 - destructuring
40:55 - yeah i would call that objective
40:56 - destruction
40:58 - cool
41:00 - and in the browser
41:02 - we
41:03 - still have our trusty old script tag
41:05 - that has survived many years of
41:07 - javascript
41:08 - but now we have a new special attribute
41:11 - called
41:12 - type
41:13 - that we can
41:14 - call type and we can assign it
41:17 - module to let the browser know this is
41:19 - not regular javascript that you're going
41:21 - to be parsing you're going to be looking
41:24 - at
41:24 - a module file and that has to be handled
41:26 - differently
41:28 - so javascript can begin its
41:31 - process of
41:32 - module loading build building out a
41:34 - dependency tree and all of that
41:37 - we also have a fallback for older
41:39 - browsers
41:40 - so when you have the no module attribute
41:44 - this is going to be ignored by those
41:46 - modern browsers that are using
41:49 - modules natively the no module attribute
41:52 - says
41:54 - ignore me to those browsers but if you
41:56 - are not in one of those browsers if
41:58 - you're in an older browser you've got
42:00 - your trusty bundled regular javascript
42:03 - file in all of its global variable glory
42:11 - one of the conflicts one of the current
42:13 - issues in javascript is that
42:17 - while most browsers are up to speed with
42:19 - es modules node is not and
42:22 - you might be asking yourself why
42:24 - node and es modules can't just get along
42:27 - well
42:28 - the implementation actually is pending i
42:30 - was able to play around with it a little
42:32 - bit
42:33 - and just make sure you have the most
42:35 - current version of node and just use the
42:38 - i think it's called experimental modules
42:40 - flag or something experimental something
42:42 - flag
42:43 - and you can absolutely play with them in
42:45 - node
42:47 - but really what's going on is that es
42:49 - modules and common js modules these are
42:53 - really different specifications
42:55 - so when i was talking about node earlier
42:57 - doing the synchronous loading and
42:59 - execution of
43:01 - um of those wrapper functions that it
43:03 - was creating with require that's a
43:05 - really different approach to modules
43:07 - than es modules it's just
43:10 - they they don't play nicely together
43:12 - they are two different concepts of
43:13 - modules so um
43:15 - one of the things that's caused a lot of
43:17 - contention is the dot mjs i think it's a
43:20 - modular javascript file extension which
43:23 - is
43:24 - basically to node what the type equals
43:27 - module attribute on the script tag was
43:29 - to the browser so this dot mjs file
43:31 - extension says to node hey you're about
43:34 - to parse
43:35 - um an es modules an es module file
43:38 - some people have called it the michael
43:40 - jackson script file extension
43:45 - anyway
43:49 - as i said i wish i could just wrap this
43:51 - up in a tidy bow but there are still a
43:53 - lot of questions about what the future
43:55 - is going to look like
43:56 - there's a lot of thought that es modules
43:58 - and http 2 will be very complementary to
44:01 - each other
44:02 - with the possibility of server push and
44:04 - being able to sort of chunk out bits of
44:07 - bits of code um
44:09 - quickly
44:10 - on demand
44:11 - and uh
44:13 - yeah i think we have yet to see what's
44:15 - to come and we're kind of in an exciting
44:17 - phase in the life the not so long life
44:20 - of javascript i think it must be in its
44:23 - i'm terrible at arithmetic it's a
44:26 - 23rd year
44:28 - it's going into its 23rd year
44:31 - just it's young adulthood and we all get
44:35 - to be a part of that and
44:38 - maybe at the end of that
44:40 - we will get to
44:41 - the promised land
44:43 - thank you
44:45 - [Applause]

Cleaned transcript:

good evening everyone thank you first of all to vijay for having me back i was with a group of developers who worked on a react open source project having to do with server side rendering and we had a lot of fun speaking together it was five of us passing off the the speaking roles back and forth for the course of the meetup so this time i'm holding down the ford alone but i'm excited i'm very excited to have a chance to nerd out with you guys for a little bit about javascript modules and this is a top topic that i think is particularly fascinating because when we look at the history and the development of modules in javascript we're kind of going in parallel with we're tracing the history of javascript growing as a language from kind of humble origins as this lightweight scripting language that was running in netscape to really becoming a powerhouse that gives us the modern web with all of its interactivity and everything that we love about it so now we're basically in an era where we have javascript running everywhere universal javascript javascript on the client and on the server side um on we have it in our thermostats even flying drones for us so needless to say javascript has come a very long way and so have modules oh and the pronunciation of my name for uh anyone who might have been wondering is meijin rhymes with regen so just well anyway so the first thing that i would like to posit is that modules are a fundamental part of our lives as javascript developers they're kind of part of the scenery so i do a lot of my daytoday work in a react code base so when i fire up my code editor many of the files i'm looking at have kind of a predictable structure i see some import statements at the top some export statements at the bottom i almost don't even think about them i mean unless i've put a typo in my file path or something and i then i am thinking about them but um i imagine there are other folks in the room working in other frameworks and working in other type code bases and environments so modules and modular thinking are kind of second nature to us and that's really how it should be modules are supposed to make our lives easier as developers they do this by giving our code structure and boundaries so that way we don't have to think about all of the moving parts i don't have to have the react source code mingling with my component logic i can take a grand take for granted that it's going to be available for me and do what i want it to do most of the time so for now it resides elsewhere out of sight and out of mind and this is especially important as code bases get bigger so when we hear about terms like modularity and separating concerns that's really about our sanity as developers who are working with each other and working with a lot of code so let's start out and get on the same page as far as our concepts and terminology we'll start with the basics what's a module anyway i like to think about modules as building blocks of data and functionality and we can bring them into a program and we can also make them available to other programs and ideally you can kind of treat them like you would building blocks and hopefully you can add or remove pieces from the hole without the whole structural integrity falling apart so when we're talking about modules we're really talking about the higher level design of our software we're often thinking about modules in terms of a single file because that's typically how we organize our modules one module one file we can also talk about modules in terms of their relationships to other modules so a module has an interface and that's its exposed bits that let us have data and functionality available for use in other programs i kind of like to think of the module interface as the little bumps on the top of a lego brick so you can try to put your lego bricks side by side and they won't really stick together but those little bumps which i actually just found out are called studs lego studs are how we actually get our structures to stick together and so module interfaces are a little bit like that and a module can also have dependencies and often that just means that we're dealing with other functionality that we're relying on to have the functionality of whatever module we're working in and so just to have a hammer at home in case there's any ambiguity about my personal position on this modules are awesome they help us to keep organized code bases especially as those code bases are growing in complexity they help us resolve our dependencies making sure that any pieces of code are supposed to be there and we don't have to worry about getting them all in the right order they also help us to share and reuse code so we have a wonderful thing called npm that gives us access to literally i think 700 000 packages right now a lot of packages of code and we ourselves can be part of a community contributing to that global repository alongside others so kind of cool but before we go any further there is an elephant in the room and we should acknowledge it so these modules which i've been talking about and that are so fundamental to modular to modular and modern programming are actually just barely a part of javascript they weren't built into javascript pre es6 so for most of its years as a language javascript didn't have any kind of builtin native module system so this is unlike python for example and so modules only really recently became part of the language and they've actually only just landed in modern browsers like as of this year so oftentimes when we're working with modules we're not working with the builtin module system at all we might be using require statements if we're working in node or com.js we might be using import statements like i showed earlier from react code we might be using valve to transpile them down to es5 and then to bundle those files that were all supposed to be separate into a single one for consumption by the browser um so what's going on well this is where i started getting curious like what how did we work for so long without modules in javascript and as i started to take a peek into the history i found that there was this overarching storyline that javascript was really built disadvantaged when it came to modules it wasn't built with any kind of modularity in mind when it was first invented it was just supposed to be lightweight scripting inline scripting and over time as more demands were made of javascript as a language to do more for us we see an increasing need so running in parallel for usable module systems so i like to think of the history of javascript as unfolding in four phases i made these up so i call it the premodule era the doityourself module phase the specification phase and the standardization phase and because it is something i made up and because it is a system of chronology it is not perfect not precise but what i was aiming to do and kind of splitting our timeline into these four segments was to bring some order to overall trends that we were that were taking place so i'll do a little fly over right now before we jump in and get into more detail for each of those phases but let's start at the beginning in the premodule era when modules were not really a thing at all javascript didn't itself have much of an identity or much respect let's be honest at that point it was nothing like it is today that didn't last too long before we started realizing that we needed some kind of modules but in the absence of those builtin modules we were improvising we were making module type structures ourselves so uh roughly in 2011 we start to see module specifications growing in popularity the javascript community especially the service server side javascript community was really starting to take off and a lot of work had to be done just to make javascript the language people wanted to develop in and a big part of that was just coming onto the same page so that's also kind of our era of single page apps and frameworks like backbone and angular starting to come into vogue and finally today we have arrived in the era of standardization and that's the phase that is currently underway and i hate to spoil the plot right at the beginning but javascript is still pretty far from having a standardized module system we do have a standard system in place but we're still working out the kinks and we're still making things hold together in the ways that we hope that they will so that one day we will all be gloriously developing with modules and not having to think about all the uh the quirks that go with with trying to do that all right so let's begin our tour we begin in a time before modules javascript's age of innocence and as we peek into the yearbook dun dun we come across gems like this so totally 90s and i'm calling this the dark ages but really i think we were probably having a good time um anyone had a geocities website i sure did i think it was called like the raspberry garden or something it was like 12 anyway it had all these cool neighborhoods like soho and sunset strip and times square and i guess you can go to the wayback machine if you want to have some nostalgia but anyway as i'm looking at this specimen from the archives i think i'm seeing at least for sure one definite use of inline scripting which is probably like this fun little animated status bar that's going it's crossing the screen for your entertainment um anyone spot any others that's the only one that i feel like kind of confident on what a time what a time but anyway yes a wild west of inline scripting and script tags no modules to speak of really a question i want us to start thinking about is um is this scalable what are some of the problems we encounter in this wild west scenario well i'll say more about that in a moment but first let's get one thing straight at this stage in the game no one was really thinking about thinking about scalability that was not the name of the the game and if you don't take it from me take it from the inventor of javascript himself mr brendan ike i hope i hope he pronounces it that way too i could i could be butchering it but he did say in an interview with infoworld that no one thought javascript would be used at the wide scale that it is not just reaching lots of people on the web but large applications like gmail to write large code you don't just want this little snippet language that i made for beginners beginners you want strong apis and ways of saying hey this is my module and this is your module and you can throw your code over to me and i can use it safely so a quick trivia question does anyone know what your javascript was invented 95 or did you say 95 that is exactly right over the course of 10 very intense days for mr ike and um i think his original instructions from netscape were actually to have a language that was a lot more like scheme for the browser so if anyone's worked with scheme which is kind of a dialective lisp you know it looks completely different from the javascript we know and love those instructions those marching orders changed significantly and i feel grateful for that so in the in 2006 we get the first of several manifestos that we will see um so this particular manifesto came from the yahoo user interface team in a blog post with the title global domination and they had a good point i would say and the point that they were trying to make is that global variables are a terrible risky practice that we're all engaging in this unsafe behavior that we're all engaging in but um in growing code bases we really had to cut cut cut that out and so what's the problem well global variables are notoriously unreliable and insecure and there are a few reasons for that and the first has to do with variable naming collisions so assuming mary and george on the u on the ue dev team are working on the same code and name to the very their variable the same thing they were likely to run into trouble pollution in the global name space and globally scoped variables are just well they're just really easy to break or to forget that they even exist and secondly because they're exposed they're not secure so it's not just coworkers who might innocently bump into each other in the global namespace dance floor thirdparty scripts and malicious code might join in the fun and global variables are a vulnerability that we generally want to avoid especially if we're yahoo and we're the big guns in the game in the mid 2000s so the ue team actually went as far as to say that an objective measure of the quality of a javascript program is how many global variables and global functions does it have a large number is bad because the chance of bad interactions with other programs goes up and a few other issues were cropping up in this era in this premodule era whenever you wanted to reuse code you'd likely be doing some kind of copypaste job and then following the trail of breadcrumbs wherever it led you and anytime you tried to update your code it would likely be a logistical nightmare as you tried to find all the pieces the places where you needed to update it dependencies were a hassle to manage especially if you were dealing with version control you had to worry about putting your script tags all in the right order and basically as code bases were getting more complex we needed a way to manage them better so let us set foot into the next era doityourself modules and in the second phase of javascript history not all of the problems from the premodule era were going to go away right off the bat but we'll start to see some of them being addressed particularly the problem of global variables because that was an immediate concern so this insight about needing to limit global variables actually spurred a ton of innovation um with an improvisation really with what was possible within the constraints and flexibilities of the javascript language and this was really an era of transformation for the web we're really moving away from the geocities model of static websites we're moving toward more interactivity and ajax requests were becoming more of a norm during this period jquery hit the scene during this time and the web was really starting to grow up a little bit from websites to web apps and so let's just keep that in mind as we start to look at some of the ways that people addressed the shortcomings of living in a world without modules we'll pick up the story where we left off with our friends at yahoo who had just declared that global variables are evil and their answer to this problem of global variables was actually just to restrict them let's let's stick with a single object with godlike status the yahoo object and the aim of the yahoo global object was literally to contain all of yahoo their state their and all of their webstate and being in all caps you can tell that it was very important it was the global so if you wanted to do anything you would say yahoo.util.dom.get or whatever it might have been you were somehow crawling through this object tree to find find what you wanted and jquery might be a more familiar example you might remember having to have the jquery object in available in globe global but as as much as this approach was touted as great practice there were definitely downsides to it too so it was still relying on a global variable a single one that could have been rewritten with a single line of code and then poof potentially everything could be gone there was still no code reusability and really no help with dependency management or versioning but you were starting to mitigate some of the risks of just having free range global variables so the basic structure of the namespace approach looks kind of like this we've got an object literal here and we've got some properties on it some data and some functionality and um we can assign those additional properties additional data um while we're declaring that namespace object or after the fact with our handy dandy dot notation and let's look at another approach that started coming up in this area era and that's the module pattern and the essence of the module pattern is being able to use an immediately invoked function expression with the power of closure so the power of closure is that it would shield private variables from being accessed outside of that function scope and as most of you know closure is what allows us to have access to the variable variable environment a function of a function even after we've exited its scope so you'll continue to see this pattern as we move along that function scoping is how we're going to start to get these boundaries and start to collect our variables in places where we can kind of protect them and not have them hanging loose everywhere control yourself javascript so here's a rather simple example of the module pattern in practice so this my doityourself module we're assigning to it the return value of this iffy and in that iffy we've got in our closure scope some private variables and then we've got our exposed functions that are returned via an object with the increment and print properties and so as one might expect you can call the print function and find out what your counter variable's value is at any point you can call the increment function increment your counter if you printed it again its value is one but you cannot access that counter directly that is the important thing thanks to our function scoping it is it has lived it is gone you can't touch it and here's another popular implementation from back in the day also the module pattern just a flavor of it called the revealing module pattern which is almost exactly the same but in this case both our public and private variables are declared outside of the return statement so pretty much everything all of our variables are being defined in closure scope and we're selectively revealing what we want to and i my understanding is that this revealing module pattern was mostly just readable it was easy to use it was easy to work with you could work mainly within that returned object and decide what you wanted to have and what you didn't want to have included you didn't have to use this keyboard as much when you well oh at all really you could simply refer to variables by name potential disadvantages of this approach this was actually considered by people who were thinking about it one of the most fragile ways of actually implementing the module pattern you might imagine that if you had some public variable that you were trying to change say you were trying to reassign it after having declared it and suppose you also had a private variable in here which somehow used or depended on that public variable well you might have a little bit of trouble and not get what you expect because because these variables are defined in this function scope what's accessible to those private variables into private methods is the closure functionality is what was in this function scope at the time at the time this iffy was invoked and so you might basically this is just to say that you might get some unexpected results it wasn't wasn't the best of the module pattern but it was out there quite a bit in the wild and just so we're clear namespace namespaces and the module pattern are not mutually exclusive approaches they often did go hand in hand which is something the late doug crockford advised um so here we've got a variation of the module pattern that takes a namespace object as a parameter you can also sometimes find this out there with the dot call function and you're using the dot call function and passing in the namespace object and then you just use this keyword instead of having that namespace in there as a function parameter but anyway same kind of idea we pass in the namespace add some data and functionality to the namespace but we've got privacy we've got that privacy that that immediately invoked function scope provides us nice closure so javascript is kind of cool okay so that's a wrap on our quick blazing tour through the early module era and as you can see the tools within javascript did take us a long way towards solving the global namespace pollution problem but we still feel like it's we still weren't where we wanted to be iffy still felt a little like a hack job um we were still dealing with this giant global god object and we still had some problems that remained we never got to the point that we were able to actually swap modules with one another module sharing was not made any easier by this so and related to that the copy paste problem with reusing functionality um so even with a module pattern we didn't really get what we mean when we say modularity we didn't get all of those benefits that we wanted so that brings us to the next phase specification so what's getting specified here is a format a format that modules should take so we can consistently know and reliably know how we're going to load them and send them out into the world and as in the last era we start with a manifesto around 2009 or 2010 people were feeling too strong emotions about javascript on one hand people were very excited about javascript's potential as a language and folks who were especially working on the server side were excited to see that javascript could be used on the on the server side so great excitement on one hand great frustration on the other frustration about the limitations of the language and all the things we wanted to do with it but remember little baby javascript coming from mr brendan ike's womb wasn't really built for any of the things any of these expectations that were piling onto javascript so kevin dengue another name that i may be butchering my respects to him wrote a blog post in january of 2009 that was called what serverside javascript needs and he outlined a proposal that included among other things a model system so there are some other things that he proposed and many of them we actually know and love today so he talked about having a package system for deploying and distributing modules he talked about having some kind of package repository for finding and installing these distributed modules and none of this existed at the time this was all kind of a pipe dream like wouldn't it be nice wouldn't it be nice if we as a javascript community had these resources available to us he talked about cross interpreter standard libraries also being important so apis that could be used across different browsers like date and math already were at that time so he said you know wouldn't it be great if we had an api for the file system that was consistent across browsers anyway the bottom line is that dengue felt that what he was describing was not actually a technical problem it was an organizational problem it was about finding consensus among the javascript community bringing people together so they could make a decision and step forward and start building something bigger something better together so like adopting some a common currency or a common language his blog post which you're welcome to check out ultimately led to the formation of a grassroots group of similarly fed up developers who called themselves eventually or common js and they decided that they would start setting some standards for javascript including standardizing module loading so not too long after that node came out just a few months later so this was may 2009 dangoor wrote his blog post in january and they created a module implementation which has since taken the name common js but it's distinct from that original group um as we'll see that original group didn't end up meeting all of their goals they kind of created some things that they didn't mean to but um anyway node had a number of competitors at the time that were also in the business of creating serverside environments for javascript but node one and the cjs the common js specification name stuck with that the node implementation so that's what we think of when we say commons as today we're talking about nodes implementation of modules and the common js spec stipulates support for module loading via a require method and assigning exports to this property on the module object called module.exports and this was really designed with server development in mind that will become important in a few minutes you might be working in node already but if you're not and if you're not hanging out in cjs regularly we'll have a quick look at the syntax we've got an awesome.js file here and we are attaching we are exporting as its module interface this awesome person function that says so and so is awesome i wish i had people affirming me like that all the time and in some other file we are using that wonderful require method to bring in that awesome person functionality and that required method is going to have you load a module and now you can have dependencies the require function is actually really powerful it is something that will block node's thread of execution module loading in node is synchronous not a big deal actually because on the server side you're working typically with file systems and your files are there already it's not a huge tax or a huge cost to be dealing with with synchronous module loading in node but i'll walk through a few fun pointers related to the require method one thing that i learned actually this year while working on that react project was that node actually caches its modules and it looks in the cache first to see if the module has already been created as a module instance and so the fun report repercussions of that are that you could potentially modify that module after caching it and then when you're working with that same module again it might have some additional properties that you might have assigned to it it may have it it can change or evolve and have all of those properties that you you give it and then this module dot underscore load function that's kind of under the hood of the require method then calls this module dot underscore compile function and that's where the magic happens this method creates a special require function actually it's specific to every module instance that's being created and it generates a wrapper function so remember just like with the module pattern where we had to scope things scope the contents that we wanted sort of protected in a module um within a function so that we could have that little pile of data and functionality and properly scoped variables same trick here a little more sophisticated but we're still using function scopes and then it actually runs that wrapper function on the spot and i think i want to highlight here that all of this kind of happens at once you start wherever your entry is into your you start wherever with whatever file you're entering into you hit your require statement node goes off to another file does its thing doesn't move on until it comes back and finishes its trail of dependency unwinding so anyway so in case you're curious here's what the wrapper function roughly looks like i just grabbed this from the node docs in github they've got a nice a nice little readme type page on modules and yeah kind of made this point already but function scoping is a powerful tool in javascript nothing outlives the execution of that wrapper function except what's actually exported from that module and that's i think i say that yeah so that function will that wrapper function will assign whatever is being exported to that file to the module.exports and off you go you have whatever you wanted that was exported from that file file name and dur name are just convenience variables so you don't have to type out the whole path and directory it's nice that node did that for us so there are of course options for using the commonjs module format on the browser many of us are again doing some kind of translation to whatever newfangled javascript code we're using so that we have continued compatibility anyway so cjs wanders beyond the server every now and again if we wanted to we can use those required methods if we want to so uh remember our friends at common js like the the group of fed up developers not the not the specification um so in a strange plot twist even though they were really talking about javascript for the server side they didn't succeed in offering any kind of usable spec for the server side but they did create one for the client called asynchronous module definition or amd quick look at the syntax there this define method takes as its first parameter this array of dependencies and then it has this function that it's going to fire off once those dependencies have been loaded true to its method it is asynchronous it is better suited to the browser and require.js is one of the more popular libraries folks are using with amd and then umd the universal module definition which i heard a developer or i read that a developer was joking that when you try to please everybody no one leaves happy so this was an attempt to support both the cjspec and the amd spec and with this hulk of boilerplate um as you might imagine it never really caught on no one wants to do that no one wants to do that so so um rest in peace umd i'm sure there are people or i'm sure there are some code bases that are using it anyway so we may say that specifications really flourished in the early part of this decade but while they were a wonderful thing and while there was a lot of innovation and a lot of effort to come up with specifications that we all use it is possible to have too much of a good thing um czech glow wacky man all these names are hard um he was a member of ember's core team and he wrote in 2014 that unless all dependencies use the same module format dependency tree of depth greater than one is so painful nobody does it nobody agrees on a solution to this problem we are all so anyway specification hell and finally that brings us to the last part of our tour where are we now well i really wish i could tie up this presentation in a nice bow but the fact is that we're still kind of in the awkward teenager phase of javascript really finding its adulthood and finding it its way of living up to the expectations we've put on it we've seen a lot of far from ideal solutions but we finally do have a builtin module system and that's a huge leap forward in the development of a language that was never supposed to come this far so think about where we started um es modules actually are supported by all major browsers as of this year i think it was last month actually that firefox just released their es modules compatible version and there's a lot of talk about how es modules are asynchronous that's not exactly right really depends on the loader we'll we can talk a little bit about that but i think that's probably beyond the scope of what we can talk about tonight but other cool cool things include support for cyclic dependencies so those are dependencies that either depend on each other directly or with a few degrees of separation in between um not going to go too deep under the hood with es modules today but let's at least look at this beautiful and consistent and concise syntax that it offers us we've got two export types on the left we can have default exports some of this may be review for those of you who are doing this on a daily basis we can have named exports so here i've got a default export coming from a message.js file i've got three little trivial arithmetic functions that are coming from a library.js file and then their corresponding import method so we can import whatever we exported as a default export using the import statement like so with the word from when we're dealing with a file that has multiple name to exports then we have the option of importing all of them we can even name give a name to the containing object so importing all of these little functions is live or i guess i could have called it arithmetic or something from lib.js we can selectively decide which parts of the interface that we want to bring in using i guess this is kind of it's not exactly i guess that's kind of objective destructuring yeah i would call that objective destruction cool and in the browser we still have our trusty old script tag that has survived many years of javascript but now we have a new special attribute called type that we can call type and we can assign it module to let the browser know this is not regular javascript that you're going to be parsing you're going to be looking at a module file and that has to be handled differently so javascript can begin its process of module loading build building out a dependency tree and all of that we also have a fallback for older browsers so when you have the no module attribute this is going to be ignored by those modern browsers that are using modules natively the no module attribute says ignore me to those browsers but if you are not in one of those browsers if you're in an older browser you've got your trusty bundled regular javascript file in all of its global variable glory one of the conflicts one of the current issues in javascript is that while most browsers are up to speed with es modules node is not and you might be asking yourself why node and es modules can't just get along well the implementation actually is pending i was able to play around with it a little bit and just make sure you have the most current version of node and just use the i think it's called experimental modules flag or something experimental something flag and you can absolutely play with them in node but really what's going on is that es modules and common js modules these are really different specifications so when i was talking about node earlier doing the synchronous loading and execution of um of those wrapper functions that it was creating with require that's a really different approach to modules than es modules it's just they they don't play nicely together they are two different concepts of modules so um one of the things that's caused a lot of contention is the dot mjs i think it's a modular javascript file extension which is basically to node what the type equals module attribute on the script tag was to the browser so this dot mjs file extension says to node hey you're about to parse um an es modules an es module file some people have called it the michael jackson script file extension anyway as i said i wish i could just wrap this up in a tidy bow but there are still a lot of questions about what the future is going to look like there's a lot of thought that es modules and http 2 will be very complementary to each other with the possibility of server push and being able to sort of chunk out bits of bits of code um quickly on demand and uh yeah i think we have yet to see what's to come and we're kind of in an exciting phase in the life the not so long life of javascript i think it must be in its i'm terrible at arithmetic it's a 23rd year it's going into its 23rd year just it's young adulthood and we all get to be a part of that and maybe at the end of that we will get to the promised land thank you
