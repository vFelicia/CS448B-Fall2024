With timestamps:

00:00 - Learn how to use TerraForm with AWS. 
In this course from Derrick Morgan,  
00:05 - you will realize within a few minutes of 
watching how amazing Derek is as an instructor.  
00:14 - Hello, and welcome to the build a development 
environment with AWS and TerraForm resume  
00:20 - foundations project. So a resume foundations 
project is a short project that is tailored  
00:27 - to cover the important aspects of a technology in 
order to help you build the foundations necessary  
00:34 - to build your own projects and apply them to your 
resumes. So let's take a look at what you're going  
00:41 - to find in the course. In this two hour project 
centered around TerraForm. You're going to use  
00:48 - VS code and deploy an AWS EC two instance, along 
with the VPC, Internet Gateway security groups,  
00:55 - et cetera, that will serve as a remote development 
environment that you can log into directly from  
01:01 - VS code will utilize several TerraForm tools 
and functions such as TerraForm, state format,  
01:08 - replace console variables, conditionals, file, 
template file, and more. We'll also use AWS user  
01:16 - data and a local exec provisioner to bootstrap the 
EC two instance and add its connection information  
01:24 - to your VS code SSH configuration file, 
allowing you to modify it for your own projects.  
01:32 - Since we'll make heavy use of documentation 
and highlight the process behind developing  
01:37 - a brand new TerraForm deployment, 
you'll have the skills you need to  
01:42 - dive deeper into TerraForm and add this 
extremely in demand skill to your resume.  
01:49 - So what are you waiting for, sign up today. 
And don't forget to terraform apply yourself.  
01:57 - So let's start out right here in the AWS 
console. And let's go to I am. Now as you  
02:03 - can see I've recently visited but just in case 
you haven't, you can just search right up here  
02:09 - in the search bar. Let's click on 
that. And now let's click on Users.  
02:17 - Now within users, you may see a lot more 
information here I've actually hidden  
02:21 - most of mine, let's go ahead and create 
a new user. So we'll click on Add Users.  
02:30 - And for the user name, feel free to use whatever 
you'd like. I'm just going to call it VS code.  
02:37 - And now I'm going to choose 
access key programmatic access,  
02:40 - we're not bothering with a password, this is not 
going to be a user that logs into the console.  
02:46 - So go ahead and click that in next permissions. 
Now as you can see, I've got a group of admins,  
02:53 - you can of course, create a new group, or you 
can just attach the policies directly. And I'm  
03:00 - going to do that just click on Attach existing 
policies directly click on administrator access,  
03:06 - and then click next tax. Now feel free to tag 
it if you'd like to, I'm not going to bother.  
03:14 - The next review, we've got right here our user 
name programmatic access, and administrator  
03:20 - access. Go ahead and click on Create user. 
And right here, you'll see that you've got  
03:28 - your access key ID and your secret access key. 
Go ahead and download that CSV. As you can see,  
03:38 - I've already installed Visual Studio code it was a 
pretty straightforward process, I am on a Windows  
03:44 - machine. But this of course will also work on a 
Mac or Linux. So go ahead and first things first,  
03:50 - let's get the AWS extension installed. So 
click on the extensions icon here on the left,  
03:58 - and then search for AWS. And once you've done 
that, we've got this AWS toolkit here, go ahead  
04:05 - and click Install. Looks like everything installed 
fine. So I'm going to go ahead and close this pane  
04:13 - and close this tab. And then I'm going 
to click on this little AWS icon.  
04:19 - As you can see, we've got connect to AWS 
right here. But before we can do that,  
04:24 - we need to get some credentials installed. 
So head up to View and command palette.  
04:29 - Then as you can see, I've searched for this 
before, but if you need to get to it, you can  
04:33 - type AWS and then start typing create credentials 
profile, just like so. And then open that. And  
04:40 - as you can see here, I've got a credentials 
profile called VS code. If yours looks different,  
04:45 - make sure that you get this looking the same if 
you want to follow along in the course exactly.  
04:50 - But of course if you don't or you're comfortable 
making simple modifications, you can name this  
04:54 - whatever you'd like. But what we need to do 
is populate this AWS access key ID In secret  
05:00 - access key. So go ahead and open your credentials 
file and paste this information in. Just like so.  
05:09 - Alright, and once you've done that, go ahead 
and Ctrl S to Save this file, you should not  
05:14 - have this white dot that was up here before, then 
close this tab, and then click on Connect to AWS.  
05:22 - And you should see your profile right here. 
If not, you can obviously type profile VS code  
05:30 - if you need to, and just click on that, and 
default region of US East one, I actually don't  
05:36 - want that region, I'm going to use a different 
one. But whichever region you choose, you can  
05:41 - choose that here, I'm just going to say no. And 
I'm going to add US west to that's the region I  
05:51 - typically use in my courses, because there's so 
much default stuff that goes on in US East one,  
05:56 - I just prefer to stick with us West too, but it 
is totally up to you. So once you've done that,  
06:02 - you can go ahead and minimize that. And then 
open the extensions panel again, let's go  
06:08 - ahead and add something that will give us a little 
TerraForm syntax highlighting, let's go ahead and  
06:13 - type in TerraForm. And as you can see, there is an 
official TerraForm extension here, it's rated 2.5.  
06:20 - It is pretty buggy, it might be better now that 
you're watching this video, feel free to choose  
06:25 - this one if you'd like. But I'm actually going to 
use this one here, it's just got a higher rating.  
06:31 - And it's been pretty consistent for me. So I'm 
going to install this one, just like so. Alright,  
06:37 - and I'm going to close that tab and close my 
extensions. So now that we've got our extensions  
06:42 - installed, let's go ahead and create our working 
directory. So I'm going to go ahead and click on  
06:49 - Open folder. And I'm just going to set mine up in 
the Documents directory, feel free to set this up  
06:55 - wherever you'd like of course, just like so. 
And then I'm going to create a new directory.  
07:03 - And I'm just going to call it TerraForm. Just like 
so. All right, and I'm going to open that and hit  
07:11 - select folder, just like so. Alright, so now we 
have a working directory, we've got our extensions  
07:18 - installed, everything is ready to start the 
course. Now it's a fairly straightforward build,  
07:24 - we're going to cut it down to the bare necessities 
because you don't need much for your development  
07:31 - environment, the more resources we add, the 
more can go wrong. So let's just make sure  
07:36 - that we keep it as small as possible. And then 
of course, as you develop new requirements,  
07:42 - you can build out your environment to meet your 
needs from there. So what we're going to do  
07:47 - is we're going to use VS code on our terminal. 
And then we're going to use the TerraForm  
07:52 - configuration files, providers variables, main 
terraform.tf VARs, which of course, we will be  
07:59 - explaining all of these throughout the course. 
And then we've got a configuration file here  
08:04 - that's going to configure VS code based on the IP 
and other information of our developer node. And  
08:12 - we've got our user data that's going to bootstrap 
that node. Now in AWS, we will build out a VPC,  
08:19 - we're going to build out an Internet Gateway, 
public route table, a security group, a public  
08:26 - subnet, and an EC two instance. So all of this 
together will form our developer environment. And  
08:33 - once we're done, after all of these files have 
been processed, and everything is good to go,  
08:39 - your VS code terminal will have access directly to 
this EC two node to deploy a remote SSH session,  
08:48 - which will allow you to have file and SSH access 
to your EC two node to run whatever you need. So  
08:55 - that's a very high level overview. Let's go ahead 
and get building. So here I am in the AWS provider  
09:03 - documentation within TerraForm. And a provider is 
basically used by TerraForm to interface with the  
09:10 - API of whatever infrastructure you're trying to 
build. So in this case, you're trying to build AWS  
09:17 - infrastructure. So you use the AWS provider, if 
you're using GCP, or Azure, or VMware or whatever  
09:24 - else you will use their respective providers. So 
as you can see, it's pretty straightforward. Since  
09:30 - we've already provided credentials, we don't need 
to provide those within the provider block here.  
09:37 - If you scroll down, you can see there's actually 
lots of ways to add these credentials. But again,  
09:42 - we already have a profile. So all we need to 
do is access the shared credentials file, just  
09:48 - like this. So let's go ahead and we'll keep it 
fairly simple. I'm just going to copy this here.  
09:56 - And then within our TerraForm directory here, 
which we created Earlier are going to create a  
10:01 - new file. And let's call this providers.tf. Just 
like so. And we'll paste that in. Now I'm actually  
10:10 - going to remove this version block here, because 
you may be in the distant future, and not on  
10:15 - version three anymore. So again, I'm going to just 
remove that and let you download whatever version  
10:21 - is current. Now after that, we need to add our 
provider block, that is the required providers  
10:28 - block. And that provides configuration that 
TerraForm needs to know about. But the provider  
10:33 - block itself provides the information needed to 
access AWS specifically. So if you scroll down  
10:40 - here, you can actually see that we have some usage 
examples. And we have one right here with shared  
10:47 - credentials file already here for us. So let's 
go ahead and just copy this one. And I'm going to  
10:55 - paste that right here. Now again, typically, 
I type all of this out. But since this is a  
11:02 - very quick course, I want to make sure it is as 
streamlined as possible for you. So here, I'm just  
11:08 - going to remove this. And I'm just going to add 
that little squiggly right there to indicate the  
11:15 - home directory, dot AWS slash credentials. Because 
that's where our credentials file is stored.  
11:25 - Now, if you've moved it, of course, you'll want to 
change this. But this is actually the default for  
11:29 - Windows and Mac. So you should be good to go. Now 
for the profile, remember, that was named VS code.  
11:37 - And the region is US West two. So this is 
what you should have here for the provider.  
11:43 - Again, if the documentation did not provide 
this exactly, of course, just copy it from  
11:48 - here. All right. So now that that's done, let's 
go ahead and run a TerraForm init to initialize  
11:55 - this and connect to AWS to ensure everything 
works out. So I'm going to click on terminal  
12:02 - and new terminal just like so. 
Let's go ahead and I'm going to  
12:07 - pull this up a little bit, clear this screen. 
And let's go ahead and run TerraForm init.  
12:16 - All right, TerraForm has been successfully 
initialized. As you can see, we've  
12:21 - got hashey Corp, AWS version 3.7 1.0. At least 
that's my version, your version is different,  
12:27 - that is perfectly fine. Also, you 
can see that TerraForm has created a  
12:31 - lock file TerraForm lock dot HCl. And what that's 
going to do is ensure that the version is frozen.  
12:40 - Again, you can change this if you'd like. And 
this should be the current version you're using.  
12:45 - But this is something you might want to keep 
in your GitHub or git lab or wherever you're  
12:50 - storing your code repository so that you can 
ensure that every time you run this code, it  
12:55 - always uses the same version of the provider, and 
you have a much lower risk of having some sort of  
13:02 - issue with an upgrade. So it looks like everything 
is all nice. And initialized. As you can see here,  
13:08 - I can do this drop down. And you can actually 
see the provider which for Windows is an exe.  
13:15 - And for Linux and Mac, you'll actually see another 
binary there. But this is compiled and you're not  
13:21 - going to go digging through it. As you can see 
here the VPC is actually pretty straightforward.  
13:27 - You basically specify the resource, this 
being the actual resource, as you can see,  
13:32 - AWS VPC, this is a static value that cannot be 
changed. If you change this, you're not going  
13:39 - to deploy a VPC. Now after that, we've got the 
name for this VPC, which in this case is main,  
13:45 - we can name it, whatever it is, we want. This is 
a logical name that only TerraForm knows about.  
13:52 - So this isn't going to show up in AWS anywhere. 
So again, make sure you understand that, but  
13:57 - this is how we will reference this VPC in future 
lessons. And then we just provide a cider block.  
14:03 - Now there are also lots of other options that 
you can specify here. As you can see, it gets  
14:08 - pretty complicated. If you go down to the argument 
reference, you can see that we have a lot of stuff  
14:14 - here we can use, such as enabled DNS support, 
which defaults to true in enabled DNS host names,  
14:20 - which defaults to false. So let's go ahead and 
let's utilize this to create a VPC, we're going  
14:27 - to bring my VS code back over here. And I'm going 
to create a new file and we're going to call that  
14:33 - main.tf. So I'll create a new file main.tf 
Just like so make sure that it is in the proper  
14:42 - directory here and you didn't accidentally 
add it within the TerraForm directory here.  
14:46 - And we've got that up. Now, the way these TF 
files are processed is they're processed as if  
14:52 - they're all the same file. So if you have 20, 
TF files in here, all with different resources,  
14:58 - they're all going to be processed Test as if 
they're the same file. So keep that in mind.  
15:03 - You can split up your code, however makes sense 
to you, you can have a compute.tf networking.tf,  
15:09 - whatever you'd like. It's all processed the 
same as long as it's in the same directory.  
15:14 - So let's go ahead and create this VPC 
resource. So I'm going to type resource,  
15:20 - AWS VPC, just like so. So this, of course, 
is specifying that I want a resource, or here  
15:26 - I wanted a provider. Here, I want a resource. Now 
once again, let's name this VPC. I'm going to name  
15:34 - it MTC for more than certified VPC just like so. 
And then I'm going to use some curly braces here.  
15:41 - This will wrap our entire resource that 
I want to specify that cider block.  
15:48 - And in my case, I'm going to do 10.123 dot 0.0 
slash 16. If you've taken my other courses,  
15:55 - you've probably seen this cider block before. 
Now under that, let's say I want to enable  
16:01 - DNS host names. As you remember, DNS host names 
defaults to false. So if I want to enable this,  
16:09 - I need to make sure that I add 
it. So I'll go ahead and enable  
16:15 - DNS host names equals true just like so. And if 
I wanted to, I can also say enable DNS support  
16:25 - equals true. Now we don't have to because this is 
assumed, however, depending on your development  
16:32 - team, you might want to ensure that this is 
explicitly mentioned, your team may not understand  
16:38 - what's default for your VPC. And it might be 
very helpful to be very explicit and specify some  
16:45 - things that default is true as true just to ensure 
that when it's easy to modify, and to your team  
16:51 - knows that this is enabled, again, not required, 
but it's something you might want to do. Now under  
16:57 - that, we're going to specify some tags. And I just 
want a name for it. And I'm just going to name  
17:04 - it Dev, just like so. So I know that this is my 
dev VPC whenever I go searching alright, and as  
17:10 - you can see, I've got my two curly braces 
here. One is to enclose these tags, and one  
17:15 - is to enclose this resource. So that's all I need 
there. Let's go ahead and run a TerraForm plan,  
17:22 - just like so. And what this is going to do 
is let us know what we're trying to build.  
17:29 - Just like so as you can see we've got all of 
these new pieces that are going to be created.  
17:34 - Within our VPC resource, we're going to have our 
cider block and Arn will be created which we won't  
17:40 - know until we actually apply it in the same with 
a lot of this other information such as the ID  
17:46 - we will not know until we apply it. Now as you can 
see we've got these green plus marks that means  
17:51 - that these are all being added. So that all looks 
good. We've got one actual resource AWS, VPC dot,  
17:59 - MTC VPC to add. So what we want to do next is 
apply we'll run a TerraForm apply, just like so.  
18:08 - And as you can see, it basically runs another 
plan, and then asks us to confirm and to confirm,  
18:16 - I'm going to type yes, scroll this up a 
little bit, and our VPC is being created.  
18:23 - All right, perfect. Our apply is now complete. 
So if we go over here to our AWS pane,  
18:30 - I'm going to click no here I do not need us 
East one right now because I am in US West.  
18:36 - I'm then going to click on Resources. And as you 
can see, I've actually got some resources already  
18:42 - shown here that's from a previous installation. 
If you click on this little sprocket type AWS  
18:48 - colon colon EC two colon colon VPC, you can also 
search for VPC, you can see that that's been  
18:54 - added, go ahead and checkmark that and click OK. 
To ensure that resources added, then if you click  
19:01 - on it, you'll see our brand new VPC is here. So 
there's our cider block, our default network ACL  
19:13 - default security group, it looks like 
everything is here enable DNS host names is true  
19:18 - enabled DNS support is true, we're going to take 
a slight detour from building to dive into the  
19:24 - TerraForm state a bit. So we better understand 
how information about our deployment is stored  
19:31 - for TerraForm. To use. This is probably one of the 
most important concepts with TerraForm. So make  
19:38 - sure you read over the documentation a good bit 
if you really want to understand how things work.  
19:43 - But essentially, we're just going to take a 
look here and see exactly what is stored in  
19:49 - our state as we deploy resources. As you 
can see, there's a lot here in the docs.  
19:55 - And we're going to explore several pieces 
of this as we build our infrastructure.  
20:01 - So here we are right here after we have now 
deployed our fresh new VPC. As you remember,  
20:07 - in our AWS resources pane here, you can see all 
of this wonderful information about our VPC. Now,  
20:15 - another way we can see what we've deployed, is 
to head into our Explorer. And right here, our  
20:22 - terraform.tf state file. As you can see, we have 
a lot of the same information default network ACL  
20:30 - default route, table ID, security group ID, the 
VPC ID there. As you can see, all of that is here,  
20:37 - VPC ID, default network, ACLs, security group, 
etc. Now, it's formatted a little bit differently.  
20:44 - But it's, for the most part, the same information. 
And this was all pulled right from the  
20:51 - AWS API. So now typically, you're not going to 
want to traverse this tf state manually as it  
20:58 - will normally be stored somewhere off site, 
whether it's in TerraForm, cloud or in AWS,  
21:03 - or somewhere else. So we have several 
different tools, we can use command line tools  
21:09 - to access the state. So let's take a look at 
TerraForm state list just like so. As you can see,  
21:17 - we only have one piece and our state one resource 
that MTC VPC that we deployed. So if I want to see  
21:25 - that information within that VPC, I can run 
a TerraForm state show, AWS VPC dot MTC VPC,  
21:35 - as you can see shown right here, I hit ENTER 
on that. We have all of the same information.  
21:46 - So we've got information here from our API, 
we've got information here within our state,  
21:52 - the state file specifically. But this 
is all the same information. It's just  
21:57 - formatted a little bit differently. 
Now you can output as JSON and  
22:02 - really manipulate that output. But we're not 
going to dive into that right now. All right. And  
22:07 - of course, if you want to see the entire state, 
all you have to do is just type TerraForm show.  
22:15 - So keep that in mind. TerraForm state 
show requires you to insert a resource.  
22:24 - Now TerraForm show is just going to show 
you everything that you've got, which of  
22:28 - course can be massive if you have a very large 
environment. So those are the basics of our state,  
22:35 - and the information that's being stored within it. 
There are a lot of commands that you can use to  
22:41 - manipulate that state to refresh it to migrate it. 
But we're not going to dive into that right now.  
22:47 - But just know, it'll be very beneficial to you. 
If you dive into the documentation a little bit,  
22:52 - and just read all about state as it is the 
most important feature within TerraForm.  
22:59 - We're going to check out a command almost as fun 
to use this TerraForm apply, but much more fun  
23:05 - to say. And that command is TerraForm destroy. 
So TerraForm destroy is pretty straightforward.  
23:13 - Basically, it's going to destroy anything that 
we have created. And as you can see here, you can  
23:21 - actually run a TerraForm apply dash destroy. 
But we typically just use TerraForm destroy,  
23:28 - there's not a lot else going on here that 
you need to really worry about, you can run  
23:34 - a TerraForm plan in destroy mode, which will tell 
you what happens when you destroy. So that can be  
23:41 - fairly useful if you need to test something out. 
But for the most part, we're just going to run  
23:45 - this TerraForm destroy. So let's do that. Let's 
knock out this VPC that we created completely  
23:51 - delete everything we have applied. So just run 
TerraForm destroy. And then we can just use a dash  
23:58 - auto approve if we don't want that confirmation 
dialog, again, useful in automation. Probably  
24:04 - wouldn't use this in production. If you're typing 
it yourself though. Let's go ahead and run that.  
24:13 - Alright, right, the destruction is complete, 
everything is gone. So that's really all you  
24:19 - need to know there. So go ahead and reapply 
it as we're going to need this VPC for pretty  
24:25 - much the remainder of the course. So TerraForm 
apply, auto approve, just like so. All right,  
24:33 - all set. We're back to where we left off. You saw 
how easy that was. This is one of the great things  
24:38 - about TerraForm infrastructure just comes and goes 
as you need it. We're going to deploy a subnet to  
24:45 - which we can deploy our future EC two instance. 
As you can see here in the docs, it's pretty  
24:51 - straightforward. Although there are a few more 
options, we're going to want to add one of them  
24:57 - and if you scroll down here is To map public IP 
on launch, default is false. We want to make sure  
25:05 - that our instance receives a public IP address 
whenever we launch into the subnet, so we want  
25:12 - to ensure we add that so let's go ahead and get 
started. All right, so right here under my VPC,  
25:21 - we're going to add another resource. And that 
resource is AWS underscore subnet. Just like so.  
25:27 - And then let's go ahead and name it. I'll just use 
MTC underscore public underscore subnet, just like  
25:35 - so. And you don't always have to add a prefix like 
this. Although I've been doing it for so long. If  
25:41 - I did not add this prefix, this course would be 
way too long due to all the errors I've made. So  
25:48 - for consistency sake, I'm just going to keep this 
MTC prefix on all of my resources. All right, so  
25:54 - let's go ahead and open and close those resource 
braces. And what we need to do is provide a VPC  
25:59 - ID now as you remember, when we ran our TerraForm 
state list, we've got a list of our resources.  
26:08 - And this is how we want to access this VPC 
resource. So what we're going to do is AWS  
26:16 - VPC dot, MTC underscore VPC, which again, matches 
this as well. And since this is another resource,  
26:23 - it's like a variable, it's not a string, so you're 
not going to quote this. This is a reference to a  
26:30 - resource, so you don't need to add quotes. And 
then what we need to do is just specify an ID.  
26:35 - So if I do the TerraForm, state show, AWS, VPC 
dot, MTC, VPC, just like so we can see that it has  
26:44 - an ID attribute. And that's the ID that we need 
for our subnets. So we just specify that.id Right  
26:53 - there. And that's how you're going to reference 
most of the resources that you have to reference  
26:58 - from other resources. So next, we 
need to provide our cider block.  
27:03 - And that's going to equal 10.123. And I'm just 
going to say, dot 1.0, slash 24, which, of course,  
27:10 - is one of the subnets within this slash 16. And 
then after that, we're going to add our map,  
27:17 - public IP on launch, that's a long one there, 
equals true and since this is a Boolean, it's  
27:24 - also not quoted. And then we need to provide an 
availability zone, just like so. And that'll be US  
27:31 - West. And we're just going to use to a or at least 
I am, because I know a is probably good to go.  
27:38 - There are ways to use what are called data 
sources to ensure that this is always correct,  
27:43 - especially if you're using multiple availability 
zones. But we're not going to dive into that now.  
27:49 - But feel free, of course, to research that if you 
are curious. So next up, we're going to add tags.  
27:57 - And that name equals Dev. Public, we'll just 
go with that. So the VPC, we just named Dev.  
28:04 - And we'll just name this here as dev public 
so that we know that it's a public subnet.  
28:10 - Again, map public IP on launch equals true 
is a good reason for us to want to make sure  
28:16 - we label it correctly. So we don't accidentally 
put sensitive resources in this subnet, which of  
28:21 - course, could cause a security nightmare. Alright, 
so that's all we have to do for this subnet. Let's  
28:27 - go ahead and run our TerraForm plan. All right, 
we've got one resource to add. So that's good  
28:34 - and AWS subnet is going to get added. As you can 
see, everything we have specified is listed here.  
28:41 - And of course, certain things like the ID are 
known after apply. So let's go ahead and run  
28:47 - a TerraForm apply. And then I'm just going to add 
auto approve, you're not always going to do this.  
28:52 - But if you're running a plan first, it's usually 
pretty safe to go ahead and just auto approve it,  
28:58 - and not have to type that yes, every single 
time. This especially is useful in automation.  
29:04 - So I'll go ahead and run this. All right, 
one added, everything looks successful.  
29:10 - So I'll go ahead and click on this sprocket 
next to resources, which again is in the AWS  
29:15 - pane. And I'll go ahead and type subnet. As 
you can see, we actually do not have subnets  
29:20 - available. This is a limitation of this AWS 
plugin, so we're not going to worry about it.  
29:28 - But it looks like that subnet creation was 
successful. And of course, you can always go into  
29:33 - the AWS console to verify we are going to give 
our resources a way to the internet by creating an  
29:40 - Internet Gateway. We will then introduce TerraForm 
format to clean up our code a little bit.  
29:46 - So let's get started. As you can see here, the 
Internet Gateway is pretty straightforward. It's  
29:52 - actually a really simple resource to deploy. 
We've got a few attributes here. These are the  
29:57 - things that will be exported. within our 
state, and these are the arguments VPC ID  
30:03 - tags and default tags. So let's just go ahead and 
knock this out. Alright, so here we are. Let's  
30:10 - go ahead and scroll down a little bit under 
our subnet, and we will add a new resource.  
30:16 - AWS Internet Gateway just like so. And we'll 
call that the MTC Internet Gateway. All right,  
30:27 - and then I will open and close my braces. Let's 
add that VPC ID. And remember how we access  
30:34 - this VPC AWS, VPC dot, MTC vpc.id. Just like so in 
fact, I can even copy this to save a little bit of  
30:45 - time, and just paste it in. And then just for the 
heck of it, I'm gonna go ahead and add some tags.  
30:53 - And we'll give it a name of DEV Igw, just like 
so. So we've got our dev VPC, our dev public,  
31:04 - and our dev Igw. So once we've done that, that's 
literally all we've got to do. But let's go ahead  
31:12 - and introduce that fun new command. If you go 
ahead and run a TerraForm, FMT, just like so  
31:19 - what that just did was that corrected any type 
of inconsistencies we've got in formatting,  
31:27 - as you can see, main.tf and providers.tf, 
or both corrected. Now, unfortunately,  
31:33 - I was not scrolled up. But as you can see, now 
all of our equal signs are lined up perfectly.  
31:38 - So it made some very minor formatting 
changes, but it looks a whole lot better.  
31:45 - So that's great. And if you want to 
see it in action, just go ahead and  
31:49 - move that a little bit. Run the command again. 
And as you can see, it automatically corrects.  
31:56 - Alright, so let's go ahead and deploy this brand 
new Internet Gateway. Go ahead and run TerraForm  
32:03 - plan, just like so. All right one to add. As you 
can see, we've got our Internet Gateway that's  
32:11 - going to get added. So let's go ahead and run 
a TerraForm apply. Auto approve, just like so.  
32:23 - Okay, apply complete, everything looks 
good. Let's click on our AWS pane. And  
32:28 - let's see if we can access this resource. 
Just go ahead and type internet. Haha,  
32:34 - AWS Internet Gateway, we've got it. So 
let's go ahead and check that and select  
32:39 - OK. And if I expand my resources here, and 
take a look under EC two Internet Gateway,  
32:47 - we'll see we've got two. So if I 
click on the one with the longer ID  
32:55 - we can see right here that 
we've got our Internet Gateway.  
32:59 - With the proper tag, we're going to create a 
route table to route traffic from our subnet  
33:05 - to our Internet Gateway. All right, here I am 
in the docks. And as you can see, there's a  
33:11 - note here. And basically, you can use a standalone 
route resource. Or you can define routes in line.  
33:20 - Now in this case, they have the routes defined 
in line just like so we're going to do it a  
33:25 - little bit differently, we're actually going to 
use a route resource, which as you can see here  
33:31 - is also fairly straightforward. And we'll 
walk through this here shortly. So let's  
33:36 - head back over to our route table. As you 
can see, all we basically need is the VPC ID,  
33:42 - and then we'll provide some tax. So let's go ahead 
and do that. So I'll open my main.tf. Once again,  
33:50 - scroll down some, let's go ahead and create 
that resource AWS route table, just like so.  
33:58 - MTC public R T, just keep 
it from getting too long,  
34:03 - and open and close our resource braces. And within 
here we need to provide that VPC ID again. And  
34:10 - as always, I'll just copy this and paste it 
right there. And then we'll add some tags.  
34:18 - Name equals Dev, public AR T, just 
like so. So now that we've done that,  
34:25 - once again, remember, we then need to add the AWS 
route, which is right here. And basically we need  
34:31 - to specify a route table ID, destination cider 
block. And in our case in Internet Gateway, so  
34:38 - let's go ahead and do that. So we'll create that 
resource AWS route just like so. default route is  
34:47 - what we'll call it. This is a default route, of 
course for all traffic to get to the internet.  
34:52 - Open and close those resource braces, route table 
ID equals and we're going to need to Use the AWS  
35:00 - route table in TC public RT AWS route, table 
dot MTC public RT. And once again, all we need  
35:10 - to specify is the ID, it's asking for an ID. 
And pretty much universally, all AWS resources  
35:17 - are going to have this ID attribute. So then we 
need a destination cider block, just like so.  
35:26 - And that's going to be 0.0 dot 0.0 slash 
zero, which means all IP addresses will  
35:32 - head for this internet gateway. And then again, 
that Gateway ID is now going to be AWS Internet  
35:41 - Gateway just like so. Dot MTC and as you can 
see, VS code is providing me some nice little  
35:49 - hints. So I'm just going to hit Tab, Internet 
gateway.id. Just like so if we scroll up,  
35:56 - we can see TC Internet Gateway right here. 
All right, perfect. That's all we need to add.  
36:04 - So let's go ahead and I'm going to scroll this 
up. Let's go ahead and run that TerraForm plan.  
36:10 - And we should have two resources to add this time. 
Perfect to to add, we've got our route table.  
36:18 - And we've got our route. So that's great. Let's go 
ahead and run our TerraForm apply, auto approve.  
36:31 - And everything was applied successfully. Let's 
go ahead and click on the little sprocket  
36:37 - next to resources and see what we have to 
offer. So what we've deployed is a route table.  
36:44 - AWS EC to route table great. And then I actually 
do not see a route that we want to use. So we're  
36:52 - just going to take a look at the route table. All 
right, here it is. It's going to be one of these  
37:02 - dev public route table. Perfect. We're going to 
bridge the gap between our route table and our  
37:09 - subnet by providing a route table association. 
So let's go ahead and get started. As you  
37:15 - can see here in the docs, the AWS route table 
association is actually pretty straightforward.  
37:22 - Basically, we just need to access 
our subnet and our route table ID.  
37:27 - And just specify both of those in an association. 
So let's go ahead and knock that out. All right,  
37:34 - so I'm gonna go ahead and scroll 
down under this route here, resource  
37:39 - and AWS route, table Association, 
probably one of the longer resource names,  
37:46 - MTC public, and I'll just call it an a sock 
there and open and close my resource braces,  
37:54 - we need to provide our subnet id. In 
that we just scroll up and take a look.  
38:02 - AWS subnet, MTC public subnet and then once 
again, we just need to provide the ID of that.  
38:09 - So AWS subnet auto complete that dot MTC 
scroll down here public subnet remove  
38:19 - some typing and potential for errors.id. Just 
like so. So that's all we've got to do there.  
38:28 - Then we need to provide a route table ID in that 
once again, we can just copy right from here.  
38:36 - And paste in. All right. So that is 
literally it. Let's go ahead and save.  
38:43 - And then I'm also going to run another 
TerraForm FMT just to clean things up,  
38:47 - look at that much more beautiful. All right. And 
then let's go ahead and run our TerraForm plan.  
38:57 - Perfect One to add our route table Association. 
And we'll run a TerraForm apply, auto approve.  
39:08 - All right, that is all set and all done. And 
if we want to see that association and some  
39:14 - of the other things we've created, we can't 
access those from the resources. So of course,  
39:19 - we can always go to the console 
here. We can access the VPC area  
39:26 - and the route tables. We've got our dev public 
RT right here. Take a look at our subnet  
39:34 - associations. And there it is. Our dev public 
subnet is associated with this route table,  
39:42 - we're going to add a very important resource 
to our deployment, the security group.  
39:47 - So here we are on the documentation, as you can 
see here is an illustration of the usage of a  
39:54 - security group. Now in this case, they've actually 
defined the ingress and egress in law Live,  
40:00 - which is perfectly fine. Now you can specify 
them separately, as you can see by this note,  
40:06 - as a security group rule resource just like we did 
with a route resource. But this is perfectly fine.  
40:13 - Now in your organization, you may find a benefit 
to adding separate resources. But in our case,  
40:20 - this will work perfectly. So as you can see here, 
the egress actually allows egress to everything  
40:26 - on any protocol, that's zero to zero. And then 
the protocol is negative one, which means UDP,  
40:33 - TCP, ICMP, etc. Any protocol, you need to use 
negative one, we'll cover it now the ingress only  
40:40 - allows port 443. But we actually want to allow 
everything, we're just going to ensure that we  
40:47 - hard code this IP to our own IP, so that we don't 
allow someone to compromise that our instance. So  
40:54 - let's go ahead and get started. Now, sometimes, I 
might actually choose to just copy this and paste  
41:01 - it into my IDE, and then modify from there to 
simplify things. But since this documentation  
41:07 - may have changed by the time you watch this, we're 
going to type it out manually. So let's go ahead  
41:13 - and start that. We're going to add our resource 
like always, AWS security group, just like so.  
41:22 - And let's just name that MTC SG for right now, 
we'll open and close those resource braces,  
41:28 - we'll create a name. That's dev S G. 
Sounds good to me. Now, keep in mind,  
41:35 - we don't need a tag here, because the security 
groups actually have a name attribute. So there's  
41:41 - no point in having to tag it, you of course, could 
tag it for other organizational reasons. But as  
41:47 - far as the name goes, this is perfectly fine. 
After that, we need to provide a description  
41:53 - dev security group sounds great to 
me, we then need to provide a VPC ID,  
42:00 - which we've used many, many times, I'm 
actually going to just scroll up, copy this  
42:08 - and paste it down here just like 
so. And then we need to provide  
42:12 - our ingress and egress. So let's go ahead 
and add our ingress here. From Port,  
42:19 - make sure you have that underscore there 
from Port equals zero to port equals zero  
42:27 - protocol equals, in quotes here negative one, 
this is presented like a string TerraForm is  
42:35 - not going to honor this negative right here, this 
dash. So make sure you specify this as a string.  
42:42 - And then cider blocks equals now I'm just going 
to put in 0.0 dot 0.0 slash zero. Because I don't  
42:51 - want to show everyone my IP address. Make sure 
you only add your own IP address here. So you  
42:58 - can go to what's my IP or somewhere else to find 
your IP address. And then that will be something  
43:04 - something something something slash 32. That slash 
32 indicates you want to use only this address.  
43:13 - But again, I'm just going to put anything 
for right now. And I'll be sure to destroy  
43:18 - my infrastructure that has this open port and 
replace it with my own later. Now as you notice,  
43:24 - this is cider blocks with an S which 
indicates that it expects a list.  
43:31 - Now these brackets allow you to enter lists. So if 
you had multiple IPs, you could put a comma here  
43:38 - and specify another one after that. But we only 
need one. All right, so our ingress is taken care  
43:46 - of. Now let's set up our egress. gonna slide this 
down a little bit, there we go. egress from Port  
43:55 - equals zero to four equals zero. Protocol, once 
again equals negative one, insider blocks. In this  
44:05 - case, I'm going to allow whatever goes into 
this subnet to access anything so you won't  
44:10 - put your IP address here. You will make sure you 
allow it to access the open Internet. All right,  
44:16 - perfect. So that's all we need to do there. 
Let's run a TerraForm FMT to clean that up. There  
44:23 - we go. Beautiful. Then let's go ahead and run a 
TerraForm plan and make sure everything works out.  
44:33 - Slide that up. Okay, one to add like we expected. 
Looks like everything looks good here from Port  
44:40 - zero protocol, negative one to port zero. Perfect. 
Let's go ahead and run that. TerraForm apply,  
44:46 - auto approve. All right, all complete. 
Let's scroll over to our AWS console.  
44:57 - I will click on Security Groups  
45:01 - Go ahead and refresh that page 
here is our dev s g. by open that,  
45:08 - click on Edit inbound rules, we can see all 
traffic is allowed on all protocols, all ports,  
45:16 - custom source, and again in my case is 0.0 
dot 0.0 slash zero. All right, perfect.  
45:24 - We're almost to the deployment of our EC two 
instance. But first, we need to provide the  
45:30 - AMI from which we want to deploy. To do this, 
we can utilize what's called a data source.  
45:37 - A data source is basically just a query of 
the AWS API to receive information needed to  
45:44 - deploy a resource. In this case, we need an AMI ID 
based on some filters we're going to provide. So  
45:52 - let's get started. So if I head over here to my 
data source documents here for the AWS AMI, you  
45:58 - can see an example, data AWS Ami. And of course 
data basically is like the resource keyword we've  
46:05 - been using, we're just using data. Now AWS AMI 
is the name of this data source. And of course,  
46:11 - this needs to stay the same no matter what. And 
then this here can be whatever you want to name  
46:16 - it. Now we'll be using most recent, and we'll be 
using some filters as well. Now one thing we have  
46:22 - to make sure is that we have the correct owner. 
Now one way to do that is to use AWS Marketplace.  
46:29 - But in our case, we're going to be a little more 
specific, let's take a look at how to get the  
46:34 - owner ID we need. So if I head into the management 
console here, going to type EC two up at the top.  
46:44 - Going to open that, if I go to instances and 
Launch Instance, let's take a look. I'm just  
46:50 - going to type Ubuntu here. And I'm going to deploy 
Ubuntu server 1804. That's what I've used in my  
46:57 - other courses. And I'm just going to stick to 
that for now. 2004 should work perfectly fine.  
47:02 - And whatever it is you want, you can choose. But 
in our case, we're just going to use this 1804.  
47:07 - So what I'm going to do is copy this AMI ID 
because an owner ID is not provided here, which is  
47:13 - a little annoying. And then I'm going to head back 
to my EC to console. And I'm going to click on  
47:19 - AMI under images. And right there, make sure you 
have public images chosen and enter that AMI ID.  
47:28 - And here is our owner. So go ahead and copy that 
you're going to need it here shortly. Alright, so  
47:34 - once we have that, let's head back over and start 
coding this thing out. Let me drop this a little  
47:40 - give us some room. So now what I'm going to do 
is actually create a new file for this. And we're  
47:46 - going to call it data sources.tf. So I'll 
just create a new file, and data sources.tf,  
47:54 - just like so. And this will just keep things 
a little cleaner. So we'll use data, AWS AMI,  
48:03 - and we'll just call it our server 
AMI or whatever you want to call it,  
48:07 - we want to specify most recent equals true. 
And then we provide the owners. Now the owners,  
48:14 - as you can see is plural. So we're actually going 
to use brackets, which makes it a list. Go ahead  
48:20 - and paste that owner ID that we got into here. And 
of course, if there are other owners, you could  
48:26 - but in this case, we just need that owner ID. All 
right, now that we have provided our owners here,  
48:33 - let's go ahead and provide a filter to get the 
correct Ami. So if I type filter, just like so,  
48:41 - name equals, and we're going to filter on 
name, I know this looks a little confusing,  
48:46 - but the filter name is actually name and then 
values equals and once again, this is plural,  
48:54 - so make sure it's in brackets. Ubuntu slash 
images, slash HV M dash S S D slash Ubuntu  
49:05 - bionic dash 18 dot o four dash AMD 64. Make 
sure you have the right architecture there.  
49:13 - Dash server Dash. And then what we're going 
to do since there's usually a date here,  
49:19 - and we're just going to pull the most recent no 
matter what, we're just going to add an asterisk.  
49:24 - So instead of the date that we would use here, 
we use an asterisk so that any date will qualify.  
49:29 - So if I just head right back over here and take 
a look, you can see. Basically all we're doing is  
49:36 - just putting an asterisk instead of this date, but 
everything else is exactly the same. All right,  
49:42 - so perfect. So that's actually all we 
need to do. Go ahead and save this file.  
49:50 - And then let's go ahead and run a TerraForm 
apply TerraForm apply auto approved just like so.  
50:02 - All right, great. So now that is applied. So 
if I open my terraform.tf state right here,  
50:09 - again, you would usually use a TerraForm show. 
But this is a little bit easier for this.  
50:13 - We can scroll down under resources. And 
you can actually see we have instances,  
50:20 - even though we don't have any EC two instances 
actually deployed, there's still an instances  
50:25 - section that contains this AMI data source. 
And if you look down, you can actually see,  
50:30 - we've got an image ID right here, which actually 
does not match here. And there's a reason for  
50:37 - that. And that is, if you look at the date, 2021 
1129, the date of this one is actually 2022 0104.  
50:49 - So this is actually a newer instance than 
what is in the console, which is why that  
50:54 - AMI doesn't match. And for our purposes, that's 
perfectly fine, we're going to create a key pair,  
51:00 - and then create a TerraForm resource that 
utilizes this key pair. This will be used  
51:06 - by the EC two instance resource we create 
so that we can SSH into it later. So let's  
51:12 - get started. All right, I'm gonna first highlight 
my main.tf here, and then I'm gonna go ahead and  
51:19 - create that key pair. So to do that, and yes, 
I am on Windows, Windows actually does have an  
51:25 - SSH utility. So I'm going to run the same commands 
that I would run on OSX or Linux, SSH dash key Gen  
51:35 - dash t. And we will use a more secure key than 
the typical RSA we use, let's use Ed 25519,  
51:45 - and hit Enter. Now we're going 
to rename this key pair here,  
51:48 - I'm just going to copy this instead of retyping. 
It basically everything before the ID EDI 25519.  
51:58 - And I'm going to paste that in. And then we're 
just going to name this MTC key, or at least I am,  
52:04 - name it, whatever you want here, just make sure 
you reference it properly throughout the rest  
52:08 - of the course. And I'll hit enter, we're not 
going to bother with a passphrase. All right,  
52:13 - perfect. It looks like everything is good to 
go. Just going to run an LS tilde slash dot  
52:18 - SSH here. And that shows me that directory. And 
MTC key is there an empty C key dot pub, which  
52:27 - is what we'll use for our key resource. So now 
let's take a look at the Docs as we usually do.  
52:33 - Resource AWS key pair, as you see, we basically 
need to specify a resource, AWS key pair and the  
52:41 - name that wherever we need to, we'll give it a 
name. And then we will provide the public key.  
52:46 - Now we could just copy and paste the public key 
from our file. But that looks very, very messy.  
52:54 - So what we're going to do is use a TerraForm 
function, we're going to use the file function.  
53:01 - So all we have to do is utilize file and then 
enter the path to our key. And what that will  
53:08 - allow us to do is specify the key just like 
this only much shorter by just passing in a  
53:14 - path instead of the full public key. So let's go 
ahead and do that. So we'll start with a resource.  
53:22 - AWS key pair just like so after that, I'm just 
going to call it MTC off, open and close those  
53:30 - resource braces. Key name, I'm going to go ahead 
and call that MTC key just to keep things simple.  
53:38 - And then we need to pass in that public key. 
And to do that, we're going to utilize the file  
53:44 - function. And we'll quote this and I'll use 
that tilde slash dot SSH slash MTC key dot pub.  
53:54 - And again, I'm on Windows, but these commands 
should all pretty much line up and be the same.  
54:00 - So I'm going to go ahead and save that. Gonna run 
a TerraForm plan. Make sure everything looks good.  
54:07 - I'll scroll up here a little bit. All right, 
perfect. So the key pair will be created looks  
54:14 - like everything past those initial checks. So I'll 
run a TerraForm apply, auto approve, just like so.  
54:24 - All right, apply complete. So if I take 
a look over here and my AWS resources,  
54:31 - we can see if this is one that is available for 
us, so I'll just type in key. Unfortunately,  
54:38 - key pair does not appear to be one that we can see 
right here from this screen. So we'll just head  
54:44 - back into the EC two console. I'll click on key 
pairs. And there it is. MTC key type EDI, 25519.  
54:55 - Everything looks great. We're going to 
finally deploy our E See to instance,  
55:01 - it won't have anything installed on it yet. But 
we'll at least get it scaffolded and deployed.  
55:07 - So let's get started. All right, we take a look 
at our docks here, the resource is actually called  
55:13 - AWS instance, as you can see, in the basic 
example, it's using an AMI lookup, which looks  
55:21 - very similar to what we have used before. As you 
can see, it's got the owner, it's got everything  
55:26 - else here. Of course, we already saw how to get 
the owner ID ourself, so that's great. And then  
55:32 - basically, we just need to provide that AMI and 
you reference that by using the data keyword,  
55:38 - dot AWS underscore AMI dot Ubuntu ID. So do keep 
that in mind where typically with a resource,  
55:46 - we would just use AWS vpc.my vpc.id, for instance, 
but with a data source, you need to pin that  
55:55 - with the word data. And then we'll just 
provide a few more arguments. As you can see,  
56:00 - there are a lot of arguments for the EC two 
instance. So let's go ahead and start coding  
56:08 - this thing out. All right, so what I'm going 
to do, let's scroll this down a little bit. And  
56:15 - let's add our resource. AWS instance, just like 
so I'll just call this dev node, just like so  
56:23 - open and close those resource braces, we need to 
provide an instance type first. And to keep this  
56:30 - in the free tier, we will use a T two dot 
micro Of course, you can scale that up,  
56:35 - but that might cost you some money. And then 
we need to provide our Ami. So as you remember,  
56:41 - the AMI in our data source here is data dot AWS 
AMI dot server AMI data dot AWS underscore AMI  
56:52 - dot server AMI, just like so. And then 
we just need to add ID to the end.  
57:01 - And then let's add some tags. We'll just give it 
a name equals, and we'll call it dev dash node,  
57:08 - just like so. Now after that, we need to provide 
our key name, which of course we created recently.  
57:15 - And what we're going to use is AWS key pair, 
which of course we just created right here,  
57:23 - dot MTC underscore off.id. Once 
again, now I see that this says key  
57:29 - name and not necessarily ID, but the ID 
is perfectly fine. Here the ID will work.  
57:36 - Now if you take a look by just running TerraForm 
state show AWS key pair dot MTC underscore off  
57:46 - we can see there actually is a key name. 
So if you want to be more explicit,  
57:50 - you can absolutely use key name ID is just a force 
of habit. It's something that I do frequently.  
57:56 - As you can see, it is the same for both. So 
both works perfectly fine. But just know you  
58:03 - can use key underscore name if you want to be more 
explicit. Alright, so now that we've done that,  
58:09 - let's go ahead and give this EC 
two instance a security group  
58:12 - VPC Security Group IDs. You see this s here, 
which means you guessed it, we need to use  
58:20 - brackets. And I'm just going to do AWS underscore 
security and tab there to autofill. That dot  
58:27 - MTC underscore s g. Right there.id. And 
of course, if you have multiple you can  
58:37 - use comma separation to provide multiple security 
groups. And then we just need a subnet id.  
58:44 - So that's going to be AWS subnet dot MTC 
underscore public subnet just like so.id.  
58:55 - Then if we want to resize the default size of the 
drive on this instance, we can provide root block  
59:03 - device just like so. And you can actually up this 
we can say volume, size equals you could say we'll  
59:12 - just say 10. We'll keep it in the free tier, which 
gives you 16. So we'll just say volume size equals  
59:17 - 10, which is larger than the eight that they give 
you by default. All right, so that actually is  
59:23 - all we need to add for our instance for now. 
Let's go ahead and run our TerraForm plan.  
59:32 - All right. As you can see, we've got a lot of 
attributes there. But everything looks good to go.  
59:41 - But actually don't bother applying yet. We're 
going to go ahead and come on back to the next  
59:47 - lesson and add some user data before we apply this 
instance. So we don't have to wait for it and then  
59:53 - just re destroy it. We're going to utilize user 
data to bootstrap our instance and install the  
59:59 - doc per engine. This will allow us to have an 
easy to instance deployed with Docker ready  
60:05 - to go for all of our development needs. So let's 
get started. Now the first thing I'm going to do  
60:11 - is just clean up this AWS instance a 
little bit, I'm going to cut this out.  
60:18 - And I'm just going to take everything that's not 
in a block, and place it together. So this will  
60:23 - make things look a little more streamlined. So as 
you can see, we've got all of our arguments here,  
60:29 - followed by the tags block, and the root device 
block. And just to be consistent, I'm actually  
60:36 - going to cut out this root device block and put it 
above the tags block since almost everywhere, we  
60:42 - finish the resource with tags. All right, perfect. 
So that looks a lot better. So now let's add this  
60:49 - user data. First thing I want to do is create 
the user data file. So I'll create a new file.  
60:56 - And let's just call it user data dot 
tpl. Now, this TPL actually stands for  
61:01 - template. We're not using this as a template 
right now. But just in case in the future,  
61:07 - you decide to use it as a template you can 
and we'll take a look at templating here  
61:12 - in the coming lessons. Alright, so go ahead and 
take that script I have provided in this lesson,  
61:18 - and paste that in. Now this script, as you can see 
is going to update apt, it's going to install some  
61:25 - dependencies, it's going to download the Docker 
GPG key, it's going to add the Docker repository  
61:33 - update once again, install Docker, and then 
it's going to add Ubuntu to the Docker group,  
61:40 - allowing you to run Docker commands as the 
Ubuntu user. I know that was a little quick,  
61:45 - feel free to reach out if you have any 
questions. So now that we've got this in,  
61:50 - it's in our user data dot tpl script, and I 
have saved it and this is in our root directory.  
61:56 - Let's head back to our main.tf. And let's go 
ahead and add this user data to our resource.  
62:03 - So what I'll do is just add user underscore data 
equals, and we're just going to use the file  
62:11 - function here. And in quotes, once again, 
user data dot tpl. So what this is going  
62:17 - to do is extract the contents from our user 
data dot tpl file and use that to bootstrap  
62:23 - our instance. So Perfect, let's go ahead and see 
if everything works. Let's run a TerraForm plan.  
62:33 - All right one to add. As you can see, 
we've got our EC two instance here,  
62:39 - everything's looking pretty good. As you can 
see, our user data is hashed here. So if this  
62:45 - user data were to change, it actually would change 
that hash and indicate that we need to redeploy  
62:51 - our instance. So that's really, really 
useful. So now let's go ahead and apply  
62:58 - TerraForm apply, auto approve, just like 
so. Now, this is going to take a little bit,  
63:05 - so feel free to pause, and then come on 
back whenever your instance is deployed.  
63:13 - All right, as you can see, the apply is complete, 
I'm going to head into my PC to console,  
63:22 - just like so. And as you can see, it's running. 
And I've actually had a few dead ones here.  
63:30 - But this new one is running, but it's still 
initializing. So go ahead and pause the video once  
63:35 - again, hit refresh a few times, and come on back 
whenever the status check is green. All right,  
63:42 - so now everything is green, we've got to have 
two checks past perfect. So now let's SSH into  
63:49 - the instance. First of all, I need that IP 
address, so we can definitely just copy it  
63:54 - from right here. But another way, of course, is to 
use our TerraForm state. So if we do a TerraForm  
64:01 - state list, just like so we then see our 
instance right here, I'm just going to copy that.  
64:09 - Then I'm going to do a TerraForm state 
show and hit that instance right there.  
64:17 - And here's all of the information we can get it 
if I scroll up a little bit, I've got the public  
64:22 - IP address right here. Perfect. So now what I'm 
going to do is just do it SSH dash i. Then if  
64:30 - you're on Linux or Windows, you can use the tilde 
slash dot SSH slash MTC key or whatever you name  
64:38 - that key. Now, if I hit tab that will actually 
correct it for Windows users, but it doesn't  
64:44 - matter. It works either way. And then I'm just 
going to use my Ubuntu username at that public IP  
64:51 - address. And hit Enter. Type yes, and bam we are 
in the instance now. So if I run a Docker version.  
65:02 - As you can see, we now have Docker installed and 
the instance is running, we're going to take a  
65:08 - look at the configuration we're going to have 
to create to allow VS code to connect to our  
65:15 - EC two instance. So first of all, if you haven't 
already, head over to the extensions, and go ahead  
65:23 - and search for SSH. And you should see this remote 
SSH app here. Go ahead and install that extension.  
65:35 - Just like so. Alright, perfect. So now that 
we've done that, we can go ahead and head  
65:41 - back to the Explorer. And first thing I want 
to do is take a look at some example config  
65:47 - files. So you should have a file now at 
your home slash dot SSH slash config.  
65:57 - So if I do cat, SSH config, just like so. I 
can see here that I already have two entries.  
66:06 - Of course, this is something I've done before. 
And what we need is we need to provide a host,  
66:12 - a host name, which happened to be the same here 
and the user that we're going to use to log in.  
66:18 - So what we need to do is provide the IP address 
of our instance, on both of these host areas host  
66:24 - and host name. And then we'll utilize Ubuntu for 
the user. So how are we going to do that? What  
66:32 - we're going to do is we're going to use template 
files. And we'll take a look into that very soon.  
66:39 - But first, let's create the files. So go ahead 
and create a file based on your operating system.  
66:46 - Whether you're on Windows, or Linux or Mac, 
Linux and Mac can both use the same script,  
66:51 - Windows is going to be different. So I'm 
going to create both in this lesson. First,  
66:56 - I'm just going to create windows dash SSH config 
dot tpl, just like so. And if you're on Windows,  
67:04 - go ahead and grab that script, copy it, and paste 
it in. So basically what this is doing, and you  
67:12 - will need to replace your username here. Mine, 
of course is Derek yours probably isn't Derek,  
67:17 - but you might be go ahead and replace that. And 
then this is going to add the host host name user  
67:24 - and an identity file, which we didn't see before. 
But we do require to our config. Now what we do  
67:32 - is we actually specify the host name, the 
user and identity file from our main.tf.  
67:40 - And we're going to take a look at how to do 
that in the coming lessons. So go ahead and  
67:46 - save this file if your windows. And if you're 
Linux, let's go ahead and create that one.  
67:53 - So again, you can call this Mac if 
you want, I'm just going to call  
67:56 - Linux SSH config for our file name. And this 
will serve for either Mac or Linux. And for that,  
68:04 - go ahead and copy the script and paste it in. And 
what we've got here is we're actually catting into  
68:10 - home dot SSH slash config. And then we've got the 
host host name, host name, user and identity file,  
68:17 - just as we did before. So go ahead and save that 
file. If you're Linux, you can also provide both  
68:23 - if you utilize both platforms like I do, 
we're going to utilize a provisioner to  
68:28 - configure the VS code on our local terminal 
to be able to SSH into our EC two instance.  
68:35 - Now a provisioner is not something you want to 
use for every deployment. Unlike other resources,  
68:42 - a provisioner success or failure will not 
be recorded or managed by TerraForm state.  
68:47 - So if something goes wrong, that's just too bad. 
There's no rollback or any other way to manage it  
68:54 - other than just running it again. While this 
is not good for configuring remote instances,  
68:59 - it's perfectly fine. For something like this, all 
we're going to be doing is adding information to  
69:06 - a config file on our local terminal. This is a 
lightweight operation that doesn't affect the  
69:12 - overall success of the deployment if something 
were to go wrong. So with that being said,  
69:17 - let's get started. First, we'll take a look over 
here at the provisioner documents. As you can see,  
69:24 - provisioners are a last resort. Generally 
speaking, you're going to want to use  
69:29 - user data which of course we do Ansible or 
packer, or chef or something else some other  
69:37 - configuration management tool. If there's some 
sort of configuration we need to do on a remote  
69:43 - instance. But once again, on our situation, 
it's perfectly fine. And we can use the local  
69:50 - exec provisioner to allow us to configure local 
machines and run local commands. As you can see,  
69:57 - basically we're running a provisioner 
and in this case a Local exec provisioner  
70:01 - within an AWS instance, resource provisioners are 
always run within another resource. This could be  
70:08 - something called a null resource also. But we're 
not going to look into that right now. Now another  
70:14 - thing we're going to use is this self object here, 
which basically allows us to access this instance,  
70:22 - and access information. So if we need a 
private IP, or public IP, or whatever,  
70:26 - we're able to access that right here, using 
this self attribute. Now, something else you  
70:32 - might notice, we've got this dollar sign, and 
braces here, that is interpolation syntax. And  
70:40 - basically what that means is this is going to be 
replaced by whatever it is we're trying to use.  
70:46 - So we've got a string here. But this here will be 
replaced by the private IP of this AWS instance.  
70:54 - And you may have remembered that in our previous 
scripts, so let's go ahead and just get to work.  
71:00 - So right over here, once again, we can take a 
look at our configuration files. And once again,  
71:07 - remember these here, the same syntax, these are 
going to be replaced by the host name, the user  
71:14 - identity file, whatever we need to pass in. So 
let's go ahead and start typing our provisioner.  
71:21 - Gonna go to the bottom of our instance resource 
here, we're going to type provisioner. Just like  
71:28 - so. And then local dash exec, we've been using 
underscores a lot throughout this script, as you  
71:36 - remember, but this provisioner uses a dash make 
sure you remember that this is a dash or a hyphen,  
71:44 - and not an underscore. This is a mistake I've made 
many, many times open and close that provisioner  
71:49 - block. Next up, we provide our command. Now 
this command is actually going to be run  
71:55 - from these files here. And to run these 
files and pass in the variables necessary,  
72:02 - we won't use the file function, we'll use what's 
called the template file function. So we take a  
72:09 - look at the template file function here, you can 
see that basically, you pass in VARs, after you  
72:16 - pass in the path. So for instance, you can take a 
look at here template file. And then this here is  
72:21 - the path which is using this interpolation syntax 
and path dot module, which is a built in variable  
72:27 - and then you use a comma. And then within an 
object here with these curly braces, you pass  
72:32 - in the variables that you need to pass in. So 
let's go ahead and do that. So for the path,  
72:39 - in my case, since I'm on a Windows machine, I'm 
just going to use quotes windows, dash SSH dash  
72:46 - config dot tpl, just like so if you're on Linux 
or Mac, you'll use the Linux version. And then  
72:52 - after that, we need to pass in our variables. 
So I'll add a comma here, then open and close  
72:58 - some curly braces, and we will pass in these 
variables, I'm actually going to indent this.  
73:05 - First up, we need our host name. Remember, we had 
to pass in a host name there. And that host name  
73:12 - is going to be self dot public underscore IP. 
Remember, we have a public IP attribute for our  
73:20 - instance that we used before, whenever we SSH into 
it. So we can just use self dot public IP here  
73:28 - to access that after that, we need to provide the 
user and that's going to be Ubuntu because that  
73:33 - is the EC two instance username that we have. 
After that we need to provide an identity file.  
73:42 - So that identity file is 
going to be our private key.  
73:46 - And the private key is located we'll just 
use a tilde here slash dot SSH slash and TC  
73:53 - key just like so. Alright, so that is all of the 
variables we need to pass in. And then after that,  
74:02 - we need to pass in an interpreter. Now the 
interpreter basically just tells our provisioner  
74:08 - what it needs to use to run this script. Now it 
defaults to bash so you don't necessarily need  
74:14 - to add this for that, but we will just to be sure, 
so I'm going to add interpreter, just like so.  
74:21 - Equals, and since I'm on Windows, we're going 
to use PowerShell and then we need to pass in  
74:28 - the next command which is dash command. Now if you 
are on Linux, and do not put both of these here,  
74:36 - I'm just using this as an example. 
For interpreter. You're going to use  
74:43 - bash, and we'll have a comma here. And then 
dash c is the interpreter you'll use for Linux.  
74:51 - But again, I'm on Windows so I'm going to 
delete that and keep this here. Alright,  
74:56 - so once you've done that, that is everything 
We need to do and this will hopefully  
75:02 - create our instance. And it will replace the 
hostname with self dot public IP the user with  
75:08 - Ubuntu and the identity file with this key 
here. So let's go ahead and give it a shot.  
75:15 - Now the first thing we need to do is we need 
to run a TerraForm plan. Pull this up some. Now  
75:23 - as you can see, we've got no changes here. That's 
because the provisioner does not affect our state,  
75:32 - it doesn't read that there's a provisioner there, 
and it's not going to change anything just because  
75:37 - we added one, we're going to redeploy our EC two 
instance. And finally see if everything works. So  
75:45 - hopefully, when we redeploy this instance, this 
provisioner is going to run add the information  
75:51 - required to our configuration file and allow us to 
SSH into the instance without any issues. So let's  
75:59 - go ahead and give it a shot. So first up, once 
again, I'm just going to run that TerraForm plan.  
76:08 - And as you can see no changes, which means that 
this provisioner is not going to run because  
76:15 - TerraForm hasn't detected anything different. 
Once again, it does not detect provisioners  
76:20 - as differences in the state. So it's not going 
to trigger a run. So let's go ahead and take a  
76:26 - look at a way that we can trigger that run. First 
up, I'm just going to run a TerraForm state list  
76:32 - again. And of course, we've got our AWS instance 
dot dev node, go ahead and highlight that and  
76:39 - copy it. And then what we want to do is use a new 
command we haven't used or at least a new flag,  
76:46 - we've used TerraForm apply a lot. But now what 
we're going to use is a dash replace. Now this  
76:53 - used to be known as TerraForm tanked, which 
would actually cause a resource to be replaced  
76:59 - on the next run. But now instead, we just use dash 
replace, I'll go ahead and paste in this instance,  
77:08 - dot dev node here. And let's hit enter. All right, 
as you can see, we are refreshing the state.  
77:15 - Okay, now we've got one to destroy, and 
one to add. So it is removing and replacing  
77:23 - our instance. And once that happens, it should run 
our local exec replacing the content in our config  
77:31 - file with what we need. And allowing us to SSH 
into our instance from VS code. So let's go ahead  
77:39 - and type yes, and pause this video. Come 
on back whenever it's done. Of course,  
77:45 - you might want to hop into the EC to console. And 
once the instance shows up, is running and has to  
77:52 - have to complete and green. Go ahead and come 
on back. And we'll see if everything worked.  
77:59 - All right, all of my checks are passed here. 
Let's go ahead and bring our editor back over.  
78:07 - And this is now the moment of truth. First 
things first, I'm just going to Cat my SSH config  
78:15 - file. And this is a really good sign. Look at 
that it looks like our provisioner did exactly  
78:21 - what we asked it to it added the IP address the 
host name, our user and the identity file to  
78:29 - our config file. So now that that's happened, 
let's head up to View command palette. And let's  
78:38 - just type in SSH right here. And as you can 
see remote SSH connect to host click on that.  
78:46 - And hey, check that out. So we've already got 
our IP address ready to go. Let's click on it  
78:53 - opens a new window. This is a Linux host. 
Again, we're on Windows terminal or I am but  
78:59 - it's a Linux host. So Choose Linux here. 
Yes, we are sure we'd like to continue.  
79:07 - Looks like everything is setting up 
downloading installing VS code server.  
79:13 - All right, let's open a terminal terminal new 
terminal. Bam check that out. And if we run Docker  
79:24 - Docker is nice and installed. Once again we can 
do a Docker dash dash version. So now we have a  
79:32 - perfectly good development environment ready to go 
you can open up folders on the remote. Once again  
79:40 - home Ubuntu is a remote folder. So if I run that 
I am now in a fully remote terminal. Go ahead,  
79:48 - I can hit trustees authors. Bam, perfect. 
So this is really, really cool. We're going  
79:55 - to start optimizing our script and making it more 
dynamic by adding variables. So let's get started.  
80:02 - Now, so far, we've hard coded pretty much 
everything. So now it's time to modify that  
80:09 - to give us some flexibility. So that we can adjust 
things easily without having to fish through every  
80:15 - single attribute here. And instead being able 
to go to one file and modify what we need there,  
80:21 - for instance, probably one of the things we're 
going to modify the most is the type of OS we're  
80:27 - using. So since for instance, I use Mac, Windows 
and Linux quite frequently, there's a good chance,  
80:34 - I'm going to want to be able to modify 
which type of instance I'm using on the fly.  
80:39 - So let's go ahead and take a look at that. Now 
first of all, what I want to do is I want to use  
80:45 - interpolation syntax to specify a variable here. 
Now, basically, that variable will be calculated  
80:52 - whenever we apply our script. So I'm going to use 
interpolation syntax, which I've mentioned before,  
80:59 - and basically that's going to be $1 sign 
in two curly braces, just like that.  
81:06 - So whatever happens here is going to be 
calculated dynamically whenever we run our script.  
81:12 - So let's go ahead and name this variable, 
we'll call it var dot host underscore OS.  
81:19 - So anywhere we need a variable, you 
specify it with var dot variable name,  
81:26 - just like so. So now if I choose windows, 
then it will be Windows dash, SSH dash config,  
81:33 - Linux, Linux, dash SSH dash config, just like so. 
So now what we need to do is we need to initialize  
81:41 - this variable and specify that, hey, we've got 
a variable that we're going to need to define.  
81:46 - And to do that, we can either do it here in 
line in the main.tf, or what I prefer to do,  
81:52 - and most everyone is to create a new file for 
it. So I'm going to create a variables.tf file.  
82:00 - Once again, it's analyzed just like any other 
TF file, it's all run at the same time. But this  
82:05 - will just make sure that it's easier to find our 
variables when we need them. Now, you can take a  
82:10 - look here at the input variables, documentation, 
declaring an input variable is actually fairly  
82:16 - straightforward, you use the variable, variable 
name, and then within braces, you give it a type.  
82:23 - And you can also give it a default. Now the type 
is not necessarily required, but it is strongly  
82:30 - recommended. So that your other DevOps coworkers 
don't lose their minds trying to figure out what  
82:36 - type of variable is expected. So let's head back 
over here, and let's go ahead and build this.  
82:42 - So it's going to be a variable, once again, post 
underscore OLS, then we'll use our curly braces.  
82:51 - And we'll just provide a type and that 
type equals string. We're not going  
82:56 - to bother with a default yet, but we'll 
get to it. So now that we've done that,  
83:01 - let's actually go ahead and perform a TerraForm 
destroy, auto approve. And as you can see here,  
83:10 - it's actually asking for this variable 
to be defined now. So keep that in mind.  
83:15 - Anytime you add a new variable, any destroy, 
apply, or plan operation is going to require  
83:23 - that you define those variables. And we'll look 
at other ways to define them so that we don't  
83:28 - have it popping up every time here from the 
command line. But for right now, we can just  
83:33 - define it dynamically. So let's just go ahead and 
I'm gonna say windows if you're on Mac, or Linux,  
83:39 - specify Linux, but again, nothing really matters 
now, because nothing is running. So go ahead and  
83:45 - destroy this infrastructure. Pause the video and 
come on back whenever it's destroyed. All right,  
83:51 - so everything is destroyed here. In just to 
illustrate, once again, if I run a TerraForm plan,  
84:00 - it is going to ask me for that variable. So if I 
type that in, then the plan will run. So keep that  
84:08 - in mind. Again, if you have variables that are not 
set, a plan, apply or destroy is going to ask for  
84:15 - those variables. So if you're in automation that 
can break your automation, we've now seen how to  
84:21 - initialize a variable and how to define it at the 
command line. But as we saw, that is not a great  
84:27 - way to define variables when an automation as it 
requires Dynamic Input, which is the opposite of  
84:34 - automated. So in this lesson, we're going to 
look at a few other ways to define variables,  
84:39 - and which of those ways take precedence over the 
others. So let's get started. So first of all,  
84:45 - let's take a look at the docs again, and if 
you scroll a good bit down, you can kind of see  
84:50 - like we've got default values, custom validation 
rules. We've got a lot here that's actually  
84:55 - really good information. But what we really want 
to see is if you scroll all All the way down,  
85:01 - you can see variable definition precedents. 
So basically environment variables  
85:06 - are processed last. So as we go down this list, 
these are processed in front of the other. So  
85:14 - environment variables are processed last. So if 
you have an environment variables set, but then  
85:19 - you define a variable in terraform.tf VARs, which 
we're going to look at, then terraform.tf. VARs,  
85:26 - is the variable we're going to use. And then 
you've got terraform.tf, fires dot JSON, which  
85:31 - not too many people use, but you can use 
it in automation, it does help sometimes,  
85:35 - you've then got auto.tf, vars, and auto that 
TFR is dot JSON, which are used in TerraForm.  
85:41 - Cloud quite frequently. And then you can specify 
a VAR and var file option on the command line.  
85:48 - But this isn't like a dynamic definition. 
It's not like it asks you for the definition  
85:54 - and you type it, you just add this dash var 
switch, and then you provide the definition.  
86:00 - And we will look at that. So let's 
go ahead and just take a look,  
86:03 - what we're going to do is run the TerraForm 
console. And this is a really good tool that will  
86:10 - help you work with certain functions and play with 
different values and things like that, that you  
86:16 - might need to experiment with before you deploy. 
So if you run TerraForm console, let's just take  
86:21 - a look. As you can see, it did not ask us for a 
variable. So if I run var dot host underscore OS  
86:30 - can see it's known after apply. So until we 
actually apply and specify that variable,  
86:36 - then our TerraForm console has no idea what that 
host OS variable is. So I'm going to go ahead  
86:42 - and type exit to get out of the console. And what 
I'm going to do first is just add a default here,  
86:48 - so go ahead and add default equals, and then 
specify your host, which again, mine is Windows,  
86:56 - yours might be Linux. So now let's go ahead and 
run a TerraForm console. It was run var dot host  
87:02 - underscore OS. There you go. So now it is 
processed it basically TerraForm console  
87:08 - has looked at all of our configuration files and 
saw that we have a default of Windows. So that's  
87:14 - awesome. All right, so I'm gonna get out of the 
console once again. Now what I'm going to do is  
87:19 - I'm going to create a new file, and we're going 
to call that TerraForm dot t f bars, just like so.  
87:30 - Now, this is the default name for our variable 
definition file. So here, all we need to do is  
87:35 - define the variable. So host OS equals windows. 
Or you know what, I'm just going to type Linux,  
87:44 - since we're not running this right now. So now 
let's run a TerraForm console, just like so.  
87:50 - And let's run var dot host OS. Now it's 
Linux, as you can see TerraForm, that TF VARs  
87:57 - takes precedence over a default variable set 
within the variables.tf. Alright, so that's great.  
88:04 - So now I'm going to get out of the console again. 
Now let's say we have I don't know a Unix System,  
88:10 - or we want a different script that only 
works with OSX. And we want to specify that  
88:15 - now if we still have these two files, how are we 
going to override this value? Now that we have  
88:21 - it defined in TerraForm dot TFRs? Well, there are 
a few ways to do that. And one way is to specify  
88:27 - the variable in line with our command. So if 
I run TerraForm, console, dash var equals,  
88:35 - and we'll just say host, os equals in Unix, 
just like so. Now, var dot host, underscore OS  
88:45 - is Unix. So if you need to override everything 
that you have specified in any file anywhere,  
88:52 - you specify it right here in line, 
and again, this could be a TerraForm.  
88:56 - Apply or TerraForm plan that you specify this 
VAR for in this will override any other files  
89:02 - that you've got. So now let's take a look at 
one more scenario. I'm going to exit once again.  
89:09 - Let's say that we have a dev dot TFRs. Now what 
matters is the TFR is not necessarily the word in  
89:19 - front. However, TerraForm is going to process 
anything in TerraForm, that TFRs by default,  
89:26 - so if you have a dev dot, TFR, and let's say 
that was host OS equals OSX, just like so,  
89:33 - we run a TerraForm console. And then we run Varta 
host OS. As you can see, it's still Linux, not  
89:42 - OSX. So if we want to pass in this file, we just 
need to run TerraForm console. Dash var dash file  
89:53 - equals dev.tf VARS. Just like so. And now let's 
take a look Farda host underscore OLS is now OSX.  
90:03 - Perfect. So now we've seen most of the ways 
that TerraForm will process variables and the  
90:08 - precedents it uses to decide which variable to 
use. So now that we've managed to choose our SSH  
90:14 - config file dynamically based on the definition 
of our host OS variable, we now need to make our  
90:21 - interpreter dynamic. Unfortunately, this isn't 
as simple as interpolation syntax replacements.  
90:29 - So we need to look at a better way, we're going 
to utilize conditional expressions to choose  
90:34 - the interpreter we need dynamically based on the 
definition of the host OS variable. So let's get  
90:41 - started. So what I mean by interpreter, of course, 
is this interpreter here, the one that determines  
90:47 - what interpreter is going to be used to interpret 
our SSH config script. And if it's Windows,  
90:54 - it's PowerShell. And if it's Linux, it's bash, 
and as you can see, we can't just replace it  
91:00 - like we did up here. That was very simple. And 
of course, there are ways we could define this.  
91:05 - But you know what, since we know that it's 
only one or the other based on the host OS,  
91:10 - I don't want to create a new variable just to 
do this, I'd much rather just continue using  
91:15 - the same host OS variable. So if you take a look 
at conditionals, here, conditional expressions,  
91:22 - you can see basically, you provide a condition 
question mark, and then you see the true value,  
91:28 - or the false value. So if host OS is Windows, 
the true value would be PowerShell. And the  
91:35 - false value could be bash, for instance. So let's 
go ahead and just hop in and take a look at what  
91:41 - this looks like. So I'm going to run the TerraForm 
console. And we're going to pass in a variable  
91:48 - definition. Of course, we haven't defined all over 
the place up here in our files, but we're just  
91:53 - going to define it right here in line, instead of 
messing with those files right now. So var equals  
92:00 - host underscore OS equals windows. For me 
anyway, and enter. Let's verify var dot host OS,  
92:11 - Windows perfect. So what we want to do is say 
if var dot host OS equals and we're using two  
92:18 - equal signs here, because we're not setting 
this we are checking for equality windows,  
92:25 - then first we'll just say PowerShell. And 
of course, this isn't the interpreter,  
92:28 - we'll use exactly, but just for the sake of 
using this now, this will be easier. Or bash,  
92:36 - just like so. As you can see, we got 
PowerShell. Now if var dot host OS  
92:44 - is Linux, and we run this same exact command 
again, PowerShell. Bash, then we get bash. So  
92:54 - that's pretty straightforward. So what we want 
is we actually want this command in the other  
92:59 - command, which of course, I've also provided, 
and we're going to use those instead of just  
93:04 - PowerShell and bash. So we'll say var dot host OS 
is Windows, then what we want is in brackets here  
93:14 - PowerShell comma, dash command, just like so 
and close that bracket. Or if it's not windows,  
93:23 - if this is false, then we just use bash, 
comma dash c, just like so. Let's hit Enter.  
93:33 - And perfect even though the formatting is a 
little wonky there, this will be perfectly fine.  
93:38 - So go ahead and just copy this directly Ctrl C, 
that and for interpreter, I'm just going to paste  
93:44 - that in just like so. And that's all we have to 
do. So let's go ahead and exit the console there.  
93:50 - And let's go up to our terraform.tf 
VARS. Make sure that is set to your OS.  
93:58 - I'm gonna go ahead and change this to Windows 
since that is the OS I'm using variables.tf.  
94:04 - The default is Windows, which is fine because 
terraform.tf Ours is going to override it anyway.  
94:10 - So if that's different, that is perfectly 
fine, but you may want to change this as well.  
94:15 - And then once again, with that our main TF, 
everything looks good. So let's go ahead and run  
94:20 - a TerraForm plan. All right, everything looks like 
it went through fine. So let's go ahead and apply  
94:29 - it TerraForm apply, auto approve, and hopefully 
by the time our instance is fully initialized,  
94:36 - we will be able to SSH into it just like we were 
able to before so go ahead and run this TerraForm  
94:42 - apply, pause the video and come on back whenever 
your EC two instance is all green. All right,  
94:49 - everything has come back just fine. We're 
running in all green. So let's go ahead and see  
94:55 - if this new IP address is available for SSH. I'll 
actually take a quick peek three 4.219 for this  
95:03 - one. So I will click on View command palette, 
I've already got remote, SSH ready to go.  
95:10 - And there it is 342219224 6.58. 
Let's go ahead and see if it works.  
95:19 - This is a Linux machine, I 
would like to continue Yes.  
95:26 - And everything is looking absolutely fantastic. We 
once again, have our development environment all  
95:34 - ready to go. But this time, it's dynamic. Based on 
the host OS that we're using, we're going to add a  
95:41 - nice little convenience feature to our script. By 
utilizing outputs to display information we need,  
95:48 - as you well know, we've been manually finding the 
public IP address of our instances to verify them.  
95:54 - Well, that is incredibly inefficient. 
So let's go ahead and add an output to  
95:58 - make this a little easier. So as you can see, 
we've got output values here. And basically,  
96:04 - it's incredibly simple to do. So this, of course, 
is how to access a private IP, well, we're just  
96:10 - going to access the public IP. As you can see, 
we've got a lot of other features as well,  
96:15 - such as the ability to mark an output sensitive 
so that it doesn't show up on the command line,  
96:20 - you've also got a depends on feature as well, 
we're not going to dive into that. But we are  
96:26 - just going to go ahead and access that public IP 
of our instance. So if you run TerraForm console,  
96:34 - you can then access all those attributes 
of our instance and kind of play with them  
96:39 - to see what output we're going to get. As 
you remember, it is AWS instance dev node.  
96:44 - So if we just type AWS underscore instance, dot 
dev underscore node, dot public underscore IP,  
96:54 - there it is. So that's very, very simple. And as 
you know, you can use TerraForm, show or TerraForm  
97:01 - state show to get all of these attributes 
that you could use for outputs. So if I get  
97:06 - out of this console, and run a TerraForm, state 
show, and of course, we'll just use once again,  
97:13 - AWS instance, dot dev node, just like so we can 
see all of the possibilities that we can use to  
97:21 - output. As you can see, we get output instance 
types, and here is public IP. So that's what we  
97:28 - did, we just accessed that. So let's go ahead 
and create this output, what we're going to do  
97:35 - is just create a new file output.tf. Once again, 
you could add it to our main.tf. But we just want  
97:43 - to clean things up a little. So output. Here, 
we'll just call this dev IP, open and close  
97:50 - those braces, value equals AWS instance, dot dev 
underscore node dot public IP, just like so that's  
98:01 - all we have to do. Now to access this output, we 
may not want to destroy our entire deployment,  
98:08 - just because we added an output, what we can do 
is just run a TerraForm, apply dash refresh only.  
98:18 - And that's basically just going to consider this 
output and add it to the state so that we can get  
98:24 - to it, just like so as you can see, we've got 
changes to outputs. So that's perfect. So let's  
98:30 - go ahead and run this. Apply complete. That's it. 
And then we can run TerraForm output. Just like so  
98:40 - to see our output once again. And this is very, 
very useful in automation. Now, if we take a look  
98:46 - in our TF state, scroll all the way to the top, 
we can see our outputs are right here. So it's  
98:54 - very easy to see what we need to see. So outputs 
are incredibly useful. And there's a whole lot you  
99:01 - can do. You can get very creative with what types 
of output you get. But for our purposes, all we  
99:07 - need to know is that IP address which matches 
the one that we use to SSH into that instance.

Cleaned transcript:

Learn how to use TerraForm with AWS. In this course from Derrick Morgan, you will realize within a few minutes of watching how amazing Derek is as an instructor. Hello, and welcome to the build a development environment with AWS and TerraForm resume foundations project. So a resume foundations project is a short project that is tailored to cover the important aspects of a technology in order to help you build the foundations necessary to build your own projects and apply them to your resumes. So let's take a look at what you're going to find in the course. In this two hour project centered around TerraForm. You're going to use VS code and deploy an AWS EC two instance, along with the VPC, Internet Gateway security groups, et cetera, that will serve as a remote development environment that you can log into directly from VS code will utilize several TerraForm tools and functions such as TerraForm, state format, replace console variables, conditionals, file, template file, and more. We'll also use AWS user data and a local exec provisioner to bootstrap the EC two instance and add its connection information to your VS code SSH configuration file, allowing you to modify it for your own projects. Since we'll make heavy use of documentation and highlight the process behind developing a brand new TerraForm deployment, you'll have the skills you need to dive deeper into TerraForm and add this extremely in demand skill to your resume. So what are you waiting for, sign up today. And don't forget to terraform apply yourself. So let's start out right here in the AWS console. And let's go to I am. Now as you can see I've recently visited but just in case you haven't, you can just search right up here in the search bar. Let's click on that. And now let's click on Users. Now within users, you may see a lot more information here I've actually hidden most of mine, let's go ahead and create a new user. So we'll click on Add Users. And for the user name, feel free to use whatever you'd like. I'm just going to call it VS code. And now I'm going to choose access key programmatic access, we're not bothering with a password, this is not going to be a user that logs into the console. So go ahead and click that in next permissions. Now as you can see, I've got a group of admins, you can of course, create a new group, or you can just attach the policies directly. And I'm going to do that just click on Attach existing policies directly click on administrator access, and then click next tax. Now feel free to tag it if you'd like to, I'm not going to bother. The next review, we've got right here our user name programmatic access, and administrator access. Go ahead and click on Create user. And right here, you'll see that you've got your access key ID and your secret access key. Go ahead and download that CSV. As you can see, I've already installed Visual Studio code it was a pretty straightforward process, I am on a Windows machine. But this of course will also work on a Mac or Linux. So go ahead and first things first, let's get the AWS extension installed. So click on the extensions icon here on the left, and then search for AWS. And once you've done that, we've got this AWS toolkit here, go ahead and click Install. Looks like everything installed fine. So I'm going to go ahead and close this pane and close this tab. And then I'm going to click on this little AWS icon. As you can see, we've got connect to AWS right here. But before we can do that, we need to get some credentials installed. So head up to View and command palette. Then as you can see, I've searched for this before, but if you need to get to it, you can type AWS and then start typing create credentials profile, just like so. And then open that. And as you can see here, I've got a credentials profile called VS code. If yours looks different, make sure that you get this looking the same if you want to follow along in the course exactly. But of course if you don't or you're comfortable making simple modifications, you can name this whatever you'd like. But what we need to do is populate this AWS access key ID In secret access key. So go ahead and open your credentials file and paste this information in. Just like so. Alright, and once you've done that, go ahead and Ctrl S to Save this file, you should not have this white dot that was up here before, then close this tab, and then click on Connect to AWS. And you should see your profile right here. If not, you can obviously type profile VS code if you need to, and just click on that, and default region of US East one, I actually don't want that region, I'm going to use a different one. But whichever region you choose, you can choose that here, I'm just going to say no. And I'm going to add US west to that's the region I typically use in my courses, because there's so much default stuff that goes on in US East one, I just prefer to stick with us West too, but it is totally up to you. So once you've done that, you can go ahead and minimize that. And then open the extensions panel again, let's go ahead and add something that will give us a little TerraForm syntax highlighting, let's go ahead and type in TerraForm. And as you can see, there is an official TerraForm extension here, it's rated 2.5. It is pretty buggy, it might be better now that you're watching this video, feel free to choose this one if you'd like. But I'm actually going to use this one here, it's just got a higher rating. And it's been pretty consistent for me. So I'm going to install this one, just like so. Alright, and I'm going to close that tab and close my extensions. So now that we've got our extensions installed, let's go ahead and create our working directory. So I'm going to go ahead and click on Open folder. And I'm just going to set mine up in the Documents directory, feel free to set this up wherever you'd like of course, just like so. And then I'm going to create a new directory. And I'm just going to call it TerraForm. Just like so. All right, and I'm going to open that and hit select folder, just like so. Alright, so now we have a working directory, we've got our extensions installed, everything is ready to start the course. Now it's a fairly straightforward build, we're going to cut it down to the bare necessities because you don't need much for your development environment, the more resources we add, the more can go wrong. So let's just make sure that we keep it as small as possible. And then of course, as you develop new requirements, you can build out your environment to meet your needs from there. So what we're going to do is we're going to use VS code on our terminal. And then we're going to use the TerraForm configuration files, providers variables, main terraform.tf VARs, which of course, we will be explaining all of these throughout the course. And then we've got a configuration file here that's going to configure VS code based on the IP and other information of our developer node. And we've got our user data that's going to bootstrap that node. Now in AWS, we will build out a VPC, we're going to build out an Internet Gateway, public route table, a security group, a public subnet, and an EC two instance. So all of this together will form our developer environment. And once we're done, after all of these files have been processed, and everything is good to go, your VS code terminal will have access directly to this EC two node to deploy a remote SSH session, which will allow you to have file and SSH access to your EC two node to run whatever you need. So that's a very high level overview. Let's go ahead and get building. So here I am in the AWS provider documentation within TerraForm. And a provider is basically used by TerraForm to interface with the API of whatever infrastructure you're trying to build. So in this case, you're trying to build AWS infrastructure. So you use the AWS provider, if you're using GCP, or Azure, or VMware or whatever else you will use their respective providers. So as you can see, it's pretty straightforward. Since we've already provided credentials, we don't need to provide those within the provider block here. If you scroll down, you can see there's actually lots of ways to add these credentials. But again, we already have a profile. So all we need to do is access the shared credentials file, just like this. So let's go ahead and we'll keep it fairly simple. I'm just going to copy this here. And then within our TerraForm directory here, which we created Earlier are going to create a new file. And let's call this providers.tf. Just like so. And we'll paste that in. Now I'm actually going to remove this version block here, because you may be in the distant future, and not on version three anymore. So again, I'm going to just remove that and let you download whatever version is current. Now after that, we need to add our provider block, that is the required providers block. And that provides configuration that TerraForm needs to know about. But the provider block itself provides the information needed to access AWS specifically. So if you scroll down here, you can actually see that we have some usage examples. And we have one right here with shared credentials file already here for us. So let's go ahead and just copy this one. And I'm going to paste that right here. Now again, typically, I type all of this out. But since this is a very quick course, I want to make sure it is as streamlined as possible for you. So here, I'm just going to remove this. And I'm just going to add that little squiggly right there to indicate the home directory, dot AWS slash credentials. Because that's where our credentials file is stored. Now, if you've moved it, of course, you'll want to change this. But this is actually the default for Windows and Mac. So you should be good to go. Now for the profile, remember, that was named VS code. And the region is US West two. So this is what you should have here for the provider. Again, if the documentation did not provide this exactly, of course, just copy it from here. All right. So now that that's done, let's go ahead and run a TerraForm init to initialize this and connect to AWS to ensure everything works out. So I'm going to click on terminal and new terminal just like so. Let's go ahead and I'm going to pull this up a little bit, clear this screen. And let's go ahead and run TerraForm init. All right, TerraForm has been successfully initialized. As you can see, we've got hashey Corp, AWS version 3.7 1.0. At least that's my version, your version is different, that is perfectly fine. Also, you can see that TerraForm has created a lock file TerraForm lock dot HCl. And what that's going to do is ensure that the version is frozen. Again, you can change this if you'd like. And this should be the current version you're using. But this is something you might want to keep in your GitHub or git lab or wherever you're storing your code repository so that you can ensure that every time you run this code, it always uses the same version of the provider, and you have a much lower risk of having some sort of issue with an upgrade. So it looks like everything is all nice. And initialized. As you can see here, I can do this drop down. And you can actually see the provider which for Windows is an exe. And for Linux and Mac, you'll actually see another binary there. But this is compiled and you're not going to go digging through it. As you can see here the VPC is actually pretty straightforward. You basically specify the resource, this being the actual resource, as you can see, AWS VPC, this is a static value that cannot be changed. If you change this, you're not going to deploy a VPC. Now after that, we've got the name for this VPC, which in this case is main, we can name it, whatever it is, we want. This is a logical name that only TerraForm knows about. So this isn't going to show up in AWS anywhere. So again, make sure you understand that, but this is how we will reference this VPC in future lessons. And then we just provide a cider block. Now there are also lots of other options that you can specify here. As you can see, it gets pretty complicated. If you go down to the argument reference, you can see that we have a lot of stuff here we can use, such as enabled DNS support, which defaults to true in enabled DNS host names, which defaults to false. So let's go ahead and let's utilize this to create a VPC, we're going to bring my VS code back over here. And I'm going to create a new file and we're going to call that main.tf. So I'll create a new file main.tf Just like so make sure that it is in the proper directory here and you didn't accidentally add it within the TerraForm directory here. And we've got that up. Now, the way these TF files are processed is they're processed as if they're all the same file. So if you have 20, TF files in here, all with different resources, they're all going to be processed Test as if they're the same file. So keep that in mind. You can split up your code, however makes sense to you, you can have a compute.tf networking.tf, whatever you'd like. It's all processed the same as long as it's in the same directory. So let's go ahead and create this VPC resource. So I'm going to type resource, AWS VPC, just like so. So this, of course, is specifying that I want a resource, or here I wanted a provider. Here, I want a resource. Now once again, let's name this VPC. I'm going to name it MTC for more than certified VPC just like so. And then I'm going to use some curly braces here. This will wrap our entire resource that I want to specify that cider block. And in my case, I'm going to do 10.123 dot 0.0 slash 16. If you've taken my other courses, you've probably seen this cider block before. Now under that, let's say I want to enable DNS host names. As you remember, DNS host names defaults to false. So if I want to enable this, I need to make sure that I add it. So I'll go ahead and enable DNS host names equals true just like so. And if I wanted to, I can also say enable DNS support equals true. Now we don't have to because this is assumed, however, depending on your development team, you might want to ensure that this is explicitly mentioned, your team may not understand what's default for your VPC. And it might be very helpful to be very explicit and specify some things that default is true as true just to ensure that when it's easy to modify, and to your team knows that this is enabled, again, not required, but it's something you might want to do. Now under that, we're going to specify some tags. And I just want a name for it. And I'm just going to name it Dev, just like so. So I know that this is my dev VPC whenever I go searching alright, and as you can see, I've got my two curly braces here. One is to enclose these tags, and one is to enclose this resource. So that's all I need there. Let's go ahead and run a TerraForm plan, just like so. And what this is going to do is let us know what we're trying to build. Just like so as you can see we've got all of these new pieces that are going to be created. Within our VPC resource, we're going to have our cider block and Arn will be created which we won't know until we actually apply it in the same with a lot of this other information such as the ID we will not know until we apply it. Now as you can see we've got these green plus marks that means that these are all being added. So that all looks good. We've got one actual resource AWS, VPC dot, MTC VPC to add. So what we want to do next is apply we'll run a TerraForm apply, just like so. And as you can see, it basically runs another plan, and then asks us to confirm and to confirm, I'm going to type yes, scroll this up a little bit, and our VPC is being created. All right, perfect. Our apply is now complete. So if we go over here to our AWS pane, I'm going to click no here I do not need us East one right now because I am in US West. I'm then going to click on Resources. And as you can see, I've actually got some resources already shown here that's from a previous installation. If you click on this little sprocket type AWS colon colon EC two colon colon VPC, you can also search for VPC, you can see that that's been added, go ahead and checkmark that and click OK. To ensure that resources added, then if you click on it, you'll see our brand new VPC is here. So there's our cider block, our default network ACL default security group, it looks like everything is here enable DNS host names is true enabled DNS support is true, we're going to take a slight detour from building to dive into the TerraForm state a bit. So we better understand how information about our deployment is stored for TerraForm. To use. This is probably one of the most important concepts with TerraForm. So make sure you read over the documentation a good bit if you really want to understand how things work. But essentially, we're just going to take a look here and see exactly what is stored in our state as we deploy resources. As you can see, there's a lot here in the docs. And we're going to explore several pieces of this as we build our infrastructure. So here we are right here after we have now deployed our fresh new VPC. As you remember, in our AWS resources pane here, you can see all of this wonderful information about our VPC. Now, another way we can see what we've deployed, is to head into our Explorer. And right here, our terraform.tf state file. As you can see, we have a lot of the same information default network ACL default route, table ID, security group ID, the VPC ID there. As you can see, all of that is here, VPC ID, default network, ACLs, security group, etc. Now, it's formatted a little bit differently. But it's, for the most part, the same information. And this was all pulled right from the AWS API. So now typically, you're not going to want to traverse this tf state manually as it will normally be stored somewhere off site, whether it's in TerraForm, cloud or in AWS, or somewhere else. So we have several different tools, we can use command line tools to access the state. So let's take a look at TerraForm state list just like so. As you can see, we only have one piece and our state one resource that MTC VPC that we deployed. So if I want to see that information within that VPC, I can run a TerraForm state show, AWS VPC dot MTC VPC, as you can see shown right here, I hit ENTER on that. We have all of the same information. So we've got information here from our API, we've got information here within our state, the state file specifically. But this is all the same information. It's just formatted a little bit differently. Now you can output as JSON and really manipulate that output. But we're not going to dive into that right now. All right. And of course, if you want to see the entire state, all you have to do is just type TerraForm show. So keep that in mind. TerraForm state show requires you to insert a resource. Now TerraForm show is just going to show you everything that you've got, which of course can be massive if you have a very large environment. So those are the basics of our state, and the information that's being stored within it. There are a lot of commands that you can use to manipulate that state to refresh it to migrate it. But we're not going to dive into that right now. But just know, it'll be very beneficial to you. If you dive into the documentation a little bit, and just read all about state as it is the most important feature within TerraForm. We're going to check out a command almost as fun to use this TerraForm apply, but much more fun to say. And that command is TerraForm destroy. So TerraForm destroy is pretty straightforward. Basically, it's going to destroy anything that we have created. And as you can see here, you can actually run a TerraForm apply dash destroy. But we typically just use TerraForm destroy, there's not a lot else going on here that you need to really worry about, you can run a TerraForm plan in destroy mode, which will tell you what happens when you destroy. So that can be fairly useful if you need to test something out. But for the most part, we're just going to run this TerraForm destroy. So let's do that. Let's knock out this VPC that we created completely delete everything we have applied. So just run TerraForm destroy. And then we can just use a dash auto approve if we don't want that confirmation dialog, again, useful in automation. Probably wouldn't use this in production. If you're typing it yourself though. Let's go ahead and run that. Alright, right, the destruction is complete, everything is gone. So that's really all you need to know there. So go ahead and reapply it as we're going to need this VPC for pretty much the remainder of the course. So TerraForm apply, auto approve, just like so. All right, all set. We're back to where we left off. You saw how easy that was. This is one of the great things about TerraForm infrastructure just comes and goes as you need it. We're going to deploy a subnet to which we can deploy our future EC two instance. As you can see here in the docs, it's pretty straightforward. Although there are a few more options, we're going to want to add one of them and if you scroll down here is To map public IP on launch, default is false. We want to make sure that our instance receives a public IP address whenever we launch into the subnet, so we want to ensure we add that so let's go ahead and get started. All right, so right here under my VPC, we're going to add another resource. And that resource is AWS underscore subnet. Just like so. And then let's go ahead and name it. I'll just use MTC underscore public underscore subnet, just like so. And you don't always have to add a prefix like this. Although I've been doing it for so long. If I did not add this prefix, this course would be way too long due to all the errors I've made. So for consistency sake, I'm just going to keep this MTC prefix on all of my resources. All right, so let's go ahead and open and close those resource braces. And what we need to do is provide a VPC ID now as you remember, when we ran our TerraForm state list, we've got a list of our resources. And this is how we want to access this VPC resource. So what we're going to do is AWS VPC dot, MTC underscore VPC, which again, matches this as well. And since this is another resource, it's like a variable, it's not a string, so you're not going to quote this. This is a reference to a resource, so you don't need to add quotes. And then what we need to do is just specify an ID. So if I do the TerraForm, state show, AWS, VPC dot, MTC, VPC, just like so we can see that it has an ID attribute. And that's the ID that we need for our subnets. So we just specify that.id Right there. And that's how you're going to reference most of the resources that you have to reference from other resources. So next, we need to provide our cider block. And that's going to equal 10.123. And I'm just going to say, dot 1.0, slash 24, which, of course, is one of the subnets within this slash 16. And then after that, we're going to add our map, public IP on launch, that's a long one there, equals true and since this is a Boolean, it's also not quoted. And then we need to provide an availability zone, just like so. And that'll be US West. And we're just going to use to a or at least I am, because I know a is probably good to go. There are ways to use what are called data sources to ensure that this is always correct, especially if you're using multiple availability zones. But we're not going to dive into that now. But feel free, of course, to research that if you are curious. So next up, we're going to add tags. And that name equals Dev. Public, we'll just go with that. So the VPC, we just named Dev. And we'll just name this here as dev public so that we know that it's a public subnet. Again, map public IP on launch equals true is a good reason for us to want to make sure we label it correctly. So we don't accidentally put sensitive resources in this subnet, which of course, could cause a security nightmare. Alright, so that's all we have to do for this subnet. Let's go ahead and run our TerraForm plan. All right, we've got one resource to add. So that's good and AWS subnet is going to get added. As you can see, everything we have specified is listed here. And of course, certain things like the ID are known after apply. So let's go ahead and run a TerraForm apply. And then I'm just going to add auto approve, you're not always going to do this. But if you're running a plan first, it's usually pretty safe to go ahead and just auto approve it, and not have to type that yes, every single time. This especially is useful in automation. So I'll go ahead and run this. All right, one added, everything looks successful. So I'll go ahead and click on this sprocket next to resources, which again is in the AWS pane. And I'll go ahead and type subnet. As you can see, we actually do not have subnets available. This is a limitation of this AWS plugin, so we're not going to worry about it. But it looks like that subnet creation was successful. And of course, you can always go into the AWS console to verify we are going to give our resources a way to the internet by creating an Internet Gateway. We will then introduce TerraForm format to clean up our code a little bit. So let's get started. As you can see here, the Internet Gateway is pretty straightforward. It's actually a really simple resource to deploy. We've got a few attributes here. These are the things that will be exported. within our state, and these are the arguments VPC ID tags and default tags. So let's just go ahead and knock this out. Alright, so here we are. Let's go ahead and scroll down a little bit under our subnet, and we will add a new resource. AWS Internet Gateway just like so. And we'll call that the MTC Internet Gateway. All right, and then I will open and close my braces. Let's add that VPC ID. And remember how we access this VPC AWS, VPC dot, MTC vpc.id. Just like so in fact, I can even copy this to save a little bit of time, and just paste it in. And then just for the heck of it, I'm gonna go ahead and add some tags. And we'll give it a name of DEV Igw, just like so. So we've got our dev VPC, our dev public, and our dev Igw. So once we've done that, that's literally all we've got to do. But let's go ahead and introduce that fun new command. If you go ahead and run a TerraForm, FMT, just like so what that just did was that corrected any type of inconsistencies we've got in formatting, as you can see, main.tf and providers.tf, or both corrected. Now, unfortunately, I was not scrolled up. But as you can see, now all of our equal signs are lined up perfectly. So it made some very minor formatting changes, but it looks a whole lot better. So that's great. And if you want to see it in action, just go ahead and move that a little bit. Run the command again. And as you can see, it automatically corrects. Alright, so let's go ahead and deploy this brand new Internet Gateway. Go ahead and run TerraForm plan, just like so. All right one to add. As you can see, we've got our Internet Gateway that's going to get added. So let's go ahead and run a TerraForm apply. Auto approve, just like so. Okay, apply complete, everything looks good. Let's click on our AWS pane. And let's see if we can access this resource. Just go ahead and type internet. Haha, AWS Internet Gateway, we've got it. So let's go ahead and check that and select OK. And if I expand my resources here, and take a look under EC two Internet Gateway, we'll see we've got two. So if I click on the one with the longer ID we can see right here that we've got our Internet Gateway. With the proper tag, we're going to create a route table to route traffic from our subnet to our Internet Gateway. All right, here I am in the docks. And as you can see, there's a note here. And basically, you can use a standalone route resource. Or you can define routes in line. Now in this case, they have the routes defined in line just like so we're going to do it a little bit differently, we're actually going to use a route resource, which as you can see here is also fairly straightforward. And we'll walk through this here shortly. So let's head back over to our route table. As you can see, all we basically need is the VPC ID, and then we'll provide some tax. So let's go ahead and do that. So I'll open my main.tf. Once again, scroll down some, let's go ahead and create that resource AWS route table, just like so. MTC public R T, just keep it from getting too long, and open and close our resource braces. And within here we need to provide that VPC ID again. And as always, I'll just copy this and paste it right there. And then we'll add some tags. Name equals Dev, public AR T, just like so. So now that we've done that, once again, remember, we then need to add the AWS route, which is right here. And basically we need to specify a route table ID, destination cider block. And in our case in Internet Gateway, so let's go ahead and do that. So we'll create that resource AWS route just like so. default route is what we'll call it. This is a default route, of course for all traffic to get to the internet. Open and close those resource braces, route table ID equals and we're going to need to Use the AWS route table in TC public RT AWS route, table dot MTC public RT. And once again, all we need to specify is the ID, it's asking for an ID. And pretty much universally, all AWS resources are going to have this ID attribute. So then we need a destination cider block, just like so. And that's going to be 0.0 dot 0.0 slash zero, which means all IP addresses will head for this internet gateway. And then again, that Gateway ID is now going to be AWS Internet Gateway just like so. Dot MTC and as you can see, VS code is providing me some nice little hints. So I'm just going to hit Tab, Internet gateway.id. Just like so if we scroll up, we can see TC Internet Gateway right here. All right, perfect. That's all we need to add. So let's go ahead and I'm going to scroll this up. Let's go ahead and run that TerraForm plan. And we should have two resources to add this time. Perfect to to add, we've got our route table. And we've got our route. So that's great. Let's go ahead and run our TerraForm apply, auto approve. And everything was applied successfully. Let's go ahead and click on the little sprocket next to resources and see what we have to offer. So what we've deployed is a route table. AWS EC to route table great. And then I actually do not see a route that we want to use. So we're just going to take a look at the route table. All right, here it is. It's going to be one of these dev public route table. Perfect. We're going to bridge the gap between our route table and our subnet by providing a route table association. So let's go ahead and get started. As you can see here in the docs, the AWS route table association is actually pretty straightforward. Basically, we just need to access our subnet and our route table ID. And just specify both of those in an association. So let's go ahead and knock that out. All right, so I'm gonna go ahead and scroll down under this route here, resource and AWS route, table Association, probably one of the longer resource names, MTC public, and I'll just call it an a sock there and open and close my resource braces, we need to provide our subnet id. In that we just scroll up and take a look. AWS subnet, MTC public subnet and then once again, we just need to provide the ID of that. So AWS subnet auto complete that dot MTC scroll down here public subnet remove some typing and potential for errors.id. Just like so. So that's all we've got to do there. Then we need to provide a route table ID in that once again, we can just copy right from here. And paste in. All right. So that is literally it. Let's go ahead and save. And then I'm also going to run another TerraForm FMT just to clean things up, look at that much more beautiful. All right. And then let's go ahead and run our TerraForm plan. Perfect One to add our route table Association. And we'll run a TerraForm apply, auto approve. All right, that is all set and all done. And if we want to see that association and some of the other things we've created, we can't access those from the resources. So of course, we can always go to the console here. We can access the VPC area and the route tables. We've got our dev public RT right here. Take a look at our subnet associations. And there it is. Our dev public subnet is associated with this route table, we're going to add a very important resource to our deployment, the security group. So here we are on the documentation, as you can see here is an illustration of the usage of a security group. Now in this case, they've actually defined the ingress and egress in law Live, which is perfectly fine. Now you can specify them separately, as you can see by this note, as a security group rule resource just like we did with a route resource. But this is perfectly fine. Now in your organization, you may find a benefit to adding separate resources. But in our case, this will work perfectly. So as you can see here, the egress actually allows egress to everything on any protocol, that's zero to zero. And then the protocol is negative one, which means UDP, TCP, ICMP, etc. Any protocol, you need to use negative one, we'll cover it now the ingress only allows port 443. But we actually want to allow everything, we're just going to ensure that we hard code this IP to our own IP, so that we don't allow someone to compromise that our instance. So let's go ahead and get started. Now, sometimes, I might actually choose to just copy this and paste it into my IDE, and then modify from there to simplify things. But since this documentation may have changed by the time you watch this, we're going to type it out manually. So let's go ahead and start that. We're going to add our resource like always, AWS security group, just like so. And let's just name that MTC SG for right now, we'll open and close those resource braces, we'll create a name. That's dev S G. Sounds good to me. Now, keep in mind, we don't need a tag here, because the security groups actually have a name attribute. So there's no point in having to tag it, you of course, could tag it for other organizational reasons. But as far as the name goes, this is perfectly fine. After that, we need to provide a description dev security group sounds great to me, we then need to provide a VPC ID, which we've used many, many times, I'm actually going to just scroll up, copy this and paste it down here just like so. And then we need to provide our ingress and egress. So let's go ahead and add our ingress here. From Port, make sure you have that underscore there from Port equals zero to port equals zero protocol equals, in quotes here negative one, this is presented like a string TerraForm is not going to honor this negative right here, this dash. So make sure you specify this as a string. And then cider blocks equals now I'm just going to put in 0.0 dot 0.0 slash zero. Because I don't want to show everyone my IP address. Make sure you only add your own IP address here. So you can go to what's my IP or somewhere else to find your IP address. And then that will be something something something something slash 32. That slash 32 indicates you want to use only this address. But again, I'm just going to put anything for right now. And I'll be sure to destroy my infrastructure that has this open port and replace it with my own later. Now as you notice, this is cider blocks with an S which indicates that it expects a list. Now these brackets allow you to enter lists. So if you had multiple IPs, you could put a comma here and specify another one after that. But we only need one. All right, so our ingress is taken care of. Now let's set up our egress. gonna slide this down a little bit, there we go. egress from Port equals zero to four equals zero. Protocol, once again equals negative one, insider blocks. In this case, I'm going to allow whatever goes into this subnet to access anything so you won't put your IP address here. You will make sure you allow it to access the open Internet. All right, perfect. So that's all we need to do there. Let's run a TerraForm FMT to clean that up. There we go. Beautiful. Then let's go ahead and run a TerraForm plan and make sure everything works out. Slide that up. Okay, one to add like we expected. Looks like everything looks good here from Port zero protocol, negative one to port zero. Perfect. Let's go ahead and run that. TerraForm apply, auto approve. All right, all complete. Let's scroll over to our AWS console. I will click on Security Groups Go ahead and refresh that page here is our dev s g. by open that, click on Edit inbound rules, we can see all traffic is allowed on all protocols, all ports, custom source, and again in my case is 0.0 dot 0.0 slash zero. All right, perfect. We're almost to the deployment of our EC two instance. But first, we need to provide the AMI from which we want to deploy. To do this, we can utilize what's called a data source. A data source is basically just a query of the AWS API to receive information needed to deploy a resource. In this case, we need an AMI ID based on some filters we're going to provide. So let's get started. So if I head over here to my data source documents here for the AWS AMI, you can see an example, data AWS Ami. And of course data basically is like the resource keyword we've been using, we're just using data. Now AWS AMI is the name of this data source. And of course, this needs to stay the same no matter what. And then this here can be whatever you want to name it. Now we'll be using most recent, and we'll be using some filters as well. Now one thing we have to make sure is that we have the correct owner. Now one way to do that is to use AWS Marketplace. But in our case, we're going to be a little more specific, let's take a look at how to get the owner ID we need. So if I head into the management console here, going to type EC two up at the top. Going to open that, if I go to instances and Launch Instance, let's take a look. I'm just going to type Ubuntu here. And I'm going to deploy Ubuntu server 1804. That's what I've used in my other courses. And I'm just going to stick to that for now. 2004 should work perfectly fine. And whatever it is you want, you can choose. But in our case, we're just going to use this 1804. So what I'm going to do is copy this AMI ID because an owner ID is not provided here, which is a little annoying. And then I'm going to head back to my EC to console. And I'm going to click on AMI under images. And right there, make sure you have public images chosen and enter that AMI ID. And here is our owner. So go ahead and copy that you're going to need it here shortly. Alright, so once we have that, let's head back over and start coding this thing out. Let me drop this a little give us some room. So now what I'm going to do is actually create a new file for this. And we're going to call it data sources.tf. So I'll just create a new file, and data sources.tf, just like so. And this will just keep things a little cleaner. So we'll use data, AWS AMI, and we'll just call it our server AMI or whatever you want to call it, we want to specify most recent equals true. And then we provide the owners. Now the owners, as you can see is plural. So we're actually going to use brackets, which makes it a list. Go ahead and paste that owner ID that we got into here. And of course, if there are other owners, you could but in this case, we just need that owner ID. All right, now that we have provided our owners here, let's go ahead and provide a filter to get the correct Ami. So if I type filter, just like so, name equals, and we're going to filter on name, I know this looks a little confusing, but the filter name is actually name and then values equals and once again, this is plural, so make sure it's in brackets. Ubuntu slash images, slash HV M dash S S D slash Ubuntu bionic dash 18 dot o four dash AMD 64. Make sure you have the right architecture there. Dash server Dash. And then what we're going to do since there's usually a date here, and we're just going to pull the most recent no matter what, we're just going to add an asterisk. So instead of the date that we would use here, we use an asterisk so that any date will qualify. So if I just head right back over here and take a look, you can see. Basically all we're doing is just putting an asterisk instead of this date, but everything else is exactly the same. All right, so perfect. So that's actually all we need to do. Go ahead and save this file. And then let's go ahead and run a TerraForm apply TerraForm apply auto approved just like so. All right, great. So now that is applied. So if I open my terraform.tf state right here, again, you would usually use a TerraForm show. But this is a little bit easier for this. We can scroll down under resources. And you can actually see we have instances, even though we don't have any EC two instances actually deployed, there's still an instances section that contains this AMI data source. And if you look down, you can actually see, we've got an image ID right here, which actually does not match here. And there's a reason for that. And that is, if you look at the date, 2021 1129, the date of this one is actually 2022 0104. So this is actually a newer instance than what is in the console, which is why that AMI doesn't match. And for our purposes, that's perfectly fine, we're going to create a key pair, and then create a TerraForm resource that utilizes this key pair. This will be used by the EC two instance resource we create so that we can SSH into it later. So let's get started. All right, I'm gonna first highlight my main.tf here, and then I'm gonna go ahead and create that key pair. So to do that, and yes, I am on Windows, Windows actually does have an SSH utility. So I'm going to run the same commands that I would run on OSX or Linux, SSH dash key Gen dash t. And we will use a more secure key than the typical RSA we use, let's use Ed 25519, and hit Enter. Now we're going to rename this key pair here, I'm just going to copy this instead of retyping. It basically everything before the ID EDI 25519. And I'm going to paste that in. And then we're just going to name this MTC key, or at least I am, name it, whatever you want here, just make sure you reference it properly throughout the rest of the course. And I'll hit enter, we're not going to bother with a passphrase. All right, perfect. It looks like everything is good to go. Just going to run an LS tilde slash dot SSH here. And that shows me that directory. And MTC key is there an empty C key dot pub, which is what we'll use for our key resource. So now let's take a look at the Docs as we usually do. Resource AWS key pair, as you see, we basically need to specify a resource, AWS key pair and the name that wherever we need to, we'll give it a name. And then we will provide the public key. Now we could just copy and paste the public key from our file. But that looks very, very messy. So what we're going to do is use a TerraForm function, we're going to use the file function. So all we have to do is utilize file and then enter the path to our key. And what that will allow us to do is specify the key just like this only much shorter by just passing in a path instead of the full public key. So let's go ahead and do that. So we'll start with a resource. AWS key pair just like so after that, I'm just going to call it MTC off, open and close those resource braces. Key name, I'm going to go ahead and call that MTC key just to keep things simple. And then we need to pass in that public key. And to do that, we're going to utilize the file function. And we'll quote this and I'll use that tilde slash dot SSH slash MTC key dot pub. And again, I'm on Windows, but these commands should all pretty much line up and be the same. So I'm going to go ahead and save that. Gonna run a TerraForm plan. Make sure everything looks good. I'll scroll up here a little bit. All right, perfect. So the key pair will be created looks like everything past those initial checks. So I'll run a TerraForm apply, auto approve, just like so. All right, apply complete. So if I take a look over here and my AWS resources, we can see if this is one that is available for us, so I'll just type in key. Unfortunately, key pair does not appear to be one that we can see right here from this screen. So we'll just head back into the EC two console. I'll click on key pairs. And there it is. MTC key type EDI, 25519. Everything looks great. We're going to finally deploy our E See to instance, it won't have anything installed on it yet. But we'll at least get it scaffolded and deployed. So let's get started. All right, we take a look at our docks here, the resource is actually called AWS instance, as you can see, in the basic example, it's using an AMI lookup, which looks very similar to what we have used before. As you can see, it's got the owner, it's got everything else here. Of course, we already saw how to get the owner ID ourself, so that's great. And then basically, we just need to provide that AMI and you reference that by using the data keyword, dot AWS underscore AMI dot Ubuntu ID. So do keep that in mind where typically with a resource, we would just use AWS vpc.my vpc.id, for instance, but with a data source, you need to pin that with the word data. And then we'll just provide a few more arguments. As you can see, there are a lot of arguments for the EC two instance. So let's go ahead and start coding this thing out. All right, so what I'm going to do, let's scroll this down a little bit. And let's add our resource. AWS instance, just like so I'll just call this dev node, just like so open and close those resource braces, we need to provide an instance type first. And to keep this in the free tier, we will use a T two dot micro Of course, you can scale that up, but that might cost you some money. And then we need to provide our Ami. So as you remember, the AMI in our data source here is data dot AWS AMI dot server AMI data dot AWS underscore AMI dot server AMI, just like so. And then we just need to add ID to the end. And then let's add some tags. We'll just give it a name equals, and we'll call it dev dash node, just like so. Now after that, we need to provide our key name, which of course we created recently. And what we're going to use is AWS key pair, which of course we just created right here, dot MTC underscore off.id. Once again, now I see that this says key name and not necessarily ID, but the ID is perfectly fine. Here the ID will work. Now if you take a look by just running TerraForm state show AWS key pair dot MTC underscore off we can see there actually is a key name. So if you want to be more explicit, you can absolutely use key name ID is just a force of habit. It's something that I do frequently. As you can see, it is the same for both. So both works perfectly fine. But just know you can use key underscore name if you want to be more explicit. Alright, so now that we've done that, let's go ahead and give this EC two instance a security group VPC Security Group IDs. You see this s here, which means you guessed it, we need to use brackets. And I'm just going to do AWS underscore security and tab there to autofill. That dot MTC underscore s g. Right there.id. And of course, if you have multiple you can use comma separation to provide multiple security groups. And then we just need a subnet id. So that's going to be AWS subnet dot MTC underscore public subnet just like so.id. Then if we want to resize the default size of the drive on this instance, we can provide root block device just like so. And you can actually up this we can say volume, size equals you could say we'll just say 10. We'll keep it in the free tier, which gives you 16. So we'll just say volume size equals 10, which is larger than the eight that they give you by default. All right, so that actually is all we need to add for our instance for now. Let's go ahead and run our TerraForm plan. All right. As you can see, we've got a lot of attributes there. But everything looks good to go. But actually don't bother applying yet. We're going to go ahead and come on back to the next lesson and add some user data before we apply this instance. So we don't have to wait for it and then just re destroy it. We're going to utilize user data to bootstrap our instance and install the doc per engine. This will allow us to have an easy to instance deployed with Docker ready to go for all of our development needs. So let's get started. Now the first thing I'm going to do is just clean up this AWS instance a little bit, I'm going to cut this out. And I'm just going to take everything that's not in a block, and place it together. So this will make things look a little more streamlined. So as you can see, we've got all of our arguments here, followed by the tags block, and the root device block. And just to be consistent, I'm actually going to cut out this root device block and put it above the tags block since almost everywhere, we finish the resource with tags. All right, perfect. So that looks a lot better. So now let's add this user data. First thing I want to do is create the user data file. So I'll create a new file. And let's just call it user data dot tpl. Now, this TPL actually stands for template. We're not using this as a template right now. But just in case in the future, you decide to use it as a template you can and we'll take a look at templating here in the coming lessons. Alright, so go ahead and take that script I have provided in this lesson, and paste that in. Now this script, as you can see is going to update apt, it's going to install some dependencies, it's going to download the Docker GPG key, it's going to add the Docker repository update once again, install Docker, and then it's going to add Ubuntu to the Docker group, allowing you to run Docker commands as the Ubuntu user. I know that was a little quick, feel free to reach out if you have any questions. So now that we've got this in, it's in our user data dot tpl script, and I have saved it and this is in our root directory. Let's head back to our main.tf. And let's go ahead and add this user data to our resource. So what I'll do is just add user underscore data equals, and we're just going to use the file function here. And in quotes, once again, user data dot tpl. So what this is going to do is extract the contents from our user data dot tpl file and use that to bootstrap our instance. So Perfect, let's go ahead and see if everything works. Let's run a TerraForm plan. All right one to add. As you can see, we've got our EC two instance here, everything's looking pretty good. As you can see, our user data is hashed here. So if this user data were to change, it actually would change that hash and indicate that we need to redeploy our instance. So that's really, really useful. So now let's go ahead and apply TerraForm apply, auto approve, just like so. Now, this is going to take a little bit, so feel free to pause, and then come on back whenever your instance is deployed. All right, as you can see, the apply is complete, I'm going to head into my PC to console, just like so. And as you can see, it's running. And I've actually had a few dead ones here. But this new one is running, but it's still initializing. So go ahead and pause the video once again, hit refresh a few times, and come on back whenever the status check is green. All right, so now everything is green, we've got to have two checks past perfect. So now let's SSH into the instance. First of all, I need that IP address, so we can definitely just copy it from right here. But another way, of course, is to use our TerraForm state. So if we do a TerraForm state list, just like so we then see our instance right here, I'm just going to copy that. Then I'm going to do a TerraForm state show and hit that instance right there. And here's all of the information we can get it if I scroll up a little bit, I've got the public IP address right here. Perfect. So now what I'm going to do is just do it SSH dash i. Then if you're on Linux or Windows, you can use the tilde slash dot SSH slash MTC key or whatever you name that key. Now, if I hit tab that will actually correct it for Windows users, but it doesn't matter. It works either way. And then I'm just going to use my Ubuntu username at that public IP address. And hit Enter. Type yes, and bam we are in the instance now. So if I run a Docker version. As you can see, we now have Docker installed and the instance is running, we're going to take a look at the configuration we're going to have to create to allow VS code to connect to our EC two instance. So first of all, if you haven't already, head over to the extensions, and go ahead and search for SSH. And you should see this remote SSH app here. Go ahead and install that extension. Just like so. Alright, perfect. So now that we've done that, we can go ahead and head back to the Explorer. And first thing I want to do is take a look at some example config files. So you should have a file now at your home slash dot SSH slash config. So if I do cat, SSH config, just like so. I can see here that I already have two entries. Of course, this is something I've done before. And what we need is we need to provide a host, a host name, which happened to be the same here and the user that we're going to use to log in. So what we need to do is provide the IP address of our instance, on both of these host areas host and host name. And then we'll utilize Ubuntu for the user. So how are we going to do that? What we're going to do is we're going to use template files. And we'll take a look into that very soon. But first, let's create the files. So go ahead and create a file based on your operating system. Whether you're on Windows, or Linux or Mac, Linux and Mac can both use the same script, Windows is going to be different. So I'm going to create both in this lesson. First, I'm just going to create windows dash SSH config dot tpl, just like so. And if you're on Windows, go ahead and grab that script, copy it, and paste it in. So basically what this is doing, and you will need to replace your username here. Mine, of course is Derek yours probably isn't Derek, but you might be go ahead and replace that. And then this is going to add the host host name user and an identity file, which we didn't see before. But we do require to our config. Now what we do is we actually specify the host name, the user and identity file from our main.tf. And we're going to take a look at how to do that in the coming lessons. So go ahead and save this file if your windows. And if you're Linux, let's go ahead and create that one. So again, you can call this Mac if you want, I'm just going to call Linux SSH config for our file name. And this will serve for either Mac or Linux. And for that, go ahead and copy the script and paste it in. And what we've got here is we're actually catting into home dot SSH slash config. And then we've got the host host name, host name, user and identity file, just as we did before. So go ahead and save that file. If you're Linux, you can also provide both if you utilize both platforms like I do, we're going to utilize a provisioner to configure the VS code on our local terminal to be able to SSH into our EC two instance. Now a provisioner is not something you want to use for every deployment. Unlike other resources, a provisioner success or failure will not be recorded or managed by TerraForm state. So if something goes wrong, that's just too bad. There's no rollback or any other way to manage it other than just running it again. While this is not good for configuring remote instances, it's perfectly fine. For something like this, all we're going to be doing is adding information to a config file on our local terminal. This is a lightweight operation that doesn't affect the overall success of the deployment if something were to go wrong. So with that being said, let's get started. First, we'll take a look over here at the provisioner documents. As you can see, provisioners are a last resort. Generally speaking, you're going to want to use user data which of course we do Ansible or packer, or chef or something else some other configuration management tool. If there's some sort of configuration we need to do on a remote instance. But once again, on our situation, it's perfectly fine. And we can use the local exec provisioner to allow us to configure local machines and run local commands. As you can see, basically we're running a provisioner and in this case a Local exec provisioner within an AWS instance, resource provisioners are always run within another resource. This could be something called a null resource also. But we're not going to look into that right now. Now another thing we're going to use is this self object here, which basically allows us to access this instance, and access information. So if we need a private IP, or public IP, or whatever, we're able to access that right here, using this self attribute. Now, something else you might notice, we've got this dollar sign, and braces here, that is interpolation syntax. And basically what that means is this is going to be replaced by whatever it is we're trying to use. So we've got a string here. But this here will be replaced by the private IP of this AWS instance. And you may have remembered that in our previous scripts, so let's go ahead and just get to work. So right over here, once again, we can take a look at our configuration files. And once again, remember these here, the same syntax, these are going to be replaced by the host name, the user identity file, whatever we need to pass in. So let's go ahead and start typing our provisioner. Gonna go to the bottom of our instance resource here, we're going to type provisioner. Just like so. And then local dash exec, we've been using underscores a lot throughout this script, as you remember, but this provisioner uses a dash make sure you remember that this is a dash or a hyphen, and not an underscore. This is a mistake I've made many, many times open and close that provisioner block. Next up, we provide our command. Now this command is actually going to be run from these files here. And to run these files and pass in the variables necessary, we won't use the file function, we'll use what's called the template file function. So we take a look at the template file function here, you can see that basically, you pass in VARs, after you pass in the path. So for instance, you can take a look at here template file. And then this here is the path which is using this interpolation syntax and path dot module, which is a built in variable and then you use a comma. And then within an object here with these curly braces, you pass in the variables that you need to pass in. So let's go ahead and do that. So for the path, in my case, since I'm on a Windows machine, I'm just going to use quotes windows, dash SSH dash config dot tpl, just like so if you're on Linux or Mac, you'll use the Linux version. And then after that, we need to pass in our variables. So I'll add a comma here, then open and close some curly braces, and we will pass in these variables, I'm actually going to indent this. First up, we need our host name. Remember, we had to pass in a host name there. And that host name is going to be self dot public underscore IP. Remember, we have a public IP attribute for our instance that we used before, whenever we SSH into it. So we can just use self dot public IP here to access that after that, we need to provide the user and that's going to be Ubuntu because that is the EC two instance username that we have. After that we need to provide an identity file. So that identity file is going to be our private key. And the private key is located we'll just use a tilde here slash dot SSH slash and TC key just like so. Alright, so that is all of the variables we need to pass in. And then after that, we need to pass in an interpreter. Now the interpreter basically just tells our provisioner what it needs to use to run this script. Now it defaults to bash so you don't necessarily need to add this for that, but we will just to be sure, so I'm going to add interpreter, just like so. Equals, and since I'm on Windows, we're going to use PowerShell and then we need to pass in the next command which is dash command. Now if you are on Linux, and do not put both of these here, I'm just using this as an example. For interpreter. You're going to use bash, and we'll have a comma here. And then dash c is the interpreter you'll use for Linux. But again, I'm on Windows so I'm going to delete that and keep this here. Alright, so once you've done that, that is everything We need to do and this will hopefully create our instance. And it will replace the hostname with self dot public IP the user with Ubuntu and the identity file with this key here. So let's go ahead and give it a shot. Now the first thing we need to do is we need to run a TerraForm plan. Pull this up some. Now as you can see, we've got no changes here. That's because the provisioner does not affect our state, it doesn't read that there's a provisioner there, and it's not going to change anything just because we added one, we're going to redeploy our EC two instance. And finally see if everything works. So hopefully, when we redeploy this instance, this provisioner is going to run add the information required to our configuration file and allow us to SSH into the instance without any issues. So let's go ahead and give it a shot. So first up, once again, I'm just going to run that TerraForm plan. And as you can see no changes, which means that this provisioner is not going to run because TerraForm hasn't detected anything different. Once again, it does not detect provisioners as differences in the state. So it's not going to trigger a run. So let's go ahead and take a look at a way that we can trigger that run. First up, I'm just going to run a TerraForm state list again. And of course, we've got our AWS instance dot dev node, go ahead and highlight that and copy it. And then what we want to do is use a new command we haven't used or at least a new flag, we've used TerraForm apply a lot. But now what we're going to use is a dash replace. Now this used to be known as TerraForm tanked, which would actually cause a resource to be replaced on the next run. But now instead, we just use dash replace, I'll go ahead and paste in this instance, dot dev node here. And let's hit enter. All right, as you can see, we are refreshing the state. Okay, now we've got one to destroy, and one to add. So it is removing and replacing our instance. And once that happens, it should run our local exec replacing the content in our config file with what we need. And allowing us to SSH into our instance from VS code. So let's go ahead and type yes, and pause this video. Come on back whenever it's done. Of course, you might want to hop into the EC to console. And once the instance shows up, is running and has to have to complete and green. Go ahead and come on back. And we'll see if everything worked. All right, all of my checks are passed here. Let's go ahead and bring our editor back over. And this is now the moment of truth. First things first, I'm just going to Cat my SSH config file. And this is a really good sign. Look at that it looks like our provisioner did exactly what we asked it to it added the IP address the host name, our user and the identity file to our config file. So now that that's happened, let's head up to View command palette. And let's just type in SSH right here. And as you can see remote SSH connect to host click on that. And hey, check that out. So we've already got our IP address ready to go. Let's click on it opens a new window. This is a Linux host. Again, we're on Windows terminal or I am but it's a Linux host. So Choose Linux here. Yes, we are sure we'd like to continue. Looks like everything is setting up downloading installing VS code server. All right, let's open a terminal terminal new terminal. Bam check that out. And if we run Docker Docker is nice and installed. Once again we can do a Docker dash dash version. So now we have a perfectly good development environment ready to go you can open up folders on the remote. Once again home Ubuntu is a remote folder. So if I run that I am now in a fully remote terminal. Go ahead, I can hit trustees authors. Bam, perfect. So this is really, really cool. We're going to start optimizing our script and making it more dynamic by adding variables. So let's get started. Now, so far, we've hard coded pretty much everything. So now it's time to modify that to give us some flexibility. So that we can adjust things easily without having to fish through every single attribute here. And instead being able to go to one file and modify what we need there, for instance, probably one of the things we're going to modify the most is the type of OS we're using. So since for instance, I use Mac, Windows and Linux quite frequently, there's a good chance, I'm going to want to be able to modify which type of instance I'm using on the fly. So let's go ahead and take a look at that. Now first of all, what I want to do is I want to use interpolation syntax to specify a variable here. Now, basically, that variable will be calculated whenever we apply our script. So I'm going to use interpolation syntax, which I've mentioned before, and basically that's going to be $1 sign in two curly braces, just like that. So whatever happens here is going to be calculated dynamically whenever we run our script. So let's go ahead and name this variable, we'll call it var dot host underscore OS. So anywhere we need a variable, you specify it with var dot variable name, just like so. So now if I choose windows, then it will be Windows dash, SSH dash config, Linux, Linux, dash SSH dash config, just like so. So now what we need to do is we need to initialize this variable and specify that, hey, we've got a variable that we're going to need to define. And to do that, we can either do it here in line in the main.tf, or what I prefer to do, and most everyone is to create a new file for it. So I'm going to create a variables.tf file. Once again, it's analyzed just like any other TF file, it's all run at the same time. But this will just make sure that it's easier to find our variables when we need them. Now, you can take a look here at the input variables, documentation, declaring an input variable is actually fairly straightforward, you use the variable, variable name, and then within braces, you give it a type. And you can also give it a default. Now the type is not necessarily required, but it is strongly recommended. So that your other DevOps coworkers don't lose their minds trying to figure out what type of variable is expected. So let's head back over here, and let's go ahead and build this. So it's going to be a variable, once again, post underscore OLS, then we'll use our curly braces. And we'll just provide a type and that type equals string. We're not going to bother with a default yet, but we'll get to it. So now that we've done that, let's actually go ahead and perform a TerraForm destroy, auto approve. And as you can see here, it's actually asking for this variable to be defined now. So keep that in mind. Anytime you add a new variable, any destroy, apply, or plan operation is going to require that you define those variables. And we'll look at other ways to define them so that we don't have it popping up every time here from the command line. But for right now, we can just define it dynamically. So let's just go ahead and I'm gonna say windows if you're on Mac, or Linux, specify Linux, but again, nothing really matters now, because nothing is running. So go ahead and destroy this infrastructure. Pause the video and come on back whenever it's destroyed. All right, so everything is destroyed here. In just to illustrate, once again, if I run a TerraForm plan, it is going to ask me for that variable. So if I type that in, then the plan will run. So keep that in mind. Again, if you have variables that are not set, a plan, apply or destroy is going to ask for those variables. So if you're in automation that can break your automation, we've now seen how to initialize a variable and how to define it at the command line. But as we saw, that is not a great way to define variables when an automation as it requires Dynamic Input, which is the opposite of automated. So in this lesson, we're going to look at a few other ways to define variables, and which of those ways take precedence over the others. So let's get started. So first of all, let's take a look at the docs again, and if you scroll a good bit down, you can kind of see like we've got default values, custom validation rules. We've got a lot here that's actually really good information. But what we really want to see is if you scroll all All the way down, you can see variable definition precedents. So basically environment variables are processed last. So as we go down this list, these are processed in front of the other. So environment variables are processed last. So if you have an environment variables set, but then you define a variable in terraform.tf VARs, which we're going to look at, then terraform.tf. VARs, is the variable we're going to use. And then you've got terraform.tf, fires dot JSON, which not too many people use, but you can use it in automation, it does help sometimes, you've then got auto.tf, vars, and auto that TFR is dot JSON, which are used in TerraForm. Cloud quite frequently. And then you can specify a VAR and var file option on the command line. But this isn't like a dynamic definition. It's not like it asks you for the definition and you type it, you just add this dash var switch, and then you provide the definition. And we will look at that. So let's go ahead and just take a look, what we're going to do is run the TerraForm console. And this is a really good tool that will help you work with certain functions and play with different values and things like that, that you might need to experiment with before you deploy. So if you run TerraForm console, let's just take a look. As you can see, it did not ask us for a variable. So if I run var dot host underscore OS can see it's known after apply. So until we actually apply and specify that variable, then our TerraForm console has no idea what that host OS variable is. So I'm going to go ahead and type exit to get out of the console. And what I'm going to do first is just add a default here, so go ahead and add default equals, and then specify your host, which again, mine is Windows, yours might be Linux. So now let's go ahead and run a TerraForm console. It was run var dot host underscore OS. There you go. So now it is processed it basically TerraForm console has looked at all of our configuration files and saw that we have a default of Windows. So that's awesome. All right, so I'm gonna get out of the console once again. Now what I'm going to do is I'm going to create a new file, and we're going to call that TerraForm dot t f bars, just like so. Now, this is the default name for our variable definition file. So here, all we need to do is define the variable. So host OS equals windows. Or you know what, I'm just going to type Linux, since we're not running this right now. So now let's run a TerraForm console, just like so. And let's run var dot host OS. Now it's Linux, as you can see TerraForm, that TF VARs takes precedence over a default variable set within the variables.tf. Alright, so that's great. So now I'm going to get out of the console again. Now let's say we have I don't know a Unix System, or we want a different script that only works with OSX. And we want to specify that now if we still have these two files, how are we going to override this value? Now that we have it defined in TerraForm dot TFRs? Well, there are a few ways to do that. And one way is to specify the variable in line with our command. So if I run TerraForm, console, dash var equals, and we'll just say host, os equals in Unix, just like so. Now, var dot host, underscore OS is Unix. So if you need to override everything that you have specified in any file anywhere, you specify it right here in line, and again, this could be a TerraForm. Apply or TerraForm plan that you specify this VAR for in this will override any other files that you've got. So now let's take a look at one more scenario. I'm going to exit once again. Let's say that we have a dev dot TFRs. Now what matters is the TFR is not necessarily the word in front. However, TerraForm is going to process anything in TerraForm, that TFRs by default, so if you have a dev dot, TFR, and let's say that was host OS equals OSX, just like so, we run a TerraForm console. And then we run Varta host OS. As you can see, it's still Linux, not OSX. So if we want to pass in this file, we just need to run TerraForm console. Dash var dash file equals dev.tf VARS. Just like so. And now let's take a look Farda host underscore OLS is now OSX. Perfect. So now we've seen most of the ways that TerraForm will process variables and the precedents it uses to decide which variable to use. So now that we've managed to choose our SSH config file dynamically based on the definition of our host OS variable, we now need to make our interpreter dynamic. Unfortunately, this isn't as simple as interpolation syntax replacements. So we need to look at a better way, we're going to utilize conditional expressions to choose the interpreter we need dynamically based on the definition of the host OS variable. So let's get started. So what I mean by interpreter, of course, is this interpreter here, the one that determines what interpreter is going to be used to interpret our SSH config script. And if it's Windows, it's PowerShell. And if it's Linux, it's bash, and as you can see, we can't just replace it like we did up here. That was very simple. And of course, there are ways we could define this. But you know what, since we know that it's only one or the other based on the host OS, I don't want to create a new variable just to do this, I'd much rather just continue using the same host OS variable. So if you take a look at conditionals, here, conditional expressions, you can see basically, you provide a condition question mark, and then you see the true value, or the false value. So if host OS is Windows, the true value would be PowerShell. And the false value could be bash, for instance. So let's go ahead and just hop in and take a look at what this looks like. So I'm going to run the TerraForm console. And we're going to pass in a variable definition. Of course, we haven't defined all over the place up here in our files, but we're just going to define it right here in line, instead of messing with those files right now. So var equals host underscore OS equals windows. For me anyway, and enter. Let's verify var dot host OS, Windows perfect. So what we want to do is say if var dot host OS equals and we're using two equal signs here, because we're not setting this we are checking for equality windows, then first we'll just say PowerShell. And of course, this isn't the interpreter, we'll use exactly, but just for the sake of using this now, this will be easier. Or bash, just like so. As you can see, we got PowerShell. Now if var dot host OS is Linux, and we run this same exact command again, PowerShell. Bash, then we get bash. So that's pretty straightforward. So what we want is we actually want this command in the other command, which of course, I've also provided, and we're going to use those instead of just PowerShell and bash. So we'll say var dot host OS is Windows, then what we want is in brackets here PowerShell comma, dash command, just like so and close that bracket. Or if it's not windows, if this is false, then we just use bash, comma dash c, just like so. Let's hit Enter. And perfect even though the formatting is a little wonky there, this will be perfectly fine. So go ahead and just copy this directly Ctrl C, that and for interpreter, I'm just going to paste that in just like so. And that's all we have to do. So let's go ahead and exit the console there. And let's go up to our terraform.tf VARS. Make sure that is set to your OS. I'm gonna go ahead and change this to Windows since that is the OS I'm using variables.tf. The default is Windows, which is fine because terraform.tf Ours is going to override it anyway. So if that's different, that is perfectly fine, but you may want to change this as well. And then once again, with that our main TF, everything looks good. So let's go ahead and run a TerraForm plan. All right, everything looks like it went through fine. So let's go ahead and apply it TerraForm apply, auto approve, and hopefully by the time our instance is fully initialized, we will be able to SSH into it just like we were able to before so go ahead and run this TerraForm apply, pause the video and come on back whenever your EC two instance is all green. All right, everything has come back just fine. We're running in all green. So let's go ahead and see if this new IP address is available for SSH. I'll actually take a quick peek three 4.219 for this one. So I will click on View command palette, I've already got remote, SSH ready to go. And there it is 342219224 6.58. Let's go ahead and see if it works. This is a Linux machine, I would like to continue Yes. And everything is looking absolutely fantastic. We once again, have our development environment all ready to go. But this time, it's dynamic. Based on the host OS that we're using, we're going to add a nice little convenience feature to our script. By utilizing outputs to display information we need, as you well know, we've been manually finding the public IP address of our instances to verify them. Well, that is incredibly inefficient. So let's go ahead and add an output to make this a little easier. So as you can see, we've got output values here. And basically, it's incredibly simple to do. So this, of course, is how to access a private IP, well, we're just going to access the public IP. As you can see, we've got a lot of other features as well, such as the ability to mark an output sensitive so that it doesn't show up on the command line, you've also got a depends on feature as well, we're not going to dive into that. But we are just going to go ahead and access that public IP of our instance. So if you run TerraForm console, you can then access all those attributes of our instance and kind of play with them to see what output we're going to get. As you remember, it is AWS instance dev node. So if we just type AWS underscore instance, dot dev underscore node, dot public underscore IP, there it is. So that's very, very simple. And as you know, you can use TerraForm, show or TerraForm state show to get all of these attributes that you could use for outputs. So if I get out of this console, and run a TerraForm, state show, and of course, we'll just use once again, AWS instance, dot dev node, just like so we can see all of the possibilities that we can use to output. As you can see, we get output instance types, and here is public IP. So that's what we did, we just accessed that. So let's go ahead and create this output, what we're going to do is just create a new file output.tf. Once again, you could add it to our main.tf. But we just want to clean things up a little. So output. Here, we'll just call this dev IP, open and close those braces, value equals AWS instance, dot dev underscore node dot public IP, just like so that's all we have to do. Now to access this output, we may not want to destroy our entire deployment, just because we added an output, what we can do is just run a TerraForm, apply dash refresh only. And that's basically just going to consider this output and add it to the state so that we can get to it, just like so as you can see, we've got changes to outputs. So that's perfect. So let's go ahead and run this. Apply complete. That's it. And then we can run TerraForm output. Just like so to see our output once again. And this is very, very useful in automation. Now, if we take a look in our TF state, scroll all the way to the top, we can see our outputs are right here. So it's very easy to see what we need to see. So outputs are incredibly useful. And there's a whole lot you can do. You can get very creative with what types of output you get. But for our purposes, all we need to know is that IP address which matches the one that we use to SSH into that instance.
