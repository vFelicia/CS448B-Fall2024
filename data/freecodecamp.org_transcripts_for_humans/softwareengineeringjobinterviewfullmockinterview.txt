With timestamps:

00:00 - are you ready to Ace your next technical
00:02 - programming interview in this video
00:04 - Keith Galley conducts a mock full-length
00:07 - real-world coding technical interview
00:09 - with Kylie Ying for a software
00:12 - engineering role learn how to use object
00:14 - oriented programming and dynamic
00:16 - programming to solve questions and get
00:19 - the job you want
00:21 - most people will probably agree that one
00:23 - of the worst Parts about finding a job
00:25 - as a software engineer is the technical
00:28 - interview during these programming
00:30 - related interviews the interviewer will
00:33 - expect you to work to a solution
00:35 - optimize it and write code or pseudocode
00:39 - on the spot the reasoning Behind these
00:40 - interviews is that they will help the
00:42 - interviewer understand your ability to
00:45 - understand the problem ask questions go
00:48 - deeper and optimize the solution how
00:51 - much do you understand data structures
00:53 - and algorithms and ultimately what is
00:57 - your coding level and what is your
00:59 - coding ability today I paired up with a
01:01 - good friend of mine Keith Galley who has
01:03 - a data science focused YouTube channel
01:05 - and he is going to be mock interviewing
01:08 - me so this interview might look like
01:10 - what a real software engineering
01:12 - interview looks like I don't know what
01:15 - question he's going to ask so it's going
01:16 - to be as much of a surprise to me as it
01:18 - is to you and I will be coating on the
01:22 - spot so
01:24 - here we go
01:29 - welcome
01:31 - to the interview how are you doing today
01:33 - I'm good how are you I'm doing pretty
01:36 - well
01:38 - um we're gonna probably just jump right
01:39 - into this interview I'm just curious are
01:41 - you familiar with coderpad because
01:43 - that's what we're going to be using
01:44 - throughout I think it might be easiest
01:45 - to kind of share code
01:47 - yeah
01:49 - cool all right so we're going to kind of
01:52 - just jump right into the the problem so
01:55 - for the purpose of this problem and let
01:57 - me share I just want to make sure you
01:59 - can access this coder link so I'm going
02:01 - to share this and I recommend maybe
02:04 - sharing your screen or I guess we also
02:07 - can just work off of this so I should be
02:09 - able to see here what you typed in
02:11 - I open the chat I can click on this link
02:14 - and it'll take me to the coder pad my
02:18 - name is Kylie and I will enter and so I
02:21 - can see that you're in this coder PAD as
02:24 - well and then here I am yeah and just to
02:27 - make sure that you're comfortable here
02:28 - you want to just run like a couple
02:30 - simple lines of code you can try just
02:32 - running this print hello world
02:34 - if you want yeah so if I run this
02:37 - it'll say that I ran a line of python it
02:40 - prints out hello world so
02:42 - I think it works perfect okay so let's
02:45 - uh kind of jump into the problem so just
02:48 - to give you some context we're going to
02:49 - start with about 20 minutes of design
02:53 - object-oriented design however you want
02:55 - to design this code and then we'll spend
02:56 - probably the last 20 minutes working on
02:59 - more of an algorithms question so that
03:01 - gives you just a little bit of a scope
03:03 - uh you don't necessarily have to
03:05 - accomplish everything you know I know
03:07 - that we have limited time
03:09 - but to kind of give you the context of
03:11 - the problem
03:13 - imagine that where
03:15 - designing a book system so an online
03:19 - Cloud reading application
03:22 - and you can pretty much imagine that
03:23 - we're building a product that is similar
03:26 - to an Amazon Kindle
03:29 - but specifically for short stories so
03:32 - we're kind of in our own Niche they
03:34 - might be Indie stories they might not be
03:36 - you know found anywhere else people
03:37 - could add their own stories
03:41 - um and basically what we want to do to
03:43 - start this problem off is that we need
03:45 - help designing the actual
03:47 - application we needed help designing the
03:50 - code that could Implement an online
03:52 - Cloud reading application and there's a
03:54 - couple things that we're looking for and
03:56 - this is very open-ended you can
03:58 - implement this how you want but a few
04:00 - things and I'll paste these into the
04:01 - coder pad that we're looking for
04:10 - I'll just paste it below
04:12 - um oh yeah okay
04:14 - you can fix this up
04:16 - and I'll delete that Top Line
04:19 - okay so a few things that you're looking
04:20 - for users have a library of books that
04:23 - they can add to or remove from users can
04:26 - set a book from their Library as active
04:30 - um the reading application remembers
04:32 - where a user left off in a given book
04:34 - and the reading application only
04:36 - displays a page of text at a time in the
04:39 - app in the active book
04:41 - exactly
04:43 - awesome
04:45 - um so
04:47 - so let's see
04:51 - essentially what we want to do is create
04:54 - a library where users can interact with
04:57 - this Library they can look at a book and
05:00 - set it as active and then
05:02 - this application will also just remember
05:04 - where they left off and display whatever
05:09 - page that they're currently looking at
05:11 - in the active book
05:13 - is that correct correct correct
05:16 - okay and then more specifically do you
05:19 - want me to kind of give like a high
05:21 - level implementation or
05:24 - um how do you want me to start this
05:26 - so I really want to just think about you
05:28 - know what components would be important
05:30 - this is I would say an object-oriented
05:32 - design question so I'm just thinking
05:34 - about how you would think about
05:36 - structuring uh I guess the base of a
05:39 - program like this so obviously we're not
05:41 - going to build this full application but
05:43 - I'm really curious about how you're
05:44 - structuring that kind of that core
05:46 - structure that core um
05:48 - Foundation
05:50 - right so let me make this uh smaller
05:54 - over on this end so people can see all
05:56 - this
05:57 - and let's type up some more notes so uh
06:01 - the things that jump out to me are that
06:04 - you need to be able to remember all
06:07 - books so if I type this
06:12 - we need to have all books in the library
06:13 - and we need to
06:16 - um remember active book and then we want
06:21 - to remember page
06:24 - uh
06:26 - remember page I guess last pages in all
06:29 - books
06:31 - and then
06:33 - we want to
06:35 - display
06:37 - a page in active book Okay so
06:43 - um by this all books in the library is
06:45 - that more so
06:48 - I guess how are we representing these
06:50 - books are we are they just like strings
06:52 - do they have a page number and then the
06:55 - string of text how is that formatted is
06:58 - it like HTML I think it's up to you how
07:00 - you want to
07:02 - um store the books within like this
07:04 - programming structure so you can kind of
07:06 - decide what makes sense
07:08 - for that
07:10 - I think the important things is the
07:12 - actual text of the book as well as the
07:14 - title of the book
07:16 - okay okay and and you can implement the
07:20 - uh the details of like the pages and all
07:22 - of that yeah
07:23 - yeah okay so I think that there's two
07:27 - things that jump out to me here right
07:29 - it's we need one class
07:33 - we want one class representing
07:36 - a book and then we want another class
07:39 - perhaps representing a library so a
07:42 - collection of books and so in this uh
07:45 - book specifically you just mentioned
07:47 - that we want the title as well as the
07:51 - like pages in the book yep
07:54 - or like I could rename that the content
07:56 - yep exactly um in the book and then for
07:59 - the library we have a collection of
08:02 - books and then I would also argue that
08:05 - this page uh or sorry that whatever the
08:09 - active book is would would be at the
08:11 - library level because
08:14 - um because we just want to toggle which
08:16 - one is active amongst this entire group
08:18 - right yeah and then actually so this
08:21 - last page in the book what I want I
08:24 - think I'm gonna put that under the book
08:26 - because it's book specific so I think it
08:28 - would make sense for every single book
08:31 - to just remember the last page so
08:34 - um
08:37 - user looked at
08:39 - okay so I like how this is represented
08:42 - and then I think uh kind of diving more
08:45 - so into the implementation I think for
08:47 - the title A String would make sense here
08:49 - because
08:51 - I mean a title is just a string yeah
08:54 - um the pages and the content in the book
08:56 - so the things here are the pages are
08:58 - ordered right when you go through a book
09:00 - They're ordered and there's a specific
09:02 - amount of content per page and so I
09:05 - think something that would make sense
09:06 - for this is just a list because I think
09:10 - a list is ordered it's a collection of
09:13 - items and
09:15 - um
09:16 - and we can't I mean I think like a set
09:19 - you would lose the ordering a dictionary
09:21 - you would lose the ordering and you
09:22 - would also over complicate things a
09:25 - little bit you could have the page
09:27 - numbers as the keys but then
09:29 - um but then a list would also do the
09:31 - same thing but kind of in a more elegant
09:33 - manner
09:34 - and then finally
09:37 - uh a tuple okay you could also have a
09:40 - tuple but
09:41 - um I don't think there's a reason to use
09:43 - like a tuple over a list in this
09:44 - specific example yep or like vice versa
09:47 - like I I think that you could choose
09:49 - from either one
09:51 - so I think here I'm just gonna use a
09:54 - list of
09:55 - um
09:57 - I guess strings
09:59 - which represent per page
10:02 - so like each string represents
10:05 - whatever's on an entire page
10:07 - and then the last page that the user
10:10 - looked at this would just be some
10:11 - integer and this would be an index into
10:13 - this list of strings so
10:15 - I would have to remember that this you
10:18 - know
10:20 - there might be an off by one error here
10:24 - um because in Python we start at zero
10:26 - but like naturally when we're reading a
10:28 - book we might start at one yep
10:30 - now for this library for this collection
10:33 - of books okay well so for this active
10:36 - book
10:37 - um I you could either use a Boolean
10:41 - where you set one book to active and the
10:43 - rest to inactive but I think that that
10:46 - would be kind of excessive because every
10:48 - single time we toggle a book as active
10:51 - we have to toggle everything else as
10:52 - inactive right
10:54 - you can't have two active books yeah
10:56 - yeah okay yeah that makes sense okay so
11:01 - then I think in that case instead what I
11:03 - would rather do is have some sort of
11:07 - um
11:09 - a string or some sort of like an ID
11:11 - matching system where we have like one
11:17 - um variable that's set to the active
11:19 - book and that might be the title or the
11:21 - ID of a certain book in the library so
11:24 - maybe maybe we can just add ID here
11:28 - um and maybe I can make that also a
11:31 - string or an integer or something yep
11:34 - and I'm going to add a question mark to
11:36 - kind of just say like maybe we could
11:38 - Implement that but I'm not sure if we'd
11:40 - want to right now
11:41 - um
11:42 - so this would correspond
11:46 - to ID
11:48 - so uh
11:52 - this would just be some variable
11:56 - and then this collection of books
11:59 - so
12:00 - I guess like when we display this page
12:05 - in an active book
12:07 - um
12:10 - I actually so I think that this week
12:13 - this might have an advantage being like
12:15 - some sort of a lookup table because we
12:18 - have
12:19 - a certain sense of an ID right and I
12:22 - think what could make sense here is
12:24 - having the ID correspond to the book
12:26 - object that we Define up here so yeah
12:30 - this could be a book object right and so
12:34 - um we don't really need this idea I
12:35 - think that if all the titles are unique
12:37 - then then we don't need this ID we can
12:40 - just we can just use the titles as the
12:43 - IDS uh but in some cases in the real
12:46 - world not all titles are unique and so
12:49 - that's what an ID might might come in
12:51 - handy
12:53 - um and so I'll leave that like
12:56 - what are our assumptions here can we
12:58 - assume that the titles are unique or
13:00 - should I be using this ID structure I
13:02 - think I like the ID structure because
13:04 - yeah we're not necessarily going to know
13:06 - that everything's unique so I think this
13:07 - is a little bit more robust
13:10 - okay awesome so I think
13:13 - um this representation looks good to me
13:15 - so I'm just going to go through uh the
13:18 - requirements again just to make sure
13:20 - that I've covered all my bases so here I
13:22 - want all books
13:23 - um
13:24 - okay so I want a library books that I
13:27 - can add to or remove from and so here I
13:29 - have a library and anytime I want to add
13:31 - to this Library I can just add an ID I
13:34 - can add the book If I want to remove
13:37 - um from the from the library then I can
13:40 - just simply delete the key item pair
13:43 - or the key whatever pair
13:46 - key value pair
13:48 - um I can set a book from their Library
13:51 - as active and so here I have this active
13:53 - book and we could always say like if
13:56 - there is no active book then we set this
13:58 - To None or something like that
14:01 - um the reading application remembers
14:02 - where a user left off so we have that
14:05 - here right the last page that the user
14:07 - looked at and not just in the active
14:09 - book
14:10 - and then
14:12 - um displaying one page of text at a time
14:14 - in the active book so we have the active
14:17 - book we can get the book object from
14:19 - that and then we can go to the page that
14:22 - the user last looked at by indexing this
14:26 - value into this list so I think we've
14:29 - covered all the bases here cool
14:32 - um let's do a couple things
14:35 - I guess I think as a starting point and
14:38 - this doesn't have to get too crazy but I
14:40 - would love to just see some you know
14:41 - python pseudocode or even some python
14:43 - kind of code just to like maybe flesh
14:45 - out one of these classes I just want to
14:46 - yeah uh you know look at that a little
14:48 - bit and how you would actually start
14:50 - writing this code
14:52 - yeah sure so so for example here I let's
14:56 - start with the book
14:58 - um and when we define a class let's
15:02 - initialize this
15:05 - so when we initialize a book we
15:08 - definitely should pass in the title and
15:11 - then
15:12 - um the content right I'm assuming that
15:14 - when we add a book these things have to
15:15 - be given to us and then
15:20 - I'm assuming that when we add a book we
15:22 - don't have a last page that the user has
15:24 - looked at is that an okay assumption
15:26 - yeah I like that assumption
15:27 - okay
15:29 - so we can set the title of this book
15:31 - just equal to whatever the title is
15:33 - uh the content of this book and I'm
15:37 - going to assume that these are given to
15:40 - us in the formatting that we want so the
15:42 - title is a string and the content is a
15:44 - list of strings that correspond to the
15:45 - pages
15:47 - um
15:47 - and I'm gonna create a variable last
15:49 - page and I'm going to set that equal to
15:52 - just zero
15:54 - I could also probably set it equal to
15:56 - negative one or something but I think
15:57 - zero makes sense because that would be
15:59 - the beginning right yep and
16:03 - um and then we need to come up with some
16:05 - sort of an ID so
16:08 - typically maybe we would have some sort
16:10 - of function that takes in the title and
16:13 - the content or maybe the author or
16:15 - something and like returns a unique ID
16:18 - um
16:18 - but I think maybe something that we can
16:22 - do here just very simply is uh have some
16:25 - sort of counter in the library and then
16:27 - every single time we like at add a new
16:31 - book we can just associate that counter
16:34 - with that book and so then we know that
16:35 - they're all unique and
16:38 - um
16:39 - and they all have their own IDs would
16:41 - that make sense yeah that that makes
16:43 - sense
16:44 - okay so then I would have to pass in the
16:46 - ID
16:48 - um
16:49 - yeah and so what I'm actually going to
16:52 - do is self.id equals ID
16:55 - uh and then
17:00 - yeah and so then uh for example we might
17:02 - want like a display page
17:05 - right in this book and so
17:08 - for that then we just want to return
17:13 - um whatever is at the last page of the
17:14 - content
17:18 - and I guess let's build on this a little
17:19 - bit another useful function you know
17:22 - obviously you want to start at the the
17:23 - last page but let's say we're starting
17:25 - to turn the page what might that look
17:27 - like
17:29 - right and so if we're turning the page
17:35 - then all we want to do is increment the
17:38 - last page right and so we might do
17:41 - self.last page
17:43 - and we just increment that by one
17:46 - um and then we could call display page
17:48 - after that
17:50 - uh if we assume that
17:54 - like we could if if we assume that these
17:57 - two go together so if we assume that
17:59 - when we turn the page we want to display
18:00 - that page then I would just return
18:02 - display page
18:05 - yep
18:06 - like that
18:08 - um
18:11 - and then actually I'm just going to go
18:13 - ahead and code up this Library as well
18:15 - so
18:20 - this Library we have this collection of
18:22 - books and then also the active book so
18:26 - rather than initializing a library with
18:29 - books I think let's just add them
18:32 - um to this so initially
18:37 - this collection might just be an empty
18:39 - dictionary and then
18:41 - the active book might be none right so
18:45 - then
18:46 - um when we
18:47 - want to add stuff so add to collection
18:55 - a book
19:00 - what I'm going to do so
19:04 - there's
19:05 - either the user could
19:08 - like or our API could like return a book
19:11 - with the uh with the title and the
19:14 - content
19:15 - Etc but since we're we said that we
19:18 - would pass the ID through like the
19:19 - library because we might have like a
19:21 - counter
19:23 - like some sort of ID counter I mean this
19:25 - is not the best way to do it but I think
19:27 - this is like a a fine hack for right now
19:30 - um
19:31 - just to make all the ideas unique what
19:34 - we can do here is
19:36 - um
19:37 - we can also when we want to add a book
19:40 - just pass in the title and the content
19:43 - and so then our new book
19:46 - is going to be a book as we've defined
19:49 - above with the ID
19:53 - and
19:55 - um the title and the count or the
19:57 - content
19:59 - and then after we create this new book
20:01 - we want to
20:03 - increment the ID counter
20:06 - uh and then we also want to add this new
20:08 - book Into The Collection right so I'm
20:10 - going to add self.collection
20:15 - um and
20:17 - I'm going to make the ID whatever the ID
20:21 - of the book is so actually I'm just
20:23 - going to call new book dot ID because I
20:25 - think that's a bit cleaner and this is
20:27 - going to be the new book
20:29 - and then we increment the counter by one
20:31 - so this is us adding to the collection
20:34 - um
20:36 - so of course we want to remove from the
20:39 - collection
20:40 - and so we want we said that we wanted to
20:42 - remove based on the ID so all we have to
20:45 - do is I think
20:49 - there's this
20:50 - delete in Python
20:53 - I'm not sure do you know keys
20:57 - okay
20:59 - is there a remove
21:02 - I think that there's I mean it should
21:04 - auto complete here in the coder pad oh
21:07 - isn't it Dell isn't there a Dell
21:11 - um
21:11 - I mean I think the biggest thing is is
21:13 - it going to be happening in place or is
21:15 - it going to be happening and creating a
21:17 - copy
21:18 - um I I understand yeah so we want it in
21:21 - place from The Collection I understand
21:22 - what you're trying to do so the exact
21:24 - details is is not super super important
21:27 - to me
21:28 - okay yeah so anyways this is removing
21:31 - from The Collection
21:33 - um and when we set active book
21:37 - again we want to do this based on the ID
21:39 - so I'm going to make self.active book
21:44 - equal to whatever that ID is
21:47 - uh and
21:52 - let's see so the user has a library of
21:55 - books they can add or remove from we did
21:57 - that sending a book as active Okay and
22:00 - then remembering where user left off so
22:03 - we've actually taken care of that
22:04 - already implicitly in our um book
22:07 - uh class and then the reading
22:09 - application only displays a page of text
22:11 - at a time all right so then here we can
22:14 - say Define display page
22:18 - and actually we don't even need the the
22:21 - ID of the book because we already have
22:23 - the active book ID right and so what I'm
22:26 - going to do is I'm going to go into my
22:28 - collection
22:30 - um and I'm gonna get the active book
22:34 - like this so
22:38 - yep
22:39 - blah blah and I'm going to click or I'm
22:42 - going to do dot display okay
22:48 - and then of course we also have this
22:49 - turn page that I could
22:52 - um
22:53 - to put up as well
22:58 - yep
23:00 - so you get the idea but
23:07 - so we wanted oops
23:09 - turn that page
23:11 - um I do think that some like drawbacks
23:14 - here are that
23:16 - uh okay so one thing that we could have
23:19 - done is instead of this active book
23:22 - instead of saving the ID we could have
23:24 - saved the book itself and I think from a
23:27 - pythonic standpoint that might make
23:28 - sense but then in the future if we're
23:30 - using some sort of database or something
23:31 - an ID would make more sense because
23:34 - that's easier to store in like a table
23:36 - um
23:37 - and
23:39 - if uh and okay also for this display
23:42 - page you might see that we've called
23:44 - this display page and turn page up here
23:47 - in the book and the reason why I did
23:50 - that rather than
23:52 - um rather than just call like
23:55 - self.book.content last page like book
23:57 - dot last page or something
23:59 - was because I think that like for
24:03 - example this should be independent of
24:05 - how we implement the book right so we
24:08 - want to keep those as kind of block like
24:11 - separate blocks as possible
24:14 - and so here what this allows me to do is
24:17 - when I go back to my book like if I
24:19 - decide to scrap this implementation
24:21 - Implement something else
24:22 - I know that I would just have to
24:24 - implement the methods display page and
24:26 - turn page for that to work
24:28 - um
24:29 - and like these functions should work
24:32 - this this looks good to me I like the
24:33 - start I think that this uh definitely
24:36 - lays out the foundation of what I was
24:38 - looking for with the requirements of
24:40 - this application so nice work with this
24:43 - couple quick follow-up questions before
24:45 - we kind of Branch into more of an
24:47 - algorithms uh
24:49 - type question as the follow-up here one
24:53 - question is you know let's say you have
24:55 - an older reader and their vision isn't
24:57 - as great so they need to make this the
25:00 - size of the font bigger so kind of
25:03 - keeping that in mind that you might have
25:04 - this variable font size how might you I
25:07 - guess refactor or change or modify your
25:10 - current structure and you don't have to
25:12 - actually write code here let's just
25:13 - discuss this to account for
25:17 - um that increase in size
25:20 - yeah
25:21 - yeah so I so when we increase something
25:25 - in size like I'm just thinking about
25:27 - intuitively on our like phone screens or
25:29 - something
25:30 - um that type that tends to shift the
25:31 - content right so like some page that
25:34 - might hold a hundred words or a hundred
25:37 - characters at you know
25:39 - um a small font size might only hold 50
25:42 - if when you double that font size
25:44 - so uh for the book instead of having
25:49 - this list what I might do is I might
25:52 - just save the entire book as a string
25:54 - and
25:56 - um and based so I would let me just edit
26:00 - this in here because I think it's easier
26:01 - to visualize what I'm saying but so I
26:04 - would might I might have like a font
26:06 - size equal to
26:09 - um
26:12 - I guess we could just use like the
26:13 - traditional like 12.5 or like yeah
26:15 - whatever uh but
26:18 - when we have this font size we could
26:20 - come up with some sort of
26:23 - um characters per page calculation
26:26 - right and so that would be based off the
26:28 - font size so calculate so this is going
26:31 - to be pseudocode now this calculate
26:33 - doesn't actually exist but calculate uh
26:36 - based on that font size
26:40 - um
26:41 - and I'm commenting it out so it doesn't
26:44 - have any errors but then uh when we do
26:47 - calculate that then what we can do in
26:49 - order to get our
26:52 - um in order to get this display page
26:54 - thing would be instead of indexing into
26:56 - this content which is now
26:58 - just a long string of characters
27:04 - what we can do here is we can return
27:09 - um we would have to do some sort of
27:10 - calculation right so we would need to we
27:13 - have this characters per page and we can
27:17 - multiply that by whatever the last page
27:21 - is
27:22 - and
27:25 - um so this would give us like kind of
27:26 - the starting index of this long string
27:28 - of characters to start uh
27:31 - the content of that page
27:34 - start index would be this
27:37 - and then what we would want to do
27:40 - is
27:41 - um
27:44 - what we want to do is then return the
27:47 - self doc content from that start index
27:50 - until the start index plus the number of
27:53 - characters on that page
27:57 - so that would be our end index so
27:58 - actually let me just write that out to
28:00 - make things a little bit more clear
28:07 - so now essentially what I've done is we
28:10 - have this variable font size which we
28:12 - can calculate characters per page
28:14 - depending on that font size so that
28:17 - might be more characters or less
28:18 - characters depending on how big the font
28:20 - size is and then our content instead of
28:23 - a list of strings is now just a really
28:25 - long string of characters and I guess
28:27 - some assumptions that I'm making here
28:29 - are that uh this would just be
28:31 - approximate so for example if we had a
28:35 - backslash n which is like a line break
28:37 - right that might just end up counting as
28:39 - a character or two characters but the
28:41 - assumption is that
28:43 - um
28:44 - that would be approximate per page or
28:46 - maybe that we're using sort of some sort
28:48 - of like mono spaced font or something
28:50 - like that
28:52 - um but essentially now that we have the
28:55 - characters per page and then just a long
28:56 - stream of characters that represents the
28:58 - content we can index into that content
29:01 - depending on like based on the last page
29:04 - that we know and so what's really cool
29:07 - here is that when we do Turn the Page uh
29:10 - we can just end up calling this so this
29:12 - is kind of that granularity that I was
29:13 - talking about yeah that that makes a lot
29:16 - of sense to me and definitely you see
29:17 - the advantage of having that function
29:20 - that you can change by having to
29:22 - implement something different uh one
29:24 - last quick I guess follow-up and then
29:26 - we'll we'll move on to the algorithms
29:27 - portion of this interview
29:30 - um I'm just trying to think you know at
29:32 - a high level let's say that we wanted we
29:34 - had multiple users in this system and
29:36 - they all
29:37 - shared books so like you know they might
29:40 - all share the Harry Potter books or
29:42 - something like that like books are
29:43 - common among all of them how might you
29:45 - modify this yeah uh given that you know
29:48 - some of these qualities of a book might
29:50 - be shared between users because they're
29:51 - all trying to access that same book
29:54 - does that make sense
29:56 - yeah so
29:58 - um yeah yeah for sure so I I think that
30:00 - when we start to you know have like
30:03 - multiple people
30:05 - um involved like this this these books
30:08 - might get stored somewhere for example
30:10 - in like a sequel table right and so then
30:13 - when that happens we would still want to
30:16 - maybe store like the ID the title the
30:18 - content in that table now the only
30:20 - changes would be that the these sort of
30:23 - customizations are
30:26 - um are per user but the book and the
30:29 - content those are for this entire group
30:32 - of people and what we can do I think is
30:36 - um
30:37 - is
30:38 - instead of this ID counter being like
30:41 - Library specific we can start
30:43 - identifying books by their IDs on a more
30:47 - like uh global scale right and so you
30:51 - know this was kind of just a hack to
30:53 - make this ID thing work and be
30:55 - independent and be like unique but for
30:58 - example when you put something into a
30:59 - SQL table you can also have an ID
31:01 - associated with those entries and so
31:03 - maybe when we add to the collection if
31:05 - we see that the title and the content is
31:07 - already in the table then we instead
31:10 - just return the book that's already in
31:12 - that table or something like that yeah
31:14 - okay I think that makes sense to me uh
31:17 - cool I I'm yeah happy with this
31:19 - discussion I think that we can move on
31:20 - to the second portion I guess do you
31:22 - have any I guess last questions on this
31:24 - before I move on or last things you want
31:26 - to say
31:30 - um
31:31 - yeah so no last questions I think that
31:33 - the last thing I want to say is also
31:34 - like it would really depend on like how
31:36 - you implement this like group of people
31:38 - right like so my immediate thought was
31:41 - like a SQL table but that doesn't have
31:44 - to be the only way
31:46 - um
31:47 - so yeah I think
31:52 - okay cool I think it would depend on
31:53 - that
31:54 - um all right awesome uh let's yeah
31:56 - switch gears and
31:58 - I'm probably going to just comment this
32:00 - out in case you do want to run some code
32:03 - and there's any errors or issues in this
32:04 - so I'm just going to comment this out
32:06 - but I'm going to leave it here just so
32:07 - we have it
32:08 - to look back at and I'm going to just
32:11 - indent this a bunch and we're going to
32:13 - just start at the top of the screen
32:15 - so don't mind all the stuff at the
32:17 - bottom all right so another important
32:20 - component of our book reading system
32:23 - and this is completely independent you
32:24 - don't have to reference any of your past
32:26 - code is
32:29 - I mentioned this is for short stories
32:31 - and you could have independent Indie
32:34 - authors you know adding these short
32:35 - stories so they're not going to be you
32:37 - know the classics not going to be those
32:38 - types of titles they're probably smaller
32:40 - authors so one thing that we want to
32:42 - avoid in this system is plagiarism
32:46 - so my task for you is to design an
32:48 - algorithm that would be able to detect
32:52 - the two most likely books that would
32:54 - have plagiarism in them
32:56 - it's like that the the two most likely
32:58 - books that pop up as a match for
33:01 - potential plagiarism uh in this in a
33:04 - library
33:05 - and we can Define as we can Define most
33:09 - likely as meaning they have the longest
33:13 - shared common section of text
33:16 - so we're looking we have a library of
33:18 - books and we're looking for the two that
33:20 - have the longest shared common section
33:23 - of text and we specifically might want
33:25 - to know how many characters that
33:27 - section of text is so you can imagine if
33:31 - it's sharing a single word obviously not
33:32 - an issue but if it's sharing six
33:35 - paragraphs that's going to be a problem
33:36 - so does that make sense
33:39 - right so just to clarify some things
33:41 - what Keith really means here by
33:43 - substring is that for example if I have
33:45 - a string such as learn
33:52 - what are substrings of this well one
33:55 - possible substring is learn
34:01 - another possible is earn
34:04 - because these are strings that are using
34:06 - characters that belong to this string
34:09 - learning
34:11 - another possible one is earning
34:15 - oops
34:18 - now you might say Okay Kylie all of
34:21 - these are consecutive in terms of the
34:24 - characters so here all of these
34:26 - correspond as characters that are next
34:29 - to each other but in this specific
34:31 - example Keith is not actually asking
34:33 - okay it has to be a consecutive
34:35 - substring instead what Keith is asking
34:37 - is just any substring which means that
34:39 - as long as the letters are in the
34:42 - correct sequence you can skip characters
34:44 - if you want to so for example here
34:49 - leg would actually also be a substring
34:53 - or
34:55 - an so for example right here we have
34:58 - earn as a substring of consecutive
34:59 - characters but down here
35:02 - I could rewrite it as a substring where
35:06 - there's actually a gap of two characters
35:08 - in the middle but this would still be a
35:10 - valid substring so it doesn't have to be
35:13 - consecutive we just need all the
35:15 - characters to be in order from left to
35:19 - right
35:20 - let's see let's start off with kind of a
35:22 - naive solution
35:24 - for that
35:26 - um
35:27 - well
35:28 - one thing that you could do is literally
35:31 - come up with every single
35:34 - combination of like substrings for both
35:39 - of these
35:40 - uh and then compare those and see which
35:42 - two substrings are the longest right
35:47 - um
35:49 - but there's a lot of different
35:50 - combinations for substrings and so I
35:53 - think that we should come up with a more
35:55 - elegant solution
35:57 - um
35:59 - let's see so
36:03 - one thing
36:04 - that I'm thinking is we should have
36:07 - pointers that start at the beginning of
36:09 - both yep strings and kind of move along
36:15 - until one of them detects
36:18 - a shared character
36:21 - so
36:23 - or like when until one of them takes
36:25 - like the first shared character so here
36:27 - actually like I would say the first
36:28 - shared character is H right
36:32 - um and so here we would have like
36:36 - like the two pointers kind of be
36:41 - this uh
36:45 - maybe I'll go from the bottom
36:49 - but here and
36:52 - here
36:53 - right and so we look at the next
36:56 - character
36:58 - and we realize okay they're not the same
36:59 - so then we want to keep going
37:02 - um but one
37:05 - downside of this is that
37:07 - well okay what if I want to start
37:09 - comparing from here and here
37:12 - right
37:13 - okay and then I move it over and like
37:15 - these two have like two shared
37:17 - characters so I think that there's still
37:19 - this question of there's a lot of
37:20 - different combinations here
37:23 - um
37:26 - so
37:31 - I think you're on the right track though
37:32 - I like I like this and then okay so far
37:34 - yeah
37:37 - okay
37:39 - um yeah so I know that here I want kind
37:43 - of these pointers that are moving and
37:44 - then I just want to be able to align
37:46 - them right I think that's the that's the
37:48 - key here is this alignment
37:51 - and so now I think we just have to
37:53 - figure out how to make that alignment
37:55 - work
37:57 - um
37:58 - I'm kind of thinking like
38:01 - like one thing that
38:03 - we could do is kind of have more of a
38:08 - base sentence and then one where when we
38:13 - have
38:14 - like
38:16 - so for example if I
38:20 - if I made this my base
38:23 - sentence
38:25 - then in the other sentence I would want
38:28 - to search this sentence uh
38:31 - for each character so
38:34 - if I have the I here then like my first
38:36 - I would start looking from here and then
38:40 - maybe I would start to look from here
38:43 - right but I think that that
38:48 - would end up
38:50 - also being kind of long because for
38:52 - every single character in here you would
38:54 - have to iterate through this entire
38:55 - thing and do the whole matching process
38:58 - um
39:00 - and so I'm
39:03 - does that make sense why that's like
39:05 - maybe not the most optimal yeah that
39:07 - makes sense
39:08 - and I guess what would be the runtime of
39:11 - that
39:12 - uh it would be o of N squared because
39:14 - well I guess if we have one sentence o
39:17 - of N and one sentence o of M it would be
39:19 - o of n m because for every single
39:22 - character we'd have to run through the
39:23 - other string
39:26 - um M times and actually
39:28 - okay so like if my base sentence is like
39:31 - like what is the worst thing that can
39:33 - happen is like a base sentence like this
39:36 - right and then you're searching the
39:40 - worst case example would be like
39:42 - something like this right
39:45 - where like if I have an i okay well I
39:47 - have to go through each of these
39:49 - and
39:52 - so yeah I guess we would have to go
39:54 - through until like they don't match
39:55 - anymore but then that would just be the
39:58 - very end of this
40:01 - so like maybe I can add like an a at the
40:03 - end of that
40:04 - so then I would actually okay so that I
40:07 - would say it would
40:10 - it might be o of N squared M where n is
40:15 - e yeah I think that makes sense to me I
40:17 - think that we should come up with a
40:19 - different solution I'm trying to think
40:21 - of how dynamic programming word work
40:23 - because I do think that this this might
40:26 - be a dynamic programming problem
40:30 - um
40:31 - I'm not sure
40:33 - of how to formulate it yes let's um I
40:37 - think that you're on to something here
40:39 - I think
40:42 - I'm trying to think of a good ways to
40:44 - kind of kick you off here
40:46 - um
40:47 - I mean I would say let's just lay out
40:49 - let's assume that this is dynamic
40:51 - programming uh I think as a good
40:54 - starting point maybe we
40:57 - can talk about sub problems here
40:59 - and try to Define that and maybe that
41:01 - will help us get to our solution or also
41:03 - maybe just to find a base case and maybe
41:05 - that will help us get to the solution so
41:06 - I think
41:08 - let's assume that dynamic programming
41:09 - can be used here let's maybe just start
41:11 - trying to figure out sub problems and
41:13 - maybe a base case
41:16 - yeah
41:17 - yeah so I definitely think that the base
41:20 - case would be pretty simple and it would
41:22 - just be if there is a match right
41:24 - between the two like if the two
41:26 - sentences equal another that would be or
41:28 - okay let's think about all the possible
41:30 - base cases so
41:32 - it'd be if there's a match
41:34 - um or maybe we've iterated through
41:36 - everything that we can and we're
41:40 - comparing like an empty string to
41:43 - non-empty or even empty to empty which
41:45 - is when we would know that we're at the
41:47 - very end right
41:49 - yeah so for example with this match I
41:52 - mean by like
41:54 - um read to read like that would be an
41:58 - exact match
42:00 - so I I think the difficulty of this
42:02 - problem is that
42:05 - is that we can start anywhere in the
42:07 - texts right
42:09 - and
42:13 - I guess if we were trying to recurse
42:15 - through this
42:17 - um
42:23 - or if we if we were trying to go through
42:25 - this with dynamic programming
42:28 - what I would kind of want to do is
42:32 - say
42:33 - okay either like
42:39 - like s is the start of some substring in
42:42 - this sentence or it's not
42:45 - right and if it's not then we want to
42:46 - move over and we want to say okay well
42:48 - then is like H is
42:51 - um
42:52 - a substring or the start of a substring
42:55 - from this other sentence or it's not
42:58 - and we want to kind of continue that
43:00 - process
43:02 - um and so if for example H is a
43:05 - substring then we would want to figure
43:08 - out what the longest
43:10 - substring
43:12 - longest matching one is and then that
43:14 - would essentially like skip us over a
43:16 - few yep a few uh blocks
43:20 - and so I think another way to kind of
43:23 - formulate this might actually be
43:27 - like how many
43:31 - how many characters can kind of almost
43:33 - subtract
43:35 - from the two
43:38 - um
43:40 - and I might uh I might jump in here just
43:43 - I think you're on the right track but I
43:45 - might provide a little bit maybe more of
43:47 - a launching point just because I want to
43:48 - be considerate of our our time here
43:51 - um I think you're on the right track
43:53 - I think that let's maybe try to Define
43:56 - this like with a single line expression
43:59 - like a single line recurrence type
44:01 - expression
44:04 - um because I think that if we can build
44:06 - up to a you know build up sub problems
44:08 - to that final state that will help us
44:11 - so
44:12 - let's say we have sections of text a
44:16 - and I'll put this in uh CR with a is one
44:19 - of our sections of text
44:22 - and b is another one of our sections of
44:25 - text
44:27 - um
44:28 - and basically that could be
44:31 - uh hello world or something you know in
44:34 - world
44:36 - uh
44:38 - just world or something like that
44:40 - um we can assume that yeah basically
44:44 - what we could start doing here is we can
44:46 - imagine that we wanted to find the
44:49 - longest match between a and b
44:52 - and you could Define that as from
44:55 - character index 0 to character index
44:59 - 0 here so like the longest common
45:03 - subsequence here or substring of a b 0 0
45:09 - would be our
45:12 - kind of goal State because we would want
45:14 - to find if we're working backwards let's
45:17 - say we want to find all the way
45:19 - to the beginning
45:22 - but to help us get there
45:24 - you know we could probably see if uh you
45:27 - know what is the longest substring at
45:30 - different indexes so if you know maybe
45:32 - index three
45:33 - index five so like this would be the I
45:36 - guess last character five would be like
45:38 - the last character of B
45:39 - and I I guess keeping this in mind can
45:42 - we Define this in such a way where we
45:43 - maybe we can uh define an equation that
45:46 - would help us work up to that final goal
45:49 - which would be the entire
45:52 - sequence
45:55 - okay so if we're using kind of these a b
45:58 - strings as example
46:00 - um
46:02 - let's define some like
46:05 - like find
46:07 - uh largest
46:10 - substring or something
46:13 - um
46:13 - and we might have string a string B
46:19 - right so
46:21 - and you're saying okay let's do index a
46:24 - and index b as well and start those off
46:27 - with zero that would be our recurrence
46:29 - relation and so
46:31 - I guess what we'd want to do is find the
46:34 - longest substring between
46:37 - yep these
46:40 - um and we want to increment yep one or
46:44 - the other
46:47 - yep
46:49 - right
46:51 - so like that
46:54 - uh
46:57 - or
47:01 - or if
47:03 - string a equals string B then what we'd
47:07 - want to do is find the longest substring
47:13 - um
47:15 - um
47:17 - we want to increment both of these
47:19 - indices apparently oops sorry so I meant
47:21 - string a at
47:23 - index a and string B at index B like
47:28 - this so then we'd want to increment both
47:30 - of the indices and we want to add one
47:35 - right because this means that we've
47:38 - found a starting match
47:43 - um
47:45 - and what we'd want to do is actually
47:47 - take the so here
47:52 - um
47:54 - and if you want to just write pseudocode
47:55 - here it's fine too for me possibility
47:59 - okay that makes sense to me
48:04 - yeah so let's just do all these
48:06 - possibilities and so then if the two
48:08 - then we have this like third possibility
48:11 - right
48:12 - and what I would want to do is uh take
48:16 - kind of the minimum
48:17 - why is this giving me an error
48:20 - oh so then I would want I would want to
48:23 - return the max of
48:26 - possibility one possibility two okay
48:29 - let's write pseudo code
48:33 - possibility one possibility to and then
48:35 - possibility three only if it makes sense
48:38 - to me if applicable
48:43 - and
48:45 - and then with our base case we said that
48:48 - it would be if one of them is at the end
48:50 - so let me add that in here
48:53 - so maybe like if uh idx a is equal to
48:57 - the length of string a then we want to
49:01 - return zero
49:03 - or or here or idxb is equal to the
49:07 - length of string B
49:11 - um
49:12 - yeah so then for our longest substring
49:15 - this makes sense now because
49:17 - with each index we have the possibility
49:20 - of Shifting it over one and trying to
49:23 - compare this sentence with this entire
49:26 - one
49:27 - uh or
49:31 - Shifting the other one over one
49:33 - comparing those two
49:36 - yep indices or those two substrings
49:39 - from there on
49:41 - or if they are a match then we also have
49:43 - the third option of moving both of them
49:45 - over so actually I should go from here
49:48 - and then because uh this fine longest
49:52 - substring repeats all that on the next
49:55 - character for those two then we repeat
49:57 - that process again and we add one every
49:59 - single time to that
50:02 - um
50:04 - so I think logically this makes sense
50:07 - now
50:09 - one thing might also be that we start to
50:11 - kind of uh recurse a lot on the same
50:15 - indices right because we're trying all
50:17 - these different combinations and if we
50:18 - move them both over by one then
50:21 - um
50:22 - then we kind of are iterating overthrew
50:25 - them a lot
50:27 - so I think that one thing that we could
50:28 - also do is Implement some sort of
50:30 - memoization
50:33 - so here
50:36 - like maybe
50:38 - hold on I lost the oh here we go okay so
50:43 - then
50:44 - like
50:48 - if I
50:52 - so if
50:53 - the memorization is is none then we
50:58 - might want to start this with some sort
51:00 - of
51:02 - uh it could be addiction I think that
51:04 - also what could make sense is like a
51:07 - list of lists
51:09 - right
51:11 - so like maybe negative one because
51:12 - there's no such thing as a negative
51:15 - one-length substring
51:17 - um
51:18 - and I'm gonna multiply that by the
51:20 - length of like string a for example yep
51:23 - and then this whole thing by the length
51:25 - of string B
51:27 - and so essentially I have this table of
51:29 - [Music]
51:33 - of
51:35 - yeah
51:38 - I always get confused with the direction
51:40 - of these things but I understand the
51:42 - goal of this length string a and length
51:44 - string they basically create a table
51:45 - that stores some of these values
51:48 - yeah
51:49 - exactly yeah yeah and then in order to
51:52 - store that here then we would want to
51:55 - create like the index a
51:58 - index B I might be these might be
52:01 - backwards but we would want to store
52:03 - that essentially and so
52:06 - um then we'd want to add a case of like
52:09 - if
52:10 - uh
52:14 - if like this memo yeah
52:17 - at index a index B these might be
52:22 - backwards again if that's negative one
52:24 - then we want to return or sorry if
52:28 - that's not negative one then that means
52:30 - that we've already found the answer so
52:32 - then we just want to return whatever
52:35 - memorize there
52:40 - um and so at the very end we'd want to
52:43 - just return memo
52:47 - like that and
52:49 - let me just think about these indices
52:51 - quickly so uh the first one is string B
52:56 - so actually if I just swap these two
52:57 - that should make it work
53:00 - uh because first we'd index in 2A and
53:02 - then we'd index into B yep so yeah yeah
53:05 - if I just swap those two that would work
53:06 - cool um uh yeah this makes sense to me I
53:09 - guess my last question I think that this
53:11 - is the approach that I was uh uh kind of
53:14 - thinking about as far as dynamic
53:15 - programming goes my last question is
53:17 - what would be the run time of this
53:21 - um you know memoized uh dynamic
53:23 - programming solution
53:30 - um
53:31 - okay so here we are going through all of
53:35 - index a or all all string a and all of
53:38 - string B right by incrementing these
53:40 - indices until we hit a base case
53:43 - so
53:46 - so there's no way to avoid going through
53:50 - both of them
53:53 - um and and incrementing one but not the
53:56 - other and so we essentially have to fill
53:57 - out this entire memoization table in
53:59 - order to figure out our answer right yep
54:01 - which means that it would be a benefit
54:03 - and then my last question I know we're
54:04 - running right up on time is I guess
54:08 - given the context of the original
54:09 - problem was you might have a library of
54:11 - books how would you leverage this find
54:13 - commas longest substring to I guess find
54:17 - the two most uh like the highest
54:19 - probability matches in the entire uh
54:22 - library of books
54:28 - um I think that so here now that we have
54:31 - this find the longest substring with
54:33 - string a string B and we have all we
54:36 - have so we let's suppose that we changed
54:38 - uh
54:39 - the implementation of this book to be
54:42 - this like long string of characters for
54:44 - the content then that means that what we
54:48 - can do for this fine longest substring
54:49 - is just pass in like
54:51 - book a DOT content and book b dot
54:54 - content and figure out the longest
54:56 - substring between the two of them and we
54:58 - can do that for all the combinations of
55:00 - books
55:01 - um unique combinations of books and
55:04 - if we find for example
55:07 - okay well so the prompt is to detect the
55:09 - two most likely books that have
55:11 - plagiarism so we would just return the
55:13 - two books with the longest substring
55:15 - but you know maybe we want to say like
55:19 - any any books where more than 30 of the
55:24 - care you know more than 30 of the book
55:26 - is uh or maybe even like ten percent
55:30 - um shares the same substrate and like we
55:32 - might call that majorism uh that's all I
55:35 - have thank you uh
55:37 - for your time I guess quickly if you
55:39 - have any questions I guess for me or any
55:41 - questions about these prompts before I
55:43 - uh head off
55:46 - okay so note to the audience that in a
55:50 - normal interview this would be a time
55:53 - when I would dive deeper and ask
55:54 - questions about
55:56 - um you know Keith's work or what you
56:00 - know he enjoys about the company
56:02 - um and if I
56:04 - you'll find something in one of his
56:06 - answers that I'm really interested in
56:07 - I'll dive into that a little bit more
56:10 - but because this is just a fake
56:12 - interview and I don't really have any
56:14 - questions about Keith's company because
56:15 - the company doesn't exist
56:18 - um yep that makes sense to me and I I
56:19 - did not give you any context really to
56:21 - work with here so we don't have to
56:23 - repeat what we did with uh the video
56:25 - that posted on my channel but cool
56:27 - that's where we can interview uh switch
56:31 - gears
56:32 - yeah all right so now let's switch over
56:34 - to the feedback section uh session
56:37 - um do you want to go through your notes
56:38 - and kind of just share what was good
56:41 - yeah it was bad your overall impression
56:43 - I think this was an interesting session
56:44 - because
56:45 - I like wanted to squeeze as much as
56:47 - possible into this like oftentimes you
56:49 - might see like a smaller fully
56:51 - object-oriented design or a smaller uh
56:54 - only algorithms but I kind of wanted to
56:56 - get both because ultimately from my
56:58 - perspective as an interviewer like I
57:00 - feel like having both Concepts is how I
57:02 - actually evaluate your programming
57:04 - skills because a single algorithm
57:06 - doesn't tell me that much as far as
57:09 - um your your actual talents and like if
57:12 - you'd be a productive member of our team
57:13 - and also the object-oriented design
57:15 - might not say everything either so I
57:17 - like the combination but it was a bit
57:19 - like it is a lot of information so
57:22 - feedback wise let's start with object
57:23 - oriented design I think solid overall I
57:28 - think that you hit like the key points
57:30 - um
57:31 - I think some of the things that I I'm
57:33 - thinking about with regards to your
57:35 - solution is
57:38 - you hit all of like the key things that
57:40 - I was looking for so like all books in
57:42 - library remember active book remember
57:44 - last page in all books display a page in
57:46 - action book I think you did a good job
57:48 - with like the basic class structure to
57:50 - capture all of that I think what I would
57:52 - have liked to see if I was to be like
57:54 - nitpicky and and looking for even better
57:57 - Solutions is I might look for even
57:59 - further breakdown of classes so like I
58:03 - think
58:04 - um there was some things that could have
58:06 - been broken down further where I think
58:08 - maybe you could have a display class
58:09 - even that could kind of separate the the
58:13 - details like you have the book class
58:15 - that has the title the content but then
58:17 - the display class can handle like the
58:19 - font sizes the characters per page all
58:21 - that and just isolate that functionality
58:25 - um yeah so that was like one thing that
58:27 - I picked up on is just I think that it's
58:29 - tricky in an interview setting but I
58:31 - think that to isolate different
58:33 - components and make it easier to fit all
58:35 - together I think further breakdown of
58:37 - these classes could have been beneficial
58:40 - um and then my other kind of like
58:42 - nitpicky comment in criticism would be
58:44 - like I think
58:46 - the the way that the IDS were structured
58:49 - wasn't
58:51 - um
58:53 - necessarily like the the most easy to
58:56 - understand
58:57 - uh so I guess providing some more
58:59 - details on
59:01 - I guess adding robustness to these IDs I
59:04 - think like one thing that would have
59:05 - been interesting I guess it didn't ask
59:07 - about this specifically but
59:10 - um
59:12 - the concept of like okay how could you
59:14 - then maybe if you only had a title in
59:16 - the the book contents how could you
59:19 - maybe grab that ID retroactively or like
59:22 - would you want to do that so like maybe
59:24 - some more robustness in how the IDS were
59:26 - set up
59:27 - so that
59:28 - uh you didn't have to have know the
59:30 - system to necessarily get an ID
59:33 - um does that make sense
59:39 - yeah yeah for sure I definitely think
59:41 - that the ID part was
59:43 - one thing where it was yeah
59:46 - like I would have rather just used the
59:48 - title of the book or like some
59:49 - combination of like the title and author
59:51 - and I think like for example
59:54 - um
59:55 - at like an actual Library they have like
59:57 - their code or whatever and they have
59:59 - their system for you know if it's
60:01 - fiction or whatever genre it is and then
60:03 - like uh some combination of I think
60:06 - author that
60:08 - I don't really remember
60:10 - um that they use to ID books and I think
60:12 - that that probably would have been like
60:14 - a better solution is if we had like the
60:16 - title and author and yeah it is tricky
60:18 - because you don't have access to that
60:19 - nice Library I think the key thing that
60:21 - you did well with the IDS is that you
60:23 - knew that had to be unique you didn't
60:25 - want to have collisions and by
60:27 - mentioning like titles might have
60:29 - collisions that's super important
60:30 - because that would cause all sorts of
60:32 - headaches for us
60:34 - um let me see what else I wrote down I
60:38 - mean again like I'll reiterate like this
60:39 - was a good solution this was a solid
60:41 - solution this would be like something
60:42 - I'm looking for so like my feedback is
60:45 - more nitpicky and like how could things
60:46 - be improved further I think another way
60:49 - and this is kind of similar to breaking
60:50 - things out from you know a book class
60:54 - and then a display class to actually put
60:56 - that onto our Kindle Cloud Reader but I
60:59 - think another way you could have maybe
61:00 - broke this down in a logical manner was
61:02 - when I asked that last follow-up
61:03 - question which was basically
61:05 - you know you might have many users in
61:07 - this and now we need to be able to each
61:11 - user needs to have their own like last
61:13 - page for each book and all that
61:15 - I think that your answer could have been
61:16 - a bit more
61:19 - nuanced there
61:21 - I think one thing that you could have
61:23 - maybe mentioned is
61:25 - we could have potentially used like
61:26 - super classic subclassing to maybe have
61:28 - like you know a base book class but
61:31 - maybe there was like a user book class
61:32 - that built off of
61:34 - that class book that you know everyone
61:36 - shared ID everyone shared title everyone
61:38 - shared content but all those user
61:40 - specific things could have reused some
61:42 - of that previous code but built off of
61:44 - it so that would have been an
61:45 - interesting idea too
61:48 - yeah yeah
61:50 - that's all I have for the yeah object
61:53 - oriented
61:55 - um portion uh any I guess other comments
61:58 - on that section
62:03 - cool and then I think for algorithm
62:05 - solution
62:07 - um I think throughout the interview you
62:09 - did a good job of explaining your
62:11 - thoughts super super important to anyone
62:13 - listening to this uh don't just write
62:15 - something down
62:16 - talk through what you're writing down as
62:19 - you're writing it that helps me make
62:21 - sure that I know what you're talking
62:23 - about that makes sure that I know that
62:25 - you're on the right track or off track
62:26 - so you did a good job both in the
62:28 - object-oriented design as well as the
62:31 - algorithm just explaining what you are
62:33 - thinking and the pros and cons so like
62:36 - one thing I liked in the algorithm
62:37 - section is
62:39 - you know coming up with a very naive
62:41 - solution to start I like seeing that
62:44 - kind of iterative approach see that
62:46 - you're kind of working towards more
62:47 - Optimal Solutions so I liked the idea of
62:50 - using like every single substring and
62:51 - these two but then realizing this is not
62:53 - optimal I liked then you're kind of
62:57 - building and taking that and being like
62:58 - okay maybe that's not the best approach
63:00 - but let's take a base sentence and a you
63:02 - know a new sentence
63:03 - and
63:05 - uh you know start going character by
63:08 - character in the base sentence and
63:09 - compare it to the you know comparison
63:11 - sentence I think that that was you know
63:13 - a you know you're working towards a
63:15 - better solution it's going to be better
63:16 - than that every substring approach but
63:19 - still not quite optimal and kind of
63:20 - realizing that there was more
63:22 - improvements that could be made there
63:24 - was a challenge in how to get to the
63:26 - dynamic programming solution I think we
63:27 - maybe lost some of those details you
63:29 - would normally have included on like the
63:31 - Nuance of this and how you might
63:33 - improve it so like I would have also
63:35 - liked to hear mention not only of herb
63:37 - tense but also like punctuation if we
63:39 - have to you know keep that in mind so if
63:41 - someone changed periods exclamation
63:42 - points should those still match or
63:44 - should they not match
63:46 - all of that
63:48 - um and then just kind of getting to the
63:50 - dynamic programming uh I think this was
63:53 - definitely like a challenge trying to
63:54 - figure out how to formulate this so I
63:56 - definitely had to help a bit more I
63:58 - think in an optimal like perfect run
64:00 - through uh you would have had
64:02 - you've gotten a little bit further
64:04 - without me having to prod but I think
64:06 - the nature of dynamic programming is
64:08 - unless you're reviewing it and like
64:09 - really like studying it and staying on
64:11 - top of it like in the real world you
64:13 - don't have to know this type of stuff uh
64:16 - you're not coming up and like designing
64:18 - from scratch dynamic programming you're
64:20 - usually looking at notes and all that so
64:22 - like I was you know I'm okay in an
64:23 - interview setting having to prod a bit
64:25 - uh but you know that's I guess the
64:27 - difference between a good interview and
64:29 - a perfect interview is like the nature
64:31 - is I had to provide a decent amount of
64:33 - details and kind of help you get to a
64:34 - recurrence and then once I gave you that
64:37 - starting point the launching point of
64:39 - the recurrence uh you did a great job
64:41 - running with it that was definitely like
64:42 - the optimal longest common subsequence
64:45 - or substring type solution with
64:48 - recursion and memoization to help get us
64:52 - to the optimal so it was nice to see
64:54 - that once you had an idea of what we
64:56 - needed to do
64:57 - that your Rams will run with it and knew
64:58 - exactly you know where you could
65:00 - Implement an optimal solution
65:03 - I think that's all I have I'm rambling
65:05 - on a bit but hopefully those notes make
65:08 - sense and I think we can further discuss
65:12 - yeah I definitely think think that this
65:14 - longest substring was a slightly more
65:17 - challenging problem based on like
65:20 - um you know the problems I've done on
65:22 - the code or like the ones that I faced
65:24 - in like actual coding interviews
65:26 - um but that's not to say that it's not
65:28 - like
65:29 - a good problem right I think it's a
65:31 - really good problem to ask and to kind
65:33 - of figure out
65:35 - um you know what are my strengths and
65:37 - weaknesses and I think that one thing
65:40 - that
65:42 - you know you've probably learned from
65:43 - this is that okay you know maybe I have
65:46 - certain ideas that are there and I like
65:48 - needed a little push in trying to
65:50 - formulate it properly but then once you
65:54 - gave me just like a structure to
65:56 - formulate it then I was able to take
65:58 - that and be able to uh run with it right
66:02 - which I think that
66:04 - you know from an interviewer's
66:05 - standpoint like when you're interviewing
66:08 - it's not just about can they do it or
66:11 - not it's also about how would they you
66:12 - know how would what would an interaction
66:14 - with this person look like right and so
66:17 - actually one thing that I really liked
66:18 - about this was that it it seemed to be
66:20 - pretty collaborative and it seemed to be
66:22 - very casual rather than like me taking a
66:25 - test
66:27 - um and so
66:29 - you know what that tells me as somebody
66:32 - interviewing is oh yeah like if I do get
66:35 - stuck like this person would be able to
66:37 - give me a hint and then I would be able
66:39 - to take that hint and do the rest of the
66:42 - problem
66:44 - um
66:45 - so yeah I mean I do wish that I was able
66:47 - to just get that in formulated but I
66:50 - think that also dynamic programming is
66:52 - typically tricky like that and it takes
66:54 - a lot of it just takes practice kind of
66:57 - to yeah and I think that you make a good
66:59 - point where it's like this was
67:01 - definitely the dynamic programming
67:03 - question was a hard question uh and I
67:07 - think sometimes once you feel like
67:09 - you're off track and an interviewer like
67:11 - oh shoot I don't know the answer to this
67:12 - like I'm screwed I think realize that
67:14 - you might be purposely given a hard
67:16 - question because then you can identify a
67:19 - larger range of candidates so like you
67:21 - know maybe the tippy top is like it's
67:24 - it's instinctual for them to like
67:25 - realize how to solve this with dynamic
67:28 - programming but I'd say like the strong
67:30 - half of this they won't know it right
67:33 - away but they'll be able to work
67:34 - themselves to it so like don't get too
67:37 - flustered this is not to you this is to
67:39 - a general comment to anyone listening
67:41 - don't get too flustered by like getting
67:43 - stuck you're oftentimes expected to get
67:45 - stuck uh you're human so you're going to
67:49 - get stuck it's how you rebound it and I
67:51 - think you did a good job mentioning you
67:52 - know you rebounded well and and that's
67:55 - what's important still like a very
67:57 - strong interview because you were able
68:00 - to work to the solution and it was a
68:01 - hard problem
68:03 - yeah I will also mention I think one
68:06 - other thing that a lot of interviewers
68:07 - do tend to look for is probably testing
68:09 - so I do think that
68:12 - um yeah you know it's a good it's a good
68:15 - signal you know we were running out of
68:16 - time but I think
68:18 - um
68:18 - for both the for the interviewer it's a
68:21 - good signal if the interviewee brings up
68:23 - testing and says oh like you know I like
68:26 - the solution but in order to verify my
68:28 - answer I would like to test it or I'd
68:29 - like to run it or something like that
68:32 - um and I think with in terms of
68:35 - what the interviewer is looking for is
68:38 - that they want you they want to see that
68:41 - you're going to be a good software
68:42 - engineer right and I think testing is a
68:44 - big part of that equation and so I think
68:47 - that
68:48 - um
68:49 - I think that just mentioning maybe hey
68:51 - like these are a few cases that I would
68:53 - have ran through if I had extra time or
68:56 - you know here are some of the edge cases
68:58 - like I think this might work for most
69:00 - cases but there might be some sort of
69:02 - edge case here and there that I should
69:03 - have like gone through
69:05 - um I think those would be yeah that's a
69:07 - great that that should also be a
69:09 - component that
69:11 - testing is super important so seeing
69:14 - that and it is challenging because we
69:16 - did kind of run out of time so like I
69:17 - feel like you didn't hit some of those
69:18 - things that you probably would have hit
69:19 - if we had all the time in the world one
69:21 - thing that's interesting I saw this on
69:24 - Twitter or LinkedIn as an idea I don't
69:27 - know what your thoughts are on it I
69:28 - think that it's a pretty solid idea I
69:30 - would kind of be impressed if a
69:31 - candidate did this
69:32 - but I could see it going either way is
69:34 - the someone mentioned they were like a a
69:38 - um data analyst at Google
69:40 - and in the interview process like they
69:42 - screwed up I think a couple queries a
69:44 - SQL queries and after the interview they
69:47 - like
69:48 - you know calm down like they collected
69:50 - their thoughts and they like emailed the
69:52 - interview interviewee interviewer like
69:55 - the solutions like oh like I goofed up
69:57 - there this is how I would have solved it
69:59 - if I you know had a little bit more time
70:00 - they followed up with like some
70:02 - solutions so it'd be interesting I don't
70:04 - know if you think it would be a good
70:05 - idea or a bad idea I could see it going
70:07 - over either way but to like follow up
70:10 - and be like oh I didn't get a mention
70:13 - these testing cases this is what I would
70:15 - have done uh I think it's probably
70:18 - situation specific because
70:20 - it could be kind of weird too I don't
70:23 - know I'm just throwing that out there as
70:24 - an interesting Avenue if you feel like
70:26 - you
70:27 - wanted to redeem a bad interview or
70:29 - something like that and like have some
70:31 - Saving Grace
70:33 - yeah well I definitely I definitely do
70:36 - think that that is
70:39 - like I don't think it's necessarily I
70:41 - don't think it would be a bad idea under
70:43 - any circumstance I think that okay maybe
70:46 - your interviewer would never see that
70:48 - and they find it a little bit strange or
70:49 - maybe they've already submitted there
70:50 - whatever but I don't think it can hurt
70:54 - um and if anything I think it shows
70:57 - dedication and it shows that you know
71:00 - you couldn't solve this problem
71:03 - but you took time and you thought about
71:05 - it some more and you didn't give up and
71:08 - then you did come up with the right
71:09 - solution and you followed up and
71:11 - communicated that yeah
71:13 - I think it yeah it's situation depended
71:15 - if I feel like my interview went great I
71:18 - probably wouldn't need feel like the
71:19 - need to do that but if I feel like oh
71:21 - shoot that was like I was I'm so much
71:23 - better than that
71:24 - at that point it can't hurt to do
71:25 - something like that and just keep it
71:27 - casual keep it like yeah hey I thought
71:29 - of this thanks again for your time yeah
71:31 - uh take care like uh
71:34 - okay so now after the interview I just
71:36 - wanted to follow up with you guys that
71:39 - interview if I walked away from it I
71:40 - would have been like all right well
71:41 - there are certain aspects that you know
71:44 - just like Keith said there are certain
71:45 - aspects that
71:47 - signaled you know I was probably a
71:49 - strong candidate but I personally would
71:52 - have walked away from that being like
71:53 - dang there are some parts that I
71:55 - probably could have done better on like
71:57 - I needed his help a little bit I
71:59 - probably could have you know eventually
72:01 - gotten if I just had a bit more time to
72:02 - think or maybe today was just not my day
72:05 - and that's just sometimes how these
72:07 - interviews go you can't do perfectly on
72:09 - all of them now a few notes about my
72:11 - implementation specifically I use
72:13 - pseudocode because Keith the interviewer
72:16 - specifically said it was okay too and in
72:19 - this specific problem I really wanted to
72:21 - focus on the algorithm and not really
72:22 - kind of get
72:24 - uh you know get into the syntax of
72:27 - things and so for me uh python is almost
72:30 - basically pseudocode so most of it was
72:32 - very pythonic
72:34 - um but I come to doll out because I was
72:37 - too lazy to get that Max part working
72:39 - because I wrote like possibility three
72:41 - if applicable and I was just a little
72:44 - bit too lazy to like actually
72:46 - yeah Implement that and then also there
72:49 - was some underlining that just wouldn't
72:51 - go away and that was really bothering me
72:52 - so that's why I also just turned it to
72:54 - uh an entire comment
72:57 - now some things to remember about
72:59 - interviewing in general so don't be
73:02 - scared to ask questions turn the
73:04 - interview more into a conversation
73:05 - because that also gives the interviewer
73:07 - a signal of this is what I'm like as a
73:09 - teammate this is what it's going to feel
73:11 - like when you're working with me
73:13 - now during the interview I would always
73:17 - recommend repeating the question to the
73:19 - interviewer just so that uh you can
73:22 - check if you actually understood the
73:24 - question and then from there maybe even
73:25 - ask clarifying questions
73:28 - um and I typically start with something
73:30 - known as the naive solution which is
73:33 - this this is the first thing that I
73:35 - thought of and this solution would work
73:37 - but it's kind of this uh very Brute
73:41 - Force solution where it might take a lot
73:44 - of time and it might not work you know
73:46 - in my time out for these super long
73:48 - strings or these super long data files
73:51 - or this very large array or something
73:54 - like that so it's very very unoptimal
73:57 - but you know it is a solution
74:01 - and then from there that's when I start
74:03 - brainstorming okay well this sucks in
74:05 - terms of timing so let's figure out how
74:08 - we can optimize it so that we can make
74:10 - it run faster and from there if you can
74:12 - find the optimal solution then you
74:15 - implement it the best way and you are
74:18 - good to go
74:19 - all right thank you guys for watching
74:21 - today uh best of luck if any of you have
74:23 - software interviews coming up you know
74:25 - be confident

Cleaned transcript:

are you ready to Ace your next technical programming interview in this video Keith Galley conducts a mock fulllength realworld coding technical interview with Kylie Ying for a software engineering role learn how to use object oriented programming and dynamic programming to solve questions and get the job you want most people will probably agree that one of the worst Parts about finding a job as a software engineer is the technical interview during these programming related interviews the interviewer will expect you to work to a solution optimize it and write code or pseudocode on the spot the reasoning Behind these interviews is that they will help the interviewer understand your ability to understand the problem ask questions go deeper and optimize the solution how much do you understand data structures and algorithms and ultimately what is your coding level and what is your coding ability today I paired up with a good friend of mine Keith Galley who has a data science focused YouTube channel and he is going to be mock interviewing me so this interview might look like what a real software engineering interview looks like I don't know what question he's going to ask so it's going to be as much of a surprise to me as it is to you and I will be coating on the spot so here we go welcome to the interview how are you doing today I'm good how are you I'm doing pretty well um we're gonna probably just jump right into this interview I'm just curious are you familiar with coderpad because that's what we're going to be using throughout I think it might be easiest to kind of share code yeah cool all right so we're going to kind of just jump right into the the problem so for the purpose of this problem and let me share I just want to make sure you can access this coder link so I'm going to share this and I recommend maybe sharing your screen or I guess we also can just work off of this so I should be able to see here what you typed in I open the chat I can click on this link and it'll take me to the coder pad my name is Kylie and I will enter and so I can see that you're in this coder PAD as well and then here I am yeah and just to make sure that you're comfortable here you want to just run like a couple simple lines of code you can try just running this print hello world if you want yeah so if I run this it'll say that I ran a line of python it prints out hello world so I think it works perfect okay so let's uh kind of jump into the problem so just to give you some context we're going to start with about 20 minutes of design objectoriented design however you want to design this code and then we'll spend probably the last 20 minutes working on more of an algorithms question so that gives you just a little bit of a scope uh you don't necessarily have to accomplish everything you know I know that we have limited time but to kind of give you the context of the problem imagine that where designing a book system so an online Cloud reading application and you can pretty much imagine that we're building a product that is similar to an Amazon Kindle but specifically for short stories so we're kind of in our own Niche they might be Indie stories they might not be you know found anywhere else people could add their own stories um and basically what we want to do to start this problem off is that we need help designing the actual application we needed help designing the code that could Implement an online Cloud reading application and there's a couple things that we're looking for and this is very openended you can implement this how you want but a few things and I'll paste these into the coder pad that we're looking for I'll just paste it below um oh yeah okay you can fix this up and I'll delete that Top Line okay so a few things that you're looking for users have a library of books that they can add to or remove from users can set a book from their Library as active um the reading application remembers where a user left off in a given book and the reading application only displays a page of text at a time in the app in the active book exactly awesome um so so let's see essentially what we want to do is create a library where users can interact with this Library they can look at a book and set it as active and then this application will also just remember where they left off and display whatever page that they're currently looking at in the active book is that correct correct correct okay and then more specifically do you want me to kind of give like a high level implementation or um how do you want me to start this so I really want to just think about you know what components would be important this is I would say an objectoriented design question so I'm just thinking about how you would think about structuring uh I guess the base of a program like this so obviously we're not going to build this full application but I'm really curious about how you're structuring that kind of that core structure that core um Foundation right so let me make this uh smaller over on this end so people can see all this and let's type up some more notes so uh the things that jump out to me are that you need to be able to remember all books so if I type this we need to have all books in the library and we need to um remember active book and then we want to remember page uh remember page I guess last pages in all books and then we want to display a page in active book Okay so um by this all books in the library is that more so I guess how are we representing these books are we are they just like strings do they have a page number and then the string of text how is that formatted is it like HTML I think it's up to you how you want to um store the books within like this programming structure so you can kind of decide what makes sense for that I think the important things is the actual text of the book as well as the title of the book okay okay and and you can implement the uh the details of like the pages and all of that yeah yeah okay so I think that there's two things that jump out to me here right it's we need one class we want one class representing a book and then we want another class perhaps representing a library so a collection of books and so in this uh book specifically you just mentioned that we want the title as well as the like pages in the book yep or like I could rename that the content yep exactly um in the book and then for the library we have a collection of books and then I would also argue that this page uh or sorry that whatever the active book is would would be at the library level because um because we just want to toggle which one is active amongst this entire group right yeah and then actually so this last page in the book what I want I think I'm gonna put that under the book because it's book specific so I think it would make sense for every single book to just remember the last page so um user looked at okay so I like how this is represented and then I think uh kind of diving more so into the implementation I think for the title A String would make sense here because I mean a title is just a string yeah um the pages and the content in the book so the things here are the pages are ordered right when you go through a book They're ordered and there's a specific amount of content per page and so I think something that would make sense for this is just a list because I think a list is ordered it's a collection of items and um and we can't I mean I think like a set you would lose the ordering a dictionary you would lose the ordering and you would also over complicate things a little bit you could have the page numbers as the keys but then um but then a list would also do the same thing but kind of in a more elegant manner and then finally uh a tuple okay you could also have a tuple but um I don't think there's a reason to use like a tuple over a list in this specific example yep or like vice versa like I I think that you could choose from either one so I think here I'm just gonna use a list of um I guess strings which represent per page so like each string represents whatever's on an entire page and then the last page that the user looked at this would just be some integer and this would be an index into this list of strings so I would have to remember that this you know there might be an off by one error here um because in Python we start at zero but like naturally when we're reading a book we might start at one yep now for this library for this collection of books okay well so for this active book um I you could either use a Boolean where you set one book to active and the rest to inactive but I think that that would be kind of excessive because every single time we toggle a book as active we have to toggle everything else as inactive right you can't have two active books yeah yeah okay yeah that makes sense okay so then I think in that case instead what I would rather do is have some sort of um a string or some sort of like an ID matching system where we have like one um variable that's set to the active book and that might be the title or the ID of a certain book in the library so maybe maybe we can just add ID here um and maybe I can make that also a string or an integer or something yep and I'm going to add a question mark to kind of just say like maybe we could Implement that but I'm not sure if we'd want to right now um so this would correspond to ID so uh this would just be some variable and then this collection of books so I guess like when we display this page in an active book um I actually so I think that this week this might have an advantage being like some sort of a lookup table because we have a certain sense of an ID right and I think what could make sense here is having the ID correspond to the book object that we Define up here so yeah this could be a book object right and so um we don't really need this idea I think that if all the titles are unique then then we don't need this ID we can just we can just use the titles as the IDS uh but in some cases in the real world not all titles are unique and so that's what an ID might might come in handy um and so I'll leave that like what are our assumptions here can we assume that the titles are unique or should I be using this ID structure I think I like the ID structure because yeah we're not necessarily going to know that everything's unique so I think this is a little bit more robust okay awesome so I think um this representation looks good to me so I'm just going to go through uh the requirements again just to make sure that I've covered all my bases so here I want all books um okay so I want a library books that I can add to or remove from and so here I have a library and anytime I want to add to this Library I can just add an ID I can add the book If I want to remove um from the from the library then I can just simply delete the key item pair or the key whatever pair key value pair um I can set a book from their Library as active and so here I have this active book and we could always say like if there is no active book then we set this To None or something like that um the reading application remembers where a user left off so we have that here right the last page that the user looked at and not just in the active book and then um displaying one page of text at a time in the active book so we have the active book we can get the book object from that and then we can go to the page that the user last looked at by indexing this value into this list so I think we've covered all the bases here cool um let's do a couple things I guess I think as a starting point and this doesn't have to get too crazy but I would love to just see some you know python pseudocode or even some python kind of code just to like maybe flesh out one of these classes I just want to yeah uh you know look at that a little bit and how you would actually start writing this code yeah sure so so for example here I let's start with the book um and when we define a class let's initialize this so when we initialize a book we definitely should pass in the title and then um the content right I'm assuming that when we add a book these things have to be given to us and then I'm assuming that when we add a book we don't have a last page that the user has looked at is that an okay assumption yeah I like that assumption okay so we can set the title of this book just equal to whatever the title is uh the content of this book and I'm going to assume that these are given to us in the formatting that we want so the title is a string and the content is a list of strings that correspond to the pages um and I'm gonna create a variable last page and I'm going to set that equal to just zero I could also probably set it equal to negative one or something but I think zero makes sense because that would be the beginning right yep and um and then we need to come up with some sort of an ID so typically maybe we would have some sort of function that takes in the title and the content or maybe the author or something and like returns a unique ID um but I think maybe something that we can do here just very simply is uh have some sort of counter in the library and then every single time we like at add a new book we can just associate that counter with that book and so then we know that they're all unique and um and they all have their own IDs would that make sense yeah that that makes sense okay so then I would have to pass in the ID um yeah and so what I'm actually going to do is self.id equals ID uh and then yeah and so then uh for example we might want like a display page right in this book and so for that then we just want to return um whatever is at the last page of the content and I guess let's build on this a little bit another useful function you know obviously you want to start at the the last page but let's say we're starting to turn the page what might that look like right and so if we're turning the page then all we want to do is increment the last page right and so we might do self.last page and we just increment that by one um and then we could call display page after that uh if we assume that like we could if if we assume that these two go together so if we assume that when we turn the page we want to display that page then I would just return display page yep like that um and then actually I'm just going to go ahead and code up this Library as well so this Library we have this collection of books and then also the active book so rather than initializing a library with books I think let's just add them um to this so initially this collection might just be an empty dictionary and then the active book might be none right so then um when we want to add stuff so add to collection a book what I'm going to do so there's either the user could like or our API could like return a book with the uh with the title and the content Etc but since we're we said that we would pass the ID through like the library because we might have like a counter like some sort of ID counter I mean this is not the best way to do it but I think this is like a a fine hack for right now um just to make all the ideas unique what we can do here is um we can also when we want to add a book just pass in the title and the content and so then our new book is going to be a book as we've defined above with the ID and um the title and the count or the content and then after we create this new book we want to increment the ID counter uh and then we also want to add this new book Into The Collection right so I'm going to add self.collection um and I'm going to make the ID whatever the ID of the book is so actually I'm just going to call new book dot ID because I think that's a bit cleaner and this is going to be the new book and then we increment the counter by one so this is us adding to the collection um so of course we want to remove from the collection and so we want we said that we wanted to remove based on the ID so all we have to do is I think there's this delete in Python I'm not sure do you know keys okay is there a remove I think that there's I mean it should auto complete here in the coder pad oh isn't it Dell isn't there a Dell um I mean I think the biggest thing is is it going to be happening in place or is it going to be happening and creating a copy um I I understand yeah so we want it in place from The Collection I understand what you're trying to do so the exact details is is not super super important to me okay yeah so anyways this is removing from The Collection um and when we set active book again we want to do this based on the ID so I'm going to make self.active book equal to whatever that ID is uh and let's see so the user has a library of books they can add or remove from we did that sending a book as active Okay and then remembering where user left off so we've actually taken care of that already implicitly in our um book uh class and then the reading application only displays a page of text at a time all right so then here we can say Define display page and actually we don't even need the the ID of the book because we already have the active book ID right and so what I'm going to do is I'm going to go into my collection um and I'm gonna get the active book like this so yep blah blah and I'm going to click or I'm going to do dot display okay and then of course we also have this turn page that I could um to put up as well yep so you get the idea but so we wanted oops turn that page um I do think that some like drawbacks here are that uh okay so one thing that we could have done is instead of this active book instead of saving the ID we could have saved the book itself and I think from a pythonic standpoint that might make sense but then in the future if we're using some sort of database or something an ID would make more sense because that's easier to store in like a table um and if uh and okay also for this display page you might see that we've called this display page and turn page up here in the book and the reason why I did that rather than um rather than just call like self.book.content last page like book dot last page or something was because I think that like for example this should be independent of how we implement the book right so we want to keep those as kind of block like separate blocks as possible and so here what this allows me to do is when I go back to my book like if I decide to scrap this implementation Implement something else I know that I would just have to implement the methods display page and turn page for that to work um and like these functions should work this this looks good to me I like the start I think that this uh definitely lays out the foundation of what I was looking for with the requirements of this application so nice work with this couple quick followup questions before we kind of Branch into more of an algorithms uh type question as the followup here one question is you know let's say you have an older reader and their vision isn't as great so they need to make this the size of the font bigger so kind of keeping that in mind that you might have this variable font size how might you I guess refactor or change or modify your current structure and you don't have to actually write code here let's just discuss this to account for um that increase in size yeah yeah so I so when we increase something in size like I'm just thinking about intuitively on our like phone screens or something um that type that tends to shift the content right so like some page that might hold a hundred words or a hundred characters at you know um a small font size might only hold 50 if when you double that font size so uh for the book instead of having this list what I might do is I might just save the entire book as a string and um and based so I would let me just edit this in here because I think it's easier to visualize what I'm saying but so I would might I might have like a font size equal to um I guess we could just use like the traditional like 12.5 or like yeah whatever uh but when we have this font size we could come up with some sort of um characters per page calculation right and so that would be based off the font size so calculate so this is going to be pseudocode now this calculate doesn't actually exist but calculate uh based on that font size um and I'm commenting it out so it doesn't have any errors but then uh when we do calculate that then what we can do in order to get our um in order to get this display page thing would be instead of indexing into this content which is now just a long string of characters what we can do here is we can return um we would have to do some sort of calculation right so we would need to we have this characters per page and we can multiply that by whatever the last page is and um so this would give us like kind of the starting index of this long string of characters to start uh the content of that page start index would be this and then what we would want to do is um what we want to do is then return the self doc content from that start index until the start index plus the number of characters on that page so that would be our end index so actually let me just write that out to make things a little bit more clear so now essentially what I've done is we have this variable font size which we can calculate characters per page depending on that font size so that might be more characters or less characters depending on how big the font size is and then our content instead of a list of strings is now just a really long string of characters and I guess some assumptions that I'm making here are that uh this would just be approximate so for example if we had a backslash n which is like a line break right that might just end up counting as a character or two characters but the assumption is that um that would be approximate per page or maybe that we're using sort of some sort of like mono spaced font or something like that um but essentially now that we have the characters per page and then just a long stream of characters that represents the content we can index into that content depending on like based on the last page that we know and so what's really cool here is that when we do Turn the Page uh we can just end up calling this so this is kind of that granularity that I was talking about yeah that that makes a lot of sense to me and definitely you see the advantage of having that function that you can change by having to implement something different uh one last quick I guess followup and then we'll we'll move on to the algorithms portion of this interview um I'm just trying to think you know at a high level let's say that we wanted we had multiple users in this system and they all shared books so like you know they might all share the Harry Potter books or something like that like books are common among all of them how might you modify this yeah uh given that you know some of these qualities of a book might be shared between users because they're all trying to access that same book does that make sense yeah so um yeah yeah for sure so I I think that when we start to you know have like multiple people um involved like this this these books might get stored somewhere for example in like a sequel table right and so then when that happens we would still want to maybe store like the ID the title the content in that table now the only changes would be that the these sort of customizations are um are per user but the book and the content those are for this entire group of people and what we can do I think is um is instead of this ID counter being like Library specific we can start identifying books by their IDs on a more like uh global scale right and so you know this was kind of just a hack to make this ID thing work and be independent and be like unique but for example when you put something into a SQL table you can also have an ID associated with those entries and so maybe when we add to the collection if we see that the title and the content is already in the table then we instead just return the book that's already in that table or something like that yeah okay I think that makes sense to me uh cool I I'm yeah happy with this discussion I think that we can move on to the second portion I guess do you have any I guess last questions on this before I move on or last things you want to say um yeah so no last questions I think that the last thing I want to say is also like it would really depend on like how you implement this like group of people right like so my immediate thought was like a SQL table but that doesn't have to be the only way um so yeah I think okay cool I think it would depend on that um all right awesome uh let's yeah switch gears and I'm probably going to just comment this out in case you do want to run some code and there's any errors or issues in this so I'm just going to comment this out but I'm going to leave it here just so we have it to look back at and I'm going to just indent this a bunch and we're going to just start at the top of the screen so don't mind all the stuff at the bottom all right so another important component of our book reading system and this is completely independent you don't have to reference any of your past code is I mentioned this is for short stories and you could have independent Indie authors you know adding these short stories so they're not going to be you know the classics not going to be those types of titles they're probably smaller authors so one thing that we want to avoid in this system is plagiarism so my task for you is to design an algorithm that would be able to detect the two most likely books that would have plagiarism in them it's like that the the two most likely books that pop up as a match for potential plagiarism uh in this in a library and we can Define as we can Define most likely as meaning they have the longest shared common section of text so we're looking we have a library of books and we're looking for the two that have the longest shared common section of text and we specifically might want to know how many characters that section of text is so you can imagine if it's sharing a single word obviously not an issue but if it's sharing six paragraphs that's going to be a problem so does that make sense right so just to clarify some things what Keith really means here by substring is that for example if I have a string such as learn what are substrings of this well one possible substring is learn another possible is earn because these are strings that are using characters that belong to this string learning another possible one is earning oops now you might say Okay Kylie all of these are consecutive in terms of the characters so here all of these correspond as characters that are next to each other but in this specific example Keith is not actually asking okay it has to be a consecutive substring instead what Keith is asking is just any substring which means that as long as the letters are in the correct sequence you can skip characters if you want to so for example here leg would actually also be a substring or an so for example right here we have earn as a substring of consecutive characters but down here I could rewrite it as a substring where there's actually a gap of two characters in the middle but this would still be a valid substring so it doesn't have to be consecutive we just need all the characters to be in order from left to right let's see let's start off with kind of a naive solution for that um well one thing that you could do is literally come up with every single combination of like substrings for both of these uh and then compare those and see which two substrings are the longest right um but there's a lot of different combinations for substrings and so I think that we should come up with a more elegant solution um let's see so one thing that I'm thinking is we should have pointers that start at the beginning of both yep strings and kind of move along until one of them detects a shared character so or like when until one of them takes like the first shared character so here actually like I would say the first shared character is H right um and so here we would have like like the two pointers kind of be this uh maybe I'll go from the bottom but here and here right and so we look at the next character and we realize okay they're not the same so then we want to keep going um but one downside of this is that well okay what if I want to start comparing from here and here right okay and then I move it over and like these two have like two shared characters so I think that there's still this question of there's a lot of different combinations here um so I think you're on the right track though I like I like this and then okay so far yeah okay um yeah so I know that here I want kind of these pointers that are moving and then I just want to be able to align them right I think that's the that's the key here is this alignment and so now I think we just have to figure out how to make that alignment work um I'm kind of thinking like like one thing that we could do is kind of have more of a base sentence and then one where when we have like so for example if I if I made this my base sentence then in the other sentence I would want to search this sentence uh for each character so if I have the I here then like my first I would start looking from here and then maybe I would start to look from here right but I think that that would end up also being kind of long because for every single character in here you would have to iterate through this entire thing and do the whole matching process um and so I'm does that make sense why that's like maybe not the most optimal yeah that makes sense and I guess what would be the runtime of that uh it would be o of N squared because well I guess if we have one sentence o of N and one sentence o of M it would be o of n m because for every single character we'd have to run through the other string um M times and actually okay so like if my base sentence is like like what is the worst thing that can happen is like a base sentence like this right and then you're searching the worst case example would be like something like this right where like if I have an i okay well I have to go through each of these and so yeah I guess we would have to go through until like they don't match anymore but then that would just be the very end of this so like maybe I can add like an a at the end of that so then I would actually okay so that I would say it would it might be o of N squared M where n is e yeah I think that makes sense to me I think that we should come up with a different solution I'm trying to think of how dynamic programming word work because I do think that this this might be a dynamic programming problem um I'm not sure of how to formulate it yes let's um I think that you're on to something here I think I'm trying to think of a good ways to kind of kick you off here um I mean I would say let's just lay out let's assume that this is dynamic programming uh I think as a good starting point maybe we can talk about sub problems here and try to Define that and maybe that will help us get to our solution or also maybe just to find a base case and maybe that will help us get to the solution so I think let's assume that dynamic programming can be used here let's maybe just start trying to figure out sub problems and maybe a base case yeah yeah so I definitely think that the base case would be pretty simple and it would just be if there is a match right between the two like if the two sentences equal another that would be or okay let's think about all the possible base cases so it'd be if there's a match um or maybe we've iterated through everything that we can and we're comparing like an empty string to nonempty or even empty to empty which is when we would know that we're at the very end right yeah so for example with this match I mean by like um read to read like that would be an exact match so I I think the difficulty of this problem is that is that we can start anywhere in the texts right and I guess if we were trying to recurse through this um or if we if we were trying to go through this with dynamic programming what I would kind of want to do is say okay either like like s is the start of some substring in this sentence or it's not right and if it's not then we want to move over and we want to say okay well then is like H is um a substring or the start of a substring from this other sentence or it's not and we want to kind of continue that process um and so if for example H is a substring then we would want to figure out what the longest substring longest matching one is and then that would essentially like skip us over a few yep a few uh blocks and so I think another way to kind of formulate this might actually be like how many how many characters can kind of almost subtract from the two um and I might uh I might jump in here just I think you're on the right track but I might provide a little bit maybe more of a launching point just because I want to be considerate of our our time here um I think you're on the right track I think that let's maybe try to Define this like with a single line expression like a single line recurrence type expression um because I think that if we can build up to a you know build up sub problems to that final state that will help us so let's say we have sections of text a and I'll put this in uh CR with a is one of our sections of text and b is another one of our sections of text um and basically that could be uh hello world or something you know in world uh just world or something like that um we can assume that yeah basically what we could start doing here is we can imagine that we wanted to find the longest match between a and b and you could Define that as from character index 0 to character index 0 here so like the longest common subsequence here or substring of a b 0 0 would be our kind of goal State because we would want to find if we're working backwards let's say we want to find all the way to the beginning but to help us get there you know we could probably see if uh you know what is the longest substring at different indexes so if you know maybe index three index five so like this would be the I guess last character five would be like the last character of B and I I guess keeping this in mind can we Define this in such a way where we maybe we can uh define an equation that would help us work up to that final goal which would be the entire sequence okay so if we're using kind of these a b strings as example um let's define some like like find uh largest substring or something um and we might have string a string B right so and you're saying okay let's do index a and index b as well and start those off with zero that would be our recurrence relation and so I guess what we'd want to do is find the longest substring between yep these um and we want to increment yep one or the other yep right so like that uh or or if string a equals string B then what we'd want to do is find the longest substring um um we want to increment both of these indices apparently oops sorry so I meant string a at index a and string B at index B like this so then we'd want to increment both of the indices and we want to add one right because this means that we've found a starting match um and what we'd want to do is actually take the so here um and if you want to just write pseudocode here it's fine too for me possibility okay that makes sense to me yeah so let's just do all these possibilities and so then if the two then we have this like third possibility right and what I would want to do is uh take kind of the minimum why is this giving me an error oh so then I would want I would want to return the max of possibility one possibility two okay let's write pseudo code possibility one possibility to and then possibility three only if it makes sense to me if applicable and and then with our base case we said that it would be if one of them is at the end so let me add that in here so maybe like if uh idx a is equal to the length of string a then we want to return zero or or here or idxb is equal to the length of string B um yeah so then for our longest substring this makes sense now because with each index we have the possibility of Shifting it over one and trying to compare this sentence with this entire one uh or Shifting the other one over one comparing those two yep indices or those two substrings from there on or if they are a match then we also have the third option of moving both of them over so actually I should go from here and then because uh this fine longest substring repeats all that on the next character for those two then we repeat that process again and we add one every single time to that um so I think logically this makes sense now one thing might also be that we start to kind of uh recurse a lot on the same indices right because we're trying all these different combinations and if we move them both over by one then um then we kind of are iterating overthrew them a lot so I think that one thing that we could also do is Implement some sort of memoization so here like maybe hold on I lost the oh here we go okay so then like if I so if the memorization is is none then we might want to start this with some sort of uh it could be addiction I think that also what could make sense is like a list of lists right so like maybe negative one because there's no such thing as a negative onelength substring um and I'm gonna multiply that by the length of like string a for example yep and then this whole thing by the length of string B and so essentially I have this table of of yeah I always get confused with the direction of these things but I understand the goal of this length string a and length string they basically create a table that stores some of these values yeah exactly yeah yeah and then in order to store that here then we would want to create like the index a index B I might be these might be backwards but we would want to store that essentially and so um then we'd want to add a case of like if uh if like this memo yeah at index a index B these might be backwards again if that's negative one then we want to return or sorry if that's not negative one then that means that we've already found the answer so then we just want to return whatever memorize there um and so at the very end we'd want to just return memo like that and let me just think about these indices quickly so uh the first one is string B so actually if I just swap these two that should make it work uh because first we'd index in 2A and then we'd index into B yep so yeah yeah if I just swap those two that would work cool um uh yeah this makes sense to me I guess my last question I think that this is the approach that I was uh uh kind of thinking about as far as dynamic programming goes my last question is what would be the run time of this um you know memoized uh dynamic programming solution um okay so here we are going through all of index a or all all string a and all of string B right by incrementing these indices until we hit a base case so so there's no way to avoid going through both of them um and and incrementing one but not the other and so we essentially have to fill out this entire memoization table in order to figure out our answer right yep which means that it would be a benefit and then my last question I know we're running right up on time is I guess given the context of the original problem was you might have a library of books how would you leverage this find commas longest substring to I guess find the two most uh like the highest probability matches in the entire uh library of books um I think that so here now that we have this find the longest substring with string a string B and we have all we have so we let's suppose that we changed uh the implementation of this book to be this like long string of characters for the content then that means that what we can do for this fine longest substring is just pass in like book a DOT content and book b dot content and figure out the longest substring between the two of them and we can do that for all the combinations of books um unique combinations of books and if we find for example okay well so the prompt is to detect the two most likely books that have plagiarism so we would just return the two books with the longest substring but you know maybe we want to say like any any books where more than 30 of the care you know more than 30 of the book is uh or maybe even like ten percent um shares the same substrate and like we might call that majorism uh that's all I have thank you uh for your time I guess quickly if you have any questions I guess for me or any questions about these prompts before I uh head off okay so note to the audience that in a normal interview this would be a time when I would dive deeper and ask questions about um you know Keith's work or what you know he enjoys about the company um and if I you'll find something in one of his answers that I'm really interested in I'll dive into that a little bit more but because this is just a fake interview and I don't really have any questions about Keith's company because the company doesn't exist um yep that makes sense to me and I I did not give you any context really to work with here so we don't have to repeat what we did with uh the video that posted on my channel but cool that's where we can interview uh switch gears yeah all right so now let's switch over to the feedback section uh session um do you want to go through your notes and kind of just share what was good yeah it was bad your overall impression I think this was an interesting session because I like wanted to squeeze as much as possible into this like oftentimes you might see like a smaller fully objectoriented design or a smaller uh only algorithms but I kind of wanted to get both because ultimately from my perspective as an interviewer like I feel like having both Concepts is how I actually evaluate your programming skills because a single algorithm doesn't tell me that much as far as um your your actual talents and like if you'd be a productive member of our team and also the objectoriented design might not say everything either so I like the combination but it was a bit like it is a lot of information so feedback wise let's start with object oriented design I think solid overall I think that you hit like the key points um I think some of the things that I I'm thinking about with regards to your solution is you hit all of like the key things that I was looking for so like all books in library remember active book remember last page in all books display a page in action book I think you did a good job with like the basic class structure to capture all of that I think what I would have liked to see if I was to be like nitpicky and and looking for even better Solutions is I might look for even further breakdown of classes so like I think um there was some things that could have been broken down further where I think maybe you could have a display class even that could kind of separate the the details like you have the book class that has the title the content but then the display class can handle like the font sizes the characters per page all that and just isolate that functionality um yeah so that was like one thing that I picked up on is just I think that it's tricky in an interview setting but I think that to isolate different components and make it easier to fit all together I think further breakdown of these classes could have been beneficial um and then my other kind of like nitpicky comment in criticism would be like I think the the way that the IDS were structured wasn't um necessarily like the the most easy to understand uh so I guess providing some more details on I guess adding robustness to these IDs I think like one thing that would have been interesting I guess it didn't ask about this specifically but um the concept of like okay how could you then maybe if you only had a title in the the book contents how could you maybe grab that ID retroactively or like would you want to do that so like maybe some more robustness in how the IDS were set up so that uh you didn't have to have know the system to necessarily get an ID um does that make sense yeah yeah for sure I definitely think that the ID part was one thing where it was yeah like I would have rather just used the title of the book or like some combination of like the title and author and I think like for example um at like an actual Library they have like their code or whatever and they have their system for you know if it's fiction or whatever genre it is and then like uh some combination of I think author that I don't really remember um that they use to ID books and I think that that probably would have been like a better solution is if we had like the title and author and yeah it is tricky because you don't have access to that nice Library I think the key thing that you did well with the IDS is that you knew that had to be unique you didn't want to have collisions and by mentioning like titles might have collisions that's super important because that would cause all sorts of headaches for us um let me see what else I wrote down I mean again like I'll reiterate like this was a good solution this was a solid solution this would be like something I'm looking for so like my feedback is more nitpicky and like how could things be improved further I think another way and this is kind of similar to breaking things out from you know a book class and then a display class to actually put that onto our Kindle Cloud Reader but I think another way you could have maybe broke this down in a logical manner was when I asked that last followup question which was basically you know you might have many users in this and now we need to be able to each user needs to have their own like last page for each book and all that I think that your answer could have been a bit more nuanced there I think one thing that you could have maybe mentioned is we could have potentially used like super classic subclassing to maybe have like you know a base book class but maybe there was like a user book class that built off of that class book that you know everyone shared ID everyone shared title everyone shared content but all those user specific things could have reused some of that previous code but built off of it so that would have been an interesting idea too yeah yeah that's all I have for the yeah object oriented um portion uh any I guess other comments on that section cool and then I think for algorithm solution um I think throughout the interview you did a good job of explaining your thoughts super super important to anyone listening to this uh don't just write something down talk through what you're writing down as you're writing it that helps me make sure that I know what you're talking about that makes sure that I know that you're on the right track or off track so you did a good job both in the objectoriented design as well as the algorithm just explaining what you are thinking and the pros and cons so like one thing I liked in the algorithm section is you know coming up with a very naive solution to start I like seeing that kind of iterative approach see that you're kind of working towards more Optimal Solutions so I liked the idea of using like every single substring and these two but then realizing this is not optimal I liked then you're kind of building and taking that and being like okay maybe that's not the best approach but let's take a base sentence and a you know a new sentence and uh you know start going character by character in the base sentence and compare it to the you know comparison sentence I think that that was you know a you know you're working towards a better solution it's going to be better than that every substring approach but still not quite optimal and kind of realizing that there was more improvements that could be made there was a challenge in how to get to the dynamic programming solution I think we maybe lost some of those details you would normally have included on like the Nuance of this and how you might improve it so like I would have also liked to hear mention not only of herb tense but also like punctuation if we have to you know keep that in mind so if someone changed periods exclamation points should those still match or should they not match all of that um and then just kind of getting to the dynamic programming uh I think this was definitely like a challenge trying to figure out how to formulate this so I definitely had to help a bit more I think in an optimal like perfect run through uh you would have had you've gotten a little bit further without me having to prod but I think the nature of dynamic programming is unless you're reviewing it and like really like studying it and staying on top of it like in the real world you don't have to know this type of stuff uh you're not coming up and like designing from scratch dynamic programming you're usually looking at notes and all that so like I was you know I'm okay in an interview setting having to prod a bit uh but you know that's I guess the difference between a good interview and a perfect interview is like the nature is I had to provide a decent amount of details and kind of help you get to a recurrence and then once I gave you that starting point the launching point of the recurrence uh you did a great job running with it that was definitely like the optimal longest common subsequence or substring type solution with recursion and memoization to help get us to the optimal so it was nice to see that once you had an idea of what we needed to do that your Rams will run with it and knew exactly you know where you could Implement an optimal solution I think that's all I have I'm rambling on a bit but hopefully those notes make sense and I think we can further discuss yeah I definitely think think that this longest substring was a slightly more challenging problem based on like um you know the problems I've done on the code or like the ones that I faced in like actual coding interviews um but that's not to say that it's not like a good problem right I think it's a really good problem to ask and to kind of figure out um you know what are my strengths and weaknesses and I think that one thing that you know you've probably learned from this is that okay you know maybe I have certain ideas that are there and I like needed a little push in trying to formulate it properly but then once you gave me just like a structure to formulate it then I was able to take that and be able to uh run with it right which I think that you know from an interviewer's standpoint like when you're interviewing it's not just about can they do it or not it's also about how would they you know how would what would an interaction with this person look like right and so actually one thing that I really liked about this was that it it seemed to be pretty collaborative and it seemed to be very casual rather than like me taking a test um and so you know what that tells me as somebody interviewing is oh yeah like if I do get stuck like this person would be able to give me a hint and then I would be able to take that hint and do the rest of the problem um so yeah I mean I do wish that I was able to just get that in formulated but I think that also dynamic programming is typically tricky like that and it takes a lot of it just takes practice kind of to yeah and I think that you make a good point where it's like this was definitely the dynamic programming question was a hard question uh and I think sometimes once you feel like you're off track and an interviewer like oh shoot I don't know the answer to this like I'm screwed I think realize that you might be purposely given a hard question because then you can identify a larger range of candidates so like you know maybe the tippy top is like it's it's instinctual for them to like realize how to solve this with dynamic programming but I'd say like the strong half of this they won't know it right away but they'll be able to work themselves to it so like don't get too flustered this is not to you this is to a general comment to anyone listening don't get too flustered by like getting stuck you're oftentimes expected to get stuck uh you're human so you're going to get stuck it's how you rebound it and I think you did a good job mentioning you know you rebounded well and and that's what's important still like a very strong interview because you were able to work to the solution and it was a hard problem yeah I will also mention I think one other thing that a lot of interviewers do tend to look for is probably testing so I do think that um yeah you know it's a good it's a good signal you know we were running out of time but I think um for both the for the interviewer it's a good signal if the interviewee brings up testing and says oh like you know I like the solution but in order to verify my answer I would like to test it or I'd like to run it or something like that um and I think with in terms of what the interviewer is looking for is that they want you they want to see that you're going to be a good software engineer right and I think testing is a big part of that equation and so I think that um I think that just mentioning maybe hey like these are a few cases that I would have ran through if I had extra time or you know here are some of the edge cases like I think this might work for most cases but there might be some sort of edge case here and there that I should have like gone through um I think those would be yeah that's a great that that should also be a component that testing is super important so seeing that and it is challenging because we did kind of run out of time so like I feel like you didn't hit some of those things that you probably would have hit if we had all the time in the world one thing that's interesting I saw this on Twitter or LinkedIn as an idea I don't know what your thoughts are on it I think that it's a pretty solid idea I would kind of be impressed if a candidate did this but I could see it going either way is the someone mentioned they were like a a um data analyst at Google and in the interview process like they screwed up I think a couple queries a SQL queries and after the interview they like you know calm down like they collected their thoughts and they like emailed the interview interviewee interviewer like the solutions like oh like I goofed up there this is how I would have solved it if I you know had a little bit more time they followed up with like some solutions so it'd be interesting I don't know if you think it would be a good idea or a bad idea I could see it going over either way but to like follow up and be like oh I didn't get a mention these testing cases this is what I would have done uh I think it's probably situation specific because it could be kind of weird too I don't know I'm just throwing that out there as an interesting Avenue if you feel like you wanted to redeem a bad interview or something like that and like have some Saving Grace yeah well I definitely I definitely do think that that is like I don't think it's necessarily I don't think it would be a bad idea under any circumstance I think that okay maybe your interviewer would never see that and they find it a little bit strange or maybe they've already submitted there whatever but I don't think it can hurt um and if anything I think it shows dedication and it shows that you know you couldn't solve this problem but you took time and you thought about it some more and you didn't give up and then you did come up with the right solution and you followed up and communicated that yeah I think it yeah it's situation depended if I feel like my interview went great I probably wouldn't need feel like the need to do that but if I feel like oh shoot that was like I was I'm so much better than that at that point it can't hurt to do something like that and just keep it casual keep it like yeah hey I thought of this thanks again for your time yeah uh take care like uh okay so now after the interview I just wanted to follow up with you guys that interview if I walked away from it I would have been like all right well there are certain aspects that you know just like Keith said there are certain aspects that signaled you know I was probably a strong candidate but I personally would have walked away from that being like dang there are some parts that I probably could have done better on like I needed his help a little bit I probably could have you know eventually gotten if I just had a bit more time to think or maybe today was just not my day and that's just sometimes how these interviews go you can't do perfectly on all of them now a few notes about my implementation specifically I use pseudocode because Keith the interviewer specifically said it was okay too and in this specific problem I really wanted to focus on the algorithm and not really kind of get uh you know get into the syntax of things and so for me uh python is almost basically pseudocode so most of it was very pythonic um but I come to doll out because I was too lazy to get that Max part working because I wrote like possibility three if applicable and I was just a little bit too lazy to like actually yeah Implement that and then also there was some underlining that just wouldn't go away and that was really bothering me so that's why I also just turned it to uh an entire comment now some things to remember about interviewing in general so don't be scared to ask questions turn the interview more into a conversation because that also gives the interviewer a signal of this is what I'm like as a teammate this is what it's going to feel like when you're working with me now during the interview I would always recommend repeating the question to the interviewer just so that uh you can check if you actually understood the question and then from there maybe even ask clarifying questions um and I typically start with something known as the naive solution which is this this is the first thing that I thought of and this solution would work but it's kind of this uh very Brute Force solution where it might take a lot of time and it might not work you know in my time out for these super long strings or these super long data files or this very large array or something like that so it's very very unoptimal but you know it is a solution and then from there that's when I start brainstorming okay well this sucks in terms of timing so let's figure out how we can optimize it so that we can make it run faster and from there if you can find the optimal solution then you implement it the best way and you are good to go all right thank you guys for watching today uh best of luck if any of you have software interviews coming up you know be confident
