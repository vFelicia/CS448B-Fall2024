With timestamps:

00:00 - welcome to this rust programming course
00:02 - for beginners this comprehensive course
00:04 - will guide you step by step through the
00:06 - fundamentals of rust enabling you to
00:09 - build robust and efficient applications
00:10 - from understanding basic syntax and data
00:13 - types to exploring more advanced topics
00:16 - like lifetimes and closures arfan zubi
00:19 - will provide clear explanations and
00:21 - Hands-On exercises to ensure you grasp
00:23 - every concept effectively get ready to
00:26 - unlock the power of rust and elevate
00:28 - your programming skills to new heights
00:30 - hi my name is Irfan and I will be your
00:33 - guide in this comprehensive for us
00:35 - course for beginners so if you're
00:38 - interested in learning rust then
00:40 - congratulations you have found the right
00:42 - course
00:43 - so I've designed this course to ensure
00:46 - that you will learn rust the proper way
00:48 - using slides and visuals to illustrate
00:51 - Concepts and providing exercises we will
00:55 - solve together this means you will have
00:57 - an appropriate mix of theory and
01:00 - practice that will help you step by step
01:02 - mastering this new awesome programming
01:05 - language
01:06 - and I strongly advise you to code along
01:09 - because you will learn so much more when
01:12 - actively participating rather than just
01:15 - watching the video
01:16 - so let's Dive In
01:20 - so what are the goals of this course
01:22 - first and foremost getting familiar with
01:25 - Core Concepts and syntax of the language
01:28 - we will take a look at data types and
01:31 - data structures as well as ownership and
01:35 - borrowing we will see how data is
01:37 - allocated in memory and how we access
01:39 - the data and we'll take a look at
01:42 - standard Library generics trades
01:45 - lifetimes and much much more basically
01:48 - everything you need to become a great
01:50 - rust developer
01:54 - so why would you want to learn rust now
01:58 - there would be I guess a thousand
02:00 - reasons but I have here put together
02:03 - some of the main ones now rust is a
02:07 - really fast language in terms of
02:09 - execution time it provides a rich type
02:12 - system it doesn't have a garbage
02:15 - collector which is part of the reason
02:17 - why it's so fast
02:19 - it provides useful compiler outputs and
02:23 - you will see that in the exercises we
02:25 - are solving it guarantees memory safety
02:29 - and it's the most beloved programming
02:31 - language since 2016 according to stack
02:35 - overflow meaning now seven years in a
02:38 - row and we are experiencing fast
02:41 - adoption in various branches
02:45 - foreign
02:46 - now over here you can see a table which
02:49 - shows various programming languages and
02:51 - their score in terms of Energy
02:53 - Efficiency and execution time and as you
02:58 - can see rust is one of the languages on
03:01 - the top of the list
03:04 - now over here are some resources that
03:07 - you can learn with now I guess the main
03:10 - resource would be the RAS programming
03:12 - language
03:13 - really fantastic book and I recommend
03:15 - you to read it then there is rustlings
03:18 - these are small exercises basically
03:21 - programs which you have to debug
03:24 - then there is Ross by example so if your
03:27 - style is more focusing code and less on
03:30 - text then this would be suitable for you
03:34 - and there is a website called rust by
03:37 - practice and that is what we will cover
03:40 - together
03:42 - and if you want to go more advanced
03:44 - there is a book called Russ forestations
03:46 - and it's also very much recommended to
03:50 - eat it
03:54 - so before we dive into the first topic I
03:57 - want to show you the website of lost by
04:00 - practice and you can access it by going
04:03 - to the URL practice dot RS
04:07 - and this is the website
04:11 - and over here as you can see these are
04:14 - all the topics we will cover together
04:17 - right now this will be the first one
04:21 - variables
04:23 - and as you can see over here we have
04:25 - small exercises that we will solve
04:28 - together
04:30 - now before we start I want to show you
04:33 - something else and of course we'll keep
04:36 - up with the tradition and write a hello
04:39 - world program
04:41 - so you can go to the
04:44 - rustlang.org website this is the
04:46 - official website of the rust foundation
04:50 - and you can click over here playground
04:55 - and as you can see over here you can
04:58 - write rascode and then execute it
05:02 - and it's really cool because you even
05:04 - have the Vim key bindings over here and
05:08 - you can even choose themes
05:11 - like that
05:16 - and let's write our first program so
05:22 - every program in Rust starts in the main
05:27 - function this is the starting point of
05:30 - execution of every rust program
05:34 - and we declare functions with the FN
05:37 - keyword
05:38 - so to print out to standard output we
05:41 - can use the print line macro
05:45 - as you can see we write print Ln
05:48 - exclamation mark and then we can provide
05:51 - here the string we want to Output
05:56 - like that
05:59 - and then you can hit run
06:05 - and as you can see we have executed our
06:09 - first program so congratulations I hope
06:13 - you coded along and now we start with
06:17 - the actual course
06:20 - so variables variables are assigned
06:24 - using the LED keyword so if you're
06:26 - coming from a JavaScript background this
06:28 - might seem familiar
06:30 - you can print to standard output by the
06:33 - print or print Ln macros
06:37 - so print and print Ln are basically very
06:41 - much the same but print Ln adds a new
06:44 - line at the end of the output
06:48 - and scope of a variable is defined by
06:52 - the block of code in which it is
06:54 - declared
06:55 - now a function is a named block of code
06:58 - that is reusable
07:01 - and shadowing allows a variable to be
07:03 - redeclared in the same scope with the
07:06 - same name
07:08 - so let's solve some exercises
07:12 - binding and mutability a variable can be
07:16 - used only if it has been initialized
07:20 - fix the arrow below with least amount of
07:23 - modification to the code
07:25 - so again we are starting always in the
07:29 - main function
07:30 - now over here we have two variables
07:34 - and again we declare variables with the
07:37 - let keyword then the name and over here
07:41 - we have a type annotation now don't
07:45 - worry too much for now we'll cover that
07:47 - in the next topic to come but for now
07:50 - think of i32 as an integer type
07:55 - right
07:57 - and then we have here the assert EQ
08:01 - macro which stands for assert equality
08:05 - so this macro takes two arguments and
08:08 - just basically asserts that these two
08:11 - are equal
08:13 - in case they are not equal the program
08:15 - will Panic meaning immediate exiting and
08:20 - returning an error message
08:24 - if there are in fact equal then the
08:27 - program will just continue executing
08:30 - so as you can see we want here that X is
08:33 - equal to a value of 5 so we can
08:37 - initialize X over here with with a value
08:40 - of 5 like that
08:45 - and to run this program you can either
08:48 - click here or you can press Ctrl enter
08:55 - and let's read that over here
08:57 - uninitialized but used error
09:00 - so when you use a variable it has to be
09:04 - initialized with a value which makes
09:06 - sense right you can't use something
09:09 - which isn't initialized yet
09:12 - now y over here is uninitialized but
09:15 - also unused this will only output a
09:19 - warning now over here you can see the
09:22 - warning actually
09:23 - but if I take this code and put it over
09:27 - here
09:30 - as you can see it gives us a warning
09:32 - unused variable y
09:36 - okay to fix that we can prepend it with
09:39 - an underscore
09:42 - like that
09:47 - all right
09:48 - use mute to Mark a variable as mutable
09:52 - so in Rust a variable in its nature is
09:57 - immutable and you have to explicitly
10:00 - state that you want a variable to be
10:02 - mutable
10:04 - so fill the blanks in the code to make
10:06 - it compile as you can see we are here
10:10 - using a variable X so we want over here
10:13 - to declare X and initialize it with a
10:18 - value of 1.
10:20 - now over here we are mutating X which
10:25 - means this variable X over here should
10:28 - be mutable and we do that using the mute
10:31 - keyword like that
10:34 - now this over here
10:37 - is shorthand Syntax for this
10:43 - all right so we take the value of one
10:46 - we add 2 to it and then we assign it
10:50 - back to X meaning X will then hold 3.
10:54 - right now
10:56 - just a quick note I will always try to
11:00 - annotate the type in this course most of
11:03 - the time it's not necessary so when you
11:06 - see me annotating types it's actually
11:09 - not because this is necessary but just
11:13 - because I want to make stuff as clear as
11:16 - possible so in this case this would hold
11:20 - an integer type and again we will cover
11:23 - that in the next topic
11:25 - let's see
11:30 - as you can see this is compiling X is
11:33 - equal to 3.
11:36 - scope a scope is the range within the
11:39 - program for which the item is valid
11:42 - fix the error below with least amount of
11:45 - modification
11:47 - so over here we are initializing the
11:50 - variable x with a value of 10.
11:53 - an integer type all right
11:58 - now
12:01 - now here we have another scope we also
12:04 - can call it the inner scope and this
12:06 - would be the outer scope right so in
12:10 - this scope over here we are declaring
12:12 - another variable y now
12:17 - we over here try to print out X and Y
12:20 - and we can do that by placing inside the
12:25 - print Ln macro these placeholders over
12:28 - here
12:29 - and then providing as additional
12:33 - arguments over here the variables we
12:36 - want to put the values inside here
12:39 - so for example if we provide X over here
12:42 - then this will get replaced by 10
12:46 - because X is holding a value of 10.
12:51 - and as you can see in the outer scope we
12:54 - are doing exactly the same
12:56 - now this program won't compile
13:00 - and the reason is because a variable is
13:05 - only valid inside the scope in which it
13:09 - was declared so for example the variable
13:12 - Y is declared inside the scope meaning
13:17 - T variable Y is only valid until this
13:21 - point
13:23 - all right that means we can't use y here
13:27 - so what would be the solution
13:30 - solution would be very simple we just
13:33 - initialize the variable y in the main
13:37 - scope in the outer scope over here
13:39 - meaning X and Y both of them are valid
13:43 - until this point over here
13:46 - right because this over here is the main
13:50 - scope
13:52 - let's see
13:55 - as you can see this is compiling
14:00 - fix the error with the use of Define X
14:04 - now we can have other functions besides
14:08 - main so over here we have the function
14:10 - define X
14:12 - and as you can see we are initializing a
14:17 - variable X which holds a string
14:20 - now this would be
14:22 - T-Type annotation for a string
14:26 - right don't worry too much about the
14:29 - annotations now because we will cover
14:31 - that but just to let you know now the
14:36 - problem here is that in main we are
14:40 - trying to access X now in this scope
14:43 - over here there is no variable with the
14:46 - name of X which means that this program
14:50 - won't compile because the compiler will
14:53 - tell you I can't find over here a
14:56 - variable with the name of X so what we
14:59 - can do over here is actually taking this
15:02 - line and putting it inside the function
15:05 - over here because as you can see in this
15:08 - scope of the function a variable X has
15:12 - been declared and initialized
15:16 - but if I run this program now
15:21 - nothing will happen
15:23 - and that's because as I've said the
15:26 - starting point of every Ras program is
15:28 - in the main function now
15:31 - when we run the code nothing will get
15:35 - executed
15:36 - and that's because we have to actually
15:39 - call this function for it to do
15:42 - something so in this case
15:45 - we can call a function like that
15:49 - just providing the name of the function
15:52 - and these parentheses
15:58 - and as you can see the output will be
16:01 - hello world right because over here we
16:05 - are
16:06 - providing x to the print line macro and
16:10 - we are appending to it comma world
16:14 - like that
16:17 - shadowing you can declare a new variable
16:20 - with the same name as a previous
16:22 - variable here we can say the first one
16:24 - is shadowed by the second one
16:28 - only modify a sort EQ to make print Line
16:31 - work print 42 in terminal as you can see
16:36 - over here we are initializing the
16:38 - variable X which holds an i32 type
16:42 - an integer type
16:45 - now in this scope over here we are
16:48 - initializing another variable with the
16:52 - same name X but over here we are
16:55 - initializing it with a value of 12
16:57 - instead of 5.
17:00 - and that means when we assert the value
17:04 - of x over here it should actually be 12
17:07 - right
17:09 - now what would be the value of x in this
17:14 - outer scope
17:18 - if you set 5 then you're right
17:21 - because
17:24 - this variable over here has been
17:26 - declared in the main scope in this scope
17:29 - over here that means X is holding a
17:32 - value of 5. now in this scope over here
17:36 - x holds a value of 12.
17:39 - and these are basically two different
17:43 - worlds right so the variable X declared
17:47 - in the main scope doesn't actually care
17:49 - about the variable X declared in this
17:52 - scope over here
17:54 - they are separate
17:56 - now over here we are shadowing X in the
18:01 - main scope meaning we re-declare and
18:04 - re-initialize the variable X again with
18:08 - an integer type
18:11 - now when we output X it should actually
18:14 - print out 42.
18:21 - as you can see this will be the output
18:25 - number six remove a line in the code to
18:28 - make it compile now over here we have a
18:32 - mutable variable X which holds one
18:37 - an integer type then we are assigning 7
18:42 - to X now X holds
18:45 - seven right
18:47 - then we are shadowing and rebinding so
18:50 - we are re-declaring X and
18:53 - re-initializing it and we initialize it
18:56 - with
18:58 - a value of x meaning with 7 right
19:04 - and then over here we are mutating X
19:09 - and that means we are here incrementing
19:13 - x by 3.
19:16 - again using this front end notation
19:18 - which would equate to that
19:22 - and
19:25 - this would actually fail and I want you
19:28 - to look at it and think about it what
19:32 - over here might cause an error
19:37 - so over here as you can see we are
19:40 - re-declaring X
19:42 - and over here we are mutating X now as
19:46 - I've said every variable in Rust is in
19:50 - its nature immutable meaning if we
19:53 - redeclare X like that X will be
19:56 - immutable even if it was mutable over
19:59 - here when we Shadow it then it will be
20:02 - immutable again so what we can do over
20:05 - here is just using
20:08 - the mute keyword again so X stays
20:12 - mutable
20:15 - now
20:18 - you might ask okay why even shadowing we
20:22 - can just assign a new value to X why is
20:25 - this even a thing
20:27 - and you can see that here very good so y
20:32 - over here holds an integer type right
20:36 - integer 4. now when shadowing we can
20:40 - assign to the variable a a value of
20:45 - another type in this case for example a
20:48 - string right so y will then hold a
20:52 - string type
20:56 - right let's run that
20:59 - and as you can see this compiles now
21:02 - this line over here is completely
21:04 - useless I hope you notice that because
21:07 - we are taking X and assign it again to X
21:10 - which basically is the exact same thing
21:13 - as we had over here so completely
21:16 - useless of course they are doing that to
21:19 - learn the concept
21:20 - but in real life you don't need this
21:23 - line all right you can just do it like
21:26 - that
21:27 - and as you can see this also compiles
21:32 - unused variables fix the warning below
21:34 - with only one solution two distinct
21:37 - Solutions so as you can see of course we
21:40 - want two stores so we will do with two
21:44 - solutions
21:45 - now the problem here is that this
21:48 - program won't actually output warnings
21:51 - right so I will again copy that
21:55 - and I will put it
21:59 - and I will put it inside the rust
22:02 - playground
22:04 - like that so if we run this program now
22:10 - as you can see we get a warning unused
22:13 - variable X now I have showed you that
22:16 - before the easiest method would be to
22:19 - prevent the variable name with an
22:21 - underscore
22:23 - as you can see we don't get the warning
22:26 - over here the second way would be to do
22:30 - it like that
22:32 - this is
22:34 - telling the compiler that it should
22:37 - allow
22:40 - unused variables
22:43 - so if you run it again
22:45 - as you can see no warning
22:50 - so we have solved that
22:53 - destructuring we can use pattern with
22:56 - lead to destructure a tuple to separate
22:59 - variables
23:01 - now tuples we will cover that in a later
23:04 - topic
23:05 - but for now just think of tuples as a
23:09 - data structure that can hold
23:13 - um various values even of different
23:16 - types
23:17 - so fix the arrow below with least amount
23:21 - of modification
23:24 - so as you can see over here we have a
23:27 - tuple right holding two integers one and
23:31 - two and this over here is called
23:34 - destructuring so we are using the let
23:37 - keyword and we use this syntax over here
23:41 - to this structure these values into
23:45 - variables X and Y so X will then hold a
23:50 - value of 1 and y will hold a value of 2.
23:53 - now over here we are mutating X
23:58 - now again
23:59 - this variable here would be immutable
24:02 - because in Rust every variable in its
24:05 - nature is immutable and we have to
24:08 - explicitly state that we want to have it
24:11 - mutable
24:12 - so what we can do over here like we did
24:15 - before we use the mute keyword
24:18 - like that and then this should actually
24:22 - compile so X holds one here and then we
24:26 - increment X by two so extrude in the
24:30 - nthole 3 and Y should stay the same as
24:34 - it was
24:39 - and as you can see this is compiling the
24:42 - structuring assignments introduced in
24:45 - Rust 1.59 you can now use Tuple slice
24:49 - and struct patterns as the left hand
24:51 - side of an assignment
24:54 - so this is very useful actually
24:58 - so we can declare two variables at once
25:02 - so here we declare X and Y and this
25:05 - would be the same like writing let X and
25:09 - let y
25:11 - right so you're writing one line of code
25:14 - instead of two lines here
25:21 - now again we declare here the variables
25:24 - and we can then
25:26 - destructure these data structures over
25:30 - here so we have here a tuple and we are
25:33 - destructuring it and notice over here we
25:36 - don't need to use the let keyword again
25:39 - because we have already declared these
25:42 - variables over here
25:44 - right
25:45 - so we assign 3 to X and this value over
25:51 - here we don't care about so we can use
25:54 - these double dots over here
25:57 - now this over here is an array and again
26:01 - we will cover that don't worry and this
26:05 - array holds two values now we don't care
26:08 - about the first one but we want to
26:11 - destructure the second one into a
26:13 - variable called y
26:16 - now fill the blank to make the code work
26:20 - in this case we have here an array right
26:24 - remember assert EQ takes two arguments
26:27 - and both of them have to be the same
26:30 - equate to the same output right so what
26:35 - would be the value of x
26:40 - it would be 3. because we have this
26:43 - structured here 3 into the variable X
26:46 - and the same goes for here we have this
26:49 - structured 2 into a variable Y which
26:54 - means y will then hold two
27:00 - all right and we are done with the first
27:03 - topic easy start and see you next time
27:08 - now let's look at numbers in Rust and
27:11 - we'll start with integer types
27:14 - now an integer is basically a whole
27:17 - number meaning it doesn't have a
27:20 - fractional part
27:22 - and integers can come in two different
27:25 - forms they can either be signed or
27:28 - unsigned now a signed integer can
27:31 - represent both positive and negative
27:34 - numbers
27:35 - and I remember that because signed might
27:38 - stand for the minus sign that could be
27:41 - prepended to it
27:43 - and unsigned integers are always
27:46 - positive integers meaning they don't
27:49 - have a minus sign hence unsigned
27:53 - now integers can come in different
27:56 - lengths so there can be 8-bit integers
28:00 - 16-bit 32 up until
28:04 - 128 bits and each length over here has
28:10 - two distinct types one for signed and
28:15 - one for unsigned so for example if we
28:18 - have a variable which holds an unsigned
28:21 - 8-bit integer we would type annotate
28:24 - that with the type u8
28:27 - or for example we have a signed 64-bit
28:30 - integral we would annotate it as i64.
28:35 - now the last element in the table over
28:38 - here is Arc and Arc stands for
28:41 - architecture now that means that the
28:44 - size of these two types eye size and U
28:47 - size are dependent on the computer's
28:50 - architecture now I guess most of you
28:53 - guys today run computers with 64-bit
28:57 - architecture meaning Isis new size have
29:01 - a size of 64 bits or 8 bytes
29:07 - All Right Now the default types in Rust
29:12 - are for integers i32 and for floats f64
29:17 - so if we don't annotate anything the
29:20 - compiler will infer it to these types
29:26 - now my head is in the way
29:31 - now to make sense of all of this you
29:34 - will have to understand the binary
29:36 - number system
29:38 - now if you're familiar with binary just
29:40 - skip ahead because you don't learn
29:42 - anything new here but I just want to
29:45 - ensure that we are all on the same page
29:48 - so if we consider this decimal number
29:52 - over here 42
29:54 - and let's look at each distinct digit so
30:00 - we would have 4 and we would have two
30:02 - right
30:04 - now 2 would be in the ones place and
30:08 - four would be in the tenths place
30:11 - and if we would have more digits here
30:13 - here would be the hundreds place
30:15 - thousands place and so on
30:18 - now
30:20 - as you can see we are here using a base
30:22 - of 10. why is that because in the
30:26 - decimal system we have 10 distinct
30:29 - digits to represent numbers right 0 to
30:33 - 9. and as you can see we are here doing
30:37 - an exponentiation with an exponent of
30:41 - zero because this is actually a
30:44 - mathematical rule which states that
30:46 - anything with an exponent of 0 will
30:49 - always evaluate to one so it doesn't
30:53 - matter which base you use if you have an
30:56 - exponent of 0 the result will always be
30:59 - one right 10 to the power of 0 would be
31:02 - 1 4 to the power of 0 would be one and
31:05 - so on
31:07 - and over here we have 10 to the power of
31:09 - 1 which would be 10 right and then what
31:13 - we do is just we are multiplying the
31:17 - digits of our number with these
31:21 - exponentiations right so we would for
31:25 - example here 4 times 10 to the power of
31:27 - 1 plus 2 times 10 to the power of 0.
31:32 - now again 10 to the power of 1 would be
31:34 - 10 and 10 to the power of 0 would be one
31:38 - and then we would multiply these numbers
31:41 - together and then add this and we would
31:44 - have 42 right something which is very
31:48 - natural to you and you don't even think
31:50 - about it right because decimal numbers
31:54 - are everywhere now in computers things
31:58 - actually look a little bit different
32:01 - let's for example again consider the
32:03 - decimal number 42 now this would be the
32:07 - binary representation of this number
32:09 - zero zero one zero one zero one zero
32:14 - and as you can see we have here eight
32:18 - digits now a digit is called bit right
32:24 - and a bit is the smallest possible unit
32:27 - of information a computer can hold okay
32:34 - now we have eight bits over here and
32:37 - eight bits make up one byte
32:40 - and we over here have actually the same
32:43 - logic as we did over here but with a
32:46 - base of two because again we can only
32:50 - represent two digits in a computer and
32:54 - that's because a transistor can only be
32:56 - in one of two states either it's
32:59 - conducting electric current or it's
33:02 - non-conducting zero or one
33:06 - right so
33:09 - the logic stays the same here we have 2
33:13 - to the power of 0 which would be one
33:15 - because of the rule we have talked about
33:17 - 2 to the power of 1 would be two two to
33:20 - the power of 2 would be four two to the
33:23 - power of 3 would be eight and so on and
33:25 - as you notice the number here doubles
33:28 - one two four eight sixteen and so on
33:33 - now
33:35 - this over here is actually the
33:37 - fascinating part about computers to me
33:39 - personally because it's just crazy if
33:43 - you think that everything
33:45 - represented this video over here and
33:49 - graphical models and 3D games and
33:52 - everything is stored and represented
33:55 - with only two digits
33:58 - mind-blowing right
34:01 - so
34:02 - we actually here do the same thing we
34:05 - are just multiplying
34:07 - the bits over here with the
34:10 - exponentiations
34:12 - now we won't consider the zero bits
34:16 - because anything multiplied by zero will
34:19 - always be zero right so we are just
34:23 - caring about the one bits over here so
34:26 - we are multiplying one times two to the
34:28 - power of one which would be 2 right
34:32 - because 1 times 2 would be two then one
34:36 - times two to the power of 3 which would
34:38 - equate to 8 and 1 times 2 to the power
34:42 - of 5 which would be 32 as you can see
34:45 - over here and then we are basically just
34:49 - adding these numbers together and we
34:51 - have 42 and this is the way your
34:55 - computer stores all of your data
34:59 - all right
35:00 - now you might ask okay how far can we go
35:05 - with this what would be the largest
35:08 - possible number we can represent
35:11 - and let's for that see the range of
35:13 - 8-bit integers
35:16 - so the smallest possible unsigned 8-bit
35:19 - integer would be zero right I hope this
35:22 - makes sense because if we have a zero in
35:25 - every position over here the result will
35:28 - just be zero right now the largest
35:31 - possible unsigned 8-bit integer would be
35:35 - 255.
35:38 - and that's the case when every single
35:41 - position over here holds A1 right and
35:45 - again we are then just multiplying D1 by
35:49 - the exponentiations over here and add it
35:52 - together
35:54 - and you might now think okay 255 isn't a
35:59 - lot what if I want to represent bigger
36:02 - numbers and there is a simple solution
36:04 - to that
36:05 - you're just adding more bits over here
36:08 - right because the more bits we have the
36:11 - larger number we can represent
36:14 - so let's see for example a 16 bit
36:18 - integer again the smallest possible
36:22 - 16-bit integer unsigned would be zero
36:27 - and this is if every position over here
36:29 - holds zero
36:31 - now the largest possible 16-bit integer
36:34 - unsigned would be 65
36:39 - 535 okay and again this would just be if
36:44 - we had in every single position a one
36:49 - right again just adding the results of
36:53 - the exponentiations over here all
36:56 - together and we would have this result
37:00 - now as you can see the more bits we have
37:03 - the more we can represent
37:07 - now what about signed integers again
37:10 - sine integers can represent negative
37:13 - numbers
37:14 - so signed integers use a concept called
37:19 - tools complement
37:21 - where the processor will take a number
37:25 - over here
37:26 - for example 42 and this would be the
37:29 - binary representation of this number
37:32 - then it will invert this binary number
37:37 - meaning a 0 becomes a 1 and 1 becomes
37:42 - zero right just inverting
37:46 - and then after inverting the number we
37:49 - add one single bit okay so we add one
37:53 - here this would then equate to zero and
37:57 - we have a carry of one
37:59 - and then we add here one and we would
38:03 - have one and the rest says the same now
38:06 - this would then be the binary
38:08 - representation of minus 42.
38:13 - or negative 42. now the most significant
38:17 - bit over here is actually the sine bit
38:20 - if it is zero then it means the number
38:24 - is positive if it is 1 then the number
38:27 - is negative all right
38:30 - and that's why there are distinct types
38:35 - for
38:37 - signed and unsigned
38:40 - and the ranges for signed and unsigned
38:43 - integers vary right
38:52 - and over here we have an illustration
38:55 - just to see the ranges for example for
38:59 - I8 a signed integral of 8 Bits
39:04 - the range would be from
39:06 - -128 to 127.
39:10 - so the smallest possible number we can
39:13 - represent with a signed 8-bit integer
39:16 - would be
39:17 - -128 and the largest one would be 127.
39:23 - and as you can see again the more bits
39:26 - we have
39:27 - the larger and smaller the integer can
39:32 - go
39:33 - right
39:35 - and again unsigned integers never go
39:39 - below zero
39:44 - right then we have view size and eye
39:48 - size so these are as I've said
39:50 - architecture dependent so on a 32-bit
39:54 - architecture computer
39:57 - the size of these view size and eye size
40:00 - type would be 32 bits
40:03 - on a 64-bit architecture it would be 64
40:07 - bits
40:08 - and this is also called pointer sized
40:11 - integer type because it matches the size
40:14 - of a word in a given platform
40:18 - so what is a word you have to understand
40:21 - that the processor does not read one
40:24 - byte at a time from memory it reads one
40:27 - word at a time
40:29 - so in a 32-bit processor it can access
40:32 - four bytes or 32 bits at a time and in a
40:37 - 64-bit processor it can access 8 bytes
40:41 - or 64 bits at a time
40:46 - now if we look at this very simplified
40:49 - representation of computer memory where
40:53 - we have over here addresses and over
40:56 - here the data
40:58 - and
40:59 - each location over here holds data of
41:03 - one byte all right
41:07 - now in a 32-bit architecture the size of
41:11 - a word is four bytes right 32 bits which
41:16 - means that the processor can access 4
41:19 - bytes at a time so the processor will
41:23 - read
41:24 - this section over here as one word right
41:29 - it's basically unit of data and what you
41:34 - have to take from this is this statement
41:36 - over here
41:37 - you size gives you the guarantee to be
41:40 - always big enough to hold any pointer or
41:44 - any offset in a data structure
41:47 - so the U size type
41:50 - can hold memory addresses which can
41:54 - point to any location in computer memory
41:59 - that's very important
42:02 - so let's see floating point there are
42:05 - two types F32 which is of size 32 bits
42:09 - and f64 which is of type 64 bits now the
42:14 - representation of these floats are
42:16 - according to the IEEE 754 specification
42:21 - so let's look at some exercises
42:26 - tips if we don't explicitly assign a
42:28 - type to a variable then the compiler
42:30 - will infer one for us
42:34 - now remove something to make it work
42:40 - as you can see over here we have a
42:42 - variable X which holds an i32
42:46 - integer right
42:48 - now over here we have immutable variable
42:52 - Y which holds an unsigned 32-bit integer
42:57 - right so over here we are trying to
43:00 - assign X to Y now this would actually
43:04 - fail because we can't assign a variable
43:08 - of a type to a variable of another type
43:12 - it's not possible
43:15 - so what we can do over here to fix that
43:18 - is actually just omitting the type and
43:22 - this will then implicitly hold an i32
43:26 - type right because this is the default
43:29 - integer type in Rust
43:33 - now over here we are initializing in
43:36 - another variable set and what would be
43:39 - the type of Z
43:43 - right it would be I 32.
43:47 - all right
43:51 - thank you
43:52 - fill the blank so over here as you can
43:56 - see we have a value 38 which is of type
44:00 - u8 so we can also annotate a type
44:04 - directly on a value
44:07 - meaning this value over here 38 is of
44:11 - type u8 now the problem here is that the
44:15 - variable over here V expects a type of
44:19 - u16
44:21 - so we can't initialize a variable which
44:25 - expects a certain type with another type
44:28 - but what we can do over here is using
44:31 - the as keyword which basically can
44:34 - convert an integer type to another
44:36 - integer type so we can use here s and
44:41 - u16
44:43 - this will then compile
44:49 - tips if we don't explicitly assign a
44:52 - type to a variable then the compiler
44:54 - will infer one for us now we know that
44:57 - already
44:58 - modify a sort EQ to make it work so over
45:02 - here we are initializing the variable x
45:05 - with a value of 5. what would be the
45:08 - type annotation
45:11 - it would be i32 right it's the default
45:15 - integer typing rust now in this assert
45:18 - EQ macro we have here a string u32 we
45:23 - don't worry yet about this method I will
45:26 - explain that in a later episode
45:28 - and on the other side of the assert EQ
45:32 - macro we have a function call so we call
45:36 - type of with an argument of x
45:40 - actually a reference to X but again
45:42 - don't worry we'll cover that
45:45 - so
45:47 - when we call this function over here it
45:50 - basically just gives us back the name of
45:53 - the type
45:55 - so if we pass X over here we would get
45:58 - back
46:00 - i32 right
46:03 - because this variable over here holds a
46:06 - value of type i32 now this boot then
46:11 - actually fail right because we want here
46:14 - that
46:16 - type of X returns u32 so what we can do
46:21 - is just changing this type annotation
46:24 - over here
46:28 - all right fill the blanks to make it
46:31 - work now over here we have a data type
46:34 - for example I8 and the constant Max now
46:38 - Max just Returns the largest possible
46:43 - number that can be represented with the
46:48 - mentioned data type so for example I8
46:52 - Max would be
46:54 - 127. right this would be an assigned
46:58 - 8-bit integer and we have seen the
47:01 - ranges
47:02 - now the max for an unsigned 8-bit
47:04 - integral would be 255.
47:09 - all right
47:14 - fix arrows and panics to make it work
47:17 - now over here we have a value 251 which
47:22 - is of type u8 and we add 8 to it now in
47:28 - this case the compiler will infer the
47:31 - types so this would be 8
47:35 - and the variable itself will hold them
47:39 - u8
47:40 - now can you spot the problem over here
47:46 - the problem is we have seen that u8 can
47:50 - only represent up to
47:53 - 255 right so over here we would have
47:58 - 259 so this is not possible
48:03 - so what we can do over here is just
48:06 - changing that to the next
48:08 - bigger data type for example u16
48:14 - now then we have here a data type I8
48:18 - assigned 8-bit integer and we call the
48:22 - checked add method now this is actually
48:26 - the same as doing it like that but in a
48:29 - safer way because we have to handle the
48:32 - error
48:34 - and unwrap over here we will cover that
48:38 - so
48:40 - this
48:42 - is actually a little bit safer but it
48:45 - still will panic because again the I8
48:48 - cannot represent
48:50 - 259 it would be an overflow so again we
48:55 - can over here just say we want an i16
49:00 - because an i16 can without problems
49:02 - represent 259.
49:06 - so V1 will then hold u16
49:10 - and V2 will hold i16
49:14 - . again I'm just doing this for clarity
49:16 - you don't have to annotate the types
49:21 - alright modify assert to make it work
49:25 - now as you can see over here we have
49:28 - numbers
49:30 - in different representations or
49:34 - basically in different number systems so
49:36 - this is decimal this is hexadecimal this
49:40 - is octal and this is binary okay
49:43 - now
49:46 - the decimal over here has an underscore
49:48 - and this is just a delimiter so this is
49:52 - just for readability it doesn't affect
49:55 - the actual value
49:58 - now let me convert that over here we
50:01 - would have 2024
50:05 - this is already in decimal system then
50:09 - over here we would have 255
50:12 - then over here we would have 63 and then
50:15 - over here I hope you remember this would
50:18 - be
50:19 - 255. now if we calculate this
50:27 - as you can see the result would be this
50:30 - value over here
50:38 - like that and this basically proves that
50:42 - in Rusty you can
50:44 - perform mathematical operations on
50:48 - different
50:49 - number systems right
50:56 - now floating Point fill the blank to
50:58 - make it work as you can see over here we
51:01 - have a floating point value so what
51:04 - would be the type
51:07 - I will annotate it directly so it would
51:10 - be f64 this is the default floating
51:13 - Point type right
51:16 - now over here we have an F 32
51:21 - and over here we have an F 64.
51:25 - right
51:29 - like that again type annotations are not
51:32 - necessary now if we pass x to the type
51:37 - of function over here what would be the
51:41 - return value
51:44 - it would be f64 right
51:52 - make it work in two distinct ways so if
51:56 - we execute this program over here
52:01 - as you can see this would panic
52:05 - now the problem here is a floating Point
52:08 - precision
52:10 - the result won't be exactly 0.3 it would
52:16 - be something like
52:20 - that maybe right or something like that
52:23 - I don't know exactly but
52:27 - t
52:29 - floating point value is too precise
52:32 - because the default floating Point type
52:34 - is f64 so this is really precise and
52:40 - that's why you have these tiny fractions
52:45 - over here now we can solve this using
52:49 - an F 32 Which is less precise right
52:56 - like that
52:58 - and this succeeds now two distinct ways
53:02 - we can also use the as keyword
53:18 - like that
53:22 - so let me first move my head over here
53:25 - again
53:26 - so range two goals first modify Sr to
53:29 - make it work second make print line
53:32 - output 97 to 122.
53:37 - now over here as you can see we have
53:39 - immutable variable sum
53:43 - what would be the type annotation it
53:46 - would be i32 okay now
53:50 - over here we have a for Loop meaning we
53:54 - are iterating over some range and then
53:58 - we are executing an instruction inside
54:01 - this code block over here
54:04 - multiple times basically the times we
54:08 - are iterating over this range over here
54:12 - now in each iteration the variable I
54:15 - will hold
54:16 - a different value right so in the first
54:19 - iteration it would be -3 in the second
54:22 - iteration it would be -2 in the third
54:25 - minus 1 and so on until we reach 1.
54:31 - y1 because 2 over here is excluded and
54:36 - that's always the case when using this
54:38 - syntax the end point of the range is
54:41 - always excluded so we are iterating from
54:44 - -3 to 1 okay
54:49 - now let's actually do these iterations
54:52 - manually so
54:55 - we start with zero right now in the
54:59 - first iteration I would be -3 so
55:03 - 0 plus minus 3 will be
55:07 - minus 3 right
55:09 - so sum will then hold
55:11 - -3 now in the second iteration I will be
55:15 - minus two so minus three plus minus 2
55:19 - will be minus five
55:21 - third iteration minus one minus five
55:25 - plus minus one will be minus six
55:29 - then
55:30 - in the next iteration I will be zero so
55:34 - it doesn't have any impact and in the
55:37 - last iteration I will be one so minus
55:40 - six plus one will be minus five
55:44 - so the value of sum after this for Loop
55:48 - will be minus five
55:51 - now over here we again have a for Loop
55:54 - and this time we are iterating over a
55:57 - range of characters namely from A to Z
56:02 - now this time Z over here is included
56:05 - because we are using the equal sign over
56:08 - here which means we want a range from A
56:12 - to Z where the end point set is included
56:17 - and C over here will then hold in each
56:21 - iteration a character so in the first
56:24 - one it would be a then it would be B
56:27 - then C and so on and we just print out
56:31 - the characters
56:33 - let's see how that looks like as you can
56:37 - see just printing out each character
56:40 - from a to z
56:43 - now we want to have an output of 97 to
56:46 - 122.
56:49 - so let's look at the ASCII table
56:53 - as you can see in memory a character
56:56 - would be stored as a numerical value now
57:01 - of course in memory everything is stored
57:03 - as binary numbers but it would be stored
57:06 - as the binary representation of these
57:11 - decimal numbers right here
57:14 - so we want to go from 97 a to
57:19 - 122 Z right
57:24 - so it's actually pretty simple instead
57:28 - of
57:29 - outputting DC as character
57:33 - we want to Output it as an u8 for
57:37 - example
57:38 - right
57:40 - and then as you can see we have the
57:42 - ASCII code for the characters from A to
57:47 - Z lowercase
57:50 - right
57:52 - then over here exercise 10 fill the
57:55 - blanks so we are here importing from the
58:00 - standard Library the Ops module range
58:03 - and range inclusive
58:05 - now we have seen the shorthand syntax
58:09 - and this would actually be the more
58:11 - verbose way to write that but I think no
58:15 - one actually does it this way
58:17 - over here we have a range which starts
58:21 - at one and ends at five now again five
58:25 - would be excluded right
58:29 - like that now range inclusive means
58:32 - we range from 1 to 5 where 5 is included
58:38 - and we would write that short and syntax
58:41 - like this
58:42 - one two five and five is included
58:51 - right let's see the last exercise in
58:54 - this topic computations fill the blanks
58:56 - and fix the errors
58:58 - so as you can see over here we have
59:00 - integer additions so one plus two will
59:05 - be three
59:07 - and the compiler over here will infer
59:10 - these types so because we have over here
59:14 - an u32 an unsigned 32-bit integer it
59:19 - will infer these values over here to be
59:23 - of the same type
59:25 - all right
59:27 - now over here the same thing we have 1
59:30 - minus 2 would be -1
59:33 - and the compiler infers these types
59:40 - then over here we have 1 minus 2 which
59:43 - is equal minus one
59:45 - the problem over here is that we are
59:48 - dealing with an unsigned 8-bit integer
59:51 - now remember unsigned integers can never
59:54 - be negative
59:56 - so what we can do to fix that is just
59:58 - converting it to an I8 assigned 8-bit
60:02 - integer and signed integers can
60:06 - represent both positive and negative
60:09 - numbers
60:10 - now over here we would have 150
60:15 - and if there are no type annotations
60:18 - here the default integer type will be
60:21 - inferred which will be i32
60:25 - now over here again we have the problem
60:28 - of floating Point Precision so we can
60:31 - cast that to an F 32.
60:42 - like that
60:43 - over here we have the modulus operator
60:46 - and the modules operator basically gives
60:50 - back the remainder of a division so if
60:54 - we divide 24 by 5 we would have a
60:58 - remainder of 4.
61:02 - now as you can see here we have Boolean
61:05 - logic and bitwise operations and I want
61:08 - to show you some slides so we get the
61:11 - concept
61:13 - let's start with Boolean logic Boolean
61:16 - logic deals with values that are either
61:19 - true or false
61:21 - and there are three basic operations and
61:25 - or and not
61:27 - and over here you can see the truth
61:29 - tables of these operations
61:32 - so let's see the and operator now the
61:35 - end operator takes two inputs and
61:38 - produces one output
61:41 - now the only time it outputs true is
61:44 - when both of the inputs are true
61:47 - otherwise it will always return false
61:51 - in an or operation
61:53 - if either one of the inputs is true or
61:57 - both of the inputs are true then it will
62:00 - output true if both of the inputs are
62:04 - false then it will output faults
62:08 - and the not operator will just basically
62:11 - invert the Boolean value so over here we
62:15 - have not false and this would evaluate
62:17 - to true and not true will evaluate to
62:22 - false
62:24 - now let's see bitwise operations
62:27 - bitwise operations are operations that
62:30 - manipulate individual bits that make up
62:33 - a binary number treating each bit of a
62:37 - binary number as a separate unit and
62:39 - perform logical operations on them
62:43 - so it's very important that you get that
62:45 - in bitwise operations we are treating
62:49 - each bit as a separate unit and we are
62:52 - doing some manipulation on each
62:54 - individual bit and not the binary number
62:57 - as a whole
63:00 - and we'll cover here and or X or
63:04 - operations and bitwise shifting now
63:07 - there are a lot more but I will just
63:09 - cover the ones in the exercise
63:14 - let's start with the end operator this
63:17 - Ampersand symbol over here and returns
63:20 - one only when both of its inputs are one
63:24 - so similar to Boolean logic as you can
63:27 - see the end operator takes two inputs
63:30 - and produces one output
63:34 - now
63:36 - as you can see in the truth table if
63:40 - both of the inputs are one then the
63:43 - output will be 1. in any other case the
63:46 - output will be zero
63:50 - let's see the or operator this symbol
63:54 - over here
63:55 - all returns one if at least one of its
63:58 - inputs is one if both inputs are zero
64:02 - the output will also be zero
64:05 - so same thing as in Boolean logic if
64:08 - either one of the inputs or both of the
64:11 - inputs are one then it will output one
64:15 - so the only case it outputs 0 is when
64:19 - both of the inputs are zero
64:24 - and let's see xor xor or exclusive or
64:28 - returns one if the inputs are different
64:31 - and zero if the inputs are the same
64:35 - so it's basically similar to the or
64:39 - operator with the difference that if
64:42 - both of the inputs are one then it will
64:45 - output 0. so the inputs must be
64:49 - different so it will output one all
64:52 - right if they are the same it will
64:54 - output 0.
64:59 - and this is basically a building block
65:02 - of your computer so your computer is
65:06 - made up of logic gates and these logic
65:08 - gates perform these operations all the
65:12 - time
65:13 - millions of times in a second
65:18 - then let's see bitwise left shift so we
65:21 - have over here the decimal number one
65:24 - this would be the binary representation
65:27 - now we want to left shift
65:31 - by five positions
65:33 - so we take this bit over here and move
65:37 - it five positions to the left
65:40 - so the so this bit over here will be at
65:44 - this position after the DP twice left
65:46 - shift operation all right and that means
65:49 - we then have a value of 32 because this
65:54 - is the binary representation of decimal
65:58 - 32.
66:01 - and bitwise right shift is basically the
66:04 - same
66:04 - now over here we have a hexadecimal
66:07 - value and we want to right shift it to
66:10 - positions
66:11 - now this value over here would be 128 in
66:17 - decimal
66:19 - and this would be the binary
66:21 - representation of 128.
66:25 - now we want to right shift it to
66:28 - positions meaning we take this bit over
66:31 - here and shift it two positions to the
66:35 - right meaning the bit will then be in
66:37 - this place and again we would have 32
66:41 - because this over here is the binary
66:44 - representation of that number all right
66:47 - let's see
66:48 - so true
66:50 - and false
66:52 - would be
66:54 - false
66:56 - right because in an and operation both
66:59 - of the inputs must be true in order for
67:02 - it to Output true now true or false
67:07 - would be true
67:09 - because in an or operation only one of
67:12 - the inputs have to be true
67:15 - and not true would be equal to
67:21 - that's right false
67:23 - fight
67:25 - like that now let me run the program so
67:29 - we can see the result of these
67:32 - bitwise operations
67:35 - so as you can see over here zero zero
67:38 - one one and zero one zero one is zero
67:42 - zero zero one why is that because again
67:46 - we are here considering each individual
67:49 - bit as a unit and Performing
67:52 - manipulation on each
67:55 - a distinct bit now over here as you can
67:58 - see we are taking the rightmost bit over
68:01 - here and we are performing The End
68:03 - operation with the rightmost bit over
68:06 - here meaning one and one
68:10 - would be one right because and if both
68:15 - of the inputs are 1 then it will output
68:19 - one in any other case as you can see one
68:23 - and zero would be zero
68:26 - 0 and 1 would be zero zero and zero of
68:31 - course would be zero
68:33 - now let's see this or operation we have
68:37 - one or one this will output one
68:42 - we have one or zero which will output
68:46 - one again right because in or operation
68:51 - if either one of its input or both of
68:54 - them are one then it will output one
68:58 - zero or one is one and zero or zero of
69:03 - course is zero
69:06 - and then we have xor one X or one put B
69:10 - zero because remember X or the inputs
69:16 - must be different in order for it to
69:18 - Output one
69:21 - like over here for example 1 X or zero
69:24 - would be one right the inputs over here
69:28 - are different one and zero
69:31 - same over here 0 x or one would be one
69:36 - and zero X or zero of course will be
69:39 - zero and as you can see over here these
69:42 - are the bitwise shifting so I've covered
69:46 - that in the slides
69:48 - all right see you in the next topic so
69:51 - we will cover in our Char pool and unit
69:54 - let's start with characters
69:57 - so over here make it work now size of
70:01 - Val will just return this size in bytes
70:05 - of a specific value so over here we are
70:09 - initializing the variable C1 with a
70:12 - character so C1 holds a type of char
70:18 - then we pass to the size of valve
70:20 - function the variable C1 and this will
70:24 - return the size of this character in
70:27 - memory in bytes right and same thing
70:31 - over here we have C2 also holding HR
70:35 - and we call the size of L function with
70:38 - this variable
70:39 - so
70:41 - let me first print out the actual result
70:45 - of this function call
70:47 - so if I come over here
70:49 - and I will do a print line
70:52 - statement
71:00 - and just basically
71:02 - outputting the result of this function
71:05 - column so let's see
71:11 - as you can see the output would be 4
71:14 - meaning this character over here will
71:18 - take up four bytes in memory so the size
71:22 - of C1 is 4 bytes
71:27 - now in Rust the chart type is big enough
71:32 - to hold every single Unicode symbol
71:35 - meaning it is of size 4 bytes so it's
71:39 - able to hold any Unicode scalar value
71:42 - all right
71:44 - and the same thing over here the output
71:47 - would be four
71:49 - meaning if we call this function we will
71:52 - get back four
71:59 - all right
72:00 - make it work again initializing a
72:03 - variable with a Char then we are calling
72:06 - the printshar function with an argument
72:09 - of this variable
72:11 - as you can see this function over here
72:13 - this is the function signature this
72:16 - function takes as argument C which is of
72:21 - type Char and then we will and then we
72:24 - just print out C
72:30 - now the problem over here is that this
72:33 - isn't actually a Char this would be
72:36 - considered a string because in Rust
72:38 - there is a difference between double
72:40 - quotes and single quotes So double
72:43 - quotes are four strings and these single
72:45 - quotes are for characters
72:49 - foreign
72:54 - out the character
72:57 - let's see booleans make print Line work
73:01 - as you can see this variable underscore
73:03 - F holds a Boolean value of false
73:07 - and over here T also holds a Boolean
73:11 - value of true
73:13 - now in an if block this conditional over
73:17 - here will be checked if the result
73:20 - evaluates to true then this instruction
73:23 - inside the curly braces will be printed
73:26 - out if it evaluates to false then the
73:31 - program will just ignore this
73:34 - instruction over here
73:35 - now in this case we want to print that
73:38 - out
73:39 - but over here the result would evaluate
73:42 - to false because we are saying not
73:46 - true right because T holds a Boolean
73:49 - value of true
73:51 - so not true would be false that means
73:54 - this will never get printed out what we
73:57 - can do over here is just removing this
74:00 - not operator and then it will work
74:05 - make it work again we have some
74:08 - variables that hold Boolean types now
74:12 - again this variable over here T will
74:15 - also hold a Boolean type because this
74:17 - over here is an and operation and
74:20 - remember an end operation takes two
74:23 - inputs and produces one output so the
74:27 - output type will be of type pool now
74:31 - true and false would evaluate to false
74:37 - and then we are comparing T and F now F
74:43 - holds true and T holds false
74:46 - which is not what we want
74:48 - so what we can do over here is just
74:51 - making this false over here
74:58 - and then both of them hold a Boolean
75:01 - value of false
75:05 - unit type make it work don't modify
75:08 - implicitly red unit
75:11 - so the unit type is a type which doesn't
75:14 - hold any value
75:16 - its size is zero bytes and it's usually
75:21 - if a function doesn't return
75:24 - any value then a unit type will be
75:28 - returned and this happens implicitly so
75:30 - you don't have to annotate that
75:34 - let's see an example
75:37 - over here the underscore V variable
75:41 - holds a unit type
75:44 - as you can see a unit type is basically
75:46 - represented as an empty Tuple
75:50 - and this would be the type annotation
75:52 - right
75:54 - so over here we are holding a tuple with
75:58 - two i-32 values
76:03 - then as you can see we have here an
76:06 - assert EQ macro we are comparing V with
76:10 - the output of this function call let's
76:13 - see this function over here implicitly
76:15 - red unit so all this function does is it
76:20 - will print out something and then goes
76:23 - back to the color now this function over
76:26 - here doesn't return anything
76:29 - and if a function doesn't return
76:31 - anything the compiler will implicitly
76:34 - return a unit type right but you don't
76:39 - have to annotate that
76:42 - all right so the return value of this
76:46 - would be unit type now V over here holds
76:50 - a tuple meaning this would fail we have
76:53 - here to provide underscore V which holds
76:57 - a unit type so this holds a unit type
77:00 - and this function call over here will
77:03 - return a unit type
77:09 - all right what's the size of the unit
77:12 - type modify 4 in assert to make it work
77:17 - as you can see we are again having this
77:20 - size of L function and we are providing
77:22 - it this variable which holds a unit type
77:26 - now the output would be zero because
77:30 - unit types are of size 0.
77:34 - so to quickly recap HR is a single
77:37 - character of size 4 bytes
77:40 - a Boolean value of true or false is of
77:43 - size 1 byte and the unit is an empty
77:47 - Tuple of size 0 bytes used to return
77:50 - nothing in expressions or functions
77:54 - so this time I will first show you the
77:57 - slide
77:58 - and then we will solve exercises so a
78:02 - statement is an instruction that
78:04 - performs some action but does not
78:06 - produce a value
78:08 - function definitions for example are
78:11 - statements as well as code that ends
78:14 - with a semicolon usually
78:17 - and an expression will evaluate to a
78:21 - resultant value so let's see
78:25 - all right let's see this example over
78:27 - here we have X which holds an u32 all
78:31 - right now
78:35 - over here we are initializing the
78:37 - variable y with the resultant value of
78:42 - this whole expression so as you can see
78:45 - we can inside these curly brackets
78:50 - we can declare variables over here and
78:54 - then we do some operations and return
78:58 - the value as you notice I omit over here
79:02 - the semicolon that means that
79:04 - this result of this operation will get
79:09 - returned which means when this evaluates
79:13 - it will then be assigned to Y so y will
79:18 - then hold the result of this operation
79:21 - now all of the code inside these curly
79:24 - braces are considered as an expression
79:27 - because it produces a resultant value
79:31 - right it would be this value over here
79:35 - now this variable assignment over here
79:39 - would be considered a statement because
79:42 - first of all it ends in a semicolon and
79:46 - second it doesn't produce a new value
79:48 - right it just assigns a value to a
79:53 - variable
79:54 - now y in the end would hold an u32 right
79:59 - because we are here performing an
80:01 - operation with values of u32 types
80:07 - the semicolon suppresses this expression
80:10 - and unit type is assigned to Z
80:14 - so Z over here would hold a unit type
80:18 - why is that because we over here have a
80:21 - semicolon so this
80:25 - code over here doesn't return a value
80:29 - if we omit the semicolon then this would
80:32 - be the return value that then gets
80:35 - assigned to this variable meaning it
80:38 - will then hold a u32
80:44 - all right let's do exercise one make it
80:47 - work with two ways so
80:52 - as you can see over here we are
80:54 - initializing this variable over here
80:56 - with this expression inside the curly
81:00 - braces now we are here initializing the
81:04 - mutable variable x with a value of one
81:07 - so X will hold I 32.
81:11 - then we are mutating X incrementing it
81:14 - by two so X should then hold
81:18 - 3 right
81:20 - now over here this would actually hold
81:25 - a unit type
81:27 - because over here we have an assignment
81:30 - so we are adding 2 to the value of x and
81:34 - then we assign it to X now the problem
81:38 - is that
81:39 - variable assignments are actually
81:42 - statements so this should end in a
81:45 - semicolon because this would be the same
81:48 - as if I would write it like that
81:52 - right
81:54 - so we can't return over here a variable
81:58 - assignment but what we can do is
82:01 - we just return X because X over here
82:05 - will then hold 3 and then we return X
82:09 - meaning the value of x is then assigned
82:12 - to the variable V
82:16 - so variable V will then hold a type of I
82:20 - 32.
82:22 - let's see
82:28 - this compiling as you can see make it
82:30 - work in two ways now the second way to
82:33 - solve it is just in this assert EQ macro
82:37 - we compare V to a unit type
82:43 - because
82:45 - um no value will get assigned to V and
82:50 - that means the variable we will then
82:52 - hold a unit type like that
82:56 - over here as you can see we are
82:58 - initializing V with a variable
83:01 - assignment so this would not be allowed
83:04 - it's invalid syntax but what we can do
83:08 - is we use curly braces like that and
83:12 - then we
83:14 - initialize here a variable X and we
83:18 - return X
83:21 - this would be allowed
83:25 - so V then holds an i32
83:32 - let's see over here we have a function
83:34 - call with two values one and two so
83:38 - let's see the function over here it
83:41 - takes two arguments X and Y of type i32
83:46 - and it returns an i32 value now over
83:51 - here as you can see this function just
83:54 - adds X Plus y now the actual return type
84:00 - over here would be unit type
84:06 - because as you can see we are ending
84:10 - this operation with a semicolon meaning
84:13 - nothing will get returned so if we omit
84:17 - the semicolon over here then we would
84:19 - have a return type of I 32.
84:26 - meaning after the function call over
84:29 - here
84:30 - s will then hold the result of this
84:34 - operation 1 plus 2 would be 3 so s would
84:39 - hold three
84:42 - that would be a type of i32
84:50 - so let's now look at functions a
84:52 - function is a block of reusable code
84:54 - that performs specific tasks it can take
84:58 - arguments processes those inputs and
85:01 - then returns a result
85:03 - and a diverging function is a function
85:06 - that never returns to the caller
85:10 - and this would happen for example if the
85:13 - diversion function is panicking looping
85:16 - forever or quitting the program
85:21 - so let's see don't modify the following
85:25 - two lines as you can see we have here a
85:28 - tuple and we are destructuring it we
85:31 - have already seen how that works
85:33 - now over here we have a function called
85:37 - now this would be the color and this
85:41 - function would be the collie okay when
85:45 - we call the function the flow control
85:47 - will go to this function and the program
85:51 - will continue executing the instructions
85:54 - provided in this function now
85:58 - it's very important that you know that
86:00 - functions always have to annotate types
86:03 - for their arguments
86:07 - so over here
86:09 - we would Define that X should be of type
86:12 - i32 right because Y is I 32 and we are
86:17 - performing here a mathematical operation
86:19 - meaning they both have to be of the same
86:22 - type
86:24 - and
86:27 - as you can see like in the last exercise
86:29 - this function wouldn't return a value
86:32 - because over here we have a semicolon so
86:35 - if we omit that then this result of this
86:40 - operation will get returned which means
86:42 - the return type would be i32
86:47 - then when this Returns the flow control
86:51 - will go back over here and assign The
86:55 - Returned value from this function to
86:58 - variable s meaning the variable s will
87:01 - then hold
87:02 - a type of i32 and the value would be 3
87:07 - right because we are calling the
87:09 - function with arguments one and two or X
87:13 - and Y
87:14 - over here which hold one and two and
87:19 - then this function will just sum it up
87:21 - together and that means s will hold 3.
87:30 - over here we are calling the print
87:33 - function so we go to the function over
87:36 - here and as you can see
87:39 - the function just prints out something
87:41 - to standard output but it doesn't return
87:45 - a value now implicitly the compiler will
87:50 - return a unit type like that but we
87:54 - don't have to write it
87:56 - it's implicit
88:05 - solve it in two ways don't let print Ln
88:08 - work
88:10 - all right so we are here calling a
88:12 - function never return
88:15 - and this function should never return
88:18 - because as you can see the return type
88:20 - over here is defined as exclamation mark
88:24 - and that means this is a diverging
88:27 - function a function that should never
88:30 - return back to the caller
88:33 - now we can do this in various different
88:36 - ways but I will just use the most simple
88:39 - one which is panic
88:43 - and the Panic macro just
88:46 - causes the program to panic meaning the
88:50 - program will immediately exit and return
88:53 - an error
89:03 - as you can see unreachable statement so
89:06 - this line over here is never reached
89:11 - as you can see and that's what we want
89:13 - because over here don't let print Ln
89:16 - work so we never actually reach this
89:20 - point the program will exit before
89:24 - going back to the caller
89:29 - diverging functions diverging functions
89:31 - never return to the caller so they may
89:34 - be used in places where a value of any
89:37 - type is expected
89:40 - so in the main function we just print
89:44 - out something and over here we have a
89:47 - function get option
89:49 - it takes as argument a value of type u8
89:54 - and returns option i32 now we will cover
89:58 - options in a later episode
90:02 - now over here we are matching TP
90:06 - and matching if you're coming from
90:09 - another programming language is like is
90:13 - which
90:15 - block okay we are matching TP and then
90:22 - if for example TP would be one then this
90:26 - code block over here would get executed
90:29 - if it is anything else then this code
90:32 - block will be executed and we will cover
90:36 - match statements but match is just a
90:40 - much more powerful way of pattern
90:43 - matching than for example if else
90:45 - conditionals
90:48 - so after this match we are calling this
90:51 - never return FN and this should never
90:55 - return so there are some macros we can
91:00 - use here I've showed you one the Panic
91:03 - macro
91:04 - [Applause]
91:10 - like that
91:12 - or we can also use unimplemented
91:18 - and you use the unimplemented macro if
91:21 - you have a function that is not
91:23 - implemented yet
91:25 - and we can also use it to do macro
91:31 - like that
91:33 - and to do is basically very similar to
91:37 - and implemented and all of them will
91:42 - cause this function to not return to the
91:46 - caller in this case this would be the
91:48 - color over here
91:52 - fill in the blank so as you can see we
91:55 - have here a variable B which then gets
91:58 - matched over here so if B holds a value
92:01 - of true then 1 will be assigned to
92:05 - variable V
92:07 - if B holds a value of false then it will
92:11 - print out success and the program will
92:15 - then panic
92:17 - now
92:18 - we can here assign false because I guess
92:22 - we wanted to print out success right
92:26 - and
92:28 - yeah let's see
92:36 - as you can see this would be the
92:38 - compiler message if a program panics
92:41 - trade main panicked at we have no value
92:44 - for false but we can panic
92:49 - that would be this output over here
92:53 - so we will now cover ownership and
92:57 - ownership is a concept which is unique
93:00 - to rust meaning even experienced
93:03 - programmers can find it difficult to
93:06 - understand this concept
93:08 - but it's very logical and it all makes
93:12 - sense and I will use visuals and
93:14 - illustrations
93:16 - to make it easier to understand the
93:20 - concept so ownership is basically a set
93:23 - of rules that govern memory management
93:27 - these rules are enforced at compiled
93:30 - time
93:31 - if any of the rules are violated then
93:34 - the program won't compile
93:39 - now let's see the three rules of
93:41 - ownership in Rust first each value in
93:45 - Rust has an owner second there can only
93:49 - be one owner at a time
93:52 - third when the owner goes out of scope
93:55 - the value will be dropped
93:58 - now the owner of a value is the variable
94:01 - or data structure that holds it and is
94:04 - responsible for allocating and freeing
94:08 - the memory used to store that data
94:13 - foreign let's look at scope
94:16 - a scope is arranged within a program for
94:19 - which an item is valid we have two types
94:23 - of scope one is global scope and that
94:26 - means a variable that is declared in
94:29 - global scope is accessible throughout
94:32 - the entire program
94:34 - and local scope if a variable is
94:39 - declared locally it means it is
94:42 - accessible only within that particular
94:45 - function or code block
94:48 - which in turn means it's not accessible
94:51 - outside of that function or code block
94:56 - let's see an example of scope
94:59 - as you can see we are here initializing
95:02 - the variable s with a string that means
95:06 - s over here is the owner of this data of
95:11 - this string value okay
95:14 - now s is valid from this point forward
95:17 - so after initializing s it will be valid
95:23 - throughout this scope over here which is
95:27 - defined by these curly braces
95:30 - so inside of this scope we can do stuff
95:34 - with s
95:37 - when this scope is over s is no longer
95:41 - valid so as over here the owner of this
95:45 - data will deallocate the data that is
95:48 - stored in computer memory and that means
95:52 - in turn we can't use as after this point
95:57 - it gets dropped or removed
96:01 - from memory
96:03 - so when s comes into scope it is valid
96:06 - it remains valid until it goes out of
96:09 - scope and a general rule is the scope
96:13 - ends where the block of code ends so to
96:17 - understand ownership you have to
96:19 - understand computer memory now memory is
96:24 - a component in a computer to store data
96:27 - and instructions for the processor to
96:30 - execute
96:32 - there is a type of memory called random
96:35 - access memory or RAM and it is volatile
96:39 - meaning when you're turning off your
96:42 - computer all data stored inside Ram is
96:46 - lost
96:47 - and there are two types of regions in
96:50 - Ram which is used by your rust program
96:53 - it is stack memory and Heap memory
96:58 - so now let's look at stack memory and I
97:02 - want you to imagine a stack of plates
97:05 - now if you want to eat something you
97:08 - take from the top of this stack a plate
97:11 - put food on it eat and then you will
97:14 - clean up the plate right when you're
97:18 - done cleaning you put the plate back on
97:21 - the top of the stack
97:24 - and that's exactly what is happening in
97:27 - stack memory so this concept is called
97:30 - last in first out meaning the last thing
97:35 - that is pushed
97:37 - on top of the stack will be the first
97:40 - thing that will get popped from this
97:42 - deck meaning the first thing that will
97:44 - get executed
97:47 - now all data stored on this deck must
97:50 - have a known fixed size like integers
97:54 - floats Charles bulls and so on basically
97:58 - all the types we have seen so far are
98:02 - all of fixed known size at compile time
98:08 - now pushing to the stack is faster than
98:11 - allocating on the Heap because the
98:13 - location for new data is always at the
98:16 - top of the stack
98:18 - meaning the program can access
98:21 - a data and stack memory at constant time
98:24 - if you are familiar with time complexity
98:28 - and types of unknown size will get
98:31 - allocated to the Heap and a pointer to
98:34 - the value is pushed to this stack
98:36 - because a pointer is fixed size
98:40 - don't worry I will show you
98:42 - illustrations which will make you
98:45 - understand this concept better
98:49 - let's see for example
98:52 - this simple rust program so as you can
98:56 - see we are starting in main because main
99:00 - is the starting point of execution in
99:03 - every rust program
99:06 - so over here we declare some variables X
99:10 - Y and Z meaning these variables are
99:13 - local to the main scope to this code
99:18 - block over here
99:21 - and
99:22 - because they are local they can't be
99:25 - accessed outside of this scope
99:30 - now over here we have a function call
99:33 - and we pass it the value of x and of Y
99:38 - right so as you can see the add numbers
99:41 - function takes two arguments of type i32
99:46 - then over here we declare a new variable
99:50 - and assign and we assign the result of
99:55 - the operation a plus b meaning
99:58 - the past value is X Plus Y
100:01 - and we assign it to the variable C and
100:06 - then we just return C right so then
100:12 - Z over here will hold the returned value
100:17 - now
100:18 - when we start execution main alongside
100:23 - with all the local variables will get
100:25 - pushed to the stack
100:29 - then because we have over here a
100:31 - function call inside Main
100:34 - the add numbers function alongside with
100:38 - all the local variables to this function
100:41 - will get pushed to this stack if we
100:44 - would have other function calls over
100:45 - here or inside here then this will also
100:50 - get pushed on the stack and so on
100:54 - and then the program will just execute
100:58 - everything that is on the stack from top
101:01 - to bottom
101:04 - now let's look at Heap memory date of no
101:08 - known fixed size belongs on the Heap
101:11 - allocating data on the Heap will return
101:14 - a pointer an address to a location where
101:17 - the data has been allocated
101:20 - allocating on the Heap is slower than
101:23 - pushing to this stack and accessing data
101:26 - on the Heap is also slower as it has to
101:29 - be accessed using a pointer which points
101:33 - to an address
101:36 - so if we look at this abstract
101:39 - illustration of Heap memory as you can
101:42 - see we are allocating to Heap memory if
101:46 - the size of of the type we are
101:49 - allocating is not known at compile time
101:53 - and the types can then also be
101:57 - dynamically grown or shrinked right the
102:01 - size is not fixed
102:04 - and we will see examples of these types
102:08 - where this cat where this could be
102:11 - useful
102:12 - so when we allocate to Heap memory let's
102:15 - see for example the this packet over
102:19 - here we will get back a memory address
102:23 - and we need this address so we know
102:26 - where this specific data over here has
102:29 - been allocated so we then can access it
102:32 - in our program
102:36 - and an example of a heap allocator type
102:41 - would be the string type now as I've
102:44 - said all types we have covered so far
102:47 - were fixed size meaning their size was
102:51 - known at compiled time and they can't
102:54 - grow and Shrink
102:56 - so the difference is a string is mutable
103:00 - meaning its size can change at run time
103:04 - and a string is stored on the stack with
103:08 - a pointer to the Heap so when we
103:11 - initialize a string type then we will
103:14 - get back a pointer which then points to
103:17 - the actual data in the Heap
103:20 - and and the actual data of the string is
103:24 - stored on the Heap
103:26 - so let's see an example to understand
103:29 - this better as you can see we have here
103:32 - the variable S1 which we initialize with
103:36 - a string type over here
103:39 - and we initialize a string like this
103:42 - string
103:44 - double colon from and then these the
103:49 - actual string
103:51 - now
103:53 - you need to understand that the variable
103:56 - S1 doesn't hold the actual string in
104:00 - this case
104:02 - it holds a pointer which points to the
104:06 - data that was allocated on the Heap so
104:10 - if we look at S1 we can see that S1
104:14 - doesn't hold the actual data but it
104:17 - holds a pointer and a pointer is
104:20 - basically a variable that holds a memory
104:24 - address that's what we call pointer
104:28 - and we have here Len and this is the
104:32 - length of the string we have initialized
104:36 - and the capacity holds the information
104:39 - of how much space was reserved in Heap
104:43 - memory for this specific type in this
104:47 - case we have initialized a string with a
104:50 - length of 5 so the capacity will be 5 so
104:55 - 5 locations have been allocated in Heap
105:00 - memory so this place is reserved
105:04 - for this string type and we will go into
105:08 - a much greater detail about capacity
105:11 - but for now when we initialize a string
105:16 - with a length of 5 the capacity will be
105:19 - five it will be the same
105:22 - so the size of this S1 variable will be
105:26 - 24 bytes because each field over here is
105:31 - of Type U size
105:34 - right so the pointer is of Type U size
105:36 - the Lan anti-capacity all of them are U
105:40 - size and u-size assuming we are on a
105:44 - 64-bit computer will be 8 bytes so 3
105:48 - times 8 bytes will be 24 bytes meaning
105:53 - the size of the variable S1 is known at
105:57 - compile time because again
106:00 - the variable S1 will get pushed to this
106:05 - stack memory and everything that lives
106:09 - on the stack memory has to be of known
106:12 - fixed size at compile time in this case
106:15 - all of these fields over here are known
106:18 - fixed size but we are pointing over here
106:23 - to the actual data in Heap memory which
106:27 - can be dynamically sized right it can
106:30 - grow and shrink and we will see examples
106:33 - of that
106:34 - so that is actually the point
106:38 - important the S1 variable doesn't hold
106:42 - the actual data but it holds a pointer
106:46 - to the data in Heap memory
106:50 - okay basically a pointer to the location
106:54 - of the first element
106:57 - and by the way in Heap memory this data
107:01 - over here is allocated as a contiguous
107:04 - block meaning in Heap memory these are
107:09 - all in a contiguous sequence of memory
107:13 - addresses right that's why we only need
107:16 - the
107:18 - memory address of the first location and
107:22 - a length and then the compiler will know
107:26 - where to look at and how long the
107:30 - sequence of data is
107:36 - so copy versus move scalar values with
107:41 - fixed size all types we've covered at
107:43 - the beginning will automatically get
107:46 - copied in this stack copying here is
107:49 - cheap
107:50 - dynamically sized data won't get copied
107:53 - but moved copying would be too expensive
107:57 - let's see an example
108:00 - over here as you can see we have
108:03 - initialized a variable x with a value of
108:06 - 5. then we assign X to y
108:11 - now the type of this value would be i32
108:14 - right because it's the default integer
108:17 - type
108:19 - now because i32 is fixed size it means
108:24 - that it lives in this stack memory
108:28 - and everything that lives in stack
108:30 - memory will automatically get copied
108:34 - meaning we are here assigning a copy of
108:38 - x to y or basically a copy of the value
108:43 - 5. so we are not assigning the actual
108:46 - value but a copy of that meaning Y and X
108:52 - would point to different memory
108:54 - locations the value is the same but the
108:57 - location at which the value is stored is
109:02 - different because again when we assign a
109:06 - fixed size integer that lives in stack
109:10 - memory rust will automatically copy the
109:14 - value
109:16 - because copying on the stack memory is
109:19 - cheap now over here as you can see we
109:23 - initialize a string
109:26 - and then we assign S1 holding this
109:29 - string 2s2
109:32 - now as we've seen S1 doesn't actually
109:36 - hold the data over here but it holds a
109:41 - pointer which is returned when we are
109:44 - allocating this data over here this
109:47 - string on the Heap memory so the
109:52 - allocator that allocates this data on
109:55 - the Heap memory will return a pointer
109:58 - and that means if we assign S1 over here
110:01 - to S2 then S2 will only get a copy of
110:06 - the pointer and not the actual
110:10 - data
110:14 - so that is how that might look like as
110:18 - you can see we have S1 which is
110:21 - initialized to hold a string
110:24 - now S1 will then be assigned to S2
110:31 - and
110:32 - as you can see this is how this might
110:35 - then look like we have here the variable
110:38 - S1 and S2 now
110:43 - the actual data over here didn't get
110:46 - copied the one thing that got copied was
110:49 - the pointer alongside with the metadata
110:53 - meaning
110:55 - these two variables now point to the
110:58 - same location in memory
111:02 - right now this would violate the second
111:04 - rule which states that there can only be
111:08 - one owner at a time
111:11 - so we can't over here have two owners to
111:15 - the same
111:17 - data in Heap memory
111:20 - so what rust will do is it will drop S1
111:25 - it will delete S1 and that means
111:29 - S2 will then be the owner of the data so
111:34 - the first variable S1 will be dropped
111:37 - and cannot be used after assigning it to
111:39 - S2 to avoid dangling pointers
111:43 - so after assigning S1 to S2 we can't use
111:48 - S1 again
111:51 - and that's different like we saw over
111:53 - here with for example integers which are
111:57 - fixed size
111:58 - we can use after assigning X to Y we can
112:02 - use both of these variables X and Y
112:05 - without any problem because again here
112:08 - the value got copied
112:14 - so the compiler will drop the variable
112:17 - S1 meaning S2 will become the owner of
112:21 - this string and that means we can't use
112:26 - S1 after this point
112:29 - now what if you want to actually have a
112:33 - deep copy meaning you actually want to
112:35 - copy the data that is allocated in Heap
112:40 - memory we can do that but we have to
112:43 - explicitly state that we want to do that
112:46 - because as I've said this might be
112:49 - expensive if you have large data that is
112:52 - allocated on the Heap
112:54 - and if rust would implicitly copy
112:59 - all the data all the time you're
113:00 - assigning variables then this would be
113:03 - really expensive and that's why we have
113:05 - to explicitly call over here the Clone
113:09 - method so when we take S1 which holds a
113:13 - string and we call upon it the Clone
113:15 - method
113:17 - and assign this to S2 then that is what
113:21 - this might look like
113:23 - as you can see S1 again doesn't hold the
113:27 - actual data but a pointer to the data
113:30 - that is that has been allocated in Heap
113:34 - memory
113:36 - and when we now look at S2 S2 also holds
113:41 - a pointer to data that has been
113:43 - allocated in Heap memory the difference
113:47 - is that the actual data in Heap memory
113:51 - that S1 is pointing to has been copied
113:55 - in Heap memory
113:57 - so S1 and S2 point to different
114:01 - locations even if the data is the same
114:06 - right and that's different from what we
114:09 - saw here as you can see S1 and S2 point
114:13 - to the same location in Heap memory
114:19 - I hope you get the concept so let's now
114:22 - see how ownership Works in functions as
114:26 - you can see we have here a variable s
114:28 - which we initialized with a string type
114:32 - so over here s comes into scope
114:36 - and in this case s will be the owner of
114:41 - this data
114:44 - then over here we are calling the takes
114:47 - ownership function providing it an
114:50 - argument of s
114:52 - so s value moves into the function and
114:55 - so is no longer valid here meaning the
114:59 - function takes ownership is now the
115:01 - owner of s
115:04 - so as you can see this function over
115:06 - here takes an argument of string type
115:10 - and it just prints out the provided
115:13 - string
115:14 - so as you can see some string comes into
115:17 - scope and some string over here is the
115:21 - string we have provided as an argument
115:25 - then we print it out and over here
115:29 - some string goes out of scope and drop
115:32 - is called the backing memory is freed
115:35 - meaning
115:37 - when we reach the end of the scope
115:41 - some string will get deallocated in Heap
115:45 - memory
115:47 - so after this point over here s
115:51 - can't be used in this main function over
115:55 - here because again the ownership has
115:58 - been moved from variable s into the
116:02 - takes ownership function
116:05 - now over here we have another
116:07 - initialized variable x with a value of
116:10 - five now five would be of type I 32 the
116:14 - default integer type meaning 5 is a type
116:18 - that lives on this stack it's pushed to
116:21 - the stack and not allocated on the Heap
116:25 - and that means when we call this
116:28 - function makes copy and provided X over
116:31 - here
116:32 - then we provide this function a copy of
116:36 - the value and not the actual value
116:39 - itself
116:41 - so we provide here a copy of the value 5
116:45 - right and then over here we just print
116:49 - out this number then here are some
116:51 - integrals out of scope nothing special
116:54 - happens
116:56 - so the argument we are providing here
116:59 - goes out of scope but X over here is
117:03 - still valid because again we have just
117:06 - provided a copy because this is a type
117:10 - that is living on the stack memory
117:16 - so let's see this example over here we
117:19 - are calling the gifs ownership function
117:23 - now when we look at this function over
117:25 - here we are inside the function code
117:29 - block
117:30 - initializing a variable with a string
117:34 - value over here
117:36 - and then we are just returning this
117:38 - string
117:39 - and that means that S1 will then hold
117:43 - the returned string
117:47 - namely this yours string over here so S1
117:51 - will be the owner of The Returned string
117:55 - type
117:57 - over here we are initializing S2 with a
118:01 - string over here that means S2 is the
118:05 - owner of the string
118:08 - then we are calling here the function
118:10 - takes and gives back with an argument of
118:13 - S2 meaning takes and gives back will
118:17 - become the owner of this data
118:22 - and that also means that after calling
118:26 - this function we can't use the variable
118:29 - as 2 because it has been dropped
118:34 - now when we look at the function takes
118:36 - and gives back it takes an argument of
118:40 - type string which we are providing here
118:42 - and then it just again Returns the
118:46 - string right so S3 will then hold the
118:50 - return string basically S3 then became
118:53 - the owner of this data right so we have
118:58 - transferred ownership from S2 to this
119:01 - function takes and gives back and then
119:04 - from this function to S3
119:08 - and then at the end of the main scope S3
119:12 - goes out of scope and is dropped S2 was
119:15 - moved we've seen that we have moved it
119:17 - inside the function so nothing happens
119:21 - S1 goes out of scope and is dropped
119:25 - so
119:26 - the variable S1 also gets dropped
119:29 - because it is the owner of of this
119:32 - string type returned from this function
119:37 - so you are now asking why do I even care
119:40 - about all this stuff in other languages
119:43 - I don't have to worry about all of this
119:47 - and this seems rather complicating
119:51 - a simple issue right now the main point
119:56 - of all of this is that ownership
119:58 - prevents memory safety issues
120:02 - so by this concept of ownership you are
120:06 - preventing dangling pointers pointers
120:09 - that point to Nowhere or some garbage
120:12 - values
120:13 - double three which is trying to free
120:15 - memory that has already been freed or
120:19 - memory leaks not free memory that should
120:22 - have been freed and if you're coming
120:25 - from C or C plus plus you're you know
120:28 - exactly what I'm talking about here
120:33 - so before stepping into borrowing we
120:36 - will do some exercises concerning
120:39 - ownership
120:43 - so let's see number one use as many
120:45 - approaches as you can to make it work
120:49 - so
120:51 - as you can see the variable X over here
120:53 - has been initialized with a string
120:57 - then we are assigning X to Y so y also
121:01 - should hold a string
121:05 - the problem over here is that we try to
121:09 - access X over here after it has been
121:13 - assigned to y
121:15 - now we have seen in the example that X
121:18 - will get dropped after we assigning
121:21 - after we are assigning it to another
121:23 - variable
121:25 - right so we can't access X but what we
121:29 - can do is
121:31 - telling the compiler that we want a deep
121:34 - copy of the data that X is holding and
121:38 - we are using for that the Clone method
121:45 - and then we X and then we can access
121:49 - both of these variables because the data
121:52 - has been cloned and X still lives on
121:59 - number two don't modify code in main
122:01 - again S1 has been initialized with a
122:05 - string
122:07 - and then we are calling here take
122:09 - ownership and providing it an argument
122:12 - as two
122:13 - as you can see the function take
122:16 - ownership expects an argument of type
122:19 - string and it just prints out the
122:23 - provided argument
122:26 - now
122:27 - we are then assigning the return value
122:31 - of this function to this variable the
122:34 - problem here is that this function
122:37 - actually doesn't return anything so this
122:40 - would hold a unit
122:42 - type right
122:44 - now if we want to return the argument
122:47 - over here after Printing and using it
122:51 - we can just return it like that and if
122:55 - you return something from a function you
122:57 - have to annotate the return type and
123:01 - that would be string right
123:04 - because we are taking here in the string
123:07 - and then we are returning it back that
123:10 - means S2 will then hold the returned
123:13 - string
123:16 - and then we can print out S2
123:20 - and notice S1 can't be used after we
123:25 - have called this function with an
123:28 - argument of S1 because the ownership has
123:31 - been transferred to this function
123:35 - so meaning
123:37 - S1 is holding the data over here which
123:40 - means it's the owner then we call this
123:43 - function and provide it as one meaning
123:46 - this function over here becomes the
123:48 - owner and then we are assigning the
123:51 - return value to S2 so that means S2 over
123:54 - here will be the owner of the data
123:59 - in the end
124:01 - number three we are here calling the
124:03 - function GIF ownership
124:06 - and as you can see inside the function
124:08 - we are initializing a variable s which
124:11 - holds a string
124:14 - and we call here the into bytes method
124:17 - on S
124:18 - now let me show you that in the
124:21 - documentation
124:25 - so this is the in two bytes method
124:29 - now as you can see converts a string
124:32 - into a byte Vector so if we have a
124:35 - string over here and we call the into
124:38 - bytes method
124:39 - then we will get the string over here
124:43 - but represented as a vector of bytes
124:47 - okay
124:49 - and the important thing here is that
124:52 - this consumes the string meaning s over
124:56 - here will get consumed and that means s
125:01 - can't be used after this point
125:06 - now what we can do as an alternative we
125:09 - can use S bytes and S bytes just takes
125:13 - references and references will be our
125:16 - next topic so don't worry too much about
125:18 - it right now but when we call the S
125:22 - bytes method over here then the owner
125:27 - will remain
125:29 - the same right it doesn't consume the
125:33 - data
125:35 - so what we can do over here is calling
125:37 - the S bytes method and that means s
125:42 - Remains the owner of this data and we
125:46 - can return it then and that means s over
125:49 - here will be then the owner of The
125:52 - Returned value
125:57 - and then we just print out s
126:04 - fix the arrow without removing code line
126:07 - again we are initializing s with a
126:11 - string
126:13 - then we are calling the print store
126:15 - function with an argument s
126:19 - and all we do is we then print out the
126:23 - string
126:25 - but over here again we try to access S
126:32 - and that would be a compiler error
126:35 - because we are over here
126:38 - providing S as an argument to this
126:40 - function over here meaning this function
126:44 - will become the owner of the data s is
126:47 - holding and that means s is not
126:50 - accessible anymore
126:52 - what we can do over here is we can call
126:56 - the Clone method
127:03 - meaning we are providing this function
127:06 - over here a copy of this data so this
127:09 - data will get copied in Heap memory
127:13 - and that means s will still be valid
127:21 - don't use clone use copy instead
127:26 - so over here we have a tuple now this
127:30 - Tuple holds two integers a unit type and
127:34 - a string
127:36 - now let me annotate that
127:38 - we annotate tuples like that
127:41 - and we have to
127:43 - find each type of array value distribute
127:48 - so we have 2i32 integers
127:52 - One units type and one string
127:57 - now over here we are calling the Clone
128:00 - method and assign it to Y so y should
128:04 - actually hold the same
128:07 - uh values all right
128:11 - and because we have called the Clone
128:13 - method we can use both variables without
128:16 - the problem now it says don't use clones
128:20 - so we can't use clone over here
128:23 - now my solution to this would be if you
128:27 - take a look
128:28 - at the types this Tuple is holding then
128:32 - we see that most of the types over here
128:35 - are actually on the stack memory meaning
128:38 - they are of known fixed size right so
128:43 - inters and i32 would be of size 32 bits
128:47 - right a unit type would be of zero bits
128:51 - the only problem arises here because we
128:54 - have a string now a string is a heap
128:57 - allocated type meaning its size is not
129:01 - known at compile time now what we can do
129:05 - over here is we can use a string literal
129:13 - now
129:14 - we will cover the difference between
129:17 - strings and string literals but for now
129:20 - a string literal is a string that is
129:24 - hard coded into the binary
129:28 - itself into the program
129:31 - so it is immutable which means that this
129:35 - size is known at compile time so all T
129:40 - types the Tuple holes are known
129:45 - are of known fixed size at compile time
129:48 - so over here we can do the same
129:51 - and what's the reason we have been doing
129:54 - this because we know that a type that
129:56 - lives in stack memory meaning it's fixed
130:00 - size will get copied implicitly
130:04 - now this Tuple only holds fixed sized
130:09 - types meaning the Tuple itself is fixed
130:12 - size and that means X over here will get
130:16 - copied implicitly by the compiler all
130:20 - right
130:25 - mutability can be changed when ownership
130:28 - is transferred
130:30 - as you can see we are here initializing
130:32 - s with a string
130:36 - then modify this line only
130:39 - we are here assigning s to S1
130:45 - now over here as you can see we are
130:48 - modifying the string that S1 is holding
130:54 - and remember when we assign s to S1 S1
130:58 - will become the owner of this data
131:01 - meaning s will get dropped
131:05 - so we are then trying to mutate S1
131:09 - and we are pushing to it D string world
131:14 - now remember that a variable is
131:17 - immutable in its nature so we have to
131:20 - use the mute keyword over here to denote
131:24 - that S1 should be mutable
131:32 - and that means that
131:35 - if
131:36 - the ownership has been transferred to
131:39 - another variable we can change its
131:42 - mutability right even if s was immutable
131:46 - we can make S1 mutable without problem
131:50 - because S1 is now the owner of the data
131:57 - now over here as you can see we are
132:00 - initializing a variable x with a boxed
132:04 - integer type now box allows you to
132:08 - allocate directly on the Heap as you
132:11 - know this is an i32 and i32 is normally
132:15 - live in stack memory when we use this
132:19 - over here Box new and we box this i32 it
132:23 - means it gets allocated on the Heap
132:27 - and that means
132:29 - X will then hold a pointer
132:32 - to the data that was allocated in Heap
132:37 - memory so the type annotation here would
132:39 - be box and
132:42 - this box holds an i32
132:45 - and X then basically holds a pointer
132:52 - now over here implement this line don't
132:54 - change other lines
132:57 - now as you can see we have over here to
133:01 - declare y
133:03 - now y gets the referenced and that means
133:08 - we have
133:10 - over here to get back a pointer so we
133:14 - can do basically the same thing like we
133:17 - did before we can use Box new and let's
133:21 - do one for example
133:24 - so the variable one will hold a box
133:29 - with a type of i32
133:33 - and as I've said we allocate
133:36 - this integer
133:38 - on Heap memory meaning we get back a
133:42 - pointer and the pointer is a memory
133:46 - address to the location where this data
133:49 - has been allocated
133:52 - now because y holds a memory address
133:58 - we can't
134:00 - assign a value and integer value
134:04 - directly to Y because Y is just holding
134:08 - an address
134:11 - and not an i32 type because remember we
134:15 - can just assign a value to a variable if
134:19 - both of them are of same type
134:22 - now as you can see y holds the type of
134:25 - box i32 which is not the same type that
134:30 - means we have to de-reference and we are
134:33 - dereferencing using this star operator
134:36 - and and this star operator means
134:40 - we go to the location
134:44 - of Y because Y is holding a memory
134:47 - address and we want to access the value
134:50 - right so we want to access this interval
134:55 - that has been allocated on the Heap and
134:58 - that means we can assign a new value
135:02 - 2y but we have to use this store
135:05 - operator
135:07 - and again over here you can see it even
135:10 - better
135:12 - this would be equal right because X is
135:17 - pointing
135:18 - to a location in memory which holds an
135:22 - integral value of 5.
135:25 - now if we would omit the star operator
135:29 - this would not match because X would
135:32 - hold something like that
135:39 - right in memory address now this memory
135:42 - address and the integer 5 would not be
135:45 - equal but this star operator basically
135:49 - says go to this address and give me back
135:52 - the value that is stored at that address
135:56 - which would be 5.
136:05 - and of course we have to make this
136:08 - variable over here mutable
136:10 - right because we are here mutating y
136:17 - partial move within the destructuring of
136:20 - a single variable both by move and by
136:23 - reference pattern binding can be used at
136:26 - the same time doing this will result
136:28 - doing this will result in a partial move
136:31 - of the variable which means that parts
136:34 - of the variable will be moved while
136:36 - other parts stay in such a case the
136:39 - parent variable cannot be used
136:41 - afterwards as a whole however the parts
136:45 - that are only referenced and not moved
136:47 - can still be used
136:50 - so over here we have a lot of stuff we
136:54 - didn't cover yet and I will try my best
136:58 - to explain it but if you don't get it
137:00 - 100 it's no problem okay we will go into
137:04 - greater detail on each of these
137:07 - structures and types
137:10 - so as you can see over here we have a
137:13 - struct person now a struct is basically
137:16 - a custom type we can create our own
137:19 - types in Rust
137:21 - and
137:22 - a struct basically is a template we are
137:26 - saying here as you can see this truck
137:29 - holds two members
137:31 - one name which is of type string and one
137:34 - H which is of type boxed u8
137:38 - okay a heap allocated unsigned 8-bit
137:42 - integer
137:44 - then we have to instantiate
137:47 - and
137:49 - this person struct meaning we are using
137:53 - this template and create basically a
137:56 - concrete value of that so we are
137:59 - providing here for the name member a
138:03 - string like it's defined here and for
138:06 - the age we provide a boxed value of 20.
138:11 - now this person variable will then hold
138:14 - a type of person right this is now our
138:18 - own
138:20 - custom defined type
138:24 - now
138:26 - name is moved out of person but age is
138:29 - referenced
138:30 - so over here we are destructuring the
138:34 - person instance over here
138:37 - and we do that very similar to tuples we
138:42 - have seen we used to let keyword the
138:45 - name of destruct and then we the
138:49 - structure the fields so the person
138:54 - so the person instance over here will
138:58 - get the structure meaning person name
139:02 - will get put into the name variable and
139:07 - the H member here will get put inside
139:10 - this H variable now notice something we
139:14 - are here using the ref keyword meaning
139:19 - th variable will only take a reference
139:23 - of this data and not the actual data
139:27 - itself
139:29 - but name will get moved inside this
139:33 - variable so the name variable here will
139:36 - be the owner of this string
139:40 - right
139:42 - and that means that person is not the
139:45 - owner of this string anymore it has been
139:49 - when instantiating the struct but it is
139:53 - not anymore
139:55 - then as you can see we are printing out
139:58 - these variables
140:00 - but we then can't use the person
140:03 - instance right because the person
140:06 - instance is not the full owner of all
140:10 - team members inside it
140:13 - and also we can't access person.name
140:16 - this is how you would access normally a
140:19 - member in a struct person Dot and then
140:23 - they member in this case name but we can
140:26 - access
140:28 - person.h because the person instance
140:31 - over here is still the owner of age
140:34 - because again we have destructured it
140:37 - and the variable H only took a reference
140:41 - again
140:44 - if you don't understand a hundred
140:46 - percent it's fine okay we haven't
140:48 - covered a lot of this stuff going on
140:51 - here and I even think this is not a good
140:54 - example right now
140:57 - but yeah so exercise eight as you can
141:01 - see we have here a tuple holding two
141:04 - string types
141:09 - [Applause]
141:11 - now we are assigning the first element
141:16 - of the Tuple and by the way Cupids are
141:19 - also zero index like arrays and we can
141:22 - access the indexes like this
141:24 - the name of the variable and then Dot
141:28 - and the index we want to access in this
141:31 - case the first one
141:33 - that means that underscore s will hold a
141:38 - type of string right namely this over
141:40 - here
141:42 - and that means the ownership of this
141:45 - string data here got transferred to this
141:49 - variable so underscore s is now the
141:53 - owner of this data
141:57 - meaning we can't access T again because
142:02 - T is not the owner anymore of all the
142:06 - values it contains in the Tuple right so
142:10 - we can't use it again but we could still
142:12 - use T at index 1 because this over here
142:17 - is still owned by T because only the
142:21 - first element has been moved out
142:31 - and over here again a tuple with two
142:34 - strings
142:37 - [Applause]
142:39 - so fill the blanks
142:41 - as you can see what we want here is
142:44 - destructuring the Tuple and we want to
142:48 - initialize these two variables S1
142:53 - and S2
142:56 - and remember when we destructure it we
143:01 - have a syntax like that
143:04 - now over here as you can see when we are
143:07 - destructuring this Tuple
143:09 - both of the values
143:12 - it is holding will get transferred to
143:16 - these variables so S1 will be the owner
143:19 - of this stream and S2 will be the owner
143:22 - of this string meaning T doesn't own any
143:26 - values after this point
143:30 - but what we can do because we want to
143:33 - access T again over here we can call the
143:37 - Clone method as you've seen
143:41 - meaning S1 and S2 only hold copies of
143:45 - these strings and not the actual values
143:49 - and that means that t will still be
143:52 - accessible and T is still the owner of
143:56 - all the values inside the tuber
144:04 - alright see you in the next topic so
144:06 - let's look at borrowing borrowing is a
144:09 - way of temporarily access data without
144:12 - taking ownership of it
144:15 - when borrowing you're taking a reference
144:18 - a pointer to the data and not the data
144:22 - itself
144:23 - its goal is to prevent Dengue pointers
144:27 - and data races
144:30 - data can be borrowed immutably and
144:33 - mutably and there are certain rules when
144:35 - borrowing which we have to comply with
144:38 - otherwise the program won't compile
144:43 - let's look at these rules the first rule
144:46 - states that at any given time you can
144:49 - have either one mutable reference or any
144:53 - number of immutable references
144:56 - but you cannot have both you either have
145:00 - one mutable reference or any number of
145:03 - immutable references
145:05 - and the second is references must always
145:10 - be valid
145:11 - so let's see an example of a reference
145:14 - over here we are initializing S1 with a
145:18 - string then we call the calculate length
145:21 - function and as you can see we are here
145:24 - passing a reference to S1 and this is
145:28 - indicated by this Ampersand symbol over
145:31 - here so then let's see the calculate
145:34 - length function as you can see the
145:36 - argument should be of type reference to
145:40 - a string which we did provide right it's
145:44 - a reference this Ampersand to S1 which
145:48 - is of type string
145:50 - and then all this function does it will
145:53 - call the Len method which will return
145:57 - the length of the string
146:01 - and it returns it now notice that the
146:03 - return type will be of Type U size
146:08 - and then this Len variable over here
146:12 - will hold the length of this string
146:16 - and the type annotation would be use
146:20 - size right the return value of this
146:23 - function
146:24 - and then we just print out S1 and length
146:28 - and notice something over here we can
146:31 - use S1 because S1 over here stays the
146:36 - owner of the data we have just provided
146:40 - here a reference to S1 and not S1 itself
146:44 - so let's see how that looks
146:48 - as you can see we have S1 now again it's
146:52 - very important that you understand that
146:54 - the variable S1 over here doesn't hold
146:57 - the actual data but a pointer to the
147:01 - data which will get allocated to the
147:04 - Heap memory so when we allocate to the
147:07 - Heap we will get back a pointer which S1
147:11 - is holding alongside with other metadata
147:15 - now because over here we are providing
147:19 - S1 as a reference that means the
147:23 - variable s from this function
147:26 - will then
147:28 - be another pointer which points to the
147:31 - S1 variable so s points to S1 and S1
147:37 - points to the Heap allocated data
147:42 - and that means that S1 over here Remains
147:46 - the owner of
147:48 - the string
147:52 - let's see Mutual references as you can
147:55 - see we initialize a string and assign it
147:59 - to S now then we call the change
148:03 - function with a mutable reference and
148:07 - notice that you have to annotate that
148:09 - you want the reference to be mutable
148:11 - this is important and it has to be
148:15 - explicitly stated so that the rules are
148:20 - set in place because remember you can
148:23 - only have one single mutable reference
148:26 - at a time
148:27 - and then this change function over here
148:30 - as you can see in the function signature
148:32 - it takes an argument of type mutable
148:36 - reference to string which we are
148:39 - providing right we are providing a
148:41 - multiple reference to S which holds a
148:45 - string and then we can manipulate the
148:48 - string
148:49 - now again very important s Remains the
148:53 - owner of this data even though we are
148:57 - manipulating it in this function over
149:00 - here s Remains the owner because we are
149:03 - here dealing with references
149:07 - so let's look at some examples just to
149:13 - strengthen the knowledge of this concept
149:17 - as you can see we here initialize s with
149:20 - a string and then we have here two
149:24 - mutable references to S and we assign it
149:28 - to R1 and R2
149:31 - now this would fail this program doesn't
149:35 - compile now this would violate the first
149:38 - rule of borrowing which says that we can
149:41 - only have one mutable reference to the
149:44 - same data at a time
149:46 - but what we can actually do
149:49 - let's see this program as you can see
149:52 - again we have a variable s which holds a
149:55 - string
149:56 - and notice over here we have an inner
149:59 - scope
150:00 - so in this scope R1 will hold a mutable
150:04 - reference to s
150:06 - now because at the end of the scope R1
150:10 - we go out of scope meaning it will be
150:13 - dropped we can then again pass a mutable
150:17 - reference to R2
150:19 - so this program will compile
150:22 - so over here again initializing s with a
150:26 - string here we have two immutable
150:29 - references to S now up to this point no
150:33 - problem because the first rule states
150:35 - that we can have any number of immutable
150:38 - references
150:40 - the problem is over here because we are
150:44 - then assigning immutable reference to S
150:47 - to R3 this is a problem because this
150:52 - would violate the first rule of
150:54 - borrowing which says that we can either
150:56 - have any number of immutable references
150:59 - or one single mutable reference but we
151:02 - can't have both of them immutable and
151:05 - mutable references at the same time
151:09 - now over here as you can see we have the
151:12 - exactly same program but as you can see
151:15 - we are here having two immutable
151:18 - references assigned to R1 and R2 and
151:23 - then we just print it out now after this
151:27 - point over here
151:28 - the variables R1 and R2 won't be used in
151:33 - the entire program and that means that
151:36 - we can assign then a mutable reference
151:39 - to R3
151:41 - it's important to notice here that again
151:45 - we don't use R1 and R2 after this point
151:50 - so it's allowed to have a mutable
151:54 - reference over here
151:56 - while over here as you can see we are
151:58 - trying to access all of them at once
152:01 - this would cause a problem
152:04 - now I've showed you some of the reasons
152:06 - why the compiler is so strict and one of
152:09 - them was dangling references so let's
152:12 - see what a dangling reference is
152:15 - as you can see over here we are calling
152:19 - a function dangle now in tangle we are
152:23 - initializing a variable with a string
152:26 - type and then we are returning over here
152:30 - a reference to this string
152:35 - as you can see in the return type it is
152:37 - a reference to a string now the problem
152:41 - here is that when the function returns
152:45 - this variable over here will hold a
152:48 - reference to this string right
152:52 - and
152:53 - s over here will get out of scope at the
152:57 - end of this function scope here
153:01 - and that means
153:02 - this variable over here will point to
153:06 - something that has already been dropped
153:09 - or deleted so it points to a garbage
153:13 - value right
153:16 - and rust won't allow you to compile a
153:20 - program like that because this will
153:22 - violate the second rule which states
153:24 - that references must always be valid
153:28 - very important
153:31 - and to avoid that we can change this
153:33 - tangle function over here and just
153:35 - returning
153:37 - this string itself right so reference to
153:41 - nothing would then be the owner of the
153:44 - string
153:45 - but returning a reference to something
153:49 - that has been declared inside the
153:51 - function scope is a bad idea all right
153:55 - let's do some exercises
153:58 - as you can see we have here a variable
154:01 - holding an i32 value
154:04 - then over here fill the blank and we
154:07 - have to complete this
154:09 - P assignment over here now let me see
154:13 - over here the memory address of X is
154:17 - and we are providing P so we want to
154:20 - print out here the memory address and by
154:25 - the way this is denotation if we pass
154:27 - here a pointer that it actually outputs
154:32 - the address
154:34 - of the memory location that P is holding
154:38 - so over here what we want to do is we
154:40 - want a reference to X now as I've told
154:44 - you
154:46 - P will then be of type reference to an
154:49 - i32 right because X is holding an i32
154:53 - type
154:55 - now a reference to an i32 is basically a
155:00 - pointer to a location in memory that
155:03 - points to this
155:06 - data over here
155:08 - so P here holds a memory address we'll
155:12 - see that when we execute this program
155:17 - as you can see the memory address of X
155:19 - is
155:20 - this
155:22 - so
155:26 - this memory address is where
155:29 - the value 5 is stored in in memory
155:34 - and we are accessing that using a
155:37 - pointer over here
155:39 - again a pointer is just a normal
155:41 - variable which holds a memory address in
155:44 - this case the memory address of x
155:48 - right
155:50 - so this is a reference to X
155:55 - over here again we have variable X
155:58 - holding i32 type and a reference to X
156:02 - which is a reference to an i32 value
156:06 - modify this line again we compare here y
156:11 - with five now y doesn't actually hold
156:15 - the value 5 it holds a memory address
156:19 - now to access the data
156:22 - at which this y pointer here will point
156:26 - to we have to dereference and we do that
156:29 - with the reference operator
156:32 - like that that means go to the location
156:36 - of Y and give me the value right so when
156:41 - we go to the location where X is stored
156:47 - for example at this memory address we
156:49 - want to get the value that is stored at
156:53 - that address
156:54 - we are using
156:55 - here the star operator
156:58 - just to access the value
157:07 - so over here we initialize a variable
157:10 - holding a string type
157:13 - then we are calling the function borrow
157:15 - object
157:17 - and as you can see the borrow object
157:19 - function expects an argument of type
157:22 - reference to a string but what we are
157:26 - here providing is a string right we are
157:29 - providing s which is of type string now
157:33 - we want here to pass a reference to s
157:36 - meaning a reference to string in this
157:40 - case we are complying with the function
157:42 - signature
157:48 - over here again variable s holding a
157:51 - string then we call puster function over
157:55 - here now again we have to always take
157:57 - care of the function signature what is
158:01 - expected so as you can see the argument
158:04 - should be of type mutable reference to a
158:07 - string so we have to pass here a mutual
158:10 - reference to s
158:13 - where s is holding a string right
158:22 - number five again here having a string
158:29 - and
158:30 - as you can see over here we are mutating
158:34 - p
158:36 - so that means we want to have immutable
158:39 - reference
158:40 - to s
158:44 - as you can see p will then hold
158:51 - P will then hold immutable reference to
158:54 - a string type right
158:57 - and then we can mutate the string that P
159:01 - is holding and again because we are here
159:04 - having a reference S will remain the
159:09 - owner of the data meaning we still can
159:12 - use S even after this assignment over
159:16 - here
159:22 - ref can be used to take references to a
159:25 - value similar to ampersand
159:29 - as you can see we have here a variable
159:31 - holding HR
159:33 - and this over here would be a variable
159:36 - which holds a reference to a chart right
159:39 - a reference to C
159:42 - now fill the blank don't change order
159:45 - code now instead of here
159:49 - using the Ampersand symbol we can use
159:52 - the ref keyword and it's exactly the
159:55 - same actually they are very similar
159:57 - there are some minor differences in
160:00 - pattern matching
160:02 - um but we will come to that
160:05 - so when we dereference R1 and R2
160:11 - then this should hold the same
160:14 - data right
160:17 - and over here check the quality of the
160:19 - two address strings
160:22 - so we have here a function get address
160:25 - which gets called with R1
160:28 - and R2
160:31 - now all this function over here does is
160:34 - it takes a reference to HR as an
160:37 - argument and it will
160:41 - then put it inside this format macro now
160:45 - this format macro over here is the same
160:47 - as the print line macro with the
160:50 - difference that the print line will
160:52 - print to the standard output while
160:55 - format will return a string right so we
160:59 - take this argument
161:01 - and then we will
161:04 - return here the memory address of this
161:08 - reference
161:09 - now in this case R1 and R2 should hold
161:12 - actually the same memory address right
161:15 - because they are pointing to the same
161:19 - data this case C so R1 is pointing to C
161:24 - and R2 is pointing to C
161:28 - all right so let's see
161:34 - and this is compiling
161:37 - borrowing rules remove something to make
161:39 - it work don't remove a whole line again
161:42 - here having immutable variable s which
161:45 - holds a string then we have two mutable
161:50 - references to s
161:52 - and this actually would
161:56 - failed to compile because again we can
162:00 - only have one mutable reference at a
162:04 - time so to solve this as you can see
162:08 - over here we are just printing out R1
162:12 - and R2 so this reference over here don't
162:16 - need to be mutable right
162:20 - because it's sufficient that we have a
162:23 - read-only reference to S and again the
162:28 - rule states that we can have as many
162:30 - immutable references as we want
162:38 - so this is compiling and also just to
162:41 - show you
162:53 - when dealing with references over here
162:55 - as you can see s is still valid
162:59 - right
163:03 - error borrow an immutable object as
163:07 - mutable
163:08 - fix the error by modifying this line as
163:11 - you can see we have here a string
163:14 - and we call here borrow object with a
163:18 - mutual reference to S so the problem
163:21 - over here is that we can't pass a mutual
163:24 - reference to something which is
163:26 - immutable so we have to make this
163:29 - variable over here mutable and then we
163:32 - can
163:33 - uh
163:35 - then we can provide here a mutable
163:38 - reference to this variable
163:47 - but the other way around it's no problem
163:50 - okay borrow a mutual object as immutable
163:54 - so this code has no errors as you can
163:58 - see we have here a string
164:00 - and we are passing to the borrow object
164:03 - and immutable reference right
164:07 - now
164:08 - this would actually compile because as
164:12 - you can see the function signature
164:14 - States it should be an immutable
164:17 - reference even though s itself is
164:20 - mutable we can still pass it as an
164:23 - immutable reference this would compile
164:26 - without problems
164:31 - and then over here you can see we are
164:33 - even mutating s because it's mutable
164:40 - comment one line to make it work we have
164:43 - here a string
164:46 - and we have a mutable reference to S
164:49 - right
164:54 - so this would be the type annotation
164:56 - mutable reference to a string type
165:00 - now we are then mutating R1
165:04 - and over here we again have a mutable
165:08 - reference to s
165:16 - and then we are modifying R2 the problem
165:21 - here is that you know the rule that we
165:24 - can only have one mutable reference at a
165:28 - time
165:29 - but as you can see R1 over here gets
165:32 - used again so this should remain valid
165:36 - but we can't have two valid mutable
165:40 - references at the same time so if I
165:43 - comment this out
165:45 - then this program should compile because
165:48 - we are not using R1 after this point
165:51 - meaning we can have another mutable
165:54 - reference
165:56 - and even if I print out here R2
166:01 - this should also compile
166:03 - because over here the only valid mutable
166:07 - reference to S would be R2 because we
166:11 - are not using R1 after this point
166:18 - so over here again we have a string
166:22 - and we have two mutable references to S
166:27 - now if we would run that
166:30 - it would actually
166:32 - compile
166:37 - as you can see the program compiles
166:40 - even though we have two mutable
166:43 - references to S but we are not using any
166:46 - one of these in the program
166:49 - but over here it says add one line below
166:52 - to make a compiler error cannot borrow S
166:55 - as mutable more than once at a time
167:00 - you can't use R1 and R2 at the same time
167:03 - so let's use both of them over here
167:07 - to force this compiler error
167:20 - and as you can see this would be the
167:22 - compiler error we are expecting Canon to
167:25 - borrow S as mutable more than once at a
167:28 - time
167:30 - and over here you can see really the Rus
167:32 - compiler is one of the best compilers
167:35 - I've ever seen because it provides you
167:39 - with really useful compiler messages
167:43 - alright see you in the next topic so we
167:45 - have now reached the topic of compound
167:48 - types now a compound type is a type
167:51 - which is made up of other types for
167:55 - example a string is made up of
167:57 - characters so it's considered a compound
168:00 - type
168:02 - now we have in Rust two types of strings
168:06 - we have string with a capital S string
168:10 - like that and we have string slices now
168:15 - if I say string I will always refer to
168:18 - this type otherwise I will say string
168:21 - slice
168:23 - so a string is a heap allocated string
168:26 - type that owns its contents and is
168:29 - mutable we have seen that a string is
168:32 - allocated in Heap memory
168:36 - a string slice is an immutable sequence
168:39 - of utf-8 bytes in memory it does not own
168:43 - the underlying data and is immutable
168:48 - so think of string slice as a view on a
168:52 - sequence of characters stored as utf-8
168:55 - bytes in memory it's basically just read
169:00 - only
169:03 - so use string slice if you just want to
169:07 - view a string
169:09 - and string slice is more lightweight and
169:12 - efficient than string and U string if
169:16 - you need to own the data and be able to
169:18 - mutate it
169:22 - then we have string literals a string
169:25 - literal is a sequence of characters
169:28 - enclosed in double quotes
169:31 - its fixed size compile time known
169:34 - sequence of utf-8 bytes the type is
169:39 - reference to static string which
169:41 - indicates the data is stored in static
169:44 - storage meaning it is valid throughout
169:47 - the entire lifetime of the program
169:51 - the data is hard-coded into the
169:53 - executable and stored in read-only
169:56 - memory meaning they are immutable
169:59 - so let's now see an example of a string
170:02 - slice and I'm seeing my head is in the
170:04 - way here
170:06 - let's do it like that
170:08 - so let's see
170:10 - over here we are initializing s with a
170:13 - string now again I repeat myself I know
170:17 - but this is very important s doesn't
170:20 - hold the actual data it holds a pointer
170:23 - which points to the data that is that is
170:27 - allocated in Heap memory so s will have
170:31 - a pointer alongside other metadata that
170:35 - will point to the first
170:37 - character of the string
170:41 - and let's now consider this world
170:45 - variable here so we are taking a
170:48 - reference to s
170:50 - meaning s will remain the owner of the
170:54 - Heap allocated string
170:57 - so we are taking a reference to S and
171:00 - providing here an offset
171:02 - from 6 to 11. now I hope you remember in
171:07 - a Range this would be excluded so it
171:10 - would be from 6 to 10.
171:14 - so when we look at the world variable we
171:17 - see that it has a pointer and a length
171:21 - now this length over here is actually
171:23 - false I'm sorry for that this should be
171:26 - the length of the string slice in this
171:28 - case one two three four five so this
171:33 - pointer points to the offset of the
171:35 - string we have provided so it points to
171:38 - index six
171:40 - and it goes to 10 because again 11 is
171:45 - excluded so this world here will hold a
171:50 - string slice of
171:52 - this word
171:54 - right
171:57 - so the string slice World points to a
171:59 - sequence of characters stored on the
172:01 - Heap this is basically just a view into
172:05 - a heap allocated string and that's why
172:09 - it's immutable
172:12 - all right
172:13 - the type of string literal hello world
172:16 - is Ampersand stir for example let s
172:21 - string slice equals hello world now this
172:25 - would be a string literal right because
172:28 - we are
172:29 - hard coding it into the executable
172:34 - and a string literal is also considered
172:38 - a string slice because it's also
172:41 - immutable and it's basically just a
172:44 - reference to the static memory this
172:47 - string gets stored in
172:50 - so store and string slice we can't use
172:54 - Stir type in normal ways but we can use
172:57 - reference to stir
172:59 - fix error without adding new line as you
173:03 - can see this would over here be a string
173:05 - literal we are hard coding this string
173:09 - into the executable into the program
173:13 - itself
173:14 - so again we can't use Stir as a type but
173:18 - we can use a reference to a stir right
173:28 - we can only use Stir by boxing it
173:31 - Ampersand can be used to convert Boxster
173:34 - to string slice now fix the arrow with
173:38 - at least two solutions as you can see
173:41 - over here we have a string literal a
173:44 - string hard coded into the program
173:46 - itself
173:48 - then we call the into method we will
173:50 - cover that later but basically into will
173:54 - convert a type into the type we are
173:57 - annotating here so this string literal
174:00 - will be put into
174:02 - a box meaning it will be Heap allocated
174:06 - then we are calling this greetings
174:09 - function with an argument s
174:13 - and as you can see as this argument over
174:15 - here is has to be of string slice so
174:20 - what we can do over here to convert this
174:23 - box into a string slice is passing a
174:27 - reference to this box
174:36 - as you can see this is compiling but we
174:39 - even can just omit all of this
174:42 - right this photo would be string slice
174:47 - and we then just pass s notice that we
174:51 - don't have to pass a reference to S
174:54 - because s is already the type we need
175:03 - string type is defined in standard
175:06 - library and stored as a vector of bytes
175:09 - back but guaranteed to always be a valid
175:13 - utf-8 sequence string is Heap allocated
175:17 - growable and not null terminated
175:21 - so let's see we want to initialize here
175:24 - s with a string right
175:27 - then we are mutating
175:31 - this string over here and mutate it
175:35 - again now over here we are pushing to it
175:37 - a string literal and over here we are
175:42 - pushing to it a single chart now if you
175:46 - push a single chart you just use the
175:48 - push method not
175:50 - not the push stir method
175:53 - and in the end as should hold hello
175:57 - world now we can initialize here an
176:02 - empty string like that
176:08 - this is now an empty string type
176:14 - now why are we using this type over here
176:17 - and not string slice
176:20 - like so for example
176:26 - why aren't we use why aren't we doing it
176:29 - like that
176:31 - because remember a string slice and
176:33 - string literals are immutable
176:36 - they are just references to some string
176:40 - data in the memory so we have to use
176:43 - string here
176:50 - so we are here initiating an empty
176:53 - string and then we are mutating it and
176:57 - push to its held over and this
176:59 - exclamation mark
177:04 - this compiles let's output the string
177:14 - as you can see
177:16 - the string over here has been mutated
177:21 - and that's the whole point of using this
177:23 - string type over here it can be mutated
177:26 - they can grow and shrink and so on
177:32 - so let's see exercise four fix all
177:35 - arrows without adding new line as you
177:39 - can see over here we have initialized a
177:41 - variable with a string
177:44 - then we are mutating this string over
177:47 - here which means we have to make this
177:50 - variable s here mutable
177:53 - so we are pushing A Single Character
177:56 - this comma and then we are pushing
177:58 - another string like that and we can even
178:02 - push to the string by using this
178:05 - notation here even though I don't like
178:08 - it but it's also possible
178:12 - but over here
178:14 - we have two
178:17 - pass it a string literal because this is
178:20 - defined in this standard Library
178:24 - all right
178:27 - let's see
178:29 - and of course over here sorry we have to
178:32 - use the push stir
178:34 - method
178:40 - as you can see this is compiling so
178:43 - again we are pushing A Single Character
178:46 - then we are using here the push stir
178:48 - method pushing a string literal and we
178:52 - can also mutate strings like that
178:57 - we place can be used to replace
178:59 - substring
179:01 - again we have here a string
179:05 - and we then can replace
179:08 - some elements inside the string
179:11 - so we provide as first argument
179:14 - the element we want to replace in this
179:17 - case dogs
179:18 - and it should be replaced with cats
179:22 - so S1 should then hold I like cats now
179:26 - again replace will mutate the string
179:29 - meaning the S should be mutable
179:35 - foreign
179:39 - methods can be found under string module
179:42 - so number six you can only concat a
179:46 - stream with a string slice and strings
179:48 - ownership can be moved to another
179:51 - variable
179:52 - so we have here S1 holding a string
179:56 - and S2 also holding a string
180:00 - now as you can see we want to
180:02 - concatenate these two strings and we can
180:05 - use the plus operator for that
180:09 - now in the rust documentation it says
180:12 - that the first argument should be of
180:15 - type string while all other arguments
180:18 - must be string slices
180:21 - so we have to convert S2 over here to a
180:24 - string slice now there are two
180:27 - possibilities the first one is using the
180:30 - s store method like that so this over
180:34 - here will then be considered as a string
180:37 - slice
180:42 - so we have converted a string to a
180:46 - string slice
180:47 - right
180:49 - but the output
180:51 - but the result of this concatenation
180:53 - will be of type string it's important to
180:56 - remember that
180:58 - and S3 should then hold this
181:01 - concatenated strings
181:06 - now because S1 over here has been moved
181:11 - inside S3 we can't use S1 anymore
181:14 - because S3 has become the owner of this
181:19 - data
181:20 - so let's instead print out S3
181:27 - and as you can see this is compiling now
181:29 - there is an easier approach to that we
181:33 - can convert a string to a string slice
181:36 - by just
181:37 - by just
181:39 - providing a reference to a string so a
181:43 - reference to a string can be
181:46 - inferred to a string slice like that
181:55 - string slice and string opposite to the
181:59 - seldom using of stir string slice and
182:01 - string are used everywhere
182:04 - swing slice can be converted to string
182:07 - in two ways so we have covered that
182:09 - fixed arrow with at least two solutions
182:13 - so over here we have a string slice
182:17 - right
182:19 - now
182:21 - we call the greetings function over here
182:24 - with an argument of s now s should
182:27 - actually be of type string
182:29 - so we can convert that by calling this
182:33 - two string method like that
182:41 - so we have converted here
182:44 - a string slice to a string
182:48 - all right
182:49 - the second way would be
183:00 - doing it like that string from and then
183:05 - providing s
183:07 - as you as you can see this is compiling
183:11 - and
183:13 - there are other ways for example two
183:15 - ohms even though
183:17 - I think this is not used that much
183:23 - because it's more General but it's also
183:26 - possible
183:32 - right we can use string form or two
183:35 - string to convert a string slice to a
183:38 - string use two approaches to fix the
183:41 - arrow and without adding a new line
183:44 - as you can see we have here a string
183:46 - literal that has been put into a string
183:51 - so this variable over here will hold a
183:54 - type of string
183:56 - now to convert this s over here into a
184:00 - string slice because this is the type
184:02 - annotation of this variable we can as I
184:06 - did before we can pass as as a reference
184:10 - and again
184:15 - a reference to a string will be inferred
184:19 - to a string slice
184:21 - again we can use as stir for example
184:27 - would be the same
184:34 - string escapes you can use escapes to
184:37 - ride bytes by their hexadecimal values
184:40 - fill the blank below to show I'm writing
184:43 - rust
184:44 - so as you can see we can escape
184:48 - certain values and they will then be
184:51 - convert to ASCII characters for example
184:54 - this would be the hexadecimal
184:56 - representation
184:58 - of the ASCII value of s
185:03 - right so if we want to write rust here
185:07 - then the next
185:10 - character to S would be T so we would
185:13 - write
185:14 - X 74.
185:17 - like that
185:20 - and you can check this out over here
185:23 - there are a lot of examples
185:25 - where we can just Escape using the
185:28 - backslash Now using two backslashes here
185:32 - will print out this literal
185:36 - and these literal characters so the
185:40 - output will be backslash x3f okay
185:45 - because we are basically escaping this
185:49 - backslash
185:56 - all right and over here we have raw
185:59 - string and a raw string is a string in
186:02 - which there are no escapes so everything
186:06 - is printed literally as it is written so
186:11 - the output of this let me run that
186:15 - so the output of this would be
186:19 - backslash x3f it won't be converted to
186:23 - an ASCII character
186:26 - so let's see string index you can't use
186:29 - index to access HR in a string but you
186:32 - can use slice
186:34 - reference to a S1 for example and the
186:37 - offset
186:39 - so let's see we have here a string
186:45 - and now we want to access the first
186:47 - character
186:49 - now in most programming languages this
186:52 - would be possible but in Rust you have
186:55 - to use string slices meaning you take a
186:58 - reference to S1 and then provide the
187:02 - offset if we want to only access the
187:05 - first character we would provide an
187:07 - offset in form of a range from 0 to 1.
187:11 - now again in a Range this would be
187:13 - excluded meaning we only access this
187:17 - first element
187:19 - so the return type will then be a string
187:22 - slice notice something here when we
187:26 - assert age we would have a string of H
187:30 - and not a character even though we are
187:33 - here only accessing a character we are
187:36 - accessing it using these string slice
187:41 - this string slice notation over here
187:44 - so remember a string slice is just a
187:47 - view into a heap allocated string right
187:50 - so we are just looking what is at this
187:54 - location
187:55 - in this case we just want to access the
187:58 - first location over here
188:01 - right
188:03 - modify this line to fix the error tips
188:07 - this would take three bytes in utf-8
188:10 - format and that's right we have said
188:12 - that a character in Rust is of size 4
188:16 - bytes now a character in a string is a
188:20 - little bit different so if it is an
188:22 - ASCII a character then it will usually
188:26 - take one byte and DC Unicode characters
188:30 - can take three bytes or I guess some of
188:33 - them even four bytes
188:36 - all right so we want to have in H1 only
188:40 - this character
188:42 - so again we are taking a reference to S1
188:45 - and providing an offset oh
188:48 - 8 would be at index 0 I would be at
188:51 - index 1 this comma index 2 and then this
188:56 - will be index 3. now this takes up three
188:59 - bytes so we have to provide here an
189:02 - offset from three to six remember six is
189:06 - excluded so it goes from three to five
189:09 - three four five three bytes
189:17 - let me output that
189:25 - as you can see this would be the output
189:29 - and again this is just a view into a
189:34 - heap allocated string right
189:40 - operate on utf-8 string fill the blank
189:43 - to print each character in this string
189:46 - so over here there is a method called
189:50 - chores
189:53 - now chores will put this sequence of
189:56 - characters into an iterator meaning we
190:00 - can then iterate over it using a for
190:03 - Loop for example
190:04 - and that means
190:06 - c will then be in each iteration one of
190:10 - these characters and we will then just
190:13 - find out C
190:17 - as you can see in each iteration we are
190:20 - printing out a single character alright
190:24 - that's it see you in the next topic so
190:27 - we'll Now cover arrays now an array is a
190:31 - fixed size collection of elements of the
190:34 - same data types stored as contiguous
190:36 - Block in stack memory now it's stored in
190:40 - stack memory because its size is known
190:43 - at compiled time
190:45 - the signature of an array is like that
190:49 - you can see over here
190:50 - which indicates that the length is fixed
190:54 - at compile time arrays can neither grow
190:57 - nor shrink they must retain their size
191:01 - so let's see
191:03 - the type of array is like this as you
191:07 - can see erase length is part of their
191:10 - type signature so their length must be
191:13 - known at compiled time for example you
191:16 - can't initialize an array like below
191:19 - this would not be possible as you can
191:22 - see we have an init R function which
191:25 - takes an argument of type i32 and then
191:29 - we try over here to initialize an array
191:32 - with
191:35 - the length that is provided as an
191:38 - argument
191:39 - this would be and compiler error because
191:42 - as we've seen the size of an array must
191:45 - be known at compiled time if we do it
191:49 - like that the size of the array would
191:51 - only be known at runtime this will cause
191:54 - an error because the compiler has no
191:57 - idea of the exact size of the array at
192:00 - compile time let's see fill the blank
192:03 - with proper array type
192:05 - as you can see we have here an array
192:08 - with five elements now what would be the
192:12 - type of these elements it would be the
192:15 - default integer type which is i32
192:19 - so we annotate arrays like that in
192:23 - square brackets then we would have to
192:26 - type of the elements
192:28 - and the amount of elements inside of the
192:33 - array which is five
192:35 - modify the code below to make it work so
192:39 - we can call the Len method on an array
192:42 - and it will then provide the length of
192:45 - the array
192:47 - so in this case this would be 5 right
192:50 - because there are five elements inside
192:56 - number two we can ignore parts of the
192:59 - array type or even the whole type let
193:02 - the compiler infer it for us
193:05 - so we actually don't have to annotate
193:08 - the type or we can annotate the type but
193:11 - leave
193:12 - for example the type annotation here for
193:16 - the compiler to infer
193:19 - fill the blank arrays or stack allocated
193:22 - size of well returns to bytes which in
193:25 - Array occupies HR takes four bytes in
193:29 - Rust Unicode Char so we have seen that
193:32 - before the size of well we'll just take
193:34 - an argument and it will output the size
193:38 - in bytes
193:40 - the provided argument occupies in memory
193:44 - so if we provide the r over here then we
193:49 - should actually get back
193:51 - 3 times 4 bytes because because a
193:56 - character in Rust takes four bytes
193:58 - meaning
194:01 - this array over here would occupy 12
194:05 - bytes in memory
194:13 - all elements in an array can be
194:15 - initialized to the same value at once
194:19 - so as you can see we have here an array
194:22 - which should hold 100 elements
194:27 - and each element should hold the number
194:30 - one okay we are here accessing the first
194:34 - element
194:35 - and this is the notation for accessing
194:40 - elements in an array in this case we
194:42 - access the first element at index 0.
194:47 - until length would be 100 so instead
194:55 - of typing out 100 times 1 we have a
195:00 - short 10 Syntax for that
195:02 - so we can here first of all provide the
195:06 - element it should hold in this case one
195:09 - and we want it to hold 100 elements of
195:14 - this value over here
195:28 - number four all elements in an array
195:30 - must be of the same type
195:34 - so as you can see because when we
195:36 - annotate an array we actually have to
195:40 - define the type here
195:43 - in this case we want integer types and
195:46 - we have three of them now as you can see
195:48 - this is a torrent this is not possible
195:52 - all elements inside an array must be of
195:56 - the same type
196:03 - indexing starts at zero so over here we
196:07 - have an array of characters let's
196:10 - annotate that
196:14 - and there are three elements inside it
196:17 - and now we want to access the first
196:21 - element right
196:23 - we want this variable over here to hold
196:26 - the first element now again arrays our
196:29 - zero indexed meaning we access it using
196:33 - this notation here and provided a value
196:37 - of 0.
196:45 - out of bounds indexing causes panic so
196:49 - over here we have an array
196:51 - which holds two strings
196:56 - and we want to
196:58 - access the first element right
197:02 - now we can use this notation over here
197:05 - like we did before or we could use the
197:09 - get method the difference is that get
197:12 - will return an option type we'll cover
197:15 - that in a later episode but it's
197:18 - generally safer than using this notation
197:22 - and this is especially true if you're
197:27 - accessing elements at runtime okay
197:31 - so
197:33 - we can use this notation or we could use
197:36 - this notation now over here this would
197:39 - panic because this array has only two
197:43 - elements meaning indexes 0 and 1. so
197:47 - let's access here index one
197:55 - and this compiles
197:59 - so let's see slices a slice is a
198:02 - reference to a contiguous sequence of
198:05 - elements in a collection it provides a
198:08 - way to borrow part of a collection
198:10 - without taking ownership of the entire
198:14 - collection it can be created from arrays
198:17 - vectors strings and other collections
198:20 - implementing DT ref trade
198:25 - so let's see this example of a slice we
198:29 - have here an array and then we are over
198:33 - here taking a reference to a and
198:37 - providing an offset
198:39 - essentially the same thing we did with
198:43 - string slices right a slice is just a
198:47 - view into a collection
198:51 - and over here we try to access the
198:53 - elements at index 1 to index two right
198:58 - because 3 would be excluded
199:02 - so the variable slice will then hold a
199:04 - slice with the elements 2 and 3 in it
199:09 - all right let's see slices are similar
199:13 - to arrays but their length is not known
199:15 - at compiled time so you can't use slice
199:18 - directly
199:20 - here both this slice over here and store
199:24 - or slice types but directly using it
199:28 - will cause errors you have to use the
199:30 - reference of this slice instead so
199:33 - because these two slices over here
199:37 - their sizes are not known at compile
199:40 - time we have to use a pointer to that
199:43 - right
199:45 - and we have seen that in the example of
199:48 - string slices
199:49 - so we use this syntax over here
199:53 - fix the arrows don't add new lines
199:57 - as you can see we are holding here an
199:59 - array let's annotate the type
200:04 - like that
200:06 - this is an array of three i32 integers
200:10 - now we want here to get a slice with
200:15 - this offset meaning from 0 to 1 0 1.
200:21 - so again like we did with a string slice
200:23 - we want a reference to an array
200:27 - with this specific offset so we are
200:31 - trying to access 0 to 1 because 2 is X
200:34 - because 2 is excluded meaning we are
200:38 - accessing here index 0 and 1. the
200:42 - elements one and two so this slice over
200:45 - here
200:46 - will then hold one and two right
200:51 - now the type annotation here would be
200:54 - like that because we are holding a
200:56 - reference to this array right and this
201:01 - would be the type annotation of a slice
201:08 - now over here we have a string later on
201:11 - now
201:13 - string literals as we've seen always are
201:17 - annotated like that
201:20 - string literal is hard coded into the
201:23 - program's binary and that's why we can
201:27 - access it using a reference
201:30 - to this string literal over here which
201:33 - is in the binary itself
201:36 - all right
201:43 - a slice reference is a two word object
201:46 - for Simplicity Reasons from now on we
201:49 - will use slice instead of slice
201:51 - reference the first word is a pointer to
201:55 - the data and the second word is the
201:57 - length of this slice the word size is
202:01 - the same as U size determined by the
202:04 - processor architecture for example 64
202:07 - bits on an
202:09 - x8664 slices can be used to borrow a
202:13 - section of an array and have the type
202:16 - signature
202:18 - like this
202:20 - where T over here stands for the type
202:25 - as you can see we have here an array
202:27 - with three characters
202:30 - now we want to have a slice of this
202:34 - array with
202:36 - the first two elements these two
202:40 - elements
202:41 - and this is shorthand notation instead
202:45 - of writing it like that we can just omit
202:48 - the zero
202:49 - all right so we are accessing 0 1 and 2
202:54 - is excluded
203:04 - so the slice variable should hold a
203:07 - slice with these elements
203:10 - the type annotation over here would be
203:12 - reference
203:14 - to char
203:16 - okay
203:19 - modify 8 to make it work tips slice
203:23 - reference is not an array if it is an
203:26 - array then assert will be packed each of
203:29 - the two characters this and this
203:32 - occupies four bytes 2 times 4 8.
203:37 - now because this slice variable over
203:41 - here doesn't actually hold an array but
203:44 - a slice
203:45 - we are here actually holding a pointer
203:49 - right because this is a reference to
203:52 - this array
203:54 - and that means we have seen over here A
203:57 - Slice reference is a two word object
204:01 - meaning the pointer and the length field
204:06 - will both occupy sizes of Type U size
204:11 - and your size
204:13 - if you're on a 64-bit computer it means
204:17 - you size will be of size 8 bytes or 64
204:21 - bits
204:23 - and that's why a slice holds
204:27 - 16 bytes
204:30 - right
204:31 - if we would pass the array here we would
204:34 - have
204:39 - if this slice would have been an array
204:41 - then 8 would actually pass because we
204:44 - would have two characters each character
204:47 - is four bytes meaning eight bytes but
204:51 - because we have a slice which holds a
204:54 - pointer and a length both of Type U size
204:57 - we have 16.
205:02 - so over here we have an array of five
205:05 - integers of type i32
205:08 - fill the blanks to make the code work as
205:12 - you can see we want the slice variable
205:14 - to hold a slice of these elements
205:19 - so
205:20 - let's first
205:22 - annotate the type actually so this slice
205:25 - variable over here should hold a slice
205:29 - of I 32 elements right so we are taking
205:36 - a reference to the array and provided an
205:39 - offset we want to go from this to this
205:44 - meaning index 0 1 we are starting at 1
205:49 - and we go up to 0 1 2 3 4.
205:57 - and I choose 4 here because 4 is
206:00 - excluded so we will go from 0 1 2 3 to
206:06 - index 3.
206:13 - string slices
206:15 - and we've covered that already but let's
206:18 - do some exercises for repetition now
206:22 - over here we have a string and we take
206:25 - over here a string slice
206:29 - meaning we take only
206:32 - the first two characters
206:44 - like that
206:46 - or let me write
206:52 - like like that right we take the first
206:54 - two characters
206:56 - fill the blank to make the code work
206:59 - don't use 0 to 2 again
207:02 - so over here we have a second variable
207:06 - which should hold a string slice and
207:09 - they should actually hold the same
207:11 - elements as you can see over here we are
207:14 - we are here asserting that slice one and
207:17 - slice two are the same
207:20 - so instead of using this syntax over
207:23 - here as we've seen before we can use
207:25 - like that we can omit t0
207:30 - over here we have a string literal
207:34 - again a string literal is hardcoded in
207:37 - 2D binary and this would be the type
207:39 - annotation
207:41 - modify this line to make the code work
207:44 - as you can see we want slice over here
207:48 - to hold
207:50 - a string slice with only this character
207:56 - so let's annotate the type this would be
207:58 - a string slice and because this Unicode
208:02 - character over here takes three bytes we
208:05 - have to provide an offset here of three
208:08 - meaning
208:09 - zero one two right three bytes
208:19 - alright last one number six a reference
208:23 - to a string can be implicitly converted
208:26 - into a string slice
208:28 - now over here we initialize a variable s
208:31 - which holds a string
208:35 - here reference to S is reference to
208:38 - string type but first word needs aced
208:42 - but first word needs a string slice as
208:46 - you can see over here
208:48 - it works because reference to string can
208:51 - be implicitly converted to string slice
208:54 - so as you can see over here we are
208:57 - calling the first word function which
209:00 - takes us an argument a type of string
209:02 - slice
209:04 - and
209:05 - this would actually work because we are
209:09 - here providing a reference to S which
209:12 - means this over here is
209:15 - a reference to a string right
209:19 - and
209:20 - a reference to a string can be converted
209:23 - to a string slice implicitly by the
209:27 - compiler
209:29 - so then this function over here will
209:31 - take a reference
209:33 - of s
209:36 - and provides an offset from 0 to 1 where
209:40 - 1 is excluded so we just so we just take
209:44 - the first element
209:47 - and it returns this as a string slice
209:50 - that means that the return value of this
209:54 - function will be assigned to the word
209:56 - variable
209:59 - then over here we are calling the clear
210:01 - method on S which means this string will
210:06 - then be empty clear will just remove
210:08 - every content in the string the string
210:11 - itself will still remain in memory with
210:14 - the same capacity and S also is valid so
210:19 - it's different from drop but it will
210:22 - empty the string essentially
210:25 - so we will then have over here an empty
210:28 - string
210:30 - the problem over here is that clear
210:32 - takes immutable reference to self
210:37 - and
210:39 - that's a problem because over here we
210:41 - have a reference which is immutable to S
210:46 - and we have over here immutable
210:48 - reference to us
210:51 - now
210:52 - the problem arises because we are here
210:55 - using the immutable reference so if we
211:00 - would delete that and put it over here
211:04 - then
211:05 - after this point the word variable over
211:09 - here which holds an immutable reference
211:12 - is not used anymore and so we can use
211:17 - this clear method
211:24 - and this is compiling and as you can see
211:26 - we just get the first element
211:32 - alright see you in the next topic
211:35 - now we will cover tuples we have seen
211:38 - some tuples before and some exercises
211:40 - but now we will go into greater detail
211:44 - so a tuple is a way to store related
211:47 - pieces of information in a single
211:50 - variable and it's essentially a
211:52 - collection of values of different types
211:55 - grouped together as a single compound
211:58 - value again a compound value is a type
212:02 - composed of other types
212:05 - it's stored as a fixed size contiguous
212:08 - block of memory on this stack and the
212:11 - signature is parentheses and the types
212:16 - the Tuple is holding
212:20 - let's see
212:21 - elements in a couple can have different
212:24 - types pupils type signature is like that
212:28 - where T1 T2 are the types of tuples
212:33 - members
212:34 - so as you can see we can hold different
212:37 - types we have here an u8 and an i16
212:42 - together in a tuple
212:46 - tuples can be tuples members so we can
212:50 - even Nest tuples so this Tuple over here
212:55 - as you can see
212:57 - holds an u8 over here
213:01 - and another Tuple inside it which holds
213:06 - an i16 and a u32 integer
213:10 - all right
213:12 - fill the blanks to make the code work
213:16 - so over here we have to annotate the
213:19 - type now again the first element over
213:22 - here would be u8 the second one is u16
213:29 - the third one is an I64
213:33 - the fourth one would be a string literal
213:40 - and the last one is a string
213:49 - members can be extracted from the Tuple
213:52 - using indexing
213:55 - so as you can see we have here a tuple
213:58 - let's annotate the type
214:00 - this is how we would annotate a tuple
214:04 - and it holds
214:05 - three string literals
214:10 - then we are accessing here the second
214:14 - element tuples remember are zero indexed
214:18 - but in this case it would be M but we
214:22 - want it to equal sulfates so we have to
214:25 - access
214:27 - d
214:29 - index 2 right 0 1 2.
214:38 - long tuples cannot be printed so
214:42 - if a tuple exceeds a certain amount of
214:46 - elements it is too long to be printed
214:53 - as you can see this would be too long
214:57 - if I delete that over here
215:03 - so this would work so we can have up to
215:06 - 12 elements in a tuple to make it
215:09 - printable
215:11 - if it exceeds 12 elements you can still
215:14 - use it but it's not printable
215:17 - the structuring Tuple with pattern
215:22 - so let's first annotate the type of this
215:24 - Tuple here
215:26 - we have an i32
215:29 - the default integer type then we have a
215:31 - float
215:32 - which means f64 the default floating
215:35 - Point type and we have a string literal
215:40 - fill the blank to make the code work
215:43 - so over here we want to destructure this
215:47 - Tuple where X holds one y holds hello
215:52 - and that holds 6.4
215:56 - so let's see
216:00 - re-distructure tuples like this using
216:03 - the let keyword and the parentheses
216:07 - then
216:08 - the first element should be X right
216:13 - now the second element 6.4 should be put
216:16 - into Z
216:20 - and the last element should be
216:23 - destructured into variable y
216:31 - the structural assignments over here we
216:34 - are declaring some variables and then
216:37 - over here we destructure this Tuple and
216:40 - we want to put it inside these variables
216:44 - so we can so because we have already
216:47 - declared these variables we don't need
216:50 - to declare it once more so we can omit
216:53 - the LED keyword
216:55 - and then
216:57 - all we do is we destructure it so one
217:02 - should be put inside variable y
217:06 - 2 should be put inside variable Z
217:11 - and 3 should be put inside variable X
217:19 - tuples can be used as function arguments
217:23 - and return values
217:25 - fill the blank need a few computations
217:28 - here
217:30 - so
217:34 - so as you can see we are calling this
217:37 - function some multiply and this function
217:40 - over here expects an argument of type
217:43 - Tuple and the Tuple should hold two
217:47 - integer values what we do over here is
217:51 - we perform some operations and return it
217:54 - in a tuple right so
217:58 - so the first operation will be this one
218:01 - adding the first element of the provided
218:05 - Tuple with the second element of the
218:07 - provided Tuple
218:09 - and then we are multiplying the first
218:12 - element of the provided Tuple with this
218:15 - second element of the provided Tuple and
218:18 - we return that in a tuple again so the
218:23 - result of this operation over here will
218:25 - be the first element
218:27 - and the result of this operation will be
218:30 - the second element and as you can see we
218:32 - and as you can see we can return that in
218:36 - a tuple
218:37 - now after returning this Tuple we
218:41 - destructure it so the first element will
218:44 - be put in X and the second element will
218:48 - be the structured to the variable Y
218:50 - where X will hold 5 and Y will hold 6.
218:56 - so we have now to provide here two
218:59 - numbers when we add them together they
219:02 - will equal they will evaluate to five if
219:06 - we multiply the two numbers they will
219:09 - evaluate two six so this is a little
219:12 - riddle for you and try to solve it
219:17 - and the answer would be
219:20 - 2 3 right and don't forget to add here
219:25 - parentheses because we are passing it
219:28 - here a tuple right we are not passing
219:32 - two arguments we are passing one
219:35 - argument which is a tuple that holds two
219:38 - elements very important
219:42 - so if we add 2 and 3 we will get 5 and
219:46 - if we multiply two times three we will
219:49 - get six and this will be the return type
219:52 - of this Tuple over here
220:01 - all right see you in the next topic
220:03 - up until now we have been using types
220:06 - that are defined in this standard
220:08 - library but we can in fact create our
220:11 - own types
220:12 - and we can do that by using a struct now
220:17 - a struct is a compound type allowing to
220:19 - group together values of different types
220:22 - into a named data structure
220:25 - it's similar to tuples but each value
220:28 - has a name so the values can then be
220:31 - accessed through this name
220:33 - and a struct has to be instantiated with
220:36 - data think of it like destruct itself is
220:40 - the template for the instances you
220:42 - create from it
220:46 - now let's see how that works
220:49 - as you can see over here we have our
220:52 - template in this case a struct named
220:55 - user and the user struct holds various
220:59 - fields and we can define a field by
221:02 - giving it a name and a type that this
221:06 - field should hold so in this case the
221:08 - active field holds a type of Boolean
221:11 - username holds a type of string email
221:14 - string and sign in count u64 and then we
221:19 - can instantiate this struct and we do
221:22 - that by calling the name of destruct
221:24 - user in this case and providing for each
221:29 - field a concrete type
221:33 - and of course the types have to match
221:35 - the template
221:36 - then we are assigning this instance we
221:40 - have created over here to a variable so
221:43 - this variable will then hold an instance
221:46 - of the user struct
221:50 - and we can access and even mutate the
221:53 - fields of an instance so over here as
221:57 - you can see we have created an instance
221:59 - and assigned it to the user1 variable
222:03 - and then we can use this syntax over
222:05 - here to access a field
222:08 - so in this case we are even mutating the
222:13 - email field from the instance user 1. as
222:17 - you can see we do that exactly like we
222:20 - would mutate a variable
222:23 - just assigning it a new value
222:26 - now to mutate you have to make it
222:29 - explicitly mutable meaning you use the
222:33 - mute keyword here like you did with
222:35 - variables
222:37 - and functions can also create instances
222:41 - and return it so in this case we have
222:44 - the build user function which creates an
222:47 - instance of the user struct and as you
222:50 - can see again it's just providing
222:53 - concrete values for each of its fields
222:57 - and over here as you can see this
223:00 - function takes two arguments email of
223:03 - type string and username of type string
223:06 - and then it provides it 2D username
223:11 - field and to the email field
223:14 - now in this case we are repeating
223:16 - ourselves as you can see and we can
223:19 - avoid this by just using this shorthand
223:22 - syntax
223:23 - so if the name of a field and the name
223:27 - of a variable or argument matches then
223:30 - we can write it like that and this just
223:34 - makes it less verbose
223:37 - and there is also a concept called
223:40 - struct update syntax so over here we
223:43 - have an instance of the user struct now
223:47 - we want to create another instance but
223:50 - taking some of the values from the
223:53 - fields from user 1. as you can see for
223:56 - example in this instance we want the
223:59 - active field to hold
224:01 - the value of user 1's active field
224:06 - so we are accessing user 1 and the
224:09 - active field
224:10 - and as you can see we are taking
224:13 - everything from this user one instance
224:16 - except the email
224:19 - and
224:21 - as I've said there is a better way to
224:24 - write this and this would be
224:26 - instantiating a struct like we did
224:29 - before but just providing the fields
224:31 - that are different from the instance we
224:35 - we want to take from it
224:38 - so for example over here we say that the
224:42 - email field should hold this value
224:44 - and the remaining values should be taken
224:47 - from this user 1 instance so this will
224:51 - then create a user instance
224:55 - with all the same values from user 1
224:58 - except the email field
225:03 - then we also have Tuple structs and
225:07 - Tuple structs are like normal structs
225:10 - but using tuple-like Syntax for defining
225:13 - their fields it's basically a named
225:16 - Tuple and it's instantiated by
225:19 - parentheses instead of curly braces and
225:24 - its values are accessed using Point
225:27 - notation
225:29 - and then we have unit-like structs and
225:33 - these are structs without any Fields
225:35 - meaning they don't hold any values
225:38 - and it's mainly used when working with
225:42 - trades and this will be covered soon
225:44 - and that means they don't store any data
225:50 - let's solve some exercises the types of
225:53 - structs
225:54 - exercise one we must specify concrete
225:57 - values for each of the fields in
226:00 - destruct
226:01 - as you can see we have here a person
226:04 - struct holding various fields
226:08 - and then over here we have a variable H
226:12 - which holds a value of 30. now then we
226:16 - are instantiating this person's struct
226:20 - and assign it to the variable P meaning
226:23 - P will then be an instance of the
226:26 - person's struct
226:28 - now as you can see we have here the
226:30 - fields and the concrete values
226:34 - and this would be the shorthand Syntax
226:37 - for this because we have over here a
226:41 - variable matching the name of the field
226:45 - so we can write it like that
226:48 - but as you've noticed we didn't provide
226:51 - the hobby field a concrete value so when
226:55 - you are instantiating a struct you have
226:58 - to provide to each field a concrete
227:02 - value so let's do that
227:13 - and the variable P will then hold a type
227:16 - of person
227:18 - now h of course has to match with the
227:21 - templates so this would be an u8
227:25 - [Applause]
227:35 - and of course
227:37 - we use commas here and not say me colons
227:43 - all right
227:44 - unit struct doesn't have any field it
227:48 - can be useful when you need to implement
227:49 - a trade on some type but don't have any
227:53 - data that you want to store in the type
227:56 - itself
227:57 - so as you can see this example is using
228:01 - trades and we have and we have not yet
228:04 - covered that so I will skip that because
228:07 - this might just be confusing and we will
228:12 - cover that soon
228:16 - number three Tuple truck looks similar
228:19 - to tuples it has added meaning this
228:22 - track name provides but has no named
228:25 - fields
228:25 - it's useful when you want to give the
228:28 - whole Tuple a name but don't care about
228:31 - the fields names
228:35 - so as you can see over here we have two
228:38 - Tuple structs one color and one point
228:42 - and they are exactly like tuples but
228:45 - they are named okay so over here we have
228:49 - three integer values in the color Tuple
228:53 - struct and in the points rack the same
228:56 - thing now we want to instantiate the
229:00 - point struct over here
229:02 - and the variable V will then hold an
229:05 - instance
229:06 - of our custom type point
229:11 - then we are calling the check color
229:14 - function and provide an argument of B
229:18 - now as you can see
229:20 - the check color function
229:23 - takes an argument of type color but this
229:27 - is not what we want right because we are
229:29 - here passing a variable of type point so
229:33 - let's change that
229:37 - and over here we are then destructuring
229:40 - the instance
229:42 - that was passed so in this case as you
229:46 - can see X should hold zero so let's
229:49 - provide this value over here
229:52 - then the P1 field and as you can see we
229:56 - are accessing
229:58 - the fields in the Tuple struct like we
230:01 - would access elements in a normal Tuple
230:04 - using this syntax so over here we are
230:08 - accessing the second element and this
230:11 - should hold 127.
230:15 - so that means the last element should
230:17 - hold 255.
230:21 - and
230:24 - as you can see over here we are
230:26 - destructuring
230:28 - so the first element over here gets this
230:31 - structured into a variable X
230:34 - now the second one over here we don't
230:37 - need to destructure right because we are
230:40 - accessing it directly using the PE
230:43 - instance
230:46 - and the last one let's call this Z okay
230:52 - and by the way when destructuring and
230:55 - you don't need a value like for example
230:57 - this one you just provided an underscore
231:02 - let's see
231:08 - and of course when the structuring we
231:10 - have to provide the name of this truck
231:13 - in this case point
231:17 - and this is compiling
231:20 - operating on structs you can make a
231:23 - whole struct mutable when instantiating
231:26 - it but rust doesn't allow us to Mark
231:28 - only certain Fields as mutable
231:33 - fill the blank and fix the arrow without
231:36 - adding removing new line
231:39 - again we have the person struct we have
231:42 - here the age variable
231:45 - let's annotate that and we have the P
231:48 - instance
231:51 - so as you can see we want to mutate the
231:55 - age field of the P instance
231:58 - and this is right but the problem is the
232:02 - P instance is not mutable so let's make
232:05 - that mutable
232:07 - and then we can also mutate the name
232:11 - field like that
232:19 - using field initial shortened syntax to
232:22 - reduce repetitions
232:25 - so again we have the person struct and
232:29 - in main we are just printing out
232:31 - something and over here we have the
232:34 - build person function so as you can see
232:37 - this function takes two arguments name
232:40 - of type string and H of type u8
232:44 - and these arguments exactly match the
232:48 - types defined in the template
232:51 - so then we can over here instantiate a
232:55 - person struct
232:56 - meaning we can hear for the name field
233:00 - provide this argument
233:03 - [Applause]
233:04 - and we have seen we can use field image
233:07 - for 10 syntax meaning if the field name
233:10 - matches the name of a variable or an
233:13 - argument we can skip it like that
233:20 - let's see exercise 6 you can create an
233:23 - instance from another instance with
233:25 - struct update syntax so as you can see
233:28 - we have here the user struct and we have
233:31 - seen an example of that in these slides
233:34 - then over here we are creating an
233:37 - instance from the user struct
233:40 - that means the variable U1 will then
233:43 - hold an instance
233:45 - that means that the variable U1 will
233:47 - then be an instance of the user type and
233:51 - again we are just providing each field
233:53 - over here with a concrete value
233:56 - then over here
233:58 - we call the set email function with an
234:02 - argument of the U1 instance
234:06 - so let's see over here as you can see in
234:08 - the function signature the argument must
234:12 - be of type user
234:14 - and then we want to create over here a
234:17 - new instance
234:19 - and what we want to achieve here is that
234:22 - we take everything
234:24 - and what we want to achieve here is that
234:27 - we take every field from the U1 instance
234:30 - except for the email field we want to
234:34 - we want that to be different
234:37 - so what we can do is providing a
234:40 - concrete value for the email field and
234:44 - then just saying the rest we want to
234:46 - take from the argument provided
234:51 - and then we are just returning it
234:55 - so that means U2 will then hold a newly
234:59 - created instance
235:07 - Point distracts we can use derive debug
235:10 - to make a struct printable click fill
235:13 - the blanks to make the code work so you
235:16 - actually can't print out a struct using
235:20 - the normal print line syntax
235:23 - we have to
235:25 - so to be able to print a struct we have
235:28 - to derive a trade again we will cover
235:32 - trades but we have to derive that
235:37 - using an attribute all right that means
235:41 - that destruct rectangle here
235:45 - implements this debug trade and that
235:49 - means we can then use debug notation to
235:52 - print it out
235:53 - so over here as you can see we have a
235:57 - variable scale
235:59 - and then we are creating here a
236:01 - rectangle instance
236:03 - so we are providing a concrete value for
236:07 - the
236:08 - field with
236:10 - and this would be 30 times the scale
236:15 - and we provide a concrete value for
236:18 - height now as you can see print debug
236:21 - info to standard error and assign the
236:24 - value of 30 times scale to width
236:29 - now this debug macro over here will just
236:32 - print out debug information to the
236:35 - standard error output
236:39 - and
236:40 - that means over here rect one will then
236:44 - hold an instance of the type rectangle
236:48 - and the type annotation for the scale
236:51 - variable over here would be u32
236:55 - right because we are passing this scale
236:58 - variable over here meaning it should be
237:02 - of Type U 32.
237:04 - and then again we are here
237:07 - using the debug macro and printing out
237:10 - racked one and instead of doing that we
237:14 - can also use a normal print line
237:16 - statement
237:17 - like you're used to except that in the
237:21 - placeholder over here we have to use
237:23 - this notation and this is called debug
237:26 - notation
237:28 - meaning any type that implements the
237:30 - debug trade can then be printed
237:37 - and the difference between debug macro
237:40 - and printland macro as you can see print
237:43 - line will point to the standard output
237:45 - while debug will print to the standard
237:48 - error and that's why you don't see it
237:51 - over here you just see the print line
237:54 - output
237:55 - now to see that
237:58 - [Applause]
237:59 - I will go to the rust playground
238:09 - and we can just run this code
238:16 - and as you can see over here this would
238:19 - be
238:20 - the debug output
238:23 - so this debug macro over here prints out
238:27 - the exact thing we are passing to the
238:32 - width field in this case 60. and this
238:37 - debug macro over here points out
238:39 - the instance right we then have an
238:42 - rectangle with a width of 60 and a
238:46 - height of 50. basically the same thing
238:49 - that we print out with the print line
238:52 - statement here
238:55 - foreign
239:01 - move within the destructuring of a
239:04 - single variable both by move and by
239:06 - reference pattern bindings can be used
239:09 - at the same time doing this will result
239:12 - in a partial move of the variable which
239:15 - means that parts of the variable will be
239:17 - moved while other parts stay in such a
239:21 - case the parent variable cannot be used
239:24 - afterwards as a whole however the parts
239:27 - that are only referenced and not moved
239:30 - can still be used
239:32 - and I guess we have seen that before but
239:35 - let's do another exercise
239:38 - so as you can see
239:40 - right we have seen that
239:42 - alright so let's move to the exercises
239:45 - directly because I've already covered
239:48 - that
239:48 - and I think the exercises are better for
239:52 - understanding so as you can see fix the
239:55 - arrows to make it work over here we have
239:58 - a file struct holding two fields of type
240:02 - string
240:05 - then in main we are creating an instance
240:08 - of the filed struct providing it
240:10 - concrete values for each field meaning F
240:14 - will then hold an instance of the file
240:18 - struct
240:20 - and over here we are then assigning the
240:24 - name field of the F instance to the
240:27 - underscore name variable
240:30 - so what would be the type annotation
240:32 - here
240:34 - it would be string right because F name
240:38 - holds a string
240:41 - and that means the name variable here
240:44 - will become the owner of this string
240:49 - data
240:50 - and that is the reason that we then
240:53 - cannot use f as a whole and also not F
240:57 - dot name because a partial move happened
241:03 - so if a field gets moved out to another
241:07 - owner then you can't access this field
241:11 - and also not the data structure that is
241:14 - holding this field
241:16 - so this would fail over here and this
241:20 - would fail now to fix that we can
241:23 - actually access
241:26 - just the name variable here right
241:29 - because this is now the owner of this
241:32 - string
241:34 - but what we can't do is accessing the
241:38 - whole instance over here this is not
241:40 - possible
241:48 - as you can see this is working
241:52 - now
241:53 - if you actually want to keep f as the
241:57 - owner of all the fields
241:59 - and to print it out like that
242:08 - and by the way notice again when we are
242:11 - outputting
242:13 - a single field we used in normal
242:15 - notation if we output the whole instance
242:18 - then we have to use debug notation
242:21 - because these fields over here hold
242:23 - types that are defined in the standard
242:26 - Library while this is a custom type we
242:30 - have created
242:31 - so to make that work we can also use
242:35 - here the Clone method
242:42 - and as you can see this is working and
242:45 - we are here printing out the instance
242:49 - all right see you in the next topic
242:54 - we can also create custom types using
242:57 - enums now an enum is a way of defining a
243:00 - type with only one of a possible set of
243:04 - values we can only access one variant of
243:07 - an enum at a time
243:10 - and it can hold additional information
243:13 - using tuples
243:15 - and it's especially useful when using in
243:19 - match statements
243:22 - let's see an example of an enum so we
243:25 - have here the enum IP address
243:29 - and this enum holds two variance so in
243:33 - enums we call it variance and not Fields
243:36 - like instructs
243:37 - and each variant over here holds a type
243:43 - using tuple-like syntax all right so an
243:48 - IP address by the way can be in either
243:50 - one of two formats either it's V4 or B6
243:55 - and now we will see the difference
243:58 - between enums and structs so this is how
244:02 - we would instantiate this enum IP
244:05 - address
244:06 - we are accessing the name of the enum
244:10 - double colon and then the name of the
244:13 - variant in this case V4 then providing
244:17 - it a concrete value
244:20 - I hope you noticed the difference
244:23 - in a struct we would have
244:26 - provided concrete values for each field
244:30 - in an enum we instantiate the enum only
244:34 - with one single variant all right
244:39 - so this home variable will then hold an
244:42 - instance of the IP address enum
244:47 - and this loopback variable over here
244:50 - will also hold an instance of IP address
244:53 - but using the variant V6
244:58 - and by the way this is the old format of
245:01 - IP addresses ntcc new one
245:07 - so let's do some exercises enums can be
245:10 - created with an explicit discriminator
245:13 - so enums are enumerated right that's why
245:19 - they are called enum now if you don't
245:23 - provide here a value it will be
245:26 - implicitly starting from zero
245:30 - this would be one and this would be two
245:33 - and we can also enumerate them with an
245:37 - explicit discriminator okay so this will
245:41 - then hold zero this variant will be one
245:44 - and this will be two
245:47 - and over here you can see C like enum
245:51 - now you can't use as a discriminator a
245:55 - floating point value this is not allowed
246:00 - but like in C if you for example would
246:04 - do it like that
246:09 - we are here providing the discriminator
246:11 - 5. then
246:15 - 1 and 2 implicitly will be six
246:20 - and seven
246:22 - right or we could say
246:25 - this should be 9 for example
246:29 - right
246:30 - so you can manipulate the enumeration of
246:34 - an enum
246:35 - so let's see actually let me change that
246:39 - back
246:41 - and let me change that to integers
246:46 - an inner variant can be converted to an
246:49 - integer by the as keyword
246:52 - so when we take
246:55 - this enum over here and we create an
246:58 - instance
246:59 - as we've said as we've seen calling the
247:03 - name of the enum and the variant
247:06 - and then we can convert it to an u8 for
247:10 - example right
247:12 - and we can do the same thing here
247:15 - and over here should be the same thing
247:27 - and as you can see this is compiling
247:30 - let me print out
247:38 - [Applause]
247:47 - as you can see when we access from the
247:50 - number in on the variant one then A1
247:55 - will get outputted now let's see if I
247:58 - provided a value of 10 over here
248:03 - but for that I have to
248:07 - comment that out
248:11 - as you can see
248:12 - this foot would then be
248:14 - the discriminator for the one variant
248:20 - all right each enum variant can hold its
248:24 - own data
248:25 - so as you can see we have here an enum
248:27 - message
248:29 - now this enum has different variants so
248:33 - this variant quit doesn't hold any
248:36 - additional data but while this variant
248:39 - move here holds Fields it's very struct
248:44 - like
248:45 - and this variant right is tube alike so
248:49 - it holds a value in a tuple syntax and
248:54 - the same thing for change color
248:56 - so we can then instantiate the move
248:59 - variant from the message enum
249:01 - with these values over here X1 and Y 2.
249:07 - and as you can see because this is very
249:10 - struck like you instantiate it basically
249:13 - like a struct
249:15 - and over here instantiating with hello
249:18 - world as you can see this variant over
249:21 - here
249:22 - holds a string type
249:25 - so
249:26 - [Applause]
249:30 - like that
249:35 - and please notice over here that both of
249:38 - these variables here hold the same type
249:41 - message
249:47 - because this is also a custom type A
249:51 - type we have created
249:54 - we can get the data which an enum
249:57 - variant is holding by pattern matching
250:01 - so
250:02 - over here we have the same enum like we
250:05 - saw before
250:06 - and over here we have an instance
250:11 - of team move variant
250:14 - now we can here use E flat and we will
250:17 - cover that in the next section
250:20 - two
250:23 - get out the data inside
250:27 - this move variant so we are matching
250:30 - here the message variable holding an
250:33 - instance of the move variant
250:35 - and then over here we can basically
250:38 - destructure it so X should then be
250:41 - destructured into a variable a
250:45 - and Y should be restructured into a
250:48 - variable B and then as you can see we
250:51 - can use these two variables
250:54 - now we are here asserting A and B
250:59 - and a stands for this value and b stands
251:03 - for this value and as you notice they
251:05 - are not the same so this would fail
251:07 - actually
251:09 - so let me change that
251:11 - and now let's run the program
251:16 - fill in the blank and fix the errors
251:18 - again same enum and over here we have an
251:23 - array of
251:25 - different variants from this enum type
251:28 - right we have the quit variant the move
251:32 - variant and the change color variant now
251:36 - the neat thing here is that all of these
251:39 - instances are of the same type message
251:43 - right our custom type now I hope you
251:46 - remember how we annotate an array
251:49 - so first thing will be the type and then
251:52 - the number of elements
251:54 - Let's see we have over here three
251:57 - elements right
252:00 - and the type would be
252:03 - I hope you know it
252:05 - message right all of these variants
252:09 - or instances hold the same type
252:14 - and then over here we are looping over
252:17 - this array here
252:19 - meaning
252:20 - message this variable will hold in each
252:24 - iteration one of these instances
252:28 - and then passing it to the show message
252:31 - function and as you can see when we want
252:34 - to take
252:35 - an instance of this inner message we can
252:38 - just use the type message here because
252:42 - again all of them all
252:45 - because all of them have the same type
252:48 - and all we do then is just printing it
252:51 - out
252:58 - and again because this is a custom type
253:01 - we cannot print it out just like that so
253:04 - we have to use debug notation here
253:07 - and derive over here
253:10 - the debug trait
253:13 - [Applause]
253:17 - and as you can see
253:18 - in each iteration over here we call the
253:22 - show message function and it will print
253:25 - out
253:27 - the contents of this array
253:31 - so let's see exercise five since there
253:34 - is no null in Rust we have to use enum
253:37 - option to deal with the cases when the
253:39 - value is absent and I want to show you
253:43 - some slides for that
253:46 - so the option enum option is an enum
253:49 - that represents a value that may or may
253:52 - not be present it's known in other
253:55 - languages as null and it's referring to
253:57 - the absence of a value it's used to
254:01 - handle cases where a function or method
254:04 - might fail to return a value
254:07 - so this is how the enum option looks
254:11 - like as defined by the standard Library
254:13 - as you can see it's an enum holding two
254:17 - variants none and some now this over
254:21 - here is a generic meaning that sum can
254:26 - hold any type and we'll cover generics
254:30 - very soon
254:31 - but for now again think that this can
254:34 - hold any type provided so let's see an
254:38 - example over here
254:40 - we are here initializing the variable 5
254:43 - with
254:45 - D variant sum holding an integer value
254:50 - right
254:52 - and then over here we are calling the
254:54 - function plus 1 providing it five
254:58 - so let's see here as you can see the
255:01 - argument should be of type option
255:04 - and the type parameter here would be i32
255:10 - now we have to provide a concrete type
255:14 - for this generic type parameter now
255:18 - again we will cover that in much greater
255:21 - detail but as you can see this is
255:25 - exactly the type we are passing to the
255:27 - function sum is a variant of the option
255:31 - enum and it is holding an i32 value
255:38 - and it is holding an i32 type now then
255:42 - we are matching this argument over here
255:45 - if it is holding a non we will return
255:48 - none if it is holding a sum then over
255:53 - here we are destructuring the value
255:55 - wrapped inside this sum variant into the
255:59 - variable I and then over here we are
256:03 - incrementing I by 1 and wrapping it in a
256:07 - sum because as you can see the return
256:10 - type over here is defined as option i32
256:17 - and
256:19 - that means that this variable over here
256:23 - will then hold some 6 right because we
256:27 - have incremented 5 over here by one so
256:31 - this will hold an option type
256:34 - and the concrete value would be sum 6.
256:40 - the sum variant and a value of 6.
256:45 - now over here we are calling the plus
256:48 - one function with none meaning the
256:51 - argument will get matched and
256:53 - this will then get
256:56 - returned right a non
256:59 - and as you can see the non is also a
257:02 - variant of the option Ina
257:06 - and this i32 just stands for the sum
257:09 - variant if your turn if we are returning
257:13 - none then this type over here is still
257:16 - valid because the non-variant here
257:19 - doesn't hold any value of generic type t
257:25 - but again generics are a topic on its
257:28 - own
257:31 - and by the way this is exactly the same
257:34 - that we have over here so let's do that
257:37 - annotating the type so over here we have
257:40 - an option holding an i32
257:44 - type all right and as I've said
257:49 - this is not necessary you can omit that
257:53 - because again
257:55 - the option type is in the prelude
257:58 - then we are calling the plus one
258:01 - function
258:02 - again we are providing it sum 5 which is
258:06 - an option
258:08 - and then we are matching the argument so
258:12 - if the argument is none
258:14 - then we return none
258:18 - it is some
258:20 - then we destructure the value
258:23 - that was passed over here
258:26 - and we incremented by one and return it
258:31 - wrapped in some because
258:34 - the return type has to be of type option
258:38 - that means over here the type annotation
258:41 - would be option i32
258:45 - and in this case we are passing a non so
258:48 - a non will be returned
258:51 - and by the way
258:54 - [Applause]
258:55 - the Returns value here would be sum 6
258:58 - right because 5
259:01 - plus 1 will be 6.
259:05 - and over here we have non-anti-type
259:07 - annotation would still be
259:10 - option I 32.
259:14 - now we want actually to unwrap this
259:18 - value inside this sum variant and we can
259:22 - do that by using IF let
259:25 - so as you can see we are matching these
259:27 - six variables holding some six and then
259:31 - we can destructure it basically so
259:35 - we can then say sum
259:38 - and the variable n
259:41 - meaning we then can use n over here
259:47 - and I see right now never let this run
259:51 - so we have to pack that into an else
259:53 - block
259:58 - just to ensure that this doesn't run
260:01 - after we are running this conditional
260:03 - here
260:07 - and as you can see it will output
260:10 - the value inside sum now again we'll
260:15 - cover generics will cover a flat and
260:18 - match over here this will actually be
260:21 - the next topic so don't worry if this
260:24 - seems a little difficult to understand
260:26 - we will cover that in much greater
260:28 - detail
260:30 - Implement a linked list via enums now
260:34 - over here
260:36 - this linked list
260:37 - I won't cover because there are a lot of
260:42 - things we haven't seen so in here we
260:45 - have
260:47 - um
260:48 - methods and other things that we didn't
260:53 - really cover so I think this would be
260:56 - more confusing than it would be helpful
261:00 - what I suggest you is that you will come
261:04 - back after we have seen some more topics
261:07 - you come back to this exercise and try
261:10 - to solve it it's not that difficult and
261:13 - the solution will be on my GitHub
261:15 - account
261:15 - but I think this is just Overkill right
261:19 - now
261:22 - so see you in the next topic
261:26 - the normal flow of execution in a
261:29 - program would be from top to bottom line
261:31 - by line but we can actually manipulate
261:34 - the flow of a program
261:37 - and flow control is a concept that
261:40 - refers to the ability to control the
261:43 - order in which statements or
261:45 - instructions are executed in a program
261:49 - it allows to specify which instructions
261:52 - should be executed under which
261:55 - conditions and in what order
261:58 - so we have many ways to do that and some
262:01 - of them are for example using
262:03 - conditionals so we have the if else
262:05 - keywords and match for example
262:08 - and we can use Loops for Loops while
262:12 - Loops there is a special Loop in Rust
262:14 - called Loop we'll cover that
262:17 - and we can even manipulate the flow
262:20 - inside the loop by keywords such as
262:22 - continue and break so let's see
262:27 - so let's start with if else conditionals
262:30 - over here we are initializing n with a
262:33 - value of 5. then over here we have an if
262:37 - conditional checking if n is less than
262:40 - zero in this case this would evaluate to
262:43 - false meaning meaning this this
262:46 - instruction over here will get ignored
262:49 - and the program will continue executing
262:52 - on the next line now in the next line we
262:55 - have another conditional
262:58 - so we can use here the else if keyword
263:03 - and over here we are checking is n
263:05 - bigger than zero
263:07 - in this case this would evaluate to true
263:10 - meaning this line will get printed out
263:13 - now we can also match anything else
263:17 - using the else keyword
263:20 - meaning if this evaluates to false and
263:24 - this evaluates to false then this will
263:26 - get executed
263:28 - now in this case this evaluates to true
263:30 - so this will get executed meaning this
263:34 - over here will be ignored
263:41 - as you can see this was the line that
263:44 - has been printed out
263:47 - number two if else expression can be
263:51 - used in assignments again initializing n
263:56 - and over here we have a variable
263:58 - assignment
264:00 - now we can even use if else conditionals
264:04 - when assigning a value to a variable now
264:09 - remember in a variable assignment is a
264:12 - statement so we so we have to end that
264:14 - with a semicolon like that
264:17 - so let's see we have here an if
264:19 - conditional and this is a Boolean and
264:23 - operation do you remember we have two
264:27 - inputs and both of these inputs have to
264:31 - evaluate to true in order the end
264:34 - operation to return true
264:37 - so let's see we have here n should be
264:41 - less than 10 which would evaluate to
264:44 - True right because 5 is less than 10.
264:47 - and 5 is bigger than -10 so this end
264:52 - operation will return true meaning the
264:58 - meaning the code in this if conditional
265:00 - block will get executed and over here we
265:04 - are just printing out a line and then we
265:08 - are multiplying n by 10 and in fact we
265:12 - don't have a semicolon so this will be
265:15 - returned from this expression meaning it
265:18 - will then be assigned to the variable
265:20 - Big N so big n will then hold
265:24 - a type of i32
265:27 - now in case this would evaluate to false
265:30 - then this else block would get executed
265:34 - meaning again we are printing out a line
265:37 - and then dividing n by 2.0
265:41 - now as you can see we should omit this
265:45 - semicolon because this should
265:47 - because this result over here should
265:50 - then be assigned to this variable
265:53 - now
265:55 - we actually can't do this operation here
265:58 - because n is of type i32 and we are
266:02 - dividing it by a floating Point number
266:06 - so we can
266:09 - so we can Typecast that when I 32.
266:16 - and as you can see
266:18 - this would be
266:20 - the output
266:22 - and we are printing out big n meaning 50
266:26 - over here
266:27 - so n
266:30 - has been multiplied by 10.
266:35 - so let's see we have here a for Loop D4
266:38 - in construct can be used to iterate
266:40 - through an iterator for example a range
266:43 - A to B
266:45 - now as you can see we have a for Loop
266:48 - declaring a variable n and we provide a
266:52 - range
266:54 - now this range over here reaches from 1
266:57 - to 100 and 100 here included because we
267:02 - have here the equal sign
267:04 - then we are checking if n is equal to
267:09 - 100 this program will panic
267:14 - that's not what we want so what we can
267:18 - do over here is just removing this equal
267:21 - sign because that means 100 is excluded
267:26 - meaning n will never be equals to 100
267:31 - the largest it will get will be 99
267:34 - because let's see
267:39 - all right
267:41 - fix the arrows without adding or
267:44 - removing lines so over here we have a
267:48 - so over here we have an array
267:51 - holding two strings
267:55 - now we want then to iterate over this
267:58 - array meaning this name variable will
268:01 - hold
268:03 - in the first iteration this string and
268:06 - in the second iteration this string
268:10 - so what we can do over here is
268:13 - pointing out
268:17 - name right so this will iterate two
268:21 - times
268:22 - and it will output this and then this
268:28 - now as you can see we are trying to
268:32 - access names again over here and that
268:36 - would then violate the ownership rules
268:39 - because as you can see in a for Loop
268:42 - the for Loop actually will take
268:44 - ownership of the provided value
268:48 - and we can pass here a reference like we
268:52 - have seen before and that means we can
268:55 - use names then again
269:02 - so
269:04 - and by the way
269:06 - we don't have to dereference name over
269:09 - here because the print line statement
269:11 - will do that automatically
269:14 - now over here we have three i32 integers
269:21 - the elements in numbers are copies so
269:23 - there is no move here so we are
269:26 - iterating over each element in this
269:28 - array
269:29 - where n will then hold in each iteration
269:33 - one element from this array so let's see
269:41 - [Applause]
269:46 - so and this would be the output
269:50 - as you can see in the first iteration
269:53 - name will hold this string and in the
269:57 - second iteration it will hold this
269:59 - string and it prints it out in each
270:02 - iteration then we print out the whole
270:04 - array
270:06 - and over here the same thing but with
270:09 - the integers
270:13 - so again we have an array
270:19 - so iterate the indexing and value in a
270:24 - so there is a useful method called
270:26 - enumerate
270:30 - and this enumerate method takes a
270:34 - collection for example an array or a
270:37 - tube pillar or anything else
270:40 - and it will then return a tuple
270:44 - and this Tuple will then hold the index
270:47 - and T value meaning for example in the
270:51 - first iteration this Tuple will hold
270:55 - for i 0 and for V4 right because
271:00 - at index 0 we have a value of 4 and it
271:05 - will then just print out the index but
271:08 - we increment it by one
271:10 - and the actual value
271:22 - and of course we have to put a into an
271:26 - iterator
271:27 - so let's see
271:31 - like that so we have to first put a into
271:34 - an iterator and then we can call this
271:37 - enumerate method on it because the
271:40 - enumerate method is implemented in the
271:44 - iterator trade we'll take a look at that
271:46 - later
271:48 - so as you can see this will be the
271:51 - output and
271:53 - that was the reason we have incremented
271:56 - I by one because we don't want to start
271:59 - with the zeroest element is four right
272:03 - so we say here the first element is four
272:05 - second three and so on
272:09 - while the while keyword can be used to
272:12 - run a loop when a condition is true fill
272:15 - in the blanks to make the last print Ln
272:18 - work
272:19 - so as you can see we have here a mutual
272:22 - variable n
272:24 - Loop while the condition is true
272:27 - so as you can see this is a while loop
272:30 - and we provided a conditional meaning if
272:34 - this evaluates to true
272:37 - then this Loop will keep running until
272:41 - this conditional evaluates two folds
272:45 - so inside the while loop we have other
272:48 - conditionals as you can see we here
272:51 - check
272:53 - the condition and modulus 15 is 0. if
272:58 - that would evaluate to true then we
273:00 - print out that
273:03 - and by the way this was a question at
273:06 - coding interviews at Google
273:09 - so
273:11 - we are
273:13 - here having more conditionals and
273:17 - a
273:18 - an else conditional so meaning if
273:21 - anything of this fails then this will
273:25 - get printed out
273:26 - so what we can do over here checking if
273:30 - n is less than 10 then this Loop will
273:34 - keep running now when you're using while
273:37 - Loops then you have to ensure that
273:40 - the while loop eventually stops right
273:43 - that this conditioner over here will
273:46 - evaluate to false eventually because
273:49 - otherwise you would have an infinite
273:51 - Loop
273:52 - now to do that we can increment and over
273:56 - here
273:58 - so I increment at the end of this while
274:02 - loop
274:03 - n by 1.
274:06 - meaning at each meaning in each
274:09 - iteration in this while loop n gets
274:12 - incremented by one so n will eventually
274:15 - be bigger or equal to 10 meaning this
274:20 - would evaluate to false meaning we break
274:23 - out of this Loop
274:30 - continue and break use break to break
274:33 - the loop
274:35 - so we have here a for Loop looping from
274:39 - 0 to 100 and 100 included
274:44 - so if n is 66 then we want to break out
274:49 - of the loop
274:49 - [Applause]
274:51 - anti-break keyword
274:53 - will immediately exit out of this for
274:57 - Loop so when this conditional evaluates
275:00 - to true we immediately exit out meaning
275:04 - the program will continue execution
275:06 - after the for Loop in this case this
275:10 - line over here
275:12 - let's see
275:15 - so as you can see in the end n will be
275:19 - equal to 66.
275:21 - because when I is 66 then we stop
275:25 - iterating
275:27 - continue will skip over the remaining
275:29 - code in current iteration and go to the
275:32 - next iteration
275:34 - so as you can see we are here again
275:37 - iterating from 0 to 100
275:40 - and we have here an if conditional if n
275:43 - is not equal to 66 then we increment n
275:48 - by 1.
275:50 - and we want them to continue
275:56 - meaning
275:58 - that
276:01 - that the remaining code
276:04 - in this for Loop will get ignored so
276:07 - discontinue keyword the program will go
276:11 - back to the beginning of the for Loop
276:14 - now in case this evaluates to false
276:18 - right so if n is in fact 66 this would
276:22 - evaluate to false meaning we ignore this
276:26 - code block and we go over here where we
276:30 - want to break out of the loo because as
276:32 - you can see we want n to be 66 at the
276:36 - end
276:41 - Loop is usually used together with break
276:44 - or continue
276:46 - so Loop is a special Loop in Rust where
276:51 - this is basically an infinite Loop and
276:55 - you have to manually
276:57 - manipulate the flow of the loop and we
277:00 - will see soon so this is a u32 over here
277:04 - count
277:07 - so let's count until Infinity
277:10 - as you can see we are here using the
277:12 - loop keyword
277:14 - meaning this would keep looping to
277:16 - Infinity
277:18 - or we provide some keywords that will
277:22 - break out of the loop or continue
277:25 - so as you can see in each iteration we
277:28 - are incrementing the count variable by
277:31 - one
277:36 - now if count is equal to 3 then we print
277:40 - out 3 and we want to skip the rest of
277:43 - this iteration so we can use here the
277:46 - continue keyword
277:48 - meaning again the rest over here will be
277:53 - ignored
277:54 - the program will go back to the
277:57 - beginning of the loop
278:01 - so
278:02 - then over here if count is not equal to
278:06 - 3
278:07 - this will get printed out so we print
278:10 - out the count in every iteration except
278:14 - if count is equal to 3.
278:18 - and then over here if count is equal to
278:20 - 5 then we'll print out okay that's
278:22 - enough and we want to break out
278:26 - meaning count in the end should hold a
278:30 - value of 5.
278:35 - you can see we are iterating one two and
278:39 - then in the third iteration this if
278:42 - conditional evaluates to true meaning we
278:45 - print out three and we continue we are
278:49 - going back to the beginning so the
278:52 - actual value of count over here is not
278:55 - printed as you can see there is no digit
278:58 - 3 but will printed out three over here
279:01 - because that was defined in this code
279:04 - block here
279:07 - and then
279:09 - add iteration 5 we will stop and break
279:13 - out of the loop
279:16 - so Loop is an expression so we can use
279:18 - it with break to return a value
279:22 - and again we have here a counter
279:29 - so over here we have a loop and we are
279:32 - in each iteration
279:34 - incrementing counter by one
279:37 - then we check if counter is equal to 10
279:41 - then we want to break out
279:45 - but as you notice we want to assign a
279:48 - value to the result variable right this
279:52 - variable should then hold an i32 but we
279:56 - don't return anything here
279:58 - so you can Define after the break
280:01 - keyword a return value meaning for
280:05 - example we want to return counter
280:08 - but in this case result will hold 10
280:12 - right because counter when we break out
280:15 - will be 10 otherwise this conditional
280:18 - would not evaluate to true so if counter
280:21 - is 10 then we break out
280:24 - but as you can see we want result to be
280:27 - 20. so we can even pass here an
280:31 - operation so we can double the counter
280:35 - value
280:36 - let's see
280:39 - and
280:40 - this is compiling
280:45 - it's possible to break or continue outer
280:48 - Loops when dealing with nested Loops in
280:51 - these cases the loops must be annotated
280:53 - with some label and the label must be
280:56 - passed to the break continuous statement
281:00 - so
281:01 - as you can see we can even Nest
281:04 - different loops
281:06 - so when we do that we have to actually
281:09 - provide labels so we provide here outer
281:13 - for the Outer Loop and inner one for the
281:17 - inner loop and as you can see we have
281:19 - even two inner Loops so we have inner
281:23 - one and inner two
281:26 - alright so let's see in the first inner
281:30 - loop
281:31 - we are checking if count is bigger than
281:34 - or equal to 20.
281:38 - if this is the case we break out of this
281:42 - inner loop
281:45 - otherwise we increment the count by two
281:51 - all right
281:55 - and notice here this would break only
281:57 - the inner one Loop so when we break out
282:00 - of this Loop this outer loop will still
282:03 - continue looping okay
282:07 - so then over here in the outer loop we
282:11 - are incrementing count by five
282:15 - and in this inner two Loop we are then
282:18 - checking if count is bigger than or
282:21 - equal to 30 then we break out of the
282:25 - Outer Loop
282:28 - otherwise if count is smaller than 30
282:31 - then
282:33 - the outer loop will continue meaning
282:37 - the program will go back to the
282:39 - beginning of the outer loop and continue
282:41 - executing from here
282:44 - so let's go step by step
282:47 - and as you can see we have to find out
282:50 - here what the count value will be in the
282:53 - end
282:55 - okay let's go step by step we start at
282:58 - zero then over here we are checking is
283:01 - Count bigger than or equal to 20 no
283:05 - right
283:06 - so that means count will get incremented
283:11 - by two
283:13 - and this will continue because we are in
283:16 - this Loop remember and this will
283:18 - continue until
283:20 - this evaluates to true meaning when
283:23 - count is 20 then we break out of this
283:27 - inner loop meaning we continue
283:31 - executing here
283:33 - then
283:35 - count would be 20 and we increment it by
283:38 - 5.
283:41 - then we enter this inner two Loop
283:45 - so 25 is not bigger or not equal to 30
283:51 - meaning we don't break off outer but we
283:56 - will continue outer meaning we go back
283:59 - over here
284:01 - now we enter this Loop here and 25 is
284:08 - bigger than 20 so we break out of this
284:11 - Inner Loop and continue here
284:14 - then we add 5 to count meaning count is
284:17 - now 30.
284:19 - so we enter this inner two Loop and this
284:23 - will now evaluate to true because count
284:26 - is equal to 30 meaning we break out of
284:30 - the outer loop so in this case count
284:33 - will be 30 in the end
284:38 - and this succeeded and I will see you in
284:41 - the next topic
284:44 - pattern match is a powerful construct
284:47 - that allows you to compare a value
284:49 - against a set of patterns and then
284:53 - execute different code based on which
284:55 - pattern matches
284:57 - and these patterns can be made up of
285:00 - literal values variable names wild cards
285:04 - and so on and in a match statement all
285:08 - possible cases must be handled and this
285:11 - is enforced by the compiler
285:14 - and really this match keyword is
285:17 - something that I really miss when I'm
285:19 - coding in other languages so once you
285:22 - get used to it you will love it and you
285:25 - will see why
285:27 - so let's see an example over here we
285:30 - have in coin enum and this enum holds
285:34 - variance of different denominations of
285:38 - U.S currency
285:40 - or U.S coins
285:42 - and here we have a function value in
285:46 - sense
285:48 - this takes as an argument a variant of
285:51 - type coin
285:54 - then it matches the argument
285:57 - and as you can see it matches the
286:00 - variance of this coin enum meaning if we
286:04 - provide an instance of this coin enum
286:07 - which holds a penny variant for example
286:10 - then it will return one right and this
286:15 - will then be the return value of this
286:18 - function so for each denomination over
286:21 - here it will return its proper value
286:33 - then let's see if let so I've said that
286:37 - in a match statement all possible cases
286:40 - have to be handled and this could
286:43 - sometimes lead to annoying boiler play
286:45 - code that is not really that necessary
286:49 - so for example we have over here an
286:51 - option type right a value wrapped inside
286:55 - sum and then we match
286:58 - this variable over here that holds this
287:02 - option type and then we are matching as
287:05 - you can see if it is sum then we the
287:09 - structure
287:10 - the value inside this Max variable and
287:13 - then we just print it out
287:16 - now as you can see we also have to match
287:19 - any other case meaning if it is not some
287:23 - in that case none then nothing will get
287:27 - executed meaning it will return a unit
287:31 - type
287:32 - now this is sometimes two verbose
287:37 - especially for cases like this for
287:40 - example you just want to unwrap
287:42 - something from a sum variant
287:46 - now what we can do instead is just using
287:50 - using E flat
287:51 - so it's exactly the same as this match
287:54 - statement but we know that config Max
287:58 - holds a sum value right so we don't have
288:03 - to
288:06 - so we don't have to consider the case
288:08 - where it holds a non-value
288:12 - and as you can see this is how we would
288:15 - destructure this value into the variable
288:18 - Max we will see a flat keyword and then
288:23 - the pattern so if config Max holds a sum
288:27 - then the value will get
288:31 - the structured
288:32 - let's do exercises
288:35 - fill the blanks so over here we have a
288:38 - direction enum holding
288:41 - directions over here as variance
288:45 - then over here as you can see we are
288:47 - instantiating
288:49 - the direction enum with a variant of the
288:53 - South
288:54 - so the type over here would be Direction
288:57 - [Applause]
288:59 - then we match this variable here
289:03 - and if this variable over here holds
289:07 - Direction East then it will print out
289:10 - east
289:12 - now we want over here to match south or
289:16 - north
289:18 - so what we can do over here is pattern
289:20 - matching either south or north and we
289:24 - can do it like that
289:28 - [Applause]
289:36 - so we are here matching
289:39 - so we are here basically saying if this
289:43 - variable holds either a variant of south
289:47 - or north then it will print out south or
289:51 - north
289:53 - now
289:54 - in case it's not any of these variants
289:58 - then it must be West right so we can
290:02 - print out here West
290:06 - let's see
290:10 - and as you can see
290:13 - the variable holds South so this will
290:16 - get matched so this will get printed out
290:22 - match is an expression so we can use it
290:25 - in assignments
290:27 - over here we have a Boolean value
290:30 - [Applause]
290:31 - fill the blank with a match expression
290:34 - Boolean true binary one Boolean false
290:38 - binary zero
290:40 - so what we want to do is we want to
290:42 - match this variable over here
290:52 - and then we provided the cases so if it
290:55 - is true
290:56 - then we should return one
291:01 - otherwise we return zero so that means
291:05 - the return value over here will then be
291:08 - assigned to this binary variable let's
291:12 - store that as u8
291:16 - and that means binary should then hold
291:19 - one right because we are matching here
291:21 - true
291:23 - and then the return value should be 1.
291:31 - using match to get the data and enum
291:35 - variant holds
291:37 - again we have the message enum we have
291:39 - seen that before
291:41 - then over here we have an array of
291:44 - message variants
291:52 - over here we are iterating over this
291:55 - array and passing it
291:59 - to this function
292:01 - as you can see
292:03 - the argument should be of type message
292:06 - so we are then matching this provided
292:10 - argument
292:12 - so we want to match over here message
292:15 - move
292:17 - [Applause]
292:22 - now as you can see the message move has
292:25 - struck like syntax so we have to match
292:29 - it like that
292:31 - and
292:36 - and as you can see we want the variables
292:39 - A and B so let's do that
292:51 - as you can see it holds Fields X and Y
292:55 - and that means we will then destructure
292:58 - these values into the variables into the
293:02 - variables A and B so a should hold 1 and
293:07 - B should hold three
293:12 - then we match over here the message
293:15 - change color variant as you can see this
293:18 - is a tuple-like
293:20 - variant
293:24 - and this Tuple has three elements so we
293:29 - can
293:30 - provide it some variables and we use
293:33 - here RGB red green blue and this is for
293:38 - color representation
293:40 - so in that case
293:43 - G the second value should be 255.
293:47 - and the last value B should be
293:51 - in this case 0.
293:56 - and again because we have to match all
293:58 - the cases
294:00 - if
294:03 - there is anything else that doesn't
294:06 - match here we will print out no data in
294:09 - this parents
294:16 - like that
294:27 - matches matches looks like match but can
294:31 - do something different
294:34 - so the macro matches allows us to
294:38 - test for example this array if a pattern
294:42 - matches
294:44 - so as you can see we are iterating over
294:48 - the elements of this array
294:51 - so over here we have the assert macro
294:54 - and all this does is it asserts that the
294:58 - given
294:59 - argument evaluates to true
295:02 - so we can over here use team matches
295:05 - macro
295:07 - and we provide it a b meaning the
295:11 - character we are iterating over
295:14 - and then we can
295:16 - give it a pattern it should match
295:21 - so as we are iterating over each element
295:25 - over here it should match each of these
295:28 - characters
295:30 - and we can do that like this
295:33 - so we want to match characters from a
295:37 - to and including z
295:41 - or
295:43 - a to and including that lowercase
295:48 - or zero
295:53 - two nine
295:54 - and notice these are characters and not
295:57 - integers because we have here an array
296:00 - of characters
296:02 - let's see
296:06 - and this succeeds as you can see all we
296:10 - did is we iterated over each element and
296:14 - we checked
296:16 - over here for each element if it matches
296:19 - if it matches this pattern
296:23 - and in this case everything matched
296:26 - because assert
296:28 - didn't Panic right because if one of
296:33 - them would evaluate to false insert will
296:36 - cause the program to panic
296:38 - let's see exercise five so over here we
296:42 - have an enum with two variants full and
296:45 - Bar
296:47 - then here we have a count variable
296:50 - which is initialized with zero
296:55 - and over here we have a vector now we
296:58 - didn't cover vectors yet but they are
297:01 - very similar to arrays but their size
297:04 - can shrink and grow meaning during a
297:07 - vector is dynamic in its size
297:10 - so as you can see we are
297:13 - having a vector of my enum variance two
297:18 - of them fool
297:20 - and one bar
297:27 - so this is a vector holding types of my
297:31 - inner
297:32 - then over here we are iterating over the
297:36 - elements of this vector
297:38 - now we want to match my enum Foo
297:44 - and if conditionals don't allow to match
297:48 - for patterns so we can't use that here
297:51 - but we can do something else we can hear
297:55 - instead using matches
297:58 - macro
297:59 - meaning we take e the element in the
298:03 - vector we are iterating over
298:06 - and we match it for
298:10 - this pattern right
298:12 - so if the element we are currently
298:15 - iterating over matches my enum full
298:19 - variant
298:21 - then
298:23 - we want to increment count by one
298:28 - like that
298:34 - and that means count after this for Loop
298:37 - iterating over each element should be
298:40 - two right because
298:42 - matches matched two times because there
298:46 - are two my enum full variants in this
298:50 - vector
298:53 - if let for some cases when matching
298:56 - enums match is too heavy we can use if
299:00 - let instead
299:02 - so over here as you can see we have an
299:05 - option
299:07 - [Applause]
299:08 - of type i32
299:11 - we move the whole match block using IF
299:14 - let instead so as you can see match is
299:18 - really verbal so we can use E flat
299:21 - instead
299:22 - and we do that like this we use the E
299:25 - flat keyword and then the pattern we
299:28 - want to match in this case sum
299:31 - and the variable should be I so the
299:35 - inner value here will get the structured
299:38 - into this variable I
299:42 - and then we are matching on all
299:49 - and if
299:51 - this matches then we want to print out
299:54 - these two lines
300:03 - as you can see this is much cleaner
300:10 - and this will get printed out this is a
300:14 - really long string and seven as you can
300:17 - see
300:18 - we here provide I and I just holds the
300:23 - inner value of this sum variant
300:28 - fill in a blank we have here a full enum
300:32 - with a bar variant holding a type of u8
300:36 - then over here we have an instance of
300:38 - the bar variant holding a value of one
300:44 - now over here again we could do the same
300:46 - thing we can use E flat and
300:52 - then we match the pattern
300:57 - so if
300:59 - the pattern is full bar then we want to
301:02 - destructure the inner value
301:04 - to a variable I
301:06 - [Applause]
301:08 - and we are matching on a
301:14 - as you can see this compiles
301:19 - so we have a full Anum with three
301:22 - variants and only the last one holds a
301:26 - value
301:28 - so over here we instantiate the full
301:31 - enum with a variant of
301:34 - cues and a value of 10. I hope I
301:39 - pronounce it correctly
301:43 - so remove the codes below using match
301:46 - instead
301:48 - so if I run this code
301:53 - then this would actually work because we
301:56 - are using IF let here but we can
302:01 - do it in a match statement so we match
302:04 - on a right
302:08 - and then we can provide the pattern
302:12 - so in case of full bar
302:16 - then we would
302:18 - then we will print out this line
302:23 - in case of Foo Bass
302:28 - we want to Output this line
302:33 - and in case of anything else
302:37 - like that
302:39 - we print out this line
302:45 - now I can delete that
302:47 - [Applause]
302:49 - and as you can see much cleaner
302:52 - so in this case match others
302:57 - shadowing fix the arrows in place again
303:00 - we have here an option
303:04 - with an inner value of i32
303:10 - then we are here using E flat to
303:13 - destructure the inner value to H
303:17 - and that means we are actually shadowing
303:20 - H because as you can see this variable
303:24 - here has the name H and we are then
303:27 - destructuring into a variable h
303:31 - so that means
303:33 - H has been shadowed
303:37 - create a new variable with the same name
303:40 - as previous age
303:42 - now over here as you can see H would be
303:46 - sum 30 which is wrong because we are
303:48 - actually here
303:50 - destructuring it right
303:54 - so H doesn't hold some 30 anymore but it
303:58 - will hold 30 because we are here
304:01 - destructuring it
304:04 - the new variable H goes out of scope
304:07 - here
304:08 - right so this variable over here
304:11 - goes out of scope
304:17 - and image can also Shadow a variable so
304:21 - we can here essentially doing the
304:24 - exactly same thing like in the uh like
304:28 - in the E flat statement over here
304:35 - foreign
304:38 - this would be the output from this match
304:42 - here
304:44 - alright see in the next topic
304:47 - so let's see patterns we can use this
304:49 - sign to match several values and we can
304:53 - use this one to match an inclusive range
304:57 - so as you can see we have here a
304:59 - function match number which takes an
305:02 - integer as argument
305:05 - then we are matching this integer and if
305:08 - it is one then we will then we'll print
305:10 - out one
305:12 - and fill in a blank with this don't use
305:16 - ranges okay so we have to match here two
305:20 - to five
305:22 - so we can do it like that
305:29 - and this pattern is basically saying if
305:32 - n is either 2 or 3 or 4 or 5 then we
305:38 - will print this
305:40 - match an inclusive range so if the
305:45 - so if n is between 6 and 10 where 10 is
305:49 - included then it will print out that
305:53 - and for any other case because again
305:56 - because again in a match statement we
305:58 - have to match every case so in this case
306:01 - we will print out that
306:05 - the add operator lets us create a
306:08 - variable that holds a value at the same
306:10 - time we are testing that value to see
306:13 - whether it matches a pattern
306:17 - so let's see we have here the point
306:19 - struct that has two Fields with I 32
306:23 - types
306:24 - fill in the blank to let P match the
306:27 - second arm so we have to complete here
306:30 - something we have here an instance of
306:34 - the point type
306:38 - now let's see the match here so we match
306:40 - on P
306:42 - and as you can see this is how we would
306:46 - match a struct so we provide this track
306:49 - name and then the fields as you can see
306:53 - we are matching X and Y so
306:56 - so if Y is equal to 0 that means this
307:00 - arm here matches and this will get
307:03 - printed out
307:04 - and we then can use x over because this
307:10 - is actually a destructuring assignment
307:13 - so this would be the same as writing it
307:16 - like that
307:17 - but this is shorthand syntax so we are
307:20 - then using X here
307:23 - now in the second arm as you can see we
307:26 - are matching X and Y Fields so X should
307:31 - be between 0 and 5 5 included
307:36 - and Y should be either 10 20 or 30.
307:42 - now as you can see when we are matching
307:45 - here this pattern we can't use x we
307:49 - don't use x here but we can in fact use
307:52 - y because we are using here the add
307:56 - operator so this means we are
307:59 - destructuring the variable y
308:02 - of the field y so that means the value
308:06 - that Y is holding over here will gets
308:09 - we'll get this structured into the Y
308:12 - variable
308:14 - and at the same time we are testing why
308:18 - if it is matching this pattern
308:24 - and the last arm as you can see we don't
308:27 - match for any pattern
308:29 - other than this main pattern and then we
308:34 - can use X and Y because again this would
308:37 - be the same as writing it like that
308:41 - all right
308:45 - now we want to match the second arm that
308:50 - means we have to provide values that
308:52 - match these patterns so let's see
308:55 - X between 0 and 5 so let's do three
308:59 - [Applause]
309:00 - and Y 10 20 or 30 I will do 30.
309:08 - as you can see this second arm matched
309:14 - fix the arrows over here we have the
309:16 - message enum that's holding which is
309:19 - holding one variant with a struct like
309:22 - syntax as you can see this is one field
309:25 - ID of type i32 then over here we are
309:30 - instantiating this variant so this will
309:33 - be an instance of the message enum
309:37 - and then over here we are matching this
309:41 - instance so if it is hello
309:44 - then we match the ID field so is it
309:49 - between 3 and 7 then
309:52 - we want to output here the ID now the
309:58 - problem here is that we did not actually
310:01 - destructure this field here into its
310:06 - distinct
310:07 - variable right so we have to provide
310:09 - here each variable let's do ID because
310:12 - that's the one defined here and for that
310:15 - we have to use the add operator so we
310:18 - are destructuring and matching the
310:21 - pattern at the same time
310:25 - and over here
310:27 - this is already done as you can see we
310:30 - can also provide any a variable with
310:34 - another name as you can see so the value
310:38 - of the ID field then we'll get this
310:41 - structured into this
310:44 - new ID variable
310:47 - right it doesn't have to be the same
310:50 - variable name as the field we have
310:55 - [Applause]
310:57 - and again we are destructuring and at
311:00 - the same time
311:01 - pattern matching and that's
311:04 - and that is the reason we are using the
311:06 - add operator
311:09 - and as you can see when we are matching
311:12 - like that then this ID over here got
311:16 - this structured because this is
311:19 - the shorthand for this all right
311:43 - and
311:44 - when we have a pattern here we have to
311:47 - wrap it inside parentheses
311:51 - that's also important
311:53 - and as you can see in this case the
311:56 - first arm matched right because ID over
312:00 - here the value is between 3 and 7.
312:05 - in match card is an additional if
312:07 - condition specified after the pattern in
312:11 - a match arm that must also match along
312:14 - with the pattern matching for that arm
312:17 - to be chosen
312:19 - fill in the blank to make the code work
312:21 - split must be used
312:25 - alright as you can see we have here an
312:27 - option
312:28 - [Applause]
312:30 - with an i32 value
312:33 - then we have here split
312:39 - and we are here matching
312:43 - the num variable and we are doing that
312:46 - to basically restructure the inner value
312:49 - so we are putting the value of 4 into X
312:53 - right so we can then use x over here
312:57 - but we over here also want a match card
313:00 - to check if x
313:03 - in this case this value over here is
313:06 - less than split
313:08 - we can do that like this
313:15 - foreign
313:19 - so this basically is just for
313:22 - destructuring the this value into X and
313:26 - over here we have an additional
313:28 - conditional in match card to check for a
313:33 - more specific condition to be true
313:37 - so
313:38 - if num is a sum so if num is of some
313:44 - variant then we the structure X and
313:48 - check it again and if all of that
313:51 - matches then we
313:53 - execute this
313:55 - if it is a sum but yeah but the value
314:00 - over here is actually bigger than split
314:03 - then this will get executed and if num
314:07 - holds a none then we just return a unit
314:11 - type
314:13 - ignoring remaining parts of the value
314:16 - with with this
314:20 - so as you can see we have here a tuple I
314:24 - want annotate that so we are matching on
314:28 - numbers
314:29 - now we only care about the first as you
314:36 - can see and the last one
314:42 - so what we can do over here we are
314:44 - matching on a tuple right so this is a
314:47 - tuple and we want to destructure the
314:52 - first and the last values into the
314:55 - variables first and last we can do it
314:59 - like that
315:05 - right so we have the first
315:08 - then anything in between and then the
315:11 - last
315:13 - so first should all two and last should
315:16 - hold 2048.
315:21 - using pattern mutable reference to V to
315:25 - match a mutable reference needs you to
315:28 - be very careful due to B being a value
315:31 - after matching
315:35 - let's see fix the arrow with least
315:37 - changing don't remove any code lines so
315:40 - over here we have a mutable variable
315:43 - holding a string
315:45 - and this would be a variable that holds
315:49 - a mutable reference to a string
315:53 - now we match r
315:56 - and that means over here we can
315:59 - destructure it directly into a value
316:04 - like that so
316:08 - this string over here will then be
316:11 - destructured into the value directly we
316:15 - don't have to match
316:17 - mute the reference like that right
316:21 - and that means the value variable
316:24 - will hold immutable reference to a
316:28 - string
316:31 - and of course then we can modify
316:34 - this stream over here
316:39 - all right that's it see you in the next
316:41 - one
316:43 - a method is a function that is
316:45 - associated with a particular type or
316:48 - struct it takes parameters and returns a
316:52 - value like a function but it's defined
316:55 - as a member of a struct or an enum
316:59 - it's called using dot notation like
317:02 - accessing members of a struct and it's
317:05 - implemented through an implementation
317:07 - block
317:09 - let's see an example over here we have
317:12 - the struct rectangle with two fields
317:17 - and as you can see we can then Implement
317:20 - methods for this rectangle type using
317:24 - the input keyword and the name of the
317:28 - type we want to implement the methods
317:31 - for
317:33 - so then over here we can see that
317:36 - rectangle has a method called area it
317:41 - takes as an argument a reference to self
317:45 - and self stands for the name of the
317:48 - instance so
317:51 - inside the method we are multiplying
317:54 - self dot with this field by self dot
317:58 - height this field and then we return the
318:02 - result of this operation now again self
318:06 - over here will be replaced by the name
318:09 - of the instance
318:12 - so when we create an instance of
318:15 - rectangle with concrete values then as
318:18 - you can see we can call this method on
318:21 - the created instance right one
318:24 - meaning when this method is called like
318:28 - that then self over here will be
318:31 - replaced by rect one so here rect1 dot
318:35 - width times rect1 dot height meaning 30
318:39 - by 50 will be returned
318:46 - now let's see Associated functions an
318:50 - Associated function is a function that
318:52 - is associated with a struct or an enum
318:55 - but doesn't take an instance as its
318:58 - first parameter so you can recognize an
319:01 - Associated function if it doesn't take
319:04 - self as its first parameter
319:08 - it's called using the name of the type
319:10 - not an instance of it
319:13 - and it's often used as Constructors for
319:16 - a struct or an enum
319:18 - so let's see an Associated function as
319:22 - you can see we have again the rectangle
319:24 - type and we Implement over here again in
319:28 - an implementation block
319:30 - the new Associated function for the
319:34 - rectangle type
319:36 - and notice we don't have a self here and
319:39 - you will see in a minute why that is now
319:42 - the new Associated function takes two
319:45 - arguments with and height both of type
319:48 - u32 and it will then create an instance
319:53 - rectangle and returns it
319:56 - meaning when we want to call this
320:00 - Associated function we don't call it on
320:03 - an instance right because we don't have
320:05 - self here we call it directly on the
320:09 - type
320:09 - so in this case we take rectangle double
320:12 - colon and then the function new and we
320:16 - provide it two values 5 and 10 right
320:21 - that means Rec 1 will then hold an
320:25 - instance of the type rectangle
320:29 - okay let's do the exercises we will skip
320:32 - this example because I've showed you
320:34 - that
320:36 - before
320:38 - and we will do the exercises directly
320:42 - methods are similar to functions declare
320:45 - with FN have parameters and a return
320:49 - value unlike functions methods are
320:52 - defined within the context of a struct
320:55 - or an enum or a trade object and the
320:59 - first parameter is always self which
321:03 - represents the instance of destruct the
321:05 - method is being called upon so as you
321:08 - can see we have the rectangle struct
321:11 - again and over here we have the
321:13 - implementation block we can implement
321:16 - the methods for this type
321:19 - now as you can see we instantiate
321:22 - rectangle over here with concrete values
321:25 - and then assign it to right one select
321:28 - one holds an instance of type rectangle
321:33 - then over here we call this
321:36 - then over here we call the method area
321:39 - on rect one and we should get back
321:43 - 1500 so let's implement the area method
321:48 - so
321:51 - the first thing is we always start with
321:55 - cell so every method takes as first
321:58 - argument self okay
322:02 - then the return type will be
322:06 - Au 32 right because we are here doing
322:10 - operation with these two fields
322:15 - now what we want to do to get the area
322:18 - of the rectangle is multiplying the
322:21 - width by the height
322:24 - so we use self.width
322:27 - times self dot height
322:31 - and I omit here the semicolon so this
322:34 - will get returned
322:37 - let's see
322:41 - so when we so when we call the area
322:44 - method on the rect one instance then
322:48 - rect one dot width times rect1 dot
322:51 - height
322:52 - will result will result in
322:56 - 1500 meaning 30 times 50.
323:01 - self will take the ownership of current
323:05 - struct instance however reference to
323:08 - self will only borrow a reference from
323:11 - the instance
323:13 - Let's see we have again destruct traffic
323:15 - light with one field now over here there
323:18 - is the implementation block we can
323:21 - Implement methods for destruct
323:24 - Now using self to fill in the blank so
323:28 - we have been using self like this
323:31 - right meaning we take a reference to the
323:35 - instance
323:37 - now this is actually syntactic sugar for
323:40 - this
323:45 - and as you can see itself with an
323:48 - uppercase s refers to the type we are
323:52 - implementing the method on right so in
323:56 - this implementation block when we use
323:58 - self uppercase it refers to traffic
324:02 - light
324:04 - and you can use this syntax or you can
324:08 - use like we did before
324:11 - using just self right
324:17 - and here we want to take immutable
324:19 - reference because we are here mutating
324:22 - the
324:24 - color field
324:30 - and again
324:33 - and this
324:36 - and this and that are exactly the same
324:39 - but this is not mutable so
324:43 - if I would do it like that
324:46 - then as you can see these are actually
324:49 - exactly the same thing but I would
324:52 - suggest just stick with that it's more
324:55 - readable and it's clear what you mean
324:59 - Associated functions all functions
325:01 - Define within an input block are called
325:04 - Associated functions because they are
325:07 - associated with the type named after the
325:10 - impul
325:12 - we can Define Associated functions that
325:15 - don't have self as their first parameter
325:17 - and thus are not methods because they
325:21 - don't need an instance of the type to
325:24 - work with
325:26 - so as you can see we again use the
325:28 - traffic like struct
325:30 - and here we have the imple block
325:33 - so let's see first Implement an
325:36 - Associated function new it will return a
325:40 - traffic light contains color red must
325:43 - use self don't use traffic light in FN
325:46 - signatures or body
325:49 - let's first see in main what's going on
325:51 - so we call here the new Associated
325:55 - function
325:58 - and disassociated function is associated
326:01 - with the traffic light type
326:05 - and again notice the difference is we
326:07 - call this directly on the type and not
326:10 - on an instance otherwise it would be a
326:14 - method
326:15 - so we call new and then we want to have
326:19 - an instance of traffic light back
326:24 - write this new function should return an
326:27 - instance of traffic light meaning we can
326:31 - then call upon this instance light the
326:34 - get State method and return Red
326:39 - so let's see
326:42 - over here we are expecting no argument
326:47 - right
326:48 - so let's leave it like that and remember
326:51 - Associated functions don't take self
326:55 - now the return type would be traffic
326:57 - light instance
327:02 - and because we should use self in here
327:05 - we can do that and again self in an
327:09 - implementation block refers to the type
327:13 - in this case traffic light
327:16 - then in there we want to create an
327:20 - instance of traffic light so again we
327:22 - can use self instead of this name
327:28 - and then we like normally instantiating
327:31 - it providing it concrete values
327:36 - so in this case we want this self.color
327:39 - field to hold a string of red
327:48 - like that
327:49 - and as you can see then we should get
327:52 - and as you can see when we call this
327:56 - Associated function we'll get back an
327:59 - instance with this concrete value a
328:02 - string red then we call upon this
328:06 - instance light the get State method so
328:10 - again self here refers to light because
328:14 - we are calling the method on this
328:16 - instance
328:17 - and it takes just a reference to the
328:22 - instance meaning light is usable even
328:25 - after this method call and all it does
328:29 - it will return the value inside the
328:31 - color field of the instance in this case
328:34 - slide
328:35 - so light dot color will hold a string of
328:40 - red
328:46 - multiple input blocks each struct is
328:49 - allowed to have multiple input blocks
328:52 - again rectangle struct and using
328:56 - multiple input blocks to rewrite the
328:59 - code below so
329:01 - we can either put all of the functions
329:04 - and methods in the same input block or
329:08 - we can even reorganize it using various
329:12 - different input blocks
329:16 - so we can for example put that
329:19 - in its own implementation block like
329:23 - that
329:24 - and it will work exactly the same this
329:27 - is just for organizing and restructuring
329:36 - enums we can also Implement methods for
329:39 - enums so over here we have the enum
329:42 - traffic light color with three variants
329:46 - Implement traffic light color with a
329:49 - method
329:50 - so over here in main we are
329:52 - instantiating traffic light color with a
329:56 - variant of yellow
330:00 - this would be the type annotation and
330:03 - then when we call a method color on the
330:07 - C instance it should return yellow
330:11 - so let's see
330:23 - so we could Implement that using a match
330:26 - statement
330:30 - then we match a self and if match self
330:35 - would be this
330:40 - then we return the string yellow
330:44 - okay
330:45 - [Applause]
330:47 - and we can over here instead of writing
330:51 - the whole name of the type we can again
330:54 - use uppercase self referring to the type
330:59 - this method is implemented on in this
331:03 - case traffic light color
331:05 - and remember in a match statement we
331:08 - have to handle all the possible cases
331:10 - meaning we have to create an arm for
331:13 - right and for green two so let's do that
331:30 - let's see
331:34 - and as you can see because we have here
331:37 - an instance which holds the variant
331:39 - yellow we will get back yellow when we
331:42 - call the color method
331:46 - all right that's it until next time
331:50 - until now we have only been dealing with
331:53 - concrete types but we can also deal with
331:57 - generics and generics are placeholders
332:01 - for concrete types it enables writing
332:05 - more reusable and flexible code and it
332:09 - avoids having duplicate code for
332:11 - different types it's a zero cost
332:14 - abstraction meaning the rust compiler
332:17 - will add compile time fill out the
332:20 - generics with concrete types
332:25 - and there is also a concept called const
332:28 - generics I will just briefly touch upon
332:31 - it because this is more of an advanced
332:34 - topic but I will show you one exercise
332:36 - just so you get the idea from it
332:40 - so const generic is a type parameter
332:43 - that represents a compile time constant
332:46 - value it allows to write generic code
332:49 - that operates on values that are known
332:52 - at compiled time and it's mainly used
332:56 - for array sizes bitwits and other
332:59 - constants and you will see what I mean
333:03 - when you see the exercise
333:07 - let's start with generics
333:10 - so as you can see over here we have a
333:14 - struct a now this would be considered a
333:18 - concrete type
333:20 - because we don't deal with generic types
333:23 - in here
333:24 - now destruct s takes as an argument an
333:28 - instance of destruct a this is also
333:32 - considered a concrete type because again
333:35 - there are not
333:37 - generics used here
333:39 - now destruct s-gen is considered a
333:44 - generic type because we are dealing here
333:47 - with a generic type parameter and this
333:51 - would be denotation when you declare
333:55 - a type for example then after the name
333:59 - of the type you annotate
334:02 - a generic type parameter like that using
334:07 - these symbols over here and then
334:10 - providing a name and by convention this
334:14 - is usually T standing for type and that
334:18 - means this struct can hold any type
334:24 - now as you can see we have here some
334:27 - functions this function over here takes
334:30 - s which is a concrete type the Gen spec
334:35 - takes as an argument an instance of s
334:39 - gen with a type of a
334:44 - now again a would be a concrete type
334:48 - meaning the type parameter over here
334:53 - is specified to be a concrete type so we
334:57 - can only pass to this S10 struct
335:02 - an instance of destruct a
335:07 - then over here we have the genspec i32
335:11 - function which takes as an argument the
335:14 - S-10
335:16 - struct over here with a value that is of
335:20 - type i32
335:23 - and over here we have a generic function
335:27 - meaning we are declaring after the
335:30 - function name the the generic type
335:34 - parameter T and then we can use it on
335:37 - here meaning that we can provide
335:41 - as an argument over here an instance of
335:44 - S-10 with any type
335:49 - so let's see using the non-generic
335:52 - functions so these over here are all
335:56 - non-generic as you can see because we
335:59 - didn't Define a generic type parameter
336:02 - and all the values it is using are
336:05 - concrete right over here we have S over
336:10 - here we have S10 and this is taking as a
336:14 - value T over here the concrete Type A
336:20 - and over here it takes as concrete type
336:23 - i32 so all these are non-generic
336:27 - functions the only generic function over
336:30 - here would be this one
336:33 - so let's see
336:34 - so we want to call Direct F and function
336:37 - and as you can see in the function
336:39 - signature we are taking as an argument
336:44 - a type of s
336:46 - so let's provide that
336:53 - now we have to pass into s
336:57 - the concrete type a right because that
337:00 - is defined
337:02 - in this
337:04 - struct
337:07 - then gen spec t
337:10 - so this function over here takes
337:14 - an S10 struct with a type of a now again
337:20 - a would be a concrete type
337:23 - so we provide here S10
337:27 - and a right
337:30 - so we are passing to the S gen
337:33 - struct over here
337:35 - a value of type A
337:41 - and in this case we want it to be S10
337:44 - and let's say 7 because over here we
337:48 - Define that this function should take as
337:51 - an argument a type S10 which holds an
337:55 - i32 integer
337:59 - then explicitly specify type parameter
338:03 - chart to generic
338:05 - so over here we are calling the generic
338:08 - function meaning we can pass to it and
338:12 - S10 type holding any possible type now
338:17 - we can explicitly specify a type
338:20 - parameter for this T over here and we
338:24 - are here saying T should be a char
338:29 - meaning we are calling the generic
338:31 - function over here with the type S gen
338:36 - and passing as a value a type of char
338:40 - let's say a
338:45 - and implicitly specify type parameter
338:49 - chart to generic so we don't have to
338:52 - annotate the type here it will be
338:55 - automatically inferred by the compiler
338:58 - so if I do the same thing over here
339:03 - let's go with Z this time
339:07 - as you can see this is compiling now
339:10 - again because sgen is defined to be
339:14 - generic over its type
339:16 - pass any value so let's pass for example
339:20 - a floating point
339:25 - as you can see this is also compiling
339:28 - because
339:30 - T over here is a placeholder that stands
339:34 - for any type possible
339:37 - but again when we annotate the specific
339:40 - type then we can only pass a character
339:44 - in this example so if I try 7.7 here
339:49 - this would be in compiler error
339:55 - if I Define f64 as you can see then it's
339:59 - working
340:02 - all right a function call with
340:05 - explicitly specified type parameter
340:08 - looks like that
340:11 - and this is also called the turbo fish
340:14 - syntax
340:15 - so let's see implement the generic
340:18 - function below
340:21 - so as you can see we are calling here
340:24 - the sum function with different types
340:28 - and that's the whole point of generics
340:30 - so here we are calling sum with two I8
340:34 - integers over here we call this sum
340:38 - function with 2i32 integers remember if
340:43 - nothing is annotated then the default
340:46 - integer type is i32 and here the same
340:50 - thing but for floating Point f 64.
340:55 - so we have to use here generics
340:59 - otherwise this won't be possible over
341:02 - here we are creating our generic type
341:06 - parameter and again by convention this
341:09 - is called t
341:11 - then we take here the arguments
341:15 - so let's say a should be of type T and B
341:20 - should also be of type T and then we
341:23 - return a type of t
341:29 - meaning if we pass here to i8
341:33 - integers then T will get converted to an
341:38 - I8 right this is just a placeholder and
341:43 - because we operate then on two i8s the
341:46 - type the return type will also be I8 so
341:51 - what we do is just adding together the
341:54 - two arguments and return it
342:04 - and over here we have to implement a
342:07 - trade bound and we'll cover that in the
342:10 - next section so we have to Define here
342:16 - that t should implement the add trait
342:19 - otherwise we can't use this plus sign
342:22 - over here
342:25 - and again we will cover that in the next
342:28 - section when we look at trades
342:31 - and as you can see this is compiling so
342:34 - we can pass to sum
342:36 - two numbers
342:37 - of any type
342:42 - let's see number three Implement struct
342:45 - point to make it work as you can see we
342:48 - are instantiating two point structs but
342:52 - over here we are passing to the fields
342:55 - different types so in the first instance
342:58 - we would have i32 values
343:02 - in the second instance we are dealing
343:04 - with floats
343:13 - so to make that possible we have to use
343:16 - generic so let's implement the point
343:18 - struct
343:23 - and we are defining here the generic
343:27 - type parameter
343:29 - and then we can Define the fields
343:36 - and as you can see the fields hold the
343:40 - type
343:41 - t
343:42 - meaning if we pass it intervals then X
343:46 - and Y Must both be integers if we are
343:50 - passing it floats then both of these
343:53 - fields must be of type floats
343:57 - now because we are here defining a
344:00 - generic type parameter this parameter
344:04 - over here becomes part of the type
344:07 - annotation so over here we are providing
344:10 - to the fields of the point struct values
344:13 - of type i32 so we must annotate that
344:19 - and over here we are passing f64
344:27 - and as you can see this is compiling now
344:30 - again we don't have to do the type
344:32 - annotations actually I just want to make
344:35 - that clear as you can see the compiler
344:38 - is able to infer that for us
344:43 - modify the struct to make the code work
344:46 - don't modify this code so as you can see
344:49 - we are here instantiating a point but
344:53 - the fields over here hold different
344:55 - types so this is not working
344:59 - because
345:01 - T over here defines that both of these
345:05 - placeholders will be filled with the
345:08 - same concrete type
345:10 - so in this case if we are passing X
345:14 - over here with an i32 type then the
345:19 - compiler thinks that y should also hold
345:22 - an i32 now what we can do then is
345:25 - defining another generic type parameter
345:29 - and by convention you just go one letter
345:33 - further so T and U meaning we can then
345:38 - use here U right and this
345:42 - indicates that the fields over here hold
345:46 - different types or could potentially
345:49 - hold different types they can also hold
345:52 - the same types
345:54 - and then when we annotate that
345:58 - we have said that the generic type
346:00 - parameter becomes part of the type
346:02 - annotation so we would pass here for x
346:07 - so we would pass here for T and i32
346:12 - the value
346:14 - the type the X field is holding and over
346:18 - here a string
346:22 - so this would be the type annotation for
346:26 - this returned instance
346:33 - number five at generic for well to make
346:36 - the code work don't modify the code in
346:39 - Main
346:40 - so here we have the valve struct holding
346:42 - one field and we have an implementation
346:46 - block implementing one method for the
346:50 - well type now how do I know it's a
346:54 - method because it has as first parameter
346:57 - this self keyword
347:00 - and all this Value method does is just
347:04 - returning a reference to the Bell field
347:07 - value all right so when we instantiate
347:11 - the Bell
347:14 - struct over here we are providing a type
347:17 - of f64.
347:19 - but over here we are instantiating the
347:22 - valve field with a string so again we
347:25 - have different types so let's annotate
347:28 - here the generic type parameter
347:31 - then we can use T here meaning the Field
347:36 - Val can hold any type
347:40 - so let's annotate here
347:53 - now over here as you can see
347:56 - we are returning the value of the Val
347:59 - field and we Define here that it should
348:02 - be of type f64. now this would cause an
348:07 - error because when we call over here
348:10 - the Value method on the instance of Y
348:14 - then self.wall would hold a string right
348:18 - so it doesn't return an f64. now we have
348:23 - to use a generic type parameter also in
348:27 - this implementation block and we can do
348:29 - that like that
348:35 - so we have over here
348:38 - the generic type parameter for our type
348:41 - and as we've said this becomes part of
348:45 - the type annotation
348:47 - and over here we are also defining a
348:51 - generic type parameter T so we are then
348:54 - able to use it inside the implementation
348:57 - block so over here we can Define that it
349:01 - should be a reference to T right a
349:06 - reference to any type that the wall
349:09 - field holds
349:11 - so in the first call of value it would
349:15 - be an F 64 right
349:18 - that is the type of The Returned value
349:23 - that Val field is holding
349:26 - and in the second call over here it
349:29 - would be a string right so T then would
349:32 - be string
349:40 - number six we have here a point struct
349:43 - and we are here defining that the fields
349:46 - could potentially hold different types
349:49 - but they could also be the same
349:52 - and here we have the implementation
349:55 - block for our point struct
350:00 - now as you can see over here we are
350:03 - instantiating a point with I 32 values
350:13 - right so they can be the same even if we
350:17 - here have two generic type parameters it
350:20 - doesn't matter they can be the same but
350:24 - over here we are instantiating point
350:26 - with two different types right
350:35 - we are instantiating point with a string
350:38 - literal this here and HR that over here
350:43 - so they are different in its types
350:48 - then we call over here the mix up method
350:52 - on P1
350:55 - and provided an argument of P2
350:59 - and then over here as you can see we
351:02 - want then P3
351:04 - to look something like that
351:26 - so we want the newly created instance
351:30 - here P3 to hold the value of the first
351:34 - instance in this case P1
351:37 - as you can see we are taking X from P1
351:42 - and we want the Y field to hold the
351:46 - value of the P2 instance of the P2
351:50 - instance this character
351:53 - right so how would we do that with
351:57 - generic type parameters
351:59 - now let's first Implement here the mix
352:03 - up function
352:08 - and again the convention is just the
352:11 - more generic type parameters you are
352:13 - declaring you just go further in the
352:16 - alphabet so T U V W all right
352:21 - and as you can see as a first argument
352:24 - we are taking P1 now let's take
352:28 - ownership we don't care because we don't
352:30 - use P1 after this point meaning we can
352:34 - take ownership and we don't have to use
352:37 - a reference to self here
352:40 - and
352:42 - as an argument here we want P2 meaning a
352:47 - point
352:49 - with generic type parameters we are
352:52 - declaring here
353:00 - and the return type will be a point
353:04 - with
353:05 - a generic type parameter t
353:08 - and a generic type parameter of w and
353:13 - you will see why that is
353:16 - so then what we want to do is creating
353:20 - here a new instance
353:26 - and we provide here x which should be of
353:31 - self because self here refers to P1
353:34 - right so we want self and we want the x
353:38 - value
353:42 - and Y should take it from the second
353:45 - argument the P1 over here and we want
353:49 - the Y field
353:55 - so let me actually annotate that as
353:58 - order
354:00 - [Applause]
354:03 - right we take here another
354:06 - Point instance and this would refer to
354:10 - P2 because we are passing P2 over here
354:14 - to this mix up method so we take from P
354:19 - to d y field
354:22 - and then we are returning this instance
354:24 - meaning P3 will then look something like
354:28 - that right
354:30 - so let me annotate the type
354:33 - we would have a point with the x value
354:37 - of P1 and i32
354:41 - and a character type of P2 the Y field
354:50 - right and that is what we will get
354:54 - let's first see if this even compiles
355:00 - and this is compiling
355:02 - now
355:03 - as you can see we have here a lot of
355:06 - generic type parameters so
355:10 - when we take a look at the mix-up method
355:14 - as you can see we are here declaring new
355:18 - generic type parameters because we want
355:21 - to Define over here that the types self
355:26 - and self again refers to the instance
355:29 - over here P1 that these types are
355:34 - different from the types provided on the
355:38 - second argument the instance of P2 right
355:41 - if we compare it together then P1
355:44 - instance holds different types than the
355:47 - P2 instant so we need new generic type
355:51 - parameters
355:52 - because t and u
355:54 - are for this P1 instance and the other
356:00 - the argument we are here providing P2
356:03 - will hold different types right
356:07 - and as you can see we are then taking
356:10 - from P1 the X field and from P2 we take
356:15 - the Y field
356:16 - and this would be the return type a
356:21 - point
356:22 - with t this is from P1 X and W this
356:28 - would be the second type from DP to
356:32 - point
356:35 - all right
356:38 - fix the errors to make the code work as
356:41 - you can see we have here is tracked
356:43 - point which has two fields which are
356:46 - generic over its type
356:49 - and we Implement over here
356:53 - a method for the point struct over here
356:58 - now this method over here is in fact
357:01 - only implemented for a struct point that
357:06 - holds F 32 types of fields right so if
357:13 - we would pass floats then this method is
357:16 - not implemented for a point
357:19 - so this is only implemented for point
357:21 - with a concrete type of F32
357:26 - now
357:28 - then over here we are calling on the
357:31 - fields X
357:33 - the power integer method
357:37 - and let's see that in the rust
357:39 - documentation
357:44 - so as you can see
357:46 - the power integer
357:48 - method over here is actually implemented
357:52 - for f 64 types right so self in this
357:57 - case must be of type f 64.
358:02 - as you can see over here we have X which
358:05 - holds an F 64 type so we can we can call
358:09 - this method on X right again this is a
358:14 - method and not a function
358:21 - so the problem over here is that self in
358:24 - this case would be F32 which is not the
358:29 - right type so let's change that f64
358:33 - and that means self over here would be
358:36 - of type f64 the concrete type we are
358:40 - providing here
358:42 - and then of course the return type would
358:45 - be f64 right because we are here
358:49 - performing an operation on two f64 types
358:54 - now
358:57 - over here of course we have to provide
359:00 - floating Point values right because
359:03 - again this method is only implemented
359:07 - for a point that holds as Fields F 64
359:13 - types
359:15 - like that
359:19 - all right and then we can use this
359:21 - method as defined in the standard
359:24 - Library
359:32 - and of course over here
359:35 - we just have to annotate one type right
359:38 - because we only have one generic type
359:41 - parameter
359:43 - and as you can see this is compiling and
359:46 - I will see you next time
359:49 - so I've told you that we will take a
359:51 - brief look at const generics and I will
359:54 - just solve one exercise and leave it at
359:57 - that because constant generics is a more
360:00 - advanced topic and you don't need it
360:03 - that much in your everyday programming
360:06 - so they're useful at some situations but
360:10 - they are not that much used
360:13 - so let's see an example over here we
360:16 - have here a struct array
360:19 - so we have here destruct array which
360:22 - defines two generic type parameters t
360:27 - and n
360:28 - now T is a generic type parameter and
360:32 - n over here is a const generic type
360:35 - parameter
360:36 - and as you can see each array struct
360:39 - holds a data field with an array
360:43 - of type t and n elements
360:48 - all right
360:49 - so when we look over here we have an
360:52 - array and I will now annotate this type
360:55 - of type array
360:59 - right this struct
361:03 - distract we have defined over here we
361:06 - are holding three instances as you can
361:09 - see one two three three instances of
361:13 - this array struct right
361:18 - like that
361:20 - now I've told you that when
361:23 - we have generic type parameters it
361:27 - becomes part of its annotations we have
361:30 - to annotate it over here too
361:33 - in fact we don't have to do that because
361:35 - it's usually inferred by the compiler
361:38 - but I will do it right now so
361:42 - this over here cares about the types in
361:46 - the aerated data field holds so as you
361:49 - can see we have here integers we have
361:52 - here
361:53 - floats and over here we again have
361:56 - integers
361:57 - and what that means is that in this
362:00 - array over here these actually should
362:03 - all hold the same type because we have
362:07 - to provide here a concrete type right
362:10 - for T and that means
362:13 - this data field over here will then hold
362:16 - in its array this type so in this case
362:20 - we will do i32
362:22 - and we need to provide it a constant
362:26 - meaning for the length of the array in
362:29 - this case we Define three all right
362:34 - and what that means is that the arrays
362:37 - inside the data field of these instances
362:41 - must be of i32 type and they must have a
362:46 - length of 3. right so we can't use
362:50 - floats here we have to use i32
362:54 - and over here we need to add another
362:57 - element
362:58 - now they can't be different for example
363:02 - let's do it like that
363:05 - that is possible
363:07 - but all of them over here must have the
363:11 - same type and the same amount of
363:15 - elements because we are annotating that
363:17 - here
363:19 - so it complies with the generic type
363:23 - parameter annotations here
363:27 - now let's create another array
363:32 - with floats
363:35 - now I want this to hold array instances
363:40 - of type f64
363:44 - and let's do two elements
363:48 - and I will pass here
363:51 - let's say also three
363:57 - and that means
364:03 - inside here
364:05 - let's first look at the outside array at
364:08 - this array over here so we want three
364:11 - elements of
364:14 - type array this array struct right
364:18 - so let's define that
364:33 - like that as you can see we have here
364:35 - three
364:38 - elements of type array now we Define
364:42 - here for the generic type parameters
364:45 - that
364:46 - the data field
364:55 - the data field should hold an array
365:04 - right because this is defined over here
365:08 - in the array struct
365:10 - so each data field should hold an array
365:14 - of f64 right the T over here
365:20 - of two elements right
365:24 - this is the const generic parameter so
365:28 - we are passing here a constant and not a
365:31 - type
365:33 - so in this case
365:36 - we the data field would have concrete
365:39 - types of f64 and two elements right so
365:45 - let's fill that out
366:00 - like that
366:02 - as you can see this is compiling because
366:04 - we are here complying with the generic
366:09 - type parameters
366:10 - we have three
366:13 - array instances
366:15 - right and each array instance holds a
366:18 - data field with these types
366:22 - f64 and they have to be two elements
366:27 - inside the array
366:29 - all right see in the next topic
366:34 - we will now cover trades so a trade is a
366:37 - set of methods that can be implemented
366:40 - for multiple types in order to provide
366:43 - common functionality and behavior
366:46 - between them a trade consists only of
366:49 - method signatures which then have to be
366:53 - implemented by the Target type it's
366:56 - similar to classes in other languages
366:59 - but not quite the same and it defines
367:03 - shared behavior in an abstract way so
367:07 - let's see how that might look like
367:10 - as you can see over here we have two
367:13 - custom types sheep and Cal now we want
367:17 - to indicate that these are somewhat
367:19 - related so over here we have created a
367:23 - trade anime which defines one method
367:28 - then over here we are implementing the
367:31 - animal trade for sheep and for cow now
367:36 - when we Implement a trade for some type
367:39 - then we have to implement all the
367:42 - methods the trade
367:45 - defines so in this case as you can see
367:47 - in the trade animal we only provide it
367:51 - with a function signature and then the
367:55 - concrete types for example sheep and cow
367:58 - will implement the method and Its
368:01 - Behavior
368:03 - so as you can see both sheep and cow
368:07 - then implement the animal trait meaning
368:10 - they automatically implement the method
368:14 - right
368:17 - so both of them
368:19 - take a reference to its instance for
368:24 - example an a ship instance and then just
368:28 - return the string over here
368:31 - and the same thing for cow
368:35 - now there is also derivable traits and
368:38 - we have seen that before a trait can be
368:41 - automatically implemented for a struct
368:44 - or an enum by the rust compiler these
368:47 - are called derivable because they can
368:49 - beat derived automatically
368:52 - and the most common derivable traits are
368:55 - debug allowing to Output content via
368:58 - this debug notation we have seen that
369:01 - clone which enables a type to be
369:04 - duplicated with the Clone method
369:08 - copy enables a type to be copied
369:10 - implicitly without requiring explicit
369:14 - clone method and partially queue enables
369:18 - comparison
369:22 - now we can pass trades as parameters so
369:27 - the notify function over here takes as
369:29 - an argument any type that implements the
369:33 - summary trade
369:35 - meaning we can ensure that the item
369:39 - argument over here implements this
369:42 - summarize method right if we provide
369:46 - here A type that didn't implement this
369:50 - summary trait then it wouldn't have this
369:52 - summarize method
369:55 - trades can be used as parameters for
369:57 - functions the function notify takes as
370:01 - an argument any type that has
370:03 - implemented the summary trait
370:07 - now there is also a concept called trade
370:10 - bounce
370:11 - meaning if we declare over here a
370:15 - generic type parameter we can define
370:18 - that
370:20 - the type over here must implement the
370:24 - summary trade so the argument we pass to
370:27 - this notify function must implement this
370:31 - summary trait
370:34 - and this is similar to the example using
370:37 - the impulse summary but more verbose
370:40 - so as you can see this would actually be
370:43 - exactly the same like we did over here
370:47 - trade bounds are declared like generics
370:50 - after the name of the function and use
370:54 - trade bounds if you have lots of
370:56 - parameters to avoid this so if we would
371:00 - have here an argument which takes a
371:04 - typed Implement summary and another
371:07 - argument which
371:09 - again takes a type that implements
371:12 - summary we can do it like that so we
371:15 - Define here a trade bound meaning the
371:19 - generic type T must implement this
371:23 - summary trait so both argument 1 and
371:27 - argument 2 take a reference to a type
371:31 - that implements the summary trait
371:35 - and if you have big trade bounds like
371:38 - for example this we have here generic
371:41 - type parameter T and we say here that
371:44 - the type T has to implement the display
371:47 - and decline trades
371:49 - and the generic Type U has to implement
371:53 - the Clone anti-debug trait right and
371:57 - then over here as you can see the first
371:59 - argument must be of type T and the
372:03 - second one of Type U and we are taking
372:05 - references
372:08 - so we can write that in a more concise
372:11 - way using a verb Clause meaning after
372:15 - the return type in a function we can use
372:18 - the verb keyword and then over here
372:21 - Define our trade bounds and this over
372:25 - here is exactly the same as this but
372:29 - instead of
372:31 - defining the trade bounds directly on
372:34 - the generic type parameter we do it in a
372:37 - separate block
372:42 - foreign and we can also
372:45 - return from a function a type that
372:49 - implements a specific trait so as you
372:52 - can see the return dog function over
372:55 - here returns an instance of the dog
372:58 - struct
372:59 - and because the animal trade over here
373:03 - has been implemented for torque we can
373:06 - also Define the return type as follows
373:10 - we return here an instance of talk
373:13 - meaning we return here
373:16 - a type that implements the animal trade
373:19 - because as you can see animal is
373:22 - implemented for the dog struct
373:26 - let's see exercise one feeling the two
373:29 - input blocks to make the chord work
373:31 - don't modify the code in main now we
373:35 - have here a trade hello
373:38 - finding two methods now over here you
373:42 - can see that we didn't only provide the
373:45 - function signature but we implemented
373:48 - basically the whole method why is that
373:51 - because this is considered the default
373:54 - implementation meaning any type that
373:58 - implements the hello trade automatically
374:00 - gets this default implementation of this
374:04 - method so we don't have then to
374:09 - implement it manually it will
374:12 - automatically get implemented for the
374:15 - type that implements the hello trade
374:19 - but as you can see over here we have a
374:21 - method which is here just a function
374:25 - signature so we have to implement that
374:28 - manually
374:30 - then over here we have two structs
374:32 - student and teacher and we Implement
374:36 - over here the hello trade for student
374:39 - and for teacher
374:42 - so let's see we have here an instance of
374:45 - student
374:47 - and as you can see this is just a struct
374:51 - that doesn't hold any values right so we
374:55 - instantiate it like that
374:57 - but because
374:59 - we have here implemented hello for the
375:03 - student struct that means we can then
375:07 - call upon it
375:09 - this method over here as you can see we
375:13 - call this say hi method on the S
375:15 - instance and then it should return high
375:19 - now we don't have to implement this say
375:22 - hi method over here again like that
375:31 - we don't have to do that because it's
375:34 - already implemented by default right
375:38 - but what we have to implement is to say
375:41 - something method because as you can see
375:44 - we are calling the say something method
375:47 - on the instance of s and remember when
375:51 - we Implement a trade for a type in this
375:54 - case student we have to implement all
375:58 - the methods
375:59 - except the default implementation here
376:03 - so let's actually
376:05 - take this and copy it over
376:09 - because the function signature must be
376:12 - exactly the same like defined in the
376:16 - trade
376:17 - and then over here we want the return to
376:20 - be I'm a good student
376:24 - so let's return this string here
376:34 - like that
376:39 - so when we call
376:42 - on an instance of student this say
376:46 - something method then it will return I'm
376:50 - a good student
376:52 - now over here we are instantiating the
376:55 - teacher struct
376:59 - and as you can see we are calling the
377:01 - method on the T instance and this should
377:05 - be the returned string so as you can see
377:08 - this is different from what is
377:11 - implemented in the default
377:13 - implementation and that means we have to
377:16 - re-implement this say hi method for the
377:19 - teacher type
377:32 - and the return string should be hi I'm
377:35 - your new teacher
377:43 - so as you can see if a trade defines a
377:46 - default implementation we can also
377:50 - overwrite
377:51 - the default implementation and provide
377:55 - another return value
377:58 - and of course because we have to
378:01 - implement
378:02 - this over here I will copy that
378:06 - and I will implement it for the teacher
378:09 - type
378:12 - so as you can see when we call
378:14 - the say something method on an instance
378:17 - of teacher then we should get back this
378:20 - string
378:29 - so as you can see we have then
378:32 - implemented the hello trade for our
378:36 - custom types student and teacher let's
378:40 - see if that compiles
378:44 - and this is compiling
378:47 - derived the compiler is capable of
378:50 - providing basic implementations for some
378:53 - trades via ddrive attribute for more
378:57 - info please visit here
378:59 - let's see over here we have a tuple
379:02 - struct centimeters which holds a value
379:05 - of type f64 now as you can see this
379:10 - truck here derives to trades partially q
379:14 - and partial order meaning the compiler
379:18 - will automatically Implement these
379:21 - trades for our type centimeters
379:25 - now partially Q is for comparing
379:28 - equality and partial order is for
379:31 - ordering
379:32 - so over here we have inches and and
379:37 - inches is a tuple struct that holds an
379:40 - i32 type
379:43 - and it derives the debug trade meaning
379:46 - we can print it out using the debug
379:49 - notation
379:51 - and as you can see over here we
379:53 - Implement a method two centimeters for
379:57 - an instance of the inches type
380:00 - so when we call
380:02 - this
380:04 - method on an instance of inches then we
380:08 - will convert it to centimeters right so
380:12 - we hear the reference self meaning the
380:15 - instance
380:17 - of inches and then we destructure over
380:22 - here
380:23 - the inches basically the value
380:27 - that the Tuple struct inches holes so
380:31 - this variable then will hold the value
380:35 - of
380:37 - the instance provided here okay and then
380:42 - as you can see we are multiplying inches
380:44 - by 2.54 to convert it to centimeters and
380:49 - we are wrapping that
380:52 - and we are returning that as an instance
380:57 - of centimeters as you can see
381:05 - add some attributes to make the code
381:08 - work don't modify other code
381:11 - so as you can see over here we are
381:13 - instantiating this seconds struct
381:19 - [Applause]
381:23 - so then we are printing it out using
381:27 - debug notation so we have to derive over
381:30 - here the debug trade
381:36 - then we are here comparing for equality
381:40 - so we have to
381:42 - derive The partially Q trait
381:47 - and over here we are checking if one
381:50 - second is bigger than one second meaning
381:53 - we need to implement the partial order
381:58 - trade
381:59 - like that
382:03 - and as you can see we are here
382:05 - instantiating the inches struct
382:09 - providing it a value of 12 right this
382:14 - i32 type
382:18 - and then we print it out
382:21 - and let's check debug is implemented so
382:24 - we can print it using debug notation and
382:29 - over here we are instantiating the
382:31 - centimeter struct
382:34 - [Applause]
382:36 - as you can see centimeters takes a value
382:39 - of f64.
382:43 - and over here we are comparing
382:49 - as you can see over here this foot
382:52 - instance
382:54 - holding an instance of inches with 12.
382:58 - so in the U.S 12 inches equal one foot
383:04 - and then we call the two centimeters
383:06 - method on it mean meaning this will then
383:10 - return an instance of centimeters right
383:14 - so we are taking here inches 12.
383:19 - and that means
383:20 - 12 over here will get destructured right
383:24 - here we have
383:28 - here self would be inches 12 and we take
383:32 - it as an reference like that so
383:37 - we destructure it like that using the
383:40 - let keyword the reference because we
383:43 - want to take the value and not a
383:46 - reference and then 12 will be put inside
383:50 - the inches variable
383:53 - then we are multiplying by
383:56 - 2.54 and returning an instance of
384:01 - centimeters and that means
384:05 - we can then compare this over here
384:10 - with the meter because the meter holds
384:14 - also the same type namely the custom
384:18 - type centimeters over here
384:21 - right
384:23 - so both
384:25 - types would be here of type centimeters
384:33 - and if this is smaller than this then it
384:37 - will
384:39 - assigned to this variable
384:41 - a string smaller otherwise bigger and
384:46 - these are string literals by the way
384:49 - and over here we are outputting
384:52 - the result of this compare
385:00 - let's see
385:06 - and as you can see this is compiling
385:10 - so we are outputting here one second
385:12 - looks like seconds one as you can see we
385:16 - can
385:17 - output this
385:21 - type over here seconds because we have
385:24 - derived the debug trade meaning we can
385:29 - use debug notation
385:32 - then one foot equals inches 12.
385:36 - and over here this one foot is smaller
385:40 - than one meter
385:43 - operator in Rust many of The Operators
385:46 - can be overloaded via trades that is
385:49 - some operators can be used to accomplish
385:52 - different tasks based on their input
385:55 - arguments this is possible because
385:58 - operators are syntactic sugar for method
386:02 - called example the plus operator in a
386:05 - plus b calls the add method as in a at B
386:10 - over here this would be a method this
386:14 - add method is part of the add trade
386:17 - hence the plus operator can be used by
386:21 - any implementer of the add trade
386:27 - so Implement implement the function
386:31 - multiply to make the code work as
386:34 - mentioned above plus needs T to
386:37 - implement standard Ops add trait
386:41 - that's why we are here importing the Ops
386:44 - module from standard Library
386:48 - so let's implement the multiply function
386:51 - as you can see over here we are
386:54 - providing two u8 integers to the
386:58 - multiply function now in the second call
387:01 - over here we are providing flow means we
387:04 - need a generic type parameter like that
387:08 - so this function takes two arguments
387:17 - and it will return T basically the same
387:21 - type of the provided arguments
387:27 - and then over here we basically just
387:30 - want to multiply a by B now as you can
387:35 - see over here we are using the operator
387:37 - for multiplications
387:40 - and that means we have to ensure that
387:44 - the T over here
387:47 - the type of the arguments that the
387:51 - multiply function takes
387:54 - implements the Mal trait
387:57 - now the mall trade like the add trades
388:00 - over here
388:02 - then knows that if both of the types of
388:08 - A and B Implement The Malt rate it is
388:12 - possible to multiply these two together
388:15 - so we can use here a trade bound meaning
388:20 - the type T over here should implement
388:28 - should implement the standard of malt
388:32 - rate
388:32 - because again this is just overloading
388:37 - and syntactic sugar for this call
388:43 - right
388:45 - so this actually would translate to this
388:49 - and we are seen in the add over here
388:51 - that it would be a at B right
388:56 - these operators are just overloaded so
388:59 - it's easier to use
389:02 - and that's why we have to ensure that a
389:07 - this argument here of type T has
389:11 - actually implemented the Mal method
389:16 - and we make sure that this is the case
389:19 - when providing here a trade bound
389:22 - meaning T must Implement The Malt rate
389:26 - meaning then that t has implemented the
389:31 - Mal method let's see
389:57 - and we have here to also
390:02 - find that the output will be of type t
390:06 - because as you can see the mult rate
390:08 - over here
390:10 - has an Associated type of output so we
390:14 - have to Define and we will take a look
390:16 - at Associated types
390:19 - but we have here to Define that the
390:21 - output should of type t
390:24 - that the output should be of type T
390:27 - right
390:29 - let's see again
390:32 - and this is working
390:36 - fix the arrows don't modify the code in
390:39 - main so over here again we are using the
390:42 - Ops module from the standard Library
390:45 - then we have here two structs full and
390:47 - power and full bar and Powerful
390:52 - the standard Ops add trade is used to
390:56 - specify the functionality of the plus
390:58 - operator here we make add bar to trace
391:03 - for addition with a right hand side of
391:06 - type bar the following block implements
391:09 - the operation full plus bar should
391:13 - return powerful so if we
391:16 - USD plus operator with these two types
391:20 - over here we should return this type
391:22 - right full plus bar should return full
391:26 - bar
391:28 - now let's see the add
391:31 - tray
391:32 - now the add trade over here takes as
391:36 - default parameter
391:39 - rhs standing for right hand side
391:43 - if we don't provide anything to right
391:45 - hand side then it will be self meaning
391:48 - the type we implement the add trade on
391:53 - and as you can see we have an Associated
391:56 - type here for the output
392:00 - and over here as you can see it takes
392:04 - self and basically becomes the owner
392:07 - when called on an instance that
392:09 - implements the add trade
392:12 - and right hand side is off type right
392:16 - hand side which means by default it
392:20 - would be self
392:21 - and this looks confusing I know but you
392:25 - will get it when we Implement that over
392:28 - here
392:29 - so as you can see we are implementing
392:31 - from the Ops module the add trade so we
392:35 - can Implement from this standard Library
392:38 - trades for our custom types
392:43 - and
392:45 - let's see
392:47 - again
392:51 - when doing something like that
392:53 - [Applause]
392:56 - then
392:59 - then the compiler will actually do
393:02 - something like that
393:08 - right it will call the add method now
393:12 - this over here is the type here would be
393:15 - an instance of Foo but just so you get
393:19 - the concept
393:23 - and as you can see we have here to
393:26 - define the right hand side meaning the
393:29 - right hand side over here would be poor
393:32 - and we are implementing the add trade
393:35 - for Foo right
393:37 - because we want the instance to be of
393:40 - Type 4 so we implement it for Foo
393:46 - and we want the right hand side to be of
393:49 - type bar now if we wanted
393:53 - to add for example
394:02 - then we could omit that because you are
394:05 - seeing that the default
394:08 - itself right so the default right hand
394:11 - side would be
394:13 - self as you can see
394:16 - so we can omit that but
394:20 - the
394:22 - bow but that means both types must be
394:26 - the same in this case Foo and fool right
394:29 - because self over here refers to the
394:33 - type we are implement the trade four
394:37 - right but in this case it would be bar
394:40 - right because the right hand side is
394:43 - different from the left hand side
394:47 - and the output should be of type full
394:50 - bar so as and again Associated functions
394:54 - we will cover that very soon
394:57 - so over here we have to implement the
395:01 - add method right because the
395:04 - add trade over here defines an add
395:08 - method so we have to implement it
395:13 - and that means we take self and this is
395:17 - taking ownership of an instance of Foo
395:21 - right
395:23 - and right hand side would be of type bar
395:28 - again
395:30 - as you can see Foo would be the instance
395:32 - then we call the add method upon the
395:35 - instance and this argument should be of
395:39 - type par and then we return full bar
395:45 - so in Main
395:48 - when we call
395:51 - so in main when we perform this over
395:54 - here full plus bar we will get back full
395:57 - bar right
395:59 - so we have implemented the plus operator
396:03 - on our custom types
396:07 - now let's do the same for minus sign but
396:11 - in this case full minus bar would be
396:14 - powerful
396:15 - so let's see as you can see this would
396:18 - be distract we want to return powerful
396:23 - so
396:25 - minus sign
396:33 - is actually the same but implementing
396:35 - this sub trade
396:38 - so we will type full sub
396:41 - R right this would be the sub method
396:44 - defined in this sub trade as you can see
396:48 - we are here implementing
396:51 - the substrate from the Ops module
396:55 - for bar
396:57 - now again we want actually to implement
397:00 - it for Foo because here
397:04 - we
397:05 - call Foo support meaning we would
397:10 - implement it for the foo instance
397:17 - because cell 4 here refers to the
397:20 - instance the method is called upon right
397:24 - so the sub will be called upon self
397:27 - meaning we have to implement it for Foo
397:31 - and the right hand side would be bar
397:36 - now we want to return bar food that's
397:39 - true
397:40 - and
397:42 - over here as you can see
397:45 - the sub method is implemented but as
397:49 - right hand side the type should be bar
397:52 - right this is the right hand side of the
397:56 - operation
398:00 - and we are returning powerful so when we
398:04 - do this full minus 4 we will get back
398:07 - powerful so we have overloaded this
398:10 - operator
398:16 - and of course to do assert EQ here
398:19 - because this is a custom type we have to
398:23 - implement the partial EQ trade so let's
398:27 - do that
398:47 - and we also have to implement the debug
398:50 - trade
398:59 - as you can see this is compiling meaning
399:02 - when we use our custom types with these
399:05 - operators they will return a custom type
399:09 - and we can do that by implementing from
399:12 - the Ops module from the standard Library
399:15 - the appropriate trades
399:18 - for our custom types
399:22 - use trade as function parameters
399:25 - instead of a concrete type for the item
399:28 - parameter we specify the input keyword
399:31 - and the trade name this parameter
399:34 - accepts any type that implements the
399:37 - specified trade
399:41 - as you can see we have here a trade
399:44 - summary
399:45 - Implement function summary to make the
399:48 - code work fix the errors without
399:50 - removing any code line
399:53 - so over here we have a struct post with
399:56 - three fields of type string
399:59 - and we Implement over here this summary
400:03 - trade for the Post struct meaning we
400:07 - have to implement the defined method in
400:11 - the trade
400:12 - so we implement it for post like this as
400:16 - you can see we are accessing from the
400:19 - instance remember this is a method so it
400:23 - refers to an instance
400:25 - it is called upon right
400:28 - so we access the fields self.title and
400:32 - self dot author all right
400:38 - then over here we have a struct Weeble
400:41 - with two fields of type string then we
400:44 - implement the summary trait for Weeble
400:47 - and we then have to implement the method
400:51 - from the trade all right because again
400:54 - when we Implement a trade for a type we
400:59 - have to implement its methods
401:03 - so this over here accesses the username
401:06 - and contact field and prints it out
401:11 - now here we have an instant of post
401:14 - and here we have an instance of weibo
401:21 - so as you can see we are here calling
401:23 - this summary function with an argument
401:26 - of post and weibo so we have to
401:30 - implement this summary function below
401:32 - let's do that
401:37 - now
401:38 - as an argument
401:41 - it takes
401:44 - now as an argument it takes
401:47 - in the first call Post and in the second
401:50 - call Weeble right two different types
401:54 - but now think about it what do they
401:57 - share in common
401:59 - write they implement this summary trade
402:03 - right we have implemented it for post
402:06 - and for Weeble so we can Define over
402:09 - here that the argument provided must be
402:13 - a type that implements the summary trait
402:18 - and we do it like that
402:21 - and then inside the function body we
402:24 - want to take this argument
402:27 - and again a is an instance of a type
402:31 - that implements the summary trait so we
402:35 - are taking a and we call upon it the
402:37 - summarize method
402:43 - meaning
402:45 - the first one it will be post dot
402:48 - summarize
402:49 - now post over here is of type post
402:53 - meaning we go to post and as you can see
402:56 - this would be the summarize method as
402:59 - you can see self would refer to the
403:01 - instance in this case post
403:05 - this instance over here
403:09 - so then the summarize method will return
403:12 - a string
403:13 - so let's actually
403:15 - assign this to a variable
403:18 - [Applause]
403:22 - this would then hold this string and we
403:24 - can then output
403:32 - like that let's see
403:36 - and of course
403:38 - when we are calling the summary method
403:42 - with an instance then we can't use the
403:45 - instance again so let's define here that
403:48 - it should take a reference
403:51 - right
404:00 - and as you can see this is compiling
404:04 - now what we can do over here
404:06 - and this would be exactly the same we
404:10 - can Define here a generic type parameter
404:13 - T and here Define that it should
404:17 - Implement summary right so we Define
404:20 - here the type t
404:23 - and it should be a type that must
404:26 - Implement summary and then we can write
404:29 - it like that
404:31 - so a should then be a reference of type
404:34 - T which implements summary trait let's
404:37 - see
404:39 - as you can see exactly the same thing
404:45 - returning types that Implement rates we
404:48 - can also use the infiltrate syntax in
404:51 - the return position to return a value of
404:54 - some type that implements a trade
404:57 - however you can only use input trade if
405:00 - you're returning a single type use trade
405:03 - objects instead when you really need to
405:06 - return several types
405:09 - so over here we have two custom types
405:12 - sheep and Cal and we have one trade
405:15 - animal which has one method
405:19 - so over here we are then implementing
405:21 - the animal trades for both of these
405:24 - custom types
405:26 - and as you can see when we Implement a
405:29 - trade for a concrete type then we have
405:33 - to implement the given method
405:37 - so over here we have a function random
405:41 - animal it takes a random number and then
405:45 - and then looks if the random number is
405:48 - less than 0.5 it will return a sheep
405:52 - instance otherwise it will return a cow
405:56 - instance
405:58 - now over here the return type of the
406:01 - function would be a type that implements
406:05 - the animal trade which both of them do
406:10 - and as you can see in main we have here
406:12 - our random number
406:17 - and we call this random number on the
406:21 - random animal function so let's for now
406:24 - assume that this really is random okay
406:28 - so that means that when this is passed
406:32 - over here it could either be a sheep or
406:36 - a cow to be returned here
406:40 - but the problem here is that the return
406:44 - type in a function must be of known
406:48 - fixed size at compile time
406:51 - which in this case sheep might be bigger
406:54 - than cow or cow might be bigger than
406:57 - sheep so the exact size is not known at
407:02 - compile time so when we do that
407:05 - this doesn't work
407:08 - and to make that work we have to know
407:11 - about trade objects so let's see
407:16 - so trade objects using input traits
407:19 - doesn't work when returning multiple
407:22 - types different implementations of a
407:25 - trade probably with different amounts of
407:28 - memory but sizes of types must be known
407:32 - at compiled time in this case a trade
407:35 - object can be used a trait object is
407:39 - essentially a pointer to any type that
407:42 - implements the given trade where the
407:45 - precise type can only be known at
407:48 - runtime
407:51 - so
407:53 - over here for example we have a trade
407:56 - animal and two custom types token cat
407:59 - then we implement the trade animal for
408:03 - both of these types
408:05 - and as you can see we have a function
408:08 - return animal it takes a string and if
408:12 - this string is dark then it returns a
408:16 - dog instance now if it returns cat then
408:20 - it returns a cat instant but as you can
408:24 - see we are here providing a reference to
408:27 - the instance and not the incense itself
408:30 - because when we return a reference to a
408:34 - type that implements the animal trade it
408:38 - means that the size of this type is
408:41 - known at compile time because remember a
408:44 - reference is a pointer and the size of a
408:48 - power and the size of a pointer is known
408:52 - at compile time meaning it's of Type U
408:55 - size and U size is 8 bytes on a 64-bit
409:00 - computer
409:02 - so the size of the return type is known
409:07 - it's just a pointer sized type
409:11 - so the size of the return type is known
409:15 - at compile time it's of size U size
409:18 - right because we are here returning a
409:22 - pointer meaning it doesn't matter if dog
409:25 - is bigger than cat or otherwise
409:28 - it's always the same size because
409:32 - pointers have a fixed size at compile
409:35 - time
409:37 - and that is how we would
409:40 - solve this problem so again here we have
409:43 - a function which
409:45 - so here we have a function which returns
409:48 - a type that implements the animal trade
409:51 - this could be dog or cat as the trade
409:55 - object is behind the pointer the size is
409:58 - known at compile time which is U size
410:01 - the size of a pointer this allows for
410:05 - more flexible code as the exact return
410:07 - type doesn't have to be known at compile
410:11 - time as long as the size is fixed
410:14 - so we don't care anymore about the size
410:17 - of dog and cat because they're behind a
410:21 - pointer
410:23 - and to understand what's going on you
410:25 - have to know about static and dynamic
410:28 - dispatch so let's first look at static
410:31 - dispatch
410:33 - static dispatch resolves method calls at
410:36 - compile time the compiler will generate
410:40 - function code for each concrete type
410:43 - that implements the trade
410:45 - it calls the appropriate function based
410:48 - on concrete types it's faster and more
410:52 - efficient than Dynamic dispatch but it
410:55 - doesn't provide great flexibility
411:00 - so we have here the trade animal
411:04 - holding one method say hi then we have
411:08 - Talking Cat and we implement the animal
411:11 - trade for dog and for cat
411:15 - now as you can see when we create an
411:17 - instance from dog and from cat and call
411:20 - the say hi method on it because as you
411:25 - can see every
411:27 - every type that implements the animal
411:30 - trait must have this method
411:33 - and when we then run this program then
411:37 - the compiler will actually generate
411:40 - methods for each concrete type in this
411:43 - case stock or cat
411:45 - because then the say hi method we are
411:49 - calling here on the dog and cat instance
411:53 - is known at compile time
411:56 - so the compiler then knows when we call
411:59 - the method on the dog or cat instance
412:03 - which method has to be resolved for
412:07 - which type
412:10 - so let's see Dynamic dispatch
412:12 - in Dynamic dispatch the specific methods
412:16 - to be called is determined at runtime
412:20 - and not at compile time like static
412:22 - dispatch
412:23 - it works by creating a reference or
412:26 - smart pointer to a trade object using
412:30 - reference din or boxed in when trade
412:35 - object is created the compiler will
412:37 - build a v-table for that trade a v table
412:41 - is a table that contains a pointer to
412:44 - the implementation of each method in the
412:48 - trades for the specific type of the
412:50 - object that the reference points to
412:55 - the compiler will do a lookup in a V
412:58 - table to determine which method should
413:01 - be called for which type that implements
413:04 - the given trade
413:06 - and this lookup will cause overhead but
413:09 - allows for more flexible code
413:12 - so exactly because of this lookup
413:15 - static dispatch is faster than Dynamic
413:19 - dispatch but on the other hand Dynamic
413:22 - dispatch allows for more flexibility
413:26 - so let's see how that might look like as
413:30 - you remember with box we are able to
413:33 - allocate a type to Heap memory meaning
413:38 - the type will then get allocated for
413:41 - example a
413:42 - i32 integer like 7 will get allocated to
413:47 - the Heap and we will then get back a
413:50 - pointer this is what box is for and we
413:54 - have seen examples of that now when we
413:57 - use box with a trait object it means
414:00 - that the
414:03 - type that implements the specific trade
414:06 - will get allocated in Heap memory get
414:10 - back a pointer to the location where the
414:14 - type that implements this specific trait
414:16 - was allocated and we will get back a v
414:21 - pointer right this is happening when
414:24 - dynamically dispatching so the V pointer
414:28 - points to the V table
414:30 - and in the v table there are certain
414:34 - Fields now there is also a field called
414:37 - Methods and this is where all the
414:40 - methods for the concrete type over here
414:43 - are located meaning at runtime the
414:48 - compiler will check this V table and see
414:52 - in the methods over here which methods
414:55 - are implemented for the concrete type
414:58 - that was allocated in Heap memory
415:03 - so let's see an example
415:06 - so we have over here a trade animal and
415:10 - we have two custom types cat and talk
415:12 - and we implement this method defined in
415:16 - the trade for both of our types right
415:20 - because when we Implement a trade for a
415:23 - custom type we have to implement all of
415:27 - its defined methods
415:29 - so over here we have seen we have a
415:33 - random animal function which takes a
415:35 - random number and based on this
415:37 - conditional it will either output a cad
415:41 - instance or a dog instance
415:45 - so then when we call this random animal
415:48 - function with the random number and for
415:50 - now just assume that this is really a
415:53 - random number
415:54 - that means the compiler first of all
415:56 - cannot determine the size of the type
416:00 - which gets returned and this is of type
416:03 - that implements the animal trade right
416:06 - cat and dog both implement the trade but
416:10 - we can't know the exact size at compile
416:14 - time meaning we put it behind a pointer
416:18 - in this case a box but a reference would
416:21 - also be possible and that means the size
416:24 - is now known right it's the size of a
416:28 - pointer basically U size 8 bytes in a
416:32 - 64-bit computer
416:34 - but we have another problem over here
416:38 - the return value will be
416:41 - a type that implements the animal trade
416:44 - but at compile time when we call the
416:47 - noise method over here the compiler
416:51 - doesn't know
416:53 - which
416:54 - of these types get returned so he so the
416:58 - compiler can't know which method he has
417:03 - to call is it for the implementation on
417:06 - cat or dog right
417:09 - so this is why we use Dynamic dispatch
417:13 - because that means this over here will
417:16 - get decided at run time so again the
417:20 - compiler will then look up in this B
417:23 - table over here using the V pointer
417:25 - which points to the V Table stores in
417:28 - heaped memory and and then it will check
417:31 - for the concrete type that got allocated
417:34 - on Heap memory this specific methods
417:38 - so for example again this is happening
417:41 - at runtime
417:42 - we return a cat then the compiler will
417:46 - see that the type over here which is
417:48 - concrete is cat so it will see in the v
417:52 - table the methods implemented for the
417:56 - concrete type of cat
417:58 - I hope this makes sense
418:01 - so this is why we need Dynamic dispatch
418:04 - here static dispatch doesn't work
418:07 - because again the output of this
418:10 - function is random
418:15 - so let's see box box is a smart pointer
418:19 - that allows to store data on the Heap
418:22 - rather than this stack and you can use
418:25 - box when you have a type whose size
418:27 - can't be known at compile time it
418:31 - returns a pointer to the data stored on
418:34 - the Heap
418:36 - so what's the difference between a
418:39 - reference and a box in terms of memory a
418:43 - box allocates the data on the Heap and
418:46 - owns it
418:47 - is also responsible for deallocating
418:50 - when the value goes out of scope and the
418:53 - reference only points to a value that is
418:56 - already in memory meaning the reference
419:00 - points to something that is already
419:03 - there while a box allocates and a and
419:08 - the reference also doesn't own anything
419:10 - it just points to something
419:14 - in terms of lifetimes a box can be
419:17 - passed across Scopes while the reference
419:19 - has limited lifetime and we will cover
419:22 - lifetimes very soon a box can be cloned
419:26 - and the reference cannot and the Box can
419:29 - also be used in pattern matching
419:34 - so
419:35 - we have left off over here and I hope by
419:39 - now you know that this over here is not
419:42 - possible we cannot return a type which
419:46 - implements the animal trade because
419:48 - these could vary in size
419:52 - and again over here we return
419:55 - a type that implements the animal trade
419:59 - now if this over here would be really a
420:02 - random number then we don't know exactly
420:05 - at compile time which type gets returned
420:08 - meaning we can't use here the noise
420:11 - method because the compiler can
420:14 - impossibly know at compile time of
420:18 - course which
420:20 - method he has to call is it this one
420:25 - or is it this one right
420:29 - and for that we will use Dynamic
420:32 - dispatch so again we can put
420:37 - this in a box
420:40 - and using here the pin keyword meaning
420:44 - we want to go with Dynamic dispatch here
420:48 - and that means we have to box these
420:51 - instances
421:05 - so now
421:07 - the return type over here is known at
421:11 - compile time meaning we can annotate it
421:13 - it would be a box
421:16 - which holds a type that implements the
421:19 - animal trade
421:21 - and this is using Dynamic dispatch
421:24 - meaning we then can call
421:27 - this noise method on this instance here
421:33 - because the compiler can check for this
421:36 - noise method at run time and not at
421:39 - compile time meaning it is determined
421:42 - which of these will get called at
421:45 - runtime when the program is running
421:48 - let's see
421:53 - and this is working
421:58 - trade bound the infiltrate syntax works
422:01 - for straightforward cases but is
422:04 - actually syntax sugar for a longer form
422:07 - which is called a trade bound when
422:10 - working with generic type parameters
422:13 - often must use trades as bounds to
422:16 - stipulate what functionality a type
422:19 - implements
422:21 - so over here we are calling the sum
422:24 - function with two arguments
422:28 - in this case
422:29 - 2i32 arguments
422:32 - and as you can see we could also call
422:34 - this with floats because we have here
422:37 - defined
422:39 - t t generic type parameter
422:44 - so as you notice X and Y Must Be of the
422:47 - same type T and the type will be T which
422:51 - gets returned and all we do over here is
422:55 - adding X Plus y
422:58 - now again to use this plus operator here
423:02 - we must Define that t over here is a
423:05 - type that implements the add trade
423:10 - because remember this would actually
423:13 - translate to this
423:18 - so it's critical that X
423:21 - implements the add trait right
423:32 - and we also have to Define over here the
423:35 - associated type output to be of type t
423:40 - let's see
423:45 - this is compiling
423:47 - let's actually call the function
423:50 - [Applause]
423:51 - and print out the result
423:58 - [Applause]
424:02 - so as you can see the output would be
424:05 - 10.
424:06 - and we can call it with float right
424:16 - so let's see exercise 8 fix the errors
424:19 - as you can see we have a pair struct
424:22 - which has two Fields holding values of
424:26 - type t meaning they are generic
424:30 - and then we have an implementation block
424:33 - for repair and we Define here an
424:37 - Associated function and this is not a
424:40 - method because it doesn't have self as
424:43 - parameter
424:44 - now over here we are instantiating a new
424:48 - pair
424:49 - and remember self over here uppercase s
424:52 - refers to the type of the implementation
424:56 - block meaning pair
424:58 - and then we return this instance so if I
425:03 - write pair here it would be the same
425:05 - thing
425:08 - then over here we have another
425:10 - implementation block
425:12 - for the type pair
425:15 - and as you can see we Define here that t
425:18 - over here should implement the debug and
425:22 - partial order
425:24 - so the type T over here the type of the
425:28 - two fields
425:29 - the type of the two Fields must
425:32 - Implement debug and partial order
425:36 - then over here we are defining a method
425:39 - compare display which takes a reference
425:43 - to an instance of pair
425:46 - and then checking over here is the value
425:49 - of the X field bigger than or equal to
425:52 - the value of the Y field
425:54 - if that is the case then self dot X will
425:59 - get printed out using debug notation
426:02 - that is why we need
426:04 - T to implement the debug trade otherwise
426:09 - we print out the value of the Y field
426:13 - so as you can see over here we have a
426:16 - custom type unit that holds an i32
426:20 - integer
426:21 - now over here we are instantiating a
426:26 - pair struct
426:27 - and as you can see we are passing here
426:29 - as concrete values for X and Y Fields
426:33 - the unit type
426:36 - our custom type
426:42 - and over here it holds one and here
426:46 - three write an i32
426:50 - the type annotation for that would be
426:54 - we would have a pair instance
426:57 - and T over here would be unit right
427:05 - because X and Y hold a type of unit so T
427:10 - over here will be unit
427:15 - now remember we have over here an
427:19 - Associated function so let's actually
427:21 - use that to
427:24 - instantiate a pair
427:42 - as you can see this is exactly the same
427:45 - thing as this but here we are using the
427:49 - new Associated function that got
427:51 - implemented on the pair type
427:55 - so I can delete that
428:01 - and again when we call on this instance
428:04 - the compare display method then we would
428:07 - have an error because as for now
428:12 - doesn't implement the debug and partial
428:15 - order trades
428:17 - so we have to derive them
428:28 - and by the way we also need the partial
428:31 - EQ trait
428:32 - [Applause]
428:34 - and that's because we are here
428:37 - checking for equality all right so we
428:40 - knew so we need partial equality
428:45 - and because we have now derived these
428:48 - trades for this type it means unit
428:51 - implements debug partial order and
428:54 - partial EQ meaning we can over here
428:57 - compare for equality and ordering and we
429:02 - can print the field out using debug
429:06 - notation
429:08 - let's see
429:12 - and this is running so the largest
429:14 - member is y you will need two
429:18 - so we have here a pair with an X field
429:21 - of unit 1 and the Y field of unit 2.
429:26 - and then the compare display method will
429:29 - give us back you will need two right
429:32 - because the wife
429:34 - because the Y field holds a value that
429:36 - is bigger than the X field compare these
429:40 - two because this is a custom type is
429:42 - only possible because we have derived
429:45 - these trades
429:48 - alright see you in the next topic
429:52 - so before doing more exercises on trade
429:55 - objects I want to cover Associated types
429:58 - now an Associated type allows to specify
430:02 - a type that is associated with the trade
430:06 - when implementing the trade for a
430:08 - specific type we have to specify the
430:11 - concrete type
430:13 - it's basically a type placeholder that
430:16 - the trade methods can use in their
430:18 - signature
430:20 - and it's similar to generic types but
430:23 - they are more flexible because they
430:26 - allow a trade to have different
430:28 - Associated types for different
430:31 - implementing types
430:33 - let's see an example we have here the my
430:37 - trade and this has an Associated type
430:41 - called my type and as you can see we can
430:44 - then use this Associated type over here
430:48 - in the methods we are defining in the
430:52 - trade so we here for example Define that
430:56 - the return type should be of type my
431:00 - type
431:02 - meaning when we implement this trade
431:05 - over here for a concrete type like for
431:08 - example my struct then we have to define
431:11 - the concrete type as you can see when we
431:14 - implement the my trade for my struct we
431:17 - Define here that my type should be i32
431:21 - and as you can see this method over here
431:24 - will then return an i32 type and this is
431:29 - defined over here and we can access the
431:32 - associated type using self uppercase
431:36 - double colon and the name of the
431:39 - associated type
431:40 - now again self here stands for the type
431:43 - we are implementing this Trade four so
431:47 - in this case my struct
431:51 - all right let's do some more exercises
431:54 - practicing trade objects
431:57 - as you can see we have here a trade bird
432:00 - that has one method
432:03 - then we have here two custom types duck
432:06 - and Swan so let's see for duck we have
432:10 - an implementation block
432:12 - and here we Define a method
432:16 - and this method takes a reference to the
432:19 - instance and prints out something
432:23 - and for Swan we also Implement a method
432:27 - now notice this has nothing to do with
432:30 - the trade these are methods that are
432:33 - defined directly on the struct right so
432:39 - here we
432:41 - Define a method fly which again takes a
432:45 - reference to the instance and prints out
432:48 - something
432:49 - now over here we are implementing the
432:51 - birth trait for duck and Swan
432:55 - meaning we have to implement the method
432:58 - defined by the trade
433:03 - so as you can see this Quark method we
433:06 - have to implement for both types
433:10 - then over here we want to instantiate a
433:13 - duck
433:18 - so we then can call on this stack
433:21 - instance the swim method
433:23 - so this will then get executed
433:29 - then over here we call the hatch a bird
433:32 - function with an argument of two
433:37 - and over here we call the hatch a bird
433:39 - function again with an argument of one
433:43 - so as you can see when we provide two we
433:46 - want over here
433:48 - duck
433:49 - when we provide one we want over here a
433:53 - swan
433:54 - and I see that because of the output
433:57 - when calling the quack method
434:03 - so let's implement this function we have
434:07 - seen that the function takes as an
434:09 - argument and interfer so let's call the
434:12 - argument species
434:14 - and let's define it as u8
434:18 - now I will keep the return type open we
434:23 - will see that then
434:25 - so let's see when we get one let's
434:29 - actually match the species argument
434:33 - when we get back one
434:35 - we want to return
434:38 - a swan if we get here for the argument
434:42 - A2 we want to return a duck instance
434:46 - and because we have to handle all the
434:49 - cases I will just panic in case anything
434:52 - else has been passed
434:57 - so over here what would be the return
435:00 - type now think about it when calling
435:03 - this function over here
435:06 - we have to provide the
435:09 - return type
435:11 - now again the return type has to be of
435:16 - known fixed size at compile time
435:20 - now over here we don't know what we'll
435:24 - get actually return that compile time
435:26 - right especially if this argument over
435:30 - here would be something that is
435:33 - generated at runtime
435:36 - meaning we don't know the exact size
435:39 - because this one struct could be larger
435:42 - in size than the duck struct or
435:45 - otherwise
435:46 - so we have actually seen the solution we
435:50 - need to box
435:51 - the return type and
435:55 - V over here Define that it should be
435:59 - dynamically dispatched and that means we
436:02 - have to box these concrete values here
436:18 - and now we are good to go because also
436:21 - another problem would be that in a match
436:25 - every return type has to be of the same
436:28 - type now again over here the function
436:31 - could sometimes return a swan or
436:35 - sometimes a duck right depending on the
436:37 - argument
436:39 - and when we do it like that we actually
436:43 - return a type of box right so they have
436:47 - all the same return type now again
436:50 - because we are here using Dynamic
436:53 - dispatch we have to put it behind a kind
436:56 - of pointer
436:58 - and that means over here we will get
437:02 - a box
437:06 - holding a trade object
437:20 - and the trade object in this case is
437:23 - bird
437:25 - so that means and we have seen that the
437:27 - compiler will then
437:30 - allocate the concrete type for example
437:34 - over here a duck
437:36 - in the Heap memory and we'll create a v
437:39 - table with all the methods because when
437:43 - we call over here the Quark method on
437:45 - bird then at this exact point Dynamic
437:49 - dispatch happens
437:51 - because it is not known at compile time
437:55 - which
437:58 - concrete type got returned here this
438:01 - will be determined at runtime so at
438:05 - runtime the compiler will check the V
438:08 - table and see the right
438:12 - and will execute the right method call
438:16 - right in this case it would be for duck
438:21 - so the compiler will look this method up
438:25 - in the v table for the tag type which
438:29 - has been allocated in Heap memory and we
438:32 - got
438:33 - and notice something over here when we
438:37 - return a trade object the trade object
438:41 - actually only implements
438:45 - the methods from the trade in this case
438:50 - Bird right so we then can't call because
438:54 - we have here a trade object we can't
438:57 - call a method directly defined on the
439:01 - type so for example this swim method is
439:05 - not in the v table that the compiler
439:08 - creates
439:10 - I hope you see that because again we are
439:13 - returning a trade object meaning in the
439:16 - v table are only the methods from the
439:20 - trade
439:24 - so over here because we have
439:26 - created an instance on the concrete type
439:29 - we can call this three method but over
439:32 - here because we have a trade object we
439:36 - can only call methods from the trade
439:39 - let's see
439:43 - and as you can see this is compiling
439:48 - array with trade objects again we have
439:51 - the birth trait with the same method
439:54 - then we have duck and Swan and as you
439:58 - can see these are methods that are
440:01 - implemented directly on the concrete
440:03 - type
440:05 - then over here again implementing the
440:08 - birth trait for duck and so on we have
440:11 - seen that fill in the blank to make the
440:14 - code work so over here we want to have
440:17 - an array because we are here iterating
440:20 - over this Birds
440:22 - variable meaning we want to iterate
440:27 - over
440:28 - an array
440:30 - now let's first annotate
440:33 - we want over here an array of birds
440:37 - right
440:39 - so we want a type that implements the
440:43 - bird trade meaning in this case stock
440:45 - and Swan and this time I will use a
440:49 - reference instead of a box so we Define
440:52 - over here that we want an array
440:56 - holding
440:58 - a type that implements the birth trait
441:02 - and is dynamically dispatched all right
441:05 - and again because using Dynamic dispatch
441:08 - requires that we put it behind some kind
441:12 - of pointer either box or a reference
441:16 - now with this array let's say we want to
441:18 - have two elements one
441:20 - duck and one swan
441:23 - so let's provide here the instances
441:28 - and again we have to put that behind a
441:31 - pointer so the size is known
441:38 - so the size is known at compile time
441:40 - because remember the size of the
441:43 - elements in an array must be known at
441:46 - compile time in this case it would be
441:48 - you size
441:51 - the size of a pointer
441:54 - now then we want over here to iterate
441:57 - over these elements here
442:01 - and then as you can see for each element
442:04 - we are calling on it the Quark method
442:08 - now again because this over here is
442:11 - happening at runtime the Quark method
442:15 - will be determined at runtime which one
442:19 - to run here
442:21 - for stuck or for swan
442:25 - right
442:27 - let's see
442:31 - and this is compiling now overs and here
442:34 - we have the same thing bird.fly
442:38 - the method we have directly implemented
442:41 - on the type isn't available
442:45 - because in a trade object over here only
442:49 - the methods from the actual trade birth
442:52 - are in the v table other methods won't
442:56 - get into DV table and so the compiler
443:00 - cannot look it up at runtime
443:06 - referenced in and boxed in so we have
443:10 - here a trade draw which has one method
443:13 - and we implement the draw trade for u8
443:17 - and f64.
443:20 - as you can see we can Implement our own
443:23 - custom trades for types in the standard
443:27 - Library
443:29 - and all this does over here
443:31 - is it will take
443:33 - a reference of the instance and and it
443:37 - will output the value now in the newer
443:41 - version of rust we don't have 2D
443:43 - reference self here this is happening
443:46 - automatically
443:48 - like that and for f64 the same thing
443:53 - now as you can see we have here an f64
443:57 - and an u8
443:59 - basically the types that implement this
444:03 - draw trade
444:06 - then over here we are calling the
444:08 - function draw with box
444:11 - and as you can see this function over
444:15 - here expects a trade object of the draw
444:19 - trade and this trait object should be
444:23 - boxed all right and then it is calling
444:26 - the draw method again the compiler will
444:29 - then look in the v table and will
444:32 - execute the appropriate method at
444:35 - runtime
444:38 - so let's pass the argument for the draw
444:40 - with box function and in this case we
444:43 - want to draw X so let's pass it X
444:48 - and of course this has to be boxed right
444:53 - like this
444:55 - now over here we want to draw Y and this
444:59 - time we are passing a reference meaning
445:03 - we over here expect a reference
445:09 - to a trade object
445:11 - that implements the draw trade
445:15 - all right
445:17 - and then we are calling the draw method
445:20 - again this time on y
445:25 - let's see
445:28 - and this is compiling
445:37 - let's see exercise four we have a trade
445:41 - full which has one method then we
445:44 - Implement Foo for u8 and string types
445:49 - and as you can see we can Implement our
445:52 - own trades on types that are defined in
445:56 - this standard Library so in this case u8
445:58 - and string
446:01 - then over here in main we have
446:04 - a variable X holding a u8 and Y holding
446:08 - a string
446:11 - basically the types we are implementing
446:14 - for for right
446:18 - and let's see now the function called
446:22 - Static dispatch so we pass here X tu8
446:26 - type and this should be statically
446:30 - dispatched so let's implement this
446:33 - function Implement below with generics
446:36 - so we need here a generic
446:39 - type parameter and we Define here a
446:43 - trade bound meaning we want T to
446:46 - implement the foo trade
446:51 - right
446:52 - because we want the argument to be of
446:55 - type
446:56 - t
446:59 - so it's important that we Define here
447:03 - the trade bound because we call
447:07 - this function only with arguments that
447:11 - implement the full trade
447:14 - and we are defining that in order to be
447:18 - able to call the method
447:21 - method on it basically this method
447:24 - defined here right
447:27 - because then we can pass types of u8 and
447:30 - string to this function and it can call
447:34 - the method because the full trade is
447:38 - implemented for this type any other type
447:41 - that doesn't implement the full trade
447:44 - won't be allowed to be passed to this
447:47 - function
447:48 - so this is static dispatch because the
447:52 - compiler at compile time will actually
447:55 - expand this code and create a function
447:59 - for the concrete types so in this case
448:02 - we are passing u8 to this function so
448:06 - the compiler will create
448:10 - a function like this
448:22 - right and then we'll call it and this is
448:25 - happening at compile time meaning the
448:28 - compiler will fill in the concrete types
448:32 - over here
448:35 - and then of course the compiler will
448:38 - know when we do a method call which
448:41 - method over here it should call right
448:45 - and
448:47 - static dispatch is usually a lot faster
448:50 - than Dynamic dispatch because you don't
448:53 - have to do a lookup it's everything in
448:57 - the binary itself but when you have to
449:00 - do a lookup you have to follow a pointer
449:03 - to Heap memory and then get the data
449:06 - from this memory location which is more
449:09 - expensive
449:11 - so let's see Dynamic dispatch in this
449:15 - case
449:16 - and we use Dynamic dispatch because
449:21 - sometimes it's just not possible to use
449:24 - static dispatch right when the size of
449:28 - the returned type it cannot be known at
449:32 - compile time then we use Dynamic
449:35 - dispatch
449:37 - and let's see how that looks like so
449:40 - over here
449:41 - we are passing a reference to Y so we
449:45 - are passing here
449:49 - a reference to a string
449:53 - now as an argument over here we want a
449:58 - reference right that's what we are
450:00 - passing
450:02 - to a trade object
450:06 - implementing the full trade all right
450:11 - and again because this is dynamic
450:13 - dispatch so this happens at runtime
450:16 - must be behind a pointer so this size is
450:21 - known at compile time
450:23 - because it pointer is always of size U
450:27 - size we have covered that
450:29 - and then we call the method on the
450:33 - argument right
450:35 - the difference is that over here this
450:38 - will then be determined at runtime which
450:43 - method over here to be called right
450:47 - because the compiler will then do a
450:50 - lookup in the v table at runtime and
450:54 - then determine for which type the method
450:57 - should be called
451:00 - let's see
451:04 - this is compiling
451:07 - object safe you can only make object
451:10 - safe trades into trade objects a trade
451:14 - is object safe if all the methods
451:16 - defined in the trade have the following
451:19 - properties the return type isn't self
451:22 - and there are no generic type parameters
451:26 - so let's see exercise 5 use at least two
451:30 - approaches to make it work don't add
451:33 - remove any code line
451:35 - so
451:37 - I think we will go first with static
451:40 - dispatch because it's easier
451:42 - so I will remove this box here
451:51 - and let's see we have a trade here
451:54 - defining one method
451:57 - now this defines that it takes a
452:00 - reference to a self
452:02 - meaning a reference to an instance of my
452:06 - trait and it returns self their self
452:10 - over here refers to the type for which
452:13 - the nitrate is implemented so in this
452:16 - case for example over here my trade is
452:20 - implemented for u32 meaning we implement
452:24 - this method over here
452:26 - and self over here would refer to u32
452:31 - right we can write it either way
452:36 - and
452:38 - u32 and string Implement my trade all
452:42 - right so they both implement the F
452:45 - method
452:46 - then over here we have a function that
452:50 - takes a trade object now in this case
452:53 - you want to use static dispatch so we
452:56 - Define here
452:58 - a generic type
453:00 - right because we are calling it with new
453:03 - 32 and a string
453:05 - now we want to ensure that t this type
453:10 - implements my trade so we can be sure
453:14 - that it implements this F method
453:21 - so this is called trade bound and this
453:24 - makes sure that t implements my trade
453:28 - so we then can call the F method on the
453:33 - provided argument here which is of type
453:35 - t
453:37 - and
453:39 - that's basically it we have implemented
453:42 - the static dispatch for this function
453:45 - over here
453:46 - and what then will happen is
453:50 - when we call this function the
453:53 - roscompiler
453:55 - will take this generic function here and
453:58 - it will provide it with concrete types
454:06 - and it will provide it with concrete
454:09 - types so in this case u32 right we are
454:12 - passing it to 32.
454:14 - and
454:16 - we have we forgot to define the return
454:19 - type so the return type over here would
454:22 - be the return type of the F method
454:26 - now in this case it would be
454:29 - T type right
454:32 - so if we are calling it
454:36 - so if we are calling the F method on a
454:39 - new 32 then the return type will be u32
454:42 - in if we call it on a string then the
454:46 - return type will be string so again we
454:48 - pass here T right
454:52 - because the type we are passing for
454:55 - example u32 will be the return type of
454:59 - this function u32 and that in case means
455:03 - that the return type of this function
455:07 - over here will be
455:09 - u32 right
455:13 - okay
455:14 - and then the same thing happens for a
455:17 - string
455:18 - so the compiler will actually
455:21 - put into these generic type parameters
455:25 - concrete types
455:29 - and that means when we are using static
455:31 - dispatch these method calls here are
455:35 - known at compile time so the compiler
455:37 - knows if you're passing a u32 type then
455:42 - it will call the F method from the eu32
455:46 - implementation of my trade right and in
455:49 - case of string then the compiler will
455:52 - know that the F method can be found in
455:56 - the
455:57 - my trade implementation of string right
456:01 - so everything here is known at compile
456:06 - time and also the size is fixed
456:12 - and this is working
456:14 - now
456:15 - we want here
456:17 - to now use Dynamic dispatch so we solve
456:20 - it in two approaches
456:23 - so before we can even use this straight
456:26 - object over here we have to make the
456:29 - trade itself object safe and we do that
456:33 - when the return type isn't self and
456:36 - there are no generic type parameters so
456:40 - we cannot Define here self we have to
456:44 - provide it concrete types now in this
456:47 - case we want
456:49 - the F method to return a trade object
456:54 - meaning
456:59 - we return a pointer
457:02 - that points to the type that implements
457:05 - my trade all right
457:09 - and over here
457:11 - because we are taking here this function
457:13 - signature and implement it for each type
457:18 - we Implement in my trade for so as you
457:21 - can see the return type must
457:24 - implement the my trade
457:28 - and it has to be boxed so we have to box
457:31 - this over here
457:36 - turn over here A U 32 right
457:41 - which implements the my trade and over
457:45 - here a string
457:47 - [Applause]
457:51 - which also implements my trade
457:55 - so as you can see we got rid of self
457:59 - because again
458:02 - at compile time the return type size has
458:06 - to be known
458:08 - that's why we are putting it behind a
458:12 - box
458:13 - now
458:15 - again the return type of this function
458:19 - would be the return type of Team method
458:22 - calls in this case it would be a boxed
458:26 - trait object
458:28 - right
458:30 - let's see if this is compiling
458:33 - and this is also compiling
458:36 - now I hope you see the difference here
458:39 - when we pass here a trade object
458:44 - basically a type in this case u32 that
458:48 - implements the my trade trade
458:51 - then this method call will be determined
458:55 - at runtime
458:57 - and that's why we have to put this
459:01 - behind pointers so the size remains
459:05 - fixed and known at compiled time
459:11 - and again use whenever possible static
459:14 - dispatch because it's faster and I guess
459:17 - easier to write but Dynamic dispatch has
459:20 - its advantages and you can use it for
459:24 - more flexibility in your code
459:28 - alright see you in the next topic
459:33 - so we have reached the topic of
459:35 - collection types and string is also a
459:38 - collection type meaning we are just
459:40 - repeating because we have covered
459:43 - strings but I think these exercises are
459:47 - good for some repetitions
459:49 - so string is a utf-8 encoded growable
459:53 - string it is the most common string type
459:55 - we used in Daily development it also has
459:58 - ownership over the string contents
460:02 - so let's see fill in the blanks and fix
460:05 - arrows don't use to string don't add
460:07 - remove any code line
460:10 - so as you can see over here we want a
460:13 - string type because we because we are
460:16 - here modifying the swing meaning it has
460:19 - to be growable
460:20 - so let's
460:22 - allocate this data over here on the heat
460:29 - so we have now a string type we can
460:33 - now let's see the poster method
460:38 - as you can see this push stir method is
460:41 - implemented on the string type and it
460:46 - takes as a type for its argument a
460:49 - string literal
460:51 - as you can see we are calling it on a
460:54 - string and providing it an argument of a
460:58 - string literal
461:00 - so we have to delete that because this
461:04 - would actually be a string right
461:07 - we want here a string literal
461:11 - like that
461:13 - and push is for pushing single
461:16 - characters so we want to push here an
461:19 - exclamation mark So s will then here
461:23 - match with this string literal
461:26 - and as you can see we are calling the
461:29 - move ownership function here meaning
461:32 - this function will then take ownership
461:34 - of s and that's not what we want because
461:37 - we are using here as again so what we
461:40 - can do is just clone it
461:43 - so the data passed to move ownership
461:46 - over here is actually cloned
461:50 - right it is copied on the Heap memory
461:54 - and that means we can still use S
461:58 - because s Remains the owner of this data
462:09 - all right
462:11 - then a string is stored as a vector of
462:14 - bytes but guaranteed to always be a
462:17 - valid utf-8 sequence
462:20 - string is Heap allocated growable and
462:23 - not null terminated a string slice is a
462:27 - slice
462:28 - basically a slice to u8
462:31 - integers because as you can see
462:35 - this string type is a vector of u8 inter
462:38 - source
462:40 - that always points to a valid utf-8
462:43 - sequence and can be used to view into a
462:46 - string just like a slice to T is a view
462:50 - into Vector T and we'll cover vectors
462:55 - after this topic
462:58 - so fill in the blanks
463:00 - we have here a string
463:03 - and we want to take a string slice from
463:07 - this string now the easiest method would
463:09 - be just to take a reference to s
463:12 - which means we take a reference to a
463:15 - string type
463:17 - and this can then be inferred by the
463:20 - compiler to a string slice
463:24 - and the second way would be to call the
463:27 - askster method on it
463:30 - this will essentially do exactly the
463:32 - same thing it will take the string s and
463:36 - we'll convert it to a string slice
463:40 - now over here we also want a string
463:43 - slice
463:45 - but we want to provide a specific offset
463:48 - we just want this data over here
463:52 - and that means we take a reference to s
463:56 - and provide it here an offset from zero
463:59 - we can omit the zero on here
464:02 - until index 0 1 2 3 4
464:08 - until index four now we would provide
464:11 - here 5 because 5 is excluded meaning we
464:16 - go from index 0 to 4.
464:22 - and over here as you can see we want to
464:26 - modify the string holding then hello
464:30 - world because we are pushing to it this
464:33 - exclamation mark as you can see we want
464:36 - it hello world and with an exclamation
464:39 - mark
464:40 - so what we can do is taking
464:43 - s over here s mutable reference
464:50 - so this would then hold a mutual
464:53 - reference to a string
464:56 - let's see
464:58 - and this is compiling now notice over
465:01 - here we could also take ownership of s
465:05 - meaning slice 3 will hold a string
465:09 - because we are not using S after this
465:12 - point so slice 3 can be the owner of s
465:17 - but in this case we have to make the
465:19 - variable mutable
465:23 - and this is also working
465:26 - question how many Heap allocations are
465:29 - happening here so we have here a string
465:33 - and
465:34 - when we create a string type then the
465:40 - data that is provided is allocated in
465:43 - Heap memory
465:45 - so this would be the first allocation
465:48 - then over here we are taking from this
465:52 - string over here a reference meaning a
465:55 - string slice and remember a string size
465:59 - is just a view into some data so we are
466:03 - just going to this location and checking
466:06 - what's in there
466:07 - so no allocation is happening
466:12 - and over here we are taking this string
466:15 - slice and convert it to a string meaning
466:19 - a heap allocation is happening over here
466:24 - right because we are taking this string
466:27 - slice
466:32 - [Applause]
466:33 - holding this
466:36 - and then we allocate this
466:39 - into the Heap once more being because we
466:43 - are calling this two string method
466:50 - let's see indexing
466:53 - so we have a string here
466:56 - and we want to index into the first
466:59 - element so slice one should then hold h
467:03 - so we want a string slice
467:07 - so we take a reference to S and provided
467:10 - the offset from 0 to 1.
467:14 - 1 is excluded meaning we just take the
467:17 - first character
467:19 - and that is because H only takes one
467:23 - byte in utf-8 format so
467:27 - ASCII characters in strings usually take
467:30 - one byte while this Unicode characters
467:34 - over here take three bytes so when we
467:38 - take a string slice here
467:41 - we want to access this character
467:45 - now for that we have to provide the
467:48 - right offset so we go from 0 1 2 3 4 5 6
467:55 - 7.
467:56 - starting at index seven and as you can
467:59 - see these Unicode characters hold three
468:03 - bytes meaning
468:04 - we must provide here an offset of 10. 10
468:09 - is excluded meaning we go from 7 8 9.
468:14 - three bytes iterate through all Source
468:17 - in s
468:19 - so to iterate over characters in a
468:23 - string type we use Stitch Source method
468:28 - but that will actually just return the
468:32 - Char we are iterating over but as you
468:35 - can see we want here as return type a
468:38 - tuple which holds the index and the
468:42 - actual character so we can use here to
468:45 - enumerate method
468:48 - and enumerate will return a tuple with
468:52 - the index and the specific character so
468:56 - in the first iteration you would have
468:58 - zero and H right the index and the
469:02 - character
469:04 - so here we are checking if the index
469:06 - over here is 7 then the variable C
469:09 - should hold this character
469:12 - right
469:14 - let's see
469:16 - and this is compiling
469:20 - now there is a crate called utf-8 slice
469:23 - you can import it into your project and
469:27 - this then allows you to slice into a
469:30 - string
469:31 - not using bytes as offsets but just
469:35 - indexing into the individual characters
469:38 - so over here we provide an offset from
469:42 - four to five meaning we want the
469:45 - character at index 4.
469:49 - so we don't have to worry about the byte
469:52 - size of this symbol
469:56 - then fill in the blanks we have here a
469:59 - string
470:00 - now we have seen that a string is
470:03 - actually a vector holding u8 intervals
470:07 - and as you can see we have here some
470:10 - bytes in a vector so this Vector holds
470:14 - u8 inters right
470:17 - and that means these are bytes that can
470:20 - be converted to ASCII characters
470:24 - so in this case these over here will
470:27 - translate to hello
470:29 - all right
470:30 - if you look up this code over here in
470:34 - the ASCII table then we will find that
470:37 - this is represented for the character
470:40 - age
470:41 - and this e l l o
470:46 - so we want to turn a bytes Vector like
470:49 - this into a string so we want to be
470:52 - string here
470:54 - so let's see this method here
470:57 - so in the documentation you can see that
470:59 - the string type implements a method from
471:02 - utf-8
471:05 - and this just takes a vector of bytes
471:10 - and then we can call this Associated
471:13 - function on the string type and provide
471:16 - it as an argument a vector of bytes
471:21 - and this will then convert it to a
471:24 - string so we can try it out
471:27 - so first of all we want to actually
471:29 - mutate the string here to hold the same
471:32 - data as this Vector holds namely hello
471:36 - so we can do that by using poster
471:42 - and we push hello meaning this string
471:45 - then holds hello
471:55 - and
471:56 - then we can take this string type and
472:00 - call from utf-8 method providing it this
472:05 - vector
472:07 - and this should then convert this Vector
472:11 - of bytes into an actual string meaning s
472:15 - and S1 will then hold the same value
472:19 - namely a string hello
472:30 - and of course this actually
472:32 - and this returns a result so we have to
472:36 - unwrap it
472:40 - and as you can see this is compiling
472:45 - so in fact a string is just a vector of
472:50 - bytes right
472:54 - and we'll cover vectors very soon and
472:57 - you will then see how this is actually
473:00 - stored in memory
473:04 - so a string is made up of three
473:07 - components a pointer to some bytes a
473:10 - length and a capacity the pointer points
473:13 - to an internal buffer string uses to
473:16 - store its data the length is the number
473:19 - of bytes currently stored in the buffer
473:22 - always stored on the Heap and the
473:25 - capacity is the size of the buffer in
473:28 - bytes as such the length will always be
473:31 - less than or equal to the capacity
473:36 - we have seen that the string type is a
473:39 - three bird object holding a pointer to
473:42 - the actual data stored in Heap memory
473:45 - the length which shows the length of the
473:48 - string in this case 5 and the capacity
473:51 - and the capacity as you can see here is
473:55 - the total amount of memory received from
473:58 - the allocator
473:59 - so when we allocate a new string type on
474:03 - the Heap the allocator we will find an
474:06 - empty spot and then we'll return a
474:10 - pointer to that location
474:15 - number six if a string has enough
474:17 - capacity adding elements to it will not
474:20 - really allocate
474:22 - so
474:24 - when we run this program over here
474:27 - then we see the capacity of string s
474:35 - now over here we are initializing an
474:39 - empty string
474:41 - meaning we have an empty string so
474:45 - nothing gets allocated to Heap memory we
474:49 - still have a string object but with a
474:53 - length of zero and a capacity of zero
474:58 - then we print it out as you can see Zero
475:02 - over here we are iterating two times
475:05 - modifying this string so in the first
475:07 - iteration s will then hold
475:11 - hello
475:12 - so it would have a length of five but
475:16 - when we print out the capacity it will
475:19 - show 8. so we have a string object that
475:23 - points to this data with a length of 5
475:27 - and a capacity of 8. now this is the
475:31 - default behavior when we don't specify a
475:35 - capacity ourself so
475:39 - when the length exceeds the capacity
475:43 - then rust has to reallocate the data
475:48 - meaning it has to find a new spot in
475:51 - Heap memory that is big enough to hold
475:54 - the data and then we'll return a pointer
475:58 - to the new location so in this case
476:01 - because we have modified the string the
476:04 - length 5 exceeds the capacity zero so it
476:09 - has to reallocate because remember in
476:12 - Heap memory
476:13 - the data is allocated as contiguous
476:18 - block of bytes all right
476:21 - and the default behavior is that the
476:24 - capacity will always double so it starts
476:28 - from 1 then 2 4 8 16 and so on and
476:32 - that's the reason we have here a
476:35 - capacity of 8 even though we only need
476:38 - five right this is a length this is a
476:41 - string of length five but because of the
476:45 - default behavior of the allocator we
476:48 - will get back a capacity of 8. and then
476:52 - in the second iteration we again push
476:55 - hello
476:57 - right so we would have a length of 10
477:01 - but as you can see the capacity doubles
477:04 - so 10 exceeds the length of 8 meaning
477:09 - the allocator will then find a new spot
477:12 - in hit memory to allocate
477:16 - this string over here of length 10. and
477:20 - it will then
477:21 - Reserve 16 bytes of memory in Heap
477:26 - memory and so on if we then exceed 16
477:29 - bytes then it will allocate to a
477:32 - location which holds 32 right it always
477:35 - doubles
477:37 - and this is when you let rust allocate
477:41 - so this is the default Behavior but as
477:44 - you can see this might be expensive so
477:47 - if you
477:48 - start with a capacity of zero and then
477:52 - you modify the string multiple times it
477:55 - means rust has to reallocate your
477:58 - daytime
477:59 - and that means it could potentially be
478:02 - expensive when you mutate this over here
478:05 - multiple times and a lot of
478:07 - reallocations are happening so there is
478:10 - a function called with capacity
478:15 - and then we can Define over here that we
478:18 - want an empty string meaning the string
478:21 - length is zero but we want a capacity of
478:25 - 25 meaning s
478:29 - is allocated in Heap memory and
478:33 - there is enough space reserved for this
478:37 - data
478:39 - to hold 25 elements right so when we do
478:44 - that again
478:47 - then as you can see
478:50 - no reallocation has happened we have
478:54 - only allocated the string one time in
478:56 - heat memory with a capacity of 25.
479:01 - now because the length doesn't exceed
479:04 - the capacity in any of this modification
479:07 - of the string it means that there is no
479:11 - need to re-allocate the data right so
479:15 - when we print out
479:22 - swing s over here in the end
479:27 - then as you can see this is the
479:31 - string that in the end hello
479:34 - hello so we have here 10 elements
479:37 - meaning
479:39 - there is no need for reallocation
479:42 - because a capacity of 25 can hold
479:46 - the string of this size and this can
479:49 - make your program a lot faster
479:52 - so let's see vectors a vector is like an
479:55 - array but dynamically sized meaning they
479:58 - can grow and Shrink it's allocated on
480:02 - the Heap as contiguous block of memory
480:05 - all elements in a vector have to have
480:08 - the same type and there is a special
480:11 - macro vac which you can use to
480:14 - initialize a new vector
480:17 - so all this time we've been dealing with
480:19 - an imposter so in actuality this string
480:22 - type is just a vector of utf-8 bytes
480:27 - that gets allocated in Heap memory
480:31 - so as you can see when we have the S1
480:34 - variable over here then again S1 won't
480:38 - hold the actual data but a pointer to
480:41 - the data allocated in Heap memory
480:44 - alongside a length and a capacity
480:47 - meaning S1 is a three word object of
480:52 - size 24 bytes
480:55 - now
480:58 - as you can see this would be a vector
481:01 - allocated in Heap memory that holds the
481:05 - utf-8
481:07 - bytes over here of course in memory this
481:11 - would be in binary but as you can see
481:14 - this then holds the
481:19 - character code for this character inside
481:22 - the string
481:25 - so let's do some exercises vectors or
481:29 - resizable arrays like slices their size
481:32 - is not known at compiled time but they
481:35 - can grow or Shrink at any time
481:38 - so over here we have a normal array
481:41 - holding three u8 elements
481:46 - now we can convert this array to a
481:50 - vector using the from Associated
481:52 - function and then passing it the array
481:55 - meaning we will then hold a vector
482:01 - of u8 elements and here you can see the
482:05 - difference between an array and a vector
482:08 - we don't provide here the length of the
482:11 - vector because the vector can actually
482:14 - grow or Shrink meaning it's dynamic in
482:18 - its size
482:20 - now the isvac function basically just
482:23 - checks if the provided argument is a
482:26 - vector
482:29 - then as you can see we are shadowing V
482:32 - and we are here initializing it with a
482:37 - vector of these elements so as you can
482:40 - see you can use the VAC macro to quickly
482:43 - create a new Vector like that
482:49 - so this will then hold a vector of u8
482:52 - elements
482:53 - and by the way you can either use square
482:56 - brackets or you can use parentheses it's
482:59 - both exactly the same
483:05 - now as you can see here we are
483:08 - initializing V or basically shadowing it
483:12 - and then we are passing it to is back
483:15 - meaning ownership would be transferred
483:18 - but we are using V here again so let's
483:21 - clone this
483:25 - and over here as you can see we are
483:28 - initializing V1 with Divac macro now we
483:33 - are passing to the back macro the array
483:37 - Mac macro over here won't convert it
483:41 - directly to a vector like this from
483:45 - Associated function did instead we would
483:48 - here have a vector
483:50 - holding
483:52 - this array all right
484:01 - I hope you can see the difference
484:04 - here we have a vector of u8 elements
484:07 - over here we have a vector holding an
484:11 - array of three u8 elements
484:14 - so
484:16 - when we compare over here V and V1 they
484:20 - won't actually be the same right
484:25 - and again let's do clone here
484:28 - just so we can then reuse B1
484:32 - now what we can do over here to fix that
484:35 - is using the VAC new
484:39 - like that
484:41 - and back new basically will then create
484:46 - a new empty Vector meaning it would be
484:49 - an object with length of 0 and capacity
484:53 - of zero
484:55 - now over here we want to iterate over
484:59 - the elements in v
485:06 - let's take a reference here because we
485:09 - are using V again and we don't want this
485:12 - for Loop to take ownership
485:14 - now all we want to do is pushing all the
485:18 - elements from we into V1
485:27 - and because we are here iterating over
485:30 - references of elements we have to
485:33 - de-reference it and by the way we will
485:35 - take a look at that in much greater
485:38 - detail
485:39 - so what we also have to do is making
485:42 - this V1 variable mutable because when
485:46 - pushing to it it has to be mutable
485:50 - alright let's see
485:55 - and this is compiling so in the end V1
485:59 - will hold a vector
486:01 - of U 8 elements meaning V and V1 are
486:07 - exactly the same
486:09 - but remember when you have an array use
486:13 - the from Associated function and not the
486:16 - VAC macro because it won't convert it
486:19 - directly to a vector instead it will
486:22 - create a vector holding an array
486:27 - Evac can be extended with extend method
486:31 - so over here we have a vector
486:34 - let's say these are i-32 values
486:39 - and as you can see we can pop meaning
486:43 - removing the last element so over here
486:50 - the vector will then hold 1 and 2
486:53 - because the last element got popped then
486:56 - we are pushing to it 3.
487:02 - meaning we have a vector holding one two
487:06 - three
487:08 - now over here again we are initializing
487:11 - an empty vector
487:14 - now as you can see we want V1 and V2 to
487:19 - be exactly the same
487:21 - so what we can do is using the extent
487:24 - method
487:26 - and providing it the V1 vector
487:31 - meaning the elements
487:38 - foreign
487:42 - and we have to pass here a reference
487:44 - meaning the elements then from V1 will
487:48 - be
487:49 - put into V2 so again V2 will then be a
487:53 - vector of I 32 elements and they hold
487:57 - exactly the same data right
488:00 - it's basically copying the contents of a
488:05 - vector into another vector
488:09 - turn X into back fill in the blanks
488:13 - so over here we have an array
488:18 - and this array holds i32
488:22 - types and the size of the array would be
488:25 - 3.
488:26 - then as we've seen we can use the from
488:29 - Associated function
488:33 - so we create a vector from this array
488:37 - meaning V1 will then hold a vector of
488:41 - i32
488:43 - types
488:45 - or what we also could do is calling the
488:48 - into method and if a type implements
488:52 - from then it will Implement into and we
488:56 - will take a look at that
488:58 - so we then take this array over here and
489:01 - convert it into a vector of i32
489:06 - values right so that means V1 and V2
489:11 - will be exactly the same
489:15 - now converting a string into a vector
489:21 - so the from trade over here
489:24 - is actually implemented for the vector
489:28 - type so over here we have a string
489:31 - and remember basically a string is a
489:35 - vector of u8 elements
489:38 - and then again we can call here into
489:41 - right converting s
489:44 - into a vector of u8 elements
489:49 - and then over here we have again a
489:51 - string and we call the method in two
489:54 - bytes meaning
489:56 - V2 holds a vector of utf-8 bytes
490:01 - represented as u8
490:04 - and this is actually exactly the same so
490:07 - meaning V1 and V2 will be identical
490:13 - then over here we have a string
490:16 - literally
490:18 - and we want to create a vector from this
490:22 - variable meaning we again use the from
490:25 - Associated function and provide it as an
490:28 - argument over here meaning B3 will then
490:32 - hold a vector of u8 types right
490:37 - so V2 over here and V3 are identical
490:44 - iterators can be collected in two
490:47 - vectors
490:48 - so when we have here an array of 10
490:50 - elements of value 0 and we put it into
490:54 - an iterator we can then collect it into
490:58 - a vector all right and we will see these
491:01 - methods over here in Twitter and collect
491:05 - in much greater detail meaning V4 will
491:09 - then hold a vector
491:12 - and of 10 times 0.
491:21 - like that all right let's see
491:29 - and this is compiling
491:33 - fix the error and implement the code so
491:36 - let's see over here we have an array
491:39 - and we convert this array into a vector
491:43 - using the from Associated function we
491:47 - have seen
491:48 - so this will then hold a vector of I 32
491:51 - types all right
491:55 - now then we are iterating here five
491:58 - times
492:00 - and
492:02 - just print out each element at the
492:06 - specific index
492:08 - here we have to implement some code and
492:11 - actually V in the end should hold a
492:15 - vector with these elements
492:18 - so as you can see
492:21 - we have we are starting with a vector
492:24 - holding one two three and we end with a
492:28 - vector 2 3 4 5 6.
492:32 - now what we want to achieve here is we
492:35 - are adding one to each element
492:38 - then we would have 2 3 and 4.
492:42 - now
492:43 - if we exceed the boundary over here then
492:47 - we want actually to add the new element
492:50 - over here
492:52 - now
492:54 - let's see first in the for Loop here
492:58 - this would actually panic because we are
493:01 - trying to access indexes that are out of
493:05 - bounds so over here we are iterating
493:08 - from 0 to 4 right 5 excluded but we have
493:13 - only three elements meaning meaning
493:16 - indexes 0 to 2.
493:19 - now we can here you stick get method
493:23 - and we have seen this get method before
493:26 - and and this is generally safer because
493:29 - it will return an option
493:33 - [Applause]
493:35 - in this case option i32 because we are
493:38 - dealing with i32 types here
493:42 - and what we then can do over here
493:46 - we want to actually manipulate this
493:49 - Vector so let's first access the
493:52 - elements
493:58 - and as you can see again I use the get
494:01 - method because we want to actually see
494:05 - if
494:08 - the index is out of bounds or not so in
494:12 - case it's not out of bounds we would
494:14 - return a sum right the get method will
494:17 - return a sum
494:20 - and the actual value at that specific
494:23 - index
494:25 - so if we found an element at the
494:28 - specific index over here then we want
494:33 - to access the element and just add to it
494:36 - one right
494:39 - we are then taking the element over here
494:42 - let's see for example in the first
494:44 - iteration I will be zero then we pass 0
494:49 - to this get method meaning we will get
494:53 - back some 1 right so we'll get back some
494:57 - 1 meaning
494:59 - e over here will then hold a value of 1.
495:03 - then we access
495:06 - this array at index 0 right and what we
495:11 - want then to do is taking 1 E over here
495:15 - and add to it one meaning then
495:19 - the first element in this Vector has
495:22 - been modified to then hold two
495:26 - now in the second iteration to do it
495:29 - would be exactly the same thing so I
495:31 - would be 1 we get over here
495:35 - the element at index one and E will then
495:39 - hold two and then over here V at index 1
495:45 - should then hold two plus one right and
495:50 - we assign it meaning
495:54 - in the modified vector the second
495:57 - element will then hold three
496:00 - now we do that again and after we are
496:04 - out of boundaries meaning we return a
496:07 - non here
496:09 - and then we want to push to the vector
496:12 - the index plus two right
496:16 - so for example in the third iteration I
496:20 - would be three right this would be out
496:23 - of bounds there is no index 3 here so we
496:26 - get back a non
496:29 - and then over here we push to V the
496:34 - index in this case 3 plus 2 meaning we
496:39 - then get back 5 right
496:42 - and let's see if this is actually
496:44 - working
496:52 - all right and let's remove this type
496:54 - annotation because this would be of Type
496:57 - U size because of the get method
497:01 - now as you can see
497:03 - when we print out here the output of the
497:07 - get method we would get someone sum two
497:11 - and some three and then two times none
497:14 - because at iteration 3 and 4 we would
497:18 - get back none because there is no
497:21 - element in this index
497:26 - and we are succeeding here because again
497:29 - we have three times sum here and when we
497:32 - have a sum we just add 1 to the value
497:36 - meaning we then have 2 3 and 4.
497:40 - and then we will get back two times none
497:44 - meaning we take the index and
497:48 - increment it by two pushing it to the
497:51 - vector so we get five and six
497:57 - slicing a vac can be mutable on the
498:01 - other hand slices are read only objects
498:04 - to get a slice use reference in Rust
498:07 - it's more common to pass slices as
498:10 - arguments rather than vectors when you
498:13 - just want to provide read access the
498:15 - same goes for string and string slices
498:19 - so over here we have a vector
498:25 - let's say i32
498:28 - then we are taking a slice from V over
498:32 - here
498:33 - meaning this would then be a slice of
498:37 - i32 elements right
498:42 - and this would be the offset meaning we
498:44 - would take from the first element to the
498:48 - last element
498:49 - out of bounds will cause a panic you
498:53 - must use the length here so as you can
498:56 - see again we are taking a string slice
499:00 - foreign
499:01 - but we are here out of bounds right
499:04 - because
499:05 - this would iterate from 0 to 3 for
499:08 - excluded and we have here only zero one
499:13 - two indexes
499:15 - so what we can do is using B dot length
499:18 - meaning we just iterate
499:21 - meaning we provide an offset from zero
499:24 - the first element to V length where the
499:28 - length here is excluded meaning vlanth
499:32 - minus one all right
499:36 - slices or read only node slice and
499:40 - reference to back are different
499:43 - so as you can see we take here immutable
499:46 - reference to a vector
499:48 - and then we can push to this Vector over
499:52 - here
499:54 - the value 4.
499:56 - now we have seen that slices are
499:59 - immutable they are just a view into some
500:02 - data so we can't use a slice to mutate
500:07 - the vector right
500:10 - so over here we want to have a slice
500:15 - of i32 elements right
500:18 - like that and we can remove the mute
500:22 - keyword over here because again we can't
500:24 - modify slices so we have pushed to it
500:28 - for meaning when we take the slice we
500:31 - want to take also this last pushed
500:34 - element right
500:38 - and this is compiling
500:42 - capacity the capacity of a vector is the
500:45 - amount of space allocated for any future
500:47 - elements that will be added onto the
500:50 - vector this is not to be confused with
500:53 - the length of a vector which specifies
500:55 - the number of actual elements within the
500:58 - vector if a vector's length exceeds its
501:02 - capacity its capacity will automatically
501:04 - be increased but its elements will have
501:07 - to be reallocated for example a vector
501:10 - with with capacity 10 and length 0 would
501:14 - be an empty Vector with space for 10
501:17 - more elements pushing 10 or fewer
501:20 - elements onto the vector will not change
501:23 - its capacity or cause reallocation to
501:26 - occur however
501:28 - however if the vector's length is
501:31 - increased to 11 it will have to
501:34 - reallocate which can be slow for this
501:37 - reason it is recommended to use the
501:39 - width capacity function whenever
501:41 - possible to specify how big the vector
501:44 - is expected to get
501:47 - and this we have already covered with
501:50 - strings but now let's see with vectors
501:54 - so over here as you can see we are
501:57 - initializing an empty Vector but with a
502:01 - capacity of 10 so this object here would
502:04 - hold length of 0 and capacity of 10
502:08 - meaning the actual elements inside
502:11 - Vector are zero there are no elements
502:15 - but
502:16 - in Heap memory there were 10 locations
502:20 - allocated for this data right
502:25 - the vector contains no items even though
502:28 - it has a capacity for more so when we
502:32 - call the length method over here we
502:34 - would get back zero right because back
502:38 - doesn't hold any values but it has a
502:42 - capacity of 10 because we have defined
502:45 - that over here
502:48 - these are all done without reallocating
502:51 - so we are then pushing 10 times to the
502:55 - vector right
502:57 - now this means
502:59 - back here holds enough space that this
503:04 - is happening without re-allocating the
503:08 - vector right
503:10 - so after pushing to the vector T Vector
503:13 - with would be of length 10. and capacity
503:18 - 10. right
503:20 - so the length must never exceed the
503:24 - capacity otherwise a re-allocation is
503:27 - happening
503:28 - as we can see here but this may make the
503:32 - vector reallocate so we are pushing
503:35 - another element to the vector meaning
503:38 - the length will be 11. this would exceed
503:42 - the capacity meaning then
503:46 - this whole Vector will be reallocated in
503:50 - Heap memory so when we have a length of
503:54 - 11 then the capacity will be at least 11
503:57 - but it can be more because we have seen
504:00 - that the default behavior when
504:03 - reallocating is that the capacity
504:06 - doubles
504:08 - feeling an appropriate value to make the
504:11 - four done without reallocating
504:14 - so as you can see we have here a vector
504:17 - we want to initialize with a certain
504:20 - capacity then we are pushing 100 times
504:24 - to this vector meaning the length here
504:27 - will be 100 so what we want to do is we
504:31 - want here to initialize a vector with a
504:35 - capacity of 100 meaning we can push 100
504:39 - times without this Vector to be
504:43 - reallocated in Heap memory
504:53 - store distinct types in Vector the
504:56 - elements in a vector must be the same
504:58 - type for example the code below will
505:00 - cause an error
505:02 - so we have here integers and a float
505:06 - this would cause an error because again
505:08 - all of them have to be of the same type
505:12 - but we can use enums or trade objects to
505:16 - store distinct types so over here we
505:20 - again see the IP address enum we have
505:23 - seen before in the examples
505:27 - now fill in the blank we want over here
505:29 - a vector that holds IP addresses
505:34 - meaning at index 0 we want this variant
505:39 - here and at index 1 we want this variant
505:43 - now we can use the back Macro for that
505:51 - and then over here I just copy
505:54 - this
505:56 - variant
505:59 - and
506:00 - this over here right we would then have
506:04 - over here a vector holding types of IP
506:08 - address
506:18 - and because this is a custom type we
506:21 - have to actually Implement partial EQ
506:24 - here
506:33 - so I hope you get the concept we have
506:36 - here a vector holding types of IP
506:40 - address right
506:45 - then over here we have a trade IP
506:48 - address that
506:50 - defines one method display and then we
506:54 - have two Tuple structs V4 and V6 we
506:59 - implement the IP address trade for v2
507:02 - struct and V6 tract meaning we have to
507:06 - implement the specific method
507:10 - and all it does it then basically prints
507:13 - out the value that is stored inside
507:16 - destruct
507:18 - so fill in the blank as you can see we
507:21 - won't hear a vector holding trade
507:25 - objects remember a trade object is boxed
507:29 - or put behind a reference
507:31 - so over here we have a vector
507:35 - holding boxes right
507:39 - and the Box holds
507:43 - a trade object meaning again this is
507:47 - using Dynamic dispatch and we won't hear
507:50 - a type that implements the IP address
507:53 - straight right in this case B4 and V6
507:58 - both are types that Implement IP address
508:07 - and as you can see even though we are
508:10 - holding here different types we can use
508:14 - it using here trade objects to store it
508:17 - in the same vector
508:28 - typo
508:34 - so and then
508:36 - we are iterating over the vector and for
508:40 - each
508:41 - element in here we just call the display
508:45 - method that has to be implemented
508:47 - because we only have types in here that
508:51 - implement the IP address trade
508:54 - and this is exactly where Dynamic
508:57 - dispatch happens and we have covered
508:59 - that
509:01 - let's take a look at hash Maps so a hash
509:04 - map is a data structure to store key
509:07 - value pairs it's allocated on the Heap
509:11 - as it is dynamically sized meaning it
509:13 - can grow and Shrink
509:16 - it allows for efficient lookup insertion
509:19 - and deletion of data so when talking
509:22 - about time complexity this means
509:25 - accessing and modifying elements or
509:29 - entries as they are called in hashmaps
509:32 - would be in the best case at constant
509:35 - time meaning Big O of 1 while in the
509:38 - worst case if you have a lot of
509:40 - collisions then it would be still linear
509:44 - time which is still pretty fast which
509:47 - means Big O of n
509:49 - each key is hashed to a unique index in
509:53 - the underlying array so there are
509:56 - vectors stores values by an integer
509:58 - index hashmap store value spy key it is
510:02 - a hashmap implemented with quadratic
510:05 - probing and simd lookup by default a
510:10 - hashmap uses a hashing algorithm
510:13 - selected to provide resistance against
510:16 - hash those attacks so over here we find
510:19 - some information about the used
510:21 - algorithm for the hash Maps
510:24 - but let's dive into the exercises
510:28 - so the first thing is we actually have
510:31 - to use here a namespace so we are
510:34 - basically importing from the collections
510:37 - module from this standard Library the
510:39 - hashmap type
510:41 - and when using vectors or strings these
510:46 - are all in the Prelude meaning we don't
510:48 - have to import it but a hash map you
510:51 - will have to basically import
510:54 - so over here we are initializing an
510:57 - empty hash map
510:59 - then we insert some entries and again a
511:04 - hash map holds entries of keys and
511:08 - values now important here is that all
511:11 - the keys must be of the same type and
511:14 - all of the values must be of the same
511:17 - type so this over here would cause an
511:21 - error
511:22 - and let's go with integers
511:25 - like that and we annotate the hash map
511:28 - like this
511:30 - [Applause]
511:33 - where key stands for key and v stands
511:36 - for value
511:38 - so over here we use string literals as
511:41 - keys
511:43 - and i32 integers as values
511:50 - then as you can see we can access
511:55 - the entries in a hash map by using again
511:58 - the get method which returns an option
512:02 - we have seen that before when dealing
512:05 - with vectors
512:06 - so we provide the get method
512:09 - the name of the key all right and then
512:14 - we will get back the appropriate value
512:17 - in this case 98 because we are accessing
512:20 - the entry sun phase right so we would
512:25 - get back here
512:26 - a sum
512:28 - an option
512:30 - i32 right this would be the return value
512:35 - some 98 and this would be the type
512:39 - option i32
512:43 - so we can check if
512:46 - the hashmap contains a certain key so
512:50 - for example if the hash map contains the
512:53 - key Daniel this would evaluate to true
512:57 - meaning the code block here will be
513:00 - executed
513:01 - and we can also index into a hashmap
513:05 - using bracket notation like that
513:08 - so again this would then hold
513:12 - the value of the entry Daniel it would
513:16 - be 95 right
513:20 - this would be an i32 again notice the
513:24 - difference between indexing like that or
513:27 - indexing using using get method
513:30 - we will get back the value here directly
513:33 - while here we get back an option so get
513:37 - is generally safer
513:41 - and then over here we are removing
513:44 - Daniel from the hash map
513:47 - right so we can use the remove method
513:50 - and provide it the key
513:53 - the entry we want to delete meaning
513:57 - after deleting Daniel over here the
514:00 - length of the hash map would be 3 right
514:08 - and we can also iterate over a hash map
514:12 - so we provide it here
514:13 - the variable holding the hash map and
514:18 - then
514:20 - the return would be a tuple holding the
514:23 - key and the value and then we just print
514:27 - out the key and the value
514:30 - let's see
514:38 - all right and we would get back here an
514:42 - option
514:44 - holding a reference to i32 all right
514:50 - and over here too we would get back a
514:53 - reference
514:54 - this is what the get method will
514:57 - actually return so as you can see we are
515:00 - printing out the hash map
515:03 - and this would be the key for example
515:06 - Ashley and this would be the value
515:09 - as you can see
515:12 - now notice that the order here is
515:15 - different from what is over there and
515:19 - that's because a hashmap is unordered so
515:22 - the order won't be retained all right
515:28 - and of course we have only three
515:30 - elements here because we have removed
515:33 - the entry of Daniel
515:45 - then over here we have an array holding
515:49 - tuples which holds a string literal and
515:53 - an integer right
516:01 - so we have an array of three elements
516:06 - and each element is of type Tuple
516:10 - and inside the Tuple is a string literal
516:14 - and an i32
516:19 - then over here we are initializing a new
516:23 - empty hash map
516:25 - then we iterate over here through the
516:28 - elements of this team's array
516:33 - so for each element here
516:37 - we insert into this empty hash map here
516:42 - the name over here the string and the
516:46 - value
516:47 - all right
516:52 - Implement team map 2 in two ways tips
516:56 - one of the approaches is to use collect
516:59 - method so we can also
517:03 - implement
517:04 - a hash map from an array holding tuples
517:08 - of keys and values by using the hash map
517:15 - from function so we provide it here
517:19 - teams
517:22 - and this will then directly convert this
517:26 - array holding tuples of keys and value
517:28 - pairs to a hash map
517:31 - meaning we then have a hash map
517:35 - holding string slice keys and i32 values
517:41 - all right
517:43 - and over here we would have the same
517:45 - thing
517:49 - and then when we compare teams map 1 and
517:53 - teams map 2 they should be equal let's
517:57 - see
517:59 - this is compiling
518:01 - now the second approach would be taking
518:04 - this teams array here
518:08 - and we want to put it into an iterator
518:13 - and again we will cover that
518:15 - and then we call collect
518:19 - now when we call the collect method it
518:21 - will basically collect the elements in
518:25 - this iterator into the type we have
518:28 - annotated here
518:33 - again this would compile because we have
518:36 - in teams map 2 the same
518:39 - keys and values as we have in teams map
518:42 - one
518:43 - and as you can see we don't need to
518:46 - write a full-blown for Loop we can just
518:50 - use some simple methods
518:56 - let's see number three fill in the
518:58 - blanks so
519:00 - type inference lets us omit an explicit
519:03 - type signature which would be hashmap
519:06 - string slice and u8 in this example so
519:10 - again we don't have to annotate the
519:12 - types I do it just to make things more
519:15 - clear
519:16 - but we can leave it at that
519:19 - insert a key only if it doesn't already
519:22 - exist
519:24 - so here we are
519:27 - accessing player stats this empty
519:30 - hashmap and we call the entry now the
519:33 - entry checks if
519:37 - an entry exists with this specific key
519:42 - and then we can call over here the or
519:45 - insert method meaning if this entry
519:48 - doesn't exist then we insert this key
519:53 - with this value meaning when we then
519:57 - access player stats with a key of Health
520:01 - we would should get back 100 right
520:04 - because this has been inserted over here
520:09 - insert a key using a function that
520:12 - provides a new value only if it doesn't
520:15 - already exist
520:19 - so
520:20 - again we are trying to access player
520:22 - stats and look for an entry Health now
520:27 - in this case this exists right because
520:29 - we have inserted it at that point
520:33 - now we can also use here the method or
520:36 - insert with the difference to our insert
520:39 - is that we don't provide a concrete
520:42 - value but a function pointer meaning
520:47 - this function will then get executed so
520:50 - this function only returns 42 so that
520:55 - means if the entry Health doesn't exist
520:59 - we insert this key with the value of 42.
521:04 - now again Health exists meaning when we
521:08 - Access Health we will still get 100
521:10 - right
521:12 - because this only executes if N3 isn't
521:17 - found
521:19 - ensures a value is in the entry by
521:21 - inserting the default if empty and
521:25 - returns immutable reference to the value
521:27 - in the entry
521:29 - so we are here
521:32 - checking for the entry health
521:35 - and if it doesn't exist we insert 50
521:40 - right
521:41 - so in this case Health already exists
521:48 - meaning we would get back immutable
521:51 - reference to the existing value 100
521:55 - right
522:00 - so this would be immutable
522:03 - reference to 100.
522:06 - and because it is mutable we can then
522:10 - modify the entry manually so we can hear
522:14 - decrement from Health which holds 100 we
522:19 - decrement 50 meaning the health will
522:22 - then hold
522:24 - 50 right this health variable holds 50.
522:30 - let's see
522:35 - this would be u8 in this case
522:49 - and this is compiling so as you can see
522:51 - when we call entry it will give us back
522:55 - a mutable reference to the value
522:59 - if it already exists to the existing
523:01 - value if it doesn't exist it will here
523:05 - create an entry because this is what the
523:08 - or insert method does and will return
523:12 - immutable reference to the created value
523:18 - and then we can
523:20 - modify
523:22 - this mutable reference
523:25 - right
523:27 - requirements of hashmap key any type
523:31 - that implements C EQ and hash trades can
523:34 - be a key in a hashmap this includes pool
523:37 - intu in string and string slices
523:41 - note that F32 and f64 do not Implement
523:45 - hash likely because floating Point
523:48 - Precision errors would make using them
523:50 - as hashmap Keys horribly error prone
523:54 - all collection classes Implement EQ and
523:57 - hash if their contained type also
524:00 - respectively implements EQ and hash for
524:04 - example a vac holding a type T will
524:08 - Implement hash if T implements hash so
524:12 - if the elements in a collection for
524:15 - example a vector or a tuple or an array
524:18 - implement
524:19 - the hash trade then the collection
524:24 - itself will Implement hash
524:28 - let's see fix the errors tips derive is
524:31 - usually a good way to implement some
524:33 - common use traits as you can see we have
524:36 - here a struct viking with two fields of
524:39 - type string
524:41 - and here we have
524:44 - an associate function for Viking just
524:48 - creating a new Viking instance from the
524:51 - arguments we provide
524:54 - and as you can see use a hashmap to
524:57 - store the Vikings Health points
525:00 - so we are creating here a hash map from
525:03 - an array holding tuples of keys and
525:06 - values
525:08 - now notice we have here a hash map
525:12 - and the type of the keys would be the
525:15 - custom type y King all right
525:21 - the value would be i32
525:27 - use derived implementation to print the
525:30 - status of the Vikings so here we are
525:33 - taking this created hash map as a
525:36 - reference and we would get back a tuple
525:40 - holding the key and the value and then
525:43 - we just print out the key and the value
525:46 - here
525:47 - so we have seen that in order
525:52 - a type can be used as a key in a hash
525:56 - map it has to implement EQ and hash so
526:01 - let's Implement that
526:11 - let's also use the partially queue over
526:13 - here
526:15 - and debug so we can print out the key
526:18 - over here in debug notation let's see
526:34 - and of course we have to implement the
526:36 - hash trade
526:44 - and as you can see it will print out
526:47 - each element in the hash map we have
526:51 - created so we have now a hash map
526:54 - using as key our custom type y King as
526:59 - you can see this would be the key
527:01 - this would be the value
527:03 - of the hashmap
527:07 - capacity like vectors hash maps are
527:10 - growable but hashmaps can also shrink
527:13 - themselves when they have excess space
527:16 - you can create a hash map with a certain
527:19 - capacity using hashmap with capacity or
527:23 - use hashmap new to get a hashmap with a
527:27 - default initial capacity this is
527:30 - recommended
527:33 - so like we did with strings and vectors
527:36 - we can Define when initializing an empty
527:39 - hashmap the capacity right
527:42 - ensuring that when we know we will push
527:46 - a lot of entries that there are no
527:50 - reallocations because remember we
527:53 - allocations are slower
527:55 - so then we are here inserting two
527:58 - entries
527:59 - and as you can see this would be an
528:01 - entry of
528:03 - key i32 and value i32 so the key entity
528:09 - value can be of the same type and over
528:12 - here we insert again another entry
528:16 - indeed the capacity of hashmap is not
528:18 - 100 so we can't compare the equality
528:21 - here
528:23 - so even though we have here defined that
528:26 - the capacity should be 100 it could
528:29 - actually be more than 100 and this is
528:33 - just in case there are collisions there
528:36 - are some
528:39 - internal stuff going on so the RAS
528:43 - compiler will actually allocate more
528:46 - capacity than 100 we defined here
528:52 - shrinks the capacity of the map with a
528:55 - lower limit so when we call map over
528:58 - here our hash map holding two entries
529:01 - and then we can shrink the capacity to
529:04 - 50 right so again the capacity won't
529:09 - probably be exactly 50 then but around
529:13 - 50 so we can shrink the hash map
529:17 - and shrinks the capacity of the map as
529:20 - much as possible so because over here we
529:22 - have only a hash map of two entries 50.
529:27 - spaces in Heap memory would actually be
529:30 - more than we need so we can use this
529:32 - shrink to fit method so that the
529:36 - capacity will shrink around
529:38 - the amount of elements it actually holds
529:42 - again it won't probably be 2 exactly but
529:46 - around this number
529:53 - ownership for types that implement the
529:56 - copy trade like i32t values are copied
529:59 - into hashmap for owned values like
530:03 - string the values will be moved and
530:05 - hashmap will be the owner of those
530:07 - values
530:09 - fix the errors with least changes don't
530:12 - remove any code line
530:15 - so over here we have initialized a
530:18 - variable with a type of i32 and an empty
530:22 - hash map
530:24 - right
530:25 - then we insert here
530:28 - and N3 into M1
530:31 - and using the same exact value for the
530:34 - key and the value meaning we have here a
530:37 - hash map
530:41 - with keys of type i32 and values of type
530:45 - i32
530:48 - over here we have a string
530:52 - and we initialize here an empty hash map
530:57 - then over here we are inserting a new
531:01 - entry using V2 this string here as the
531:06 - key and V1 over here as value so we
531:10 - would have here a hash map
531:15 - using
531:17 - keys of type string and value of type
531:21 - i32
531:24 - and because this is an owned type
531:27 - meaning it doesn't Implement copy this
531:31 - will then actually be moved into the
531:33 - hash map so we can't use V2 here
531:38 - but what we could do to fix that is we
531:41 - could use a string slice of this string
531:44 - right we just provide a reference
531:48 - meaning then the hash map will have
531:51 - type for the keys of string slices right
531:58 - and that means we can then again use V2
532:05 - and again because V1 is of type i32 it
532:10 - means it implements the copy trade
532:12 - meaning even if we pass it as a key in
532:15 - the hash map or as a value it is still
532:19 - usable
532:20 - but when you are dealing with types that
532:22 - don't Implement copy the ownership will
532:26 - get moved meaning hashmap will then be
532:29 - the owner of the type
532:34 - alright and there are some third-party
532:36 - hash lips but I won't cover that in this
532:39 - beginners course so we'll see you in the
532:41 - next topic
532:46 - let's now look at type coercion and we
532:49 - have already seen the S keyword and this
532:52 - is mostly used for converting integers
532:56 - so type conversion also called type
532:59 - casting is coercing a primitive type
533:02 - that can be performed by as keyword
533:06 - as conversions can be Chained and when
533:09 - casting to an unsight type T for example
533:12 - then T Max Plus 1 is added or subtracted
533:17 - until the value fits into the new type
533:21 - and using unsafe methods can lead to
533:24 - undefined Behavior
533:27 - so let's see an example as you can see
533:31 - we have here the largest unsigned 8-bit
533:34 - integer 255.
533:38 - and this would be the binary
533:40 - representation
533:42 - this means that u8 right this data type
533:45 - for unsigned 8-bit integers Max meaning
533:51 - 255 plus 1 will be
533:54 - 256 so for example if we Typecast 1000 s
534:01 - u 8 then let's see what the compiler
534:05 - will do
534:06 - it will subtract
534:09 - 256 this value over here from 1000
534:14 - and then it will check seven hours
534:17 - 744 is still bigger than the largest
534:21 - value it can represent meaning it will
534:24 - do the same thing
534:26 - subtracting
534:28 - 256 will leave us with
534:32 - 488 still bigger than this value so
534:36 - again the same thing it will subtract
534:39 - 256 and this will leave us with
534:43 - 232 meaning this will then be the
534:46 - returned value when we cast 1000 s u 8
534:50 - because remember an 8-bit unsigned
534:53 - integer can't represent 1000 it's out of
534:58 - bounds
535:00 - now when we Typecast
535:02 - -1
535:03 - as u8 then remember an unsight integer
535:09 - cannot represent negative numbers
535:11 - meaning what it will then do it will
535:15 - basically rotate so 0 would be the
535:19 - smallest possible number an 8-bit
535:21 - unsigned integer can represent and then
535:25 - -1 will just basically rotate it will go
535:27 - back to the biggest one meaning this
535:31 - type casting over here will result in
535:34 - 255.
535:38 - so convert by S rust provides no
535:41 - implicit type conversion coercion
535:44 - between primitive types but explicit
535:47 - type conversions can be performed can be
535:50 - performed using the as keyword
535:53 - fix the errors and fill in the blank
535:56 - don't remove any code
535:58 - so over here we have an F 32 float right
536:04 - then we Typecast this float into an u8
536:10 - meaning over here the fractional part
536:14 - will get removed so the value would be
536:17 - 97.
536:20 - and of course this will then hold a u8
536:24 - now we want to Typecast this decimal
536:27 - into HR now this is not possible
536:31 - directly but we have seen that we can
536:33 - chain as statements so we can convert
536:38 - this first to an u8
536:41 - meaning we will get 97 like we did here
536:44 - and then Typecast it to a character so
536:48 - C1 will then hold a character
536:52 - and by the way 97 would be the ASCII
536:55 - code for a
536:59 - and over here as you can see we can
537:02 - Typecast this integer holding an u8 type
537:06 - as Char directly so C2 would also hold
537:10 - HR
537:13 - now as you can see we are here comparing
537:17 - the integer holding 97 with this type
537:22 - casting now this type casting over here
537:25 - converts the B character to its u8
537:30 - representation now B would be
537:33 - represented as 98.
537:36 - so what we can do over here is adding
537:39 - one
537:42 - 297 because remember 97 would be a
537:48 - meaning when we add 1 to 8 we will get
537:51 - back B right so both of them will hold
537:56 - 98.
538:03 - by default overflow will cause compile
538:06 - errors but we can add a global
538:08 - annotation to suppress these errors
538:12 - so as you can see the largest possible
538:16 - number u8 can represent would be
538:19 - 255 meaning this would cause an error
538:25 - because again 1000 is larger than the
538:28 - largest possible number a weight can
538:31 - represent meaning we have here an
538:34 - overflow error now we can actually allow
538:37 - overflowing
538:39 - by using this attribute
538:53 - so
538:55 - distance won't complain right
538:58 - and then when we print out B
539:02 - [Applause]
539:12 - as you can see we would get back
539:15 - 232 because we have seen over here
539:21 - that
539:22 - this would be the result when the
539:25 - compiler performs this operation
539:29 - so we allow here overflowing literals
539:33 - right
539:34 - if we didn't if we comment this out
539:38 - then the compiler will complain because
539:41 - this is actually not possible
539:46 - when casting any value to an unsight
539:49 - type T T Max plus one is added or
539:52 - subtracted until the value fits into the
539:56 - new type that's what we have seen so in
540:00 - this case 1000 as u16 would return 1000
540:05 - right because a u16 can represent a
540:10 - number of 1000 but over here we would
540:14 - have an overflow meaning this would
540:18 - return
540:20 - 232 like we have seen over here
540:25 - for positive numbers this is the same as
540:28 - the modulus
540:30 - so this would actually be the same as
540:35 - uh doing a thousand modulus
540:39 - 256 remember
540:42 - u8 Max
540:44 - plus one
540:49 - meaning 256.
540:54 - now we have also seen in the example
540:57 - when we have
540:58 - -1 and casting that to an unsigned
541:01 - integer it will then basically just
541:04 - rotate so this will return
541:07 - 255. since rust 1.45 the S keyword
541:12 - performs a saturating cast when casting
541:15 - from float to int if the floating point
541:18 - value exceeds the upper bound or is less
541:22 - than the lower round the The Returned
541:24 - value will be equal to the bound crossed
541:28 - so in this case we have a float here
541:32 - casting it to u8 meaning a saturating
541:37 - cost will be performed so it will just
541:40 - return the largest possible number u8
541:43 - can represent which would be 255.
541:49 - now in case we have here A minus 100 as
541:53 - floating point and convert it to u8 this
541:57 - just would return 0.
542:01 - it's a possible number u8 can represent
542:06 - this Behavior incurs a small runtime
542:09 - cost and can be avoided with unsafe
542:12 - methods however the results might be
542:15 - overflow and return unsound values use
542:19 - these methods wisely we can use here in
542:22 - an unsafe block
542:25 - the method to int unchecked
542:30 - so the compiler here won't actually
542:33 - check what's going on so as you can see
542:36 - we are casting 300 floating Point 2 and
542:41 - U int
542:43 - to a u8
542:45 - so as you can see we are here casting
542:48 - 300.0 floating point to
542:52 - and u8 integer and this won't be checked
542:57 - by the compiler that's because it's in
543:00 - an unsafe block
543:03 - now this would return 44 right because
543:09 - 300 minus u8 Max
543:13 - plus one
543:16 - would be 300 minus 256
543:22 - meaning we would be left with 44.
543:26 - and minus 100 Su 8 as you can see we are
543:31 - typecasting this floating point
543:35 - 2 and u8 integer and again this is
543:38 - unchecked so again what the compiler
543:41 - will do here it will take u8 Max
543:45 - plus one meaning 256 and it subtracts
543:51 - 100 meaning we would get 156.
543:58 - and not a number
544:01 - would be converted to zero okay
544:07 - thank you
544:11 - and of course here we have to use again
544:16 - the attribute allow
544:18 - overflowing
544:21 - literals
544:23 - just so this will actually compile
544:26 - because usually this won't compile
544:34 - and as you can see this would be the
544:36 - output
544:39 - now over here we are dealing with raw
544:42 - pointers and we won't cover that in this
544:45 - beginner's course because this is more
544:48 - of an advanced topic
544:50 - so see you in the next topic
544:54 - so we have seen type conversions for
544:57 - integers and types from the standard
545:00 - library but what if we want to convert
545:03 - types that we defined basically custom
545:06 - types and rust has for this T from
545:11 - entity into trade so let's see from and
545:14 - into trades are used for type
545:17 - conversions between different types
545:19 - without requiring explicit costs it's
545:23 - part of the standard library and can be
545:26 - implemented for custom types
545:29 - implementing the from trade for a type
545:32 - will give us the intu implementation for
545:35 - the given type for free meaning when we
545:38 - Implement from we implement it into
545:41 - automatically
545:43 - so always implement the from trade and
545:46 - not the into trade
545:50 - let's see here an example we have a
545:53 - custom type number
545:56 - and then over here we are implementing
545:59 - the from trade right so we want to
546:04 - convert from an i32 to our custom type
546:09 - number right and the from trade
546:13 - implements a method from
546:16 - so we take here as an argument an i32
546:20 - and we will then create a new instance
546:24 - of the number type with the provided
546:27 - value and then return it and that means
546:31 - when we use here the from Associated
546:33 - function on our custom type
546:37 - number and provide it in i32 then this
546:42 - can directly be converted to our custom
546:47 - type right
546:50 - and we can do it in two ways from as
546:53 - we've seen because we have implemented
546:55 - it and I've told you that when we and
546:58 - I've told you that when you implement it
547:00 - from trade T into trade is automatically
547:04 - implemented meaning we can also call the
547:07 - into method on the type we want to
547:11 - convert to but when you use into a type
547:15 - annotation is needed so the compiler
547:17 - knows into what type you want to convert
547:21 - this type right so we convert here
547:25 - a type of i32 into a number
547:30 - and this would be the implementation
547:37 - so the from trade allows for a type to
547:39 - Define how to create itself from another
547:42 - type hence providing a very simple
547:45 - mechanism for converting between several
547:48 - types deformant into trades are
547:51 - inherently linked and this is actually
547:53 - part of its implementation it means if
547:57 - we it means if we write something like
548:01 - this
548:02 - we Implement here
548:04 - so we Implement here the from trade for
548:07 - the custom Type U then we can use
548:12 - U from T right we can then
548:17 - create a u-type from the type T we have
548:22 - implemented the front trade on
548:26 - or we could also use into so we convert
548:30 - T into U
548:33 - the input rate is simply the reciprocal
548:36 - of the from trade that is if you have
548:39 - implemented the from trade for your type
548:42 - then the input rate will be
548:44 - automatically implemented for the same
548:47 - type using the into trade will typically
548:50 - require to type annotations as the
548:54 - compiler is unable to determine this
548:57 - most of the time
548:59 - so for example we can easily convert a
549:02 - string slice into a string
549:07 - as you can see we have over here a
549:09 - string slice and then we can call string
549:13 - and the from Associated function
549:15 - providing it this string literally
549:19 - meaning this will then be converted to a
549:22 - string
549:23 - and we could also use the two string
549:26 - method again this and this is exactly
549:29 - the same
549:31 - and we could also then use the into
549:34 - because remember when we Implement from
549:36 - we get into for free so we can so we
549:42 - convert this my string string literal
549:45 - into a string and again type annotations
549:49 - are needed
549:53 - because the sender library has already
549:55 - implemented this for us
549:59 - input from string slice for string so we
550:02 - can easily convert a string to a string
550:06 - slice and vice versa
550:09 - some implementations of form can be
550:12 - found here
550:13 - so as you can see we have here input
550:17 - from Bool for i32 meaning we can convert
550:24 - Boolean into an i32 so when we have here
550:29 - a Boolean value and call into it will
550:32 - convert this Boolean value into an i32
550:37 - integer in this case this would
550:40 - be zero zero for false and one for true
550:46 - and again when we can use the into
550:49 - method we can use the from Associated
550:51 - function
550:54 - so we call the associated function on
550:56 - the type i32 and provide it here the
551:01 - Boolean value right
551:06 - so this will then actually be exactly
551:09 - the same
551:12 - fix the error in two ways first
551:15 - Implement from Char 4 maybe you should
551:18 - check the docs mentioned above to find
551:21 - the answer
551:22 - second a keyword from the last chapter
551:28 - so let's see the docs
551:34 - so
551:36 - we want here to convert a character
551:42 - so let's see over here as you can see
551:45 - you can see all the types that
551:48 - implemented from trade so we want to go
551:52 - from character
551:54 - and as you can see we can convert a
551:57 - character to either u32 u64 or
552:03 - u128 as well as string so I 32 is not
552:09 - supported
552:12 - and as you notice these are only
552:14 - unsigned types because it's logical a
552:19 - character can't be negative right it
552:21 - can't hold a negative number so we only
552:23 - have
552:25 - unsigned intervals here
552:27 - so we can
552:30 - so we can then in fact convert HR into a
552:34 - u32 let's say
552:37 - so in this case
552:39 - Char implements
552:42 - so in this case
552:43 - we use here u32 right we can convert
552:48 - from HR to Au 32.
552:52 - meaning when we change this over here
552:55 - this should actually work so we provide
552:58 - here a character called the into method
553:00 - and then we should have a new 32.
553:05 - fix the error in two ways so we can't
553:09 - use the as keyword here this is not
553:12 - implemented but what we can do is let's
553:16 - first use the from method
553:33 - so we can create a string or basically
553:37 - converting a character into a string
553:41 - because we have seen in the
553:43 - documentation this is actually
553:45 - implemented
553:48 - and the second way would be to call a
553:53 - and then into right like we did over
553:56 - here
554:04 - Implement from for custom types from is
554:08 - now included in standard Prelude so
554:10 - there is no need to introduce it into
554:13 - the current scope so we don't have to uh
554:18 - so we don't have to import the from
554:21 - trade it's actually in the Prelude
554:23 - meaning we can use it
554:25 - without importing anything so over here
554:28 - we have a custom type number with one
554:31 - field
554:33 - now we want to implement the from trade
554:36 - for our custom number meaning we should
554:40 - be able to convert from an i32 into a
554:45 - number
554:46 - so when we call over here
554:49 - number
554:51 - from
554:53 - right
554:55 - then
554:56 - we should get over here number
555:00 - this would then create an instance of
555:03 - the number struct
555:05 - and the value field here will hold a
555:09 - value of 30 right
555:12 - so
555:14 - and the same thing is when we would call
555:17 - 30
555:18 - like that
555:20 - and call into right this should then
555:24 - convert the
555:27 - i32 integer into the number type
555:31 - automatically
555:33 - and remember we only have to implement
555:36 - the from trade because then we can use
555:39 - from and into
555:42 - both of them
555:44 - so let's see so this over here is the
555:48 - from trade and
555:51 - let's take this function signature over
555:53 - here
555:55 - and copy it like that
556:00 - now in this case self refers to number
556:03 - right
556:04 - and what we want to do is create here a
556:08 - new instance
556:12 - and we just take the value in this case
556:16 - the i32 right
556:19 - and we provide it as a value for the
556:23 - value field
556:26 - and again because the name of this
556:28 - argument matches the name of the field
556:31 - we can use it like that and this is
556:34 - sufficient so let's see
556:39 - and this is compiling so as you can see
556:41 - then it's really easy to convert one
556:45 - type to a custom type we have created
556:51 - when performing error handling it is
556:53 - often useful to implement from trade for
556:56 - our own error type then we can use
556:59 - question mark to automatically convert
557:02 - the underlying error type to our own
557:05 - type now we didn't cover that this will
557:09 - be the next topic but let's see the
557:12 - exercise we have here an enum CLI error
557:15 - now
557:17 - the two variants here IO error and parse
557:21 - Arrow hold Arrow types from the standard
557:24 - Library okay
557:27 - and
557:29 - these are actually the error types that
557:31 - get returned in case of an error when
557:35 - using these specific methods
557:39 - that are implemented in this standard
557:42 - Library
557:44 - so as you can see we want here to
557:47 - implement the from trade for different
557:50 - error kinds from this standard library
557:53 - and we want to convert that to our
557:56 - custom error type CLI error
558:00 - so let's see over here we have the
558:02 - function open and pause file it takes a
558:05 - file name as argument
558:07 - and it returns a result and we will
558:11 - cover results so a result basically says
558:15 - in case of
558:17 - success it will return a result with i32
558:21 - and otherwise CLI error
558:26 - so then we call the read to string
558:29 - function and as you can see this is
558:32 - defined in the fs module FS is used for
558:37 - file manipulation
558:39 - and we provide to this function over
558:42 - here the file name
558:44 - now we pass a reference because this is
558:47 - defined in the documentation of this
558:50 - function we are here using the question
558:53 - mark operator meaning in case of success
558:58 - the result type that will get returned
559:01 - will be unwrapped and contents will hold
559:04 - a string
559:06 - in case of an error it will return the
559:10 - CLI error meaning the rest of this code
559:13 - won't get executed and we just get acli
559:18 - error instead
559:20 - now
559:22 - the error type returned from this
559:25 - function would be IO error
559:29 - so in order this error to be converted
559:32 - to a CLI error we have to implement for
559:35 - this error type the from trade right but
559:40 - let's see what's happening here we then
559:43 - take the contents meaning this string
559:46 - over here that gets returned in case
559:49 - this function call is successful
559:53 - and we then hold over here the contents
559:56 - of the provided file then we trim and
560:01 - then we pause now pause could
560:03 - potentially fail and parsing is
560:05 - basically converting a string to an
560:08 - integer value right so in case of
560:13 - success we will get out an i32 in case
560:18 - of error we'll get back a num pulse and
560:22 - error this is defined in the num module
560:26 - again we will cover error handling and
560:28 - all of that don't worry this is now just
560:31 - about the type conversion
560:35 - and then we return an OK with the num
560:39 - value here we have to wrap it in OK
560:41 - because we return a result type
560:46 - now let's see how we would Implement
560:49 - that so again I will just go to the
560:51 - documentation and copy the function
560:55 - signature
560:59 - like that
561:02 - so we have the function signature
561:06 - and then we can over here see what we
561:10 - want to do so in case we get an i o
561:13 - error we want to convert that to our
561:17 - custom CLI error now how would we do
561:20 - that let's change here
561:23 - the argument to e for error and the type
561:28 - would be IO error right we are
561:33 - implementing it
561:35 - from this type
561:37 - now what we want to do is we just want
561:40 - basically to pass the i o error into the
561:45 - io error variant in our custom type so
561:49 - we can access the variant
561:53 - so we can create an instance
561:58 - remember this is the syntax to access
562:01 - the enum so we access CLI error and then
562:04 - the io error variant
562:09 - and all we do then is just passing this
562:12 - IO error type
562:15 - meaning we then have an instance of this
562:18 - variant holding our i o error and that
562:22 - means we have then implemented the from
562:25 - trade for our custom type so any IO
562:29 - error type can be
562:31 - implicitly converted to CLI error
562:34 - meaning in case this function over here
562:37 - returns an IO error it will implicitly
562:41 - be converted to a CLI error
562:45 - let's do the same thing over here for
562:48 - parse int error this would be the error
562:51 - type from the parse method
562:57 - so again let's change here the argument
563:00 - name and the type would be over here
563:06 - and then we again just access this enum
563:14 - access the pause int Arrow variant
563:18 - and we pass it the actual error that
563:22 - gets returned
563:24 - and this would mean we then create
563:27 - another instance of the pause error
563:30 - variant
563:33 - let's see if this works
563:37 - and as you can see this is compiling
563:39 - meaning in case of an error over here
563:43 - both these Arrow types from the standard
563:47 - Library I or error and parse int Arrow
563:50 - will be implicitly converted to CLI
563:54 - error right
563:57 - try from try into similar to from and
564:01 - into try from and try into our generic
564:04 - traits for converting between types
564:08 - unlike from into try from and try into
564:12 - are used for valuable conversions and
564:15 - return a result instead of a plane value
564:21 - now again we use the result type we will
564:23 - cover that when there is a possibility
564:27 - of an error of something going wrong
564:32 - so as you can see we have here an i16
564:35 - holding 256.
564:39 - into trade has a method in two hence try
564:43 - into has a method
564:47 - try into right this is the method
564:51 - defined on the try into trade so we take
564:55 - this value here and call the try into
564:59 - method on it
565:01 - meaning this will return a result so we
565:04 - match this result in case of an okay
565:07 - then we unwrap the value from the result
565:12 - and if it is an error then we just print
565:16 - out the error over here
565:20 - and
565:21 - return 0.
565:24 - right
565:25 - so in case this succeeds then n will
565:29 - hold a u8
565:31 - and the value in case this fails n will
565:35 - hold a value of 0. now we have seen that
565:40 - when we want to convert an u8
565:44 - then this would actually fail because
565:46 - this is out of boundaries
565:49 - but because we are here
565:52 - basically error handling that means that
565:55 - the program here won't actually panic
566:00 - so in case this fails here which it does
566:03 - then we will just assign to n the value
566:07 - 0 and print out the error so in this
566:11 - case n would be zero
566:16 - and again error handling will be our
566:18 - next topic so don't worry if this seems
566:21 - a little bit strange
566:27 - then over here we have a tuple struct
566:30 - even num and it takes an i32 type
566:36 - we Implement here the try from
566:40 - trade for the custom even num type
566:45 - now here we have an Associated type and
566:49 - we Define that it should be of type unit
566:52 - type okay and then we Implement here the
566:57 - try from function
567:01 - so all this function basically does it
567:04 - takes a value and it checks if it is
567:07 - divisible by zero and then we will
567:09 - return the result in this case okay even
567:13 - num and inside it t value provided
567:16 - otherwise if it is not divisible by 2
567:20 - then we return an error holding our
567:24 - unit type we have defined here as you
567:27 - can see the type
567:29 - in case of an error would be this
567:31 - Associated type error meaning a unit
567:34 - type so we have provided that over here
567:39 - so then we can use the drive from
567:43 - function so when we call even num and
567:48 - try from 8 then this would return okay
567:52 - right because 8 is divisible by two so
567:57 - we would get back a result in this case
568:00 - okay even num and T value we have passed
568:04 - right that's what we defined here
568:09 - now in case we try from a value of 5
568:12 - this would return an error with a unit
568:15 - type inside because again 5 is not
568:19 - divisible by 2.
568:22 - now with try from and try into it's
568:26 - exactly the same like with from and into
568:29 - when we Implement try from then try into
568:33 - is automatically implemented so we can
568:36 - use this try into method here directly
568:40 - so we try here to convert eight into
568:46 - this result right and the result in case
568:49 - of success will will hold the type of
568:52 - even num and otherwise a unit type like
568:55 - defined over here
568:59 - and in this case result will then hold
569:03 - ok
569:06 - even num
569:09 - and the value we have passed eight
569:13 - now when we call try into on 5 then this
569:19 - will actually return error
569:21 - and a unit type inside like we have
569:25 - defined over here
569:27 - let's see
569:31 - and this is compiling see you in the
569:34 - next topic
569:36 - let's now see two more exercises and
569:39 - this time we are converting a custom
569:42 - type into a string
569:45 - so to convert any type to string you can
569:48 - simply use the two string trade for that
569:51 - type rather than doing that directly you
569:54 - should implement the fmt display trait
569:57 - which will automatically provide
569:59 - tostring and also allows you to print
570:02 - the type with print line
570:05 - so again
570:07 - same thing like with from and into if
570:10 - you implement from then into is for free
570:13 - so you usually don't implement this
570:17 - trade directly for a type you implement
570:20 - display and you will get two string
570:23 - implementation for free
570:26 - so let's see we import here fmt
570:30 - and we have here our custom type point
570:34 - now here we are instantiating a point
570:37 - so what we want to achieve here is that
570:40 - when we take the point instance here we
570:42 - have instantiated and converted to a
570:46 - string
570:48 - this should then be the output
570:52 - and we can also use the format macro
570:56 - here
571:01 - basically just providing origin because
571:04 - the format macro will automatically
571:07 - convert that to a string in order to
571:10 - print it out and the output will be the
571:13 - same
571:14 - so let's implement the display trade
571:17 - here so as you can see this is the
571:20 - display trade and it provides one method
571:24 - now let's take it from over here
571:27 - they provide here an example
571:33 - and we can just copy
571:36 - this over here now I remove the lifetime
571:39 - it's not needed
571:41 - and
571:43 - let's implement the fmt
571:47 - method here so as you can see the fmt
571:50 - method provides here a formatter meaning
571:54 - we want to write we can use the right
571:57 - macro here and the right macro works
572:01 - like println or format but the
572:04 - difference is it will write to a buffer
572:08 - in this case f
572:10 - this is the formatter from the fmt
572:13 - module and then
572:16 - we here provide what we want to print
572:19 - out
572:21 - so in this case we want to print out the
572:23 - point is entity values so let's do that
572:33 - [Applause]
572:38 - and then like in a print Ln macro we
572:42 - provided the values so in this case we
572:44 - want cells dot X
572:46 - and self.y we want to print out
572:51 - the X and the Y field
572:54 - and that's basically it we have
572:56 - implemented the display trade for Point
572:59 - meaning our customly created type Point
573:03 - can be converted directly to a string so
573:07 - let's see
573:14 - and this is compiling so
573:24 - if we pass origin here let's see the
573:27 - output
573:29 - as you can see this would be the output
573:33 - so we can even
573:36 - manipulate how the output should look
573:39 - like so instead of just so instead of
573:42 - just printing out the two fields we have
573:44 - even
573:45 - provided the output with a whole
573:48 - sentence right
573:53 - this will be the last one we will be
573:55 - doing we can use parse method to convert
573:58 - a string into an i32 number
574:01 - this is because from string is
574:04 - implemented for i32 type in standard
574:07 - Library
574:08 - to use from string method you need to
574:11 - introduce this trade into the current
574:13 - scope so we have to import this
574:17 - trade from the stir module
574:23 - so over here we want to pause
574:27 - and parsing again means converting a
574:30 - string into an integer so we would here
574:34 - have an i32 type of this value and over
574:39 - here the same thing
574:43 - now we can either annotate the type over
574:47 - here or we could use the turbo fish
574:50 - syntax meaning we can directly annotate
574:54 - the type on the method
574:58 - like that
575:03 - and then because the from string trade
575:06 - is actually implemented for the i32 type
575:10 - we can also
575:12 - call the associated function from store
575:20 - let's do 20 here
575:22 - so this will
575:24 - convert from this string literal into an
575:28 - i32 meaning this will then hold an i32
575:31 - now because all of them hold i32
575:35 - integers we can then do a mathematical
575:39 - operation meaning we just add together
575:41 - all of these values 5 10 and 20.
575:46 - so to be variable will hold an i32 and
575:51 - it should be equal to
575:54 - 35
575:59 - and this is compiling see you in the
576:01 - next topic
576:04 - now we will cover error handling
576:07 - anti-simples form of error handling is
576:10 - to use the Panic macro Panic will print
576:13 - out an error message unwind this deck
576:16 - and finally exit the program now
576:19 - unwinding the stack means that when you
576:23 - actually execute the program then we
576:25 - have seen that the local variables and
576:28 - the function calls will be pushed to
576:30 - this stack now when panicking that means
576:33 - that the compiler will actually delete
576:36 - everything step by step from this stack
576:39 - memory and then exit the program
576:43 - and in multi-threaded programs it will
576:46 - exit the thread in which the Panic
576:48 - occurs not the whole program so we don't
576:51 - deal here with a multi-threaded programs
576:54 - this will be another course but I just
576:57 - want to mention it
576:59 - so let's see exercises
577:02 - as you can see we have here a function
577:05 - drink which takes a string literally
577:09 - if the string literal is lemonade then
577:12 - we print out success
577:14 - otherwise we actually want to panic
577:18 - right
577:20 - because we want to ensure that this line
577:23 - never gets reached meaning never gets
577:26 - printed out
577:27 - so when we pass over here lemonade
577:33 - then this will print out success and
577:36 - then will panic
577:43 - and this would be the output if a
577:46 - program panics threat main panicked at
577:49 - explicit panic and it will provide you
577:52 - the line number
577:54 - at which the Panic occurred in in this
577:57 - case an explicit panic because we have
577:59 - here called the Panic macro
578:04 - common Panic cases make make the code
578:07 - work by fixing all panics
578:11 - so when we call here the S bytes method
578:14 - on a string then it will give us back
578:17 - the array holding the utf-8 bytes of
578:21 - this string now we have seen that
578:24 - actually the utf-8 representation of a
578:27 - would be 97.
578:30 - B would be 98
578:34 - and C would be 99
578:37 - so again if srtq doesn't match if this
578:42 - does evaluate to another value then this
578:45 - then assert EQ will cause a panic over
578:49 - here we have a vector
578:53 - and we try here to access the third
578:57 - index now we only have now we only can
579:01 - go to index 2 right it's the outmost
579:04 - index we can provide
579:06 - so let's change that
579:09 - and this will then hold an i32 right
579:12 - because we are accessing a specific
579:15 - element
579:16 - unwrap May panic when get return a none
579:20 - so the get method over here will return
579:22 - an option meaning it either returns a
579:26 - sum with a value or a non now in this
579:30 - case this would return a non because we
579:33 - don't have any value at index 3. so when
579:38 - we try to unwrap a non
579:41 - value then we will panic
579:45 - now let's hear excess index 1 for
579:48 - example
579:50 - then it will return a sum
579:54 - two right the first element
579:57 - write the element at index one
580:01 - and unwrap we basically just unwrap the
580:04 - inner value so
580:07 - La will then hold a value of 2 of type
580:11 - i32
580:12 - sometimes the compiler is unable to find
580:15 - the Overflow errors for you in compile
580:18 - time so a panic will occur
580:22 - so when we call here the production rate
580:25 - per hour function with a value of 2 then
580:29 - let's see we have here speed
580:32 - the provided argument of type u8 and
580:36 - here we have cph of type u8
580:39 - now as you can see we are inside here
580:44 - multiplying the speed in this case 2 by
580:49 - cph
580:51 - 222 now this would actually result in an
580:55 - overflow because
580:58 - 2 times 221 would be
581:03 - 442 right now remember an u8 can only
581:07 - represent up to the number
581:10 - 255 so this would actually cause a panic
581:14 - but what we can do is just actually
581:17 - taking here a u16 and converting that to
581:22 - u16 meaning when we multiply these
581:25 - together then
581:27 - the result of u16 will still be able to
581:31 - represent the resultant number
581:35 - and over here we can do the same thing
581:45 - and then let's see because of the same
581:47 - reason as above we have to wrap it in a
581:50 - function to make the Panic occur so here
581:54 - we are calling the divide function with
581:57 - two arguments 15 and 0.
582:00 - so to divide function takes two
582:03 - arguments of type u8 and just divides it
582:06 - now this would also panic because we
582:10 - can't divide by zero this is a
582:12 - mathematical Rule and this will always
582:15 - lead to a panic so let's here divide by
582:18 - 1 for example
582:21 - let's see if this is compiling
582:27 - all right and again when we use the get
582:30 - method we will get back a reference to
582:33 - the value and not the actual value so
582:36 - let's change that
582:45 - and this is compiling
582:49 - detailed call SEC by default is stack
582:52 - unwinding will only give something like
582:54 - this
582:55 - so this would be the output if your
582:59 - program panicked though there is the
583:02 - reason of panic and the line of code is
583:04 - showing where the Panic has occurred
583:06 - sometimes you want to get more info
583:09 - about the call stack
583:12 - fill in the blank to display the hole
583:14 - called stack tips you can find the clue
583:16 - in the default Panic info so when we run
583:20 - cargo run this is basically how you
583:23 - execute a program you have written and
583:25 - will cover that then you just provide
583:28 - over here this rust back Trace equals
583:33 - one environment variable and it will
583:35 - then give you
583:38 - detailed information about the Panic
583:41 - that occurred
583:44 - so over here unwinding and abort by
583:47 - default when a panic accuracy program
583:49 - starts unwinding which means rust walks
583:52 - back up to stack and cleans up the data
583:55 - from each function it encounters
583:58 - but this work pack and cleanup is a lot
584:01 - of work the alternative is to
584:04 - immediately abort the program without
584:06 - cleaning up if in your project you need
584:10 - to make the resulting binary as small as
584:12 - possible you can switch from unwinding
584:15 - to aborting by adding below content to
584:18 - cargo.com
584:21 - so
584:22 - we can here Define in this cargo.tamil
584:25 - file and I will show you an example of
584:27 - that
584:29 - how Panic actually behaves so we have
584:32 - two
584:34 - um so we have two options here either
584:36 - unwinding or aborting when choosing a
584:40 - board here then the stack won't get
584:43 - unwinded meaning this will then be the
584:47 - responsibility of the operating system
584:49 - and not of the rust compiler
584:53 - alright see you in the next episode
584:57 - so we have seen the option type and the
585:01 - option type stands for a value that
585:03 - could potentially be absent so let's now
585:06 - look at the result type result is an
585:10 - enum type that represents the outcome of
585:13 - an operation that could potentially fail
585:16 - it has two possible variants okay a
585:20 - value T was found and error and error
585:23 - was found with a value e and as you can
585:27 - see the variance hold the specific
585:30 - information
585:32 - the expected outcome is okay the
585:35 - unexpected outcome is error since result
585:38 - is an enum the possible variance can be
585:41 - matched using a match pattern and that
585:44 - is what we call error handling
585:47 - so let's see an example
585:50 - let's again consider the divide function
585:54 - we have seen before so again we can't
585:57 - divide by zero meaning if the second
586:00 - argument here is 0 then we should return
586:05 - an error otherwise the program will
586:08 - Panic now we can do here error handling
586:11 - meaning we check if Y is zero right or
586:17 - in this case 0.0 because the arguments
586:20 - are floating Point numbers now in case y
586:24 - what's the value of 0 then we return the
586:27 - error variant of the result enum and we
586:31 - provide it an error message all right so
586:36 - in this case
586:38 - we use an explicit return keyword
586:42 - meaning when this returns it won't
586:48 - execute any further it will directly
586:52 - return the error type and stop execution
586:56 - now in case Y is not 0 then we will just
586:59 - divide X by Y and wrap it inside okay
587:03 - because remember result is an enum
587:07 - meaning we have two wrapped the
587:12 - resultant value inside the variant so
587:15 - that means when this function succeeds
587:18 - then we will get back an F 32 right the
587:24 - result of this operation and this is
587:27 - wrapped inside okay because as you can
587:29 - see we are returning a result type now
587:33 - in case of an error we would return this
587:37 - string over here wrapped in the arrow
587:40 - variant
587:47 - and this allows us then when we call the
587:50 - function divide with two arguments
587:54 - that we can then match the result we get
587:59 - back here as you can see we would get
588:01 - back a result type meaning the result
588:05 - type has two variants either okay or
588:09 - error and we can here use pattern
588:12 - matching to the structure the inner
588:16 - value for example this F32 into the
588:20 - variable Val which we then can print out
588:24 - and in case of an error we will get back
588:28 - this string over here the error message
588:31 - and we destructure it into this variable
588:34 - here and then print it out
588:39 - unwrap the unwrapped method takes as
588:42 - input a value of type result and takes
588:45 - out the value which is wrapped inside
588:48 - okay in case of success or panics in
588:52 - case of an error in case it returns an
588:55 - OK variant we just take the value that
588:59 - is wrapped inside
589:01 - otherwise the program will panic
589:05 - so you should use unwrap only if you're
589:08 - a hundred percent sure that the return
589:12 - variant will be okay otherwise you
589:16 - should use match
589:19 - and let's see the question mark operator
589:22 - the question mark operator is a
589:25 - shorthand way to propagate errors or
589:27 - unwrap OK results
589:30 - basically it's the same as unwrap but
589:33 - instead of panic it returns an error it
589:37 - replaces an entire match statement and
589:41 - can and it can even be used in the main
589:44 - function
589:47 - so as you can see over here in the main
589:50 - function we can Define here that main
589:53 - should return a result type
589:57 - and
589:58 - as you can see we have here a string
590:01 - holding a number then we try to parse
590:05 - this string over here into an i32 type
590:10 - now we have seen that the parse method
590:13 - could potentially fail right if we have
590:16 - here a string holding T for example the
590:20 - compiler can't convert it to an i32
590:23 - because it's not a valid number
590:26 - so in case we get back the OK variant
590:30 - remember parse will return a result if
590:34 - we get back okay then we just take the
590:38 - inner value and return it meaning the
590:42 - inner value will then be assigned to the
590:45 - number variable
590:47 - in case of an error we want to return
590:51 - meaning this over here won't get
590:55 - executed it will return before and we
590:59 - just provide the error message over here
591:04 - and in this case because we are using a
591:08 - function from the standard Library this
591:10 - error message is actually provided right
591:13 - so we just take the provided error
591:15 - message and return it
591:18 - and if this didn't fail it means this
591:22 - will get executed and we just print out
591:24 - the unwrapped number now because we
591:28 - return here a result type we have to
591:31 - also return an OK in case everything
591:34 - succeeded now because at the end of Main
591:39 - basically the end of the program has
591:42 - been reached so it doesn't make sense to
591:46 - return any meaningful value so we just
591:49 - return a unit type like that so I've
591:52 - told you that the question mark operator
591:54 - actually replaces an entire match
591:57 - statement meaning
592:00 - this over here would be exactly the same
592:03 - so let's see again we are in Main and we
592:06 - return a result
592:09 - now as you can see we have again a
592:12 - string holding a number
592:14 - then we try to parse over here and again
592:17 - pause returns a result so we have to
592:21 - handle the error case
592:23 - now we can do that appending to it the
592:27 - question mark operator
592:29 - meaning
592:30 - in case this succeeds
592:34 - and it returns an OK with the value in
592:38 - this case 10 but post as an integer then
592:42 - it will just assign it to this variable
592:44 - meaning number will then hold 10 as an
592:48 - i32
592:50 - in case this fails then it will return a
592:55 - pause int error as defined in the parse
592:58 - method
592:59 - okay
593:00 - so this over here is exactly the same
593:03 - like we did over here
593:06 - and when this returns an error
593:09 - the following lines won't be executed
593:13 - in case this succeeds then we have
593:17 - number which holds 10 of type i32 then
593:22 - we'll just print out the post number and
593:25 - then we return a unit type because
593:28 - remember we are here returning a result
593:31 - meaning we have to also return OK
593:33 - variant in case of success
593:38 - but again because we are in Main and
593:41 - this would be the end of the program we
593:43 - don't return any meaningful value we
593:46 - will return a unit type and there is
593:50 - also a concept called type Alias so it's
593:53 - basically just a way giving a name to an
593:57 - existing type
593:58 - so if you like to write u64 like this
594:03 - then you can create a type Alias meaning
594:06 - we can use the type keyword and provide
594:10 - a new name for a specific type and as
594:14 - you can see over here we are then using
594:16 - the new type we have created here and
594:20 - this would at compile time then be
594:22 - replaced with the real type
594:26 - and please don't confuse that with
594:29 - Associated types in trades they are
594:32 - different okay let's see result is an
594:35 - enum to describe possible errors it has
594:38 - two variants okay and error in short
594:42 - words the expected outcome is okay while
594:45 - the unexpected outcome is error
594:48 - so let's see fill in the blanks and fix
594:51 - the errors first of all we are importing
594:53 - the pause and arrow from the num module
594:57 - because we are using here the parse
594:59 - method meaning it will in case of an
595:03 - error return the parse and error
595:07 - now we have here the function multiply
595:09 - that takes two arguments of type string
595:12 - literals okay now
595:16 - as you can see we are here returning OK
595:19 - meaning
595:21 - the return type will be of type result
595:26 - and in case of success
595:30 - or let's actually wait with annotating
595:33 - that let's first see what's happening
595:35 - here so we are taking this string
595:37 - literal and try to parse it to an i32
595:41 - right so again this parse method over
595:45 - here will return a result
595:49 - in case of success we would have
595:54 - okay
595:57 - and the value that was paused so for
596:01 - example when we call here multiply with
596:04 - an argument of 10 for the first
596:06 - parameter then we would have a parsed
596:10 - number 10 right
596:12 - so we would have in case of success and
596:16 - I 32 here
596:18 - in case of an error we would have the
596:21 - parse into error
596:24 - like that
596:28 - and parsing terror is the error type
596:31 - that is defined for this method again
596:33 - this is implemented in the standard
596:35 - Library so this has to comply with what
596:39 - is defined there and N2 is exactly the
596:44 - same
596:45 - but for the second argument
596:49 - then over here
596:52 - we unwrap
596:53 - and remember unwrap will take a result
596:57 - and just unwraps the inner value so in
597:01 - case we have okay
597:04 - let's take the first argument 10
597:09 - then unwrap we'll just unwrap the inner
597:12 - value
597:13 - meaning it Returns the integer i32 right
597:18 - that is wrapped inside the result enum
597:23 - and
597:25 - then over here we are multiplying by N2
597:28 - again we have to unwrap because this is
597:31 - a result type
597:33 - and
597:35 - if this succeeds actually then we will
597:39 - return an OK meaning
597:43 - OK will then hold
597:49 - in this case 10 times 2 will be 20 right
597:57 - like that so we return an i32 in case of
598:02 - success
598:04 - in case of error we we will return a
598:09 - pause and error because that is the
598:11 - error that is defined from the parse
598:13 - method
598:16 - so let's see when we call multiply with
598:19 - these two string literals 10 and 2 then
598:22 - this should actually work right because
598:25 - the compiler is able to parse these into
598:29 - integers
598:32 - so it will pause here and this will then
598:35 - be okay
598:38 - 10
598:39 - and over here we would have okay 2.
598:44 - then we unwrap both of these over here
598:49 - meaning we unwrapped the value from the
598:51 - variant
598:53 - and here are two meaning we multiply 10
598:56 - by 2 and then this would be 20 and we
599:00 - wrap it inside okay because we have to
599:03 - return a variant of the result enum
599:07 - which means that the return type over
599:11 - here would be
599:13 - this right
599:16 - so result in case of success will hold
599:20 - ok
599:23 - and 20. right
599:27 - now in this case this would actually
599:29 - fail because the compiler can't convert
599:33 - T to an integer
599:35 - now we want this to actually assert to 8
599:39 - so let's do here four
599:42 - and this means this will get passed to
599:45 - four
599:47 - and this will get paused to 2 right
599:51 - and then again we just multiply these
599:54 - together and return it wrapped inside
599:57 - the OK variant
600:02 - meaning over here
600:05 - we get back a result
600:08 - and result will then hold ok
600:16 - and eight
600:21 - right now if we unwrap the result over
600:25 - here then it would unwrap the inner
600:28 - value
600:32 - as you can see so unwrap method allows
600:36 - us to unwrap the inner value so
600:40 - okay 8 would be unwrapped to eight
600:48 - question mark operator is almost exactly
600:51 - equivalent to unwrap but question mark
600:53 - operator returns instead of panic on
600:57 - error
600:58 - so let's see we have again the percent
601:00 - error Implement multiply with question
601:04 - mark don't use unwrap here
601:07 - so let's see again we are taking two
601:12 - arguments of type string literal right
601:15 - three and four in this case
601:18 - and
601:20 - let's start to implement so we declare
601:23 - here N1
601:25 - and we take N1 string
601:30 - and try to parse it into an i32
601:36 - right now again we should here use the
601:39 - question mark operator so we append it
601:43 - after the method call here
601:46 - and then we can only use the question
601:50 - mark operator when the return type of
601:54 - the function is a result right because
601:57 - the question mark operator
601:59 - in case of an error will return
602:04 - the error variant and inside it the
602:08 - error value so we return error a result
602:13 - in case of success it should be i32 and
602:17 - in case of failure it should be
602:19 - dispersed in error because again this is
602:22 - defined as the error return value of the
602:26 - parse method now for N2 we do exactly
602:31 - the same
602:42 - and that means if any of these fail then
602:46 - it will immediately return meaning the
602:51 - rest of the function won't get executed
602:53 - and a pause end error will be returned
602:57 - now the question mark operator in case
603:00 - of success it won't return a result it
603:04 - will unwrap so for example when we pass
603:07 - here 3 and this will get passed it will
603:11 - return
603:12 - okay and three
603:15 - right and then the question mark
603:17 - operator like unwrap will unwrap the
603:21 - inner value
603:24 - so N1 will then hold three meaning an
603:27 - i32 integer
603:30 - and N2 the same thing
603:39 - and then all we want to do is just
603:42 - returning and OK in case of success
603:45 - because the return type is result
603:49 - and we want to multiply N1 by N2
603:55 - notice over here that I didn't have to
603:57 - unwrap because we have here I 32 types
604:02 - right
604:03 - while over here we had to unwrap because
604:06 - this held result types
604:10 - you have to remember that
604:13 - let's see
604:21 - and of course I have to change that over
604:24 - here
604:25 - typo
604:27 - and this is compiling
604:29 - so what we had over here when we provide
604:32 - Forum as a string we would have okay
604:35 - four
604:37 - right and then the question mark
604:39 - operator unwrapistic value
604:42 - and then over here we are multiplying
604:45 - three by four which would be 12.
604:49 - then we wrap it inside ok to comply with
604:53 - the function signature
604:56 - so this will then be the returned value
605:00 - right
605:01 - and then over here as you can see we are
605:03 - calling the function and unwrap it
605:06 - because we have here a result type so we
605:10 - unwrapped the inner value
605:13 - because this would return okay 12. and
605:17 - we unwrap it meaning the inner value
605:21 - gets unwrapped
605:26 - let's see over here we have the file
605:29 - type from the fs module and over here we
605:33 - are importing some stuff from the i o
605:36 - module
605:38 - so over here we are opening a file
605:42 - providing here to the open Associated
605:44 - function the name of the file in form of
605:48 - a string literal meaning this will then
605:51 - return a result
605:53 - and in case of success it will hold a
605:57 - file right
606:00 - and in case of error it would be IO
606:03 - error
606:06 - all right
606:09 - and then we are matching f
606:12 - now F holds a result meaning we must
606:16 - over here handle both cases from
606:21 - in case of success and in case of
606:24 - failure so if it is okay then we unwrap
606:27 - the inner value meaning the file and we
606:31 - just assign it to f
606:36 - in case of an error we return the error
606:40 - wrapped inside the error variant of the
606:45 - result type
606:47 - right because this function over here
606:49 - returns a result
606:54 - all right
606:55 - and then over here we are creating a new
606:58 - empty string
607:01 - we then take F over here and read to
607:05 - string meaning the contents of this file
607:09 - over here will be copied to this string
607:13 - meaning s will then hold basically the
607:16 - contents of the file we have opened
607:20 - and we have to provide here a mutable
607:23 - reference because this is defined in the
607:26 - standard Library
607:27 - and then again because this read to
607:30 - string method returns a result we have
607:34 - to match it so in case of okay then we
607:39 - will return over here
607:41 - a string right this string s over here
607:45 - in case of error we will return the
607:49 - error
607:50 - and both of them
607:54 - file open and read to string return an i
607:59 - o error all right
608:05 - now over here fill in the blanks with
608:07 - one code line don't change any code
608:10 - lines
608:11 - as you can see we have here the function
608:13 - read File 2 which returns a result in
608:18 - case of success it's a string in case of
608:21 - error it will be the i o error from this
608:24 - standard Library we here declare a new
608:27 - string
608:28 - and we here initialize a new empty
608:31 - string
608:32 - and
608:33 - I told you that the question mark
608:35 - operator replaces a whole match
608:39 - statement
608:41 - so we can write all of this in one
608:44 - single line so first of all we are
608:47 - opening the file so let's take this
608:51 - and as we've seen open will return a
608:55 - result so we can use the question mark
608:58 - operator here to replace this whole
609:01 - match statement
609:04 - so in case of error it will immediately
609:08 - return and it returns this error type
609:13 - in case of success then
609:16 - we will get OK and a string and this
609:21 - will then unwrap it to the string right
609:27 - and in case of success we will have
609:30 - a value of type file like we saw over
609:35 - here and again file is a type defined in
609:39 - FS module
609:41 - so
609:42 - we have seen that the question mark
609:44 - operator will then unwrap we will
609:47 - basically get something like that
609:51 - and it will unwrap the file inside the
609:55 - OK variant
609:57 - what we then can do is call the read to
610:00 - string method on it right
610:05 - so we are calling read to string and
610:08 - then again we have to append this
610:10 - question mark operator because we need
610:13 - to string also returns a result type
610:16 - right so in case of success we'll then
610:20 - over here mutate s meaning the contents
610:25 - of this file will get read to this
610:29 - string all right or written to the
610:32 - string
610:34 - and then we just return s right the
610:38 - string and that means in case of success
610:41 - we will have as return type a result
610:44 - that is holding a string in case this or
610:49 - this fails then it will return an i o
610:52 - error meaning if this fails then over
610:57 - here a i o error gets returned and this
611:00 - will never be executed
611:03 - and if this fails again we return this
611:07 - error and this will never get executed
611:11 - let's see
611:15 - this is compiling
611:18 - map and then map and then are two common
611:22 - combinators for result t e also for
611:26 - option t
611:28 - so we have over here the parse into
611:31 - error fill in the blank in two ways map
611:34 - and then
611:38 - so we have here the function at 2 taking
611:42 - a string literal and returning a result
611:45 - in case of success holding an i32 in
611:49 - case of error parse and error all right
611:53 - because this is the default error type
611:55 - of the parse method
611:58 - then we are taking this then we are
612:00 - taking this string literal and try to
612:03 - parse it to an i32
612:08 - and then as you can see when we provide
612:11 - here at 2 with a string holding four
612:15 - then we want to get back six
612:18 - so as you can see when we provide four
612:21 - we will get back 6 over here and that
612:24 - means we want to parse this string and
612:28 - then add 2 to the post number and for
612:33 - that we can use map which is really
612:36 - convenient
612:39 - because we not only want to handle this
612:43 - result case but also then
612:46 - modify the value right so
612:51 - n here takes a closure and we will cover
612:55 - closures very soon so we provide here an
612:59 - argument n and n would then hold the
613:03 - parsed number and all we do is adding 2
613:08 - to n
613:10 - right
613:14 - and that's all so
613:18 - let's actually see the map
613:21 - method in the documentation
613:26 - as you can see maps a result te to
613:28 - result u e by applying a function to a
613:31 - contained okay value leaving an error
613:34 - value untouched
613:36 - so
613:38 - when we call the map over here
613:41 - it will perform it will apply a function
613:46 - if
613:48 - this method returns an OK value if it
613:51 - returns an error then it will leave it
613:55 - untouched
613:57 - all right so in this case this would
613:59 - actually succeed right so pause over
614:03 - here will pause this 4 into an i32
614:07 - integer meaning it will then take the OK
614:11 - value
614:12 - and unwrap it so n will then hold A4 and
614:17 - then we just add
614:20 - and
614:21 - and then we just add 2 to 4.
614:25 - right
614:27 - let's see
614:33 - and this compiles now the second
614:35 - approach would be using and then
614:39 - now and then is very very similar to map
614:44 - the difference is here
614:46 - in the
614:48 - closure that the end then method takes
614:52 - so let's go back to map here
614:55 - so over here you can see this is the
614:58 - argument for the closure right and the
615:02 - closure over here returns
615:05 - directly the value
615:08 - all right and over here it will the
615:12 - closure itself will return a result
615:16 - now both of these methods return results
615:19 - over here
615:20 - but the difference is in the closure and
615:24 - you will see what I mean when we are
615:25 - looking at this
615:27 - so
615:28 - this is very similar
615:32 - it will take this past integer and then
615:37 - put the unwrapped value into n and then
615:40 - over here we add 2
615:43 - to 2N now we have seen that map would
615:46 - work like that
615:48 - and and then method will actually return
615:51 - in the closure itself a result so we
615:55 - have to wrap that into ok
615:58 - like that but otherwise they are exactly
616:01 - the same
616:03 - and this succeeds
616:09 - number five with the return type we
616:12 - written we can use pattern matching
616:14 - without unweb but it's all verbose
616:18 - so here again we have the multiply
616:20 - function taking two string literals in
616:23 - case of success it returns an i32
616:27 - otherwise parse and error
616:30 - so over here we are using the match
616:33 - keyword now we want to pause the first
616:36 - string literally the first argument in
616:39 - case of okay then we destructure it into
616:43 - T variable N1 so N1 will then hold the
616:47 - parsed number in case of an error we
616:51 - just return the error type
616:54 - then we match inside this
616:59 - [Music]
617:01 - match arm over here again so we match
617:05 - the second argument parsing it and if
617:09 - this is okay then we get out and two all
617:12 - right and then we can multiply N1 by N2
617:17 - and return the result wrapped in the OK
617:21 - variant
617:24 - because as you can see the function
617:26 - returns a result type
617:29 - and in case of an error it just returns
617:31 - an error
617:33 - so this would be very verbose so
617:36 - rewriting multiply to make it succinct
617:39 - you should use both and then and map
617:42 - here
617:44 - so let's see
617:45 - we take first of all the n one star over
617:50 - here the first string literal all right
617:55 - then
617:57 - we want to parse it
618:02 - to an i32 integer right
618:07 - and let's then use and then
618:13 - so if this succeeds then we will have
618:16 - here n which holds the past integer
618:21 - right and let's actually
618:24 - write it more beautiful like that so we
618:28 - take then n
618:31 - or let's call it or let's call it N1
618:34 - just to make a distinction
618:37 - and then over here we want to parse the
618:40 - second one
618:46 - right we want here the second one
618:50 - and then if this also succeeds we want
618:53 - to multiply N1 and the post and two
618:57 - together so let's use a map here
619:01 - and we would here have N2 right because
619:04 - map over here is called upon the parse
619:07 - method so we would then get back and two
619:11 - and then we just return
619:14 - N1 times N2 and notice because we are
619:19 - using map here we don't have to wrap it
619:21 - inside okay right
619:24 - so this will then return
619:26 - for example when we call it by 10 and 2
619:30 - it will return 20.
619:33 - all right
619:35 - and
619:37 - and then we have seen that it will
619:40 - return the result type so in case of
619:44 - success it it will return okay with an
619:48 - i32 value inside otherwise it will
619:52 - return a pause end error let's see
619:59 - and this is compiling so as you can see
620:02 - when we are calling the multiply
620:04 - function with
620:06 - with 10 and 2 as string literals it will
620:12 - pause the first argument meaning we then
620:15 - have over here
620:18 - okay 10. right
620:22 - and then over here we call the end then
620:25 - Method All right so we take this N1
620:30 - value here
620:31 - basically unwrapping it
620:34 - and inside and then we parse the second
620:38 - number so in this case two right so this
620:41 - will then get parsed into an i32 and we
620:46 - then can map meaning we have N2 over
620:49 - here and two in this case would be okay
620:53 - 2 right
620:55 - and map will take an unwrap the value
620:59 - inside OK meaning we then have N2
621:03 - which holds two
621:06 - over here and then we multiply N1 by N2
621:10 - and return it all right
621:16 - and all we then do is here The Returned
621:20 - value would be of this type right
621:28 - and in this case this would return
621:33 - okay 20.
621:36 - right because it could parse these two
621:39 - numbers and it multiplied it and
621:42 - returned it so we get okay 20 then we
621:46 - pass that to the print function
621:49 - as you can see it takes as an argument a
621:52 - result type then we match it if it is
621:56 - okay then we print out the
621:58 - value wrapped inside okay in this case
622:01 - 20 otherwise we will print out the error
622:07 - and when we call multiply with an
622:09 - argument that can't be paused
622:13 - then you would get a pause int error
622:16 - right so this would then hold a percent
622:19 - error we are providing that 2D print
622:23 - function and then we match the argument
622:26 - this TT and this will then match the
622:29 - error meaning the error will get printed
622:33 - so in the first one so in the first
622:36 - print call n is 20 so we have
622:40 - successfully paused these two numbers
622:42 - and unwrapped the value printing it and
622:47 - in the second one because we provide
622:49 - here an argument that can't be paused we
622:52 - get
622:53 - and pause into arrow and this would be
622:57 - the error message that is provided in
623:00 - this standard Library
623:03 - so type Alias using this type over here
623:07 - everywhere is verbose and tedious we can
623:10 - use Alias for this purpose so at a
623:14 - module level creating aliases can be
623:17 - particularly helpful errors found in a
623:20 - specific module often has the same error
623:23 - type so a single Alias can succinctly
623:26 - Define all Associated results this is so
623:31 - useful even the standard Library even
623:33 - supplies one IO result
623:37 - so as you can see we have here again the
623:40 - pulse and error and we want here to
623:43 - create a type alias
623:46 - now we have here the same multiply
623:50 - function we have seen above so I won't
623:52 - cover that anymore but the return type
623:56 - is defined as res i32
624:01 - and the print function over here takes
624:03 - as an argument a type of rice i32
624:08 - now as you can see exactly the same
624:11 - functions as we had over here
624:14 - but we don't write out the whole type we
624:18 - use here A type Alias so we can Define
624:21 - that here
624:24 - we use res
624:26 - i32 and we want to Define that as a
624:30 - result
624:32 - in case of success holding an I30 tool
624:35 - in case of an error
624:38 - as you can see the parse method would
624:40 - return a parse and error
624:44 - and then instead of writing that all the
624:47 - time in our functions we can use this
624:50 - simple type alias
624:53 - and of course at compile time
624:56 - these type aliases will then get
624:58 - replaced with this
625:01 - concrete type here
625:04 - let's see
625:10 - and as you can see the same output as
625:12 - before
625:13 - using result in F and Main typically the
625:16 - main function will look like this
625:19 - however main is also able to have a
625:22 - return type of result if an error occurs
625:26 - within the main function it will return
625:28 - an error code and print a debug
625:31 - representation of the error debug trade
625:34 - the following example shows such a
625:37 - scenario
625:39 - so as you can see we have here again the
625:41 - percent error and we Define here in the
625:44 - main function that the return type
625:46 - should be of type result in success
625:50 - returning a unit type in case of error
625:54 - it will return a parse and error so over
625:57 - here we have a string literal
626:01 - and we are then trying to parse this
626:05 - string literal to an i32 now again pulse
626:11 - returns a result so we have to handle
626:13 - both cases in case of ok we just take
626:17 - the wrapped value and assign it to
626:21 - number right in this case this would
626:23 - hold an i32
626:26 - in case of an error it will just return
626:29 - the error and it will stop execution
626:32 - from this point
626:36 - and then all we do is we will print out
626:39 - the number so let's see if this is
626:41 - compiling
626:44 - as you can see this is compiling we are
626:46 - printing out the number and don't forget
626:49 - because we return a result type here we
626:53 - have to return
626:56 - the result variant okay with a unit type
627:00 - in case of success we provide here a
627:04 - unit type to the OK variant because
627:08 - the end of main means the end of the
627:11 - program because the end of main means
627:14 - the end of the program so we don't have
627:16 - to actually return anything here right
627:19 - because if the program ends this
627:22 - returned value won't be beneficial but
627:26 - we can just provide the unit type so we
627:30 - comply with the function signature
627:33 - and by the way as we've seen we can here
627:38 - just use the
627:41 - question mark operator so we can replace
627:43 - this match statement by this
627:47 - and this is actually the reason most
627:50 - people use here in main the result type
627:54 - because then it allows us that we use
627:57 - the question mark operator otherwise if
628:00 - we didn't have result here we can't use
628:03 - this operator
628:06 - let's see
628:11 - of course I have to remove the match
628:14 - keyword here
628:17 - and as you can see this would be the
628:19 - same thing
628:21 - all right see you in the next topic
628:23 - let's take a look at cargo now cargo is
628:27 - the official package manager and
628:29 - building tool in Rust it helps automate
628:33 - tasks such as creating new projects
628:35 - building running testing code and
628:38 - managing dependencies a crate is a
628:42 - compilation unit of rust source code so
628:46 - basically a crate is the smallest amount
628:49 - of code the RAS compilers considers at a
628:53 - time and crates.io is the repository for
628:57 - rust packages
629:14 - so as you can see this is the website of
629:17 - crates.io and here you find
629:22 - some libraries for example we have here
629:24 - the rent Library
629:27 - and this allows for creating random
629:31 - numbers
629:35 - and as you can see you can add this very
629:39 - quickly into your own project and we'll
629:42 - see how this will work
629:45 - what is a crate a crate can be of two
629:48 - types either it's a binary crate and
629:51 - that means the program is compiled into
629:54 - an executable binary it's basically a
629:57 - program you can run and binary crates
630:01 - always have the main function in it
630:04 - and a library create a library create is
630:07 - compiled into a library and it doesn't
630:10 - contain a main function but it's
630:14 - considered a collection of reusable code
630:17 - that can be shared across multiple
630:20 - projects
630:22 - and the create route is the source file
630:25 - that is the root module of the crate in
630:29 - binaries it would be source main.rs and
630:33 - in libraries it would be the file lib
630:36 - dot RS
630:40 - then we have modules and a module is a
630:44 - way of organizing code by grouping
630:46 - together related items modules can be
630:50 - imported using namespaces avoiding
630:54 - naming collisions
630:56 - it also controls the privacy of its
630:59 - items like functions trucks enums and so
631:02 - on when compiling the compiler starts
631:05 - from the create route we have seen in a
631:08 - binary crate this would be in main.rs
631:12 - and in a library it would be lib.rs
631:17 - then it checks if the modules are
631:19 - declared and looks for sub modules
631:23 - sub modules could be directly written in
631:26 - line with curly braces it could be
631:29 - written in a separate file which has the
631:33 - module name ending in dot RS or it could
631:37 - be in a separate director which has the
631:40 - same name of the module and a mod.rs
631:44 - file inside it and we'll do exercises
631:47 - and you will see how that works so in
631:50 - case you want to follow these exercises
631:53 - you actually have to install rust on
631:56 - your system so you can go to
631:58 - rosslang.org
632:00 - and then you can click install
632:05 - and over here it will give you a command
632:08 - you can copy
632:11 - then running a terminal
632:17 - and you can just copy
632:20 - this into your terminal now I'm on a
632:24 - Unix like operating system meaning
632:27 - I will use the Linux command but the
632:32 - website will recognize your operating
632:35 - system and provide the appropriate
632:37 - command so if you're on Windows it will
632:40 - give you a command that you can paste
632:44 - into Powershell for example
632:47 - so proceed with installation default you
632:50 - can then press 1 and enter now I have
632:54 - already
632:55 - downloaded that so I want
632:59 - um run it again
633:01 - and then to check if everything is
633:04 - installed correctly you can use these
633:06 - commands
633:10 - first of all we check is the RAS
633:13 - compiler installed if you get back a
633:15 - version it means everything is installed
633:18 - then we check for cargo
633:21 - [Applause]
633:23 - this is fine and rust up
633:29 - and rust up is used for
633:32 - um updating the version of rust on your
633:36 - local system
633:40 - all right
633:43 - all right so let's now see the exercises
633:46 - a package is a project which you create
633:49 - with Cargo in most cases so it contains
633:51 - a cargo.tomel file in it
633:55 - so create a package with below layout
634:00 - now I will do that directly in the home
634:02 - directory but you can do it at any
634:04 - location you want
634:06 - so
634:07 - to create a new package we can use cargo
634:13 - new
634:14 - and then provide the name of the package
634:17 - so we want the name here to be hello
634:19 - package
634:27 - and as you can see that we
634:33 - and as you can see the package has been
634:35 - created so let's C CD hello package and
634:42 - we are now inside our created package
634:46 - right so we have here cargo Tamil and a
634:49 - source directory let's see source
634:55 - and if I print out the contents in main
634:58 - as you can see it contains a simple
635:02 - program
635:03 - that prints out hello world
635:06 - so
635:12 - let me actually
635:14 - do it like that
635:16 - so over here if I now do A3 command
635:22 - as you can see we have exactly the same
635:24 - file structure here we have a cargo
635:27 - Tamil and then resource directory with
635:31 - main.rs inside
635:33 - let's print out the cargo toner
635:39 - and as you can see this matches the file
635:42 - in the exercise
635:46 - create a package with below layout
635:51 - so over here we want to create a library
635:56 - so I'm back in my home directory and we
635:59 - can create the library create right now
636:03 - let's do Park on you then the package
636:05 - name here
636:09 - and then we have to write the lib flag
636:12 - right so this will then create a library
636:18 - and then let's CD into that
636:26 - as you can see we have corgotomel and a
636:29 - source directory
636:30 - now
636:32 - let me print out the cargo thermal file
636:39 - and as you can see again this matches
636:42 - and if we go to the source directory
636:47 - as you can see over here we have a
636:51 - lib.rs file and this just has a basic
636:55 - add function over here together with
636:58 - some tests
637:01 - all right
637:06 - fill in the blank with your answer
637:08 - what's the difference between package
637:10 - number one and package number two
637:14 - now the difference would be package
637:16 - number one is a binary crate
637:24 - and package number two is a library
637:27 - crate
637:34 - all right
637:39 - create a crate is a binary or library to
637:43 - create rules
637:45 - the create route is a source file that
637:47 - the rascompiler starts from and makes up
637:51 - the root module of the crate
637:53 - in package hello package there is a
637:56 - binary create with the same name as the
637:58 - package hello packet and source main.rs
638:03 - is the create root of this binary crate
638:08 - similar to hello package hello package
638:10 - one also has a crate in it however this
638:13 - package doesn't contain a binary crate
638:16 - but a library crate and source lib.rs is
638:21 - the great root
638:24 - so what's the name of the library crate
638:27 - in package hello package one the answer
638:31 - would be it would be hello package one
638:34 - right because as we've seen over here in
638:38 - the package hello package there is a
638:41 - binary crate called hello packet
638:45 - and that means in a package hello
638:47 - package one
638:48 - the name of the library crate would be
638:52 - hello package one and by the way a
638:55 - package is what we have seen over here
638:59 - basically
639:01 - when we create a new project right when
639:05 - we create a new project we create a new
639:08 - package and the package consists of a
639:11 - cargo.tomel file and a source directory
639:14 - together with other stuff
639:21 - add a library create for hello package
639:24 - and describe its files 3 below
639:29 - alright so we want to add in the hello
639:32 - package
639:34 - a library crate
639:41 - so let me remove this over here
639:45 - and we will go inside hello package
639:49 - now over here in this Source directory
639:54 - we want to create a new library create
639:56 - as you can see we have until now a
639:59 - binary crate so let's create
640:03 - a lib dot RS touch is a Linux command
640:07 - that allows to create a new file
640:10 - so then we would have lib RS and Main RS
640:16 - so when we look at T3
640:20 - as you can see we then have the cargo
640:22 - terminal The Source directory and two
640:25 - crates one Library crate and one binary
640:28 - crate
640:31 - so this will then hold lip.rs
640:34 - and main.rs
640:40 - after this step there should be two
640:43 - crates in package hello package a binary
640:46 - crate and a library crate both with the
640:49 - same name as the package
640:52 - a package can contain at most one
640:56 - Library crate but it can contain as many
640:59 - binary crates as you would like by
641:01 - placing files in Source bin directory
641:05 - each file will be a separate binary
641:08 - crate with the same name as the file so
641:11 - create a package which contains three
641:14 - binary crates hello package main one
641:17 - main two one Library create
641:21 - so what we want over here is to have in
641:23 - this Source folder the lib.rs
641:28 - and main.rs
641:31 - then inside the source folder we want to
641:35 - have a bin directory which holds main 1
641:40 - and Main two
641:46 - right
641:47 - so
641:53 - so as we've seen we can have as many
641:55 - binary crates as we want in a package
641:58 - but only one Library create
642:02 - and over here we have some other
642:04 - directories so we have tests for
642:07 - integrated tests benches for Benchmark
642:10 - and examples
642:13 - so let's create these over here
642:23 - so as you can see inside source we
642:25 - already have a library crate and a
642:27 - binary crate now we want to create a new
642:30 - directory
642:32 - called bin
642:36 - then we see the into bin and we create
642:41 - main1.rs and main2.rs
642:46 - so again when we go to the
642:49 - root of the package as you can see we
642:52 - have cargo terminal The Source directory
642:55 - we have inside the source directory a
642:58 - bin directory holding two binary crates
643:01 - main one main two and we have in the
643:04 - source directory
643:06 - lib.rs and main.rs
643:12 - yep as you can see the above package
643:15 - structure is very standard and is widely
643:18 - used in many rust projects
643:21 - so let's see modules modules let us
643:24 - organize the code within a crate into
643:26 - groups for readability and ease of reuse
643:30 - module also controls the privacy of
643:33 - items which is which is whether an item
643:37 - can be seen by outside code public or
643:41 - it's just an internal implementation and
643:44 - not available for outside code private
643:48 - we have created a package named hello
643:51 - package in previous chapter and it looks
643:54 - like this now we actually created over
643:57 - here a bin directory so let's delete
644:00 - that
644:04 - I go into source and then remove the bin
644:07 - directory
644:13 - so as you can see T3 looks exactly the
644:16 - same
644:19 - now it's time to create some modules in
644:21 - the library create and use them in the
644:24 - binary crate let's start
644:27 - so as you can see we can
644:31 - Define some code in the library create
644:34 - and then use it in the binary crate
644:38 - so Implement module front of house based
644:41 - on the module tree below
644:44 - so in the library create we want to
644:47 - create a module front of house
644:49 - and this should then hold two sub
644:53 - modules hosting and serving now hosting
644:57 - holds two functions and serving holes
645:00 - for functions
645:03 - so as you can see
645:06 - we will do that in the library crate all
645:09 - right
645:10 - and again modules allow us to structure
645:13 - our code
645:17 - so
645:20 - [Applause]
645:23 - let's open lib.rs and I will copy this
645:27 - over here so we have to implement front
645:30 - of house
645:32 - now we have seen that front of house
645:34 - module should contain two sub modules
645:38 - namely hosting and serving
645:52 - like that so we have a front of house
645:56 - module that contains two sub modules
645:59 - hosting and serving
646:02 - now we want to add these functions over
646:05 - here add to wait list and see it at
646:08 - table in the hosting module
646:15 - uh
646:18 - at waste list
646:21 - adds to wait list
646:27 - and
646:28 - see it at table
646:34 - so as you can see front of house
646:36 - containing one sub module hosting
646:38 - holding two functions over here
646:42 - now let's see serving
646:46 - I will just copy that
647:08 - like that and
647:19 - doing it like that as you can see it is
647:22 - serving module holds three functions
647:33 - and when we run the code actually
647:39 - we can use the cargo run command
647:43 - and as you can see this is compiling but
647:45 - it gives us warning that we didn't use
647:49 - these functions over here which is okay
647:53 - and of course hello world will get
647:55 - printed from the binary crate
648:00 - right because main just prints out hello
648:04 - world
648:08 - let's call add to waitlist from a
648:10 - function eat at restaurant which is
648:13 - within the library create route
648:15 - so inside lib.rs
648:18 - we are below
648:21 - the module front of house we are
648:24 - creating a new function
648:36 - like that call add to wait list with
648:40 - absolute path
648:42 - so it's like in a file system you can
648:44 - have absolute paths and you can have
648:46 - relative paths so in this case we want
648:50 - to use the absolute path to the add to
648:54 - wait list
648:55 - function over here
648:57 - so we would use for the absolute path to
649:01 - create root
649:02 - then we want the front of house module
649:07 - and we want the sub module hosting right
649:14 - and then over here we can call the
649:17 - function like that add to wait list now
649:21 - this would be considered the absolute
649:24 - path
649:26 - now over here we are using the relative
649:29 - path so we are actually already in the
649:32 - create route right so that means we
649:35 - don't need to use crate here we can
649:37 - directly access front of house
649:46 - hosting
649:49 - and then call the add to wait list
649:53 - function
649:57 - now as you can see it gives me here an
650:00 - error
650:01 - module hosting is private so we can make
650:06 - this public using the pub keyword all
650:09 - right
650:11 - now the same thing with the functions
650:13 - let's make them public
650:16 - like that
650:21 - you can use super to import items within
650:24 - the parent module
650:26 - so
650:28 - again in lib.rs we want to create
650:31 - another module so let's copy that
650:38 - put it below the front of house
650:42 - and as you can see over here we have the
650:44 - back of house module with two functions
650:48 - declared inside it
650:51 - so we have fixed incorrect order and
650:55 - inside this function we call the cook
650:57 - order function over here
651:00 - fill in the blank in three ways using
651:03 - keyword super using absolute path
651:14 - so in order to access the function over
651:17 - here serve order let's first use this
651:21 - super keyword so super means we go one
651:25 - level up right so we are here inside the
651:29 - module back of house we go one level up
651:32 - which would be the create route right
651:35 - lib dot RS so we use super
651:40 - and then we can access front of house
651:45 - and I guess hosting
651:47 - no serving and serve order
651:59 - like that and again serving is private
652:02 - let's do that
652:03 - let's make it a public function
652:10 - and again serving here is private so
652:13 - let's make that public
652:15 - and also the function here
652:19 - like that
652:21 - and the second way would be using
652:24 - absolute path so again you can use here
652:26 - create right create would refer to
652:31 - lib.rs because it is the great root of
652:35 - this package
652:40 - separating modules into different files
652:45 - so
652:47 - as you can see we want to put these
652:52 - modules into their own distinct files
652:56 - please separate the modules and codes
652:58 - above into files resident in below third
653:02 - three
653:03 - so as you can see we have here Main and
653:06 - leap RS crates and here we have the
653:11 - modules we want to split up so we have
653:14 - the module front of house
653:17 - holding hosting and serving this r sub
653:21 - modules and mod.rs and we have over here
653:26 - back of house.rs now we have said that
653:30 - there are three ways to declare modules
653:34 - right the first way would be in the
653:37 - create route for example lib.rs we
653:41 - Define
653:43 - in module and put it right inside the
653:48 - curly braces right all the code is
653:51 - inside these curly braces right the
653:55 - second way would be
653:57 - two
654:00 - in lib.rs
654:02 - declaring the back of house module but
654:06 - without curly braces right only
654:09 - declaring like this for example
654:18 - only declaring the module
654:21 - and that means the compiler will then
654:23 - check
654:24 - is there in Source directory a file
654:29 - named as the same name as we gave it to
654:33 - the module right so we declared a module
654:37 - in lib.rs and then we have to create a
654:40 - file ending in dot RS with the same name
654:44 - as the module we have declared
654:48 - and the Third Way would be if we want
654:51 - the module to be a subdirectory of
654:56 - source then we have to again declare
654:59 - front of house inside lib.rs the same
655:03 - way we did before
655:05 - but we create a directory instead of a
655:09 - file with the same name as the module
655:14 - and then very important
655:16 - the code of the module will then be in
655:20 - mod.rs now in our case we are declaring
655:24 - in
655:25 - mod.rs2 sub modules hosting and serving
655:30 - all right
655:33 - so we want to have this code separated
655:36 - in different files and this is how it
655:39 - should look like
655:41 - so let's start
655:45 - with back of house
655:48 - all right
655:49 - I will copy that
655:54 - and first of all
655:59 - I will delete anything in here
656:04 - and let's declare the module back of
656:09 - house
656:10 - right
656:12 - now we have here declared a module as
656:15 - you can see the file is not found so we
656:18 - can here declare
656:20 - and
656:22 - back of house
656:26 - dot RS
656:28 - and then we can put
656:41 - and then we can put the code of the back
656:45 - of house module directly into this pack
656:48 - of house file removing this over here
656:51 - because we have already declared
656:54 - T module and as you can see back of
656:58 - house file now contains
657:01 - only the code related to this module
657:05 - again we have in lib.rs
657:09 - declared the back of house module then
657:13 - we have over here created a file that
657:18 - has the same name as
657:21 - the module right and in here we are
657:25 - providing the code
657:29 - like that
657:31 - and because we have already declared the
657:34 - back of house module we don't have to
657:36 - redeclare it inside here right
657:41 - now as you can see we also want front of
657:46 - house now the difference is front of
657:48 - house should be a directory holding two
657:52 - sub modules
657:54 - so let's first of all
657:56 - in lib
657:58 - we want to declare front of house module
658:04 - like that
658:08 - then we create the directory with the
658:12 - same name as the module
658:16 - foreign
658:19 - like that
658:23 - then the first thing is we create a file
658:27 - mod.rs this is now
658:30 - the create root of this this will be
658:34 - considered the root of this module
658:37 - mod.rs
658:41 - and as you can see we want here inside
658:45 - front of house two sub modules hosting
658:49 - and serving let's declare them
658:57 - like that
658:59 - and then we can create both of these
659:03 - files let's start with hosting
659:09 - and we just take all the code from the
659:13 - hosting module here
659:22 - like that and let's create serving
659:30 - and we just take the code here from this
659:34 - serving module
659:38 - like that
659:40 - let me remove the comment
659:46 - so
659:50 - and now if we go back
659:53 - to the source directory
659:59 - as you can see we have back of house
660:01 - this is a module we have front of house
660:04 - hosting and serving these are two sub
660:09 - modules and we have here
660:12 - mod.rs exactly like we wanted here now
660:17 - over here by the way
660:19 - this function eat at restaurant will be
660:21 - directly in the lib.rs
660:36 - so as you can see instead of defining
660:40 - the module and putting all the code in
660:43 - curly braces meaning inline
660:46 - we can use
660:50 - um different files to restructure and
660:53 - reorganize our code and this makes the
660:57 - lib.rs file much more clean and readable
661:06 - assessing code in library create from
661:09 - binary crate please ensure you have
661:11 - completed the fourth exercise before
661:13 - making further progress you should have
661:16 - below structures and the corresponding
661:19 - codes in them when reaching here
661:22 - so we have done that
661:25 - now we will call a few Library function
661:28 - now we will call a few Library functions
661:31 - from the binary crate
661:34 - so let's copy that into the binary crate
661:54 - like that now we want to call a function
661:59 - so the output should be sit down please
662:02 - and then a second function which returns
662:05 - yummy yummy now
662:08 - as you can see over here
662:11 - we have to call the eat at restaurant
662:14 - function
662:16 - to get back yummy yummy and sit down
662:20 - please would be in the front of house
662:22 - module in hosting and seat at table
662:27 - function so let's see first of all I
662:31 - want here the module front of house
662:37 - right because the binary crate and the
662:40 - library create are separate from each
662:42 - other so the binary crate over here
662:44 - can't know what is defined in the
662:48 - library crate
662:50 - and then over here we can SD create
662:54 - module
662:55 - and then here we can use an absolute
662:59 - path providing the create route now we
663:02 - have to actually provide here
663:04 - the name of the crate meaning hello
663:09 - package all right
663:11 - and then we can call font of house
663:16 - and
663:18 - let's see
663:20 - front of house hosting seat at the table
663:28 - at table
663:31 - like that
663:38 - and then over here we call hello package
663:42 - and then eat at restaurant
663:46 - this is defined in our
663:50 - lib.rs so again instead of writing here
663:54 - a crate
663:57 - we write the name of the package because
664:00 - we are here in the binary crate so we
664:03 - can use the create keyword in lib.rs but
664:07 - in main.rs we have to write the name of
664:11 - the package
664:13 - let's run that
664:18 - and as you can see we have some errors
664:21 - module serving is private
664:24 - and module hosting is private
664:29 - so to actually access that
664:33 - from the binary crate we have to make
664:35 - them public
664:37 - so let's see
664:43 - first of all we go to lib.rs and we want
664:46 - these two modules to be public so let's
664:50 - make them pop like this which means that
664:54 - these two modules are now accessible for
664:57 - our binary crates the main.rs file then
665:01 - let's go to
665:03 - um front of house
665:08 - and let's here make these two modules or
665:11 - these two sub modules also public
665:17 - like that
665:18 - and
665:23 - if the module itself is public that
665:28 - doesn't mean that the inner functions
665:30 - for example or structs or anything that
665:33 - is inside the module is also public so
665:35 - we have to declare here as you can see
665:38 - this is already done that these
665:40 - functions are also public if we want to
665:43 - access it
665:48 - and as you can see serving also has the
665:51 - public functions
665:53 - now let's check again in lib.rs because
665:56 - we are calling here a function all right
665:59 - this is also public
666:02 - let's run it again
666:07 - and as you can see this is actually
666:09 - compiling it just over here
666:12 - and complaints that we didn't use some
666:15 - of the functions which is okay at the
666:18 - moment
666:21 - now instead of just assorting let's
666:23 - actually print that out
666:36 - and let's do it like that
667:06 - as you can see the output will be sit
667:08 - down please
667:12 - let's call the second one
667:20 - so we want to get this
667:28 - like that
667:34 - let's see
667:41 - all right
667:48 - I copied here the holy uh
667:52 - I copied here the whole assert
667:55 - we don't need this actually let's see
668:01 - and as you can see the output will be
668:03 - sit down please and yummy yummy
668:08 - so we have successfully restructured and
668:11 - reorganized our whole code into
668:14 - different files and folders meaning it
668:17 - is much more organized and much more
668:21 - readable
668:25 - all right see you in the next topic
668:28 - we will now take a look at the debug and
668:31 - display trades so types which want to be
668:34 - printable must Implement either debug or
668:38 - the display trades
668:40 - and automatic implementations are only
668:44 - provided for types in this standard
668:47 - Library so this doesn't apply to our
668:50 - customly created types
668:52 - a debug trade can be implemented by
668:55 - simply using derivable trade
668:58 - and a display trade must be manually
669:01 - implemented
669:04 - let's see
669:05 - we have here print Ln and format
669:08 - printing is handled by a series of
669:11 - macros defined in standard format some
669:15 - of which include format write formatted
669:18 - text to string
669:20 - print same as format but the text is
669:24 - printed to the console print Ln is the
669:27 - same as print but a new line is appended
669:31 - ePrint is the same as format but the
669:34 - text is printed to the standard error
669:38 - and e-print Ln same as e-print but a new
669:42 - line is a pendant
669:44 - all parse text in the same fashion
669:48 - all porous text in the same fashion as a
669:51 - plus rust checks format correctness at
669:54 - compile time
669:56 - so let's see we have here a string
669:58 - literal
670:00 - and we use here the format macro meaning
670:04 - the return type will be string
670:08 - and we want here s to hold a string of
670:12 - hello world
670:14 - so again we use the format macro like we
670:17 - would use the print L and macro we have
670:19 - been using so in this case we want to
670:22 - take S1 over here
670:26 - and then just append the rest
670:30 - so we take hello this will be placed
670:32 - here and then the rest
670:41 - and this is compiling
670:43 - let's actually print that out
670:53 - as you can see this would be the output
670:56 - when printing out s
671:00 - print print Ln fill in the blanks to
671:03 - make it print a hello world I am and
671:06 - turn on the new line Sun face
671:09 - so over here we want to use print
671:12 - because as you can see I am should be on
671:16 - the same line
671:18 - so as we've seen print macro doesn't
671:21 - append a new line character
671:24 - now a new line is defined in C
671:28 - like that all right and this is a symbol
671:33 - that the compiler knows that it should
671:36 - treat it as a new line but in this case
671:40 - print doesn't append it so the next line
671:43 - will be on the same line as this print
671:47 - statement
671:50 - so let's use here print Ln
671:53 - because as you can see after I am we
671:56 - want to have a new line
671:59 - and then over here we can again use
672:01 - print Ln
672:11 - and this would be the output
672:18 - debug and display so all types which
672:21 - want to be printable must implement the
672:24 - standard format formatting trade debug
672:28 - or display
672:29 - automatic implementations are only
672:32 - provided for types such as in this
672:35 - standard Library all others have to be
672:38 - manually implemented
672:40 - let's first look at debug
672:44 - the implementation of debug is very
672:47 - straightforward all types can derive the
672:50 - debug implementation this is not true
672:53 - for display which must be manually
672:55 - implemented
672:57 - and we have used that before this is the
673:00 - debug notation must be used to print out
673:03 - the type which has implemented the debug
673:06 - trade
673:08 - so as you can see over here we have a
673:11 - custom type
673:13 - this structure cannot be printed either
673:16 - with display or debug to make this
673:20 - struct printable with debug we can
673:23 - derive the automatic implementations
673:25 - provided by rust
673:28 - so again we can use a derivable trait
673:31 - meaning this struct over here implements
673:35 - the debug trade meaning we can print it
673:38 - out using debug notation
673:43 - so fill in the blanks and fix the errors
673:46 - as you can see we have here a custom
673:48 - type structure holding an i32 value
673:52 - types in standard and rust have
673:55 - implemented the debug trade
673:58 - so as you can see this is of type i32
674:02 - now all of the types in the standard
674:04 - Library have implemented debug or even
674:08 - display so we can use here
674:11 - to display notation
674:13 - and this will print out fine now over
674:16 - here we must use debug notation
674:21 - because this is a type that we have
674:24 - created and again to use the debug
674:27 - notation we have to derive the debug
674:30 - trade
674:38 - like that
674:40 - and that means structure implements the
674:43 - debug trait and we can then print it out
674:46 - so this i32 type will be printed
674:49 - automatically because it's a type
674:52 - defined in this standard library and
674:54 - over here we just had to derived debug
674:58 - trade and then use debug notation here
675:03 - so format debug definitely makes one
675:06 - type printable but sacrifices some
675:08 - Elegance
675:10 - maybe we can get more elegant by
675:13 - replacing this notation with something
675:16 - else but not this
675:20 - alright let's see we have here
675:23 - a custom type that derives the debug
675:26 - trade
675:28 - then we are here instantiating it
675:32 - and when we now execute the program
675:37 - as you can see the output will be like
675:40 - this now we want the output to look
675:42 - something like that and we can for that
675:45 - use the pretty notation
675:47 - just adding this hashtag symbol between
675:50 - the colon and the question mark
675:55 - and then the output should look much
675:58 - more pretty
676:00 - as you can see the output will then be
676:03 - like this
676:04 - and notice we first had to derive the
676:08 - debug trade in order to print it out
676:11 - using debug notation
676:15 - we can also manually Implement debug
676:18 - trade for our types
676:21 - so as you can see we have here two
676:23 - custom types structure and deep
676:26 - now structure holds a type of i32 and
676:30 - depos a type of structure meaning
676:35 - these are basically nested so we have
676:38 - keep
676:40 - which holds a structure
676:44 - which holds an i32 right
676:48 - the problem with derive is there is no
676:51 - control over how the results look what
676:55 - if I want
676:56 - what if I want this to just show A7
677:00 - so as you can see we are here
677:03 - instantiating it with a value of 7. now
677:07 - when we print it like that then as you
677:10 - can see the whole structure will get
677:12 - printed out but we only want tip value
677:15 - over here
677:16 - so what we can do is we implement the
677:19 - debug trade manually meaning we can
677:23 - manipulate the output
677:25 - so let's see the debug trade in the
677:28 - documentation and as you can see this is
677:31 - the debug trade as defined in this
677:34 - standard Library so let's copy this
677:37 - function signature
677:40 - so we can then over here implement the
677:43 - debug trade
677:47 - and this is found in a module M and this
677:51 - is inside the module fmt from the
677:54 - standard library and we want to
677:56 - implement it for the Deep over here now
678:01 - we remove that
678:04 - and we also remove that because we are
678:06 - implementing debug trade manually right
678:09 - we don't need the derived implementation
678:14 - so let's see deep
678:17 - then I will copy the
678:19 - function signature
678:22 - so here we can use a custom type fmt
678:25 - result
678:32 - and you know what we can use a namespace
678:34 - here
678:37 - so then we don't have to write here
678:39 - standard all the time
678:42 - like that I can delete this lifetime
678:47 - and now we can implement the debug trade
678:51 - namely this fmt method
678:55 - so again we want to write to a buffer so
678:58 - we will still write macro
679:02 - and it should write to this formatter
679:05 - which is provided by the debug trade
679:11 - and then over here all we want to
679:14 - actually print out is
679:17 - in this case self right the instance
679:21 - over here
679:23 - and then we access the first element so
679:27 - when we access the first element in a
679:31 - tuple we use the dot notation like that
679:34 - and inside here we have now accessed
679:38 - structure and we want to access
679:41 - this value this structure
679:44 - struct holes right so we again use zero
679:49 - and that's basically it now it should
679:52 - print out
679:57 - and of course over here
679:59 - fmt formatter this is also from the fmt
680:03 - module and as you can see now 7 will
680:07 - print
680:08 - so all we did over here is manipulating
680:11 - how the output of the debug trade looks
680:15 - like when we use debug notation
680:18 - and as you can see we have defined for
680:20 - the Deep custom type over here how the
680:24 - output should look like so the output
680:27 - will just be the inner element of deep
680:31 - and structure right this i32
680:35 - and we just access that and write it to
680:39 - this buffer
680:41 - all right
680:44 - display here debug is simple and easy to
680:47 - use but sometimes but sometimes we want
680:50 - to customize the output appearance of
680:53 - our type this is where display really
680:56 - shines unlike debug there is no way to
680:59 - derive the implementation of the display
681:02 - trade we have to manually implement it
681:05 - another thing to note the placeholder
681:09 - for display is this and not that so this
681:13 - would be for debug trade for display we
681:17 - are using that and you know that already
681:20 - so make it work as you can see again we
681:23 - are using the fmt module and we have a
681:27 - custom type 0.2d holding two fields of
681:31 - type f64.
681:33 - now we want to implement the display and
681:37 - the debug trade for this custom type
681:40 - meaning when we instantiate this point
681:43 - 2D
681:47 - then we can pass the instance over here
681:50 - and it will
681:53 - give us this output right so we are
681:56 - using here the display notation and
681:59 - debug notation
682:01 - and as you can see we can here Define
682:03 - different outputs
682:05 - so when we pass an instance of point
682:09 - then the display trade actually will
682:12 - output something like that
682:14 - if we use debug notation then we want
682:17 - the output to look something like that
682:19 - and that's what I mean when I say we can
682:22 - manipulate how the output of a custom
682:25 - type will look like
682:28 - so
682:29 - I will
682:31 - take over here this
682:33 - method
682:36 - and I will just copy it over here
682:41 - now let's first implement the display
682:44 - trait as you can see we want the output
682:47 - to look something like that so we Define
682:50 - here
682:51 - lay
682:54 - the X field the value of x field and
682:59 - then plus the value of the by field and
683:03 - we have here an i okay
683:07 - like that
683:08 - and we can access these fields using
683:12 - normal notation self
683:15 - dot X and cell dot y
683:19 - right
683:21 - and for debug notation we want the
683:24 - output to look something like that so
683:26 - let's copy this
683:29 - put it inside here
683:31 - and as you can see we want here
683:34 - the value of the X field and here the
683:38 - value of the Y field
683:49 - and as you can see we are here using
683:52 - curly braces and this is usually for the
683:56 - placeholder so what we have to do here
683:58 - is using two of them meaning this
684:02 - calibrases over here will basically be
684:05 - escaped all right
684:08 - and then over here we have to provide
684:10 - the arguments self.x and self dot y
684:15 - let's see
684:19 - and this is compiling now let's see the
684:21 - actual output
684:32 - [Applause]
684:37 - as you can see I'm using display
684:39 - notation and debug notation and just
684:42 - provided an instance of the point to the
684:45 - type
684:50 - and as you can see this will then be the
684:53 - output
684:56 - so question mark operator implementing
684:59 - fmt display for a structural whose
685:01 - elements must be handled separately is
685:04 - tricky the problem is each right
685:07 - generates a fmt result which must be
685:11 - handled in the same place
685:14 - fortunately Russ provides the question
685:16 - mark operator to help us eliminate some
685:19 - unnecessary codes for dealing with fmt
685:23 - result
685:25 - so
685:28 - let's see again we are using the fmt
685:31 - module and we have here a custom type a
685:35 - struct list
685:37 - a tuple struck list holding a vector of
685:41 - i32 elements right over here we are
685:45 - instantiating this list with a vector
685:48 - holding one two three
685:50 - now as you can see when we put this
685:55 - list over here into the format macro
685:59 - then we want the output to look
686:01 - something like that so we want to print
686:03 - these square brackets the index colon
686:08 - and then the actual value
686:11 - now let's see how this would be
686:14 - implemented notice over here we are
686:17 - implementing the display trade so we can
686:19 - then use it to display the type directly
686:25 - so as you can see this is the function
686:27 - signature from the fmt module
686:33 - and
686:35 - as you can see over here we return a
686:39 - type of fmt result now this is a third
686:42 - now this would be a type Alias and we
686:46 - have covered that
686:49 - now over here
686:51 - we want to extract the value using Tuple
686:55 - indexing and creating a reference to
686:58 - back
686:59 - so the first thing we do is we want to
687:02 - access the vector in the list struct and
687:08 - we do that using Tuple indexing right we
687:11 - want the first element because there is
687:14 - actually only one element on here
687:17 - so we access that meaning we'll get back
687:20 - a reference to a vector
687:24 - holding i32
687:28 - types right
687:30 - here we are taking a reference
687:34 - now then we have basically unwrapped
687:37 - this Vector into this variable
687:40 - now as you can see we use the right
687:44 - macro to write to this buffer this
687:48 - square bracket
687:50 - because as you can see this is what we
687:52 - want to Output
687:54 - so the first thing added to the buffer
687:57 - will be this square bracket then iterate
688:01 - over V in vac while enumerating the
688:04 - iteration count in count so we take this
688:07 - vector and we iterate over it and
688:11 - enumerate meaning we will get back a
688:14 - tuple holding the index and the actual
688:18 - value
688:20 - then for every element except the first
688:24 - add a comma use the question mark
688:26 - operator to return on errors
688:31 - so as you can see if count is not equal
688:34 - to zero
688:36 - meaning if it is in fact the first
688:40 - element then we don't add this comma all
688:42 - right because we don't want to look
688:45 - something like that
688:49 - so this is only after the second
688:53 - iteration that this comma will be added
688:58 - and then we write the actual value over
689:02 - here
689:04 - and this iterates three times right for
689:07 - each element and then in the end it will
689:11 - put into the buffer this square bracket
689:15 - so when we run that
689:19 - as you can see the output would be
689:21 - something like that
689:23 - but this is the output that we want
689:26 - so what's missing over here is we didn't
689:30 - include the indexes right so what we can
689:36 - do over here
689:37 - we want here to be the index and then a
689:41 - colon like here and a space and then the
689:45 - value so we have the index in this count
689:48 - variable so let's use that
689:53 - and again we can then
689:56 - run the program
689:59 - and this succeeded so let's actually
690:01 - print that out
690:13 - as you can see this would be the output
690:16 - so we can really manipulate the output
690:19 - of our custom types using the debug and
690:24 - the display trades and by the way as you
690:28 - can see we are here using the question
690:30 - mark operator because this over here
690:33 - could potentially fail right
690:36 - that's why we are using this here and
690:41 - we use here the result type from the fmt
690:45 - module just in case any of these
690:48 - operations here fail
690:52 - alright see you in the next topic
690:55 - so let's take a look at lifetimes now
690:57 - lifetimes are only necessary when
691:00 - dealing with references and even then
691:03 - most of the time the compiler can
691:06 - actually infer the lifetimes and we
691:09 - don't have to worry about it so let's
691:11 - see
691:12 - a lifetime is another kind of generic
691:15 - ensuring that references are valid as
691:18 - long as needed
691:20 - every reference has a lifetime which is
691:23 - the scope for which the reference is
691:25 - valid
691:26 - most of the time this is implicit and
691:29 - inferred so we don't have to worry about
691:32 - it
691:33 - sometimes though lifetime annotations
691:35 - are needed and that's the case if the
691:38 - compiler can't infer it and lifetime
691:42 - annotations is a concept which most
691:45 - other programming languages don't have
691:48 - so even for experienced programmers this
691:52 - sometimes looks a little bit confusing
691:55 - but in actuality it's a very simple
691:58 - concept and you will understand it very
692:02 - quickly
692:03 - so
692:05 - actually the main aim of lifetimes is to
692:09 - prevent dangling references also called
692:12 - dangling pointers
692:14 - so let's see we are here in Main and we
692:18 - declare a variable R we don't initialize
692:21 - it with a value but just declaring it
692:25 - meaning
692:26 - the compiler will actually infer a
692:30 - lifetime of a for this variable and the
692:34 - lifetime a in this case is valid until
692:38 - the end of the main scope right
692:42 - then over here we have an inner scope
692:45 - and in this scope we are initializing
692:48 - variable x with a value of 5. so the
692:52 - compiler will annotate this variable to
692:56 - be of Lifetime B
692:59 - and as you can see lifetime B is only
693:02 - valid until the end of this scope
693:06 - now then we are assigning a reference to
693:10 - x to the variable R meaning the variable
693:14 - R we have declared here holds a
693:17 - reference to the variable X
693:20 - the problem here is that when X goes out
693:24 - of scope at this point then R Points to
693:28 - something that is not valid anymore
693:31 - right and that's the aim of references
693:35 - to avoid exactly this scenario
693:40 - now to understand lifetimes you have to
693:43 - understand the borrow check or in Rust
693:46 - so the borrow Checker Compares Scopes to
693:50 - determine whether all borrows are valid
693:53 - it's a key part of Russ ownership system
693:56 - it tracks lifetimes of references and
694:00 - ensures that they don't violate the
694:03 - ownership rules these rules ensure that
694:06 - the value is not accessed after it has
694:09 - been moved or freed from memory
694:12 - an important a reference to a value must
694:16 - never outlive the value itself
694:19 - so you have to remember
694:22 - especially the last line
694:24 - a reference to a value must never
694:27 - outlive the value itself
694:30 - so when we go back here as you can see
694:33 - we have here a reference to value 5. now
694:36 - the problem is that this reference
694:38 - outlives the value itself meaning X
694:43 - holding this value we are referencing to
694:46 - goes out of scope meaning the reference
694:50 - on here lifts longer than the actual
694:53 - value it is referring to
694:56 - all right
695:00 - let's see the compiler uses lifetime to
695:03 - ensure all borrows are valid typically a
695:07 - variable's lifetime begins when it is
695:09 - created and ends when it is destroyed
695:13 - so the scope of Lifetime annotate the
695:16 - lifetime of I and borrow 2.
695:20 - lifetimes are annotated below with lines
695:23 - denoting the creation and destruction of
695:25 - each variable
695:27 - I has the longest lifetime because its
695:30 - scope entirely encloses both borrow1 and
695:33 - borrow two the duration of borrow 1
695:36 - compared to borrow 2 is irrelevant since
695:39 - they are disjoint
695:41 - so when we look at this program here
695:46 - what you see is that we have here
695:48 - initialized variable I right
695:52 - now this variable I over here lives
695:55 - until the main scope ends
695:59 - all right
696:01 - basically it outlives this scope and
696:05 - this scope
696:06 - now over here we are assigning a
696:09 - reference to I to borrow one
696:13 - right so borrow one lifetime starts
696:17 - and then we are just printing out borrow
696:20 - one now over here borrow one will go out
696:25 - of scope
696:26 - but it doesn't matter because the value
696:29 - itself still lives on all right
696:34 - and over here the same thing we have
696:36 - power 2 which holds a reference to I
696:40 - meaning
696:42 - that borrow 2 lives inside the scope so
696:46 - we print here borrow two and then it
696:49 - will here go out of scope
696:51 - but again the value here lives on so the
696:55 - actual value outlives
696:58 - T borrows or the references
697:01 - all right
697:04 - example two so over here we have a
697:07 - variable X
697:09 - with a value of 5.
697:12 - and then over here we have a reference
697:15 - to X
697:17 - assigned to variable r
697:20 - and then we are printing out R right so
697:24 - if we execute that it will compile
697:29 - because again as you can see we are
697:32 - declaring here the variable X in this
697:35 - scope so variable X we live until the
697:39 - scope ends and the same thing for the
697:43 - reference to X
697:45 - so the reference to X is assigned to R
697:48 - meaning R will live until the end of
697:52 - this scope
697:53 - so the value and the borrow to the value
697:57 - are both valid
698:00 - all right and over here you can see the
698:03 - lifetime annotations the important thing
698:06 - here is that
698:07 - both
698:09 - the value itself and the reference to
698:11 - the value or valid right the reference
698:16 - here doesn't outlive the actual value it
698:20 - is pointing to
698:22 - annotate R and X as above and explain
698:25 - why this code fails to compile in the
698:28 - lifetime aspect
698:31 - that's actually the example we have seen
698:34 - so we are here declaring r and over here
698:38 - in this inner scope
698:40 - we declare a variable X and initializing
698:44 - it with a value of 5. then we are
698:48 - assigning a reference to X to R
698:52 - the problem here is X will go out of
698:55 - scope so R still points to
698:59 - dislocation but this over here has gone
699:03 - out of scope right so rust won't allow
699:07 - you to compile this program and you will
699:10 - get a compiler Arrow saying X does not
699:14 - live long enough right
699:18 - because
699:20 - the reference to the value lives longer
699:23 - than the actual value lives right
699:29 - meaning the lifetime of X is shorter
699:33 - than the lifetime of r
699:35 - or the lifetime of X holding the value
699:39 - is shorter than the lifetime of R
699:41 - holding the reference to a value and
699:44 - this should never happen
699:47 - so lifetime annotating The Borrowed
699:50 - cycle reuses explicit lifetime
699:52 - annotations to determine how long a
699:55 - reference should be valid but for us
699:58 - users in most cases there is no need to
700:01 - annotate the lifetime because there are
700:04 - several illusion rules before learning
700:06 - these rules we need to know how to
700:09 - annotate lifetime manually
700:12 - so
700:14 - ignoring illusion rules and that's the
700:17 - next topic lifetimes in function
700:20 - signatures have a few constraints
700:23 - any reference must have an annotated
700:26 - lifetime any reference being returned
700:29 - must have the same lifetime as one of
700:32 - the inputs or be static so over here we
700:35 - have a function print one
700:38 - and it takes as an argument a reference
700:42 - to an i32 type alright
700:47 - now this is how we would annotate a
700:50 - lifetime it's actually very similar to
700:53 - generics but we use this apostrophe
700:56 - syntax and a lowercase letter by
701:00 - convention just going from a b c d and
701:03 - so on
701:04 - so in this case we annotate here
701:08 - that the reference
701:11 - that the reference here is of Lifetime a
701:15 - so when we have over here a lifetime
701:18 - annotation
701:20 - then we can provide here
701:23 - then we can annotate it here for our
701:26 - reference right and again we are just
701:29 - dealing with lifetimes when we are
701:31 - dealing with references
701:34 - so in this case we say the reference to
701:37 - the i32 type should be of Lifetime a now
701:42 - when we annotate that to our function it
701:45 - means that
701:47 - the lifetime a must at least live as
701:51 - long as the function itself or we all or
701:55 - we could also say lifetime a must
701:58 - outlive this function so the past
702:02 - reference over here must outlive this
702:05 - function this is just ensuring that the
702:10 - reference passed here lives longer than
702:13 - this function meaning we can ensure that
702:16 - this function always deals with a valid
702:20 - reference right
702:23 - and all we do here is printing out X
702:27 - mutable references are possible with
702:30 - lifetimes as well so if you would have a
702:34 - mutable reference you would annotate it
702:36 - like that
702:37 - first after the Ampersand of course you
702:41 - will always put the lifetime annotation
702:44 - and then the mute keyword and then of
702:47 - course the type
702:52 - multiple elements with different
702:54 - lifetimes in this case it would be fine
702:56 - for both to have the same lifetime a but
702:59 - in more complex cases different
703:02 - lifetimes may be required
703:05 - so as you can see we can
703:07 - Define more than one lifetime over here
703:10 - we have lifetime a and lifetime B
703:13 - meaning the references pairs to this
703:16 - function could be of different lifetime
703:18 - but again
703:21 - lifetime a and lifetime B must outlive
703:25 - this function so the past references
703:29 - over here must outlive the function
703:34 - right
703:36 - and returning references that have been
703:39 - passed in is acceptable however the
703:42 - correct lifetime must be returned
703:45 - so let's take a look at the function
703:48 - pass X as you can see it takes two
703:51 - arguments and both of them are
703:53 - references
703:55 - now this would be of Lifetime a and this
703:59 - would be of Lifetime B again both of
704:03 - these references must outlive this
704:06 - function
704:08 - and we are just returning X which is
704:12 - annotated with a lifetime a meaning the
704:16 - return type will return
704:18 - meaning the return type will be a
704:21 - reference to an i32 with a lifetime of a
704:25 - right this would be the type that is
704:29 - annotated to the X argument here
704:34 - if we would here have y and we return y
704:39 - then we would do it like that right
704:42 - because we are returning a reference
704:44 - with a lifetime annotation of B
704:58 - foreign
705:02 - so as you can see we have here
705:04 - two variables
705:06 - holding i32 types and then we are
705:10 - passing to all of the above functions T
705:14 - reference to these two
705:16 - variables right because all of these
705:19 - functions over here expect a reference
705:22 - to an i32 type
705:26 - now
705:28 - in this case this program will compile
705:36 - as you can see this is compiling because
705:39 - we have here declared X and Y in the
705:43 - main scope meaning they are valid until
705:47 - the end of the scope over here right so
705:53 - t x and y references we pass to the
705:56 - functions outlive all the functions
706:00 - which is a requirement right
706:03 - the best references must outlive the
706:07 - function
706:08 - so we don't have to deal with dangling
706:11 - references
706:14 - and so let's see an exercise to
706:17 - understand it even more make it work by
706:19 - adding proper lifetime annotation
706:22 - so over here we have the function
706:24 - longest that takes two arguments of type
706:27 - string slice
706:29 - now we then test the length of these
706:33 - string slices
706:34 - and if x is
706:37 - and if x
706:39 - is longer than y then we return X
706:43 - otherwise we return y
706:47 - so
706:49 - if we go over here in the main function
706:52 - and let's do some variables
707:06 - as you can see we have two string
707:08 - literals long and longer
707:15 - now we would pass that to this function
707:19 - over here
707:21 - now
707:23 - it could be possible in this case
707:26 - the return type is known at compile time
707:30 - but sometimes this is decided at runtime
707:33 - and when we are passing these arguments
707:37 - to the function over here let's do that
707:40 - actually
707:49 - [Applause]
707:52 - and notice we don't have to pass here a
707:56 - reference because string literals are
707:59 - already references all right now if we
708:03 - would compile that this would actually
708:05 - fail right missing lifetime specifier
708:11 - so what we want to achieve here
708:14 - is first of all we want to add a
708:16 - lifetime parameter like that
708:21 - and then we want to define the lifetimes
708:24 - of these references
708:28 - now in this case the function over here
708:31 - could either return X or Y right
708:35 - depending on which argument has the
708:39 - longer string
708:41 - right so sometimes it might be X that is
708:44 - returned and sometimes it might be y so
708:48 - we can't be sure if we annotate here a
708:52 - and B like that
708:57 - we don't know which one will get
708:59 - returned is it a or b it depends on the
709:03 - arguments right
709:05 - so what we can Define here is that
709:11 - X and Y these two arguments have the
709:15 - same lifetime meaning
709:18 - these two references share the same
709:21 - lifetime they must be declared in the
709:25 - same scope and both of them of course
709:28 - must outlive the function longest
709:32 - so in this case this is what we are
709:35 - providing right we are declaring X and Y
709:38 - over here in the main scope so when we
709:41 - call the longest function with these two
709:44 - references over here it means that these
709:47 - two references still live on even after
709:51 - this function call all right because
709:54 - again the reference of X and Y will
709:58 - leave until the main scope ends
710:02 - now because we have here defined that
710:06 - both of these references have the same
710:09 - lifetime
710:10 - it is clear that the returned
710:14 - string slice must have the same lifetime
710:17 - either X or Y right
710:21 - let's see
710:25 - and as you can see this is compiling in
710:27 - this case longest will return y because
710:31 - it is longer than this than the X string
710:37 - all right
710:40 - a must live longer than the function
710:42 - here reference to string Foo would
710:46 - create a string followed by a reference
710:48 - then the data is dropped upon exiting
710:51 - the scope leaving a reference to invalid
710:54 - data to be returned
710:56 - fix the arrow in three ways as you can
710:59 - see we have the function invalid output
711:02 - we Define here a lifetime parameter a
711:05 - and declare that The Returned reference
711:08 - should be of this lifetime
711:11 - now the problem here is we are
711:15 - creating a new string and returning a
711:20 - reference to it right we are returning a
711:23 - reference to a string the problem is
711:26 - this string was declared inside the
711:29 - function now when
711:32 - the function returns to the caller it
711:36 - means the string over here will get out
711:38 - of scope right because it is declared
711:41 - inside the function
711:43 - so again if we call for example
711:53 - if we call this function
711:56 - then we would get back
711:58 - a reference to a string right the
712:01 - problem is
712:03 - that
712:04 - the reference points to something that
712:07 - isn't valid anymore this string declared
712:10 - here got out of scope so X points to
712:14 - something that is not valid anymore
712:17 - so returning a reference to something
712:20 - declared inside the function is a really
712:23 - bad idea now what we can do over here to
712:26 - fix that and this is probably the
712:28 - easiest fix
712:30 - we just return the string itself right
712:34 - so then ownership will be transferred
712:37 - and X will be the owner
712:39 - all right let's print out X
712:48 - as you can see this is working because
712:51 - we are here
712:52 - declaring a string
712:55 - and then return it meaning the ownership
712:58 - of the string will then be returned over
713:02 - here right so X will become the owner of
713:06 - the returns string from the invalid
713:09 - function
713:12 - the second way to fix that would be
713:15 - returning a string literal
713:19 - right
713:20 - and a string literal actually has always
713:25 - a static lifetime we will come back to
713:27 - that but that actually means that this
713:30 - reference is of static lifetime meaning
713:34 - it is valid throughout the entire
713:37 - program
713:38 - all right because remember a string
713:41 - literal is hard coded into the binary so
713:45 - it lifts as long as the program lives
713:49 - so then over here we will get back a
713:52 - string slice right
713:55 - let's see
713:58 - and as you can see this is also
714:00 - compiling
714:02 - the Third Way would be
714:04 - over here
714:08 - create a string
714:20 - and then we can pass this string to the
714:23 - invalid output so
714:26 - in this case we want here to take
714:29 - a reference to a string right we can
714:34 - also write it like that because remember
714:37 - a reference to a string
714:40 - will be automatically inferred to a
714:42 - string size right
714:45 - so
714:51 - [Applause]
714:55 - so we are then passing a reference to
714:58 - this string right and what we want to
715:01 - return here is s
715:04 - meaning we return here a string slice
715:08 - and we can annotate a lifetime parameter
715:19 - and then we will print out X let's see
715:25 - and this is also working because as you
715:29 - can see we have defined here a string
715:32 - meaning s over here is the owner of this
715:36 - train then we are passing a reference of
715:40 - s to this function right
715:44 - we annotate here a lifetime a meaning
715:48 - the reference over here passed to the
715:51 - argument s must outlive this function
715:55 - which it does right we have declared s
715:58 - here so even after this function call S
716:02 - still lives on right
716:05 - and then all we do is we again return as
716:09 - the past reference right so
716:12 - it will actually have the same lifetime
716:15 - as the past argument
716:18 - all right meaning we have here then a
716:22 - returned string slice
716:28 - all right
716:30 - Point refs takes two references to i32
716:34 - which have different lifetimes A and B
716:37 - these two lifetimes must live at least
716:41 - as long as the function print refs so as
716:44 - you can see we are here in the print
716:47 - refs function declaring two lifetime
716:50 - parameters one for argument X and one
716:54 - for argument y again we are dealing with
716:57 - references meaning
716:59 - we care about the lifetimes if these
717:02 - would be owned types like so
717:05 - then we don't deal with references right
717:08 - [Applause]
717:10 - and then we just print out X and Y to
717:13 - provided arguments
717:16 - make it work if function which takes no
717:18 - arguments but has a lifetime parameter a
717:22 - so over here
717:26 - we can see that we annotate a lifetime
717:29 - parameter a and we have here
717:33 - and i32 integer now error X does not
717:37 - live long enough
717:40 - so we assign to Y over here in reference
717:44 - to X
717:46 - the problem again is that when we
717:49 - annotate this lifetime parameter it says
717:52 - the lifetime a must outlive this
717:56 - function
717:57 - which it doesn't right because
718:00 - the reference over here
718:05 - because the value we are referencing to
718:08 - is declared inside the function meaning
718:11 - it will then be dropped at the end of
718:15 - the scope
718:16 - attempting to use the lifetime a as an
718:19 - explicit type annotation inside the
718:21 - function will fail because the lifetime
718:23 - of reference X is shorter than a a short
718:28 - lifetime cannot be coerced into a longer
718:31 - one
718:33 - so let's see in main we are here
718:37 - destructuring a tuple into the variables
718:40 - 4 and 9 right so 4 will hold 4 and 9
718:45 - will hold 9. borrows of both variables
718:49 - are passed into the function
718:51 - so we are then calling the print refs
718:54 - function with references to 4 and 9
718:58 - right
719:00 - this function over here
719:04 - any input which is borrowed must outlive
719:07 - the borrower in other words the lifetime
719:10 - of 4 and 9 must be longer than D then
719:14 - that of print refs
719:16 - so again when we annotate these
719:19 - lifetimes on a function both of the
719:22 - lifetimes must outlive
719:25 - the function or both of the
719:30 - references passed here must outlive the
719:33 - lifetime of this function which they do
719:36 - right so 4 and 9 are declared in main
719:40 - scope meaning they outlive this function
719:43 - over here
719:44 - so this should actually work
719:49 - so failed borrow contains no references
719:52 - to force a to be longer than the
719:55 - lifetime of the function but a is longer
719:59 - because the lifetime is never
720:00 - constrained it defaults to static
720:05 - so
720:06 - so as you can see we have here declared
720:09 - the lifetime a which states that the
720:13 - reference holding the lifetime of a must
720:16 - outlive the function this is not the
720:19 - case right because we are declaring the
720:21 - value inside the function itself
720:25 - now when we remove that
720:28 - actually this over here will then
720:32 - work all right let's see
720:41 - let's see structs make it work by adding
720:43 - proper lifetime annotation a type of
720:46 - road which houses a reference to an i32
720:50 - the reference to i-32 must outlive
720:54 - borrowed
720:55 - so as you can see we have here a custom
720:59 - type a tuple struct holding a reference
721:03 - to i32
721:06 - now in this case we have to annotate the
721:09 - lifetime and we do it like that
721:12 - and then we pass it to the reference
721:15 - like so and that means this reference
721:18 - here must outlive this struct or the
721:24 - instance we create from it right
721:28 - similarly both references here must
721:31 - outlive this structure
721:34 - again we are here annotating the
721:37 - lifetime and we say that both of them
721:39 - should have the same lifetime which
721:42 - makes it easier right
721:44 - and enum which is either an i32 or a
721:48 - reference to one
721:50 - so as you can see again
721:53 - we can annotate a lifetime basically
721:56 - like a generic type parameter
721:59 - and over here as you can see this
722:01 - variant holds a type of i32 so the enum
722:06 - will be the owner of this type we don't
722:09 - care about any lifetime annotation we
722:13 - only care about lifetime annotations
722:15 - when dealing with a reference
722:19 - like that
722:22 - now let's see we have here i32 and i32
722:27 - and then we are instantiating the
722:30 - borrowed struct with a reference X right
722:36 - so as you can see this would be the
722:38 - borrowed struct and it holds a reference
722:43 - 2x which is i32 right
722:53 - now as you can see we Define here that
722:56 - reference
722:58 - of Lifetime a must outlive
723:01 - this struct or the instance of destruct
723:05 - right so X over here must outlive this
723:10 - instance which
723:12 - which it does right because it again it
723:16 - is declared in main scope meaning X and
723:19 - Y we live until this point here
723:23 - so they outlived The Borrowed struct
723:28 - and over here as you can see we pass
723:30 - here references to the X and Y field of
723:34 - the named borrowed
723:36 - a struct
723:40 - so this would then be an instance now
723:42 - again
723:43 - X and Y in this case first of all they
723:47 - are declared in the same scope so they
723:49 - can have the same Lifetime right
723:52 - they both live in the same scope and
723:55 - both of these variables will end at the
723:59 - same time
724:01 - so
724:03 - this will actually compile right
724:05 - everything over here is safe
724:09 - so as you can see we instantiate clear
724:12 - the either enum
724:17 - and one time with the variant ref
724:19 - holding a reference to X
724:23 - now again as you can see we have here a
724:26 - lifetime parameter a which states it
724:29 - must outlive the instance of the enum
724:32 - which it does right X is valid all the
724:37 - time
724:38 - and the second variant doesn't hold a
724:42 - reference we just pass it to single
724:46 - we just pass it
724:48 - T variable
724:50 - now because this implements copy it's an
724:52 - i32 it means that even then y will still
724:57 - live on so either want to take ownership
725:00 - it will take ownership of the copied
725:03 - value
725:04 - let's see if this is actually compiling
725:13 - and this is compiling
725:16 - make it work so over here we have
725:20 - destruct no copy type and and over here
725:24 - we have struct example and as you can
725:27 - see we annotate here the lifetimes A and
725:30 - B meaning over here the A and B field
725:34 - could hold references that have
725:38 - different lifetimes but they can also be
725:41 - the same all right
725:44 - now let's see in main a tight to FN main
725:47 - stack frame
725:49 - so as you can see we have here an i32
725:52 - and over here we have declared a
725:55 - variable which should be of type example
725:58 - but we haven't initialized it with
726:01 - values all right we haven't instantiated
726:05 - the example struct now notice here we
726:09 - have another scope
726:11 - lifetime B tied to new stack frame so
726:15 - then we have here an instance of the no
726:17 - Copy Type struct
726:21 - and as you can see fix me
726:24 - so then we are instantiating example
726:28 - with the fields over here passing it
726:31 - concrete values as you can see we are
726:34 - passing it a reference to Bar a this and
726:39 - a reference to Bar B so the problem over
726:43 - here is that VAR B will go out of scope
726:48 - at this point right
726:51 - meaning
726:53 - the example struct we have instantiated
726:57 - over here will hold the B field which
727:01 - points to something that is not valid
727:04 - anymore as you can see we are here
727:06 - printing out example now if we would
727:09 - print it out in this scope
727:12 - then this would actually compile
727:16 - and of course this must be your 32
727:19 - because it is a u32 field here as you
727:23 - can see this is compiling fine
727:26 - now even though
727:29 - we are here in a new scope right we have
727:34 - declared Bar B here in the inner scope
727:38 - but even then both of these references
727:43 - are valid right
727:46 - because we are here then using example
727:50 - in the same scope and we have noted that
727:54 - here that you that the lifetime of a and
727:59 - b are different right so the lifetime of
728:04 - bar a
728:07 - is actually longer than the lifetime of
728:10 - Bar B
728:13 - right because for a lives until the end
728:16 - of the main function while Bar B leaves
728:20 - only until this point
728:23 - but again
728:25 - this is safe and this is compiling
728:28 - because the VAR B we have created here
728:32 - and passed a reference
728:34 - to the
728:36 - example struct is valid
728:41 - if we leave this over here then this
728:44 - wouldn't compile right because vorby
728:47 - gets out of scope
728:50 - and
728:54 - we over here say that both A and B must
728:59 - outlive example
729:01 - all right so example is used here but
729:05 - not all references are still valid which
729:10 - would lead to a compiled error
729:12 - but what we can do also is just removing
729:15 - this scope here
729:17 - meaning everything is now declared in
729:19 - main scope so this would also compile
729:22 - right because all the references to
729:25 - these variables are valid
729:31 - let's see here we have again struck no
729:33 - copy type and the example struct we have
729:36 - seen before and as you can see denoting
729:40 - that the lifetimes of these references
729:43 - might differ but they can be the same
729:46 - it's no problem so let's see here fixed
729:49 - function signature we have here the fix
729:51 - me function which takes us an argument a
729:54 - reference to an example instance and it
729:58 - will then return
730:00 - the B field from the provided argument
730:04 - from the example struct right it will
730:08 - return this field over here meaning a
730:12 - reference to no copy type because that
730:15 - is what B is holding
730:18 - now over here we are instantiating no
730:21 - Copy Type
730:27 - and we are instantiating the example
730:31 - struct
730:33 - so we pass for the field a here a
730:37 - reference to one
730:39 - and for B we pass a reference to no Copy
730:44 - Type
730:45 - right
730:48 - [Applause]
730:51 - and then we pass a reference
730:54 - this example instance over here to the
730:57 - fix me function now let's first annotate
731:01 - the lifetime parameter
731:04 - again we do a
731:08 - and over here we say
731:11 - that the past reference to the example
731:15 - instance must outlive this function
731:18 - right which it actually does because
731:21 - here we are instantiating the example
731:24 - struct and passing it to a reference
731:27 - and passing it as a reference to this
731:30 - function meaning example over here will
731:33 - live longer than the function right
731:37 - and we can then Define that no Copy Type
731:43 - must also outlive
731:47 - this fix me function all right which it
731:52 - does because again it's secured the main
731:54 - meaning the end of scope will be at this
731:58 - point
731:59 - so both the instance of example and the
732:03 - no copy type both outlive this fix me
732:08 - function
732:09 - and as you can see we can pass this same
732:12 - lifetime parameter because they are
732:14 - declared in the same scope meaning they
732:17 - have the same lifetime
732:25 - methods are annotated similarly to
732:28 - functions so we have here destruct owner
732:31 - holding an i32 type
732:34 - so annotate lifetimes as in a standalone
732:37 - function as you can see we have here the
732:40 - implementation block for owner and we
732:43 - Implement some methods for this custom
732:46 - type
732:47 - and this is how we would annotate
732:50 - lifetime parameters again same thing
732:53 - again same thing like in functions
733:10 - make it work by adding proper lifetime
733:13 - annotations
733:15 - you have a struct important excerpt
733:18 - and the port field holding a string
733:20 - slice now again string slice is a
733:23 - reference meaning we have here to
733:26 - annotate the lifetime parameter
733:30 - so that means the reference that the
733:33 - port field of destruct is holding
733:36 - outlives the entire struct
733:39 - right
733:41 - and over here we have
733:44 - a method implemented for the important
733:48 - excerpt struct so as you can see we are
733:52 - using a lifetime parameter here but we
733:55 - have to actually first declare it
733:58 - like that
734:03 - and that's basically it it should
734:06 - compile
734:07 - so when distract over here
734:10 - declares a lifetime parameter we have to
734:14 - declare it in the implementation block
734:17 - again but we are here not using it
734:19 - meaning we can do it like that right we
734:22 - don't care about this lifetime parameter
734:25 - here
734:26 - and this lifetime parameter is declared
734:29 - only on the on the method right
734:35 - this is compiling but there is an easier
734:38 - way actually we don't have to use any
734:42 - lifetime here right
734:45 - because we can Define here that
734:48 - the string slice is static
734:52 - meaning it will live throughout the
734:55 - entire program
734:57 - all right
734:59 - illusion some lifetime patterns are so
735:02 - common that the borrowed Checker will
735:04 - allow you to Omit them to Safe typing
735:07 - and to improve readability this is known
735:10 - as illusion
735:12 - illusion exists in Rust only because
735:15 - these patterns are common
735:17 - for a more comprehensive understanding
735:19 - of a lesion please see lifetime illusion
735:22 - in the official book
735:24 - so I have prepared some slides
735:29 - let's see there are three rules of
735:31 - Lifetime illusion the first rule states
735:34 - compiler assigns a lifetime parameter to
735:38 - each parameter that's a reference
735:41 - second if there is exactly one input
735:44 - lifetime parameter that lifetime is
735:47 - assigned to all output lifetime
735:50 - parameters
735:52 - third rule if there are multiple
735:54 - lifetime parameters but one of them is a
735:57 - reference to self or immutable reference
736:00 - to self the lifetime of self is assigned
736:04 - to all output lifetime parameters
736:09 - so let's see an example
736:13 - and
736:14 - before we see the example as you can see
736:17 - lifetime illusion makes writing rust
736:20 - much more easy until this point we
736:23 - didn't worry and care about lifetimes
736:25 - and that's most of the time the compiler
736:28 - just inferred it so we didn't have to
736:31 - worry
736:32 - now let's see here we have the function
736:35 - first word taking a reference okay and
736:39 - returning a reference
736:41 - so the compiler applies the first rule
736:44 - each parameter gets its own lifetime
736:48 - so the compiler behind the scenes will
736:52 - annotate here a lifetime for this
736:54 - function and we'll annotate it for all
736:58 - the references right
737:02 - so the second rule applies because there
737:05 - is exactly one input lifetime
737:08 - again we have only one argument that is
737:11 - a reference
737:13 - so this gets assigned to the output
737:16 - lifetime meaning the output reference
737:20 - here must then be
737:23 - the same reference right we are taking a
737:26 - reference so it must be the same when we
737:28 - are when we are returning a reference
737:32 - so in this case the compiler could infer
737:35 - the lifetime and we don't have to
737:37 - specify them manually
737:39 - so what the compiler will do he will
737:42 - just annotate the same lifetime as for
737:46 - the input argument right
737:49 - so this is all inferred you can write it
737:52 - like that and it will compile you don't
737:54 - have to worry about lifetimes
737:58 - so let's see this example we have the
738:00 - function longest that takes two
738:02 - references as arguments okay and it
738:06 - returns one reference
738:08 - first rule each parameter gets its own
738:11 - lifetime so the compiler will come and
738:14 - annotate
738:16 - A and B each reference gets its own
738:21 - lifetime all right so here the second
738:24 - rule doesn't apply because there is more
738:27 - than one input lifetime also the third
738:30 - rule doesn't apply because this function
738:32 - is not a method we have now to manually
738:36 - annotate the lifetime parameters
738:39 - so as you can see over here the compiler
738:42 - cannot infer
738:44 - The Returned reference here is it of
738:47 - Lifetime a or is it of Lifetime B right
738:52 - so it depends if you return X then you
738:56 - would annotate a lifetime of a if you
738:59 - return B then you would return then you
739:02 - would annotate a lifetime of B and again
739:06 - both lifet times A and B must outlive
739:10 - this function
739:13 - let's see an example in a method so as
739:18 - you can see we have a method taking a
739:20 - reference to self meaning taking the
739:23 - instance as a reference and doesn't take
739:26 - ownership
739:28 - so here the third rule applies which
739:31 - states that if there is a reference to
739:33 - self then all references will have the
739:37 - same lifetime as self
739:39 - right so we can have here any number of
739:43 - arguments all of them will take the
739:46 - exact same lifetime as the lifetime of
739:49 - self because this is inferred and it
739:52 - makes sense right because
739:55 - all of the provided arguments to a
739:59 - method must actually outlive
740:01 - the structure or the enum
740:05 - instance
740:07 - all right so all of the arguments here
740:10 - take
740:12 - implicitly the same lifetime as self
740:17 - all right
740:23 - so let's see remove all the lifetimes
740:26 - that can be elided as you can see over
740:29 - here we have only one input argument
740:33 - and the second thing is we don't even
740:35 - return anything so we don't even have to
740:38 - care about
740:39 - uh the lifetime because we don't worry
740:42 - that it might go out of scope right but
740:46 - in this case we only have one argument
740:49 - meaning the compiler is able to infer
740:51 - that
740:53 - over here again we have only one
740:56 - argument
740:58 - but
740:59 - as you can see the difference is we are
741:02 - returning
741:04 - a reference right
741:07 - so
741:08 - because there is only one argument here
741:13 - the compiler can infer that the
741:17 - reference over here must be the
741:18 - reference that will be returned so we
741:22 - don't have to annotate the lifetimes so
741:25 - let's see over here we have the longest
741:27 - function and
741:30 - the first rule says that the compiler
741:32 - will annotate a lifetime for each
741:36 - reference meaning it will create a and b
741:39 - because we have here two references
741:43 - right two arguments
741:45 - and
741:47 - it will annotate for the first argument
741:50 - a and for the second argument lifetime
741:53 - of B
741:54 - now over here this
741:58 - the compiler cannot infer which lifetime
742:02 - will get returned meaning as you can see
742:06 - we are returning X so the lifetime over
742:10 - here would be a right the lifetime of
742:13 - the argument X
742:16 - but notice both of the references must
742:20 - outlive the function
742:22 - right
742:26 - here we have a struct owner that holds
742:29 - an i32 type
742:31 - annotate lifetimes as in a standalone
742:34 - function
742:36 - so as you can see we have here
742:40 - methods implemented on the owner struct
742:43 - now again when we have a mutable
742:47 - reference or an immutable reference to
742:50 - self then we never have to worry about
742:53 - lifetime annotations because this will
742:56 - get inferred by the compiler
743:00 - all right all references pass to these
743:04 - methods will get the same lifetime as
743:07 - self
743:08 - or SD reference to self
743:12 - now over here we have to annotate the
743:15 - lifetime because this is a struct and we
743:18 - want to ensure that the reference the
743:22 - name field is holding is actually living
743:25 - longer than the instance of a struct
743:28 - person okay and over here the same thing
743:32 - let's see if this is compiling
743:38 - and this is compiling what we could do
743:41 - also here
743:42 - we could remove that and doing it like
743:45 - this all right this should actually also
743:47 - work
743:50 - okay we have here to specify that this
743:53 - string is static in this case we have to
743:56 - explicitly state it and as you can see
743:59 - this is compiling so you don't have to
744:02 - declare here a lifetime parameter you
744:06 - can put here this static Lifetime and
744:10 - static lifetimes will be our next topic
744:14 - let's take a look at static lifetimes so
744:17 - aesthetic lifetime refers to a lifetime
744:20 - that lasts for the entire duration of
744:23 - the program's execution
744:25 - any reference or borrowed value with a
744:28 - static lifetime can be safely used
744:31 - throughout the program
744:33 - and aesthetic lifetime can be coerced to
744:37 - a shorter lifetime if needed
744:42 - so we have seen string literals and they
744:46 - are usually annotated using an ampersand
744:48 - and stir but implicitly it would have a
744:53 - static lifetime
744:55 - so string literals have a static
744:57 - lifetime because they are hard coded
744:59 - into the executable meaning they are
745:02 - valid throughout the entire duration of
745:06 - the program's execution
745:09 - let's see
745:11 - static is a reserved lifetime name you
745:14 - might have encountered it several times
745:17 - so a reference with static lifetime is
745:21 - for example a string literal and this
745:24 - would be the full type annotation
745:29 - static as part of a trade bound
745:32 - so as you can see we are here defining a
745:37 - generic type parameter and we say that
745:39 - the argument provided should be of type
745:42 - T now in the Vera Clause over here we
745:46 - see that t must be of static lifetime
745:51 - though they are all static but subtly
745:54 - different
745:55 - as a reference lifetime Ampersand static
745:58 - indicates the data pointed to by the
746:01 - reference lives as long as the running
746:04 - program but it can still be close to a
746:07 - shorter lifetime
746:09 - there are several ways to make a
746:11 - variable with static lifetime two of
746:14 - them are stored in the read-only memory
746:16 - of the binary
746:19 - fill in the blank in two ways
746:21 - so as you can see we are calling here
746:24 - neat static within argument of V so
746:28 - let's declare that here
746:30 - and as you can see the argument must be
746:33 - of type static string or string literal
746:38 - all right
746:39 - and then we are here checking is the
746:43 - argument equal hello
746:45 - so let's initialize it here
746:50 - so the first way is just initializing it
746:53 - like that without any type annotation
746:59 - because this is simply inferred by the
747:02 - compiler so any string literal is hard
747:06 - coded into the binary means it lives as
747:10 - long as the program's execution Because
747:14 - the actual data of the string literal is
747:17 - living in the binary the second way is
747:20 - just annotating the full type annotation
747:26 - like that
747:33 - and this static lifetime annotation here
747:36 - can also be omitted so we can annotate
747:40 - it like this
747:47 - as you can see the compiler is able to
747:51 - infer the lifetime
747:54 - another way to make static lifetime is
747:56 - using box leak now this is an unsafe
748:00 - method and I won't cover that because
748:03 - it's a more advanced topic
748:06 - but I have solved it and will put it on
748:09 - my GitHub if you want to solve it for
748:12 - yourself
748:14 - static only indicates that the data can
748:17 - live forever not the reference the
748:20 - letter one the letter one will be
748:23 - constrained by its scope
748:25 - so let's see make a string literal and
748:28 - print it so over here we have a string
748:31 - literal meaning it's a string slice of
748:36 - static lifetime
748:40 - then we print it out
748:42 - when static string goes out of scope the
748:44 - reference can no longer be used but the
748:47 - data remains in the binary so
748:52 - at the end of this scope over here
748:55 - this variable will go out of scope
748:58 - meaning it's dropped
749:00 - and that means we can't then use static
749:04 - string anymore because the variable has
749:07 - been dropped now even though the
749:11 - variable now even though the variable
749:14 - has been dropped the data over here is
749:17 - actually still living on right
749:21 - so this is living in the binary a string
749:25 - literal is hard coded into the binary
749:27 - meaning it is of static lifetime meaning
749:30 - it is valid throughout the entire Pro
749:34 - programs lifetime
749:37 - but of course a variable is bound to its
749:41 - scope
749:46 - so to make that work we can
749:50 - take that and copy it over here meaning
749:53 - the variable static string is valid
749:56 - until main ends as you can see
750:04 - static can be close to a shorter
750:06 - lifetime
750:08 - so over here make a constants with
750:11 - static lifetime so this over here is the
750:15 - static keyword meaning we are here
750:17 - creating a constant now constants by
750:20 - conventions are always uppercase right
750:26 - and by the way the difference between
750:28 - conist
750:31 - [Applause]
750:35 - the difference between this and this now
750:37 - both of them live for the entire
750:40 - lifetime of the program both are of
750:43 - static lifetime but the difference is
750:46 - that static will always remain at the
750:49 - same memory location while a const
750:53 - constant will get inlined so when we use
750:57 - for example num const here then it will
751:01 - get inlined meaning the compiler will
751:06 - basically copy that into the code in the
751:10 - function so the memory location could
751:13 - change but static always stays at the
751:16 - same memory location
751:20 - so returns a reference to num there is
751:24 - static lifetime is coerced to that of
751:27 - the input argument
751:30 - so as you can see over here we have a
751:33 - function corostatic and we have defined
751:36 - a lifetime parameter a
751:39 - we Define here that the input reference
751:42 - should be of this lifetime a right
751:46 - meaning the reference we take as an
751:49 - argument to this function must outlive
751:53 - the function itself
751:55 - now we over here actually return
751:59 - this constant right basically a
752:03 - reference to this constant
752:05 - and we can in this case course
752:09 - the static lifetime of this num constant
752:13 - to a shorter lifetime
752:17 - it's no problem right
752:19 - so a is shorter than static right
752:27 - aesthetic lifetime is
752:30 - larger than this a lifetime here meaning
752:35 - aesthetic meaning a reference with a
752:38 - static lifetime lives longer than a
752:43 - because a only defines that it must
752:45 - outlive this function right but we can
752:49 - hear chorus it to a shorter lifetime so
752:54 - it matches with the lifetime annotated
752:57 - on the function
753:00 - make an integer to use for coreostatic
753:03 - so over here we make an integer
753:08 - and then we pass a reference of this
753:12 - integer and called the chorus static
753:15 - function
753:16 - meaning we here returned a reference to
753:20 - an i32 right basically a reference to
753:24 - the number 18.
753:27 - and then we will just print out the
753:30 - result of this function call right
753:34 - now
753:36 - as you can see we have crossed num here
753:39 - to a shorter lifetime
753:42 - but this doesn't change the actual
753:45 - lifetime of this static constant right
753:49 - so even after this scope over here
753:52 - we can still access num because again
753:56 - it's of static lifetime it lives as long
754:00 - as the program is running
754:03 - so even though we have here corrected to
754:06 - a shorter lifetime it doesn't matter it
754:09 - remains static right
754:16 - let's see as a trade bound it means the
754:19 - type does not contain any non-static
754:22 - references
754:23 - for example the receiver can hold on to
754:26 - the type for as long as they want and it
754:29 - will never become invalid until they
754:31 - drop it
754:32 - it's important to understand this means
754:35 - that any owned data always passes a
754:39 - static lifetime bound but the reference
754:41 - to that owned data generally does not
754:46 - so
754:48 - so let's look at function printed as you
754:51 - can see we Define here a generic type
754:54 - parameter meaning the input meaning the
754:57 - input argument here must be of type T
755:00 - now this over here is a trade bound
755:03 - meaning we say the type T must implement
755:06 - the debug trade and
755:10 - T cannot contain any reference that is
755:15 - not of static lifetimes so all
755:17 - references T is containing must be of
755:21 - static lifetime
755:23 - right
755:24 - and over here we do basically the exact
755:26 - same thing but using the impul keyword
755:29 - right this and this is actually quite
755:33 - the same
755:34 - and then over here as you can see
755:38 - 22 takes a reference to T right
755:43 - and again T must implement the debug
755:45 - trade and it cannot contain any
755:48 - non-static
755:50 - references all right
755:53 - so
755:54 - I is owned and contains no references
755:57 - thus it's static
756:00 - [Applause]
756:01 - as you can see we are here initializing
756:04 - I with a value of 5 meaning I is the
756:07 - owner of 5. now when we pass the owner
756:11 - to a function then it would actually
756:14 - comply with this function signature
756:17 - because owned types are also considered
756:20 - static okay
756:24 - now this would actually work
756:30 - because again
756:32 - i32 implements debug and it is
756:36 - considered static because we are passing
756:39 - an owned type right
756:42 - oops reference to I only has the
756:45 - lifetime defined by the scope of main so
756:48 - it's not static
756:50 - right so the so a reference to I has a
756:54 - lifetime that is defined by this main
756:58 - scope
756:59 - so it's not static anymore right
757:02 - so this would actually
757:05 - output and error right
757:10 - and this would be the same thing again
757:13 - print it and print it one would actually
757:16 - be very similar right
757:20 - now this here actually works because we
757:24 - are here passing a reference to I again
757:28 - right so we pass a reference to I
757:32 - and again the reference to I would have
757:35 - a
757:36 - lifetime of this main function now the
757:40 - difference is here that
757:43 - in the argument we defined that
757:46 - the argument should be a reference to T
757:51 - meaning
757:53 - if we
757:54 - think away it is ampersands
757:57 - I would be T right
758:01 - so a reference to T would be a reference
758:03 - to I
758:05 - hope this makes sense
758:07 - so
758:08 - that means again when we pass I directly
758:11 - it would be it would Implement debug and
758:15 - it would be of static Lifetime right so
758:19 - this over here would work
758:23 - now to fix this over here we can
758:28 - do it two ways we can create here the
758:31 - constant I
758:33 - and again constants have a static
758:35 - lifetime as you can see this is
758:38 - compiling
758:40 - and the second thing is we can use this
758:43 - static keyword meaning I is static
758:48 - so this would pass because
758:51 - the argument we are passing
758:54 - or the references we are passing are all
758:57 - of static Lifetime and they implement
759:00 - the debug trade right
759:03 - i32 implements debug and we have ensured
759:08 - that all of them are of static lifetime
759:15 - now the last one here again deals with
759:18 - box leak I won't cover this but again
759:21 - the solution is in my GitHub if you want
759:24 - to solve it you can do that and then
759:26 - compare with my Solutions
759:32 - alright see you in the next one
759:35 - so let's see closures a closure is an
759:38 - anonymous function that is able to
759:40 - capture the values from the scope in
759:43 - which it is defined and if you are
759:46 - coming from python then you might know
759:48 - Lambda functions and in JavaScript they
759:51 - are called Arrow functions
759:54 - and they can be defined inline for
759:57 - example as a function parameter they
760:00 - don't require type annotations and they
760:03 - can take ownership of a value by using
760:06 - the move keyword
760:10 - so all functions and closures
760:14 - implement the F and trades and that is
760:18 - the trait that defines the signature for
760:21 - closures and functions
760:24 - it describes the types the number of
760:27 - arguments and the return type there are
760:30 - three different traits FN ones the
760:34 - closure can be called only once because
760:37 - it takes ownership of the captured
760:39 - values
760:41 - FM mute it might mutate a captured value
760:45 - it can be called more than once and FN
760:49 - it doesn't take any ownership of
760:52 - captured values it doesn't mutate
760:54 - anything and it might not even capture
760:58 - anything from its environment
761:01 - so let's take a look over here we have
761:04 - here initialize the variable x with a
761:07 - value of 1. now over here we would have
761:10 - a closure and closures are defined like
761:13 - that first of all we have these symbols
761:17 - over here and between them we Define the
761:21 - name of the argument
761:23 - and as you can see over here we just add
761:26 - the argument with the value of x so as
761:30 - you can see the closure here is able to
761:34 - capture the value of x something a
761:37 - function can't do right
761:40 - and
761:42 - we then assign this closure to a
761:45 - variable meaning we then can call this
761:48 - closure
761:49 - and calling it like in normal function
761:52 - so in this case as you can see we call
761:54 - the closure using the variable name
761:57 - closure and then providing it an
762:00 - argument right
762:02 - so actually disclosure call should
762:05 - evaluate to 3 because we provide 2 here
762:10 - meaning weld will be 2 and adding X to
762:14 - it one so two plus one will be 3.
762:18 - so disclosure captures the value of x
762:21 - and modifies it the compiler will
762:24 - capture variables in the least
762:26 - restrictive manner possible
762:29 - in this case immutable reference of X is
762:33 - taken rather than taking ownership
762:35 - because it's less restrictive
762:39 - let's see closures can capture the
762:42 - enclosing environments for example we
762:45 - can capture the X variable that's the
762:48 - example we have seen
762:50 - from the syntax we can see that closures
762:53 - are very convenient for on the Fly usage
762:56 - unlike functions both the input and
762:59 - return types of a closure can be
763:02 - inferred by the compiler
763:05 - so we have here a normal function as you
763:08 - can see it takes an argument of type i32
763:11 - and it will just add 1 to T and it will
763:15 - just add 1 to the provided argument and
763:18 - returns it meaning the return type will
763:21 - be i32
763:23 - now closures are Anonymous here we are
763:26 - binding them to references
763:29 - these nameless functions are assigned to
763:31 - appropriately named variables
763:34 - so as you can see we can here create a
763:38 - closure
763:39 - and this and this over here are exactly
763:43 - the same so type annotations enclosures
763:47 - are not required okay
763:52 - and then again we assign the closure to
763:55 - a variable in order so we can call it
763:58 - all right over here we have a variable I
764:01 - with a value of 1.
764:04 - and then we are just calling the
764:06 - function and these two closures with
764:10 - this value over here
764:14 - and a closure taking no arguments which
764:17 - returns an i32 the return type is in
764:21 - third
764:22 - so this would be a very primitive
764:24 - closure just with running one when being
764:27 - called so when we call one here we will
764:31 - just get back one
764:34 - let's execute that
764:37 - you can see when we call this function
764:40 - and these two closures it will just add
764:43 - one to the provided argument
764:47 - and over here we are just returning one
764:54 - capturing closures can capture variables
764:58 - by borrowing or moving but they prefer
765:01 - to capture by borrowing and only go
765:04 - lower when required
765:06 - so they can capture the values either by
765:10 - reference by mutable reference or by
765:13 - value meaning the closure will then only
765:16 - type it captures okay
765:19 - so let's see exercise one make it work
765:22 - with least amount of changes so over
765:25 - here we are initializing a variable
765:27 - color with a string
765:30 - so as you can see over here we have a
765:33 - closure and we assign it to print so we
765:36 - can then call it now this closure here
765:39 - doesn't expect any arguments but it uses
765:43 - the move keyword meaning the captured
765:46 - values will be moved inside this closure
765:51 - right
765:53 - so that means the closure here will
765:56 - become the owner of the captured value
766:00 - this is not always the case so for
766:02 - example over here a immutable reference
766:06 - is sufficient because we are just
766:08 - reading basically this data here we
766:12 - don't mutate anything and we don't need
766:14 - ownership to print something out
766:17 - but as you can see printing two time
766:20 - over here will cause an error right
766:25 - so what we can do is we can remove the
766:27 - move keyword
766:29 - and color can be borrowed immutably
766:32 - again because the closure only holds an
766:35 - immutable reference to color
766:37 - right that means when we don't move the
766:41 - captured value we can then
766:43 - take a reference to color again
766:47 - so this foothold a reference to a string
766:55 - as you can see we print here out two
766:58 - times color green because we are calling
767:00 - this closure two times
767:04 - and this will take an immutable
767:06 - reference of this captured value
767:11 - all right and then we can take another
767:14 - reference of this
767:17 - string
767:19 - so let's see exercise 2 make it work
767:22 - don't use reborrow and count reborrowed
767:25 - don't modify assert EQ
767:28 - so we have over here an i32
767:32 - by the way this is mutable and we have
767:35 - here a closure taking no arguments
767:39 - then as you can see it captures this
767:42 - variable here all right and it mutates
767:46 - it meaning count will then hold one
767:50 - and then we just print out count
767:53 - over here we are calling disclosure
767:57 - and then we are taking a reference to
768:00 - count meaning a reference
768:05 - to an i32 right
768:10 - and then we are again calling
768:13 - this ink closure
768:16 - the closure no longer needs to borrow
768:18 - mutable borrow account therefore it is
768:21 - possible to re-borrow without an error
768:25 - so what is happening over here we have
768:28 - seen that the compiler will take the
768:31 - least restrictive approach so in this
768:34 - case it will take an
768:37 - so in this case the count variable here
768:40 - will be captured as a mutable reference
768:45 - right
768:47 - and
768:49 - that would be a problem because as you
768:51 - can see we are calling Inc and over here
768:55 - we call it again after you're defining
768:59 - an immutable reference to count
769:02 - so maybe you remember that you can
769:05 - either have one mutable reference or any
769:09 - number of immutable references but not
769:12 - both at the same time
769:14 - so this would be a problem
769:17 - so we can call here the move keyword
769:21 - meaning
769:23 - disclosure here takes ownership of this
769:27 - value now again because i32 implements
769:31 - the copy trade it means
769:33 - it will actually get a copy of count
769:37 - so count is still accessible even after
769:40 - this
769:41 - closure call right the closure will just
769:45 - take a copy of the value
769:48 - and that means we can then take an
769:52 - immutable reference again to count and
769:55 - call the closure right
769:58 - and over here the closure no longer
770:00 - needs to borrow a mutual reference to
770:03 - count therefore it is possible to
770:05 - re-borrow without an error
770:07 - so as you can see we are here taking a
770:10 - mutable reference to count again because
770:13 - we don't use this immutable borrow over
770:17 - here again after this point right so
770:21 - this is allowed
770:24 - let's see
770:25 - and as you can see this is compiling and
770:28 - here you can see that count
770:31 - has been modified
770:34 - so let's see exercise 3 make it work in
770:37 - two ways none of them is to remove take
770:38 - movable away from the code
770:41 - so as you can see we have here
770:45 - initialized a variable with a heap
770:49 - allocated i32 integer right
770:54 - then over here we have a closure and we
770:57 - capture here this movable variable
771:02 - now
771:03 - we have seen that actually the compiler
771:06 - will use the least restrictive approach
771:09 - so in this case because we have only a
771:11 - print line it will take this variable
771:14 - here as immutable reference we just need
771:18 - to print it out
771:20 - now over here we are calling the take
771:23 - function as you can see the take
771:25 - function takes an argument of any type
771:28 - but it takes ownership meaning when we
771:32 - call the take function
771:35 - with an argument the argument will then
771:40 - lose its ownership so take function will
771:44 - become the owner of movable in this case
771:48 - right and that means we can't call
771:52 - disclosure two times
771:55 - because in this case again
771:58 - the compiler will try to use the least
772:02 - restrictive approach but in this case
772:04 - it's necessary that this closure over
772:09 - here will Implement F and once so it
772:13 - only can be called one time because
772:16 - again over here move a bell when we call
772:19 - this take function it will take movable
772:22 - and take ownership of it because it's
772:25 - necessary for the compiler to do that to
772:28 - comply with this function signature but
772:31 - what we can do is we say we want a
772:34 - reference right
772:36 - so again the compiler will then
772:39 - implement the F and trade for this for
772:43 - disclosure meaning
772:45 - it can be called two times now we will
772:49 - see a lot of more example of these FN
772:51 - trades so don't worry
772:53 - it just means now because we just need
772:58 - over here immutable references the
773:00 - compiler will actually capture
773:03 - this
773:05 - variable here as an immutable reference
773:08 - right so nothing gets moved inside this
773:12 - closure and movable will remain the
773:15 - owner of the data
773:19 - for comparison the following code has no
773:22 - error
773:23 - foreign
773:25 - so as you can see we have again a heap
773:28 - allocated integer and we have here a
773:31 - closure now as you can see we use the
773:34 - move keyword here
773:36 - and in this case disclosure will capture
773:39 - the movable variable only as an
773:43 - immutable reference because we here only
773:46 - print out the variable we don't need an
773:50 - we don't need a mutual reference and we
773:52 - don't need to take ownership so we can
773:55 - call this closure two times without any
773:59 - problem
774:01 - type in third the following foreclosures
774:04 - has no difference in input and return
774:07 - types
774:10 - so this is actually a function not a
774:13 - closure but as you can see all of them
774:16 - are exactly the same so we can skip the
774:19 - type annotations and we can even skip
774:22 - the curly braces if it is declared on
774:26 - the same line
774:27 - so this over here is exactly the same as
774:31 - writing it like that
774:34 - so over here we have an example closure
774:37 - taking one argument and just returning
774:39 - that argument so then
774:42 - V over here
774:44 - call the example closure with a string
774:49 - meaning
774:50 - over here this would be the argument
774:53 - provided and it returns a string
775:00 - now when you define a closure
775:04 - and call it with a concrete value the
775:07 - compiler will then infer the types of
775:11 - the arguments and the return type so in
775:14 - this case the compiler will annotate the
775:16 - types like that
775:28 - right we take an argument of type string
775:32 - and return the string
775:35 - and that means
775:37 - that we then can't call the closure
775:40 - again with another type
775:43 - this would cause an error okay what we
775:47 - have to do is to convert that to a
775:50 - string
775:51 - let's do it like that so we get back a
775:54 - string here
775:59 - and this is compiling
776:02 - so let's see FN F and mute FN once when
776:06 - taking a closure as an input parameter
776:09 - the closures complete type must be
776:12 - annotated using one of the following
776:15 - trades
776:16 - FN the closure uses the captured value
776:19 - by reference F and mute the closure uses
776:23 - the captured value by mutable reference
776:26 - F and once the closure uses the captured
776:29 - value by value basically taking
776:33 - ownership
776:35 - alright so make it work by changing the
776:39 - trade Bound in two ways
776:42 - so when a function accepts a closure as
776:46 - an argument we have to actually
776:50 - Define what will be the type of the
776:53 - arguments to the closure and the return
776:56 - type of the closure right
776:59 - and we
777:02 - over here can see that a closure
777:04 - implements one of these
777:07 - three trades all right
777:11 - now over here in the fn1's function we
777:15 - Define that the fund argument must be of
777:19 - type f
777:21 - and here we Define the trade bound so F
777:25 - must be a type that implements F and
777:28 - ones
777:29 - taking as argument U size and returning
777:33 - a Boolean value
777:35 - all right
777:37 - and
777:39 - inside this function over here we are
777:42 - just calling the provided func closure
777:45 - and providing its arguments
777:51 - so as you can see we have here a vector
777:55 - [Applause]
777:57 - and we call the FN ones function with an
778:02 - argument of a closure as you can see we
778:05 - can't pass a closure as a function
778:08 - argument
778:10 - now in this case disclosure will
778:14 - implement the fn1 straight right
778:18 - basically meaning it will take ownership
778:21 - of the captured values and it can be
778:25 - only called once
778:28 - so it takes as argument
778:32 - a a type of view size right
778:37 - so
778:41 - and this is necessary here because we
778:44 - are comparing the provided argument 3
778:47 - and 4 with the return value of the Len
778:52 - method right this land method is defined
778:55 - on vectors and it will return EU size so
779:00 - that over here has to be of hue size we
779:04 - have to Define that
779:06 - and all this does is we can provide
779:08 - disclosure an argument and it will check
779:12 - is for example 3 over here is it the
779:17 - same as the length of this vector
779:21 - now the problem here is that we have to
779:25 - change the trade bound because at the
779:28 - moment we are calling the funk closure
779:31 - passed as argument to this function two
779:34 - times while it implements FN once
779:37 - meaning it can only be called once now
779:42 - what we can do over here is we take FN
779:45 - right basically just taking an immutable
779:50 - reference of a captured value now the
779:53 - captured value in this closure here
779:56 - would be X right this vector
779:59 - acoustic because the closure captures it
780:03 - from the environment it is defined in
780:07 - and this should actually work let's see
780:13 - as you can see when we pass this closure
780:16 - to this function and we Define here the
780:20 - closure must implement the FN trade
780:23 - taking a u sizes argument and returning
780:26 - a bull
780:27 - then we are calling the closure right
780:31 - Funk here
780:33 - holds a closure so we are calling it
780:36 - with three in this case this would
780:38 - evaluate to true because the length of
780:42 - vac is three elements right so x dot
780:46 - length will return three meaning it's
780:49 - equal to the provided argument and four
780:52 - of course would return false
780:58 - so we are here initializing a string
781:01 - and over here we are defining a closure
781:04 - it takes an argument and it then
781:08 - modifies the string over here basically
781:11 - pushing the string that was provided in
781:14 - the argument
781:20 - then we are calling the exact function
781:24 - providing it this closure all right
781:29 - then let's see
781:31 - all this function does it takes a
781:34 - closure as an argument
781:37 - and then it will call the closure
781:40 - and it will pass it a string literal
781:43 - right
781:45 - meaning
781:47 - that
781:48 - to this string as
781:51 - this string literal will be pushed right
781:54 - so after calling this closure
781:57 - s should then hold
782:00 - hello
782:02 - all right
782:04 - and then we just print out s
782:08 - now what would be the appropriate trade
782:12 - Bound for this closure
782:16 - think about it we have FN FN mute and FN
782:22 - once so what would be the least
782:25 - restrictive approach
782:28 - it would be FN mute right
782:31 - because we are mutating here this string
782:34 - the captured value
782:37 - but we don't need to take ownership in
782:40 - order to be able to mutate it right now
782:44 - we have to provide the argument this
782:46 - would be of type string slice right we
782:50 - are passing here at this string literal
782:51 - which is string slice
782:54 - and then we have to provide a return
782:57 - type
782:59 - so actually
783:02 - this won't return anything right so we
783:05 - don't here have to provide
783:08 - a return type so let's see if this works
783:19 - and as you can see we have here a
783:21 - lifetime parameter
783:25 - and this is just ensuring that
783:28 - the past string literal here
783:31 - is actually outliving
783:35 - this function exact right which is the
783:38 - case because string literals remember
783:40 - are static lifetime
783:43 - they live the entire duration of the
783:46 - program and as you can see when we print
783:49 - out s it has successfully been modified
783:54 - so it's sufficient to use here F and
783:58 - mute but if we want we can even take
784:00 - ownership
784:02 - but then we have the Restriction that we
784:05 - can only call this closure one time
784:08 - right
784:10 - so if we try that
784:14 - as you can see this is working two
784:19 - which trade does the compiler prefer to
784:22 - use FN the closer uses the captured
784:25 - value by reference
784:27 - FM mute the closure uses the captured
784:30 - value by mutable reference
784:33 - fn1 stick closure uses the captured
784:36 - value by value
784:38 - on a variable by variable basis the
784:41 - compiler will capture variables in the
784:44 - least restrictive manner possible
784:48 - for instance consider a parameter
784:50 - annotated as fn1s to specify that the
784:55 - equation May capture
784:57 - T by reference by mutable reference or
785:00 - taking ownership but the compiler will
785:03 - ultimately choose based on how the
785:06 - captured values
785:08 - based on how the captured variables are
785:11 - used in the closure
785:13 - which trait to use is determined by what
785:16 - the closure does with captured value
785:21 - this is because if a move is possible
785:24 - then any of borrows should also be
785:27 - possible note that the reverse is not
785:30 - true if the parameter is annotated as FN
785:33 - then capturing variables by Mutual
785:36 - reference or by T is not allowed
785:43 - let's see number seven fill in the blank
785:45 - a function which takes a closure as an
785:48 - argument and calls it f denotes that f
785:51 - is a generic type parameter so as you
785:55 - can see we have here the function apply
785:57 - and it takes as an argument a closure
786:00 - and all it does it will then call
786:04 - disclosure right and we have here to
786:07 - define the trade Bound for the provided
786:10 - closure
786:12 - a function which takes a closure and
786:14 - returns an i32
786:17 - so over here we have applied to three
786:19 - again taking a closure and we have 10 to
786:23 - Define here the trade bound
786:26 - the closure takes in i32 and returns an
786:29 - i32
786:32 - and again this function over here will
786:34 - just call the closure and the difference
786:37 - is it will then return The Returned
786:40 - value from the closure so as you can see
786:43 - over here it just calls the closure but
786:46 - it doesn't return anything because
786:49 - here this is a statement it's ending
786:52 - with semicolon here we omit the
786:55 - semicolon meaning the return value of
786:58 - the closure will be the return value the
787:01 - function returns
787:03 - all right
787:05 - so over here we have a string knittering
787:10 - in non-copy type to own creates owned
787:13 - data from borrowed one
787:16 - so as you can see we take a string
787:18 - literal and call the two owned method
787:22 - now the UN now the two ohms method will
787:25 - convert a string slice to a string
787:32 - capture two variables creating by
787:35 - reference and Farwell by value so over
787:39 - here we have a closure
787:42 - then greetings by reference requires FN
787:46 - so
787:48 - as you can see this closure captures the
787:52 - greeting variable now all it does it
787:56 - will print it out meaning
787:58 - to take a an immutable reference would
788:02 - be sufficient so the compiler will
788:05 - implement the FN trade for disclosure
788:08 - because it is sufficient to only take an
788:13 - immutable reference to the captured
788:15 - variable all right
788:18 - mutation forces farewell to be captured
788:21 - by mutable reference now requires FN
788:25 - mute
788:26 - so as you can see we are taking Farwell
788:29 - and we are modifying it
788:31 - now this requires far well over here to
788:35 - to capture as immutable reference again
788:39 - you can see that the compiler tries
788:41 - always to use the list restrictive
788:44 - approach
788:46 - so then the compiler will instead
788:49 - implement the FN mute trade for
788:52 - disclosure all right
788:55 - because again we capture here a variable
788:59 - which needs to be mutated then manually
789:03 - calling drop forces for well to be
789:05 - captured by value now requires FN once
789:10 - so this mem drop here allows that we
789:14 - manually dropped a value from memory
789:18 - right but this actually requires that we
789:23 - take farewell as a value right so the
789:27 - closure should take ownership of this
789:31 - variable
789:33 - meaning the compiler will now implement
789:36 - the fn1 straight for this closure
789:40 - right
789:42 - so as you can see step by step
789:44 - here an immutable reference was
789:47 - sufficient so it just implements the FN
789:50 - trade here a string got mutated so it
789:55 - takes the captured values as f
789:59 - as IMM mutable reference meaning F and
790:02 - mute is implemented and here when a
790:05 - function needs to take ownership then of
790:07 - course the captured value must be
790:10 - captured
790:12 - as owned type meaning fn1s is
790:17 - implemented
790:18 - so that means if this closure implements
790:22 - the fn1 straight it can only be called
790:25 - once because you have inside values
790:30 - that capture
790:32 - the environment values by taking
790:35 - ownership
790:37 - Quality Function which applies to
790:39 - closure
790:40 - so we call the apply function here
790:43 - providing it an argument diary
790:49 - disclosure here right
790:51 - we are calling apply and providing diary
790:56 - now let's see this would be this
791:00 - function and as we've seen
791:03 - because Farwell here gets captured by
791:09 - by value meaning the closure takes
791:12 - ownership we have to Define here that it
791:16 - will be a closure that implements the FN
791:20 - once
791:22 - trait right
791:27 - now as you can see the closure doesn't
791:29 - take any argument and it doesn't return
791:33 - anything
791:36 - so we would annotate it like that
791:39 - so again this just defines that the
791:42 - generic type f
791:44 - must implement the FN once trade
791:51 - and over here double satisfies apply to
791:54 - three straight bound so here we have a
791:57 - closure taking one argument
792:01 - and
792:03 - it Returns the result of this operation
792:07 - right so we call the apply to three
792:10 - function providing it as argument
792:13 - disclosure
792:15 - and as you can see over here apply to 3
792:20 - is a closure
792:23 - generic type f and V here
792:26 - Define that the type f must implement
792:30 - the FN trade
792:31 - and as you can see it takes as an
792:34 - argument an i32 and the return value and
792:38 - the return type will be i32
792:43 - so let's see I take disclosure here
792:49 - and disclosure was passed as an argument
792:53 - to this function and all this function
792:56 - does is it will call the closure with an
792:59 - argument of 3. now X here will be
793:03 - replaced by three
793:05 - and the return will be 2 times 3 which
793:09 - would be 6 right
793:12 - so
793:14 - disclosure then returns an i32 namely 6
793:19 - and as you can see because we omit here
793:22 - this semicolon it means that the return
793:25 - value of this closure will be the return
793:28 - value of this function
793:31 - so when we call this function over here
793:34 - the return value over here will be 6
793:40 - as you can see this is all compiling
793:46 - move closures May still Implement FN or
793:50 - FN mute even though they capture
793:52 - variables by move
793:54 - this is because the trades implemented
793:56 - by closure type are determined by what
794:00 - the closure does with the captured value
794:02 - not how it captures them the move
794:06 - keyword only specifies the letter
794:09 - so the move keyword only specifies how
794:14 - the captured values are captured
794:18 - while the FN trades determine what the
794:23 - closure does with the captured values
794:27 - so as you can see we have here a string
794:30 - and we have here a closure
794:33 - with the move keyword meaning
794:37 - values will get moved inside disclosure
794:40 - now because over here as you can see as
794:43 - in this case
794:45 - doesn't need to be taken as value so the
794:50 - closure doesn't need to take ownership
794:52 - of the data because it will just print
794:55 - it out right so an immutable reference
794:58 - would be sufficient
795:01 - and that's exactly what this says so
795:04 - over here as you can see we are calling
795:07 - the exec function with this closure
795:11 - and when we see over here the exact
795:13 - function takes us an argument a closure
795:17 - that implements the FN ones
795:22 - trade all right so it will in fact take
795:26 - ownership of the captured value
795:30 - and then in the function itself it will
795:32 - just call the closure and Returns the
795:35 - return type of the closure
795:38 - now over here as you can see again we
795:41 - have a string and we have a closure even
795:45 - though we have the move keyword as you
795:47 - can see we Define here that the provided
795:50 - closure to exec only has to implement TF
795:55 - and trade so the string s here will get
795:59 - moved so basically this closure here
796:02 - takes ownership
796:04 - but we can still Define disclosure over
796:06 - here to just Implement FN
796:10 - because again
796:12 - even though we are taking ownership we
796:15 - are just printing out right
796:18 - the difference between move and the
796:21 - event rates is
796:23 - the event rates
796:25 - Define what the closure does with the
796:28 - captured values and move defines how it
796:33 - captures them so it would capture here
796:35 - by taking ownership
796:37 - but the FN trait only defines what are
796:44 - we doing with the captured value in this
796:48 - case you're just printing it out meaning
796:50 - an immutable reference would be
796:53 - sufficient so we can even here pass FN
796:56 - and it still would work
797:01 - fill in a blank so over here we have a
797:03 - string
797:05 - and this would be a closure that takes
797:08 - an argument and returns a string
797:12 - now what we do over here is pushing to
797:17 - this string the provided argument right
797:20 - and then what we do is we will return s
797:27 - meaning the string right
797:31 - so when we call over here this function
797:34 - and provided the closure
797:37 - then we have to implement the FN once
797:41 - rate
797:43 - and it will take as an argument
797:47 - a string literally let's annotate that
797:50 - with the lifetime parameter a
797:55 - and
797:57 - it will return a string right
798:04 - so this would be
798:07 - so this would be the trade bound we are
798:10 - defining here
798:12 - now why did I Implement here FN once or
798:16 - why did I Define that F over here the
798:19 - type of the argument must implement the
798:22 - fn1 straight because as you can see we
798:25 - are capturing s
798:28 - and modify it now over here it would be
798:31 - sufficient to use an FN mute right
798:38 - now
798:41 - again it would be sufficient to just use
798:44 - a mutable reference to S but again we
798:48 - are here returning as right we are
798:53 - returning this captured variable
798:57 - meaning we must be the owner to return
799:00 - something
799:01 - so we have to Define that F should
799:04 - implement the fn1 straight
799:07 - right because we are here returning s
799:10 - meaning
799:12 - the closure must be the owner in order
799:15 - to return it
799:17 - let's see
799:21 - and this is compiling
799:24 - input functions since closure can be
799:27 - used as arguments you might wonder can
799:29 - we use functions as arguments too and
799:33 - indeed we can
799:35 - so as you can see we have here the call
799:37 - me function
799:39 - Implement call me to make it work
799:42 - and over here we have a normal function
799:45 - just printing out something and in main
799:47 - here we have a closure right also just
799:52 - printing out something
799:54 - then we call the call me function here
799:57 - two times one time with a closure and
800:01 - one time with a function
800:04 - and
800:06 - that means let's see
800:09 - first of all we Define we want here A
800:13 - type f which is generic okay so we have
800:17 - to Define here a generic type parameter
800:20 - and then of course we have to define a
800:23 - trade bound right
800:27 - so
800:28 - in this case over here we are not
800:31 - mutating anything and we don't need to
800:34 - take ownership
800:35 - and in fact over here we don't even
800:38 - capture any variables right
800:41 - it will just print out something
800:44 - and it doesn't capture anything so in
800:47 - this case FN
800:49 - so in this case the F and rate is
800:51 - sufficient right and by the way they
800:54 - don't take any argument and they don't
800:57 - return anything
800:59 - so let's see
801:04 - and this will be the output so we call
801:07 - call me providing it to closure the
801:09 - closure implements CFN trade and then
801:13 - call me we'll just call the provided
801:16 - function and closure
801:19 - right
801:20 - meaning when they are called they will
801:22 - just print out this over here
801:26 - course closure first because closure has
801:29 - been called first
801:33 - let's see exercise 10 closure as return
801:36 - types returning a closure is much harder
801:40 - than you may have thought of now it's
801:43 - actually not that hard but you will see
801:46 - fill in the blank using two approaches
801:48 - and fix the error
801:51 - so as you can see we have here the
801:53 - create FN function and we have to Define
801:56 - here the return type so let's first see
802:00 - we have over here a variable that is
802:03 - declared inside the function meaning num
802:07 - will only live as long as this function
802:11 - lives right
802:13 - and then over here we are returning a
802:18 - closure notice we omit here semicolon
802:21 - meaning
802:22 - this whole closure will actually be
802:25 - returned by the function
802:28 - and when we go into main as you can see
802:32 - we call the create FN function
802:36 - then this function should return a
802:39 - closure meaning F and plane will hold a
802:43 - closure basically F and claim will look
802:46 - something like that
802:50 - right
802:51 - holding a closure meaning we then can
802:54 - call the FN plane closure with a
803:00 - integer all right
803:02 - because we have to Define here that X
803:05 - should be of type i32 because we here
803:09 - capture num which is of type i32
803:13 - remember when we perform an operation
803:16 - both values must be of the same type
803:20 - now let's see
803:24 - we call the create FN function
803:28 - then we initialize the num variable
803:32 - and then we have here the closure that
803:36 - will get returned meaning num here will
803:40 - capture this variable
803:44 - and
803:46 - when we then call the closure over here
803:49 - that will get returned by create FN
803:53 - then we provided a value of 1 meaning X
803:57 - will be 1 and num will be 5.
804:02 - right
804:05 - meaning the value the output should be
804:08 - 16.
804:11 - when calling
804:13 - let's write it here after calling the
804:17 - closure itself the output should be 6.
804:20 - now let's see
804:23 - first of all we have to think about how
804:26 - is this num variable captured
804:29 - now again the compiler will use the list
804:33 - restrictive approach so it will just
804:36 - take a reference
804:39 - problem here is
804:42 - that we actually return this closure
804:46 - right so num actually must outlive
804:51 - this function otherwise when we return
804:54 - the closure and num
804:57 - gets out of scope then over here we hold
805:00 - a closure that refers to something that
805:04 - got out of scope so let's use the move
805:08 - keyword here meaning num gets moved into
805:12 - the closure so the closure will become
805:15 - the owner of this
805:20 - variable all right
805:24 - now again here we can use static
805:27 - dispatch or dynamic dispatch now I will
805:31 - go first with static dispatch
805:34 - so in this case we want to return a type
805:38 - that implements the FN trait right
805:41 - because over here we have the closure
805:44 - that we want to return
805:47 - so let's Implement that
805:51 - disclosure should implement the FN trait
805:55 - and
805:57 - again over here FN is sufficient
806:01 - because
806:06 - even though we have captured the num by
806:09 - ownership the actual closure
806:12 - only performs an operation so it doesn't
806:15 - modify num
806:17 - and remember move defines how we capture
806:21 - the closure and the FN trades Define
806:25 - what
806:27 - the closure will do with the captured
806:30 - value alright so FN here is sufficient
806:34 - and disclosure takes as an argument in
806:37 - i32
806:40 - right because the argument and the num
806:42 - variable must match because we are
806:45 - performing an operation on them
806:48 - and the return type should also be i32
806:52 - all right
806:55 - the result of this operation
807:00 - so let's see
807:04 - and this is compiling now let's actually
807:10 - see the output
807:21 - as you can see the output will be 6.
807:25 - now this is using static dispatch now we
807:29 - can also use Dynamic dispatch remember
807:32 - when you when dealing with trade bounds
807:35 - like this
807:37 - we then have to basically box this
807:43 - over here
807:45 - and we put this over here into a box
807:50 - right
807:52 - this would then be a trade object we are
807:56 - using Dynamic dispatch here
807:58 - so let's see
808:03 - and this is also working so we have
808:06 - implemented the return type in two
808:09 - approaches
808:12 - fill in the blank and fix the error
808:15 - so as you can see we have the function
808:17 - Factory taking one argument of type i32
808:21 - over here we have a variable of type i32
808:26 - and if x the provided argument is bigger
808:31 - than 1 then this will be returned
808:35 - and else if it is smaller than one
808:39 - disclosure will be returned so using
808:43 - here the static dispatch approach
808:45 - doesn't work okay we cannot do something
808:49 - like that
808:55 - because over here
808:58 - we don't know exactly which closure gets
809:02 - returned and as you've noticed they are
809:05 - identical right but in fact disclosure
809:10 - is different than this because
809:13 - these have been both declared and they
809:16 - are located in different memory
809:20 - locations all right
809:23 - so even though they are exactly the same
809:27 - the compiler can't know at compile time
809:30 - which of these closures will get
809:34 - returned because they live at different
809:37 - memory locations
809:40 - now what we can do over here is using
809:43 - the dynamic dispatch approach
809:47 - so for that again we are boxing these
809:50 - closures
810:00 - and we Define here that the return type
810:03 - will be a box
810:08 - that holds a trait object namely a trade
810:14 - object that implements the FN trait
810:17 - taking as argument and i32 this x here
810:21 - and returning an i32
810:27 - right let's see
810:33 - right and we have to provide here the
810:36 - main function because otherwise the
810:39 - program won't compiled
810:43 - and this is compiling alright see you in
810:47 - the next topic
810:50 - so iterators will be the last topic we
810:53 - will cover together so let's Dive In
810:56 - iterator allows to perform a task on a
811:00 - sequence of items in turn
811:03 - iterators are lazy meaning they have no
811:06 - effect until methods are called that
811:09 - consume the iterator to use it up
811:13 - all iterators implement the iterator
811:16 - trade which provides the next method
811:19 - which gets called automatically when
811:22 - traversing over some data
811:25 - and some methods consume the iterator
811:28 - While others produce a new iterator from
811:32 - the provided iterator let's see the
811:35 - iterator pattern allows us to perform
811:37 - some tasks on a sequence of items in
811:41 - turn an iterator is responsible for the
811:44 - logic of iterating over each item and
811:48 - determining when the sequence has
811:50 - finished
811:52 - so
811:54 - over here we have a vector and then we
811:57 - are iterating over the elements in this
812:01 - vector
812:03 - and as you can see the variable X will
812:05 - hold in each iteration one element of
812:10 - the vector
812:12 - so when we print that out
812:15 - as you can see in each iteration it will
812:18 - just print out X which means X in the
812:21 - first iteration is 1 then 2 and then 3.
812:26 - in the code buff you may consider for as
812:30 - a simple Loop but actually it is
812:32 - iterating over an iterator by default
812:36 - the for Loop will apply the into ether
812:39 - to the collection and change it into an
812:42 - iterator as a result the following code
812:45 - is equivalent to the previous one
812:48 - so this is happening implicitly
812:52 - that V over here this vector or really
812:56 - any collection
812:58 - will be called with this into either
813:01 - method meaning this collection will be
813:05 - converted to an iterator right
813:09 - and then we Traverse over each item
813:14 - so let's see exercise one refactoring
813:17 - the following code using iterators so we
813:20 - have here an array holding 10
813:24 - Elements which are all zero
813:29 - something like that okay 10 times
813:33 - then we have here a for loop iterating
813:36 - from 0 to array length where the actual
813:40 - length is excluded meaning from 0 to 9
813:44 - right 10 times
813:46 - and then we just index into this array
813:49 - and print out the
813:51 - and print out the element living at the
813:55 - specific index
813:57 - so when we execute that as you can see
814:00 - we print out 10 times 0.
814:03 - now again we don't have to use this
814:05 - syntax we can just pass here
814:08 - the array itself
814:11 - and it will do exactly the same
814:15 - and we have seen that the compiler
814:17 - implicitly will put that into an
814:20 - iterator
814:21 - like that
814:25 - and as you can see this would be the
814:28 - exactly same thing
814:30 - one of the easiest ways to create an
814:33 - iterator is to use the range notation
814:37 - so over here we are initializing an
814:39 - empty vector right then we want to
814:43 - iterate here over a range and in each
814:46 - iteration we are just pushing n to the
814:50 - vector
814:51 - now in the end the length of this Vector
814:54 - should contain 100 elements right so
814:59 - what we can do over here is going from 0
815:01 - to 100 meaning 100 is excluded going
815:06 - from 0 to 99 meaning the vector will
815:09 - then hold
815:10 - elements from 0 to 99.
815:19 - like that right 100 elements
815:26 - and this will compile
815:29 - next Method All iterators Implement a
815:33 - trait named iterator that is defined in
815:36 - the standard Library
815:38 - as you can see this is the iterator
815:40 - trade that is defined in the standard
815:43 - Library it has an Associated type item
815:46 - which basically refers to the type
815:51 - we are iterating over for example a
815:55 - vector of u8
815:57 - then the item type will be u8 right and
816:03 - as you can see each type that implements
816:06 - the iterator trade will need to will
816:10 - implement the next method taking a
816:13 - mutable reference to the instance and
816:16 - returning an option containing
816:20 - the type of the associated type defined
816:23 - here
816:24 - and we can call the next method on
816:27 - iterators directly
816:30 - so over here we have a vector
816:34 - and
816:40 - we can then put that into an iterator
816:43 - right
816:45 - so this will then actually hold an
816:47 - iterator right and not a vector anymore
816:51 - so we put this collection into an
816:54 - iterator meaning we then can use the
816:57 - next method that is implemented for the
817:01 - iterator type and that is actually
817:04 - exactly what is happening when you are
817:06 - doing a for Loop for example in the back
817:10 - the rascompiler will just call next all
817:15 - the time until it reaches a point where
817:18 - there is a non-return because remember
817:21 - this next method will return an option
817:25 - type
817:27 - so
817:29 - when we put that into an iterator and
817:32 - call next we will get a sum
817:36 - and the first element right
817:39 - then sum and two
817:42 - and
817:43 - as you can see
817:45 - we don't have any more elements so it
817:48 - will return Norm right this is the
817:51 - option type and we have covered that
817:59 - and when we put a collection into an
818:02 - iterator it should be mutable right so
818:06 - the next method takes a mutable
818:09 - reference we have seen so we have to
818:13 - make it mutable
818:15 - all right
818:17 - into iter eater and iter mute in the
818:20 - previous section we have mentioned that
818:23 - 4 will apply the into ether to the
818:25 - collection and change it into a iterator
818:28 - however this is not the only way to
818:31 - convert collections into iterators into
818:34 - either eater and intermute all of them
818:37 - can convert a collection into an
818:40 - iterator but in different ways so into
818:44 - ether consumes The Collection once the
818:46 - collection has been consumed it is no
818:49 - longer available for reuse because its
818:52 - ownership has been moved within the loop
818:56 - ether dispers each element of the
818:59 - collection through each iteration thus
819:02 - leaving the collection untouched and
819:04 - available for reuse after the loop
819:08 - and it remute this mutably borrows each
819:12 - element of the collection allowing for
819:14 - the collection to be modified in place
819:20 - so as you can see we have here a vector
819:30 - then we Loop over this Vector here right
819:37 - and
819:39 - all we do here is actually printing out
819:42 - each of the elements
819:45 - now we have seen that implicitly the
819:48 - compiler will call here into iter
819:50 - meaning the iterator will become the
819:54 - owner of this data right so we can't
819:57 - reuse
819:59 - these are after we have put it into this
820:03 - iterator
820:04 - but there is not a solution we
820:09 - can just use either here because it's
820:12 - sufficient that we have a mutable
820:15 - because it's sufficient here that we
820:18 - have an immutable reference right we
820:20 - just want to print it out we don't need
820:23 - to mutate anything or anything else we
820:26 - only need read only data right so let's
820:29 - see
820:32 - and as you can see
820:34 - we then iterate over each element
820:36 - printing it
820:38 - this over here and then we can reuse the
820:42 - collection over here so ownership hasn't
820:46 - been transferred into this iterator
820:50 - five fill in the blank so over here we
820:53 - have a vector
820:55 - with string literals okay
820:59 - and then over here we are iterating over
821:02 - the elements in this vector
821:05 - now as you can see
821:07 - we are here matching the element
821:12 - and if it is immutable reference to the
821:16 - string literal fairies then we will
821:20 - actually modify
821:24 - the elements that we are iterating at
821:28 - this exact moment to this over here
821:32 - if it is anything else then it will be
821:35 - replaced by hello right
821:38 - so in the first iteration
821:43 - name will hold a string literal this
821:47 - over here then we match this and in this
821:51 - case this arm will match meaning we
821:55 - assign string literal hello to this
822:00 - element right so instead of Pop we would
822:03 - then have hello in the first index
822:07 - right
822:08 - so as you can see we are mutating
822:11 - meaning we can here use either mute
822:14 - right we want to take mutable references
822:18 - from this vector but as you can see over
822:22 - here we are again using these names
822:25 - Vector meaning we can't take ownership
822:28 - so let's see
822:33 - and this is compiling and as you can see
822:36 - the first two elements got replaced by
822:39 - hello and the last one ferries has been
822:43 - matched here right name holds a mutable
822:47 - reference to the string slice Ferries
822:52 - and that's why this will get returned
822:54 - meaning it will be assigned to this
822:58 - element
823:01 - let's see exercise 6 fill in the blank
823:04 - as you can see we have here a vector
823:07 - now over here we want to put this Vector
823:11 - into an iterator right now before we do
823:16 - that as you can see this is the vector
823:19 - in the beginning and this is how it
823:22 - should look like in the end so we want
823:24 - to mutate the first element
823:27 - so in this case we take it as mutable
823:32 - references calling The Ether mute method
823:37 - right so we take from here mutable
823:40 - references of the elements in this
823:43 - vector
823:44 - then over here we can call the next
823:47 - method
823:49 - which will then give us back an option
823:52 - type of the first element right so we
823:55 - pet our match here some with the inner
823:58 - value and then what we can do because we
824:02 - get here
824:03 - a new to the reference meaning we can
824:06 - dereference it and assign it a new value
824:09 - like that
824:13 - so we get no output let's actually see
824:16 - the elements
824:31 - as you can see we changed the first
824:33 - element we have mutated it using ether
824:37 - mute right getting bad getting back
824:41 - immutable reference to the elements
824:45 - creating our own iterator we can not
824:48 - only create iterators from collections
824:50 - type but also can create iterators by
824:54 - implementing the iterator trade on our
824:57 - own types
824:59 - so as you can see we have here a custom
825:01 - type counter which has one field and we
825:05 - Implement here the associated function
825:08 - new
825:10 - basically just creating an instance
825:15 - and then over here we implement the
825:18 - iterator trade for counter right
825:22 - so first of all we have to give the
825:25 - associated type a concrete type in this
825:28 - case u32 right basically the type this
825:34 - field is holding
825:36 - then we implement the next method as you
825:40 - can see next takes a mutable reference
825:42 - to the instance and it returns
825:46 - an option
825:48 - that holds a type of the associated item
825:52 - here
825:54 - right it would be u32 in this case
825:57 - so if self.count is less than 5
826:01 - then we increment the count field here
826:05 - and we return
826:08 - the
826:09 - actual count
826:11 - otherwise we return none so if self to
826:16 - account is bigger than 5 then it returns
826:19 - none so as you can see we are then
826:21 - creating a new instance of this counter
826:24 - type
826:25 - using the new Associated function
826:30 - and then as you can see when we call the
826:33 - next method on it right because we can
826:37 - do that because we have implemented the
826:40 - iterator trade for our custom type
826:43 - so when we do that we just get back
826:47 - T value of count as you can see
826:50 - when calling next
826:53 - then over here it checks is the self to
826:57 - count field less than five
826:59 - in this case it is right we didn't
827:02 - increment it so far so it should hold
827:05 - zero
827:07 - and in that case it will increment it by
827:09 - one right the count field over here gets
827:12 - incremented by one
827:14 - and then it returns it
827:17 - and of course packing it into a sum
827:21 - because we return here an option type
827:25 - so that means we get one in the next
827:28 - iteration we get 2 3 4 5 and then as you
827:33 - can see the count field holds a value of
827:37 - 5 meaning this won't get
827:41 - meaning this would evaluate to false and
827:44 - this will get executed right so we will
827:47 - get back a non
827:51 - and over here we have Fibonacci so the
827:55 - Fibonacci sequence
827:58 - starts at zero then one then zero plus
828:02 - one is one then one plus one is two then
828:07 - one plus two is three
828:09 - two plus three is five five plus three
828:12 - is eight and so on right
828:16 - and as you can see we have here distract
828:19 - Fibonacci that has a current field and a
828:23 - next field
828:24 - so as you can see current for example
828:26 - would hold zero and next would hold one
828:32 - and as you can see we are implementing
828:35 - the iterator for Fibonacci
828:40 - so we Define here the return type to be
828:44 - u32 right or basically the type of the
828:48 - items we are iterating over so these
828:52 - both of these fields hold u32
828:56 - and
828:57 - over here we have a function Fibonacci
829:00 - which just returns an instance of the
829:04 - Fibonacci struct with current holding 0
829:07 - and next holding one
829:10 - so notice something here when we call
829:13 - next we actually want to return someone
829:16 - and not some zero so this is important
829:20 - but let's now implement the next method
829:23 - so we have seen that it will return
829:25 - option type holding self item
829:30 - write the type that is defined in the
829:33 - associated type item
829:37 - and then over here I will create a new
829:40 - variable forward
829:42 - and this would then be self dot current
829:46 - plus cells dot next
829:49 - right because
829:53 - so forward in this example would be zero
829:56 - plus one right this would equal one
830:00 - so we can then
830:03 - to go one step forward we want to go
830:07 - like this and then like this right
830:10 - we can assign to self current
830:15 - self next
830:19 - meaning
830:21 - in the next iteration the current field
830:24 - will hold one right
830:28 - and self.next
830:33 - will hold forward
830:35 - right self to current plus self dot next
830:39 - meaning in the next iteration next we'll
830:43 - hold one so we will be at this point
830:45 - right
830:47 - and then all we need to do is we wrap it
830:50 - in sum because again we return an option
830:53 - and we return the current
830:57 - a field over here
831:01 - let's see
831:05 - methods that consume the iterator
831:09 - the iterator trade has a number of
831:11 - methods with default implementations
831:13 - provided by the standard Library
831:16 - consuming adapters some of these methods
831:19 - called the method next we use up the
831:22 - iterator so they are called consuming
831:25 - adapters
831:26 - so over here we have a vector
831:29 - and we put that into an iter notice we
831:33 - take here the iter method meaning it
831:36 - will just take immutable references to
831:39 - the elements
831:41 - and then we call on this iterator this
831:44 - sum method the sum method will take the
831:47 - ownership of the iterator and iterates
831:50 - through the items by repeatedly calling
831:53 - next method
831:55 - right so all this sum method does it
831:58 - will just add together all the elements
832:00 - in the vector notice sum will take
832:04 - ownership of this iterator meaning we
832:08 - can't use V1 eater again right so in
832:13 - this case the total will be six
832:15 - now I can't edit here let's see it in
832:19 - the playground
832:33 - so we have here a vector
832:37 - and then we put it into an iterator and
832:41 - then we call the sum method on the
832:43 - iterator
832:45 - meaning this should then hold
832:47 - i32 and the value should be 6 right just
832:53 - adding all of these together
832:55 - now that means we can't use V1 either
832:58 - again here this is not possible because
833:01 - it is some method will take ownership of
833:06 - the
833:07 - V1 eater
833:09 - variable
833:11 - let's see
833:13 - as you can see this is compiling
833:17 - let's actually print out the result
833:30 - as you can see we would have six
833:37 - collect other than converting a
833:40 - collection into an iterator we can also
833:43 - collect the result values into a
833:45 - collection collect will consume the
833:48 - iterator
833:49 - so over here we have
833:52 - an array
833:54 - which holds two tuples right
833:58 - and each Tuple has as
834:01 - and each Tuple has a string literal and
834:05 - an i32 right
834:08 - then we take this names array here put
834:12 - it into an iterator notice here into
834:15 - either meaning we take ownership of
834:18 - these elements
834:19 - and then we collect meaning we collect
834:23 - it into another collection which has to
834:26 - be annotated here
834:28 - meaning we will then create a hash map
834:31 - with string literals as keys
834:35 - and i32 values right then we print it
834:41 - out here and over here we have a vector
834:44 - of i32 types
834:47 - and we call The Ether method over here
834:52 - meaning we just take references
834:55 - to this vector and then over here we
834:59 - call collect
835:00 - meaning it will get collected
835:04 - into an iterator right because we want
835:08 - here V2
835:10 - meaning
835:13 - and then we annotate here that we want a
835:16 - vector of i32 because as you can see V2
835:20 - should hold a vector with these elements
835:24 - let's see
835:27 - and actually over here we would have
835:30 - references of i32s right because again
835:35 - ether here takes references of these
835:39 - elements meaning they would not equate
835:42 - we want a vector of I 32 elements
835:46 - meaning we can call the input ether
835:49 - and that means
835:51 - ownership of these elements will be
835:55 - transferred to V2 and this would be the
835:58 - output of the print line over here we
836:01 - are printing here out the hash map we
836:04 - have converted
836:07 - iterator adapters methods allowing you
836:10 - to change one iterator into another
836:12 - iterator are known as iterator adapters
836:16 - you can chain multiple iterator adapters
836:19 - to perform complex actions in a readable
836:22 - way but because all iterators are lazy
836:26 - you have to call one of the consuming
836:29 - adapters to get results from calls to
836:32 - iterator adapters so over here fill in
836:35 - the blanks we have a vector
836:38 - and we iterate over the elements just
836:41 - taking immutable references alright then
836:45 - over here you can see we want to modify
836:48 - the elements inside this Vector to look
836:51 - something like that basically just
836:53 - incrementing each element
836:56 - now we can use here map
837:00 - to do that
837:05 - right
837:06 - Now map will create
837:09 - another iterator it will take ownership
837:12 - of this iterator here
837:15 - and it will then
837:18 - create another iterator
837:21 - right but with the
837:24 - modified elements and then we can call
837:27 - here collect
837:28 - to actually put it into a collection
837:31 - meaning this Vector over here
837:34 - let's see
837:39 - all right this is compiling I guess this
837:41 - would be i32
837:43 - so we have taken it from this vector
837:47 - so this is compiling
837:52 - let's actually output
838:03 - [Applause]
838:09 - as you can see we have modified the
838:13 - elements
838:14 - but of course
838:27 - V1 is still accessible
838:31 - and that is because we have called here
838:34 - the eater method meaning we just take
838:38 - immutable references of the elements in
838:42 - this vector
838:43 - meaning the ownership will remain at V1
838:47 - so we have now reached the end of this
838:50 - course and if you have made it this far
838:52 - then your dedication to this language is
838:56 - really impressive and this is only the
838:59 - beginning of your journey I hope this
839:01 - course was helpful
839:03 - don't forget to split the word about
839:05 - free software and I'm out

Cleaned transcript:

welcome to this rust programming course for beginners this comprehensive course will guide you step by step through the fundamentals of rust enabling you to build robust and efficient applications from understanding basic syntax and data types to exploring more advanced topics like lifetimes and closures arfan zubi will provide clear explanations and HandsOn exercises to ensure you grasp every concept effectively get ready to unlock the power of rust and elevate your programming skills to new heights hi my name is Irfan and I will be your guide in this comprehensive for us course for beginners so if you're interested in learning rust then congratulations you have found the right course so I've designed this course to ensure that you will learn rust the proper way using slides and visuals to illustrate Concepts and providing exercises we will solve together this means you will have an appropriate mix of theory and practice that will help you step by step mastering this new awesome programming language and I strongly advise you to code along because you will learn so much more when actively participating rather than just watching the video so let's Dive In so what are the goals of this course first and foremost getting familiar with Core Concepts and syntax of the language we will take a look at data types and data structures as well as ownership and borrowing we will see how data is allocated in memory and how we access the data and we'll take a look at standard Library generics trades lifetimes and much much more basically everything you need to become a great rust developer so why would you want to learn rust now there would be I guess a thousand reasons but I have here put together some of the main ones now rust is a really fast language in terms of execution time it provides a rich type system it doesn't have a garbage collector which is part of the reason why it's so fast it provides useful compiler outputs and you will see that in the exercises we are solving it guarantees memory safety and it's the most beloved programming language since 2016 according to stack overflow meaning now seven years in a row and we are experiencing fast adoption in various branches foreign now over here you can see a table which shows various programming languages and their score in terms of Energy Efficiency and execution time and as you can see rust is one of the languages on the top of the list now over here are some resources that you can learn with now I guess the main resource would be the RAS programming language really fantastic book and I recommend you to read it then there is rustlings these are small exercises basically programs which you have to debug then there is Ross by example so if your style is more focusing code and less on text then this would be suitable for you and there is a website called rust by practice and that is what we will cover together and if you want to go more advanced there is a book called Russ forestations and it's also very much recommended to eat it so before we dive into the first topic I want to show you the website of lost by practice and you can access it by going to the URL practice dot RS and this is the website and over here as you can see these are all the topics we will cover together right now this will be the first one variables and as you can see over here we have small exercises that we will solve together now before we start I want to show you something else and of course we'll keep up with the tradition and write a hello world program so you can go to the rustlang.org website this is the official website of the rust foundation and you can click over here playground and as you can see over here you can write rascode and then execute it and it's really cool because you even have the Vim key bindings over here and you can even choose themes like that and let's write our first program so every program in Rust starts in the main function this is the starting point of execution of every rust program and we declare functions with the FN keyword so to print out to standard output we can use the print line macro as you can see we write print Ln exclamation mark and then we can provide here the string we want to Output like that and then you can hit run and as you can see we have executed our first program so congratulations I hope you coded along and now we start with the actual course so variables variables are assigned using the LED keyword so if you're coming from a JavaScript background this might seem familiar you can print to standard output by the print or print Ln macros so print and print Ln are basically very much the same but print Ln adds a new line at the end of the output and scope of a variable is defined by the block of code in which it is declared now a function is a named block of code that is reusable and shadowing allows a variable to be redeclared in the same scope with the same name so let's solve some exercises binding and mutability a variable can be used only if it has been initialized fix the arrow below with least amount of modification to the code so again we are starting always in the main function now over here we have two variables and again we declare variables with the let keyword then the name and over here we have a type annotation now don't worry too much for now we'll cover that in the next topic to come but for now think of i32 as an integer type right and then we have here the assert EQ macro which stands for assert equality so this macro takes two arguments and just basically asserts that these two are equal in case they are not equal the program will Panic meaning immediate exiting and returning an error message if there are in fact equal then the program will just continue executing so as you can see we want here that X is equal to a value of 5 so we can initialize X over here with with a value of 5 like that and to run this program you can either click here or you can press Ctrl enter and let's read that over here uninitialized but used error so when you use a variable it has to be initialized with a value which makes sense right you can't use something which isn't initialized yet now y over here is uninitialized but also unused this will only output a warning now over here you can see the warning actually but if I take this code and put it over here as you can see it gives us a warning unused variable y okay to fix that we can prepend it with an underscore like that all right use mute to Mark a variable as mutable so in Rust a variable in its nature is immutable and you have to explicitly state that you want a variable to be mutable so fill the blanks in the code to make it compile as you can see we are here using a variable X so we want over here to declare X and initialize it with a value of 1. now over here we are mutating X which means this variable X over here should be mutable and we do that using the mute keyword like that now this over here is shorthand Syntax for this all right so we take the value of one we add 2 to it and then we assign it back to X meaning X will then hold 3. right now just a quick note I will always try to annotate the type in this course most of the time it's not necessary so when you see me annotating types it's actually not because this is necessary but just because I want to make stuff as clear as possible so in this case this would hold an integer type and again we will cover that in the next topic let's see as you can see this is compiling X is equal to 3. scope a scope is the range within the program for which the item is valid fix the error below with least amount of modification so over here we are initializing the variable x with a value of 10. an integer type all right now now here we have another scope we also can call it the inner scope and this would be the outer scope right so in this scope over here we are declaring another variable y now we over here try to print out X and Y and we can do that by placing inside the print Ln macro these placeholders over here and then providing as additional arguments over here the variables we want to put the values inside here so for example if we provide X over here then this will get replaced by 10 because X is holding a value of 10. and as you can see in the outer scope we are doing exactly the same now this program won't compile and the reason is because a variable is only valid inside the scope in which it was declared so for example the variable Y is declared inside the scope meaning T variable Y is only valid until this point all right that means we can't use y here so what would be the solution solution would be very simple we just initialize the variable y in the main scope in the outer scope over here meaning X and Y both of them are valid until this point over here right because this over here is the main scope let's see as you can see this is compiling fix the error with the use of Define X now we can have other functions besides main so over here we have the function define X and as you can see we are initializing a variable X which holds a string now this would be TType annotation for a string right don't worry too much about the annotations now because we will cover that but just to let you know now the problem here is that in main we are trying to access X now in this scope over here there is no variable with the name of X which means that this program won't compile because the compiler will tell you I can't find over here a variable with the name of X so what we can do over here is actually taking this line and putting it inside the function over here because as you can see in this scope of the function a variable X has been declared and initialized but if I run this program now nothing will happen and that's because as I've said the starting point of every Ras program is in the main function now when we run the code nothing will get executed and that's because we have to actually call this function for it to do something so in this case we can call a function like that just providing the name of the function and these parentheses and as you can see the output will be hello world right because over here we are providing x to the print line macro and we are appending to it comma world like that shadowing you can declare a new variable with the same name as a previous variable here we can say the first one is shadowed by the second one only modify a sort EQ to make print Line work print 42 in terminal as you can see over here we are initializing the variable X which holds an i32 type an integer type now in this scope over here we are initializing another variable with the same name X but over here we are initializing it with a value of 12 instead of 5. and that means when we assert the value of x over here it should actually be 12 right now what would be the value of x in this outer scope if you set 5 then you're right because this variable over here has been declared in the main scope in this scope over here that means X is holding a value of 5. now in this scope over here x holds a value of 12. and these are basically two different worlds right so the variable X declared in the main scope doesn't actually care about the variable X declared in this scope over here they are separate now over here we are shadowing X in the main scope meaning we redeclare and reinitialize the variable X again with an integer type now when we output X it should actually print out 42. as you can see this will be the output number six remove a line in the code to make it compile now over here we have a mutable variable X which holds one an integer type then we are assigning 7 to X now X holds seven right then we are shadowing and rebinding so we are redeclaring X and reinitializing it and we initialize it with a value of x meaning with 7 right and then over here we are mutating X and that means we are here incrementing x by 3. again using this front end notation which would equate to that and this would actually fail and I want you to look at it and think about it what over here might cause an error so over here as you can see we are redeclaring X and over here we are mutating X now as I've said every variable in Rust is in its nature immutable meaning if we redeclare X like that X will be immutable even if it was mutable over here when we Shadow it then it will be immutable again so what we can do over here is just using the mute keyword again so X stays mutable now you might ask okay why even shadowing we can just assign a new value to X why is this even a thing and you can see that here very good so y over here holds an integer type right integer 4. now when shadowing we can assign to the variable a a value of another type in this case for example a string right so y will then hold a string type right let's run that and as you can see this compiles now this line over here is completely useless I hope you notice that because we are taking X and assign it again to X which basically is the exact same thing as we had over here so completely useless of course they are doing that to learn the concept but in real life you don't need this line all right you can just do it like that and as you can see this also compiles unused variables fix the warning below with only one solution two distinct Solutions so as you can see of course we want two stores so we will do with two solutions now the problem here is that this program won't actually output warnings right so I will again copy that and I will put it and I will put it inside the rust playground like that so if we run this program now as you can see we get a warning unused variable X now I have showed you that before the easiest method would be to prevent the variable name with an underscore as you can see we don't get the warning over here the second way would be to do it like that this is telling the compiler that it should allow unused variables so if you run it again as you can see no warning so we have solved that destructuring we can use pattern with lead to destructure a tuple to separate variables now tuples we will cover that in a later topic but for now just think of tuples as a data structure that can hold um various values even of different types so fix the arrow below with least amount of modification so as you can see over here we have a tuple right holding two integers one and two and this over here is called destructuring so we are using the let keyword and we use this syntax over here to this structure these values into variables X and Y so X will then hold a value of 1 and y will hold a value of 2. now over here we are mutating X now again this variable here would be immutable because in Rust every variable in its nature is immutable and we have to explicitly state that we want to have it mutable so what we can do over here like we did before we use the mute keyword like that and then this should actually compile so X holds one here and then we increment X by two so extrude in the nthole 3 and Y should stay the same as it was and as you can see this is compiling the structuring assignments introduced in Rust 1.59 you can now use Tuple slice and struct patterns as the left hand side of an assignment so this is very useful actually so we can declare two variables at once so here we declare X and Y and this would be the same like writing let X and let y right so you're writing one line of code instead of two lines here now again we declare here the variables and we can then destructure these data structures over here so we have here a tuple and we are destructuring it and notice over here we don't need to use the let keyword again because we have already declared these variables over here right so we assign 3 to X and this value over here we don't care about so we can use these double dots over here now this over here is an array and again we will cover that don't worry and this array holds two values now we don't care about the first one but we want to destructure the second one into a variable called y now fill the blank to make the code work in this case we have here an array right remember assert EQ takes two arguments and both of them have to be the same equate to the same output right so what would be the value of x it would be 3. because we have this structured here 3 into the variable X and the same goes for here we have this structured 2 into a variable Y which means y will then hold two all right and we are done with the first topic easy start and see you next time now let's look at numbers in Rust and we'll start with integer types now an integer is basically a whole number meaning it doesn't have a fractional part and integers can come in two different forms they can either be signed or unsigned now a signed integer can represent both positive and negative numbers and I remember that because signed might stand for the minus sign that could be prepended to it and unsigned integers are always positive integers meaning they don't have a minus sign hence unsigned now integers can come in different lengths so there can be 8bit integers 16bit 32 up until 128 bits and each length over here has two distinct types one for signed and one for unsigned so for example if we have a variable which holds an unsigned 8bit integer we would type annotate that with the type u8 or for example we have a signed 64bit integral we would annotate it as i64. now the last element in the table over here is Arc and Arc stands for architecture now that means that the size of these two types eye size and U size are dependent on the computer's architecture now I guess most of you guys today run computers with 64bit architecture meaning Isis new size have a size of 64 bits or 8 bytes All Right Now the default types in Rust are for integers i32 and for floats f64 so if we don't annotate anything the compiler will infer it to these types now my head is in the way now to make sense of all of this you will have to understand the binary number system now if you're familiar with binary just skip ahead because you don't learn anything new here but I just want to ensure that we are all on the same page so if we consider this decimal number over here 42 and let's look at each distinct digit so we would have 4 and we would have two right now 2 would be in the ones place and four would be in the tenths place and if we would have more digits here here would be the hundreds place thousands place and so on now as you can see we are here using a base of 10. why is that because in the decimal system we have 10 distinct digits to represent numbers right 0 to 9. and as you can see we are here doing an exponentiation with an exponent of zero because this is actually a mathematical rule which states that anything with an exponent of 0 will always evaluate to one so it doesn't matter which base you use if you have an exponent of 0 the result will always be one right 10 to the power of 0 would be 1 4 to the power of 0 would be one and so on and over here we have 10 to the power of 1 which would be 10 right and then what we do is just we are multiplying the digits of our number with these exponentiations right so we would for example here 4 times 10 to the power of 1 plus 2 times 10 to the power of 0. now again 10 to the power of 1 would be 10 and 10 to the power of 0 would be one and then we would multiply these numbers together and then add this and we would have 42 right something which is very natural to you and you don't even think about it right because decimal numbers are everywhere now in computers things actually look a little bit different let's for example again consider the decimal number 42 now this would be the binary representation of this number zero zero one zero one zero one zero and as you can see we have here eight digits now a digit is called bit right and a bit is the smallest possible unit of information a computer can hold okay now we have eight bits over here and eight bits make up one byte and we over here have actually the same logic as we did over here but with a base of two because again we can only represent two digits in a computer and that's because a transistor can only be in one of two states either it's conducting electric current or it's nonconducting zero or one right so the logic stays the same here we have 2 to the power of 0 which would be one because of the rule we have talked about 2 to the power of 1 would be two two to the power of 2 would be four two to the power of 3 would be eight and so on and as you notice the number here doubles one two four eight sixteen and so on now this over here is actually the fascinating part about computers to me personally because it's just crazy if you think that everything represented this video over here and graphical models and 3D games and everything is stored and represented with only two digits mindblowing right so we actually here do the same thing we are just multiplying the bits over here with the exponentiations now we won't consider the zero bits because anything multiplied by zero will always be zero right so we are just caring about the one bits over here so we are multiplying one times two to the power of one which would be 2 right because 1 times 2 would be two then one times two to the power of 3 which would equate to 8 and 1 times 2 to the power of 5 which would be 32 as you can see over here and then we are basically just adding these numbers together and we have 42 and this is the way your computer stores all of your data all right now you might ask okay how far can we go with this what would be the largest possible number we can represent and let's for that see the range of 8bit integers so the smallest possible unsigned 8bit integer would be zero right I hope this makes sense because if we have a zero in every position over here the result will just be zero right now the largest possible unsigned 8bit integer would be 255. and that's the case when every single position over here holds A1 right and again we are then just multiplying D1 by the exponentiations over here and add it together and you might now think okay 255 isn't a lot what if I want to represent bigger numbers and there is a simple solution to that you're just adding more bits over here right because the more bits we have the larger number we can represent so let's see for example a 16 bit integer again the smallest possible 16bit integer unsigned would be zero and this is if every position over here holds zero now the largest possible 16bit integer unsigned would be 65 535 okay and again this would just be if we had in every single position a one right again just adding the results of the exponentiations over here all together and we would have this result now as you can see the more bits we have the more we can represent now what about signed integers again sine integers can represent negative numbers so signed integers use a concept called tools complement where the processor will take a number over here for example 42 and this would be the binary representation of this number then it will invert this binary number meaning a 0 becomes a 1 and 1 becomes zero right just inverting and then after inverting the number we add one single bit okay so we add one here this would then equate to zero and we have a carry of one and then we add here one and we would have one and the rest says the same now this would then be the binary representation of minus 42. or negative 42. now the most significant bit over here is actually the sine bit if it is zero then it means the number is positive if it is 1 then the number is negative all right and that's why there are distinct types for signed and unsigned and the ranges for signed and unsigned integers vary right and over here we have an illustration just to see the ranges for example for I8 a signed integral of 8 Bits the range would be from 128 to 127. so the smallest possible number we can represent with a signed 8bit integer would be 128 and the largest one would be 127. and as you can see again the more bits we have the larger and smaller the integer can go right and again unsigned integers never go below zero right then we have view size and eye size so these are as I've said architecture dependent so on a 32bit architecture computer the size of these view size and eye size type would be 32 bits on a 64bit architecture it would be 64 bits and this is also called pointer sized integer type because it matches the size of a word in a given platform so what is a word you have to understand that the processor does not read one byte at a time from memory it reads one word at a time so in a 32bit processor it can access four bytes or 32 bits at a time and in a 64bit processor it can access 8 bytes or 64 bits at a time now if we look at this very simplified representation of computer memory where we have over here addresses and over here the data and each location over here holds data of one byte all right now in a 32bit architecture the size of a word is four bytes right 32 bits which means that the processor can access 4 bytes at a time so the processor will read this section over here as one word right it's basically unit of data and what you have to take from this is this statement over here you size gives you the guarantee to be always big enough to hold any pointer or any offset in a data structure so the U size type can hold memory addresses which can point to any location in computer memory that's very important so let's see floating point there are two types F32 which is of size 32 bits and f64 which is of type 64 bits now the representation of these floats are according to the IEEE 754 specification so let's look at some exercises tips if we don't explicitly assign a type to a variable then the compiler will infer one for us now remove something to make it work as you can see over here we have a variable X which holds an i32 integer right now over here we have immutable variable Y which holds an unsigned 32bit integer right so over here we are trying to assign X to Y now this would actually fail because we can't assign a variable of a type to a variable of another type it's not possible so what we can do over here to fix that is actually just omitting the type and this will then implicitly hold an i32 type right because this is the default integer type in Rust now over here we are initializing in another variable set and what would be the type of Z right it would be I 32. all right thank you fill the blank so over here as you can see we have a value 38 which is of type u8 so we can also annotate a type directly on a value meaning this value over here 38 is of type u8 now the problem here is that the variable over here V expects a type of u16 so we can't initialize a variable which expects a certain type with another type but what we can do over here is using the as keyword which basically can convert an integer type to another integer type so we can use here s and u16 this will then compile tips if we don't explicitly assign a type to a variable then the compiler will infer one for us now we know that already modify a sort EQ to make it work so over here we are initializing the variable x with a value of 5. what would be the type annotation it would be i32 right it's the default integer typing rust now in this assert EQ macro we have here a string u32 we don't worry yet about this method I will explain that in a later episode and on the other side of the assert EQ macro we have a function call so we call type of with an argument of x actually a reference to X but again don't worry we'll cover that so when we call this function over here it basically just gives us back the name of the type so if we pass X over here we would get back i32 right because this variable over here holds a value of type i32 now this boot then actually fail right because we want here that type of X returns u32 so what we can do is just changing this type annotation over here all right fill the blanks to make it work now over here we have a data type for example I8 and the constant Max now Max just Returns the largest possible number that can be represented with the mentioned data type so for example I8 Max would be 127. right this would be an assigned 8bit integer and we have seen the ranges now the max for an unsigned 8bit integral would be 255. all right fix arrows and panics to make it work now over here we have a value 251 which is of type u8 and we add 8 to it now in this case the compiler will infer the types so this would be 8 and the variable itself will hold them u8 now can you spot the problem over here the problem is we have seen that u8 can only represent up to 255 right so over here we would have 259 so this is not possible so what we can do over here is just changing that to the next bigger data type for example u16 now then we have here a data type I8 assigned 8bit integer and we call the checked add method now this is actually the same as doing it like that but in a safer way because we have to handle the error and unwrap over here we will cover that so this is actually a little bit safer but it still will panic because again the I8 cannot represent 259 it would be an overflow so again we can over here just say we want an i16 because an i16 can without problems represent 259. so V1 will then hold u16 and V2 will hold i16 . again I'm just doing this for clarity you don't have to annotate the types alright modify assert to make it work now as you can see over here we have numbers in different representations or basically in different number systems so this is decimal this is hexadecimal this is octal and this is binary okay now the decimal over here has an underscore and this is just a delimiter so this is just for readability it doesn't affect the actual value now let me convert that over here we would have 2024 this is already in decimal system then over here we would have 255 then over here we would have 63 and then over here I hope you remember this would be 255. now if we calculate this as you can see the result would be this value over here like that and this basically proves that in Rusty you can perform mathematical operations on different number systems right now floating Point fill the blank to make it work as you can see over here we have a floating point value so what would be the type I will annotate it directly so it would be f64 this is the default floating Point type right now over here we have an F 32 and over here we have an F 64. right like that again type annotations are not necessary now if we pass x to the type of function over here what would be the return value it would be f64 right make it work in two distinct ways so if we execute this program over here as you can see this would panic now the problem here is a floating Point precision the result won't be exactly 0.3 it would be something like that maybe right or something like that I don't know exactly but t floating point value is too precise because the default floating Point type is f64 so this is really precise and that's why you have these tiny fractions over here now we can solve this using an F 32 Which is less precise right like that and this succeeds now two distinct ways we can also use the as keyword like that so let me first move my head over here again so range two goals first modify Sr to make it work second make print line output 97 to 122. now over here as you can see we have immutable variable sum what would be the type annotation it would be i32 okay now over here we have a for Loop meaning we are iterating over some range and then we are executing an instruction inside this code block over here multiple times basically the times we are iterating over this range over here now in each iteration the variable I will hold a different value right so in the first iteration it would be 3 in the second iteration it would be 2 in the third minus 1 and so on until we reach 1. y1 because 2 over here is excluded and that's always the case when using this syntax the end point of the range is always excluded so we are iterating from 3 to 1 okay now let's actually do these iterations manually so we start with zero right now in the first iteration I would be 3 so 0 plus minus 3 will be minus 3 right so sum will then hold 3 now in the second iteration I will be minus two so minus three plus minus 2 will be minus five third iteration minus one minus five plus minus one will be minus six then in the next iteration I will be zero so it doesn't have any impact and in the last iteration I will be one so minus six plus one will be minus five so the value of sum after this for Loop will be minus five now over here we again have a for Loop and this time we are iterating over a range of characters namely from A to Z now this time Z over here is included because we are using the equal sign over here which means we want a range from A to Z where the end point set is included and C over here will then hold in each iteration a character so in the first one it would be a then it would be B then C and so on and we just print out the characters let's see how that looks like as you can see just printing out each character from a to z now we want to have an output of 97 to 122. so let's look at the ASCII table as you can see in memory a character would be stored as a numerical value now of course in memory everything is stored as binary numbers but it would be stored as the binary representation of these decimal numbers right here so we want to go from 97 a to 122 Z right so it's actually pretty simple instead of outputting DC as character we want to Output it as an u8 for example right and then as you can see we have the ASCII code for the characters from A to Z lowercase right then over here exercise 10 fill the blanks so we are here importing from the standard Library the Ops module range and range inclusive now we have seen the shorthand syntax and this would actually be the more verbose way to write that but I think no one actually does it this way over here we have a range which starts at one and ends at five now again five would be excluded right like that now range inclusive means we range from 1 to 5 where 5 is included and we would write that short and syntax like this one two five and five is included right let's see the last exercise in this topic computations fill the blanks and fix the errors so as you can see over here we have integer additions so one plus two will be three and the compiler over here will infer these types so because we have over here an u32 an unsigned 32bit integer it will infer these values over here to be of the same type all right now over here the same thing we have 1 minus 2 would be 1 and the compiler infers these types then over here we have 1 minus 2 which is equal minus one the problem over here is that we are dealing with an unsigned 8bit integer now remember unsigned integers can never be negative so what we can do to fix that is just converting it to an I8 assigned 8bit integer and signed integers can represent both positive and negative numbers now over here we would have 150 and if there are no type annotations here the default integer type will be inferred which will be i32 now over here again we have the problem of floating Point Precision so we can cast that to an F 32. like that over here we have the modulus operator and the modules operator basically gives back the remainder of a division so if we divide 24 by 5 we would have a remainder of 4. now as you can see here we have Boolean logic and bitwise operations and I want to show you some slides so we get the concept let's start with Boolean logic Boolean logic deals with values that are either true or false and there are three basic operations and or and not and over here you can see the truth tables of these operations so let's see the and operator now the end operator takes two inputs and produces one output now the only time it outputs true is when both of the inputs are true otherwise it will always return false in an or operation if either one of the inputs is true or both of the inputs are true then it will output true if both of the inputs are false then it will output faults and the not operator will just basically invert the Boolean value so over here we have not false and this would evaluate to true and not true will evaluate to false now let's see bitwise operations bitwise operations are operations that manipulate individual bits that make up a binary number treating each bit of a binary number as a separate unit and perform logical operations on them so it's very important that you get that in bitwise operations we are treating each bit as a separate unit and we are doing some manipulation on each individual bit and not the binary number as a whole and we'll cover here and or X or operations and bitwise shifting now there are a lot more but I will just cover the ones in the exercise let's start with the end operator this Ampersand symbol over here and returns one only when both of its inputs are one so similar to Boolean logic as you can see the end operator takes two inputs and produces one output now as you can see in the truth table if both of the inputs are one then the output will be 1. in any other case the output will be zero let's see the or operator this symbol over here all returns one if at least one of its inputs is one if both inputs are zero the output will also be zero so same thing as in Boolean logic if either one of the inputs or both of the inputs are one then it will output one so the only case it outputs 0 is when both of the inputs are zero and let's see xor xor or exclusive or returns one if the inputs are different and zero if the inputs are the same so it's basically similar to the or operator with the difference that if both of the inputs are one then it will output 0. so the inputs must be different so it will output one all right if they are the same it will output 0. and this is basically a building block of your computer so your computer is made up of logic gates and these logic gates perform these operations all the time millions of times in a second then let's see bitwise left shift so we have over here the decimal number one this would be the binary representation now we want to left shift by five positions so we take this bit over here and move it five positions to the left so the so this bit over here will be at this position after the DP twice left shift operation all right and that means we then have a value of 32 because this is the binary representation of decimal 32. and bitwise right shift is basically the same now over here we have a hexadecimal value and we want to right shift it to positions now this value over here would be 128 in decimal and this would be the binary representation of 128. now we want to right shift it to positions meaning we take this bit over here and shift it two positions to the right meaning the bit will then be in this place and again we would have 32 because this over here is the binary representation of that number all right let's see so true and false would be false right because in an and operation both of the inputs must be true in order for it to Output true now true or false would be true because in an or operation only one of the inputs have to be true and not true would be equal to that's right false fight like that now let me run the program so we can see the result of these bitwise operations so as you can see over here zero zero one one and zero one zero one is zero zero zero one why is that because again we are here considering each individual bit as a unit and Performing manipulation on each a distinct bit now over here as you can see we are taking the rightmost bit over here and we are performing The End operation with the rightmost bit over here meaning one and one would be one right because and if both of the inputs are 1 then it will output one in any other case as you can see one and zero would be zero 0 and 1 would be zero zero and zero of course would be zero now let's see this or operation we have one or one this will output one we have one or zero which will output one again right because in or operation if either one of its input or both of them are one then it will output one zero or one is one and zero or zero of course is zero and then we have xor one X or one put B zero because remember X or the inputs must be different in order for it to Output one like over here for example 1 X or zero would be one right the inputs over here are different one and zero same over here 0 x or one would be one and zero X or zero of course will be zero and as you can see over here these are the bitwise shifting so I've covered that in the slides all right see you in the next topic so we will cover in our Char pool and unit let's start with characters so over here make it work now size of Val will just return this size in bytes of a specific value so over here we are initializing the variable C1 with a character so C1 holds a type of char then we pass to the size of valve function the variable C1 and this will return the size of this character in memory in bytes right and same thing over here we have C2 also holding HR and we call the size of L function with this variable so let me first print out the actual result of this function call so if I come over here and I will do a print line statement and just basically outputting the result of this function column so let's see as you can see the output would be 4 meaning this character over here will take up four bytes in memory so the size of C1 is 4 bytes now in Rust the chart type is big enough to hold every single Unicode symbol meaning it is of size 4 bytes so it's able to hold any Unicode scalar value all right and the same thing over here the output would be four meaning if we call this function we will get back four all right make it work again initializing a variable with a Char then we are calling the printshar function with an argument of this variable as you can see this function over here this is the function signature this function takes as argument C which is of type Char and then we will and then we just print out C now the problem over here is that this isn't actually a Char this would be considered a string because in Rust there is a difference between double quotes and single quotes So double quotes are four strings and these single quotes are for characters foreign out the character let's see booleans make print Line work as you can see this variable underscore F holds a Boolean value of false and over here T also holds a Boolean value of true now in an if block this conditional over here will be checked if the result evaluates to true then this instruction inside the curly braces will be printed out if it evaluates to false then the program will just ignore this instruction over here now in this case we want to print that out but over here the result would evaluate to false because we are saying not true right because T holds a Boolean value of true so not true would be false that means this will never get printed out what we can do over here is just removing this not operator and then it will work make it work again we have some variables that hold Boolean types now again this variable over here T will also hold a Boolean type because this over here is an and operation and remember an end operation takes two inputs and produces one output so the output type will be of type pool now true and false would evaluate to false and then we are comparing T and F now F holds true and T holds false which is not what we want so what we can do over here is just making this false over here and then both of them hold a Boolean value of false unit type make it work don't modify implicitly red unit so the unit type is a type which doesn't hold any value its size is zero bytes and it's usually if a function doesn't return any value then a unit type will be returned and this happens implicitly so you don't have to annotate that let's see an example over here the underscore V variable holds a unit type as you can see a unit type is basically represented as an empty Tuple and this would be the type annotation right so over here we are holding a tuple with two i32 values then as you can see we have here an assert EQ macro we are comparing V with the output of this function call let's see this function over here implicitly red unit so all this function does is it will print out something and then goes back to the color now this function over here doesn't return anything and if a function doesn't return anything the compiler will implicitly return a unit type right but you don't have to annotate that all right so the return value of this would be unit type now V over here holds a tuple meaning this would fail we have here to provide underscore V which holds a unit type so this holds a unit type and this function call over here will return a unit type all right what's the size of the unit type modify 4 in assert to make it work as you can see we are again having this size of L function and we are providing it this variable which holds a unit type now the output would be zero because unit types are of size 0. so to quickly recap HR is a single character of size 4 bytes a Boolean value of true or false is of size 1 byte and the unit is an empty Tuple of size 0 bytes used to return nothing in expressions or functions so this time I will first show you the slide and then we will solve exercises so a statement is an instruction that performs some action but does not produce a value function definitions for example are statements as well as code that ends with a semicolon usually and an expression will evaluate to a resultant value so let's see all right let's see this example over here we have X which holds an u32 all right now over here we are initializing the variable y with the resultant value of this whole expression so as you can see we can inside these curly brackets we can declare variables over here and then we do some operations and return the value as you notice I omit over here the semicolon that means that this result of this operation will get returned which means when this evaluates it will then be assigned to Y so y will then hold the result of this operation now all of the code inside these curly braces are considered as an expression because it produces a resultant value right it would be this value over here now this variable assignment over here would be considered a statement because first of all it ends in a semicolon and second it doesn't produce a new value right it just assigns a value to a variable now y in the end would hold an u32 right because we are here performing an operation with values of u32 types the semicolon suppresses this expression and unit type is assigned to Z so Z over here would hold a unit type why is that because we over here have a semicolon so this code over here doesn't return a value if we omit the semicolon then this would be the return value that then gets assigned to this variable meaning it will then hold a u32 all right let's do exercise one make it work with two ways so as you can see over here we are initializing this variable over here with this expression inside the curly braces now we are here initializing the mutable variable x with a value of one so X will hold I 32. then we are mutating X incrementing it by two so X should then hold 3 right now over here this would actually hold a unit type because over here we have an assignment so we are adding 2 to the value of x and then we assign it to X now the problem is that variable assignments are actually statements so this should end in a semicolon because this would be the same as if I would write it like that right so we can't return over here a variable assignment but what we can do is we just return X because X over here will then hold 3 and then we return X meaning the value of x is then assigned to the variable V so variable V will then hold a type of I 32. let's see this compiling as you can see make it work in two ways now the second way to solve it is just in this assert EQ macro we compare V to a unit type because um no value will get assigned to V and that means the variable we will then hold a unit type like that over here as you can see we are initializing V with a variable assignment so this would not be allowed it's invalid syntax but what we can do is we use curly braces like that and then we initialize here a variable X and we return X this would be allowed so V then holds an i32 let's see over here we have a function call with two values one and two so let's see the function over here it takes two arguments X and Y of type i32 and it returns an i32 value now over here as you can see this function just adds X Plus y now the actual return type over here would be unit type because as you can see we are ending this operation with a semicolon meaning nothing will get returned so if we omit the semicolon over here then we would have a return type of I 32. meaning after the function call over here s will then hold the result of this operation 1 plus 2 would be 3 so s would hold three that would be a type of i32 so let's now look at functions a function is a block of reusable code that performs specific tasks it can take arguments processes those inputs and then returns a result and a diverging function is a function that never returns to the caller and this would happen for example if the diversion function is panicking looping forever or quitting the program so let's see don't modify the following two lines as you can see we have here a tuple and we are destructuring it we have already seen how that works now over here we have a function called now this would be the color and this function would be the collie okay when we call the function the flow control will go to this function and the program will continue executing the instructions provided in this function now it's very important that you know that functions always have to annotate types for their arguments so over here we would Define that X should be of type i32 right because Y is I 32 and we are performing here a mathematical operation meaning they both have to be of the same type and as you can see like in the last exercise this function wouldn't return a value because over here we have a semicolon so if we omit that then this result of this operation will get returned which means the return type would be i32 then when this Returns the flow control will go back over here and assign The Returned value from this function to variable s meaning the variable s will then hold a type of i32 and the value would be 3 right because we are calling the function with arguments one and two or X and Y over here which hold one and two and then this function will just sum it up together and that means s will hold 3. over here we are calling the print function so we go to the function over here and as you can see the function just prints out something to standard output but it doesn't return a value now implicitly the compiler will return a unit type like that but we don't have to write it it's implicit solve it in two ways don't let print Ln work all right so we are here calling a function never return and this function should never return because as you can see the return type over here is defined as exclamation mark and that means this is a diverging function a function that should never return back to the caller now we can do this in various different ways but I will just use the most simple one which is panic and the Panic macro just causes the program to panic meaning the program will immediately exit and return an error as you can see unreachable statement so this line over here is never reached as you can see and that's what we want because over here don't let print Ln work so we never actually reach this point the program will exit before going back to the caller diverging functions diverging functions never return to the caller so they may be used in places where a value of any type is expected so in the main function we just print out something and over here we have a function get option it takes as argument a value of type u8 and returns option i32 now we will cover options in a later episode now over here we are matching TP and matching if you're coming from another programming language is like is which block okay we are matching TP and then if for example TP would be one then this code block over here would get executed if it is anything else then this code block will be executed and we will cover match statements but match is just a much more powerful way of pattern matching than for example if else conditionals so after this match we are calling this never return FN and this should never return so there are some macros we can use here I've showed you one the Panic macro like that or we can also use unimplemented and you use the unimplemented macro if you have a function that is not implemented yet and we can also use it to do macro like that and to do is basically very similar to and implemented and all of them will cause this function to not return to the caller in this case this would be the color over here fill in the blank so as you can see we have here a variable B which then gets matched over here so if B holds a value of true then 1 will be assigned to variable V if B holds a value of false then it will print out success and the program will then panic now we can here assign false because I guess we wanted to print out success right and yeah let's see as you can see this would be the compiler message if a program panics trade main panicked at we have no value for false but we can panic that would be this output over here so we will now cover ownership and ownership is a concept which is unique to rust meaning even experienced programmers can find it difficult to understand this concept but it's very logical and it all makes sense and I will use visuals and illustrations to make it easier to understand the concept so ownership is basically a set of rules that govern memory management these rules are enforced at compiled time if any of the rules are violated then the program won't compile now let's see the three rules of ownership in Rust first each value in Rust has an owner second there can only be one owner at a time third when the owner goes out of scope the value will be dropped now the owner of a value is the variable or data structure that holds it and is responsible for allocating and freeing the memory used to store that data foreign let's look at scope a scope is arranged within a program for which an item is valid we have two types of scope one is global scope and that means a variable that is declared in global scope is accessible throughout the entire program and local scope if a variable is declared locally it means it is accessible only within that particular function or code block which in turn means it's not accessible outside of that function or code block let's see an example of scope as you can see we are here initializing the variable s with a string that means s over here is the owner of this data of this string value okay now s is valid from this point forward so after initializing s it will be valid throughout this scope over here which is defined by these curly braces so inside of this scope we can do stuff with s when this scope is over s is no longer valid so as over here the owner of this data will deallocate the data that is stored in computer memory and that means in turn we can't use as after this point it gets dropped or removed from memory so when s comes into scope it is valid it remains valid until it goes out of scope and a general rule is the scope ends where the block of code ends so to understand ownership you have to understand computer memory now memory is a component in a computer to store data and instructions for the processor to execute there is a type of memory called random access memory or RAM and it is volatile meaning when you're turning off your computer all data stored inside Ram is lost and there are two types of regions in Ram which is used by your rust program it is stack memory and Heap memory so now let's look at stack memory and I want you to imagine a stack of plates now if you want to eat something you take from the top of this stack a plate put food on it eat and then you will clean up the plate right when you're done cleaning you put the plate back on the top of the stack and that's exactly what is happening in stack memory so this concept is called last in first out meaning the last thing that is pushed on top of the stack will be the first thing that will get popped from this deck meaning the first thing that will get executed now all data stored on this deck must have a known fixed size like integers floats Charles bulls and so on basically all the types we have seen so far are all of fixed known size at compile time now pushing to the stack is faster than allocating on the Heap because the location for new data is always at the top of the stack meaning the program can access a data and stack memory at constant time if you are familiar with time complexity and types of unknown size will get allocated to the Heap and a pointer to the value is pushed to this stack because a pointer is fixed size don't worry I will show you illustrations which will make you understand this concept better let's see for example this simple rust program so as you can see we are starting in main because main is the starting point of execution in every rust program so over here we declare some variables X Y and Z meaning these variables are local to the main scope to this code block over here and because they are local they can't be accessed outside of this scope now over here we have a function call and we pass it the value of x and of Y right so as you can see the add numbers function takes two arguments of type i32 then over here we declare a new variable and assign and we assign the result of the operation a plus b meaning the past value is X Plus Y and we assign it to the variable C and then we just return C right so then Z over here will hold the returned value now when we start execution main alongside with all the local variables will get pushed to the stack then because we have over here a function call inside Main the add numbers function alongside with all the local variables to this function will get pushed to this stack if we would have other function calls over here or inside here then this will also get pushed on the stack and so on and then the program will just execute everything that is on the stack from top to bottom now let's look at Heap memory date of no known fixed size belongs on the Heap allocating data on the Heap will return a pointer an address to a location where the data has been allocated allocating on the Heap is slower than pushing to this stack and accessing data on the Heap is also slower as it has to be accessed using a pointer which points to an address so if we look at this abstract illustration of Heap memory as you can see we are allocating to Heap memory if the size of of the type we are allocating is not known at compile time and the types can then also be dynamically grown or shrinked right the size is not fixed and we will see examples of these types where this cat where this could be useful so when we allocate to Heap memory let's see for example the this packet over here we will get back a memory address and we need this address so we know where this specific data over here has been allocated so we then can access it in our program and an example of a heap allocator type would be the string type now as I've said all types we have covered so far were fixed size meaning their size was known at compiled time and they can't grow and Shrink so the difference is a string is mutable meaning its size can change at run time and a string is stored on the stack with a pointer to the Heap so when we initialize a string type then we will get back a pointer which then points to the actual data in the Heap and and the actual data of the string is stored on the Heap so let's see an example to understand this better as you can see we have here the variable S1 which we initialize with a string type over here and we initialize a string like this string double colon from and then these the actual string now you need to understand that the variable S1 doesn't hold the actual string in this case it holds a pointer which points to the data that was allocated on the Heap so if we look at S1 we can see that S1 doesn't hold the actual data but it holds a pointer and a pointer is basically a variable that holds a memory address that's what we call pointer and we have here Len and this is the length of the string we have initialized and the capacity holds the information of how much space was reserved in Heap memory for this specific type in this case we have initialized a string with a length of 5 so the capacity will be 5 so 5 locations have been allocated in Heap memory so this place is reserved for this string type and we will go into a much greater detail about capacity but for now when we initialize a string with a length of 5 the capacity will be five it will be the same so the size of this S1 variable will be 24 bytes because each field over here is of Type U size right so the pointer is of Type U size the Lan anticapacity all of them are U size and usize assuming we are on a 64bit computer will be 8 bytes so 3 times 8 bytes will be 24 bytes meaning the size of the variable S1 is known at compile time because again the variable S1 will get pushed to this stack memory and everything that lives on the stack memory has to be of known fixed size at compile time in this case all of these fields over here are known fixed size but we are pointing over here to the actual data in Heap memory which can be dynamically sized right it can grow and shrink and we will see examples of that so that is actually the point important the S1 variable doesn't hold the actual data but it holds a pointer to the data in Heap memory okay basically a pointer to the location of the first element and by the way in Heap memory this data over here is allocated as a contiguous block meaning in Heap memory these are all in a contiguous sequence of memory addresses right that's why we only need the memory address of the first location and a length and then the compiler will know where to look at and how long the sequence of data is so copy versus move scalar values with fixed size all types we've covered at the beginning will automatically get copied in this stack copying here is cheap dynamically sized data won't get copied but moved copying would be too expensive let's see an example over here as you can see we have initialized a variable x with a value of 5. then we assign X to y now the type of this value would be i32 right because it's the default integer type now because i32 is fixed size it means that it lives in this stack memory and everything that lives in stack memory will automatically get copied meaning we are here assigning a copy of x to y or basically a copy of the value 5. so we are not assigning the actual value but a copy of that meaning Y and X would point to different memory locations the value is the same but the location at which the value is stored is different because again when we assign a fixed size integer that lives in stack memory rust will automatically copy the value because copying on the stack memory is cheap now over here as you can see we initialize a string and then we assign S1 holding this string 2s2 now as we've seen S1 doesn't actually hold the data over here but it holds a pointer which is returned when we are allocating this data over here this string on the Heap memory so the allocator that allocates this data on the Heap memory will return a pointer and that means if we assign S1 over here to S2 then S2 will only get a copy of the pointer and not the actual data so that is how that might look like as you can see we have S1 which is initialized to hold a string now S1 will then be assigned to S2 and as you can see this is how this might then look like we have here the variable S1 and S2 now the actual data over here didn't get copied the one thing that got copied was the pointer alongside with the metadata meaning these two variables now point to the same location in memory right now this would violate the second rule which states that there can only be one owner at a time so we can't over here have two owners to the same data in Heap memory so what rust will do is it will drop S1 it will delete S1 and that means S2 will then be the owner of the data so the first variable S1 will be dropped and cannot be used after assigning it to S2 to avoid dangling pointers so after assigning S1 to S2 we can't use S1 again and that's different like we saw over here with for example integers which are fixed size we can use after assigning X to Y we can use both of these variables X and Y without any problem because again here the value got copied so the compiler will drop the variable S1 meaning S2 will become the owner of this string and that means we can't use S1 after this point now what if you want to actually have a deep copy meaning you actually want to copy the data that is allocated in Heap memory we can do that but we have to explicitly state that we want to do that because as I've said this might be expensive if you have large data that is allocated on the Heap and if rust would implicitly copy all the data all the time you're assigning variables then this would be really expensive and that's why we have to explicitly call over here the Clone method so when we take S1 which holds a string and we call upon it the Clone method and assign this to S2 then that is what this might look like as you can see S1 again doesn't hold the actual data but a pointer to the data that is that has been allocated in Heap memory and when we now look at S2 S2 also holds a pointer to data that has been allocated in Heap memory the difference is that the actual data in Heap memory that S1 is pointing to has been copied in Heap memory so S1 and S2 point to different locations even if the data is the same right and that's different from what we saw here as you can see S1 and S2 point to the same location in Heap memory I hope you get the concept so let's now see how ownership Works in functions as you can see we have here a variable s which we initialized with a string type so over here s comes into scope and in this case s will be the owner of this data then over here we are calling the takes ownership function providing it an argument of s so s value moves into the function and so is no longer valid here meaning the function takes ownership is now the owner of s so as you can see this function over here takes an argument of string type and it just prints out the provided string so as you can see some string comes into scope and some string over here is the string we have provided as an argument then we print it out and over here some string goes out of scope and drop is called the backing memory is freed meaning when we reach the end of the scope some string will get deallocated in Heap memory so after this point over here s can't be used in this main function over here because again the ownership has been moved from variable s into the takes ownership function now over here we have another initialized variable x with a value of five now five would be of type I 32 the default integer type meaning 5 is a type that lives on this stack it's pushed to the stack and not allocated on the Heap and that means when we call this function makes copy and provided X over here then we provide this function a copy of the value and not the actual value itself so we provide here a copy of the value 5 right and then over here we just print out this number then here are some integrals out of scope nothing special happens so the argument we are providing here goes out of scope but X over here is still valid because again we have just provided a copy because this is a type that is living on the stack memory so let's see this example over here we are calling the gifs ownership function now when we look at this function over here we are inside the function code block initializing a variable with a string value over here and then we are just returning this string and that means that S1 will then hold the returned string namely this yours string over here so S1 will be the owner of The Returned string type over here we are initializing S2 with a string over here that means S2 is the owner of the string then we are calling here the function takes and gives back with an argument of S2 meaning takes and gives back will become the owner of this data and that also means that after calling this function we can't use the variable as 2 because it has been dropped now when we look at the function takes and gives back it takes an argument of type string which we are providing here and then it just again Returns the string right so S3 will then hold the return string basically S3 then became the owner of this data right so we have transferred ownership from S2 to this function takes and gives back and then from this function to S3 and then at the end of the main scope S3 goes out of scope and is dropped S2 was moved we've seen that we have moved it inside the function so nothing happens S1 goes out of scope and is dropped so the variable S1 also gets dropped because it is the owner of of this string type returned from this function so you are now asking why do I even care about all this stuff in other languages I don't have to worry about all of this and this seems rather complicating a simple issue right now the main point of all of this is that ownership prevents memory safety issues so by this concept of ownership you are preventing dangling pointers pointers that point to Nowhere or some garbage values double three which is trying to free memory that has already been freed or memory leaks not free memory that should have been freed and if you're coming from C or C plus plus you're you know exactly what I'm talking about here so before stepping into borrowing we will do some exercises concerning ownership so let's see number one use as many approaches as you can to make it work so as you can see the variable X over here has been initialized with a string then we are assigning X to Y so y also should hold a string the problem over here is that we try to access X over here after it has been assigned to y now we have seen in the example that X will get dropped after we assigning after we are assigning it to another variable right so we can't access X but what we can do is telling the compiler that we want a deep copy of the data that X is holding and we are using for that the Clone method and then we X and then we can access both of these variables because the data has been cloned and X still lives on number two don't modify code in main again S1 has been initialized with a string and then we are calling here take ownership and providing it an argument as two as you can see the function take ownership expects an argument of type string and it just prints out the provided argument now we are then assigning the return value of this function to this variable the problem here is that this function actually doesn't return anything so this would hold a unit type right now if we want to return the argument over here after Printing and using it we can just return it like that and if you return something from a function you have to annotate the return type and that would be string right because we are taking here in the string and then we are returning it back that means S2 will then hold the returned string and then we can print out S2 and notice S1 can't be used after we have called this function with an argument of S1 because the ownership has been transferred to this function so meaning S1 is holding the data over here which means it's the owner then we call this function and provide it as one meaning this function over here becomes the owner and then we are assigning the return value to S2 so that means S2 over here will be the owner of the data in the end number three we are here calling the function GIF ownership and as you can see inside the function we are initializing a variable s which holds a string and we call here the into bytes method on S now let me show you that in the documentation so this is the in two bytes method now as you can see converts a string into a byte Vector so if we have a string over here and we call the into bytes method then we will get the string over here but represented as a vector of bytes okay and the important thing here is that this consumes the string meaning s over here will get consumed and that means s can't be used after this point now what we can do as an alternative we can use S bytes and S bytes just takes references and references will be our next topic so don't worry too much about it right now but when we call the S bytes method over here then the owner will remain the same right it doesn't consume the data so what we can do over here is calling the S bytes method and that means s Remains the owner of this data and we can return it then and that means s over here will be then the owner of The Returned value and then we just print out s fix the arrow without removing code line again we are initializing s with a string then we are calling the print store function with an argument s and all we do is we then print out the string but over here again we try to access S and that would be a compiler error because we are over here providing S as an argument to this function over here meaning this function will become the owner of the data s is holding and that means s is not accessible anymore what we can do over here is we can call the Clone method meaning we are providing this function over here a copy of this data so this data will get copied in Heap memory and that means s will still be valid don't use clone use copy instead so over here we have a tuple now this Tuple holds two integers a unit type and a string now let me annotate that we annotate tuples like that and we have to find each type of array value distribute so we have 2i32 integers One units type and one string now over here we are calling the Clone method and assign it to Y so y should actually hold the same uh values all right and because we have called the Clone method we can use both variables without the problem now it says don't use clones so we can't use clone over here now my solution to this would be if you take a look at the types this Tuple is holding then we see that most of the types over here are actually on the stack memory meaning they are of known fixed size right so inters and i32 would be of size 32 bits right a unit type would be of zero bits the only problem arises here because we have a string now a string is a heap allocated type meaning its size is not known at compile time now what we can do over here is we can use a string literal now we will cover the difference between strings and string literals but for now a string literal is a string that is hard coded into the binary itself into the program so it is immutable which means that this size is known at compile time so all T types the Tuple holes are known are of known fixed size at compile time so over here we can do the same and what's the reason we have been doing this because we know that a type that lives in stack memory meaning it's fixed size will get copied implicitly now this Tuple only holds fixed sized types meaning the Tuple itself is fixed size and that means X over here will get copied implicitly by the compiler all right mutability can be changed when ownership is transferred as you can see we are here initializing s with a string then modify this line only we are here assigning s to S1 now over here as you can see we are modifying the string that S1 is holding and remember when we assign s to S1 S1 will become the owner of this data meaning s will get dropped so we are then trying to mutate S1 and we are pushing to it D string world now remember that a variable is immutable in its nature so we have to use the mute keyword over here to denote that S1 should be mutable and that means that if the ownership has been transferred to another variable we can change its mutability right even if s was immutable we can make S1 mutable without problem because S1 is now the owner of the data now over here as you can see we are initializing a variable x with a boxed integer type now box allows you to allocate directly on the Heap as you know this is an i32 and i32 is normally live in stack memory when we use this over here Box new and we box this i32 it means it gets allocated on the Heap and that means X will then hold a pointer to the data that was allocated in Heap memory so the type annotation here would be box and this box holds an i32 and X then basically holds a pointer now over here implement this line don't change other lines now as you can see we have over here to declare y now y gets the referenced and that means we have over here to get back a pointer so we can do basically the same thing like we did before we can use Box new and let's do one for example so the variable one will hold a box with a type of i32 and as I've said we allocate this integer on Heap memory meaning we get back a pointer and the pointer is a memory address to the location where this data has been allocated now because y holds a memory address we can't assign a value and integer value directly to Y because Y is just holding an address and not an i32 type because remember we can just assign a value to a variable if both of them are of same type now as you can see y holds the type of box i32 which is not the same type that means we have to dereference and we are dereferencing using this star operator and and this star operator means we go to the location of Y because Y is holding a memory address and we want to access the value right so we want to access this interval that has been allocated on the Heap and that means we can assign a new value 2y but we have to use this store operator and again over here you can see it even better this would be equal right because X is pointing to a location in memory which holds an integral value of 5. now if we would omit the star operator this would not match because X would hold something like that right in memory address now this memory address and the integer 5 would not be equal but this star operator basically says go to this address and give me back the value that is stored at that address which would be 5. and of course we have to make this variable over here mutable right because we are here mutating y partial move within the destructuring of a single variable both by move and by reference pattern binding can be used at the same time doing this will result doing this will result in a partial move of the variable which means that parts of the variable will be moved while other parts stay in such a case the parent variable cannot be used afterwards as a whole however the parts that are only referenced and not moved can still be used so over here we have a lot of stuff we didn't cover yet and I will try my best to explain it but if you don't get it 100 it's no problem okay we will go into greater detail on each of these structures and types so as you can see over here we have a struct person now a struct is basically a custom type we can create our own types in Rust and a struct basically is a template we are saying here as you can see this truck holds two members one name which is of type string and one H which is of type boxed u8 okay a heap allocated unsigned 8bit integer then we have to instantiate and this person struct meaning we are using this template and create basically a concrete value of that so we are providing here for the name member a string like it's defined here and for the age we provide a boxed value of 20. now this person variable will then hold a type of person right this is now our own custom defined type now name is moved out of person but age is referenced so over here we are destructuring the person instance over here and we do that very similar to tuples we have seen we used to let keyword the name of destruct and then we the structure the fields so the person so the person instance over here will get the structure meaning person name will get put into the name variable and the H member here will get put inside this H variable now notice something we are here using the ref keyword meaning th variable will only take a reference of this data and not the actual data itself but name will get moved inside this variable so the name variable here will be the owner of this string right and that means that person is not the owner of this string anymore it has been when instantiating the struct but it is not anymore then as you can see we are printing out these variables but we then can't use the person instance right because the person instance is not the full owner of all team members inside it and also we can't access person.name this is how you would access normally a member in a struct person Dot and then they member in this case name but we can access person.h because the person instance over here is still the owner of age because again we have destructured it and the variable H only took a reference again if you don't understand a hundred percent it's fine okay we haven't covered a lot of this stuff going on here and I even think this is not a good example right now but yeah so exercise eight as you can see we have here a tuple holding two string types now we are assigning the first element of the Tuple and by the way Cupids are also zero index like arrays and we can access the indexes like this the name of the variable and then Dot and the index we want to access in this case the first one that means that underscore s will hold a type of string right namely this over here and that means the ownership of this string data here got transferred to this variable so underscore s is now the owner of this data meaning we can't access T again because T is not the owner anymore of all the values it contains in the Tuple right so we can't use it again but we could still use T at index 1 because this over here is still owned by T because only the first element has been moved out and over here again a tuple with two strings so fill the blanks as you can see what we want here is destructuring the Tuple and we want to initialize these two variables S1 and S2 and remember when we destructure it we have a syntax like that now over here as you can see when we are destructuring this Tuple both of the values it is holding will get transferred to these variables so S1 will be the owner of this stream and S2 will be the owner of this string meaning T doesn't own any values after this point but what we can do because we want to access T again over here we can call the Clone method as you've seen meaning S1 and S2 only hold copies of these strings and not the actual values and that means that t will still be accessible and T is still the owner of all the values inside the tuber alright see you in the next topic so let's look at borrowing borrowing is a way of temporarily access data without taking ownership of it when borrowing you're taking a reference a pointer to the data and not the data itself its goal is to prevent Dengue pointers and data races data can be borrowed immutably and mutably and there are certain rules when borrowing which we have to comply with otherwise the program won't compile let's look at these rules the first rule states that at any given time you can have either one mutable reference or any number of immutable references but you cannot have both you either have one mutable reference or any number of immutable references and the second is references must always be valid so let's see an example of a reference over here we are initializing S1 with a string then we call the calculate length function and as you can see we are here passing a reference to S1 and this is indicated by this Ampersand symbol over here so then let's see the calculate length function as you can see the argument should be of type reference to a string which we did provide right it's a reference this Ampersand to S1 which is of type string and then all this function does it will call the Len method which will return the length of the string and it returns it now notice that the return type will be of Type U size and then this Len variable over here will hold the length of this string and the type annotation would be use size right the return value of this function and then we just print out S1 and length and notice something over here we can use S1 because S1 over here stays the owner of the data we have just provided here a reference to S1 and not S1 itself so let's see how that looks as you can see we have S1 now again it's very important that you understand that the variable S1 over here doesn't hold the actual data but a pointer to the data which will get allocated to the Heap memory so when we allocate to the Heap we will get back a pointer which S1 is holding alongside with other metadata now because over here we are providing S1 as a reference that means the variable s from this function will then be another pointer which points to the S1 variable so s points to S1 and S1 points to the Heap allocated data and that means that S1 over here Remains the owner of the string let's see Mutual references as you can see we initialize a string and assign it to S now then we call the change function with a mutable reference and notice that you have to annotate that you want the reference to be mutable this is important and it has to be explicitly stated so that the rules are set in place because remember you can only have one single mutable reference at a time and then this change function over here as you can see in the function signature it takes an argument of type mutable reference to string which we are providing right we are providing a multiple reference to S which holds a string and then we can manipulate the string now again very important s Remains the owner of this data even though we are manipulating it in this function over here s Remains the owner because we are here dealing with references so let's look at some examples just to strengthen the knowledge of this concept as you can see we here initialize s with a string and then we have here two mutable references to S and we assign it to R1 and R2 now this would fail this program doesn't compile now this would violate the first rule of borrowing which says that we can only have one mutable reference to the same data at a time but what we can actually do let's see this program as you can see again we have a variable s which holds a string and notice over here we have an inner scope so in this scope R1 will hold a mutable reference to s now because at the end of the scope R1 we go out of scope meaning it will be dropped we can then again pass a mutable reference to R2 so this program will compile so over here again initializing s with a string here we have two immutable references to S now up to this point no problem because the first rule states that we can have any number of immutable references the problem is over here because we are then assigning immutable reference to S to R3 this is a problem because this would violate the first rule of borrowing which says that we can either have any number of immutable references or one single mutable reference but we can't have both of them immutable and mutable references at the same time now over here as you can see we have the exactly same program but as you can see we are here having two immutable references assigned to R1 and R2 and then we just print it out now after this point over here the variables R1 and R2 won't be used in the entire program and that means that we can assign then a mutable reference to R3 it's important to notice here that again we don't use R1 and R2 after this point so it's allowed to have a mutable reference over here while over here as you can see we are trying to access all of them at once this would cause a problem now I've showed you some of the reasons why the compiler is so strict and one of them was dangling references so let's see what a dangling reference is as you can see over here we are calling a function dangle now in tangle we are initializing a variable with a string type and then we are returning over here a reference to this string as you can see in the return type it is a reference to a string now the problem here is that when the function returns this variable over here will hold a reference to this string right and s over here will get out of scope at the end of this function scope here and that means this variable over here will point to something that has already been dropped or deleted so it points to a garbage value right and rust won't allow you to compile a program like that because this will violate the second rule which states that references must always be valid very important and to avoid that we can change this tangle function over here and just returning this string itself right so reference to nothing would then be the owner of the string but returning a reference to something that has been declared inside the function scope is a bad idea all right let's do some exercises as you can see we have here a variable holding an i32 value then over here fill the blank and we have to complete this P assignment over here now let me see over here the memory address of X is and we are providing P so we want to print out here the memory address and by the way this is denotation if we pass here a pointer that it actually outputs the address of the memory location that P is holding so over here what we want to do is we want a reference to X now as I've told you P will then be of type reference to an i32 right because X is holding an i32 type now a reference to an i32 is basically a pointer to a location in memory that points to this data over here so P here holds a memory address we'll see that when we execute this program as you can see the memory address of X is this so this memory address is where the value 5 is stored in in memory and we are accessing that using a pointer over here again a pointer is just a normal variable which holds a memory address in this case the memory address of x right so this is a reference to X over here again we have variable X holding i32 type and a reference to X which is a reference to an i32 value modify this line again we compare here y with five now y doesn't actually hold the value 5 it holds a memory address now to access the data at which this y pointer here will point to we have to dereference and we do that with the reference operator like that that means go to the location of Y and give me the value right so when we go to the location where X is stored for example at this memory address we want to get the value that is stored at that address we are using here the star operator just to access the value so over here we initialize a variable holding a string type then we are calling the function borrow object and as you can see the borrow object function expects an argument of type reference to a string but what we are here providing is a string right we are providing s which is of type string now we want here to pass a reference to s meaning a reference to string in this case we are complying with the function signature over here again variable s holding a string then we call puster function over here now again we have to always take care of the function signature what is expected so as you can see the argument should be of type mutable reference to a string so we have to pass here a mutual reference to s where s is holding a string right number five again here having a string and as you can see over here we are mutating p so that means we want to have immutable reference to s as you can see p will then hold P will then hold immutable reference to a string type right and then we can mutate the string that P is holding and again because we are here having a reference S will remain the owner of the data meaning we still can use S even after this assignment over here ref can be used to take references to a value similar to ampersand as you can see we have here a variable holding HR and this over here would be a variable which holds a reference to a chart right a reference to C now fill the blank don't change order code now instead of here using the Ampersand symbol we can use the ref keyword and it's exactly the same actually they are very similar there are some minor differences in pattern matching um but we will come to that so when we dereference R1 and R2 then this should hold the same data right and over here check the quality of the two address strings so we have here a function get address which gets called with R1 and R2 now all this function over here does is it takes a reference to HR as an argument and it will then put it inside this format macro now this format macro over here is the same as the print line macro with the difference that the print line will print to the standard output while format will return a string right so we take this argument and then we will return here the memory address of this reference now in this case R1 and R2 should hold actually the same memory address right because they are pointing to the same data this case C so R1 is pointing to C and R2 is pointing to C all right so let's see and this is compiling borrowing rules remove something to make it work don't remove a whole line again here having immutable variable s which holds a string then we have two mutable references to s and this actually would failed to compile because again we can only have one mutable reference at a time so to solve this as you can see over here we are just printing out R1 and R2 so this reference over here don't need to be mutable right because it's sufficient that we have a readonly reference to S and again the rule states that we can have as many immutable references as we want so this is compiling and also just to show you when dealing with references over here as you can see s is still valid right error borrow an immutable object as mutable fix the error by modifying this line as you can see we have here a string and we call here borrow object with a mutual reference to S so the problem over here is that we can't pass a mutual reference to something which is immutable so we have to make this variable over here mutable and then we can uh then we can provide here a mutable reference to this variable but the other way around it's no problem okay borrow a mutual object as immutable so this code has no errors as you can see we have here a string and we are passing to the borrow object and immutable reference right now this would actually compile because as you can see the function signature States it should be an immutable reference even though s itself is mutable we can still pass it as an immutable reference this would compile without problems and then over here you can see we are even mutating s because it's mutable comment one line to make it work we have here a string and we have a mutable reference to S right so this would be the type annotation mutable reference to a string type now we are then mutating R1 and over here we again have a mutable reference to s and then we are modifying R2 the problem here is that you know the rule that we can only have one mutable reference at a time but as you can see R1 over here gets used again so this should remain valid but we can't have two valid mutable references at the same time so if I comment this out then this program should compile because we are not using R1 after this point meaning we can have another mutable reference and even if I print out here R2 this should also compile because over here the only valid mutable reference to S would be R2 because we are not using R1 after this point so over here again we have a string and we have two mutable references to S now if we would run that it would actually compile as you can see the program compiles even though we have two mutable references to S but we are not using any one of these in the program but over here it says add one line below to make a compiler error cannot borrow S as mutable more than once at a time you can't use R1 and R2 at the same time so let's use both of them over here to force this compiler error and as you can see this would be the compiler error we are expecting Canon to borrow S as mutable more than once at a time and over here you can see really the Rus compiler is one of the best compilers I've ever seen because it provides you with really useful compiler messages alright see you in the next topic so we have now reached the topic of compound types now a compound type is a type which is made up of other types for example a string is made up of characters so it's considered a compound type now we have in Rust two types of strings we have string with a capital S string like that and we have string slices now if I say string I will always refer to this type otherwise I will say string slice so a string is a heap allocated string type that owns its contents and is mutable we have seen that a string is allocated in Heap memory a string slice is an immutable sequence of utf8 bytes in memory it does not own the underlying data and is immutable so think of string slice as a view on a sequence of characters stored as utf8 bytes in memory it's basically just read only so use string slice if you just want to view a string and string slice is more lightweight and efficient than string and U string if you need to own the data and be able to mutate it then we have string literals a string literal is a sequence of characters enclosed in double quotes its fixed size compile time known sequence of utf8 bytes the type is reference to static string which indicates the data is stored in static storage meaning it is valid throughout the entire lifetime of the program the data is hardcoded into the executable and stored in readonly memory meaning they are immutable so let's now see an example of a string slice and I'm seeing my head is in the way here let's do it like that so let's see over here we are initializing s with a string now again I repeat myself I know but this is very important s doesn't hold the actual data it holds a pointer which points to the data that is that is allocated in Heap memory so s will have a pointer alongside other metadata that will point to the first character of the string and let's now consider this world variable here so we are taking a reference to s meaning s will remain the owner of the Heap allocated string so we are taking a reference to S and providing here an offset from 6 to 11. now I hope you remember in a Range this would be excluded so it would be from 6 to 10. so when we look at the world variable we see that it has a pointer and a length now this length over here is actually false I'm sorry for that this should be the length of the string slice in this case one two three four five so this pointer points to the offset of the string we have provided so it points to index six and it goes to 10 because again 11 is excluded so this world here will hold a string slice of this word right so the string slice World points to a sequence of characters stored on the Heap this is basically just a view into a heap allocated string and that's why it's immutable all right the type of string literal hello world is Ampersand stir for example let s string slice equals hello world now this would be a string literal right because we are hard coding it into the executable and a string literal is also considered a string slice because it's also immutable and it's basically just a reference to the static memory this string gets stored in so store and string slice we can't use Stir type in normal ways but we can use reference to stir fix error without adding new line as you can see this would over here be a string literal we are hard coding this string into the executable into the program itself so again we can't use Stir as a type but we can use a reference to a stir right we can only use Stir by boxing it Ampersand can be used to convert Boxster to string slice now fix the arrow with at least two solutions as you can see over here we have a string literal a string hard coded into the program itself then we call the into method we will cover that later but basically into will convert a type into the type we are annotating here so this string literal will be put into a box meaning it will be Heap allocated then we are calling this greetings function with an argument s and as you can see as this argument over here is has to be of string slice so what we can do over here to convert this box into a string slice is passing a reference to this box as you can see this is compiling but we even can just omit all of this right this photo would be string slice and we then just pass s notice that we don't have to pass a reference to S because s is already the type we need string type is defined in standard library and stored as a vector of bytes back but guaranteed to always be a valid utf8 sequence string is Heap allocated growable and not null terminated so let's see we want to initialize here s with a string right then we are mutating this string over here and mutate it again now over here we are pushing to it a string literal and over here we are pushing to it a single chart now if you push a single chart you just use the push method not not the push stir method and in the end as should hold hello world now we can initialize here an empty string like that this is now an empty string type now why are we using this type over here and not string slice like so for example why aren't we use why aren't we doing it like that because remember a string slice and string literals are immutable they are just references to some string data in the memory so we have to use string here so we are here initiating an empty string and then we are mutating it and push to its held over and this exclamation mark this compiles let's output the string as you can see the string over here has been mutated and that's the whole point of using this string type over here it can be mutated they can grow and shrink and so on so let's see exercise four fix all arrows without adding new line as you can see over here we have initialized a variable with a string then we are mutating this string over here which means we have to make this variable s here mutable so we are pushing A Single Character this comma and then we are pushing another string like that and we can even push to the string by using this notation here even though I don't like it but it's also possible but over here we have two pass it a string literal because this is defined in this standard Library all right let's see and of course over here sorry we have to use the push stir method as you can see this is compiling so again we are pushing A Single Character then we are using here the push stir method pushing a string literal and we can also mutate strings like that we place can be used to replace substring again we have here a string and we then can replace some elements inside the string so we provide as first argument the element we want to replace in this case dogs and it should be replaced with cats so S1 should then hold I like cats now again replace will mutate the string meaning the S should be mutable foreign methods can be found under string module so number six you can only concat a stream with a string slice and strings ownership can be moved to another variable so we have here S1 holding a string and S2 also holding a string now as you can see we want to concatenate these two strings and we can use the plus operator for that now in the rust documentation it says that the first argument should be of type string while all other arguments must be string slices so we have to convert S2 over here to a string slice now there are two possibilities the first one is using the s store method like that so this over here will then be considered as a string slice so we have converted a string to a string slice right but the output but the result of this concatenation will be of type string it's important to remember that and S3 should then hold this concatenated strings now because S1 over here has been moved inside S3 we can't use S1 anymore because S3 has become the owner of this data so let's instead print out S3 and as you can see this is compiling now there is an easier approach to that we can convert a string to a string slice by just by just providing a reference to a string so a reference to a string can be inferred to a string slice like that string slice and string opposite to the seldom using of stir string slice and string are used everywhere swing slice can be converted to string in two ways so we have covered that fixed arrow with at least two solutions so over here we have a string slice right now we call the greetings function over here with an argument of s now s should actually be of type string so we can convert that by calling this two string method like that so we have converted here a string slice to a string all right the second way would be doing it like that string from and then providing s as you as you can see this is compiling and there are other ways for example two ohms even though I think this is not used that much because it's more General but it's also possible right we can use string form or two string to convert a string slice to a string use two approaches to fix the arrow and without adding a new line as you can see we have here a string literal that has been put into a string so this variable over here will hold a type of string now to convert this s over here into a string slice because this is the type annotation of this variable we can as I did before we can pass as as a reference and again a reference to a string will be inferred to a string slice again we can use as stir for example would be the same string escapes you can use escapes to ride bytes by their hexadecimal values fill the blank below to show I'm writing rust so as you can see we can escape certain values and they will then be convert to ASCII characters for example this would be the hexadecimal representation of the ASCII value of s right so if we want to write rust here then the next character to S would be T so we would write X 74. like that and you can check this out over here there are a lot of examples where we can just Escape using the backslash Now using two backslashes here will print out this literal and these literal characters so the output will be backslash x3f okay because we are basically escaping this backslash all right and over here we have raw string and a raw string is a string in which there are no escapes so everything is printed literally as it is written so the output of this let me run that so the output of this would be backslash x3f it won't be converted to an ASCII character so let's see string index you can't use index to access HR in a string but you can use slice reference to a S1 for example and the offset so let's see we have here a string and now we want to access the first character now in most programming languages this would be possible but in Rust you have to use string slices meaning you take a reference to S1 and then provide the offset if we want to only access the first character we would provide an offset in form of a range from 0 to 1. now again in a Range this would be excluded meaning we only access this first element so the return type will then be a string slice notice something here when we assert age we would have a string of H and not a character even though we are here only accessing a character we are accessing it using these string slice this string slice notation over here so remember a string slice is just a view into a heap allocated string right so we are just looking what is at this location in this case we just want to access the first location over here right modify this line to fix the error tips this would take three bytes in utf8 format and that's right we have said that a character in Rust is of size 4 bytes now a character in a string is a little bit different so if it is an ASCII a character then it will usually take one byte and DC Unicode characters can take three bytes or I guess some of them even four bytes all right so we want to have in H1 only this character so again we are taking a reference to S1 and providing an offset oh 8 would be at index 0 I would be at index 1 this comma index 2 and then this will be index 3. now this takes up three bytes so we have to provide here an offset from three to six remember six is excluded so it goes from three to five three four five three bytes let me output that as you can see this would be the output and again this is just a view into a heap allocated string right operate on utf8 string fill the blank to print each character in this string so over here there is a method called chores now chores will put this sequence of characters into an iterator meaning we can then iterate over it using a for Loop for example and that means c will then be in each iteration one of these characters and we will then just find out C as you can see in each iteration we are printing out a single character alright that's it see you in the next topic so we'll Now cover arrays now an array is a fixed size collection of elements of the same data types stored as contiguous Block in stack memory now it's stored in stack memory because its size is known at compiled time the signature of an array is like that you can see over here which indicates that the length is fixed at compile time arrays can neither grow nor shrink they must retain their size so let's see the type of array is like this as you can see erase length is part of their type signature so their length must be known at compiled time for example you can't initialize an array like below this would not be possible as you can see we have an init R function which takes an argument of type i32 and then we try over here to initialize an array with the length that is provided as an argument this would be and compiler error because as we've seen the size of an array must be known at compiled time if we do it like that the size of the array would only be known at runtime this will cause an error because the compiler has no idea of the exact size of the array at compile time let's see fill the blank with proper array type as you can see we have here an array with five elements now what would be the type of these elements it would be the default integer type which is i32 so we annotate arrays like that in square brackets then we would have to type of the elements and the amount of elements inside of the array which is five modify the code below to make it work so we can call the Len method on an array and it will then provide the length of the array so in this case this would be 5 right because there are five elements inside number two we can ignore parts of the array type or even the whole type let the compiler infer it for us so we actually don't have to annotate the type or we can annotate the type but leave for example the type annotation here for the compiler to infer fill the blank arrays or stack allocated size of well returns to bytes which in Array occupies HR takes four bytes in Rust Unicode Char so we have seen that before the size of well we'll just take an argument and it will output the size in bytes the provided argument occupies in memory so if we provide the r over here then we should actually get back 3 times 4 bytes because because a character in Rust takes four bytes meaning this array over here would occupy 12 bytes in memory all elements in an array can be initialized to the same value at once so as you can see we have here an array which should hold 100 elements and each element should hold the number one okay we are here accessing the first element and this is the notation for accessing elements in an array in this case we access the first element at index 0. until length would be 100 so instead of typing out 100 times 1 we have a short 10 Syntax for that so we can here first of all provide the element it should hold in this case one and we want it to hold 100 elements of this value over here number four all elements in an array must be of the same type so as you can see because when we annotate an array we actually have to define the type here in this case we want integer types and we have three of them now as you can see this is a torrent this is not possible all elements inside an array must be of the same type indexing starts at zero so over here we have an array of characters let's annotate that and there are three elements inside it and now we want to access the first element right we want this variable over here to hold the first element now again arrays our zero indexed meaning we access it using this notation here and provided a value of 0. out of bounds indexing causes panic so over here we have an array which holds two strings and we want to access the first element right now we can use this notation over here like we did before or we could use the get method the difference is that get will return an option type we'll cover that in a later episode but it's generally safer than using this notation and this is especially true if you're accessing elements at runtime okay so we can use this notation or we could use this notation now over here this would panic because this array has only two elements meaning indexes 0 and 1. so let's access here index one and this compiles so let's see slices a slice is a reference to a contiguous sequence of elements in a collection it provides a way to borrow part of a collection without taking ownership of the entire collection it can be created from arrays vectors strings and other collections implementing DT ref trade so let's see this example of a slice we have here an array and then we are over here taking a reference to a and providing an offset essentially the same thing we did with string slices right a slice is just a view into a collection and over here we try to access the elements at index 1 to index two right because 3 would be excluded so the variable slice will then hold a slice with the elements 2 and 3 in it all right let's see slices are similar to arrays but their length is not known at compiled time so you can't use slice directly here both this slice over here and store or slice types but directly using it will cause errors you have to use the reference of this slice instead so because these two slices over here their sizes are not known at compile time we have to use a pointer to that right and we have seen that in the example of string slices so we use this syntax over here fix the arrows don't add new lines as you can see we are holding here an array let's annotate the type like that this is an array of three i32 integers now we want here to get a slice with this offset meaning from 0 to 1 0 1. so again like we did with a string slice we want a reference to an array with this specific offset so we are trying to access 0 to 1 because 2 is X because 2 is excluded meaning we are accessing here index 0 and 1. the elements one and two so this slice over here will then hold one and two right now the type annotation here would be like that because we are holding a reference to this array right and this would be the type annotation of a slice now over here we have a string later on now string literals as we've seen always are annotated like that string literal is hard coded into the program's binary and that's why we can access it using a reference to this string literal over here which is in the binary itself all right a slice reference is a two word object for Simplicity Reasons from now on we will use slice instead of slice reference the first word is a pointer to the data and the second word is the length of this slice the word size is the same as U size determined by the processor architecture for example 64 bits on an x8664 slices can be used to borrow a section of an array and have the type signature like this where T over here stands for the type as you can see we have here an array with three characters now we want to have a slice of this array with the first two elements these two elements and this is shorthand notation instead of writing it like that we can just omit the zero all right so we are accessing 0 1 and 2 is excluded so the slice variable should hold a slice with these elements the type annotation over here would be reference to char okay modify 8 to make it work tips slice reference is not an array if it is an array then assert will be packed each of the two characters this and this occupies four bytes 2 times 4 8. now because this slice variable over here doesn't actually hold an array but a slice we are here actually holding a pointer right because this is a reference to this array and that means we have seen over here A Slice reference is a two word object meaning the pointer and the length field will both occupy sizes of Type U size and your size if you're on a 64bit computer it means you size will be of size 8 bytes or 64 bits and that's why a slice holds 16 bytes right if we would pass the array here we would have if this slice would have been an array then 8 would actually pass because we would have two characters each character is four bytes meaning eight bytes but because we have a slice which holds a pointer and a length both of Type U size we have 16. so over here we have an array of five integers of type i32 fill the blanks to make the code work as you can see we want the slice variable to hold a slice of these elements so let's first annotate the type actually so this slice variable over here should hold a slice of I 32 elements right so we are taking a reference to the array and provided an offset we want to go from this to this meaning index 0 1 we are starting at 1 and we go up to 0 1 2 3 4. and I choose 4 here because 4 is excluded so we will go from 0 1 2 3 to index 3. string slices and we've covered that already but let's do some exercises for repetition now over here we have a string and we take over here a string slice meaning we take only the first two characters like that or let me write like like that right we take the first two characters fill the blank to make the code work don't use 0 to 2 again so over here we have a second variable which should hold a string slice and they should actually hold the same elements as you can see over here we are we are here asserting that slice one and slice two are the same so instead of using this syntax over here as we've seen before we can use like that we can omit t0 over here we have a string literal again a string literal is hardcoded in 2D binary and this would be the type annotation modify this line to make the code work as you can see we want slice over here to hold a string slice with only this character so let's annotate the type this would be a string slice and because this Unicode character over here takes three bytes we have to provide an offset here of three meaning zero one two right three bytes alright last one number six a reference to a string can be implicitly converted into a string slice now over here we initialize a variable s which holds a string here reference to S is reference to string type but first word needs aced but first word needs a string slice as you can see over here it works because reference to string can be implicitly converted to string slice so as you can see over here we are calling the first word function which takes us an argument a type of string slice and this would actually work because we are here providing a reference to S which means this over here is a reference to a string right and a reference to a string can be converted to a string slice implicitly by the compiler so then this function over here will take a reference of s and provides an offset from 0 to 1 where 1 is excluded so we just so we just take the first element and it returns this as a string slice that means that the return value of this function will be assigned to the word variable then over here we are calling the clear method on S which means this string will then be empty clear will just remove every content in the string the string itself will still remain in memory with the same capacity and S also is valid so it's different from drop but it will empty the string essentially so we will then have over here an empty string the problem over here is that clear takes immutable reference to self and that's a problem because over here we have a reference which is immutable to S and we have over here immutable reference to us now the problem arises because we are here using the immutable reference so if we would delete that and put it over here then after this point the word variable over here which holds an immutable reference is not used anymore and so we can use this clear method and this is compiling and as you can see we just get the first element alright see you in the next topic now we will cover tuples we have seen some tuples before and some exercises but now we will go into greater detail so a tuple is a way to store related pieces of information in a single variable and it's essentially a collection of values of different types grouped together as a single compound value again a compound value is a type composed of other types it's stored as a fixed size contiguous block of memory on this stack and the signature is parentheses and the types the Tuple is holding let's see elements in a couple can have different types pupils type signature is like that where T1 T2 are the types of tuples members so as you can see we can hold different types we have here an u8 and an i16 together in a tuple tuples can be tuples members so we can even Nest tuples so this Tuple over here as you can see holds an u8 over here and another Tuple inside it which holds an i16 and a u32 integer all right fill the blanks to make the code work so over here we have to annotate the type now again the first element over here would be u8 the second one is u16 the third one is an I64 the fourth one would be a string literal and the last one is a string members can be extracted from the Tuple using indexing so as you can see we have here a tuple let's annotate the type this is how we would annotate a tuple and it holds three string literals then we are accessing here the second element tuples remember are zero indexed but in this case it would be M but we want it to equal sulfates so we have to access d index 2 right 0 1 2. long tuples cannot be printed so if a tuple exceeds a certain amount of elements it is too long to be printed as you can see this would be too long if I delete that over here so this would work so we can have up to 12 elements in a tuple to make it printable if it exceeds 12 elements you can still use it but it's not printable the structuring Tuple with pattern so let's first annotate the type of this Tuple here we have an i32 the default integer type then we have a float which means f64 the default floating Point type and we have a string literal fill the blank to make the code work so over here we want to destructure this Tuple where X holds one y holds hello and that holds 6.4 so let's see redistructure tuples like this using the let keyword and the parentheses then the first element should be X right now the second element 6.4 should be put into Z and the last element should be destructured into variable y the structural assignments over here we are declaring some variables and then over here we destructure this Tuple and we want to put it inside these variables so we can so because we have already declared these variables we don't need to declare it once more so we can omit the LED keyword and then all we do is we destructure it so one should be put inside variable y 2 should be put inside variable Z and 3 should be put inside variable X tuples can be used as function arguments and return values fill the blank need a few computations here so so as you can see we are calling this function some multiply and this function over here expects an argument of type Tuple and the Tuple should hold two integer values what we do over here is we perform some operations and return it in a tuple right so so the first operation will be this one adding the first element of the provided Tuple with the second element of the provided Tuple and then we are multiplying the first element of the provided Tuple with this second element of the provided Tuple and we return that in a tuple again so the result of this operation over here will be the first element and the result of this operation will be the second element and as you can see we and as you can see we can return that in a tuple now after returning this Tuple we destructure it so the first element will be put in X and the second element will be the structured to the variable Y where X will hold 5 and Y will hold 6. so we have now to provide here two numbers when we add them together they will equal they will evaluate to five if we multiply the two numbers they will evaluate two six so this is a little riddle for you and try to solve it and the answer would be 2 3 right and don't forget to add here parentheses because we are passing it here a tuple right we are not passing two arguments we are passing one argument which is a tuple that holds two elements very important so if we add 2 and 3 we will get 5 and if we multiply two times three we will get six and this will be the return type of this Tuple over here all right see you in the next topic up until now we have been using types that are defined in this standard library but we can in fact create our own types and we can do that by using a struct now a struct is a compound type allowing to group together values of different types into a named data structure it's similar to tuples but each value has a name so the values can then be accessed through this name and a struct has to be instantiated with data think of it like destruct itself is the template for the instances you create from it now let's see how that works as you can see over here we have our template in this case a struct named user and the user struct holds various fields and we can define a field by giving it a name and a type that this field should hold so in this case the active field holds a type of Boolean username holds a type of string email string and sign in count u64 and then we can instantiate this struct and we do that by calling the name of destruct user in this case and providing for each field a concrete type and of course the types have to match the template then we are assigning this instance we have created over here to a variable so this variable will then hold an instance of the user struct and we can access and even mutate the fields of an instance so over here as you can see we have created an instance and assigned it to the user1 variable and then we can use this syntax over here to access a field so in this case we are even mutating the email field from the instance user 1. as you can see we do that exactly like we would mutate a variable just assigning it a new value now to mutate you have to make it explicitly mutable meaning you use the mute keyword here like you did with variables and functions can also create instances and return it so in this case we have the build user function which creates an instance of the user struct and as you can see again it's just providing concrete values for each of its fields and over here as you can see this function takes two arguments email of type string and username of type string and then it provides it 2D username field and to the email field now in this case we are repeating ourselves as you can see and we can avoid this by just using this shorthand syntax so if the name of a field and the name of a variable or argument matches then we can write it like that and this just makes it less verbose and there is also a concept called struct update syntax so over here we have an instance of the user struct now we want to create another instance but taking some of the values from the fields from user 1. as you can see for example in this instance we want the active field to hold the value of user 1's active field so we are accessing user 1 and the active field and as you can see we are taking everything from this user one instance except the email and as I've said there is a better way to write this and this would be instantiating a struct like we did before but just providing the fields that are different from the instance we we want to take from it so for example over here we say that the email field should hold this value and the remaining values should be taken from this user 1 instance so this will then create a user instance with all the same values from user 1 except the email field then we also have Tuple structs and Tuple structs are like normal structs but using tuplelike Syntax for defining their fields it's basically a named Tuple and it's instantiated by parentheses instead of curly braces and its values are accessed using Point notation and then we have unitlike structs and these are structs without any Fields meaning they don't hold any values and it's mainly used when working with trades and this will be covered soon and that means they don't store any data let's solve some exercises the types of structs exercise one we must specify concrete values for each of the fields in destruct as you can see we have here a person struct holding various fields and then over here we have a variable H which holds a value of 30. now then we are instantiating this person's struct and assign it to the variable P meaning P will then be an instance of the person's struct now as you can see we have here the fields and the concrete values and this would be the shorthand Syntax for this because we have over here a variable matching the name of the field so we can write it like that but as you've noticed we didn't provide the hobby field a concrete value so when you are instantiating a struct you have to provide to each field a concrete value so let's do that and the variable P will then hold a type of person now h of course has to match with the templates so this would be an u8 and of course we use commas here and not say me colons all right unit struct doesn't have any field it can be useful when you need to implement a trade on some type but don't have any data that you want to store in the type itself so as you can see this example is using trades and we have and we have not yet covered that so I will skip that because this might just be confusing and we will cover that soon number three Tuple truck looks similar to tuples it has added meaning this track name provides but has no named fields it's useful when you want to give the whole Tuple a name but don't care about the fields names so as you can see over here we have two Tuple structs one color and one point and they are exactly like tuples but they are named okay so over here we have three integer values in the color Tuple struct and in the points rack the same thing now we want to instantiate the point struct over here and the variable V will then hold an instance of our custom type point then we are calling the check color function and provide an argument of B now as you can see the check color function takes an argument of type color but this is not what we want right because we are here passing a variable of type point so let's change that and over here we are then destructuring the instance that was passed so in this case as you can see X should hold zero so let's provide this value over here then the P1 field and as you can see we are accessing the fields in the Tuple struct like we would access elements in a normal Tuple using this syntax so over here we are accessing the second element and this should hold 127. so that means the last element should hold 255. and as you can see over here we are destructuring so the first element over here gets this structured into a variable X now the second one over here we don't need to destructure right because we are accessing it directly using the PE instance and the last one let's call this Z okay and by the way when destructuring and you don't need a value like for example this one you just provided an underscore let's see and of course when the structuring we have to provide the name of this truck in this case point and this is compiling operating on structs you can make a whole struct mutable when instantiating it but rust doesn't allow us to Mark only certain Fields as mutable fill the blank and fix the arrow without adding removing new line again we have the person struct we have here the age variable let's annotate that and we have the P instance so as you can see we want to mutate the age field of the P instance and this is right but the problem is the P instance is not mutable so let's make that mutable and then we can also mutate the name field like that using field initial shortened syntax to reduce repetitions so again we have the person struct and in main we are just printing out something and over here we have the build person function so as you can see this function takes two arguments name of type string and H of type u8 and these arguments exactly match the types defined in the template so then we can over here instantiate a person struct meaning we can hear for the name field provide this argument and we have seen we can use field image for 10 syntax meaning if the field name matches the name of a variable or an argument we can skip it like that let's see exercise 6 you can create an instance from another instance with struct update syntax so as you can see we have here the user struct and we have seen an example of that in these slides then over here we are creating an instance from the user struct that means the variable U1 will then hold an instance that means that the variable U1 will then be an instance of the user type and again we are just providing each field over here with a concrete value then over here we call the set email function with an argument of the U1 instance so let's see over here as you can see in the function signature the argument must be of type user and then we want to create over here a new instance and what we want to achieve here is that we take everything and what we want to achieve here is that we take every field from the U1 instance except for the email field we want to we want that to be different so what we can do is providing a concrete value for the email field and then just saying the rest we want to take from the argument provided and then we are just returning it so that means U2 will then hold a newly created instance Point distracts we can use derive debug to make a struct printable click fill the blanks to make the code work so you actually can't print out a struct using the normal print line syntax we have to so to be able to print a struct we have to derive a trade again we will cover trades but we have to derive that using an attribute all right that means that destruct rectangle here implements this debug trade and that means we can then use debug notation to print it out so over here as you can see we have a variable scale and then we are creating here a rectangle instance so we are providing a concrete value for the field with and this would be 30 times the scale and we provide a concrete value for height now as you can see print debug info to standard error and assign the value of 30 times scale to width now this debug macro over here will just print out debug information to the standard error output and that means over here rect one will then hold an instance of the type rectangle and the type annotation for the scale variable over here would be u32 right because we are passing this scale variable over here meaning it should be of Type U 32. and then again we are here using the debug macro and printing out racked one and instead of doing that we can also use a normal print line statement like you're used to except that in the placeholder over here we have to use this notation and this is called debug notation meaning any type that implements the debug trade can then be printed and the difference between debug macro and printland macro as you can see print line will point to the standard output while debug will print to the standard error and that's why you don't see it over here you just see the print line output now to see that I will go to the rust playground and we can just run this code and as you can see over here this would be the debug output so this debug macro over here prints out the exact thing we are passing to the width field in this case 60. and this debug macro over here points out the instance right we then have an rectangle with a width of 60 and a height of 50. basically the same thing that we print out with the print line statement here foreign move within the destructuring of a single variable both by move and by reference pattern bindings can be used at the same time doing this will result in a partial move of the variable which means that parts of the variable will be moved while other parts stay in such a case the parent variable cannot be used afterwards as a whole however the parts that are only referenced and not moved can still be used and I guess we have seen that before but let's do another exercise so as you can see right we have seen that alright so let's move to the exercises directly because I've already covered that and I think the exercises are better for understanding so as you can see fix the arrows to make it work over here we have a file struct holding two fields of type string then in main we are creating an instance of the filed struct providing it concrete values for each field meaning F will then hold an instance of the file struct and over here we are then assigning the name field of the F instance to the underscore name variable so what would be the type annotation here it would be string right because F name holds a string and that means the name variable here will become the owner of this string data and that is the reason that we then cannot use f as a whole and also not F dot name because a partial move happened so if a field gets moved out to another owner then you can't access this field and also not the data structure that is holding this field so this would fail over here and this would fail now to fix that we can actually access just the name variable here right because this is now the owner of this string but what we can't do is accessing the whole instance over here this is not possible as you can see this is working now if you actually want to keep f as the owner of all the fields and to print it out like that and by the way notice again when we are outputting a single field we used in normal notation if we output the whole instance then we have to use debug notation because these fields over here hold types that are defined in the standard Library while this is a custom type we have created so to make that work we can also use here the Clone method and as you can see this is working and we are here printing out the instance all right see you in the next topic we can also create custom types using enums now an enum is a way of defining a type with only one of a possible set of values we can only access one variant of an enum at a time and it can hold additional information using tuples and it's especially useful when using in match statements let's see an example of an enum so we have here the enum IP address and this enum holds two variance so in enums we call it variance and not Fields like instructs and each variant over here holds a type using tuplelike syntax all right so an IP address by the way can be in either one of two formats either it's V4 or B6 and now we will see the difference between enums and structs so this is how we would instantiate this enum IP address we are accessing the name of the enum double colon and then the name of the variant in this case V4 then providing it a concrete value I hope you noticed the difference in a struct we would have provided concrete values for each field in an enum we instantiate the enum only with one single variant all right so this home variable will then hold an instance of the IP address enum and this loopback variable over here will also hold an instance of IP address but using the variant V6 and by the way this is the old format of IP addresses ntcc new one so let's do some exercises enums can be created with an explicit discriminator so enums are enumerated right that's why they are called enum now if you don't provide here a value it will be implicitly starting from zero this would be one and this would be two and we can also enumerate them with an explicit discriminator okay so this will then hold zero this variant will be one and this will be two and over here you can see C like enum now you can't use as a discriminator a floating point value this is not allowed but like in C if you for example would do it like that we are here providing the discriminator 5. then 1 and 2 implicitly will be six and seven right or we could say this should be 9 for example right so you can manipulate the enumeration of an enum so let's see actually let me change that back and let me change that to integers an inner variant can be converted to an integer by the as keyword so when we take this enum over here and we create an instance as we've said as we've seen calling the name of the enum and the variant and then we can convert it to an u8 for example right and we can do the same thing here and over here should be the same thing and as you can see this is compiling let me print out as you can see when we access from the number in on the variant one then A1 will get outputted now let's see if I provided a value of 10 over here but for that I have to comment that out as you can see this foot would then be the discriminator for the one variant all right each enum variant can hold its own data so as you can see we have here an enum message now this enum has different variants so this variant quit doesn't hold any additional data but while this variant move here holds Fields it's very struct like and this variant right is tube alike so it holds a value in a tuple syntax and the same thing for change color so we can then instantiate the move variant from the message enum with these values over here X1 and Y 2. and as you can see because this is very struck like you instantiate it basically like a struct and over here instantiating with hello world as you can see this variant over here holds a string type so like that and please notice over here that both of these variables here hold the same type message because this is also a custom type A type we have created we can get the data which an enum variant is holding by pattern matching so over here we have the same enum like we saw before and over here we have an instance of team move variant now we can here use E flat and we will cover that in the next section two get out the data inside this move variant so we are matching here the message variable holding an instance of the move variant and then over here we can basically destructure it so X should then be destructured into a variable a and Y should be restructured into a variable B and then as you can see we can use these two variables now we are here asserting A and B and a stands for this value and b stands for this value and as you notice they are not the same so this would fail actually so let me change that and now let's run the program fill in the blank and fix the errors again same enum and over here we have an array of different variants from this enum type right we have the quit variant the move variant and the change color variant now the neat thing here is that all of these instances are of the same type message right our custom type now I hope you remember how we annotate an array so first thing will be the type and then the number of elements Let's see we have over here three elements right and the type would be I hope you know it message right all of these variants or instances hold the same type and then over here we are looping over this array here meaning message this variable will hold in each iteration one of these instances and then passing it to the show message function and as you can see when we want to take an instance of this inner message we can just use the type message here because again all of them all because all of them have the same type and all we do then is just printing it out and again because this is a custom type we cannot print it out just like that so we have to use debug notation here and derive over here the debug trait and as you can see in each iteration over here we call the show message function and it will print out the contents of this array so let's see exercise five since there is no null in Rust we have to use enum option to deal with the cases when the value is absent and I want to show you some slides for that so the option enum option is an enum that represents a value that may or may not be present it's known in other languages as null and it's referring to the absence of a value it's used to handle cases where a function or method might fail to return a value so this is how the enum option looks like as defined by the standard Library as you can see it's an enum holding two variants none and some now this over here is a generic meaning that sum can hold any type and we'll cover generics very soon but for now again think that this can hold any type provided so let's see an example over here we are here initializing the variable 5 with D variant sum holding an integer value right and then over here we are calling the function plus 1 providing it five so let's see here as you can see the argument should be of type option and the type parameter here would be i32 now we have to provide a concrete type for this generic type parameter now again we will cover that in much greater detail but as you can see this is exactly the type we are passing to the function sum is a variant of the option enum and it is holding an i32 value and it is holding an i32 type now then we are matching this argument over here if it is holding a non we will return none if it is holding a sum then over here we are destructuring the value wrapped inside this sum variant into the variable I and then over here we are incrementing I by 1 and wrapping it in a sum because as you can see the return type over here is defined as option i32 and that means that this variable over here will then hold some 6 right because we have incremented 5 over here by one so this will hold an option type and the concrete value would be sum 6. the sum variant and a value of 6. now over here we are calling the plus one function with none meaning the argument will get matched and this will then get returned right a non and as you can see the non is also a variant of the option Ina and this i32 just stands for the sum variant if your turn if we are returning none then this type over here is still valid because the nonvariant here doesn't hold any value of generic type t but again generics are a topic on its own and by the way this is exactly the same that we have over here so let's do that annotating the type so over here we have an option holding an i32 type all right and as I've said this is not necessary you can omit that because again the option type is in the prelude then we are calling the plus one function again we are providing it sum 5 which is an option and then we are matching the argument so if the argument is none then we return none it is some then we destructure the value that was passed over here and we incremented by one and return it wrapped in some because the return type has to be of type option that means over here the type annotation would be option i32 and in this case we are passing a non so a non will be returned and by the way the Returns value here would be sum 6 right because 5 plus 1 will be 6. and over here we have nonantitype annotation would still be option I 32. now we want actually to unwrap this value inside this sum variant and we can do that by using IF let so as you can see we are matching these six variables holding some six and then we can destructure it basically so we can then say sum and the variable n meaning we then can use n over here and I see right now never let this run so we have to pack that into an else block just to ensure that this doesn't run after we are running this conditional here and as you can see it will output the value inside sum now again we'll cover generics will cover a flat and match over here this will actually be the next topic so don't worry if this seems a little difficult to understand we will cover that in much greater detail Implement a linked list via enums now over here this linked list I won't cover because there are a lot of things we haven't seen so in here we have um methods and other things that we didn't really cover so I think this would be more confusing than it would be helpful what I suggest you is that you will come back after we have seen some more topics you come back to this exercise and try to solve it it's not that difficult and the solution will be on my GitHub account but I think this is just Overkill right now so see you in the next topic the normal flow of execution in a program would be from top to bottom line by line but we can actually manipulate the flow of a program and flow control is a concept that refers to the ability to control the order in which statements or instructions are executed in a program it allows to specify which instructions should be executed under which conditions and in what order so we have many ways to do that and some of them are for example using conditionals so we have the if else keywords and match for example and we can use Loops for Loops while Loops there is a special Loop in Rust called Loop we'll cover that and we can even manipulate the flow inside the loop by keywords such as continue and break so let's see so let's start with if else conditionals over here we are initializing n with a value of 5. then over here we have an if conditional checking if n is less than zero in this case this would evaluate to false meaning meaning this this instruction over here will get ignored and the program will continue executing on the next line now in the next line we have another conditional so we can use here the else if keyword and over here we are checking is n bigger than zero in this case this would evaluate to true meaning this line will get printed out now we can also match anything else using the else keyword meaning if this evaluates to false and this evaluates to false then this will get executed now in this case this evaluates to true so this will get executed meaning this over here will be ignored as you can see this was the line that has been printed out number two if else expression can be used in assignments again initializing n and over here we have a variable assignment now we can even use if else conditionals when assigning a value to a variable now remember in a variable assignment is a statement so we so we have to end that with a semicolon like that so let's see we have here an if conditional and this is a Boolean and operation do you remember we have two inputs and both of these inputs have to evaluate to true in order the end operation to return true so let's see we have here n should be less than 10 which would evaluate to True right because 5 is less than 10. and 5 is bigger than 10 so this end operation will return true meaning the meaning the code in this if conditional block will get executed and over here we are just printing out a line and then we are multiplying n by 10 and in fact we don't have a semicolon so this will be returned from this expression meaning it will then be assigned to the variable Big N so big n will then hold a type of i32 now in case this would evaluate to false then this else block would get executed meaning again we are printing out a line and then dividing n by 2.0 now as you can see we should omit this semicolon because this should because this result over here should then be assigned to this variable now we actually can't do this operation here because n is of type i32 and we are dividing it by a floating Point number so we can so we can Typecast that when I 32. and as you can see this would be the output and we are printing out big n meaning 50 over here so n has been multiplied by 10. so let's see we have here a for Loop D4 in construct can be used to iterate through an iterator for example a range A to B now as you can see we have a for Loop declaring a variable n and we provide a range now this range over here reaches from 1 to 100 and 100 here included because we have here the equal sign then we are checking if n is equal to 100 this program will panic that's not what we want so what we can do over here is just removing this equal sign because that means 100 is excluded meaning n will never be equals to 100 the largest it will get will be 99 because let's see all right fix the arrows without adding or removing lines so over here we have a so over here we have an array holding two strings now we want then to iterate over this array meaning this name variable will hold in the first iteration this string and in the second iteration this string so what we can do over here is pointing out name right so this will iterate two times and it will output this and then this now as you can see we are trying to access names again over here and that would then violate the ownership rules because as you can see in a for Loop the for Loop actually will take ownership of the provided value and we can pass here a reference like we have seen before and that means we can use names then again so and by the way we don't have to dereference name over here because the print line statement will do that automatically now over here we have three i32 integers the elements in numbers are copies so there is no move here so we are iterating over each element in this array where n will then hold in each iteration one element from this array so let's see so and this would be the output as you can see in the first iteration name will hold this string and in the second iteration it will hold this string and it prints it out in each iteration then we print out the whole array and over here the same thing but with the integers so again we have an array so iterate the indexing and value in a so there is a useful method called enumerate and this enumerate method takes a collection for example an array or a tube pillar or anything else and it will then return a tuple and this Tuple will then hold the index and T value meaning for example in the first iteration this Tuple will hold for i 0 and for V4 right because at index 0 we have a value of 4 and it will then just print out the index but we increment it by one and the actual value and of course we have to put a into an iterator so let's see like that so we have to first put a into an iterator and then we can call this enumerate method on it because the enumerate method is implemented in the iterator trade we'll take a look at that later so as you can see this will be the output and that was the reason we have incremented I by one because we don't want to start with the zeroest element is four right so we say here the first element is four second three and so on while the while keyword can be used to run a loop when a condition is true fill in the blanks to make the last print Ln work so as you can see we have here a mutual variable n Loop while the condition is true so as you can see this is a while loop and we provided a conditional meaning if this evaluates to true then this Loop will keep running until this conditional evaluates two folds so inside the while loop we have other conditionals as you can see we here check the condition and modulus 15 is 0. if that would evaluate to true then we print out that and by the way this was a question at coding interviews at Google so we are here having more conditionals and a an else conditional so meaning if anything of this fails then this will get printed out so what we can do over here checking if n is less than 10 then this Loop will keep running now when you're using while Loops then you have to ensure that the while loop eventually stops right that this conditioner over here will evaluate to false eventually because otherwise you would have an infinite Loop now to do that we can increment and over here so I increment at the end of this while loop n by 1. meaning at each meaning in each iteration in this while loop n gets incremented by one so n will eventually be bigger or equal to 10 meaning this would evaluate to false meaning we break out of this Loop continue and break use break to break the loop so we have here a for Loop looping from 0 to 100 and 100 included so if n is 66 then we want to break out of the loop antibreak keyword will immediately exit out of this for Loop so when this conditional evaluates to true we immediately exit out meaning the program will continue execution after the for Loop in this case this line over here let's see so as you can see in the end n will be equal to 66. because when I is 66 then we stop iterating continue will skip over the remaining code in current iteration and go to the next iteration so as you can see we are here again iterating from 0 to 100 and we have here an if conditional if n is not equal to 66 then we increment n by 1. and we want them to continue meaning that that the remaining code in this for Loop will get ignored so discontinue keyword the program will go back to the beginning of the for Loop now in case this evaluates to false right so if n is in fact 66 this would evaluate to false meaning we ignore this code block and we go over here where we want to break out of the loo because as you can see we want n to be 66 at the end Loop is usually used together with break or continue so Loop is a special Loop in Rust where this is basically an infinite Loop and you have to manually manipulate the flow of the loop and we will see soon so this is a u32 over here count so let's count until Infinity as you can see we are here using the loop keyword meaning this would keep looping to Infinity or we provide some keywords that will break out of the loop or continue so as you can see in each iteration we are incrementing the count variable by one now if count is equal to 3 then we print out 3 and we want to skip the rest of this iteration so we can use here the continue keyword meaning again the rest over here will be ignored the program will go back to the beginning of the loop so then over here if count is not equal to 3 this will get printed out so we print out the count in every iteration except if count is equal to 3. and then over here if count is equal to 5 then we'll print out okay that's enough and we want to break out meaning count in the end should hold a value of 5. you can see we are iterating one two and then in the third iteration this if conditional evaluates to true meaning we print out three and we continue we are going back to the beginning so the actual value of count over here is not printed as you can see there is no digit 3 but will printed out three over here because that was defined in this code block here and then add iteration 5 we will stop and break out of the loop so Loop is an expression so we can use it with break to return a value and again we have here a counter so over here we have a loop and we are in each iteration incrementing counter by one then we check if counter is equal to 10 then we want to break out but as you notice we want to assign a value to the result variable right this variable should then hold an i32 but we don't return anything here so you can Define after the break keyword a return value meaning for example we want to return counter but in this case result will hold 10 right because counter when we break out will be 10 otherwise this conditional would not evaluate to true so if counter is 10 then we break out but as you can see we want result to be 20. so we can even pass here an operation so we can double the counter value let's see and this is compiling it's possible to break or continue outer Loops when dealing with nested Loops in these cases the loops must be annotated with some label and the label must be passed to the break continuous statement so as you can see we can even Nest different loops so when we do that we have to actually provide labels so we provide here outer for the Outer Loop and inner one for the inner loop and as you can see we have even two inner Loops so we have inner one and inner two alright so let's see in the first inner loop we are checking if count is bigger than or equal to 20. if this is the case we break out of this inner loop otherwise we increment the count by two all right and notice here this would break only the inner one Loop so when we break out of this Loop this outer loop will still continue looping okay so then over here in the outer loop we are incrementing count by five and in this inner two Loop we are then checking if count is bigger than or equal to 30 then we break out of the Outer Loop otherwise if count is smaller than 30 then the outer loop will continue meaning the program will go back to the beginning of the outer loop and continue executing from here so let's go step by step and as you can see we have to find out here what the count value will be in the end okay let's go step by step we start at zero then over here we are checking is Count bigger than or equal to 20 no right so that means count will get incremented by two and this will continue because we are in this Loop remember and this will continue until this evaluates to true meaning when count is 20 then we break out of this inner loop meaning we continue executing here then count would be 20 and we increment it by 5. then we enter this inner two Loop so 25 is not bigger or not equal to 30 meaning we don't break off outer but we will continue outer meaning we go back over here now we enter this Loop here and 25 is bigger than 20 so we break out of this Inner Loop and continue here then we add 5 to count meaning count is now 30. so we enter this inner two Loop and this will now evaluate to true because count is equal to 30 meaning we break out of the outer loop so in this case count will be 30 in the end and this succeeded and I will see you in the next topic pattern match is a powerful construct that allows you to compare a value against a set of patterns and then execute different code based on which pattern matches and these patterns can be made up of literal values variable names wild cards and so on and in a match statement all possible cases must be handled and this is enforced by the compiler and really this match keyword is something that I really miss when I'm coding in other languages so once you get used to it you will love it and you will see why so let's see an example over here we have in coin enum and this enum holds variance of different denominations of U.S currency or U.S coins and here we have a function value in sense this takes as an argument a variant of type coin then it matches the argument and as you can see it matches the variance of this coin enum meaning if we provide an instance of this coin enum which holds a penny variant for example then it will return one right and this will then be the return value of this function so for each denomination over here it will return its proper value then let's see if let so I've said that in a match statement all possible cases have to be handled and this could sometimes lead to annoying boiler play code that is not really that necessary so for example we have over here an option type right a value wrapped inside sum and then we match this variable over here that holds this option type and then we are matching as you can see if it is sum then we the structure the value inside this Max variable and then we just print it out now as you can see we also have to match any other case meaning if it is not some in that case none then nothing will get executed meaning it will return a unit type now this is sometimes two verbose especially for cases like this for example you just want to unwrap something from a sum variant now what we can do instead is just using using E flat so it's exactly the same as this match statement but we know that config Max holds a sum value right so we don't have to so we don't have to consider the case where it holds a nonvalue and as you can see this is how we would destructure this value into the variable Max we will see a flat keyword and then the pattern so if config Max holds a sum then the value will get the structured let's do exercises fill the blanks so over here we have a direction enum holding directions over here as variance then over here as you can see we are instantiating the direction enum with a variant of the South so the type over here would be Direction then we match this variable here and if this variable over here holds Direction East then it will print out east now we want over here to match south or north so what we can do over here is pattern matching either south or north and we can do it like that so we are here matching so we are here basically saying if this variable holds either a variant of south or north then it will print out south or north now in case it's not any of these variants then it must be West right so we can print out here West let's see and as you can see the variable holds South so this will get matched so this will get printed out match is an expression so we can use it in assignments over here we have a Boolean value fill the blank with a match expression Boolean true binary one Boolean false binary zero so what we want to do is we want to match this variable over here and then we provided the cases so if it is true then we should return one otherwise we return zero so that means the return value over here will then be assigned to this binary variable let's store that as u8 and that means binary should then hold one right because we are matching here true and then the return value should be 1. using match to get the data and enum variant holds again we have the message enum we have seen that before then over here we have an array of message variants over here we are iterating over this array and passing it to this function as you can see the argument should be of type message so we are then matching this provided argument so we want to match over here message move now as you can see the message move has struck like syntax so we have to match it like that and and as you can see we want the variables A and B so let's do that as you can see it holds Fields X and Y and that means we will then destructure these values into the variables into the variables A and B so a should hold 1 and B should hold three then we match over here the message change color variant as you can see this is a tuplelike variant and this Tuple has three elements so we can provide it some variables and we use here RGB red green blue and this is for color representation so in that case G the second value should be 255. and the last value B should be in this case 0. and again because we have to match all the cases if there is anything else that doesn't match here we will print out no data in this parents like that matches matches looks like match but can do something different so the macro matches allows us to test for example this array if a pattern matches so as you can see we are iterating over the elements of this array so over here we have the assert macro and all this does is it asserts that the given argument evaluates to true so we can over here use team matches macro and we provide it a b meaning the character we are iterating over and then we can give it a pattern it should match so as we are iterating over each element over here it should match each of these characters and we can do that like this so we want to match characters from a to and including z or a to and including that lowercase or zero two nine and notice these are characters and not integers because we have here an array of characters let's see and this succeeds as you can see all we did is we iterated over each element and we checked over here for each element if it matches if it matches this pattern and in this case everything matched because assert didn't Panic right because if one of them would evaluate to false insert will cause the program to panic let's see exercise five so over here we have an enum with two variants full and Bar then here we have a count variable which is initialized with zero and over here we have a vector now we didn't cover vectors yet but they are very similar to arrays but their size can shrink and grow meaning during a vector is dynamic in its size so as you can see we are having a vector of my enum variance two of them fool and one bar so this is a vector holding types of my inner then over here we are iterating over the elements of this vector now we want to match my enum Foo and if conditionals don't allow to match for patterns so we can't use that here but we can do something else we can hear instead using matches macro meaning we take e the element in the vector we are iterating over and we match it for this pattern right so if the element we are currently iterating over matches my enum full variant then we want to increment count by one like that and that means count after this for Loop iterating over each element should be two right because matches matched two times because there are two my enum full variants in this vector if let for some cases when matching enums match is too heavy we can use if let instead so over here as you can see we have an option of type i32 we move the whole match block using IF let instead so as you can see match is really verbal so we can use E flat instead and we do that like this we use the E flat keyword and then the pattern we want to match in this case sum and the variable should be I so the inner value here will get the structured into this variable I and then we are matching on all and if this matches then we want to print out these two lines as you can see this is much cleaner and this will get printed out this is a really long string and seven as you can see we here provide I and I just holds the inner value of this sum variant fill in a blank we have here a full enum with a bar variant holding a type of u8 then over here we have an instance of the bar variant holding a value of one now over here again we could do the same thing we can use E flat and then we match the pattern so if the pattern is full bar then we want to destructure the inner value to a variable I and we are matching on a as you can see this compiles so we have a full Anum with three variants and only the last one holds a value so over here we instantiate the full enum with a variant of cues and a value of 10. I hope I pronounce it correctly so remove the codes below using match instead so if I run this code then this would actually work because we are using IF let here but we can do it in a match statement so we match on a right and then we can provide the pattern so in case of full bar then we would then we will print out this line in case of Foo Bass we want to Output this line and in case of anything else like that we print out this line now I can delete that and as you can see much cleaner so in this case match others shadowing fix the arrows in place again we have here an option with an inner value of i32 then we are here using E flat to destructure the inner value to H and that means we are actually shadowing H because as you can see this variable here has the name H and we are then destructuring into a variable h so that means H has been shadowed create a new variable with the same name as previous age now over here as you can see H would be sum 30 which is wrong because we are actually here destructuring it right so H doesn't hold some 30 anymore but it will hold 30 because we are here destructuring it the new variable H goes out of scope here right so this variable over here goes out of scope and image can also Shadow a variable so we can here essentially doing the exactly same thing like in the uh like in the E flat statement over here foreign this would be the output from this match here alright see in the next topic so let's see patterns we can use this sign to match several values and we can use this one to match an inclusive range so as you can see we have here a function match number which takes an integer as argument then we are matching this integer and if it is one then we will then we'll print out one and fill in a blank with this don't use ranges okay so we have to match here two to five so we can do it like that and this pattern is basically saying if n is either 2 or 3 or 4 or 5 then we will print this match an inclusive range so if the so if n is between 6 and 10 where 10 is included then it will print out that and for any other case because again because again in a match statement we have to match every case so in this case we will print out that the add operator lets us create a variable that holds a value at the same time we are testing that value to see whether it matches a pattern so let's see we have here the point struct that has two Fields with I 32 types fill in the blank to let P match the second arm so we have to complete here something we have here an instance of the point type now let's see the match here so we match on P and as you can see this is how we would match a struct so we provide this track name and then the fields as you can see we are matching X and Y so so if Y is equal to 0 that means this arm here matches and this will get printed out and we then can use x over because this is actually a destructuring assignment so this would be the same as writing it like that but this is shorthand syntax so we are then using X here now in the second arm as you can see we are matching X and Y Fields so X should be between 0 and 5 5 included and Y should be either 10 20 or 30. now as you can see when we are matching here this pattern we can't use x we don't use x here but we can in fact use y because we are using here the add operator so this means we are destructuring the variable y of the field y so that means the value that Y is holding over here will gets we'll get this structured into the Y variable and at the same time we are testing why if it is matching this pattern and the last arm as you can see we don't match for any pattern other than this main pattern and then we can use X and Y because again this would be the same as writing it like that all right now we want to match the second arm that means we have to provide values that match these patterns so let's see X between 0 and 5 so let's do three and Y 10 20 or 30 I will do 30. as you can see this second arm matched fix the arrows over here we have the message enum that's holding which is holding one variant with a struct like syntax as you can see this is one field ID of type i32 then over here we are instantiating this variant so this will be an instance of the message enum and then over here we are matching this instance so if it is hello then we match the ID field so is it between 3 and 7 then we want to output here the ID now the problem here is that we did not actually destructure this field here into its distinct variable right so we have to provide here each variable let's do ID because that's the one defined here and for that we have to use the add operator so we are destructuring and matching the pattern at the same time and over here this is already done as you can see we can also provide any a variable with another name as you can see so the value of the ID field then we'll get this structured into this new ID variable right it doesn't have to be the same variable name as the field we have and again we are destructuring and at the same time pattern matching and that's and that is the reason we are using the add operator and as you can see when we are matching like that then this ID over here got this structured because this is the shorthand for this all right and when we have a pattern here we have to wrap it inside parentheses that's also important and as you can see in this case the first arm matched right because ID over here the value is between 3 and 7. in match card is an additional if condition specified after the pattern in a match arm that must also match along with the pattern matching for that arm to be chosen fill in the blank to make the code work split must be used alright as you can see we have here an option with an i32 value then we have here split and we are here matching the num variable and we are doing that to basically restructure the inner value so we are putting the value of 4 into X right so we can then use x over here but we over here also want a match card to check if x in this case this value over here is less than split we can do that like this foreign so this basically is just for destructuring the this value into X and over here we have an additional conditional in match card to check for a more specific condition to be true so if num is a sum so if num is of some variant then we the structure X and check it again and if all of that matches then we execute this if it is a sum but yeah but the value over here is actually bigger than split then this will get executed and if num holds a none then we just return a unit type ignoring remaining parts of the value with with this so as you can see we have here a tuple I want annotate that so we are matching on numbers now we only care about the first as you can see and the last one so what we can do over here we are matching on a tuple right so this is a tuple and we want to destructure the first and the last values into the variables first and last we can do it like that right so we have the first then anything in between and then the last so first should all two and last should hold 2048. using pattern mutable reference to V to match a mutable reference needs you to be very careful due to B being a value after matching let's see fix the arrow with least changing don't remove any code lines so over here we have a mutable variable holding a string and this would be a variable that holds a mutable reference to a string now we match r and that means over here we can destructure it directly into a value like that so this string over here will then be destructured into the value directly we don't have to match mute the reference like that right and that means the value variable will hold immutable reference to a string and of course then we can modify this stream over here all right that's it see you in the next one a method is a function that is associated with a particular type or struct it takes parameters and returns a value like a function but it's defined as a member of a struct or an enum it's called using dot notation like accessing members of a struct and it's implemented through an implementation block let's see an example over here we have the struct rectangle with two fields and as you can see we can then Implement methods for this rectangle type using the input keyword and the name of the type we want to implement the methods for so then over here we can see that rectangle has a method called area it takes as an argument a reference to self and self stands for the name of the instance so inside the method we are multiplying self dot with this field by self dot height this field and then we return the result of this operation now again self over here will be replaced by the name of the instance so when we create an instance of rectangle with concrete values then as you can see we can call this method on the created instance right one meaning when this method is called like that then self over here will be replaced by rect one so here rect1 dot width times rect1 dot height meaning 30 by 50 will be returned now let's see Associated functions an Associated function is a function that is associated with a struct or an enum but doesn't take an instance as its first parameter so you can recognize an Associated function if it doesn't take self as its first parameter it's called using the name of the type not an instance of it and it's often used as Constructors for a struct or an enum so let's see an Associated function as you can see we have again the rectangle type and we Implement over here again in an implementation block the new Associated function for the rectangle type and notice we don't have a self here and you will see in a minute why that is now the new Associated function takes two arguments with and height both of type u32 and it will then create an instance rectangle and returns it meaning when we want to call this Associated function we don't call it on an instance right because we don't have self here we call it directly on the type so in this case we take rectangle double colon and then the function new and we provide it two values 5 and 10 right that means Rec 1 will then hold an instance of the type rectangle okay let's do the exercises we will skip this example because I've showed you that before and we will do the exercises directly methods are similar to functions declare with FN have parameters and a return value unlike functions methods are defined within the context of a struct or an enum or a trade object and the first parameter is always self which represents the instance of destruct the method is being called upon so as you can see we have the rectangle struct again and over here we have the implementation block we can implement the methods for this type now as you can see we instantiate rectangle over here with concrete values and then assign it to right one select one holds an instance of type rectangle then over here we call this then over here we call the method area on rect one and we should get back 1500 so let's implement the area method so the first thing is we always start with cell so every method takes as first argument self okay then the return type will be Au 32 right because we are here doing operation with these two fields now what we want to do to get the area of the rectangle is multiplying the width by the height so we use self.width times self dot height and I omit here the semicolon so this will get returned let's see so when we so when we call the area method on the rect one instance then rect one dot width times rect1 dot height will result will result in 1500 meaning 30 times 50. self will take the ownership of current struct instance however reference to self will only borrow a reference from the instance Let's see we have again destruct traffic light with one field now over here there is the implementation block we can Implement methods for destruct Now using self to fill in the blank so we have been using self like this right meaning we take a reference to the instance now this is actually syntactic sugar for this and as you can see itself with an uppercase s refers to the type we are implementing the method on right so in this implementation block when we use self uppercase it refers to traffic light and you can use this syntax or you can use like we did before using just self right and here we want to take immutable reference because we are here mutating the color field and again and this and this and that are exactly the same but this is not mutable so if I would do it like that then as you can see these are actually exactly the same thing but I would suggest just stick with that it's more readable and it's clear what you mean Associated functions all functions Define within an input block are called Associated functions because they are associated with the type named after the impul we can Define Associated functions that don't have self as their first parameter and thus are not methods because they don't need an instance of the type to work with so as you can see we again use the traffic like struct and here we have the imple block so let's see first Implement an Associated function new it will return a traffic light contains color red must use self don't use traffic light in FN signatures or body let's first see in main what's going on so we call here the new Associated function and disassociated function is associated with the traffic light type and again notice the difference is we call this directly on the type and not on an instance otherwise it would be a method so we call new and then we want to have an instance of traffic light back write this new function should return an instance of traffic light meaning we can then call upon this instance light the get State method and return Red so let's see over here we are expecting no argument right so let's leave it like that and remember Associated functions don't take self now the return type would be traffic light instance and because we should use self in here we can do that and again self in an implementation block refers to the type in this case traffic light then in there we want to create an instance of traffic light so again we can use self instead of this name and then we like normally instantiating it providing it concrete values so in this case we want this self.color field to hold a string of red like that and as you can see then we should get and as you can see when we call this Associated function we'll get back an instance with this concrete value a string red then we call upon this instance light the get State method so again self here refers to light because we are calling the method on this instance and it takes just a reference to the instance meaning light is usable even after this method call and all it does it will return the value inside the color field of the instance in this case slide so light dot color will hold a string of red multiple input blocks each struct is allowed to have multiple input blocks again rectangle struct and using multiple input blocks to rewrite the code below so we can either put all of the functions and methods in the same input block or we can even reorganize it using various different input blocks so we can for example put that in its own implementation block like that and it will work exactly the same this is just for organizing and restructuring enums we can also Implement methods for enums so over here we have the enum traffic light color with three variants Implement traffic light color with a method so over here in main we are instantiating traffic light color with a variant of yellow this would be the type annotation and then when we call a method color on the C instance it should return yellow so let's see so we could Implement that using a match statement then we match a self and if match self would be this then we return the string yellow okay and we can over here instead of writing the whole name of the type we can again use uppercase self referring to the type this method is implemented on in this case traffic light color and remember in a match statement we have to handle all the possible cases meaning we have to create an arm for right and for green two so let's do that let's see and as you can see because we have here an instance which holds the variant yellow we will get back yellow when we call the color method all right that's it until next time until now we have only been dealing with concrete types but we can also deal with generics and generics are placeholders for concrete types it enables writing more reusable and flexible code and it avoids having duplicate code for different types it's a zero cost abstraction meaning the rust compiler will add compile time fill out the generics with concrete types and there is also a concept called const generics I will just briefly touch upon it because this is more of an advanced topic but I will show you one exercise just so you get the idea from it so const generic is a type parameter that represents a compile time constant value it allows to write generic code that operates on values that are known at compiled time and it's mainly used for array sizes bitwits and other constants and you will see what I mean when you see the exercise let's start with generics so as you can see over here we have a struct a now this would be considered a concrete type because we don't deal with generic types in here now destruct s takes as an argument an instance of destruct a this is also considered a concrete type because again there are not generics used here now destruct sgen is considered a generic type because we are dealing here with a generic type parameter and this would be denotation when you declare a type for example then after the name of the type you annotate a generic type parameter like that using these symbols over here and then providing a name and by convention this is usually T standing for type and that means this struct can hold any type now as you can see we have here some functions this function over here takes s which is a concrete type the Gen spec takes as an argument an instance of s gen with a type of a now again a would be a concrete type meaning the type parameter over here is specified to be a concrete type so we can only pass to this S10 struct an instance of destruct a then over here we have the genspec i32 function which takes as an argument the S10 struct over here with a value that is of type i32 and over here we have a generic function meaning we are declaring after the function name the the generic type parameter T and then we can use it on here meaning that we can provide as an argument over here an instance of S10 with any type so let's see using the nongeneric functions so these over here are all nongeneric as you can see because we didn't Define a generic type parameter and all the values it is using are concrete right over here we have S over here we have S10 and this is taking as a value T over here the concrete Type A and over here it takes as concrete type i32 so all these are nongeneric functions the only generic function over here would be this one so let's see so we want to call Direct F and function and as you can see in the function signature we are taking as an argument a type of s so let's provide that now we have to pass into s the concrete type a right because that is defined in this struct then gen spec t so this function over here takes an S10 struct with a type of a now again a would be a concrete type so we provide here S10 and a right so we are passing to the S gen struct over here a value of type A and in this case we want it to be S10 and let's say 7 because over here we Define that this function should take as an argument a type S10 which holds an i32 integer then explicitly specify type parameter chart to generic so over here we are calling the generic function meaning we can pass to it and S10 type holding any possible type now we can explicitly specify a type parameter for this T over here and we are here saying T should be a char meaning we are calling the generic function over here with the type S gen and passing as a value a type of char let's say a and implicitly specify type parameter chart to generic so we don't have to annotate the type here it will be automatically inferred by the compiler so if I do the same thing over here let's go with Z this time as you can see this is compiling now again because sgen is defined to be generic over its type pass any value so let's pass for example a floating point as you can see this is also compiling because T over here is a placeholder that stands for any type possible but again when we annotate the specific type then we can only pass a character in this example so if I try 7.7 here this would be in compiler error if I Define f64 as you can see then it's working all right a function call with explicitly specified type parameter looks like that and this is also called the turbo fish syntax so let's see implement the generic function below so as you can see we are calling here the sum function with different types and that's the whole point of generics so here we are calling sum with two I8 integers over here we call this sum function with 2i32 integers remember if nothing is annotated then the default integer type is i32 and here the same thing but for floating Point f 64. so we have to use here generics otherwise this won't be possible over here we are creating our generic type parameter and again by convention this is called t then we take here the arguments so let's say a should be of type T and B should also be of type T and then we return a type of t meaning if we pass here to i8 integers then T will get converted to an I8 right this is just a placeholder and because we operate then on two i8s the type the return type will also be I8 so what we do is just adding together the two arguments and return it and over here we have to implement a trade bound and we'll cover that in the next section so we have to Define here that t should implement the add trait otherwise we can't use this plus sign over here and again we will cover that in the next section when we look at trades and as you can see this is compiling so we can pass to sum two numbers of any type let's see number three Implement struct point to make it work as you can see we are instantiating two point structs but over here we are passing to the fields different types so in the first instance we would have i32 values in the second instance we are dealing with floats so to make that possible we have to use generic so let's implement the point struct and we are defining here the generic type parameter and then we can Define the fields and as you can see the fields hold the type t meaning if we pass it intervals then X and Y Must both be integers if we are passing it floats then both of these fields must be of type floats now because we are here defining a generic type parameter this parameter over here becomes part of the type annotation so over here we are providing to the fields of the point struct values of type i32 so we must annotate that and over here we are passing f64 and as you can see this is compiling now again we don't have to do the type annotations actually I just want to make that clear as you can see the compiler is able to infer that for us modify the struct to make the code work don't modify this code so as you can see we are here instantiating a point but the fields over here hold different types so this is not working because T over here defines that both of these placeholders will be filled with the same concrete type so in this case if we are passing X over here with an i32 type then the compiler thinks that y should also hold an i32 now what we can do then is defining another generic type parameter and by convention you just go one letter further so T and U meaning we can then use here U right and this indicates that the fields over here hold different types or could potentially hold different types they can also hold the same types and then when we annotate that we have said that the generic type parameter becomes part of the type annotation so we would pass here for x so we would pass here for T and i32 the value the type the X field is holding and over here a string so this would be the type annotation for this returned instance number five at generic for well to make the code work don't modify the code in Main so here we have the valve struct holding one field and we have an implementation block implementing one method for the well type now how do I know it's a method because it has as first parameter this self keyword and all this Value method does is just returning a reference to the Bell field value all right so when we instantiate the Bell struct over here we are providing a type of f64. but over here we are instantiating the valve field with a string so again we have different types so let's annotate here the generic type parameter then we can use T here meaning the Field Val can hold any type so let's annotate here now over here as you can see we are returning the value of the Val field and we Define here that it should be of type f64. now this would cause an error because when we call over here the Value method on the instance of Y then self.wall would hold a string right so it doesn't return an f64. now we have to use a generic type parameter also in this implementation block and we can do that like that so we have over here the generic type parameter for our type and as we've said this becomes part of the type annotation and over here we are also defining a generic type parameter T so we are then able to use it inside the implementation block so over here we can Define that it should be a reference to T right a reference to any type that the wall field holds so in the first call of value it would be an F 64 right that is the type of The Returned value that Val field is holding and in the second call over here it would be a string right so T then would be string number six we have here a point struct and we are here defining that the fields could potentially hold different types but they could also be the same and here we have the implementation block for our point struct now as you can see over here we are instantiating a point with I 32 values right so they can be the same even if we here have two generic type parameters it doesn't matter they can be the same but over here we are instantiating point with two different types right we are instantiating point with a string literal this here and HR that over here so they are different in its types then we call over here the mix up method on P1 and provided an argument of P2 and then over here as you can see we want then P3 to look something like that so we want the newly created instance here P3 to hold the value of the first instance in this case P1 as you can see we are taking X from P1 and we want the Y field to hold the value of the P2 instance of the P2 instance this character right so how would we do that with generic type parameters now let's first Implement here the mix up function and again the convention is just the more generic type parameters you are declaring you just go further in the alphabet so T U V W all right and as you can see as a first argument we are taking P1 now let's take ownership we don't care because we don't use P1 after this point meaning we can take ownership and we don't have to use a reference to self here and as an argument here we want P2 meaning a point with generic type parameters we are declaring here and the return type will be a point with a generic type parameter t and a generic type parameter of w and you will see why that is so then what we want to do is creating here a new instance and we provide here x which should be of self because self here refers to P1 right so we want self and we want the x value and Y should take it from the second argument the P1 over here and we want the Y field so let me actually annotate that as order right we take here another Point instance and this would refer to P2 because we are passing P2 over here to this mix up method so we take from P to d y field and then we are returning this instance meaning P3 will then look something like that right so let me annotate the type we would have a point with the x value of P1 and i32 and a character type of P2 the Y field right and that is what we will get let's first see if this even compiles and this is compiling now as you can see we have here a lot of generic type parameters so when we take a look at the mixup method as you can see we are here declaring new generic type parameters because we want to Define over here that the types self and self again refers to the instance over here P1 that these types are different from the types provided on the second argument the instance of P2 right if we compare it together then P1 instance holds different types than the P2 instant so we need new generic type parameters because t and u are for this P1 instance and the other the argument we are here providing P2 will hold different types right and as you can see we are then taking from P1 the X field and from P2 we take the Y field and this would be the return type a point with t this is from P1 X and W this would be the second type from DP to point all right fix the errors to make the code work as you can see we have here is tracked point which has two fields which are generic over its type and we Implement over here a method for the point struct over here now this method over here is in fact only implemented for a struct point that holds F 32 types of fields right so if we would pass floats then this method is not implemented for a point so this is only implemented for point with a concrete type of F32 now then over here we are calling on the fields X the power integer method and let's see that in the rust documentation so as you can see the power integer method over here is actually implemented for f 64 types right so self in this case must be of type f 64. as you can see over here we have X which holds an F 64 type so we can we can call this method on X right again this is a method and not a function so the problem over here is that self in this case would be F32 which is not the right type so let's change that f64 and that means self over here would be of type f64 the concrete type we are providing here and then of course the return type would be f64 right because we are here performing an operation on two f64 types now over here of course we have to provide floating Point values right because again this method is only implemented for a point that holds as Fields F 64 types like that all right and then we can use this method as defined in the standard Library and of course over here we just have to annotate one type right because we only have one generic type parameter and as you can see this is compiling and I will see you next time so I've told you that we will take a brief look at const generics and I will just solve one exercise and leave it at that because constant generics is a more advanced topic and you don't need it that much in your everyday programming so they're useful at some situations but they are not that much used so let's see an example over here we have here a struct array so we have here destruct array which defines two generic type parameters t and n now T is a generic type parameter and n over here is a const generic type parameter and as you can see each array struct holds a data field with an array of type t and n elements all right so when we look over here we have an array and I will now annotate this type of type array right this struct distract we have defined over here we are holding three instances as you can see one two three three instances of this array struct right like that now I've told you that when we have generic type parameters it becomes part of its annotations we have to annotate it over here too in fact we don't have to do that because it's usually inferred by the compiler but I will do it right now so this over here cares about the types in the aerated data field holds so as you can see we have here integers we have here floats and over here we again have integers and what that means is that in this array over here these actually should all hold the same type because we have to provide here a concrete type right for T and that means this data field over here will then hold in its array this type so in this case we will do i32 and we need to provide it a constant meaning for the length of the array in this case we Define three all right and what that means is that the arrays inside the data field of these instances must be of i32 type and they must have a length of 3. right so we can't use floats here we have to use i32 and over here we need to add another element now they can't be different for example let's do it like that that is possible but all of them over here must have the same type and the same amount of elements because we are annotating that here so it complies with the generic type parameter annotations here now let's create another array with floats now I want this to hold array instances of type f64 and let's do two elements and I will pass here let's say also three and that means inside here let's first look at the outside array at this array over here so we want three elements of type array this array struct right so let's define that like that as you can see we have here three elements of type array now we Define here for the generic type parameters that the data field the data field should hold an array right because this is defined over here in the array struct so each data field should hold an array of f64 right the T over here of two elements right this is the const generic parameter so we are passing here a constant and not a type so in this case we the data field would have concrete types of f64 and two elements right so let's fill that out like that as you can see this is compiling because we are here complying with the generic type parameters we have three array instances right and each array instance holds a data field with these types f64 and they have to be two elements inside the array all right see in the next topic we will now cover trades so a trade is a set of methods that can be implemented for multiple types in order to provide common functionality and behavior between them a trade consists only of method signatures which then have to be implemented by the Target type it's similar to classes in other languages but not quite the same and it defines shared behavior in an abstract way so let's see how that might look like as you can see over here we have two custom types sheep and Cal now we want to indicate that these are somewhat related so over here we have created a trade anime which defines one method then over here we are implementing the animal trade for sheep and for cow now when we Implement a trade for some type then we have to implement all the methods the trade defines so in this case as you can see in the trade animal we only provide it with a function signature and then the concrete types for example sheep and cow will implement the method and Its Behavior so as you can see both sheep and cow then implement the animal trait meaning they automatically implement the method right so both of them take a reference to its instance for example an a ship instance and then just return the string over here and the same thing for cow now there is also derivable traits and we have seen that before a trait can be automatically implemented for a struct or an enum by the rust compiler these are called derivable because they can beat derived automatically and the most common derivable traits are debug allowing to Output content via this debug notation we have seen that clone which enables a type to be duplicated with the Clone method copy enables a type to be copied implicitly without requiring explicit clone method and partially queue enables comparison now we can pass trades as parameters so the notify function over here takes as an argument any type that implements the summary trade meaning we can ensure that the item argument over here implements this summarize method right if we provide here A type that didn't implement this summary trait then it wouldn't have this summarize method trades can be used as parameters for functions the function notify takes as an argument any type that has implemented the summary trait now there is also a concept called trade bounce meaning if we declare over here a generic type parameter we can define that the type over here must implement the summary trade so the argument we pass to this notify function must implement this summary trait and this is similar to the example using the impulse summary but more verbose so as you can see this would actually be exactly the same like we did over here trade bounds are declared like generics after the name of the function and use trade bounds if you have lots of parameters to avoid this so if we would have here an argument which takes a typed Implement summary and another argument which again takes a type that implements summary we can do it like that so we Define here a trade bound meaning the generic type T must implement this summary trait so both argument 1 and argument 2 take a reference to a type that implements the summary trait and if you have big trade bounds like for example this we have here generic type parameter T and we say here that the type T has to implement the display and decline trades and the generic Type U has to implement the Clone antidebug trait right and then over here as you can see the first argument must be of type T and the second one of Type U and we are taking references so we can write that in a more concise way using a verb Clause meaning after the return type in a function we can use the verb keyword and then over here Define our trade bounds and this over here is exactly the same as this but instead of defining the trade bounds directly on the generic type parameter we do it in a separate block foreign and we can also return from a function a type that implements a specific trait so as you can see the return dog function over here returns an instance of the dog struct and because the animal trade over here has been implemented for torque we can also Define the return type as follows we return here an instance of talk meaning we return here a type that implements the animal trade because as you can see animal is implemented for the dog struct let's see exercise one feeling the two input blocks to make the chord work don't modify the code in main now we have here a trade hello finding two methods now over here you can see that we didn't only provide the function signature but we implemented basically the whole method why is that because this is considered the default implementation meaning any type that implements the hello trade automatically gets this default implementation of this method so we don't have then to implement it manually it will automatically get implemented for the type that implements the hello trade but as you can see over here we have a method which is here just a function signature so we have to implement that manually then over here we have two structs student and teacher and we Implement over here the hello trade for student and for teacher so let's see we have here an instance of student and as you can see this is just a struct that doesn't hold any values right so we instantiate it like that but because we have here implemented hello for the student struct that means we can then call upon it this method over here as you can see we call this say hi method on the S instance and then it should return high now we don't have to implement this say hi method over here again like that we don't have to do that because it's already implemented by default right but what we have to implement is to say something method because as you can see we are calling the say something method on the instance of s and remember when we Implement a trade for a type in this case student we have to implement all the methods except the default implementation here so let's actually take this and copy it over because the function signature must be exactly the same like defined in the trade and then over here we want the return to be I'm a good student so let's return this string here like that so when we call on an instance of student this say something method then it will return I'm a good student now over here we are instantiating the teacher struct and as you can see we are calling the method on the T instance and this should be the returned string so as you can see this is different from what is implemented in the default implementation and that means we have to reimplement this say hi method for the teacher type and the return string should be hi I'm your new teacher so as you can see if a trade defines a default implementation we can also overwrite the default implementation and provide another return value and of course because we have to implement this over here I will copy that and I will implement it for the teacher type so as you can see when we call the say something method on an instance of teacher then we should get back this string so as you can see we have then implemented the hello trade for our custom types student and teacher let's see if that compiles and this is compiling derived the compiler is capable of providing basic implementations for some trades via ddrive attribute for more info please visit here let's see over here we have a tuple struct centimeters which holds a value of type f64 now as you can see this truck here derives to trades partially q and partial order meaning the compiler will automatically Implement these trades for our type centimeters now partially Q is for comparing equality and partial order is for ordering so over here we have inches and and inches is a tuple struct that holds an i32 type and it derives the debug trade meaning we can print it out using the debug notation and as you can see over here we Implement a method two centimeters for an instance of the inches type so when we call this method on an instance of inches then we will convert it to centimeters right so we hear the reference self meaning the instance of inches and then we destructure over here the inches basically the value that the Tuple struct inches holes so this variable then will hold the value of the instance provided here okay and then as you can see we are multiplying inches by 2.54 to convert it to centimeters and we are wrapping that and we are returning that as an instance of centimeters as you can see add some attributes to make the code work don't modify other code so as you can see over here we are instantiating this seconds struct so then we are printing it out using debug notation so we have to derive over here the debug trade then we are here comparing for equality so we have to derive The partially Q trait and over here we are checking if one second is bigger than one second meaning we need to implement the partial order trade like that and as you can see we are here instantiating the inches struct providing it a value of 12 right this i32 type and then we print it out and let's check debug is implemented so we can print it using debug notation and over here we are instantiating the centimeter struct as you can see centimeters takes a value of f64. and over here we are comparing as you can see over here this foot instance holding an instance of inches with 12. so in the U.S 12 inches equal one foot and then we call the two centimeters method on it mean meaning this will then return an instance of centimeters right so we are taking here inches 12. and that means 12 over here will get destructured right here we have here self would be inches 12 and we take it as an reference like that so we destructure it like that using the let keyword the reference because we want to take the value and not a reference and then 12 will be put inside the inches variable then we are multiplying by 2.54 and returning an instance of centimeters and that means we can then compare this over here with the meter because the meter holds also the same type namely the custom type centimeters over here right so both types would be here of type centimeters and if this is smaller than this then it will assigned to this variable a string smaller otherwise bigger and these are string literals by the way and over here we are outputting the result of this compare let's see and as you can see this is compiling so we are outputting here one second looks like seconds one as you can see we can output this type over here seconds because we have derived the debug trade meaning we can use debug notation then one foot equals inches 12. and over here this one foot is smaller than one meter operator in Rust many of The Operators can be overloaded via trades that is some operators can be used to accomplish different tasks based on their input arguments this is possible because operators are syntactic sugar for method called example the plus operator in a plus b calls the add method as in a at B over here this would be a method this add method is part of the add trade hence the plus operator can be used by any implementer of the add trade so Implement implement the function multiply to make the code work as mentioned above plus needs T to implement standard Ops add trait that's why we are here importing the Ops module from standard Library so let's implement the multiply function as you can see over here we are providing two u8 integers to the multiply function now in the second call over here we are providing flow means we need a generic type parameter like that so this function takes two arguments and it will return T basically the same type of the provided arguments and then over here we basically just want to multiply a by B now as you can see over here we are using the operator for multiplications and that means we have to ensure that the T over here the type of the arguments that the multiply function takes implements the Mal trait now the mall trade like the add trades over here then knows that if both of the types of A and B Implement The Malt rate it is possible to multiply these two together so we can use here a trade bound meaning the type T over here should implement should implement the standard of malt rate because again this is just overloading and syntactic sugar for this call right so this actually would translate to this and we are seen in the add over here that it would be a at B right these operators are just overloaded so it's easier to use and that's why we have to ensure that a this argument here of type T has actually implemented the Mal method and we make sure that this is the case when providing here a trade bound meaning T must Implement The Malt rate meaning then that t has implemented the Mal method let's see and we have here to also find that the output will be of type t because as you can see the mult rate over here has an Associated type of output so we have to Define and we will take a look at Associated types but we have here to Define that the output should of type t that the output should be of type T right let's see again and this is working fix the arrows don't modify the code in main so over here again we are using the Ops module from the standard Library then we have here two structs full and power and full bar and Powerful the standard Ops add trade is used to specify the functionality of the plus operator here we make add bar to trace for addition with a right hand side of type bar the following block implements the operation full plus bar should return powerful so if we USD plus operator with these two types over here we should return this type right full plus bar should return full bar now let's see the add tray now the add trade over here takes as default parameter rhs standing for right hand side if we don't provide anything to right hand side then it will be self meaning the type we implement the add trade on and as you can see we have an Associated type here for the output and over here as you can see it takes self and basically becomes the owner when called on an instance that implements the add trade and right hand side is off type right hand side which means by default it would be self and this looks confusing I know but you will get it when we Implement that over here so as you can see we are implementing from the Ops module the add trade so we can Implement from this standard Library trades for our custom types and let's see again when doing something like that then then the compiler will actually do something like that right it will call the add method now this over here is the type here would be an instance of Foo but just so you get the concept and as you can see we have here to define the right hand side meaning the right hand side over here would be poor and we are implementing the add trade for Foo right because we want the instance to be of Type 4 so we implement it for Foo and we want the right hand side to be of type bar now if we wanted to add for example then we could omit that because you are seeing that the default itself right so the default right hand side would be self as you can see so we can omit that but the bow but that means both types must be the same in this case Foo and fool right because self over here refers to the type we are implement the trade four right but in this case it would be bar right because the right hand side is different from the left hand side and the output should be of type full bar so as and again Associated functions we will cover that very soon so over here we have to implement the add method right because the add trade over here defines an add method so we have to implement it and that means we take self and this is taking ownership of an instance of Foo right and right hand side would be of type bar again as you can see Foo would be the instance then we call the add method upon the instance and this argument should be of type par and then we return full bar so in Main when we call so in main when we perform this over here full plus bar we will get back full bar right so we have implemented the plus operator on our custom types now let's do the same for minus sign but in this case full minus bar would be powerful so let's see as you can see this would be distract we want to return powerful so minus sign is actually the same but implementing this sub trade so we will type full sub R right this would be the sub method defined in this sub trade as you can see we are here implementing the substrate from the Ops module for bar now again we want actually to implement it for Foo because here we call Foo support meaning we would implement it for the foo instance because cell 4 here refers to the instance the method is called upon right so the sub will be called upon self meaning we have to implement it for Foo and the right hand side would be bar now we want to return bar food that's true and over here as you can see the sub method is implemented but as right hand side the type should be bar right this is the right hand side of the operation and we are returning powerful so when we do this full minus 4 we will get back powerful so we have overloaded this operator and of course to do assert EQ here because this is a custom type we have to implement the partial EQ trade so let's do that and we also have to implement the debug trade as you can see this is compiling meaning when we use our custom types with these operators they will return a custom type and we can do that by implementing from the Ops module from the standard Library the appropriate trades for our custom types use trade as function parameters instead of a concrete type for the item parameter we specify the input keyword and the trade name this parameter accepts any type that implements the specified trade as you can see we have here a trade summary Implement function summary to make the code work fix the errors without removing any code line so over here we have a struct post with three fields of type string and we Implement over here this summary trade for the Post struct meaning we have to implement the defined method in the trade so we implement it for post like this as you can see we are accessing from the instance remember this is a method so it refers to an instance it is called upon right so we access the fields self.title and self dot author all right then over here we have a struct Weeble with two fields of type string then we implement the summary trait for Weeble and we then have to implement the method from the trade all right because again when we Implement a trade for a type we have to implement its methods so this over here accesses the username and contact field and prints it out now here we have an instant of post and here we have an instance of weibo so as you can see we are here calling this summary function with an argument of post and weibo so we have to implement this summary function below let's do that now as an argument it takes now as an argument it takes in the first call Post and in the second call Weeble right two different types but now think about it what do they share in common write they implement this summary trade right we have implemented it for post and for Weeble so we can Define over here that the argument provided must be a type that implements the summary trait and we do it like that and then inside the function body we want to take this argument and again a is an instance of a type that implements the summary trait so we are taking a and we call upon it the summarize method meaning the first one it will be post dot summarize now post over here is of type post meaning we go to post and as you can see this would be the summarize method as you can see self would refer to the instance in this case post this instance over here so then the summarize method will return a string so let's actually assign this to a variable this would then hold this string and we can then output like that let's see and of course when we are calling the summary method with an instance then we can't use the instance again so let's define here that it should take a reference right and as you can see this is compiling now what we can do over here and this would be exactly the same we can Define here a generic type parameter T and here Define that it should Implement summary right so we Define here the type t and it should be a type that must Implement summary and then we can write it like that so a should then be a reference of type T which implements summary trait let's see as you can see exactly the same thing returning types that Implement rates we can also use the infiltrate syntax in the return position to return a value of some type that implements a trade however you can only use input trade if you're returning a single type use trade objects instead when you really need to return several types so over here we have two custom types sheep and Cal and we have one trade animal which has one method so over here we are then implementing the animal trades for both of these custom types and as you can see when we Implement a trade for a concrete type then we have to implement the given method so over here we have a function random animal it takes a random number and then and then looks if the random number is less than 0.5 it will return a sheep instance otherwise it will return a cow instance now over here the return type of the function would be a type that implements the animal trade which both of them do and as you can see in main we have here our random number and we call this random number on the random animal function so let's for now assume that this really is random okay so that means that when this is passed over here it could either be a sheep or a cow to be returned here but the problem here is that the return type in a function must be of known fixed size at compile time which in this case sheep might be bigger than cow or cow might be bigger than sheep so the exact size is not known at compile time so when we do that this doesn't work and to make that work we have to know about trade objects so let's see so trade objects using input traits doesn't work when returning multiple types different implementations of a trade probably with different amounts of memory but sizes of types must be known at compiled time in this case a trade object can be used a trait object is essentially a pointer to any type that implements the given trade where the precise type can only be known at runtime so over here for example we have a trade animal and two custom types token cat then we implement the trade animal for both of these types and as you can see we have a function return animal it takes a string and if this string is dark then it returns a dog instance now if it returns cat then it returns a cat instant but as you can see we are here providing a reference to the instance and not the incense itself because when we return a reference to a type that implements the animal trade it means that the size of this type is known at compile time because remember a reference is a pointer and the size of a power and the size of a pointer is known at compile time meaning it's of Type U size and U size is 8 bytes on a 64bit computer so the size of the return type is known it's just a pointer sized type so the size of the return type is known at compile time it's of size U size right because we are here returning a pointer meaning it doesn't matter if dog is bigger than cat or otherwise it's always the same size because pointers have a fixed size at compile time and that is how we would solve this problem so again here we have a function which so here we have a function which returns a type that implements the animal trade this could be dog or cat as the trade object is behind the pointer the size is known at compile time which is U size the size of a pointer this allows for more flexible code as the exact return type doesn't have to be known at compile time as long as the size is fixed so we don't care anymore about the size of dog and cat because they're behind a pointer and to understand what's going on you have to know about static and dynamic dispatch so let's first look at static dispatch static dispatch resolves method calls at compile time the compiler will generate function code for each concrete type that implements the trade it calls the appropriate function based on concrete types it's faster and more efficient than Dynamic dispatch but it doesn't provide great flexibility so we have here the trade animal holding one method say hi then we have Talking Cat and we implement the animal trade for dog and for cat now as you can see when we create an instance from dog and from cat and call the say hi method on it because as you can see every every type that implements the animal trait must have this method and when we then run this program then the compiler will actually generate methods for each concrete type in this case stock or cat because then the say hi method we are calling here on the dog and cat instance is known at compile time so the compiler then knows when we call the method on the dog or cat instance which method has to be resolved for which type so let's see Dynamic dispatch in Dynamic dispatch the specific methods to be called is determined at runtime and not at compile time like static dispatch it works by creating a reference or smart pointer to a trade object using reference din or boxed in when trade object is created the compiler will build a vtable for that trade a v table is a table that contains a pointer to the implementation of each method in the trades for the specific type of the object that the reference points to the compiler will do a lookup in a V table to determine which method should be called for which type that implements the given trade and this lookup will cause overhead but allows for more flexible code so exactly because of this lookup static dispatch is faster than Dynamic dispatch but on the other hand Dynamic dispatch allows for more flexibility so let's see how that might look like as you remember with box we are able to allocate a type to Heap memory meaning the type will then get allocated for example a i32 integer like 7 will get allocated to the Heap and we will then get back a pointer this is what box is for and we have seen examples of that now when we use box with a trait object it means that the type that implements the specific trade will get allocated in Heap memory get back a pointer to the location where the type that implements this specific trait was allocated and we will get back a v pointer right this is happening when dynamically dispatching so the V pointer points to the V table and in the v table there are certain Fields now there is also a field called Methods and this is where all the methods for the concrete type over here are located meaning at runtime the compiler will check this V table and see in the methods over here which methods are implemented for the concrete type that was allocated in Heap memory so let's see an example so we have over here a trade animal and we have two custom types cat and talk and we implement this method defined in the trade for both of our types right because when we Implement a trade for a custom type we have to implement all of its defined methods so over here we have seen we have a random animal function which takes a random number and based on this conditional it will either output a cad instance or a dog instance so then when we call this random animal function with the random number and for now just assume that this is really a random number that means the compiler first of all cannot determine the size of the type which gets returned and this is of type that implements the animal trade right cat and dog both implement the trade but we can't know the exact size at compile time meaning we put it behind a pointer in this case a box but a reference would also be possible and that means the size is now known right it's the size of a pointer basically U size 8 bytes in a 64bit computer but we have another problem over here the return value will be a type that implements the animal trade but at compile time when we call the noise method over here the compiler doesn't know which of these types get returned so he so the compiler can't know which method he has to call is it for the implementation on cat or dog right so this is why we use Dynamic dispatch because that means this over here will get decided at run time so again the compiler will then look up in this B table over here using the V pointer which points to the V Table stores in heaped memory and and then it will check for the concrete type that got allocated on Heap memory this specific methods so for example again this is happening at runtime we return a cat then the compiler will see that the type over here which is concrete is cat so it will see in the v table the methods implemented for the concrete type of cat I hope this makes sense so this is why we need Dynamic dispatch here static dispatch doesn't work because again the output of this function is random so let's see box box is a smart pointer that allows to store data on the Heap rather than this stack and you can use box when you have a type whose size can't be known at compile time it returns a pointer to the data stored on the Heap so what's the difference between a reference and a box in terms of memory a box allocates the data on the Heap and owns it is also responsible for deallocating when the value goes out of scope and the reference only points to a value that is already in memory meaning the reference points to something that is already there while a box allocates and a and the reference also doesn't own anything it just points to something in terms of lifetimes a box can be passed across Scopes while the reference has limited lifetime and we will cover lifetimes very soon a box can be cloned and the reference cannot and the Box can also be used in pattern matching so we have left off over here and I hope by now you know that this over here is not possible we cannot return a type which implements the animal trade because these could vary in size and again over here we return a type that implements the animal trade now if this over here would be really a random number then we don't know exactly at compile time which type gets returned meaning we can't use here the noise method because the compiler can impossibly know at compile time of course which method he has to call is it this one or is it this one right and for that we will use Dynamic dispatch so again we can put this in a box and using here the pin keyword meaning we want to go with Dynamic dispatch here and that means we have to box these instances so now the return type over here is known at compile time meaning we can annotate it it would be a box which holds a type that implements the animal trade and this is using Dynamic dispatch meaning we then can call this noise method on this instance here because the compiler can check for this noise method at run time and not at compile time meaning it is determined which of these will get called at runtime when the program is running let's see and this is working trade bound the infiltrate syntax works for straightforward cases but is actually syntax sugar for a longer form which is called a trade bound when working with generic type parameters often must use trades as bounds to stipulate what functionality a type implements so over here we are calling the sum function with two arguments in this case 2i32 arguments and as you can see we could also call this with floats because we have here defined t t generic type parameter so as you notice X and Y Must Be of the same type T and the type will be T which gets returned and all we do over here is adding X Plus y now again to use this plus operator here we must Define that t over here is a type that implements the add trade because remember this would actually translate to this so it's critical that X implements the add trait right and we also have to Define over here the associated type output to be of type t let's see this is compiling let's actually call the function and print out the result so as you can see the output would be 10. and we can call it with float right so let's see exercise 8 fix the errors as you can see we have a pair struct which has two Fields holding values of type t meaning they are generic and then we have an implementation block for repair and we Define here an Associated function and this is not a method because it doesn't have self as parameter now over here we are instantiating a new pair and remember self over here uppercase s refers to the type of the implementation block meaning pair and then we return this instance so if I write pair here it would be the same thing then over here we have another implementation block for the type pair and as you can see we Define here that t over here should implement the debug and partial order so the type T over here the type of the two fields the type of the two Fields must Implement debug and partial order then over here we are defining a method compare display which takes a reference to an instance of pair and then checking over here is the value of the X field bigger than or equal to the value of the Y field if that is the case then self dot X will get printed out using debug notation that is why we need T to implement the debug trade otherwise we print out the value of the Y field so as you can see over here we have a custom type unit that holds an i32 integer now over here we are instantiating a pair struct and as you can see we are passing here as concrete values for X and Y Fields the unit type our custom type and over here it holds one and here three write an i32 the type annotation for that would be we would have a pair instance and T over here would be unit right because X and Y hold a type of unit so T over here will be unit now remember we have over here an Associated function so let's actually use that to instantiate a pair as you can see this is exactly the same thing as this but here we are using the new Associated function that got implemented on the pair type so I can delete that and again when we call on this instance the compare display method then we would have an error because as for now doesn't implement the debug and partial order trades so we have to derive them and by the way we also need the partial EQ trait and that's because we are here checking for equality all right so we knew so we need partial equality and because we have now derived these trades for this type it means unit implements debug partial order and partial EQ meaning we can over here compare for equality and ordering and we can print the field out using debug notation let's see and this is running so the largest member is y you will need two so we have here a pair with an X field of unit 1 and the Y field of unit 2. and then the compare display method will give us back you will need two right because the wife because the Y field holds a value that is bigger than the X field compare these two because this is a custom type is only possible because we have derived these trades alright see you in the next topic so before doing more exercises on trade objects I want to cover Associated types now an Associated type allows to specify a type that is associated with the trade when implementing the trade for a specific type we have to specify the concrete type it's basically a type placeholder that the trade methods can use in their signature and it's similar to generic types but they are more flexible because they allow a trade to have different Associated types for different implementing types let's see an example we have here the my trade and this has an Associated type called my type and as you can see we can then use this Associated type over here in the methods we are defining in the trade so we here for example Define that the return type should be of type my type meaning when we implement this trade over here for a concrete type like for example my struct then we have to define the concrete type as you can see when we implement the my trade for my struct we Define here that my type should be i32 and as you can see this method over here will then return an i32 type and this is defined over here and we can access the associated type using self uppercase double colon and the name of the associated type now again self here stands for the type we are implementing this Trade four so in this case my struct all right let's do some more exercises practicing trade objects as you can see we have here a trade bird that has one method then we have here two custom types duck and Swan so let's see for duck we have an implementation block and here we Define a method and this method takes a reference to the instance and prints out something and for Swan we also Implement a method now notice this has nothing to do with the trade these are methods that are defined directly on the struct right so here we Define a method fly which again takes a reference to the instance and prints out something now over here we are implementing the birth trait for duck and Swan meaning we have to implement the method defined by the trade so as you can see this Quark method we have to implement for both types then over here we want to instantiate a duck so we then can call on this stack instance the swim method so this will then get executed then over here we call the hatch a bird function with an argument of two and over here we call the hatch a bird function again with an argument of one so as you can see when we provide two we want over here duck when we provide one we want over here a swan and I see that because of the output when calling the quack method so let's implement this function we have seen that the function takes as an argument and interfer so let's call the argument species and let's define it as u8 now I will keep the return type open we will see that then so let's see when we get one let's actually match the species argument when we get back one we want to return a swan if we get here for the argument A2 we want to return a duck instance and because we have to handle all the cases I will just panic in case anything else has been passed so over here what would be the return type now think about it when calling this function over here we have to provide the return type now again the return type has to be of known fixed size at compile time now over here we don't know what we'll get actually return that compile time right especially if this argument over here would be something that is generated at runtime meaning we don't know the exact size because this one struct could be larger in size than the duck struct or otherwise so we have actually seen the solution we need to box the return type and V over here Define that it should be dynamically dispatched and that means we have to box these concrete values here and now we are good to go because also another problem would be that in a match every return type has to be of the same type now again over here the function could sometimes return a swan or sometimes a duck right depending on the argument and when we do it like that we actually return a type of box right so they have all the same return type now again because we are here using Dynamic dispatch we have to put it behind a kind of pointer and that means over here we will get a box holding a trade object and the trade object in this case is bird so that means and we have seen that the compiler will then allocate the concrete type for example over here a duck in the Heap memory and we'll create a v table with all the methods because when we call over here the Quark method on bird then at this exact point Dynamic dispatch happens because it is not known at compile time which concrete type got returned here this will be determined at runtime so at runtime the compiler will check the V table and see the right and will execute the right method call right in this case it would be for duck so the compiler will look this method up in the v table for the tag type which has been allocated in Heap memory and we got and notice something over here when we return a trade object the trade object actually only implements the methods from the trade in this case Bird right so we then can't call because we have here a trade object we can't call a method directly defined on the type so for example this swim method is not in the v table that the compiler creates I hope you see that because again we are returning a trade object meaning in the v table are only the methods from the trade so over here because we have created an instance on the concrete type we can call this three method but over here because we have a trade object we can only call methods from the trade let's see and as you can see this is compiling array with trade objects again we have the birth trait with the same method then we have duck and Swan and as you can see these are methods that are implemented directly on the concrete type then over here again implementing the birth trait for duck and so on we have seen that fill in the blank to make the code work so over here we want to have an array because we are here iterating over this Birds variable meaning we want to iterate over an array now let's first annotate we want over here an array of birds right so we want a type that implements the bird trade meaning in this case stock and Swan and this time I will use a reference instead of a box so we Define over here that we want an array holding a type that implements the birth trait and is dynamically dispatched all right and again because using Dynamic dispatch requires that we put it behind some kind of pointer either box or a reference now with this array let's say we want to have two elements one duck and one swan so let's provide here the instances and again we have to put that behind a pointer so the size is known so the size is known at compile time because remember the size of the elements in an array must be known at compile time in this case it would be you size the size of a pointer now then we want over here to iterate over these elements here and then as you can see for each element we are calling on it the Quark method now again because this over here is happening at runtime the Quark method will be determined at runtime which one to run here for stuck or for swan right let's see and this is compiling now overs and here we have the same thing bird.fly the method we have directly implemented on the type isn't available because in a trade object over here only the methods from the actual trade birth are in the v table other methods won't get into DV table and so the compiler cannot look it up at runtime referenced in and boxed in so we have here a trade draw which has one method and we implement the draw trade for u8 and f64. as you can see we can Implement our own custom trades for types in the standard Library and all this does over here is it will take a reference of the instance and and it will output the value now in the newer version of rust we don't have 2D reference self here this is happening automatically like that and for f64 the same thing now as you can see we have here an f64 and an u8 basically the types that implement this draw trade then over here we are calling the function draw with box and as you can see this function over here expects a trade object of the draw trade and this trait object should be boxed all right and then it is calling the draw method again the compiler will then look in the v table and will execute the appropriate method at runtime so let's pass the argument for the draw with box function and in this case we want to draw X so let's pass it X and of course this has to be boxed right like this now over here we want to draw Y and this time we are passing a reference meaning we over here expect a reference to a trade object that implements the draw trade all right and then we are calling the draw method again this time on y let's see and this is compiling let's see exercise four we have a trade full which has one method then we Implement Foo for u8 and string types and as you can see we can Implement our own trades on types that are defined in this standard Library so in this case u8 and string then over here in main we have a variable X holding a u8 and Y holding a string basically the types we are implementing for for right and let's see now the function called Static dispatch so we pass here X tu8 type and this should be statically dispatched so let's implement this function Implement below with generics so we need here a generic type parameter and we Define here a trade bound meaning we want T to implement the foo trade right because we want the argument to be of type t so it's important that we Define here the trade bound because we call this function only with arguments that implement the full trade and we are defining that in order to be able to call the method method on it basically this method defined here right because then we can pass types of u8 and string to this function and it can call the method because the full trade is implemented for this type any other type that doesn't implement the full trade won't be allowed to be passed to this function so this is static dispatch because the compiler at compile time will actually expand this code and create a function for the concrete types so in this case we are passing u8 to this function so the compiler will create a function like this right and then we'll call it and this is happening at compile time meaning the compiler will fill in the concrete types over here and then of course the compiler will know when we do a method call which method over here it should call right and static dispatch is usually a lot faster than Dynamic dispatch because you don't have to do a lookup it's everything in the binary itself but when you have to do a lookup you have to follow a pointer to Heap memory and then get the data from this memory location which is more expensive so let's see Dynamic dispatch in this case and we use Dynamic dispatch because sometimes it's just not possible to use static dispatch right when the size of the returned type it cannot be known at compile time then we use Dynamic dispatch and let's see how that looks like so over here we are passing a reference to Y so we are passing here a reference to a string now as an argument over here we want a reference right that's what we are passing to a trade object implementing the full trade all right and again because this is dynamic dispatch so this happens at runtime must be behind a pointer so this size is known at compile time because it pointer is always of size U size we have covered that and then we call the method on the argument right the difference is that over here this will then be determined at runtime which method over here to be called right because the compiler will then do a lookup in the v table at runtime and then determine for which type the method should be called let's see this is compiling object safe you can only make object safe trades into trade objects a trade is object safe if all the methods defined in the trade have the following properties the return type isn't self and there are no generic type parameters so let's see exercise 5 use at least two approaches to make it work don't add remove any code line so I think we will go first with static dispatch because it's easier so I will remove this box here and let's see we have a trade here defining one method now this defines that it takes a reference to a self meaning a reference to an instance of my trait and it returns self their self over here refers to the type for which the nitrate is implemented so in this case for example over here my trade is implemented for u32 meaning we implement this method over here and self over here would refer to u32 right we can write it either way and u32 and string Implement my trade all right so they both implement the F method then over here we have a function that takes a trade object now in this case you want to use static dispatch so we Define here a generic type right because we are calling it with new 32 and a string now we want to ensure that t this type implements my trade so we can be sure that it implements this F method so this is called trade bound and this makes sure that t implements my trade so we then can call the F method on the provided argument here which is of type t and that's basically it we have implemented the static dispatch for this function over here and what then will happen is when we call this function the roscompiler will take this generic function here and it will provide it with concrete types and it will provide it with concrete types so in this case u32 right we are passing it to 32. and we have we forgot to define the return type so the return type over here would be the return type of the F method now in this case it would be T type right so if we are calling it so if we are calling the F method on a new 32 then the return type will be u32 in if we call it on a string then the return type will be string so again we pass here T right because the type we are passing for example u32 will be the return type of this function u32 and that in case means that the return type of this function over here will be u32 right okay and then the same thing happens for a string so the compiler will actually put into these generic type parameters concrete types and that means when we are using static dispatch these method calls here are known at compile time so the compiler knows if you're passing a u32 type then it will call the F method from the eu32 implementation of my trade right and in case of string then the compiler will know that the F method can be found in the my trade implementation of string right so everything here is known at compile time and also the size is fixed and this is working now we want here to now use Dynamic dispatch so we solve it in two approaches so before we can even use this straight object over here we have to make the trade itself object safe and we do that when the return type isn't self and there are no generic type parameters so we cannot Define here self we have to provide it concrete types now in this case we want the F method to return a trade object meaning we return a pointer that points to the type that implements my trade all right and over here because we are taking here this function signature and implement it for each type we Implement in my trade for so as you can see the return type must implement the my trade and it has to be boxed so we have to box this over here turn over here A U 32 right which implements the my trade and over here a string which also implements my trade so as you can see we got rid of self because again at compile time the return type size has to be known that's why we are putting it behind a box now again the return type of this function would be the return type of Team method calls in this case it would be a boxed trait object right let's see if this is compiling and this is also compiling now I hope you see the difference here when we pass here a trade object basically a type in this case u32 that implements the my trade trade then this method call will be determined at runtime and that's why we have to put this behind pointers so the size remains fixed and known at compiled time and again use whenever possible static dispatch because it's faster and I guess easier to write but Dynamic dispatch has its advantages and you can use it for more flexibility in your code alright see you in the next topic so we have reached the topic of collection types and string is also a collection type meaning we are just repeating because we have covered strings but I think these exercises are good for some repetitions so string is a utf8 encoded growable string it is the most common string type we used in Daily development it also has ownership over the string contents so let's see fill in the blanks and fix arrows don't use to string don't add remove any code line so as you can see over here we want a string type because we because we are here modifying the swing meaning it has to be growable so let's allocate this data over here on the heat so we have now a string type we can now let's see the poster method as you can see this push stir method is implemented on the string type and it takes as a type for its argument a string literal as you can see we are calling it on a string and providing it an argument of a string literal so we have to delete that because this would actually be a string right we want here a string literal like that and push is for pushing single characters so we want to push here an exclamation mark So s will then here match with this string literal and as you can see we are calling the move ownership function here meaning this function will then take ownership of s and that's not what we want because we are using here as again so what we can do is just clone it so the data passed to move ownership over here is actually cloned right it is copied on the Heap memory and that means we can still use S because s Remains the owner of this data all right then a string is stored as a vector of bytes but guaranteed to always be a valid utf8 sequence string is Heap allocated growable and not null terminated a string slice is a slice basically a slice to u8 integers because as you can see this string type is a vector of u8 inter source that always points to a valid utf8 sequence and can be used to view into a string just like a slice to T is a view into Vector T and we'll cover vectors after this topic so fill in the blanks we have here a string and we want to take a string slice from this string now the easiest method would be just to take a reference to s which means we take a reference to a string type and this can then be inferred by the compiler to a string slice and the second way would be to call the askster method on it this will essentially do exactly the same thing it will take the string s and we'll convert it to a string slice now over here we also want a string slice but we want to provide a specific offset we just want this data over here and that means we take a reference to s and provide it here an offset from zero we can omit the zero on here until index 0 1 2 3 4 until index four now we would provide here 5 because 5 is excluded meaning we go from index 0 to 4. and over here as you can see we want to modify the string holding then hello world because we are pushing to it this exclamation mark as you can see we want it hello world and with an exclamation mark so what we can do is taking s over here s mutable reference so this would then hold a mutual reference to a string let's see and this is compiling now notice over here we could also take ownership of s meaning slice 3 will hold a string because we are not using S after this point so slice 3 can be the owner of s but in this case we have to make the variable mutable and this is also working question how many Heap allocations are happening here so we have here a string and when we create a string type then the data that is provided is allocated in Heap memory so this would be the first allocation then over here we are taking from this string over here a reference meaning a string slice and remember a string size is just a view into some data so we are just going to this location and checking what's in there so no allocation is happening and over here we are taking this string slice and convert it to a string meaning a heap allocation is happening over here right because we are taking this string slice holding this and then we allocate this into the Heap once more being because we are calling this two string method let's see indexing so we have a string here and we want to index into the first element so slice one should then hold h so we want a string slice so we take a reference to S and provided the offset from 0 to 1. 1 is excluded meaning we just take the first character and that is because H only takes one byte in utf8 format so ASCII characters in strings usually take one byte while this Unicode characters over here take three bytes so when we take a string slice here we want to access this character now for that we have to provide the right offset so we go from 0 1 2 3 4 5 6 7. starting at index seven and as you can see these Unicode characters hold three bytes meaning we must provide here an offset of 10. 10 is excluded meaning we go from 7 8 9. three bytes iterate through all Source in s so to iterate over characters in a string type we use Stitch Source method but that will actually just return the Char we are iterating over but as you can see we want here as return type a tuple which holds the index and the actual character so we can use here to enumerate method and enumerate will return a tuple with the index and the specific character so in the first iteration you would have zero and H right the index and the character so here we are checking if the index over here is 7 then the variable C should hold this character right let's see and this is compiling now there is a crate called utf8 slice you can import it into your project and this then allows you to slice into a string not using bytes as offsets but just indexing into the individual characters so over here we provide an offset from four to five meaning we want the character at index 4. so we don't have to worry about the byte size of this symbol then fill in the blanks we have here a string now we have seen that a string is actually a vector holding u8 intervals and as you can see we have here some bytes in a vector so this Vector holds u8 inters right and that means these are bytes that can be converted to ASCII characters so in this case these over here will translate to hello all right if you look up this code over here in the ASCII table then we will find that this is represented for the character age and this e l l o so we want to turn a bytes Vector like this into a string so we want to be string here so let's see this method here so in the documentation you can see that the string type implements a method from utf8 and this just takes a vector of bytes and then we can call this Associated function on the string type and provide it as an argument a vector of bytes and this will then convert it to a string so we can try it out so first of all we want to actually mutate the string here to hold the same data as this Vector holds namely hello so we can do that by using poster and we push hello meaning this string then holds hello and then we can take this string type and call from utf8 method providing it this vector and this should then convert this Vector of bytes into an actual string meaning s and S1 will then hold the same value namely a string hello and of course this actually and this returns a result so we have to unwrap it and as you can see this is compiling so in fact a string is just a vector of bytes right and we'll cover vectors very soon and you will then see how this is actually stored in memory so a string is made up of three components a pointer to some bytes a length and a capacity the pointer points to an internal buffer string uses to store its data the length is the number of bytes currently stored in the buffer always stored on the Heap and the capacity is the size of the buffer in bytes as such the length will always be less than or equal to the capacity we have seen that the string type is a three bird object holding a pointer to the actual data stored in Heap memory the length which shows the length of the string in this case 5 and the capacity and the capacity as you can see here is the total amount of memory received from the allocator so when we allocate a new string type on the Heap the allocator we will find an empty spot and then we'll return a pointer to that location number six if a string has enough capacity adding elements to it will not really allocate so when we run this program over here then we see the capacity of string s now over here we are initializing an empty string meaning we have an empty string so nothing gets allocated to Heap memory we still have a string object but with a length of zero and a capacity of zero then we print it out as you can see Zero over here we are iterating two times modifying this string so in the first iteration s will then hold hello so it would have a length of five but when we print out the capacity it will show 8. so we have a string object that points to this data with a length of 5 and a capacity of 8. now this is the default behavior when we don't specify a capacity ourself so when the length exceeds the capacity then rust has to reallocate the data meaning it has to find a new spot in Heap memory that is big enough to hold the data and then we'll return a pointer to the new location so in this case because we have modified the string the length 5 exceeds the capacity zero so it has to reallocate because remember in Heap memory the data is allocated as contiguous block of bytes all right and the default behavior is that the capacity will always double so it starts from 1 then 2 4 8 16 and so on and that's the reason we have here a capacity of 8 even though we only need five right this is a length this is a string of length five but because of the default behavior of the allocator we will get back a capacity of 8. and then in the second iteration we again push hello right so we would have a length of 10 but as you can see the capacity doubles so 10 exceeds the length of 8 meaning the allocator will then find a new spot in hit memory to allocate this string over here of length 10. and it will then Reserve 16 bytes of memory in Heap memory and so on if we then exceed 16 bytes then it will allocate to a location which holds 32 right it always doubles and this is when you let rust allocate so this is the default Behavior but as you can see this might be expensive so if you start with a capacity of zero and then you modify the string multiple times it means rust has to reallocate your daytime and that means it could potentially be expensive when you mutate this over here multiple times and a lot of reallocations are happening so there is a function called with capacity and then we can Define over here that we want an empty string meaning the string length is zero but we want a capacity of 25 meaning s is allocated in Heap memory and there is enough space reserved for this data to hold 25 elements right so when we do that again then as you can see no reallocation has happened we have only allocated the string one time in heat memory with a capacity of 25. now because the length doesn't exceed the capacity in any of this modification of the string it means that there is no need to reallocate the data right so when we print out swing s over here in the end then as you can see this is the string that in the end hello hello so we have here 10 elements meaning there is no need for reallocation because a capacity of 25 can hold the string of this size and this can make your program a lot faster so let's see vectors a vector is like an array but dynamically sized meaning they can grow and Shrink it's allocated on the Heap as contiguous block of memory all elements in a vector have to have the same type and there is a special macro vac which you can use to initialize a new vector so all this time we've been dealing with an imposter so in actuality this string type is just a vector of utf8 bytes that gets allocated in Heap memory so as you can see when we have the S1 variable over here then again S1 won't hold the actual data but a pointer to the data allocated in Heap memory alongside a length and a capacity meaning S1 is a three word object of size 24 bytes now as you can see this would be a vector allocated in Heap memory that holds the utf8 bytes over here of course in memory this would be in binary but as you can see this then holds the character code for this character inside the string so let's do some exercises vectors or resizable arrays like slices their size is not known at compiled time but they can grow or Shrink at any time so over here we have a normal array holding three u8 elements now we can convert this array to a vector using the from Associated function and then passing it the array meaning we will then hold a vector of u8 elements and here you can see the difference between an array and a vector we don't provide here the length of the vector because the vector can actually grow or Shrink meaning it's dynamic in its size now the isvac function basically just checks if the provided argument is a vector then as you can see we are shadowing V and we are here initializing it with a vector of these elements so as you can see you can use the VAC macro to quickly create a new Vector like that so this will then hold a vector of u8 elements and by the way you can either use square brackets or you can use parentheses it's both exactly the same now as you can see here we are initializing V or basically shadowing it and then we are passing it to is back meaning ownership would be transferred but we are using V here again so let's clone this and over here as you can see we are initializing V1 with Divac macro now we are passing to the back macro the array Mac macro over here won't convert it directly to a vector like this from Associated function did instead we would here have a vector holding this array all right I hope you can see the difference here we have a vector of u8 elements over here we have a vector holding an array of three u8 elements so when we compare over here V and V1 they won't actually be the same right and again let's do clone here just so we can then reuse B1 now what we can do over here to fix that is using the VAC new like that and back new basically will then create a new empty Vector meaning it would be an object with length of 0 and capacity of zero now over here we want to iterate over the elements in v let's take a reference here because we are using V again and we don't want this for Loop to take ownership now all we want to do is pushing all the elements from we into V1 and because we are here iterating over references of elements we have to dereference it and by the way we will take a look at that in much greater detail so what we also have to do is making this V1 variable mutable because when pushing to it it has to be mutable alright let's see and this is compiling so in the end V1 will hold a vector of U 8 elements meaning V and V1 are exactly the same but remember when you have an array use the from Associated function and not the VAC macro because it won't convert it directly to a vector instead it will create a vector holding an array Evac can be extended with extend method so over here we have a vector let's say these are i32 values and as you can see we can pop meaning removing the last element so over here the vector will then hold 1 and 2 because the last element got popped then we are pushing to it 3. meaning we have a vector holding one two three now over here again we are initializing an empty vector now as you can see we want V1 and V2 to be exactly the same so what we can do is using the extent method and providing it the V1 vector meaning the elements foreign and we have to pass here a reference meaning the elements then from V1 will be put into V2 so again V2 will then be a vector of I 32 elements and they hold exactly the same data right it's basically copying the contents of a vector into another vector turn X into back fill in the blanks so over here we have an array and this array holds i32 types and the size of the array would be 3. then as we've seen we can use the from Associated function so we create a vector from this array meaning V1 will then hold a vector of i32 types or what we also could do is calling the into method and if a type implements from then it will Implement into and we will take a look at that so we then take this array over here and convert it into a vector of i32 values right so that means V1 and V2 will be exactly the same now converting a string into a vector so the from trade over here is actually implemented for the vector type so over here we have a string and remember basically a string is a vector of u8 elements and then again we can call here into right converting s into a vector of u8 elements and then over here we have again a string and we call the method in two bytes meaning V2 holds a vector of utf8 bytes represented as u8 and this is actually exactly the same so meaning V1 and V2 will be identical then over here we have a string literally and we want to create a vector from this variable meaning we again use the from Associated function and provide it as an argument over here meaning B3 will then hold a vector of u8 types right so V2 over here and V3 are identical iterators can be collected in two vectors so when we have here an array of 10 elements of value 0 and we put it into an iterator we can then collect it into a vector all right and we will see these methods over here in Twitter and collect in much greater detail meaning V4 will then hold a vector and of 10 times 0. like that all right let's see and this is compiling fix the error and implement the code so let's see over here we have an array and we convert this array into a vector using the from Associated function we have seen so this will then hold a vector of I 32 types all right now then we are iterating here five times and just print out each element at the specific index here we have to implement some code and actually V in the end should hold a vector with these elements so as you can see we have we are starting with a vector holding one two three and we end with a vector 2 3 4 5 6. now what we want to achieve here is we are adding one to each element then we would have 2 3 and 4. now if we exceed the boundary over here then we want actually to add the new element over here now let's see first in the for Loop here this would actually panic because we are trying to access indexes that are out of bounds so over here we are iterating from 0 to 4 right 5 excluded but we have only three elements meaning meaning indexes 0 to 2. now we can here you stick get method and we have seen this get method before and and this is generally safer because it will return an option in this case option i32 because we are dealing with i32 types here and what we then can do over here we want to actually manipulate this Vector so let's first access the elements and as you can see again I use the get method because we want to actually see if the index is out of bounds or not so in case it's not out of bounds we would return a sum right the get method will return a sum and the actual value at that specific index so if we found an element at the specific index over here then we want to access the element and just add to it one right we are then taking the element over here let's see for example in the first iteration I will be zero then we pass 0 to this get method meaning we will get back some 1 right so we'll get back some 1 meaning e over here will then hold a value of 1. then we access this array at index 0 right and what we want then to do is taking 1 E over here and add to it one meaning then the first element in this Vector has been modified to then hold two now in the second iteration to do it would be exactly the same thing so I would be 1 we get over here the element at index one and E will then hold two and then over here V at index 1 should then hold two plus one right and we assign it meaning in the modified vector the second element will then hold three now we do that again and after we are out of boundaries meaning we return a non here and then we want to push to the vector the index plus two right so for example in the third iteration I would be three right this would be out of bounds there is no index 3 here so we get back a non and then over here we push to V the index in this case 3 plus 2 meaning we then get back 5 right and let's see if this is actually working all right and let's remove this type annotation because this would be of Type U size because of the get method now as you can see when we print out here the output of the get method we would get someone sum two and some three and then two times none because at iteration 3 and 4 we would get back none because there is no element in this index and we are succeeding here because again we have three times sum here and when we have a sum we just add 1 to the value meaning we then have 2 3 and 4. and then we will get back two times none meaning we take the index and increment it by two pushing it to the vector so we get five and six slicing a vac can be mutable on the other hand slices are read only objects to get a slice use reference in Rust it's more common to pass slices as arguments rather than vectors when you just want to provide read access the same goes for string and string slices so over here we have a vector let's say i32 then we are taking a slice from V over here meaning this would then be a slice of i32 elements right and this would be the offset meaning we would take from the first element to the last element out of bounds will cause a panic you must use the length here so as you can see again we are taking a string slice foreign but we are here out of bounds right because this would iterate from 0 to 3 for excluded and we have here only zero one two indexes so what we can do is using B dot length meaning we just iterate meaning we provide an offset from zero the first element to V length where the length here is excluded meaning vlanth minus one all right slices or read only node slice and reference to back are different so as you can see we take here immutable reference to a vector and then we can push to this Vector over here the value 4. now we have seen that slices are immutable they are just a view into some data so we can't use a slice to mutate the vector right so over here we want to have a slice of i32 elements right like that and we can remove the mute keyword over here because again we can't modify slices so we have pushed to it for meaning when we take the slice we want to take also this last pushed element right and this is compiling capacity the capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector this is not to be confused with the length of a vector which specifies the number of actual elements within the vector if a vector's length exceeds its capacity its capacity will automatically be increased but its elements will have to be reallocated for example a vector with with capacity 10 and length 0 would be an empty Vector with space for 10 more elements pushing 10 or fewer elements onto the vector will not change its capacity or cause reallocation to occur however however if the vector's length is increased to 11 it will have to reallocate which can be slow for this reason it is recommended to use the width capacity function whenever possible to specify how big the vector is expected to get and this we have already covered with strings but now let's see with vectors so over here as you can see we are initializing an empty Vector but with a capacity of 10 so this object here would hold length of 0 and capacity of 10 meaning the actual elements inside Vector are zero there are no elements but in Heap memory there were 10 locations allocated for this data right the vector contains no items even though it has a capacity for more so when we call the length method over here we would get back zero right because back doesn't hold any values but it has a capacity of 10 because we have defined that over here these are all done without reallocating so we are then pushing 10 times to the vector right now this means back here holds enough space that this is happening without reallocating the vector right so after pushing to the vector T Vector with would be of length 10. and capacity 10. right so the length must never exceed the capacity otherwise a reallocation is happening as we can see here but this may make the vector reallocate so we are pushing another element to the vector meaning the length will be 11. this would exceed the capacity meaning then this whole Vector will be reallocated in Heap memory so when we have a length of 11 then the capacity will be at least 11 but it can be more because we have seen that the default behavior when reallocating is that the capacity doubles feeling an appropriate value to make the four done without reallocating so as you can see we have here a vector we want to initialize with a certain capacity then we are pushing 100 times to this vector meaning the length here will be 100 so what we want to do is we want here to initialize a vector with a capacity of 100 meaning we can push 100 times without this Vector to be reallocated in Heap memory store distinct types in Vector the elements in a vector must be the same type for example the code below will cause an error so we have here integers and a float this would cause an error because again all of them have to be of the same type but we can use enums or trade objects to store distinct types so over here we again see the IP address enum we have seen before in the examples now fill in the blank we want over here a vector that holds IP addresses meaning at index 0 we want this variant here and at index 1 we want this variant now we can use the back Macro for that and then over here I just copy this variant and this over here right we would then have over here a vector holding types of IP address and because this is a custom type we have to actually Implement partial EQ here so I hope you get the concept we have here a vector holding types of IP address right then over here we have a trade IP address that defines one method display and then we have two Tuple structs V4 and V6 we implement the IP address trade for v2 struct and V6 tract meaning we have to implement the specific method and all it does it then basically prints out the value that is stored inside destruct so fill in the blank as you can see we won't hear a vector holding trade objects remember a trade object is boxed or put behind a reference so over here we have a vector holding boxes right and the Box holds a trade object meaning again this is using Dynamic dispatch and we won't hear a type that implements the IP address straight right in this case B4 and V6 both are types that Implement IP address and as you can see even though we are holding here different types we can use it using here trade objects to store it in the same vector typo so and then we are iterating over the vector and for each element in here we just call the display method that has to be implemented because we only have types in here that implement the IP address trade and this is exactly where Dynamic dispatch happens and we have covered that let's take a look at hash Maps so a hash map is a data structure to store key value pairs it's allocated on the Heap as it is dynamically sized meaning it can grow and Shrink it allows for efficient lookup insertion and deletion of data so when talking about time complexity this means accessing and modifying elements or entries as they are called in hashmaps would be in the best case at constant time meaning Big O of 1 while in the worst case if you have a lot of collisions then it would be still linear time which is still pretty fast which means Big O of n each key is hashed to a unique index in the underlying array so there are vectors stores values by an integer index hashmap store value spy key it is a hashmap implemented with quadratic probing and simd lookup by default a hashmap uses a hashing algorithm selected to provide resistance against hash those attacks so over here we find some information about the used algorithm for the hash Maps but let's dive into the exercises so the first thing is we actually have to use here a namespace so we are basically importing from the collections module from this standard Library the hashmap type and when using vectors or strings these are all in the Prelude meaning we don't have to import it but a hash map you will have to basically import so over here we are initializing an empty hash map then we insert some entries and again a hash map holds entries of keys and values now important here is that all the keys must be of the same type and all of the values must be of the same type so this over here would cause an error and let's go with integers like that and we annotate the hash map like this where key stands for key and v stands for value so over here we use string literals as keys and i32 integers as values then as you can see we can access the entries in a hash map by using again the get method which returns an option we have seen that before when dealing with vectors so we provide the get method the name of the key all right and then we will get back the appropriate value in this case 98 because we are accessing the entry sun phase right so we would get back here a sum an option i32 right this would be the return value some 98 and this would be the type option i32 so we can check if the hashmap contains a certain key so for example if the hash map contains the key Daniel this would evaluate to true meaning the code block here will be executed and we can also index into a hashmap using bracket notation like that so again this would then hold the value of the entry Daniel it would be 95 right this would be an i32 again notice the difference between indexing like that or indexing using using get method we will get back the value here directly while here we get back an option so get is generally safer and then over here we are removing Daniel from the hash map right so we can use the remove method and provide it the key the entry we want to delete meaning after deleting Daniel over here the length of the hash map would be 3 right and we can also iterate over a hash map so we provide it here the variable holding the hash map and then the return would be a tuple holding the key and the value and then we just print out the key and the value let's see all right and we would get back here an option holding a reference to i32 all right and over here too we would get back a reference this is what the get method will actually return so as you can see we are printing out the hash map and this would be the key for example Ashley and this would be the value as you can see now notice that the order here is different from what is over there and that's because a hashmap is unordered so the order won't be retained all right and of course we have only three elements here because we have removed the entry of Daniel then over here we have an array holding tuples which holds a string literal and an integer right so we have an array of three elements and each element is of type Tuple and inside the Tuple is a string literal and an i32 then over here we are initializing a new empty hash map then we iterate over here through the elements of this team's array so for each element here we insert into this empty hash map here the name over here the string and the value all right Implement team map 2 in two ways tips one of the approaches is to use collect method so we can also implement a hash map from an array holding tuples of keys and values by using the hash map from function so we provide it here teams and this will then directly convert this array holding tuples of keys and value pairs to a hash map meaning we then have a hash map holding string slice keys and i32 values all right and over here we would have the same thing and then when we compare teams map 1 and teams map 2 they should be equal let's see this is compiling now the second approach would be taking this teams array here and we want to put it into an iterator and again we will cover that and then we call collect now when we call the collect method it will basically collect the elements in this iterator into the type we have annotated here again this would compile because we have in teams map 2 the same keys and values as we have in teams map one and as you can see we don't need to write a fullblown for Loop we can just use some simple methods let's see number three fill in the blanks so type inference lets us omit an explicit type signature which would be hashmap string slice and u8 in this example so again we don't have to annotate the types I do it just to make things more clear but we can leave it at that insert a key only if it doesn't already exist so here we are accessing player stats this empty hashmap and we call the entry now the entry checks if an entry exists with this specific key and then we can call over here the or insert method meaning if this entry doesn't exist then we insert this key with this value meaning when we then access player stats with a key of Health we would should get back 100 right because this has been inserted over here insert a key using a function that provides a new value only if it doesn't already exist so again we are trying to access player stats and look for an entry Health now in this case this exists right because we have inserted it at that point now we can also use here the method or insert with the difference to our insert is that we don't provide a concrete value but a function pointer meaning this function will then get executed so this function only returns 42 so that means if the entry Health doesn't exist we insert this key with the value of 42. now again Health exists meaning when we Access Health we will still get 100 right because this only executes if N3 isn't found ensures a value is in the entry by inserting the default if empty and returns immutable reference to the value in the entry so we are here checking for the entry health and if it doesn't exist we insert 50 right so in this case Health already exists meaning we would get back immutable reference to the existing value 100 right so this would be immutable reference to 100. and because it is mutable we can then modify the entry manually so we can hear decrement from Health which holds 100 we decrement 50 meaning the health will then hold 50 right this health variable holds 50. let's see this would be u8 in this case and this is compiling so as you can see when we call entry it will give us back a mutable reference to the value if it already exists to the existing value if it doesn't exist it will here create an entry because this is what the or insert method does and will return immutable reference to the created value and then we can modify this mutable reference right requirements of hashmap key any type that implements C EQ and hash trades can be a key in a hashmap this includes pool intu in string and string slices note that F32 and f64 do not Implement hash likely because floating Point Precision errors would make using them as hashmap Keys horribly error prone all collection classes Implement EQ and hash if their contained type also respectively implements EQ and hash for example a vac holding a type T will Implement hash if T implements hash so if the elements in a collection for example a vector or a tuple or an array implement the hash trade then the collection itself will Implement hash let's see fix the errors tips derive is usually a good way to implement some common use traits as you can see we have here a struct viking with two fields of type string and here we have an associate function for Viking just creating a new Viking instance from the arguments we provide and as you can see use a hashmap to store the Vikings Health points so we are creating here a hash map from an array holding tuples of keys and values now notice we have here a hash map and the type of the keys would be the custom type y King all right the value would be i32 use derived implementation to print the status of the Vikings so here we are taking this created hash map as a reference and we would get back a tuple holding the key and the value and then we just print out the key and the value here so we have seen that in order a type can be used as a key in a hash map it has to implement EQ and hash so let's Implement that let's also use the partially queue over here and debug so we can print out the key over here in debug notation let's see and of course we have to implement the hash trade and as you can see it will print out each element in the hash map we have created so we have now a hash map using as key our custom type y King as you can see this would be the key this would be the value of the hashmap capacity like vectors hash maps are growable but hashmaps can also shrink themselves when they have excess space you can create a hash map with a certain capacity using hashmap with capacity or use hashmap new to get a hashmap with a default initial capacity this is recommended so like we did with strings and vectors we can Define when initializing an empty hashmap the capacity right ensuring that when we know we will push a lot of entries that there are no reallocations because remember we allocations are slower so then we are here inserting two entries and as you can see this would be an entry of key i32 and value i32 so the key entity value can be of the same type and over here we insert again another entry indeed the capacity of hashmap is not 100 so we can't compare the equality here so even though we have here defined that the capacity should be 100 it could actually be more than 100 and this is just in case there are collisions there are some internal stuff going on so the RAS compiler will actually allocate more capacity than 100 we defined here shrinks the capacity of the map with a lower limit so when we call map over here our hash map holding two entries and then we can shrink the capacity to 50 right so again the capacity won't probably be exactly 50 then but around 50 so we can shrink the hash map and shrinks the capacity of the map as much as possible so because over here we have only a hash map of two entries 50. spaces in Heap memory would actually be more than we need so we can use this shrink to fit method so that the capacity will shrink around the amount of elements it actually holds again it won't probably be 2 exactly but around this number ownership for types that implement the copy trade like i32t values are copied into hashmap for owned values like string the values will be moved and hashmap will be the owner of those values fix the errors with least changes don't remove any code line so over here we have initialized a variable with a type of i32 and an empty hash map right then we insert here and N3 into M1 and using the same exact value for the key and the value meaning we have here a hash map with keys of type i32 and values of type i32 over here we have a string and we initialize here an empty hash map then over here we are inserting a new entry using V2 this string here as the key and V1 over here as value so we would have here a hash map using keys of type string and value of type i32 and because this is an owned type meaning it doesn't Implement copy this will then actually be moved into the hash map so we can't use V2 here but what we could do to fix that is we could use a string slice of this string right we just provide a reference meaning then the hash map will have type for the keys of string slices right and that means we can then again use V2 and again because V1 is of type i32 it means it implements the copy trade meaning even if we pass it as a key in the hash map or as a value it is still usable but when you are dealing with types that don't Implement copy the ownership will get moved meaning hashmap will then be the owner of the type alright and there are some thirdparty hash lips but I won't cover that in this beginners course so we'll see you in the next topic let's now look at type coercion and we have already seen the S keyword and this is mostly used for converting integers so type conversion also called type casting is coercing a primitive type that can be performed by as keyword as conversions can be Chained and when casting to an unsight type T for example then T Max Plus 1 is added or subtracted until the value fits into the new type and using unsafe methods can lead to undefined Behavior so let's see an example as you can see we have here the largest unsigned 8bit integer 255. and this would be the binary representation this means that u8 right this data type for unsigned 8bit integers Max meaning 255 plus 1 will be 256 so for example if we Typecast 1000 s u 8 then let's see what the compiler will do it will subtract 256 this value over here from 1000 and then it will check seven hours 744 is still bigger than the largest value it can represent meaning it will do the same thing subtracting 256 will leave us with 488 still bigger than this value so again the same thing it will subtract 256 and this will leave us with 232 meaning this will then be the returned value when we cast 1000 s u 8 because remember an 8bit unsigned integer can't represent 1000 it's out of bounds now when we Typecast 1 as u8 then remember an unsight integer cannot represent negative numbers meaning what it will then do it will basically rotate so 0 would be the smallest possible number an 8bit unsigned integer can represent and then 1 will just basically rotate it will go back to the biggest one meaning this type casting over here will result in 255. so convert by S rust provides no implicit type conversion coercion between primitive types but explicit type conversions can be performed can be performed using the as keyword fix the errors and fill in the blank don't remove any code so over here we have an F 32 float right then we Typecast this float into an u8 meaning over here the fractional part will get removed so the value would be 97. and of course this will then hold a u8 now we want to Typecast this decimal into HR now this is not possible directly but we have seen that we can chain as statements so we can convert this first to an u8 meaning we will get 97 like we did here and then Typecast it to a character so C1 will then hold a character and by the way 97 would be the ASCII code for a and over here as you can see we can Typecast this integer holding an u8 type as Char directly so C2 would also hold HR now as you can see we are here comparing the integer holding 97 with this type casting now this type casting over here converts the B character to its u8 representation now B would be represented as 98. so what we can do over here is adding one 297 because remember 97 would be a meaning when we add 1 to 8 we will get back B right so both of them will hold 98. by default overflow will cause compile errors but we can add a global annotation to suppress these errors so as you can see the largest possible number u8 can represent would be 255 meaning this would cause an error because again 1000 is larger than the largest possible number a weight can represent meaning we have here an overflow error now we can actually allow overflowing by using this attribute so distance won't complain right and then when we print out B as you can see we would get back 232 because we have seen over here that this would be the result when the compiler performs this operation so we allow here overflowing literals right if we didn't if we comment this out then the compiler will complain because this is actually not possible when casting any value to an unsight type T T Max plus one is added or subtracted until the value fits into the new type that's what we have seen so in this case 1000 as u16 would return 1000 right because a u16 can represent a number of 1000 but over here we would have an overflow meaning this would return 232 like we have seen over here for positive numbers this is the same as the modulus so this would actually be the same as uh doing a thousand modulus 256 remember u8 Max plus one meaning 256. now we have also seen in the example when we have 1 and casting that to an unsigned integer it will then basically just rotate so this will return 255. since rust 1.45 the S keyword performs a saturating cast when casting from float to int if the floating point value exceeds the upper bound or is less than the lower round the The Returned value will be equal to the bound crossed so in this case we have a float here casting it to u8 meaning a saturating cost will be performed so it will just return the largest possible number u8 can represent which would be 255. now in case we have here A minus 100 as floating point and convert it to u8 this just would return 0. it's a possible number u8 can represent this Behavior incurs a small runtime cost and can be avoided with unsafe methods however the results might be overflow and return unsound values use these methods wisely we can use here in an unsafe block the method to int unchecked so the compiler here won't actually check what's going on so as you can see we are casting 300 floating Point 2 and U int to a u8 so as you can see we are here casting 300.0 floating point to and u8 integer and this won't be checked by the compiler that's because it's in an unsafe block now this would return 44 right because 300 minus u8 Max plus one would be 300 minus 256 meaning we would be left with 44. and minus 100 Su 8 as you can see we are typecasting this floating point 2 and u8 integer and again this is unchecked so again what the compiler will do here it will take u8 Max plus one meaning 256 and it subtracts 100 meaning we would get 156. and not a number would be converted to zero okay thank you and of course here we have to use again the attribute allow overflowing literals just so this will actually compile because usually this won't compile and as you can see this would be the output now over here we are dealing with raw pointers and we won't cover that in this beginner's course because this is more of an advanced topic so see you in the next topic so we have seen type conversions for integers and types from the standard library but what if we want to convert types that we defined basically custom types and rust has for this T from entity into trade so let's see from and into trades are used for type conversions between different types without requiring explicit costs it's part of the standard library and can be implemented for custom types implementing the from trade for a type will give us the intu implementation for the given type for free meaning when we Implement from we implement it into automatically so always implement the from trade and not the into trade let's see here an example we have a custom type number and then over here we are implementing the from trade right so we want to convert from an i32 to our custom type number right and the from trade implements a method from so we take here as an argument an i32 and we will then create a new instance of the number type with the provided value and then return it and that means when we use here the from Associated function on our custom type number and provide it in i32 then this can directly be converted to our custom type right and we can do it in two ways from as we've seen because we have implemented it and I've told you that when we and I've told you that when you implement it from trade T into trade is automatically implemented meaning we can also call the into method on the type we want to convert to but when you use into a type annotation is needed so the compiler knows into what type you want to convert this type right so we convert here a type of i32 into a number and this would be the implementation so the from trade allows for a type to Define how to create itself from another type hence providing a very simple mechanism for converting between several types deformant into trades are inherently linked and this is actually part of its implementation it means if we it means if we write something like this we Implement here so we Implement here the from trade for the custom Type U then we can use U from T right we can then create a utype from the type T we have implemented the front trade on or we could also use into so we convert T into U the input rate is simply the reciprocal of the from trade that is if you have implemented the from trade for your type then the input rate will be automatically implemented for the same type using the into trade will typically require to type annotations as the compiler is unable to determine this most of the time so for example we can easily convert a string slice into a string as you can see we have over here a string slice and then we can call string and the from Associated function providing it this string literally meaning this will then be converted to a string and we could also use the two string method again this and this is exactly the same and we could also then use the into because remember when we Implement from we get into for free so we can so we convert this my string string literal into a string and again type annotations are needed because the sender library has already implemented this for us input from string slice for string so we can easily convert a string to a string slice and vice versa some implementations of form can be found here so as you can see we have here input from Bool for i32 meaning we can convert Boolean into an i32 so when we have here a Boolean value and call into it will convert this Boolean value into an i32 integer in this case this would be zero zero for false and one for true and again when we can use the into method we can use the from Associated function so we call the associated function on the type i32 and provide it here the Boolean value right so this will then actually be exactly the same fix the error in two ways first Implement from Char 4 maybe you should check the docs mentioned above to find the answer second a keyword from the last chapter so let's see the docs so we want here to convert a character so let's see over here as you can see you can see all the types that implemented from trade so we want to go from character and as you can see we can convert a character to either u32 u64 or u128 as well as string so I 32 is not supported and as you notice these are only unsigned types because it's logical a character can't be negative right it can't hold a negative number so we only have unsigned intervals here so we can so we can then in fact convert HR into a u32 let's say so in this case Char implements so in this case we use here u32 right we can convert from HR to Au 32. meaning when we change this over here this should actually work so we provide here a character called the into method and then we should have a new 32. fix the error in two ways so we can't use the as keyword here this is not implemented but what we can do is let's first use the from method so we can create a string or basically converting a character into a string because we have seen in the documentation this is actually implemented and the second way would be to call a and then into right like we did over here Implement from for custom types from is now included in standard Prelude so there is no need to introduce it into the current scope so we don't have to uh so we don't have to import the from trade it's actually in the Prelude meaning we can use it without importing anything so over here we have a custom type number with one field now we want to implement the from trade for our custom number meaning we should be able to convert from an i32 into a number so when we call over here number from right then we should get over here number this would then create an instance of the number struct and the value field here will hold a value of 30 right so and the same thing is when we would call 30 like that and call into right this should then convert the i32 integer into the number type automatically and remember we only have to implement the from trade because then we can use from and into both of them so let's see so this over here is the from trade and let's take this function signature over here and copy it like that now in this case self refers to number right and what we want to do is create here a new instance and we just take the value in this case the i32 right and we provide it as a value for the value field and again because the name of this argument matches the name of the field we can use it like that and this is sufficient so let's see and this is compiling so as you can see then it's really easy to convert one type to a custom type we have created when performing error handling it is often useful to implement from trade for our own error type then we can use question mark to automatically convert the underlying error type to our own type now we didn't cover that this will be the next topic but let's see the exercise we have here an enum CLI error now the two variants here IO error and parse Arrow hold Arrow types from the standard Library okay and these are actually the error types that get returned in case of an error when using these specific methods that are implemented in this standard Library so as you can see we want here to implement the from trade for different error kinds from this standard library and we want to convert that to our custom error type CLI error so let's see over here we have the function open and pause file it takes a file name as argument and it returns a result and we will cover results so a result basically says in case of success it will return a result with i32 and otherwise CLI error so then we call the read to string function and as you can see this is defined in the fs module FS is used for file manipulation and we provide to this function over here the file name now we pass a reference because this is defined in the documentation of this function we are here using the question mark operator meaning in case of success the result type that will get returned will be unwrapped and contents will hold a string in case of an error it will return the CLI error meaning the rest of this code won't get executed and we just get acli error instead now the error type returned from this function would be IO error so in order this error to be converted to a CLI error we have to implement for this error type the from trade right but let's see what's happening here we then take the contents meaning this string over here that gets returned in case this function call is successful and we then hold over here the contents of the provided file then we trim and then we pause now pause could potentially fail and parsing is basically converting a string to an integer value right so in case of success we will get out an i32 in case of error we'll get back a num pulse and error this is defined in the num module again we will cover error handling and all of that don't worry this is now just about the type conversion and then we return an OK with the num value here we have to wrap it in OK because we return a result type now let's see how we would Implement that so again I will just go to the documentation and copy the function signature like that so we have the function signature and then we can over here see what we want to do so in case we get an i o error we want to convert that to our custom CLI error now how would we do that let's change here the argument to e for error and the type would be IO error right we are implementing it from this type now what we want to do is we just want basically to pass the i o error into the io error variant in our custom type so we can access the variant so we can create an instance remember this is the syntax to access the enum so we access CLI error and then the io error variant and all we do then is just passing this IO error type meaning we then have an instance of this variant holding our i o error and that means we have then implemented the from trade for our custom type so any IO error type can be implicitly converted to CLI error meaning in case this function over here returns an IO error it will implicitly be converted to a CLI error let's do the same thing over here for parse int error this would be the error type from the parse method so again let's change here the argument name and the type would be over here and then we again just access this enum access the pause int Arrow variant and we pass it the actual error that gets returned and this would mean we then create another instance of the pause error variant let's see if this works and as you can see this is compiling meaning in case of an error over here both these Arrow types from the standard Library I or error and parse int Arrow will be implicitly converted to CLI error right try from try into similar to from and into try from and try into our generic traits for converting between types unlike from into try from and try into are used for valuable conversions and return a result instead of a plane value now again we use the result type we will cover that when there is a possibility of an error of something going wrong so as you can see we have here an i16 holding 256. into trade has a method in two hence try into has a method try into right this is the method defined on the try into trade so we take this value here and call the try into method on it meaning this will return a result so we match this result in case of an okay then we unwrap the value from the result and if it is an error then we just print out the error over here and return 0. right so in case this succeeds then n will hold a u8 and the value in case this fails n will hold a value of 0. now we have seen that when we want to convert an u8 then this would actually fail because this is out of boundaries but because we are here basically error handling that means that the program here won't actually panic so in case this fails here which it does then we will just assign to n the value 0 and print out the error so in this case n would be zero and again error handling will be our next topic so don't worry if this seems a little bit strange then over here we have a tuple struct even num and it takes an i32 type we Implement here the try from trade for the custom even num type now here we have an Associated type and we Define that it should be of type unit type okay and then we Implement here the try from function so all this function basically does it takes a value and it checks if it is divisible by zero and then we will return the result in this case okay even num and inside it t value provided otherwise if it is not divisible by 2 then we return an error holding our unit type we have defined here as you can see the type in case of an error would be this Associated type error meaning a unit type so we have provided that over here so then we can use the drive from function so when we call even num and try from 8 then this would return okay right because 8 is divisible by two so we would get back a result in this case okay even num and T value we have passed right that's what we defined here now in case we try from a value of 5 this would return an error with a unit type inside because again 5 is not divisible by 2. now with try from and try into it's exactly the same like with from and into when we Implement try from then try into is automatically implemented so we can use this try into method here directly so we try here to convert eight into this result right and the result in case of success will will hold the type of even num and otherwise a unit type like defined over here and in this case result will then hold ok even num and the value we have passed eight now when we call try into on 5 then this will actually return error and a unit type inside like we have defined over here let's see and this is compiling see you in the next topic let's now see two more exercises and this time we are converting a custom type into a string so to convert any type to string you can simply use the two string trade for that type rather than doing that directly you should implement the fmt display trait which will automatically provide tostring and also allows you to print the type with print line so again same thing like with from and into if you implement from then into is for free so you usually don't implement this trade directly for a type you implement display and you will get two string implementation for free so let's see we import here fmt and we have here our custom type point now here we are instantiating a point so what we want to achieve here is that when we take the point instance here we have instantiated and converted to a string this should then be the output and we can also use the format macro here basically just providing origin because the format macro will automatically convert that to a string in order to print it out and the output will be the same so let's implement the display trade here so as you can see this is the display trade and it provides one method now let's take it from over here they provide here an example and we can just copy this over here now I remove the lifetime it's not needed and let's implement the fmt method here so as you can see the fmt method provides here a formatter meaning we want to write we can use the right macro here and the right macro works like println or format but the difference is it will write to a buffer in this case f this is the formatter from the fmt module and then we here provide what we want to print out so in this case we want to print out the point is entity values so let's do that and then like in a print Ln macro we provided the values so in this case we want cells dot X and self.y we want to print out the X and the Y field and that's basically it we have implemented the display trade for Point meaning our customly created type Point can be converted directly to a string so let's see and this is compiling so if we pass origin here let's see the output as you can see this would be the output so we can even manipulate how the output should look like so instead of just so instead of just printing out the two fields we have even provided the output with a whole sentence right this will be the last one we will be doing we can use parse method to convert a string into an i32 number this is because from string is implemented for i32 type in standard Library to use from string method you need to introduce this trade into the current scope so we have to import this trade from the stir module so over here we want to pause and parsing again means converting a string into an integer so we would here have an i32 type of this value and over here the same thing now we can either annotate the type over here or we could use the turbo fish syntax meaning we can directly annotate the type on the method like that and then because the from string trade is actually implemented for the i32 type we can also call the associated function from store let's do 20 here so this will convert from this string literal into an i32 meaning this will then hold an i32 now because all of them hold i32 integers we can then do a mathematical operation meaning we just add together all of these values 5 10 and 20. so to be variable will hold an i32 and it should be equal to 35 and this is compiling see you in the next topic now we will cover error handling antisimples form of error handling is to use the Panic macro Panic will print out an error message unwind this deck and finally exit the program now unwinding the stack means that when you actually execute the program then we have seen that the local variables and the function calls will be pushed to this stack now when panicking that means that the compiler will actually delete everything step by step from this stack memory and then exit the program and in multithreaded programs it will exit the thread in which the Panic occurs not the whole program so we don't deal here with a multithreaded programs this will be another course but I just want to mention it so let's see exercises as you can see we have here a function drink which takes a string literally if the string literal is lemonade then we print out success otherwise we actually want to panic right because we want to ensure that this line never gets reached meaning never gets printed out so when we pass over here lemonade then this will print out success and then will panic and this would be the output if a program panics threat main panicked at explicit panic and it will provide you the line number at which the Panic occurred in in this case an explicit panic because we have here called the Panic macro common Panic cases make make the code work by fixing all panics so when we call here the S bytes method on a string then it will give us back the array holding the utf8 bytes of this string now we have seen that actually the utf8 representation of a would be 97. B would be 98 and C would be 99 so again if srtq doesn't match if this does evaluate to another value then this then assert EQ will cause a panic over here we have a vector and we try here to access the third index now we only have now we only can go to index 2 right it's the outmost index we can provide so let's change that and this will then hold an i32 right because we are accessing a specific element unwrap May panic when get return a none so the get method over here will return an option meaning it either returns a sum with a value or a non now in this case this would return a non because we don't have any value at index 3. so when we try to unwrap a non value then we will panic now let's hear excess index 1 for example then it will return a sum two right the first element write the element at index one and unwrap we basically just unwrap the inner value so La will then hold a value of 2 of type i32 sometimes the compiler is unable to find the Overflow errors for you in compile time so a panic will occur so when we call here the production rate per hour function with a value of 2 then let's see we have here speed the provided argument of type u8 and here we have cph of type u8 now as you can see we are inside here multiplying the speed in this case 2 by cph 222 now this would actually result in an overflow because 2 times 221 would be 442 right now remember an u8 can only represent up to the number 255 so this would actually cause a panic but what we can do is just actually taking here a u16 and converting that to u16 meaning when we multiply these together then the result of u16 will still be able to represent the resultant number and over here we can do the same thing and then let's see because of the same reason as above we have to wrap it in a function to make the Panic occur so here we are calling the divide function with two arguments 15 and 0. so to divide function takes two arguments of type u8 and just divides it now this would also panic because we can't divide by zero this is a mathematical Rule and this will always lead to a panic so let's here divide by 1 for example let's see if this is compiling all right and again when we use the get method we will get back a reference to the value and not the actual value so let's change that and this is compiling detailed call SEC by default is stack unwinding will only give something like this so this would be the output if your program panicked though there is the reason of panic and the line of code is showing where the Panic has occurred sometimes you want to get more info about the call stack fill in the blank to display the hole called stack tips you can find the clue in the default Panic info so when we run cargo run this is basically how you execute a program you have written and will cover that then you just provide over here this rust back Trace equals one environment variable and it will then give you detailed information about the Panic that occurred so over here unwinding and abort by default when a panic accuracy program starts unwinding which means rust walks back up to stack and cleans up the data from each function it encounters but this work pack and cleanup is a lot of work the alternative is to immediately abort the program without cleaning up if in your project you need to make the resulting binary as small as possible you can switch from unwinding to aborting by adding below content to cargo.com so we can here Define in this cargo.tamil file and I will show you an example of that how Panic actually behaves so we have two um so we have two options here either unwinding or aborting when choosing a board here then the stack won't get unwinded meaning this will then be the responsibility of the operating system and not of the rust compiler alright see you in the next episode so we have seen the option type and the option type stands for a value that could potentially be absent so let's now look at the result type result is an enum type that represents the outcome of an operation that could potentially fail it has two possible variants okay a value T was found and error and error was found with a value e and as you can see the variance hold the specific information the expected outcome is okay the unexpected outcome is error since result is an enum the possible variance can be matched using a match pattern and that is what we call error handling so let's see an example let's again consider the divide function we have seen before so again we can't divide by zero meaning if the second argument here is 0 then we should return an error otherwise the program will Panic now we can do here error handling meaning we check if Y is zero right or in this case 0.0 because the arguments are floating Point numbers now in case y what's the value of 0 then we return the error variant of the result enum and we provide it an error message all right so in this case we use an explicit return keyword meaning when this returns it won't execute any further it will directly return the error type and stop execution now in case Y is not 0 then we will just divide X by Y and wrap it inside okay because remember result is an enum meaning we have two wrapped the resultant value inside the variant so that means when this function succeeds then we will get back an F 32 right the result of this operation and this is wrapped inside okay because as you can see we are returning a result type now in case of an error we would return this string over here wrapped in the arrow variant and this allows us then when we call the function divide with two arguments that we can then match the result we get back here as you can see we would get back a result type meaning the result type has two variants either okay or error and we can here use pattern matching to the structure the inner value for example this F32 into the variable Val which we then can print out and in case of an error we will get back this string over here the error message and we destructure it into this variable here and then print it out unwrap the unwrapped method takes as input a value of type result and takes out the value which is wrapped inside okay in case of success or panics in case of an error in case it returns an OK variant we just take the value that is wrapped inside otherwise the program will panic so you should use unwrap only if you're a hundred percent sure that the return variant will be okay otherwise you should use match and let's see the question mark operator the question mark operator is a shorthand way to propagate errors or unwrap OK results basically it's the same as unwrap but instead of panic it returns an error it replaces an entire match statement and can and it can even be used in the main function so as you can see over here in the main function we can Define here that main should return a result type and as you can see we have here a string holding a number then we try to parse this string over here into an i32 type now we have seen that the parse method could potentially fail right if we have here a string holding T for example the compiler can't convert it to an i32 because it's not a valid number so in case we get back the OK variant remember parse will return a result if we get back okay then we just take the inner value and return it meaning the inner value will then be assigned to the number variable in case of an error we want to return meaning this over here won't get executed it will return before and we just provide the error message over here and in this case because we are using a function from the standard Library this error message is actually provided right so we just take the provided error message and return it and if this didn't fail it means this will get executed and we just print out the unwrapped number now because we return here a result type we have to also return an OK in case everything succeeded now because at the end of Main basically the end of the program has been reached so it doesn't make sense to return any meaningful value so we just return a unit type like that so I've told you that the question mark operator actually replaces an entire match statement meaning this over here would be exactly the same so let's see again we are in Main and we return a result now as you can see we have again a string holding a number then we try to parse over here and again pause returns a result so we have to handle the error case now we can do that appending to it the question mark operator meaning in case this succeeds and it returns an OK with the value in this case 10 but post as an integer then it will just assign it to this variable meaning number will then hold 10 as an i32 in case this fails then it will return a pause int error as defined in the parse method okay so this over here is exactly the same like we did over here and when this returns an error the following lines won't be executed in case this succeeds then we have number which holds 10 of type i32 then we'll just print out the post number and then we return a unit type because remember we are here returning a result meaning we have to also return OK variant in case of success but again because we are in Main and this would be the end of the program we don't return any meaningful value we will return a unit type and there is also a concept called type Alias so it's basically just a way giving a name to an existing type so if you like to write u64 like this then you can create a type Alias meaning we can use the type keyword and provide a new name for a specific type and as you can see over here we are then using the new type we have created here and this would at compile time then be replaced with the real type and please don't confuse that with Associated types in trades they are different okay let's see result is an enum to describe possible errors it has two variants okay and error in short words the expected outcome is okay while the unexpected outcome is error so let's see fill in the blanks and fix the errors first of all we are importing the pause and arrow from the num module because we are using here the parse method meaning it will in case of an error return the parse and error now we have here the function multiply that takes two arguments of type string literals okay now as you can see we are here returning OK meaning the return type will be of type result and in case of success or let's actually wait with annotating that let's first see what's happening here so we are taking this string literal and try to parse it to an i32 right so again this parse method over here will return a result in case of success we would have okay and the value that was paused so for example when we call here multiply with an argument of 10 for the first parameter then we would have a parsed number 10 right so we would have in case of success and I 32 here in case of an error we would have the parse into error like that and parsing terror is the error type that is defined for this method again this is implemented in the standard Library so this has to comply with what is defined there and N2 is exactly the same but for the second argument then over here we unwrap and remember unwrap will take a result and just unwraps the inner value so in case we have okay let's take the first argument 10 then unwrap we'll just unwrap the inner value meaning it Returns the integer i32 right that is wrapped inside the result enum and then over here we are multiplying by N2 again we have to unwrap because this is a result type and if this succeeds actually then we will return an OK meaning OK will then hold in this case 10 times 2 will be 20 right like that so we return an i32 in case of success in case of error we we will return a pause and error because that is the error that is defined from the parse method so let's see when we call multiply with these two string literals 10 and 2 then this should actually work right because the compiler is able to parse these into integers so it will pause here and this will then be okay 10 and over here we would have okay 2. then we unwrap both of these over here meaning we unwrapped the value from the variant and here are two meaning we multiply 10 by 2 and then this would be 20 and we wrap it inside okay because we have to return a variant of the result enum which means that the return type over here would be this right so result in case of success will hold ok and 20. right now in this case this would actually fail because the compiler can't convert T to an integer now we want this to actually assert to 8 so let's do here four and this means this will get passed to four and this will get paused to 2 right and then again we just multiply these together and return it wrapped inside the OK variant meaning over here we get back a result and result will then hold ok and eight right now if we unwrap the result over here then it would unwrap the inner value as you can see so unwrap method allows us to unwrap the inner value so okay 8 would be unwrapped to eight question mark operator is almost exactly equivalent to unwrap but question mark operator returns instead of panic on error so let's see we have again the percent error Implement multiply with question mark don't use unwrap here so let's see again we are taking two arguments of type string literal right three and four in this case and let's start to implement so we declare here N1 and we take N1 string and try to parse it into an i32 right now again we should here use the question mark operator so we append it after the method call here and then we can only use the question mark operator when the return type of the function is a result right because the question mark operator in case of an error will return the error variant and inside it the error value so we return error a result in case of success it should be i32 and in case of failure it should be dispersed in error because again this is defined as the error return value of the parse method now for N2 we do exactly the same and that means if any of these fail then it will immediately return meaning the rest of the function won't get executed and a pause end error will be returned now the question mark operator in case of success it won't return a result it will unwrap so for example when we pass here 3 and this will get passed it will return okay and three right and then the question mark operator like unwrap will unwrap the inner value so N1 will then hold three meaning an i32 integer and N2 the same thing and then all we want to do is just returning and OK in case of success because the return type is result and we want to multiply N1 by N2 notice over here that I didn't have to unwrap because we have here I 32 types right while over here we had to unwrap because this held result types you have to remember that let's see and of course I have to change that over here typo and this is compiling so what we had over here when we provide Forum as a string we would have okay four right and then the question mark operator unwrapistic value and then over here we are multiplying three by four which would be 12. then we wrap it inside ok to comply with the function signature so this will then be the returned value right and then over here as you can see we are calling the function and unwrap it because we have here a result type so we unwrapped the inner value because this would return okay 12. and we unwrap it meaning the inner value gets unwrapped let's see over here we have the file type from the fs module and over here we are importing some stuff from the i o module so over here we are opening a file providing here to the open Associated function the name of the file in form of a string literal meaning this will then return a result and in case of success it will hold a file right and in case of error it would be IO error all right and then we are matching f now F holds a result meaning we must over here handle both cases from in case of success and in case of failure so if it is okay then we unwrap the inner value meaning the file and we just assign it to f in case of an error we return the error wrapped inside the error variant of the result type right because this function over here returns a result all right and then over here we are creating a new empty string we then take F over here and read to string meaning the contents of this file over here will be copied to this string meaning s will then hold basically the contents of the file we have opened and we have to provide here a mutable reference because this is defined in the standard Library and then again because this read to string method returns a result we have to match it so in case of okay then we will return over here a string right this string s over here in case of error we will return the error and both of them file open and read to string return an i o error all right now over here fill in the blanks with one code line don't change any code lines as you can see we have here the function read File 2 which returns a result in case of success it's a string in case of error it will be the i o error from this standard Library we here declare a new string and we here initialize a new empty string and I told you that the question mark operator replaces a whole match statement so we can write all of this in one single line so first of all we are opening the file so let's take this and as we've seen open will return a result so we can use the question mark operator here to replace this whole match statement so in case of error it will immediately return and it returns this error type in case of success then we will get OK and a string and this will then unwrap it to the string right and in case of success we will have a value of type file like we saw over here and again file is a type defined in FS module so we have seen that the question mark operator will then unwrap we will basically get something like that and it will unwrap the file inside the OK variant what we then can do is call the read to string method on it right so we are calling read to string and then again we have to append this question mark operator because we need to string also returns a result type right so in case of success we'll then over here mutate s meaning the contents of this file will get read to this string all right or written to the string and then we just return s right the string and that means in case of success we will have as return type a result that is holding a string in case this or this fails then it will return an i o error meaning if this fails then over here a i o error gets returned and this will never be executed and if this fails again we return this error and this will never get executed let's see this is compiling map and then map and then are two common combinators for result t e also for option t so we have over here the parse into error fill in the blank in two ways map and then so we have here the function at 2 taking a string literal and returning a result in case of success holding an i32 in case of error parse and error all right because this is the default error type of the parse method then we are taking this then we are taking this string literal and try to parse it to an i32 and then as you can see when we provide here at 2 with a string holding four then we want to get back six so as you can see when we provide four we will get back 6 over here and that means we want to parse this string and then add 2 to the post number and for that we can use map which is really convenient because we not only want to handle this result case but also then modify the value right so n here takes a closure and we will cover closures very soon so we provide here an argument n and n would then hold the parsed number and all we do is adding 2 to n right and that's all so let's actually see the map method in the documentation as you can see maps a result te to result u e by applying a function to a contained okay value leaving an error value untouched so when we call the map over here it will perform it will apply a function if this method returns an OK value if it returns an error then it will leave it untouched all right so in this case this would actually succeed right so pause over here will pause this 4 into an i32 integer meaning it will then take the OK value and unwrap it so n will then hold A4 and then we just add and and then we just add 2 to 4. right let's see and this compiles now the second approach would be using and then now and then is very very similar to map the difference is here in the closure that the end then method takes so let's go back to map here so over here you can see this is the argument for the closure right and the closure over here returns directly the value all right and over here it will the closure itself will return a result now both of these methods return results over here but the difference is in the closure and you will see what I mean when we are looking at this so this is very similar it will take this past integer and then put the unwrapped value into n and then over here we add 2 to 2N now we have seen that map would work like that and and then method will actually return in the closure itself a result so we have to wrap that into ok like that but otherwise they are exactly the same and this succeeds number five with the return type we written we can use pattern matching without unweb but it's all verbose so here again we have the multiply function taking two string literals in case of success it returns an i32 otherwise parse and error so over here we are using the match keyword now we want to pause the first string literally the first argument in case of okay then we destructure it into T variable N1 so N1 will then hold the parsed number in case of an error we just return the error type then we match inside this match arm over here again so we match the second argument parsing it and if this is okay then we get out and two all right and then we can multiply N1 by N2 and return the result wrapped in the OK variant because as you can see the function returns a result type and in case of an error it just returns an error so this would be very verbose so rewriting multiply to make it succinct you should use both and then and map here so let's see we take first of all the n one star over here the first string literal all right then we want to parse it to an i32 integer right and let's then use and then so if this succeeds then we will have here n which holds the past integer right and let's actually write it more beautiful like that so we take then n or let's call it or let's call it N1 just to make a distinction and then over here we want to parse the second one right we want here the second one and then if this also succeeds we want to multiply N1 and the post and two together so let's use a map here and we would here have N2 right because map over here is called upon the parse method so we would then get back and two and then we just return N1 times N2 and notice because we are using map here we don't have to wrap it inside okay right so this will then return for example when we call it by 10 and 2 it will return 20. all right and and then we have seen that it will return the result type so in case of success it it will return okay with an i32 value inside otherwise it will return a pause end error let's see and this is compiling so as you can see when we are calling the multiply function with with 10 and 2 as string literals it will pause the first argument meaning we then have over here okay 10. right and then over here we call the end then Method All right so we take this N1 value here basically unwrapping it and inside and then we parse the second number so in this case two right so this will then get parsed into an i32 and we then can map meaning we have N2 over here and two in this case would be okay 2 right and map will take an unwrap the value inside OK meaning we then have N2 which holds two over here and then we multiply N1 by N2 and return it all right and all we then do is here The Returned value would be of this type right and in this case this would return okay 20. right because it could parse these two numbers and it multiplied it and returned it so we get okay 20 then we pass that to the print function as you can see it takes as an argument a result type then we match it if it is okay then we print out the value wrapped inside okay in this case 20 otherwise we will print out the error and when we call multiply with an argument that can't be paused then you would get a pause int error right so this would then hold a percent error we are providing that 2D print function and then we match the argument this TT and this will then match the error meaning the error will get printed so in the first one so in the first print call n is 20 so we have successfully paused these two numbers and unwrapped the value printing it and in the second one because we provide here an argument that can't be paused we get and pause into arrow and this would be the error message that is provided in this standard Library so type Alias using this type over here everywhere is verbose and tedious we can use Alias for this purpose so at a module level creating aliases can be particularly helpful errors found in a specific module often has the same error type so a single Alias can succinctly Define all Associated results this is so useful even the standard Library even supplies one IO result so as you can see we have here again the pulse and error and we want here to create a type alias now we have here the same multiply function we have seen above so I won't cover that anymore but the return type is defined as res i32 and the print function over here takes as an argument a type of rice i32 now as you can see exactly the same functions as we had over here but we don't write out the whole type we use here A type Alias so we can Define that here we use res i32 and we want to Define that as a result in case of success holding an I30 tool in case of an error as you can see the parse method would return a parse and error and then instead of writing that all the time in our functions we can use this simple type alias and of course at compile time these type aliases will then get replaced with this concrete type here let's see and as you can see the same output as before using result in F and Main typically the main function will look like this however main is also able to have a return type of result if an error occurs within the main function it will return an error code and print a debug representation of the error debug trade the following example shows such a scenario so as you can see we have here again the percent error and we Define here in the main function that the return type should be of type result in success returning a unit type in case of error it will return a parse and error so over here we have a string literal and we are then trying to parse this string literal to an i32 now again pulse returns a result so we have to handle both cases in case of ok we just take the wrapped value and assign it to number right in this case this would hold an i32 in case of an error it will just return the error and it will stop execution from this point and then all we do is we will print out the number so let's see if this is compiling as you can see this is compiling we are printing out the number and don't forget because we return a result type here we have to return the result variant okay with a unit type in case of success we provide here a unit type to the OK variant because the end of main means the end of the program because the end of main means the end of the program so we don't have to actually return anything here right because if the program ends this returned value won't be beneficial but we can just provide the unit type so we comply with the function signature and by the way as we've seen we can here just use the question mark operator so we can replace this match statement by this and this is actually the reason most people use here in main the result type because then it allows us that we use the question mark operator otherwise if we didn't have result here we can't use this operator let's see of course I have to remove the match keyword here and as you can see this would be the same thing all right see you in the next topic let's take a look at cargo now cargo is the official package manager and building tool in Rust it helps automate tasks such as creating new projects building running testing code and managing dependencies a crate is a compilation unit of rust source code so basically a crate is the smallest amount of code the RAS compilers considers at a time and crates.io is the repository for rust packages so as you can see this is the website of crates.io and here you find some libraries for example we have here the rent Library and this allows for creating random numbers and as you can see you can add this very quickly into your own project and we'll see how this will work what is a crate a crate can be of two types either it's a binary crate and that means the program is compiled into an executable binary it's basically a program you can run and binary crates always have the main function in it and a library create a library create is compiled into a library and it doesn't contain a main function but it's considered a collection of reusable code that can be shared across multiple projects and the create route is the source file that is the root module of the crate in binaries it would be source main.rs and in libraries it would be the file lib dot RS then we have modules and a module is a way of organizing code by grouping together related items modules can be imported using namespaces avoiding naming collisions it also controls the privacy of its items like functions trucks enums and so on when compiling the compiler starts from the create route we have seen in a binary crate this would be in main.rs and in a library it would be lib.rs then it checks if the modules are declared and looks for sub modules sub modules could be directly written in line with curly braces it could be written in a separate file which has the module name ending in dot RS or it could be in a separate director which has the same name of the module and a mod.rs file inside it and we'll do exercises and you will see how that works so in case you want to follow these exercises you actually have to install rust on your system so you can go to rosslang.org and then you can click install and over here it will give you a command you can copy then running a terminal and you can just copy this into your terminal now I'm on a Unix like operating system meaning I will use the Linux command but the website will recognize your operating system and provide the appropriate command so if you're on Windows it will give you a command that you can paste into Powershell for example so proceed with installation default you can then press 1 and enter now I have already downloaded that so I want um run it again and then to check if everything is installed correctly you can use these commands first of all we check is the RAS compiler installed if you get back a version it means everything is installed then we check for cargo this is fine and rust up and rust up is used for um updating the version of rust on your local system all right all right so let's now see the exercises a package is a project which you create with Cargo in most cases so it contains a cargo.tomel file in it so create a package with below layout now I will do that directly in the home directory but you can do it at any location you want so to create a new package we can use cargo new and then provide the name of the package so we want the name here to be hello package and as you can see that we and as you can see the package has been created so let's C CD hello package and we are now inside our created package right so we have here cargo Tamil and a source directory let's see source and if I print out the contents in main as you can see it contains a simple program that prints out hello world so let me actually do it like that so over here if I now do A3 command as you can see we have exactly the same file structure here we have a cargo Tamil and then resource directory with main.rs inside let's print out the cargo toner and as you can see this matches the file in the exercise create a package with below layout so over here we want to create a library so I'm back in my home directory and we can create the library create right now let's do Park on you then the package name here and then we have to write the lib flag right so this will then create a library and then let's CD into that as you can see we have corgotomel and a source directory now let me print out the cargo thermal file and as you can see again this matches and if we go to the source directory as you can see over here we have a lib.rs file and this just has a basic add function over here together with some tests all right fill in the blank with your answer what's the difference between package number one and package number two now the difference would be package number one is a binary crate and package number two is a library crate all right create a crate is a binary or library to create rules the create route is a source file that the rascompiler starts from and makes up the root module of the crate in package hello package there is a binary create with the same name as the package hello packet and source main.rs is the create root of this binary crate similar to hello package hello package one also has a crate in it however this package doesn't contain a binary crate but a library crate and source lib.rs is the great root so what's the name of the library crate in package hello package one the answer would be it would be hello package one right because as we've seen over here in the package hello package there is a binary crate called hello packet and that means in a package hello package one the name of the library crate would be hello package one and by the way a package is what we have seen over here basically when we create a new project right when we create a new project we create a new package and the package consists of a cargo.tomel file and a source directory together with other stuff add a library create for hello package and describe its files 3 below alright so we want to add in the hello package a library crate so let me remove this over here and we will go inside hello package now over here in this Source directory we want to create a new library create as you can see we have until now a binary crate so let's create a lib dot RS touch is a Linux command that allows to create a new file so then we would have lib RS and Main RS so when we look at T3 as you can see we then have the cargo terminal The Source directory and two crates one Library crate and one binary crate so this will then hold lip.rs and main.rs after this step there should be two crates in package hello package a binary crate and a library crate both with the same name as the package a package can contain at most one Library crate but it can contain as many binary crates as you would like by placing files in Source bin directory each file will be a separate binary crate with the same name as the file so create a package which contains three binary crates hello package main one main two one Library create so what we want over here is to have in this Source folder the lib.rs and main.rs then inside the source folder we want to have a bin directory which holds main 1 and Main two right so so as we've seen we can have as many binary crates as we want in a package but only one Library create and over here we have some other directories so we have tests for integrated tests benches for Benchmark and examples so let's create these over here so as you can see inside source we already have a library crate and a binary crate now we want to create a new directory called bin then we see the into bin and we create main1.rs and main2.rs so again when we go to the root of the package as you can see we have cargo terminal The Source directory we have inside the source directory a bin directory holding two binary crates main one main two and we have in the source directory lib.rs and main.rs yep as you can see the above package structure is very standard and is widely used in many rust projects so let's see modules modules let us organize the code within a crate into groups for readability and ease of reuse module also controls the privacy of items which is which is whether an item can be seen by outside code public or it's just an internal implementation and not available for outside code private we have created a package named hello package in previous chapter and it looks like this now we actually created over here a bin directory so let's delete that I go into source and then remove the bin directory so as you can see T3 looks exactly the same now it's time to create some modules in the library create and use them in the binary crate let's start so as you can see we can Define some code in the library create and then use it in the binary crate so Implement module front of house based on the module tree below so in the library create we want to create a module front of house and this should then hold two sub modules hosting and serving now hosting holds two functions and serving holes for functions so as you can see we will do that in the library crate all right and again modules allow us to structure our code so let's open lib.rs and I will copy this over here so we have to implement front of house now we have seen that front of house module should contain two sub modules namely hosting and serving like that so we have a front of house module that contains two sub modules hosting and serving now we want to add these functions over here add to wait list and see it at table in the hosting module uh at waste list adds to wait list and see it at table so as you can see front of house containing one sub module hosting holding two functions over here now let's see serving I will just copy that like that and doing it like that as you can see it is serving module holds three functions and when we run the code actually we can use the cargo run command and as you can see this is compiling but it gives us warning that we didn't use these functions over here which is okay and of course hello world will get printed from the binary crate right because main just prints out hello world let's call add to waitlist from a function eat at restaurant which is within the library create route so inside lib.rs we are below the module front of house we are creating a new function like that call add to wait list with absolute path so it's like in a file system you can have absolute paths and you can have relative paths so in this case we want to use the absolute path to the add to wait list function over here so we would use for the absolute path to create root then we want the front of house module and we want the sub module hosting right and then over here we can call the function like that add to wait list now this would be considered the absolute path now over here we are using the relative path so we are actually already in the create route right so that means we don't need to use crate here we can directly access front of house hosting and then call the add to wait list function now as you can see it gives me here an error module hosting is private so we can make this public using the pub keyword all right now the same thing with the functions let's make them public like that you can use super to import items within the parent module so again in lib.rs we want to create another module so let's copy that put it below the front of house and as you can see over here we have the back of house module with two functions declared inside it so we have fixed incorrect order and inside this function we call the cook order function over here fill in the blank in three ways using keyword super using absolute path so in order to access the function over here serve order let's first use this super keyword so super means we go one level up right so we are here inside the module back of house we go one level up which would be the create route right lib dot RS so we use super and then we can access front of house and I guess hosting no serving and serve order like that and again serving is private let's do that let's make it a public function and again serving here is private so let's make that public and also the function here like that and the second way would be using absolute path so again you can use here create right create would refer to lib.rs because it is the great root of this package separating modules into different files so as you can see we want to put these modules into their own distinct files please separate the modules and codes above into files resident in below third three so as you can see we have here Main and leap RS crates and here we have the modules we want to split up so we have the module front of house holding hosting and serving this r sub modules and mod.rs and we have over here back of house.rs now we have said that there are three ways to declare modules right the first way would be in the create route for example lib.rs we Define in module and put it right inside the curly braces right all the code is inside these curly braces right the second way would be two in lib.rs declaring the back of house module but without curly braces right only declaring like this for example only declaring the module and that means the compiler will then check is there in Source directory a file named as the same name as we gave it to the module right so we declared a module in lib.rs and then we have to create a file ending in dot RS with the same name as the module we have declared and the Third Way would be if we want the module to be a subdirectory of source then we have to again declare front of house inside lib.rs the same way we did before but we create a directory instead of a file with the same name as the module and then very important the code of the module will then be in mod.rs now in our case we are declaring in mod.rs2 sub modules hosting and serving all right so we want to have this code separated in different files and this is how it should look like so let's start with back of house all right I will copy that and first of all I will delete anything in here and let's declare the module back of house right now we have here declared a module as you can see the file is not found so we can here declare and back of house dot RS and then we can put and then we can put the code of the back of house module directly into this pack of house file removing this over here because we have already declared T module and as you can see back of house file now contains only the code related to this module again we have in lib.rs declared the back of house module then we have over here created a file that has the same name as the module right and in here we are providing the code like that and because we have already declared the back of house module we don't have to redeclare it inside here right now as you can see we also want front of house now the difference is front of house should be a directory holding two sub modules so let's first of all in lib we want to declare front of house module like that then we create the directory with the same name as the module foreign like that then the first thing is we create a file mod.rs this is now the create root of this this will be considered the root of this module mod.rs and as you can see we want here inside front of house two sub modules hosting and serving let's declare them like that and then we can create both of these files let's start with hosting and we just take all the code from the hosting module here like that and let's create serving and we just take the code here from this serving module like that let me remove the comment so and now if we go back to the source directory as you can see we have back of house this is a module we have front of house hosting and serving these are two sub modules and we have here mod.rs exactly like we wanted here now over here by the way this function eat at restaurant will be directly in the lib.rs so as you can see instead of defining the module and putting all the code in curly braces meaning inline we can use um different files to restructure and reorganize our code and this makes the lib.rs file much more clean and readable assessing code in library create from binary crate please ensure you have completed the fourth exercise before making further progress you should have below structures and the corresponding codes in them when reaching here so we have done that now we will call a few Library function now we will call a few Library functions from the binary crate so let's copy that into the binary crate like that now we want to call a function so the output should be sit down please and then a second function which returns yummy yummy now as you can see over here we have to call the eat at restaurant function to get back yummy yummy and sit down please would be in the front of house module in hosting and seat at table function so let's see first of all I want here the module front of house right because the binary crate and the library create are separate from each other so the binary crate over here can't know what is defined in the library crate and then over here we can SD create module and then here we can use an absolute path providing the create route now we have to actually provide here the name of the crate meaning hello package all right and then we can call font of house and let's see front of house hosting seat at the table at table like that and then over here we call hello package and then eat at restaurant this is defined in our lib.rs so again instead of writing here a crate we write the name of the package because we are here in the binary crate so we can use the create keyword in lib.rs but in main.rs we have to write the name of the package let's run that and as you can see we have some errors module serving is private and module hosting is private so to actually access that from the binary crate we have to make them public so let's see first of all we go to lib.rs and we want these two modules to be public so let's make them pop like this which means that these two modules are now accessible for our binary crates the main.rs file then let's go to um front of house and let's here make these two modules or these two sub modules also public like that and if the module itself is public that doesn't mean that the inner functions for example or structs or anything that is inside the module is also public so we have to declare here as you can see this is already done that these functions are also public if we want to access it and as you can see serving also has the public functions now let's check again in lib.rs because we are calling here a function all right this is also public let's run it again and as you can see this is actually compiling it just over here and complaints that we didn't use some of the functions which is okay at the moment now instead of just assorting let's actually print that out and let's do it like that as you can see the output will be sit down please let's call the second one so we want to get this like that let's see all right I copied here the holy uh I copied here the whole assert we don't need this actually let's see and as you can see the output will be sit down please and yummy yummy so we have successfully restructured and reorganized our whole code into different files and folders meaning it is much more organized and much more readable all right see you in the next topic we will now take a look at the debug and display trades so types which want to be printable must Implement either debug or the display trades and automatic implementations are only provided for types in this standard Library so this doesn't apply to our customly created types a debug trade can be implemented by simply using derivable trade and a display trade must be manually implemented let's see we have here print Ln and format printing is handled by a series of macros defined in standard format some of which include format write formatted text to string print same as format but the text is printed to the console print Ln is the same as print but a new line is appended ePrint is the same as format but the text is printed to the standard error and eprint Ln same as eprint but a new line is a pendant all parse text in the same fashion all porous text in the same fashion as a plus rust checks format correctness at compile time so let's see we have here a string literal and we use here the format macro meaning the return type will be string and we want here s to hold a string of hello world so again we use the format macro like we would use the print L and macro we have been using so in this case we want to take S1 over here and then just append the rest so we take hello this will be placed here and then the rest and this is compiling let's actually print that out as you can see this would be the output when printing out s print print Ln fill in the blanks to make it print a hello world I am and turn on the new line Sun face so over here we want to use print because as you can see I am should be on the same line so as we've seen print macro doesn't append a new line character now a new line is defined in C like that all right and this is a symbol that the compiler knows that it should treat it as a new line but in this case print doesn't append it so the next line will be on the same line as this print statement so let's use here print Ln because as you can see after I am we want to have a new line and then over here we can again use print Ln and this would be the output debug and display so all types which want to be printable must implement the standard format formatting trade debug or display automatic implementations are only provided for types such as in this standard Library all others have to be manually implemented let's first look at debug the implementation of debug is very straightforward all types can derive the debug implementation this is not true for display which must be manually implemented and we have used that before this is the debug notation must be used to print out the type which has implemented the debug trade so as you can see over here we have a custom type this structure cannot be printed either with display or debug to make this struct printable with debug we can derive the automatic implementations provided by rust so again we can use a derivable trait meaning this struct over here implements the debug trade meaning we can print it out using debug notation so fill in the blanks and fix the errors as you can see we have here a custom type structure holding an i32 value types in standard and rust have implemented the debug trade so as you can see this is of type i32 now all of the types in the standard Library have implemented debug or even display so we can use here to display notation and this will print out fine now over here we must use debug notation because this is a type that we have created and again to use the debug notation we have to derive the debug trade like that and that means structure implements the debug trait and we can then print it out so this i32 type will be printed automatically because it's a type defined in this standard library and over here we just had to derived debug trade and then use debug notation here so format debug definitely makes one type printable but sacrifices some Elegance maybe we can get more elegant by replacing this notation with something else but not this alright let's see we have here a custom type that derives the debug trade then we are here instantiating it and when we now execute the program as you can see the output will be like this now we want the output to look something like that and we can for that use the pretty notation just adding this hashtag symbol between the colon and the question mark and then the output should look much more pretty as you can see the output will then be like this and notice we first had to derive the debug trade in order to print it out using debug notation we can also manually Implement debug trade for our types so as you can see we have here two custom types structure and deep now structure holds a type of i32 and depos a type of structure meaning these are basically nested so we have keep which holds a structure which holds an i32 right the problem with derive is there is no control over how the results look what if I want what if I want this to just show A7 so as you can see we are here instantiating it with a value of 7. now when we print it like that then as you can see the whole structure will get printed out but we only want tip value over here so what we can do is we implement the debug trade manually meaning we can manipulate the output so let's see the debug trade in the documentation and as you can see this is the debug trade as defined in this standard Library so let's copy this function signature so we can then over here implement the debug trade and this is found in a module M and this is inside the module fmt from the standard library and we want to implement it for the Deep over here now we remove that and we also remove that because we are implementing debug trade manually right we don't need the derived implementation so let's see deep then I will copy the function signature so here we can use a custom type fmt result and you know what we can use a namespace here so then we don't have to write here standard all the time like that I can delete this lifetime and now we can implement the debug trade namely this fmt method so again we want to write to a buffer so we will still write macro and it should write to this formatter which is provided by the debug trade and then over here all we want to actually print out is in this case self right the instance over here and then we access the first element so when we access the first element in a tuple we use the dot notation like that and inside here we have now accessed structure and we want to access this value this structure struct holes right so we again use zero and that's basically it now it should print out and of course over here fmt formatter this is also from the fmt module and as you can see now 7 will print so all we did over here is manipulating how the output of the debug trade looks like when we use debug notation and as you can see we have defined for the Deep custom type over here how the output should look like so the output will just be the inner element of deep and structure right this i32 and we just access that and write it to this buffer all right display here debug is simple and easy to use but sometimes but sometimes we want to customize the output appearance of our type this is where display really shines unlike debug there is no way to derive the implementation of the display trade we have to manually implement it another thing to note the placeholder for display is this and not that so this would be for debug trade for display we are using that and you know that already so make it work as you can see again we are using the fmt module and we have a custom type 0.2d holding two fields of type f64. now we want to implement the display and the debug trade for this custom type meaning when we instantiate this point 2D then we can pass the instance over here and it will give us this output right so we are using here the display notation and debug notation and as you can see we can here Define different outputs so when we pass an instance of point then the display trade actually will output something like that if we use debug notation then we want the output to look something like that and that's what I mean when I say we can manipulate how the output of a custom type will look like so I will take over here this method and I will just copy it over here now let's first implement the display trait as you can see we want the output to look something like that so we Define here lay the X field the value of x field and then plus the value of the by field and we have here an i okay like that and we can access these fields using normal notation self dot X and cell dot y right and for debug notation we want the output to look something like that so let's copy this put it inside here and as you can see we want here the value of the X field and here the value of the Y field and as you can see we are here using curly braces and this is usually for the placeholder so what we have to do here is using two of them meaning this calibrases over here will basically be escaped all right and then over here we have to provide the arguments self.x and self dot y let's see and this is compiling now let's see the actual output as you can see I'm using display notation and debug notation and just provided an instance of the point to the type and as you can see this will then be the output so question mark operator implementing fmt display for a structural whose elements must be handled separately is tricky the problem is each right generates a fmt result which must be handled in the same place fortunately Russ provides the question mark operator to help us eliminate some unnecessary codes for dealing with fmt result so let's see again we are using the fmt module and we have here a custom type a struct list a tuple struck list holding a vector of i32 elements right over here we are instantiating this list with a vector holding one two three now as you can see when we put this list over here into the format macro then we want the output to look something like that so we want to print these square brackets the index colon and then the actual value now let's see how this would be implemented notice over here we are implementing the display trade so we can then use it to display the type directly so as you can see this is the function signature from the fmt module and as you can see over here we return a type of fmt result now this is a third now this would be a type Alias and we have covered that now over here we want to extract the value using Tuple indexing and creating a reference to back so the first thing we do is we want to access the vector in the list struct and we do that using Tuple indexing right we want the first element because there is actually only one element on here so we access that meaning we'll get back a reference to a vector holding i32 types right here we are taking a reference now then we have basically unwrapped this Vector into this variable now as you can see we use the right macro to write to this buffer this square bracket because as you can see this is what we want to Output so the first thing added to the buffer will be this square bracket then iterate over V in vac while enumerating the iteration count in count so we take this vector and we iterate over it and enumerate meaning we will get back a tuple holding the index and the actual value then for every element except the first add a comma use the question mark operator to return on errors so as you can see if count is not equal to zero meaning if it is in fact the first element then we don't add this comma all right because we don't want to look something like that so this is only after the second iteration that this comma will be added and then we write the actual value over here and this iterates three times right for each element and then in the end it will put into the buffer this square bracket so when we run that as you can see the output would be something like that but this is the output that we want so what's missing over here is we didn't include the indexes right so what we can do over here we want here to be the index and then a colon like here and a space and then the value so we have the index in this count variable so let's use that and again we can then run the program and this succeeded so let's actually print that out as you can see this would be the output so we can really manipulate the output of our custom types using the debug and the display trades and by the way as you can see we are here using the question mark operator because this over here could potentially fail right that's why we are using this here and we use here the result type from the fmt module just in case any of these operations here fail alright see you in the next topic so let's take a look at lifetimes now lifetimes are only necessary when dealing with references and even then most of the time the compiler can actually infer the lifetimes and we don't have to worry about it so let's see a lifetime is another kind of generic ensuring that references are valid as long as needed every reference has a lifetime which is the scope for which the reference is valid most of the time this is implicit and inferred so we don't have to worry about it sometimes though lifetime annotations are needed and that's the case if the compiler can't infer it and lifetime annotations is a concept which most other programming languages don't have so even for experienced programmers this sometimes looks a little bit confusing but in actuality it's a very simple concept and you will understand it very quickly so actually the main aim of lifetimes is to prevent dangling references also called dangling pointers so let's see we are here in Main and we declare a variable R we don't initialize it with a value but just declaring it meaning the compiler will actually infer a lifetime of a for this variable and the lifetime a in this case is valid until the end of the main scope right then over here we have an inner scope and in this scope we are initializing variable x with a value of 5. so the compiler will annotate this variable to be of Lifetime B and as you can see lifetime B is only valid until the end of this scope now then we are assigning a reference to x to the variable R meaning the variable R we have declared here holds a reference to the variable X the problem here is that when X goes out of scope at this point then R Points to something that is not valid anymore right and that's the aim of references to avoid exactly this scenario now to understand lifetimes you have to understand the borrow check or in Rust so the borrow Checker Compares Scopes to determine whether all borrows are valid it's a key part of Russ ownership system it tracks lifetimes of references and ensures that they don't violate the ownership rules these rules ensure that the value is not accessed after it has been moved or freed from memory an important a reference to a value must never outlive the value itself so you have to remember especially the last line a reference to a value must never outlive the value itself so when we go back here as you can see we have here a reference to value 5. now the problem is that this reference outlives the value itself meaning X holding this value we are referencing to goes out of scope meaning the reference on here lifts longer than the actual value it is referring to all right let's see the compiler uses lifetime to ensure all borrows are valid typically a variable's lifetime begins when it is created and ends when it is destroyed so the scope of Lifetime annotate the lifetime of I and borrow 2. lifetimes are annotated below with lines denoting the creation and destruction of each variable I has the longest lifetime because its scope entirely encloses both borrow1 and borrow two the duration of borrow 1 compared to borrow 2 is irrelevant since they are disjoint so when we look at this program here what you see is that we have here initialized variable I right now this variable I over here lives until the main scope ends all right basically it outlives this scope and this scope now over here we are assigning a reference to I to borrow one right so borrow one lifetime starts and then we are just printing out borrow one now over here borrow one will go out of scope but it doesn't matter because the value itself still lives on all right and over here the same thing we have power 2 which holds a reference to I meaning that borrow 2 lives inside the scope so we print here borrow two and then it will here go out of scope but again the value here lives on so the actual value outlives T borrows or the references all right example two so over here we have a variable X with a value of 5. and then over here we have a reference to X assigned to variable r and then we are printing out R right so if we execute that it will compile because again as you can see we are declaring here the variable X in this scope so variable X we live until the scope ends and the same thing for the reference to X so the reference to X is assigned to R meaning R will live until the end of this scope so the value and the borrow to the value are both valid all right and over here you can see the lifetime annotations the important thing here is that both the value itself and the reference to the value or valid right the reference here doesn't outlive the actual value it is pointing to annotate R and X as above and explain why this code fails to compile in the lifetime aspect that's actually the example we have seen so we are here declaring r and over here in this inner scope we declare a variable X and initializing it with a value of 5. then we are assigning a reference to X to R the problem here is X will go out of scope so R still points to dislocation but this over here has gone out of scope right so rust won't allow you to compile this program and you will get a compiler Arrow saying X does not live long enough right because the reference to the value lives longer than the actual value lives right meaning the lifetime of X is shorter than the lifetime of r or the lifetime of X holding the value is shorter than the lifetime of R holding the reference to a value and this should never happen so lifetime annotating The Borrowed cycle reuses explicit lifetime annotations to determine how long a reference should be valid but for us users in most cases there is no need to annotate the lifetime because there are several illusion rules before learning these rules we need to know how to annotate lifetime manually so ignoring illusion rules and that's the next topic lifetimes in function signatures have a few constraints any reference must have an annotated lifetime any reference being returned must have the same lifetime as one of the inputs or be static so over here we have a function print one and it takes as an argument a reference to an i32 type alright now this is how we would annotate a lifetime it's actually very similar to generics but we use this apostrophe syntax and a lowercase letter by convention just going from a b c d and so on so in this case we annotate here that the reference that the reference here is of Lifetime a so when we have over here a lifetime annotation then we can provide here then we can annotate it here for our reference right and again we are just dealing with lifetimes when we are dealing with references so in this case we say the reference to the i32 type should be of Lifetime a now when we annotate that to our function it means that the lifetime a must at least live as long as the function itself or we all or we could also say lifetime a must outlive this function so the past reference over here must outlive this function this is just ensuring that the reference passed here lives longer than this function meaning we can ensure that this function always deals with a valid reference right and all we do here is printing out X mutable references are possible with lifetimes as well so if you would have a mutable reference you would annotate it like that first after the Ampersand of course you will always put the lifetime annotation and then the mute keyword and then of course the type multiple elements with different lifetimes in this case it would be fine for both to have the same lifetime a but in more complex cases different lifetimes may be required so as you can see we can Define more than one lifetime over here we have lifetime a and lifetime B meaning the references pairs to this function could be of different lifetime but again lifetime a and lifetime B must outlive this function so the past references over here must outlive the function right and returning references that have been passed in is acceptable however the correct lifetime must be returned so let's take a look at the function pass X as you can see it takes two arguments and both of them are references now this would be of Lifetime a and this would be of Lifetime B again both of these references must outlive this function and we are just returning X which is annotated with a lifetime a meaning the return type will return meaning the return type will be a reference to an i32 with a lifetime of a right this would be the type that is annotated to the X argument here if we would here have y and we return y then we would do it like that right because we are returning a reference with a lifetime annotation of B foreign so as you can see we have here two variables holding i32 types and then we are passing to all of the above functions T reference to these two variables right because all of these functions over here expect a reference to an i32 type now in this case this program will compile as you can see this is compiling because we have here declared X and Y in the main scope meaning they are valid until the end of the scope over here right so t x and y references we pass to the functions outlive all the functions which is a requirement right the best references must outlive the function so we don't have to deal with dangling references and so let's see an exercise to understand it even more make it work by adding proper lifetime annotation so over here we have the function longest that takes two arguments of type string slice now we then test the length of these string slices and if x is and if x is longer than y then we return X otherwise we return y so if we go over here in the main function and let's do some variables as you can see we have two string literals long and longer now we would pass that to this function over here now it could be possible in this case the return type is known at compile time but sometimes this is decided at runtime and when we are passing these arguments to the function over here let's do that actually and notice we don't have to pass here a reference because string literals are already references all right now if we would compile that this would actually fail right missing lifetime specifier so what we want to achieve here is first of all we want to add a lifetime parameter like that and then we want to define the lifetimes of these references now in this case the function over here could either return X or Y right depending on which argument has the longer string right so sometimes it might be X that is returned and sometimes it might be y so we can't be sure if we annotate here a and B like that we don't know which one will get returned is it a or b it depends on the arguments right so what we can Define here is that X and Y these two arguments have the same lifetime meaning these two references share the same lifetime they must be declared in the same scope and both of them of course must outlive the function longest so in this case this is what we are providing right we are declaring X and Y over here in the main scope so when we call the longest function with these two references over here it means that these two references still live on even after this function call all right because again the reference of X and Y will leave until the main scope ends now because we have here defined that both of these references have the same lifetime it is clear that the returned string slice must have the same lifetime either X or Y right let's see and as you can see this is compiling in this case longest will return y because it is longer than this than the X string all right a must live longer than the function here reference to string Foo would create a string followed by a reference then the data is dropped upon exiting the scope leaving a reference to invalid data to be returned fix the arrow in three ways as you can see we have the function invalid output we Define here a lifetime parameter a and declare that The Returned reference should be of this lifetime now the problem here is we are creating a new string and returning a reference to it right we are returning a reference to a string the problem is this string was declared inside the function now when the function returns to the caller it means the string over here will get out of scope right because it is declared inside the function so again if we call for example if we call this function then we would get back a reference to a string right the problem is that the reference points to something that isn't valid anymore this string declared here got out of scope so X points to something that is not valid anymore so returning a reference to something declared inside the function is a really bad idea now what we can do over here to fix that and this is probably the easiest fix we just return the string itself right so then ownership will be transferred and X will be the owner all right let's print out X as you can see this is working because we are here declaring a string and then return it meaning the ownership of the string will then be returned over here right so X will become the owner of the returns string from the invalid function the second way to fix that would be returning a string literal right and a string literal actually has always a static lifetime we will come back to that but that actually means that this reference is of static lifetime meaning it is valid throughout the entire program all right because remember a string literal is hard coded into the binary so it lifts as long as the program lives so then over here we will get back a string slice right let's see and as you can see this is also compiling the Third Way would be over here create a string and then we can pass this string to the invalid output so in this case we want here to take a reference to a string right we can also write it like that because remember a reference to a string will be automatically inferred to a string size right so so we are then passing a reference to this string right and what we want to return here is s meaning we return here a string slice and we can annotate a lifetime parameter and then we will print out X let's see and this is also working because as you can see we have defined here a string meaning s over here is the owner of this train then we are passing a reference of s to this function right we annotate here a lifetime a meaning the reference over here passed to the argument s must outlive this function which it does right we have declared s here so even after this function call S still lives on right and then all we do is we again return as the past reference right so it will actually have the same lifetime as the past argument all right meaning we have here then a returned string slice all right Point refs takes two references to i32 which have different lifetimes A and B these two lifetimes must live at least as long as the function print refs so as you can see we are here in the print refs function declaring two lifetime parameters one for argument X and one for argument y again we are dealing with references meaning we care about the lifetimes if these would be owned types like so then we don't deal with references right and then we just print out X and Y to provided arguments make it work if function which takes no arguments but has a lifetime parameter a so over here we can see that we annotate a lifetime parameter a and we have here and i32 integer now error X does not live long enough so we assign to Y over here in reference to X the problem again is that when we annotate this lifetime parameter it says the lifetime a must outlive this function which it doesn't right because the reference over here because the value we are referencing to is declared inside the function meaning it will then be dropped at the end of the scope attempting to use the lifetime a as an explicit type annotation inside the function will fail because the lifetime of reference X is shorter than a a short lifetime cannot be coerced into a longer one so let's see in main we are here destructuring a tuple into the variables 4 and 9 right so 4 will hold 4 and 9 will hold 9. borrows of both variables are passed into the function so we are then calling the print refs function with references to 4 and 9 right this function over here any input which is borrowed must outlive the borrower in other words the lifetime of 4 and 9 must be longer than D then that of print refs so again when we annotate these lifetimes on a function both of the lifetimes must outlive the function or both of the references passed here must outlive the lifetime of this function which they do right so 4 and 9 are declared in main scope meaning they outlive this function over here so this should actually work so failed borrow contains no references to force a to be longer than the lifetime of the function but a is longer because the lifetime is never constrained it defaults to static so so as you can see we have here declared the lifetime a which states that the reference holding the lifetime of a must outlive the function this is not the case right because we are declaring the value inside the function itself now when we remove that actually this over here will then work all right let's see let's see structs make it work by adding proper lifetime annotation a type of road which houses a reference to an i32 the reference to i32 must outlive borrowed so as you can see we have here a custom type a tuple struct holding a reference to i32 now in this case we have to annotate the lifetime and we do it like that and then we pass it to the reference like so and that means this reference here must outlive this struct or the instance we create from it right similarly both references here must outlive this structure again we are here annotating the lifetime and we say that both of them should have the same lifetime which makes it easier right and enum which is either an i32 or a reference to one so as you can see again we can annotate a lifetime basically like a generic type parameter and over here as you can see this variant holds a type of i32 so the enum will be the owner of this type we don't care about any lifetime annotation we only care about lifetime annotations when dealing with a reference like that now let's see we have here i32 and i32 and then we are instantiating the borrowed struct with a reference X right so as you can see this would be the borrowed struct and it holds a reference 2x which is i32 right now as you can see we Define here that reference of Lifetime a must outlive this struct or the instance of destruct right so X over here must outlive this instance which which it does right because it again it is declared in main scope meaning X and Y we live until this point here so they outlived The Borrowed struct and over here as you can see we pass here references to the X and Y field of the named borrowed a struct so this would then be an instance now again X and Y in this case first of all they are declared in the same scope so they can have the same Lifetime right they both live in the same scope and both of these variables will end at the same time so this will actually compile right everything over here is safe so as you can see we instantiate clear the either enum and one time with the variant ref holding a reference to X now again as you can see we have here a lifetime parameter a which states it must outlive the instance of the enum which it does right X is valid all the time and the second variant doesn't hold a reference we just pass it to single we just pass it T variable now because this implements copy it's an i32 it means that even then y will still live on so either want to take ownership it will take ownership of the copied value let's see if this is actually compiling and this is compiling make it work so over here we have destruct no copy type and and over here we have struct example and as you can see we annotate here the lifetimes A and B meaning over here the A and B field could hold references that have different lifetimes but they can also be the same all right now let's see in main a tight to FN main stack frame so as you can see we have here an i32 and over here we have declared a variable which should be of type example but we haven't initialized it with values all right we haven't instantiated the example struct now notice here we have another scope lifetime B tied to new stack frame so then we have here an instance of the no Copy Type struct and as you can see fix me so then we are instantiating example with the fields over here passing it concrete values as you can see we are passing it a reference to Bar a this and a reference to Bar B so the problem over here is that VAR B will go out of scope at this point right meaning the example struct we have instantiated over here will hold the B field which points to something that is not valid anymore as you can see we are here printing out example now if we would print it out in this scope then this would actually compile and of course this must be your 32 because it is a u32 field here as you can see this is compiling fine now even though we are here in a new scope right we have declared Bar B here in the inner scope but even then both of these references are valid right because we are here then using example in the same scope and we have noted that here that you that the lifetime of a and b are different right so the lifetime of bar a is actually longer than the lifetime of Bar B right because for a lives until the end of the main function while Bar B leaves only until this point but again this is safe and this is compiling because the VAR B we have created here and passed a reference to the example struct is valid if we leave this over here then this wouldn't compile right because vorby gets out of scope and we over here say that both A and B must outlive example all right so example is used here but not all references are still valid which would lead to a compiled error but what we can do also is just removing this scope here meaning everything is now declared in main scope so this would also compile right because all the references to these variables are valid let's see here we have again struck no copy type and the example struct we have seen before and as you can see denoting that the lifetimes of these references might differ but they can be the same it's no problem so let's see here fixed function signature we have here the fix me function which takes us an argument a reference to an example instance and it will then return the B field from the provided argument from the example struct right it will return this field over here meaning a reference to no copy type because that is what B is holding now over here we are instantiating no Copy Type and we are instantiating the example struct so we pass for the field a here a reference to one and for B we pass a reference to no Copy Type right and then we pass a reference this example instance over here to the fix me function now let's first annotate the lifetime parameter again we do a and over here we say that the past reference to the example instance must outlive this function right which it actually does because here we are instantiating the example struct and passing it to a reference and passing it as a reference to this function meaning example over here will live longer than the function right and we can then Define that no Copy Type must also outlive this fix me function all right which it does because again it's secured the main meaning the end of scope will be at this point so both the instance of example and the no copy type both outlive this fix me function and as you can see we can pass this same lifetime parameter because they are declared in the same scope meaning they have the same lifetime methods are annotated similarly to functions so we have here destruct owner holding an i32 type so annotate lifetimes as in a standalone function as you can see we have here the implementation block for owner and we Implement some methods for this custom type and this is how we would annotate lifetime parameters again same thing again same thing like in functions make it work by adding proper lifetime annotations you have a struct important excerpt and the port field holding a string slice now again string slice is a reference meaning we have here to annotate the lifetime parameter so that means the reference that the port field of destruct is holding outlives the entire struct right and over here we have a method implemented for the important excerpt struct so as you can see we are using a lifetime parameter here but we have to actually first declare it like that and that's basically it it should compile so when distract over here declares a lifetime parameter we have to declare it in the implementation block again but we are here not using it meaning we can do it like that right we don't care about this lifetime parameter here and this lifetime parameter is declared only on the on the method right this is compiling but there is an easier way actually we don't have to use any lifetime here right because we can Define here that the string slice is static meaning it will live throughout the entire program all right illusion some lifetime patterns are so common that the borrowed Checker will allow you to Omit them to Safe typing and to improve readability this is known as illusion illusion exists in Rust only because these patterns are common for a more comprehensive understanding of a lesion please see lifetime illusion in the official book so I have prepared some slides let's see there are three rules of Lifetime illusion the first rule states compiler assigns a lifetime parameter to each parameter that's a reference second if there is exactly one input lifetime parameter that lifetime is assigned to all output lifetime parameters third rule if there are multiple lifetime parameters but one of them is a reference to self or immutable reference to self the lifetime of self is assigned to all output lifetime parameters so let's see an example and before we see the example as you can see lifetime illusion makes writing rust much more easy until this point we didn't worry and care about lifetimes and that's most of the time the compiler just inferred it so we didn't have to worry now let's see here we have the function first word taking a reference okay and returning a reference so the compiler applies the first rule each parameter gets its own lifetime so the compiler behind the scenes will annotate here a lifetime for this function and we'll annotate it for all the references right so the second rule applies because there is exactly one input lifetime again we have only one argument that is a reference so this gets assigned to the output lifetime meaning the output reference here must then be the same reference right we are taking a reference so it must be the same when we are when we are returning a reference so in this case the compiler could infer the lifetime and we don't have to specify them manually so what the compiler will do he will just annotate the same lifetime as for the input argument right so this is all inferred you can write it like that and it will compile you don't have to worry about lifetimes so let's see this example we have the function longest that takes two references as arguments okay and it returns one reference first rule each parameter gets its own lifetime so the compiler will come and annotate A and B each reference gets its own lifetime all right so here the second rule doesn't apply because there is more than one input lifetime also the third rule doesn't apply because this function is not a method we have now to manually annotate the lifetime parameters so as you can see over here the compiler cannot infer The Returned reference here is it of Lifetime a or is it of Lifetime B right so it depends if you return X then you would annotate a lifetime of a if you return B then you would return then you would annotate a lifetime of B and again both lifet times A and B must outlive this function let's see an example in a method so as you can see we have a method taking a reference to self meaning taking the instance as a reference and doesn't take ownership so here the third rule applies which states that if there is a reference to self then all references will have the same lifetime as self right so we can have here any number of arguments all of them will take the exact same lifetime as the lifetime of self because this is inferred and it makes sense right because all of the provided arguments to a method must actually outlive the structure or the enum instance all right so all of the arguments here take implicitly the same lifetime as self all right so let's see remove all the lifetimes that can be elided as you can see over here we have only one input argument and the second thing is we don't even return anything so we don't even have to care about uh the lifetime because we don't worry that it might go out of scope right but in this case we only have one argument meaning the compiler is able to infer that over here again we have only one argument but as you can see the difference is we are returning a reference right so because there is only one argument here the compiler can infer that the reference over here must be the reference that will be returned so we don't have to annotate the lifetimes so let's see over here we have the longest function and the first rule says that the compiler will annotate a lifetime for each reference meaning it will create a and b because we have here two references right two arguments and it will annotate for the first argument a and for the second argument lifetime of B now over here this the compiler cannot infer which lifetime will get returned meaning as you can see we are returning X so the lifetime over here would be a right the lifetime of the argument X but notice both of the references must outlive the function right here we have a struct owner that holds an i32 type annotate lifetimes as in a standalone function so as you can see we have here methods implemented on the owner struct now again when we have a mutable reference or an immutable reference to self then we never have to worry about lifetime annotations because this will get inferred by the compiler all right all references pass to these methods will get the same lifetime as self or SD reference to self now over here we have to annotate the lifetime because this is a struct and we want to ensure that the reference the name field is holding is actually living longer than the instance of a struct person okay and over here the same thing let's see if this is compiling and this is compiling what we could do also here we could remove that and doing it like this all right this should actually also work okay we have here to specify that this string is static in this case we have to explicitly state it and as you can see this is compiling so you don't have to declare here a lifetime parameter you can put here this static Lifetime and static lifetimes will be our next topic let's take a look at static lifetimes so aesthetic lifetime refers to a lifetime that lasts for the entire duration of the program's execution any reference or borrowed value with a static lifetime can be safely used throughout the program and aesthetic lifetime can be coerced to a shorter lifetime if needed so we have seen string literals and they are usually annotated using an ampersand and stir but implicitly it would have a static lifetime so string literals have a static lifetime because they are hard coded into the executable meaning they are valid throughout the entire duration of the program's execution let's see static is a reserved lifetime name you might have encountered it several times so a reference with static lifetime is for example a string literal and this would be the full type annotation static as part of a trade bound so as you can see we are here defining a generic type parameter and we say that the argument provided should be of type T now in the Vera Clause over here we see that t must be of static lifetime though they are all static but subtly different as a reference lifetime Ampersand static indicates the data pointed to by the reference lives as long as the running program but it can still be close to a shorter lifetime there are several ways to make a variable with static lifetime two of them are stored in the readonly memory of the binary fill in the blank in two ways so as you can see we are calling here neat static within argument of V so let's declare that here and as you can see the argument must be of type static string or string literal all right and then we are here checking is the argument equal hello so let's initialize it here so the first way is just initializing it like that without any type annotation because this is simply inferred by the compiler so any string literal is hard coded into the binary means it lives as long as the program's execution Because the actual data of the string literal is living in the binary the second way is just annotating the full type annotation like that and this static lifetime annotation here can also be omitted so we can annotate it like this as you can see the compiler is able to infer the lifetime another way to make static lifetime is using box leak now this is an unsafe method and I won't cover that because it's a more advanced topic but I have solved it and will put it on my GitHub if you want to solve it for yourself static only indicates that the data can live forever not the reference the letter one the letter one will be constrained by its scope so let's see make a string literal and print it so over here we have a string literal meaning it's a string slice of static lifetime then we print it out when static string goes out of scope the reference can no longer be used but the data remains in the binary so at the end of this scope over here this variable will go out of scope meaning it's dropped and that means we can't then use static string anymore because the variable has been dropped now even though the variable now even though the variable has been dropped the data over here is actually still living on right so this is living in the binary a string literal is hard coded into the binary meaning it is of static lifetime meaning it is valid throughout the entire Pro programs lifetime but of course a variable is bound to its scope so to make that work we can take that and copy it over here meaning the variable static string is valid until main ends as you can see static can be close to a shorter lifetime so over here make a constants with static lifetime so this over here is the static keyword meaning we are here creating a constant now constants by conventions are always uppercase right and by the way the difference between conist the difference between this and this now both of them live for the entire lifetime of the program both are of static lifetime but the difference is that static will always remain at the same memory location while a const constant will get inlined so when we use for example num const here then it will get inlined meaning the compiler will basically copy that into the code in the function so the memory location could change but static always stays at the same memory location so returns a reference to num there is static lifetime is coerced to that of the input argument so as you can see over here we have a function corostatic and we have defined a lifetime parameter a we Define here that the input reference should be of this lifetime a right meaning the reference we take as an argument to this function must outlive the function itself now we over here actually return this constant right basically a reference to this constant and we can in this case course the static lifetime of this num constant to a shorter lifetime it's no problem right so a is shorter than static right aesthetic lifetime is larger than this a lifetime here meaning aesthetic meaning a reference with a static lifetime lives longer than a because a only defines that it must outlive this function right but we can hear chorus it to a shorter lifetime so it matches with the lifetime annotated on the function make an integer to use for coreostatic so over here we make an integer and then we pass a reference of this integer and called the chorus static function meaning we here returned a reference to an i32 right basically a reference to the number 18. and then we will just print out the result of this function call right now as you can see we have crossed num here to a shorter lifetime but this doesn't change the actual lifetime of this static constant right so even after this scope over here we can still access num because again it's of static lifetime it lives as long as the program is running so even though we have here corrected to a shorter lifetime it doesn't matter it remains static right let's see as a trade bound it means the type does not contain any nonstatic references for example the receiver can hold on to the type for as long as they want and it will never become invalid until they drop it it's important to understand this means that any owned data always passes a static lifetime bound but the reference to that owned data generally does not so so let's look at function printed as you can see we Define here a generic type parameter meaning the input meaning the input argument here must be of type T now this over here is a trade bound meaning we say the type T must implement the debug trade and T cannot contain any reference that is not of static lifetimes so all references T is containing must be of static lifetime right and over here we do basically the exact same thing but using the impul keyword right this and this is actually quite the same and then over here as you can see 22 takes a reference to T right and again T must implement the debug trade and it cannot contain any nonstatic references all right so I is owned and contains no references thus it's static as you can see we are here initializing I with a value of 5 meaning I is the owner of 5. now when we pass the owner to a function then it would actually comply with this function signature because owned types are also considered static okay now this would actually work because again i32 implements debug and it is considered static because we are passing an owned type right oops reference to I only has the lifetime defined by the scope of main so it's not static right so the so a reference to I has a lifetime that is defined by this main scope so it's not static anymore right so this would actually output and error right and this would be the same thing again print it and print it one would actually be very similar right now this here actually works because we are here passing a reference to I again right so we pass a reference to I and again the reference to I would have a lifetime of this main function now the difference is here that in the argument we defined that the argument should be a reference to T meaning if we think away it is ampersands I would be T right so a reference to T would be a reference to I hope this makes sense so that means again when we pass I directly it would be it would Implement debug and it would be of static Lifetime right so this over here would work now to fix this over here we can do it two ways we can create here the constant I and again constants have a static lifetime as you can see this is compiling and the second thing is we can use this static keyword meaning I is static so this would pass because the argument we are passing or the references we are passing are all of static Lifetime and they implement the debug trade right i32 implements debug and we have ensured that all of them are of static lifetime now the last one here again deals with box leak I won't cover this but again the solution is in my GitHub if you want to solve it you can do that and then compare with my Solutions alright see you in the next one so let's see closures a closure is an anonymous function that is able to capture the values from the scope in which it is defined and if you are coming from python then you might know Lambda functions and in JavaScript they are called Arrow functions and they can be defined inline for example as a function parameter they don't require type annotations and they can take ownership of a value by using the move keyword so all functions and closures implement the F and trades and that is the trait that defines the signature for closures and functions it describes the types the number of arguments and the return type there are three different traits FN ones the closure can be called only once because it takes ownership of the captured values FM mute it might mutate a captured value it can be called more than once and FN it doesn't take any ownership of captured values it doesn't mutate anything and it might not even capture anything from its environment so let's take a look over here we have here initialize the variable x with a value of 1. now over here we would have a closure and closures are defined like that first of all we have these symbols over here and between them we Define the name of the argument and as you can see over here we just add the argument with the value of x so as you can see the closure here is able to capture the value of x something a function can't do right and we then assign this closure to a variable meaning we then can call this closure and calling it like in normal function so in this case as you can see we call the closure using the variable name closure and then providing it an argument right so actually disclosure call should evaluate to 3 because we provide 2 here meaning weld will be 2 and adding X to it one so two plus one will be 3. so disclosure captures the value of x and modifies it the compiler will capture variables in the least restrictive manner possible in this case immutable reference of X is taken rather than taking ownership because it's less restrictive let's see closures can capture the enclosing environments for example we can capture the X variable that's the example we have seen from the syntax we can see that closures are very convenient for on the Fly usage unlike functions both the input and return types of a closure can be inferred by the compiler so we have here a normal function as you can see it takes an argument of type i32 and it will just add 1 to T and it will just add 1 to the provided argument and returns it meaning the return type will be i32 now closures are Anonymous here we are binding them to references these nameless functions are assigned to appropriately named variables so as you can see we can here create a closure and this and this over here are exactly the same so type annotations enclosures are not required okay and then again we assign the closure to a variable in order so we can call it all right over here we have a variable I with a value of 1. and then we are just calling the function and these two closures with this value over here and a closure taking no arguments which returns an i32 the return type is in third so this would be a very primitive closure just with running one when being called so when we call one here we will just get back one let's execute that you can see when we call this function and these two closures it will just add one to the provided argument and over here we are just returning one capturing closures can capture variables by borrowing or moving but they prefer to capture by borrowing and only go lower when required so they can capture the values either by reference by mutable reference or by value meaning the closure will then only type it captures okay so let's see exercise one make it work with least amount of changes so over here we are initializing a variable color with a string so as you can see over here we have a closure and we assign it to print so we can then call it now this closure here doesn't expect any arguments but it uses the move keyword meaning the captured values will be moved inside this closure right so that means the closure here will become the owner of the captured value this is not always the case so for example over here a immutable reference is sufficient because we are just reading basically this data here we don't mutate anything and we don't need ownership to print something out but as you can see printing two time over here will cause an error right so what we can do is we can remove the move keyword and color can be borrowed immutably again because the closure only holds an immutable reference to color right that means when we don't move the captured value we can then take a reference to color again so this foothold a reference to a string as you can see we print here out two times color green because we are calling this closure two times and this will take an immutable reference of this captured value all right and then we can take another reference of this string so let's see exercise 2 make it work don't use reborrow and count reborrowed don't modify assert EQ so we have over here an i32 by the way this is mutable and we have here a closure taking no arguments then as you can see it captures this variable here all right and it mutates it meaning count will then hold one and then we just print out count over here we are calling disclosure and then we are taking a reference to count meaning a reference to an i32 right and then we are again calling this ink closure the closure no longer needs to borrow mutable borrow account therefore it is possible to reborrow without an error so what is happening over here we have seen that the compiler will take the least restrictive approach so in this case it will take an so in this case the count variable here will be captured as a mutable reference right and that would be a problem because as you can see we are calling Inc and over here we call it again after you're defining an immutable reference to count so maybe you remember that you can either have one mutable reference or any number of immutable references but not both at the same time so this would be a problem so we can call here the move keyword meaning disclosure here takes ownership of this value now again because i32 implements the copy trade it means it will actually get a copy of count so count is still accessible even after this closure call right the closure will just take a copy of the value and that means we can then take an immutable reference again to count and call the closure right and over here the closure no longer needs to borrow a mutual reference to count therefore it is possible to reborrow without an error so as you can see we are here taking a mutable reference to count again because we don't use this immutable borrow over here again after this point right so this is allowed let's see and as you can see this is compiling and here you can see that count has been modified so let's see exercise 3 make it work in two ways none of them is to remove take movable away from the code so as you can see we have here initialized a variable with a heap allocated i32 integer right then over here we have a closure and we capture here this movable variable now we have seen that actually the compiler will use the least restrictive approach so in this case because we have only a print line it will take this variable here as immutable reference we just need to print it out now over here we are calling the take function as you can see the take function takes an argument of any type but it takes ownership meaning when we call the take function with an argument the argument will then lose its ownership so take function will become the owner of movable in this case right and that means we can't call disclosure two times because in this case again the compiler will try to use the least restrictive approach but in this case it's necessary that this closure over here will Implement F and once so it only can be called one time because again over here move a bell when we call this take function it will take movable and take ownership of it because it's necessary for the compiler to do that to comply with this function signature but what we can do is we say we want a reference right so again the compiler will then implement the F and trade for this for disclosure meaning it can be called two times now we will see a lot of more example of these FN trades so don't worry it just means now because we just need over here immutable references the compiler will actually capture this variable here as an immutable reference right so nothing gets moved inside this closure and movable will remain the owner of the data for comparison the following code has no error foreign so as you can see we have again a heap allocated integer and we have here a closure now as you can see we use the move keyword here and in this case disclosure will capture the movable variable only as an immutable reference because we here only print out the variable we don't need an we don't need a mutual reference and we don't need to take ownership so we can call this closure two times without any problem type in third the following foreclosures has no difference in input and return types so this is actually a function not a closure but as you can see all of them are exactly the same so we can skip the type annotations and we can even skip the curly braces if it is declared on the same line so this over here is exactly the same as writing it like that so over here we have an example closure taking one argument and just returning that argument so then V over here call the example closure with a string meaning over here this would be the argument provided and it returns a string now when you define a closure and call it with a concrete value the compiler will then infer the types of the arguments and the return type so in this case the compiler will annotate the types like that right we take an argument of type string and return the string and that means that we then can't call the closure again with another type this would cause an error okay what we have to do is to convert that to a string let's do it like that so we get back a string here and this is compiling so let's see FN F and mute FN once when taking a closure as an input parameter the closures complete type must be annotated using one of the following trades FN the closure uses the captured value by reference F and mute the closure uses the captured value by mutable reference F and once the closure uses the captured value by value basically taking ownership alright so make it work by changing the trade Bound in two ways so when a function accepts a closure as an argument we have to actually Define what will be the type of the arguments to the closure and the return type of the closure right and we over here can see that a closure implements one of these three trades all right now over here in the fn1's function we Define that the fund argument must be of type f and here we Define the trade bound so F must be a type that implements F and ones taking as argument U size and returning a Boolean value all right and inside this function over here we are just calling the provided func closure and providing its arguments so as you can see we have here a vector and we call the FN ones function with an argument of a closure as you can see we can't pass a closure as a function argument now in this case disclosure will implement the fn1 straight right basically meaning it will take ownership of the captured values and it can be only called once so it takes as argument a a type of view size right so and this is necessary here because we are comparing the provided argument 3 and 4 with the return value of the Len method right this land method is defined on vectors and it will return EU size so that over here has to be of hue size we have to Define that and all this does is we can provide disclosure an argument and it will check is for example 3 over here is it the same as the length of this vector now the problem here is that we have to change the trade bound because at the moment we are calling the funk closure passed as argument to this function two times while it implements FN once meaning it can only be called once now what we can do over here is we take FN right basically just taking an immutable reference of a captured value now the captured value in this closure here would be X right this vector acoustic because the closure captures it from the environment it is defined in and this should actually work let's see as you can see when we pass this closure to this function and we Define here the closure must implement the FN trade taking a u sizes argument and returning a bull then we are calling the closure right Funk here holds a closure so we are calling it with three in this case this would evaluate to true because the length of vac is three elements right so x dot length will return three meaning it's equal to the provided argument and four of course would return false so we are here initializing a string and over here we are defining a closure it takes an argument and it then modifies the string over here basically pushing the string that was provided in the argument then we are calling the exact function providing it this closure all right then let's see all this function does it takes a closure as an argument and then it will call the closure and it will pass it a string literal right meaning that to this string as this string literal will be pushed right so after calling this closure s should then hold hello all right and then we just print out s now what would be the appropriate trade Bound for this closure think about it we have FN FN mute and FN once so what would be the least restrictive approach it would be FN mute right because we are mutating here this string the captured value but we don't need to take ownership in order to be able to mutate it right now we have to provide the argument this would be of type string slice right we are passing here at this string literal which is string slice and then we have to provide a return type so actually this won't return anything right so we don't here have to provide a return type so let's see if this works and as you can see we have here a lifetime parameter and this is just ensuring that the past string literal here is actually outliving this function exact right which is the case because string literals remember are static lifetime they live the entire duration of the program and as you can see when we print out s it has successfully been modified so it's sufficient to use here F and mute but if we want we can even take ownership but then we have the Restriction that we can only call this closure one time right so if we try that as you can see this is working two which trade does the compiler prefer to use FN the closer uses the captured value by reference FM mute the closure uses the captured value by mutable reference fn1 stick closure uses the captured value by value on a variable by variable basis the compiler will capture variables in the least restrictive manner possible for instance consider a parameter annotated as fn1s to specify that the equation May capture T by reference by mutable reference or taking ownership but the compiler will ultimately choose based on how the captured values based on how the captured variables are used in the closure which trait to use is determined by what the closure does with captured value this is because if a move is possible then any of borrows should also be possible note that the reverse is not true if the parameter is annotated as FN then capturing variables by Mutual reference or by T is not allowed let's see number seven fill in the blank a function which takes a closure as an argument and calls it f denotes that f is a generic type parameter so as you can see we have here the function apply and it takes as an argument a closure and all it does it will then call disclosure right and we have here to define the trade Bound for the provided closure a function which takes a closure and returns an i32 so over here we have applied to three again taking a closure and we have 10 to Define here the trade bound the closure takes in i32 and returns an i32 and again this function over here will just call the closure and the difference is it will then return The Returned value from the closure so as you can see over here it just calls the closure but it doesn't return anything because here this is a statement it's ending with semicolon here we omit the semicolon meaning the return value of the closure will be the return value the function returns all right so over here we have a string knittering in noncopy type to own creates owned data from borrowed one so as you can see we take a string literal and call the two owned method now the UN now the two ohms method will convert a string slice to a string capture two variables creating by reference and Farwell by value so over here we have a closure then greetings by reference requires FN so as you can see this closure captures the greeting variable now all it does it will print it out meaning to take a an immutable reference would be sufficient so the compiler will implement the FN trade for disclosure because it is sufficient to only take an immutable reference to the captured variable all right mutation forces farewell to be captured by mutable reference now requires FN mute so as you can see we are taking Farwell and we are modifying it now this requires far well over here to to capture as immutable reference again you can see that the compiler tries always to use the list restrictive approach so then the compiler will instead implement the FN mute trade for disclosure all right because again we capture here a variable which needs to be mutated then manually calling drop forces for well to be captured by value now requires FN once so this mem drop here allows that we manually dropped a value from memory right but this actually requires that we take farewell as a value right so the closure should take ownership of this variable meaning the compiler will now implement the fn1 straight for this closure right so as you can see step by step here an immutable reference was sufficient so it just implements the FN trade here a string got mutated so it takes the captured values as f as IMM mutable reference meaning F and mute is implemented and here when a function needs to take ownership then of course the captured value must be captured as owned type meaning fn1s is implemented so that means if this closure implements the fn1 straight it can only be called once because you have inside values that capture the environment values by taking ownership Quality Function which applies to closure so we call the apply function here providing it an argument diary disclosure here right we are calling apply and providing diary now let's see this would be this function and as we've seen because Farwell here gets captured by by value meaning the closure takes ownership we have to Define here that it will be a closure that implements the FN once trait right now as you can see the closure doesn't take any argument and it doesn't return anything so we would annotate it like that so again this just defines that the generic type f must implement the FN once trade and over here double satisfies apply to three straight bound so here we have a closure taking one argument and it Returns the result of this operation right so we call the apply to three function providing it as argument disclosure and as you can see over here apply to 3 is a closure generic type f and V here Define that the type f must implement the FN trade and as you can see it takes as an argument an i32 and the return value and the return type will be i32 so let's see I take disclosure here and disclosure was passed as an argument to this function and all this function does is it will call the closure with an argument of 3. now X here will be replaced by three and the return will be 2 times 3 which would be 6 right so disclosure then returns an i32 namely 6 and as you can see because we omit here this semicolon it means that the return value of this closure will be the return value of this function so when we call this function over here the return value over here will be 6 as you can see this is all compiling move closures May still Implement FN or FN mute even though they capture variables by move this is because the trades implemented by closure type are determined by what the closure does with the captured value not how it captures them the move keyword only specifies the letter so the move keyword only specifies how the captured values are captured while the FN trades determine what the closure does with the captured values so as you can see we have here a string and we have here a closure with the move keyword meaning values will get moved inside disclosure now because over here as you can see as in this case doesn't need to be taken as value so the closure doesn't need to take ownership of the data because it will just print it out right so an immutable reference would be sufficient and that's exactly what this says so over here as you can see we are calling the exec function with this closure and when we see over here the exact function takes us an argument a closure that implements the FN ones trade all right so it will in fact take ownership of the captured value and then in the function itself it will just call the closure and Returns the return type of the closure now over here as you can see again we have a string and we have a closure even though we have the move keyword as you can see we Define here that the provided closure to exec only has to implement TF and trade so the string s here will get moved so basically this closure here takes ownership but we can still Define disclosure over here to just Implement FN because again even though we are taking ownership we are just printing out right the difference between move and the event rates is the event rates Define what the closure does with the captured values and move defines how it captures them so it would capture here by taking ownership but the FN trait only defines what are we doing with the captured value in this case you're just printing it out meaning an immutable reference would be sufficient so we can even here pass FN and it still would work fill in a blank so over here we have a string and this would be a closure that takes an argument and returns a string now what we do over here is pushing to this string the provided argument right and then what we do is we will return s meaning the string right so when we call over here this function and provided the closure then we have to implement the FN once rate and it will take as an argument a string literally let's annotate that with the lifetime parameter a and it will return a string right so this would be so this would be the trade bound we are defining here now why did I Implement here FN once or why did I Define that F over here the type of the argument must implement the fn1 straight because as you can see we are capturing s and modify it now over here it would be sufficient to use an FN mute right now again it would be sufficient to just use a mutable reference to S but again we are here returning as right we are returning this captured variable meaning we must be the owner to return something so we have to Define that F should implement the fn1 straight right because we are here returning s meaning the closure must be the owner in order to return it let's see and this is compiling input functions since closure can be used as arguments you might wonder can we use functions as arguments too and indeed we can so as you can see we have here the call me function Implement call me to make it work and over here we have a normal function just printing out something and in main here we have a closure right also just printing out something then we call the call me function here two times one time with a closure and one time with a function and that means let's see first of all we Define we want here A type f which is generic okay so we have to Define here a generic type parameter and then of course we have to define a trade bound right so in this case over here we are not mutating anything and we don't need to take ownership and in fact over here we don't even capture any variables right it will just print out something and it doesn't capture anything so in this case FN so in this case the F and rate is sufficient right and by the way they don't take any argument and they don't return anything so let's see and this will be the output so we call call me providing it to closure the closure implements CFN trade and then call me we'll just call the provided function and closure right meaning when they are called they will just print out this over here course closure first because closure has been called first let's see exercise 10 closure as return types returning a closure is much harder than you may have thought of now it's actually not that hard but you will see fill in the blank using two approaches and fix the error so as you can see we have here the create FN function and we have to Define here the return type so let's first see we have over here a variable that is declared inside the function meaning num will only live as long as this function lives right and then over here we are returning a closure notice we omit here semicolon meaning this whole closure will actually be returned by the function and when we go into main as you can see we call the create FN function then this function should return a closure meaning F and plane will hold a closure basically F and claim will look something like that right holding a closure meaning we then can call the FN plane closure with a integer all right because we have to Define here that X should be of type i32 because we here capture num which is of type i32 remember when we perform an operation both values must be of the same type now let's see we call the create FN function then we initialize the num variable and then we have here the closure that will get returned meaning num here will capture this variable and when we then call the closure over here that will get returned by create FN then we provided a value of 1 meaning X will be 1 and num will be 5. right meaning the value the output should be 16. when calling let's write it here after calling the closure itself the output should be 6. now let's see first of all we have to think about how is this num variable captured now again the compiler will use the list restrictive approach so it will just take a reference problem here is that we actually return this closure right so num actually must outlive this function otherwise when we return the closure and num gets out of scope then over here we hold a closure that refers to something that got out of scope so let's use the move keyword here meaning num gets moved into the closure so the closure will become the owner of this variable all right now again here we can use static dispatch or dynamic dispatch now I will go first with static dispatch so in this case we want to return a type that implements the FN trait right because over here we have the closure that we want to return so let's Implement that disclosure should implement the FN trait and again over here FN is sufficient because even though we have captured the num by ownership the actual closure only performs an operation so it doesn't modify num and remember move defines how we capture the closure and the FN trades Define what the closure will do with the captured value alright so FN here is sufficient and disclosure takes as an argument in i32 right because the argument and the num variable must match because we are performing an operation on them and the return type should also be i32 all right the result of this operation so let's see and this is compiling now let's actually see the output as you can see the output will be 6. now this is using static dispatch now we can also use Dynamic dispatch remember when you when dealing with trade bounds like this we then have to basically box this over here and we put this over here into a box right this would then be a trade object we are using Dynamic dispatch here so let's see and this is also working so we have implemented the return type in two approaches fill in the blank and fix the error so as you can see we have the function Factory taking one argument of type i32 over here we have a variable of type i32 and if x the provided argument is bigger than 1 then this will be returned and else if it is smaller than one disclosure will be returned so using here the static dispatch approach doesn't work okay we cannot do something like that because over here we don't know exactly which closure gets returned and as you've noticed they are identical right but in fact disclosure is different than this because these have been both declared and they are located in different memory locations all right so even though they are exactly the same the compiler can't know at compile time which of these closures will get returned because they live at different memory locations now what we can do over here is using the dynamic dispatch approach so for that again we are boxing these closures and we Define here that the return type will be a box that holds a trait object namely a trade object that implements the FN trait taking as argument and i32 this x here and returning an i32 right let's see right and we have to provide here the main function because otherwise the program won't compiled and this is compiling alright see you in the next topic so iterators will be the last topic we will cover together so let's Dive In iterator allows to perform a task on a sequence of items in turn iterators are lazy meaning they have no effect until methods are called that consume the iterator to use it up all iterators implement the iterator trade which provides the next method which gets called automatically when traversing over some data and some methods consume the iterator While others produce a new iterator from the provided iterator let's see the iterator pattern allows us to perform some tasks on a sequence of items in turn an iterator is responsible for the logic of iterating over each item and determining when the sequence has finished so over here we have a vector and then we are iterating over the elements in this vector and as you can see the variable X will hold in each iteration one element of the vector so when we print that out as you can see in each iteration it will just print out X which means X in the first iteration is 1 then 2 and then 3. in the code buff you may consider for as a simple Loop but actually it is iterating over an iterator by default the for Loop will apply the into ether to the collection and change it into an iterator as a result the following code is equivalent to the previous one so this is happening implicitly that V over here this vector or really any collection will be called with this into either method meaning this collection will be converted to an iterator right and then we Traverse over each item so let's see exercise one refactoring the following code using iterators so we have here an array holding 10 Elements which are all zero something like that okay 10 times then we have here a for loop iterating from 0 to array length where the actual length is excluded meaning from 0 to 9 right 10 times and then we just index into this array and print out the and print out the element living at the specific index so when we execute that as you can see we print out 10 times 0. now again we don't have to use this syntax we can just pass here the array itself and it will do exactly the same and we have seen that the compiler implicitly will put that into an iterator like that and as you can see this would be the exactly same thing one of the easiest ways to create an iterator is to use the range notation so over here we are initializing an empty vector right then we want to iterate here over a range and in each iteration we are just pushing n to the vector now in the end the length of this Vector should contain 100 elements right so what we can do over here is going from 0 to 100 meaning 100 is excluded going from 0 to 99 meaning the vector will then hold elements from 0 to 99. like that right 100 elements and this will compile next Method All iterators Implement a trait named iterator that is defined in the standard Library as you can see this is the iterator trade that is defined in the standard Library it has an Associated type item which basically refers to the type we are iterating over for example a vector of u8 then the item type will be u8 right and as you can see each type that implements the iterator trade will need to will implement the next method taking a mutable reference to the instance and returning an option containing the type of the associated type defined here and we can call the next method on iterators directly so over here we have a vector and we can then put that into an iterator right so this will then actually hold an iterator right and not a vector anymore so we put this collection into an iterator meaning we then can use the next method that is implemented for the iterator type and that is actually exactly what is happening when you are doing a for Loop for example in the back the rascompiler will just call next all the time until it reaches a point where there is a nonreturn because remember this next method will return an option type so when we put that into an iterator and call next we will get a sum and the first element right then sum and two and as you can see we don't have any more elements so it will return Norm right this is the option type and we have covered that and when we put a collection into an iterator it should be mutable right so the next method takes a mutable reference we have seen so we have to make it mutable all right into iter eater and iter mute in the previous section we have mentioned that 4 will apply the into ether to the collection and change it into a iterator however this is not the only way to convert collections into iterators into either eater and intermute all of them can convert a collection into an iterator but in different ways so into ether consumes The Collection once the collection has been consumed it is no longer available for reuse because its ownership has been moved within the loop ether dispers each element of the collection through each iteration thus leaving the collection untouched and available for reuse after the loop and it remute this mutably borrows each element of the collection allowing for the collection to be modified in place so as you can see we have here a vector then we Loop over this Vector here right and all we do here is actually printing out each of the elements now we have seen that implicitly the compiler will call here into iter meaning the iterator will become the owner of this data right so we can't reuse these are after we have put it into this iterator but there is not a solution we can just use either here because it's sufficient that we have a mutable because it's sufficient here that we have an immutable reference right we just want to print it out we don't need to mutate anything or anything else we only need read only data right so let's see and as you can see we then iterate over each element printing it this over here and then we can reuse the collection over here so ownership hasn't been transferred into this iterator five fill in the blank so over here we have a vector with string literals okay and then over here we are iterating over the elements in this vector now as you can see we are here matching the element and if it is immutable reference to the string literal fairies then we will actually modify the elements that we are iterating at this exact moment to this over here if it is anything else then it will be replaced by hello right so in the first iteration name will hold a string literal this over here then we match this and in this case this arm will match meaning we assign string literal hello to this element right so instead of Pop we would then have hello in the first index right so as you can see we are mutating meaning we can here use either mute right we want to take mutable references from this vector but as you can see over here we are again using these names Vector meaning we can't take ownership so let's see and this is compiling and as you can see the first two elements got replaced by hello and the last one ferries has been matched here right name holds a mutable reference to the string slice Ferries and that's why this will get returned meaning it will be assigned to this element let's see exercise 6 fill in the blank as you can see we have here a vector now over here we want to put this Vector into an iterator right now before we do that as you can see this is the vector in the beginning and this is how it should look like in the end so we want to mutate the first element so in this case we take it as mutable references calling The Ether mute method right so we take from here mutable references of the elements in this vector then over here we can call the next method which will then give us back an option type of the first element right so we pet our match here some with the inner value and then what we can do because we get here a new to the reference meaning we can dereference it and assign it a new value like that so we get no output let's actually see the elements as you can see we changed the first element we have mutated it using ether mute right getting bad getting back immutable reference to the elements creating our own iterator we can not only create iterators from collections type but also can create iterators by implementing the iterator trade on our own types so as you can see we have here a custom type counter which has one field and we Implement here the associated function new basically just creating an instance and then over here we implement the iterator trade for counter right so first of all we have to give the associated type a concrete type in this case u32 right basically the type this field is holding then we implement the next method as you can see next takes a mutable reference to the instance and it returns an option that holds a type of the associated item here right it would be u32 in this case so if self.count is less than 5 then we increment the count field here and we return the actual count otherwise we return none so if self to account is bigger than 5 then it returns none so as you can see we are then creating a new instance of this counter type using the new Associated function and then as you can see when we call the next method on it right because we can do that because we have implemented the iterator trade for our custom type so when we do that we just get back T value of count as you can see when calling next then over here it checks is the self to count field less than five in this case it is right we didn't increment it so far so it should hold zero and in that case it will increment it by one right the count field over here gets incremented by one and then it returns it and of course packing it into a sum because we return here an option type so that means we get one in the next iteration we get 2 3 4 5 and then as you can see the count field holds a value of 5 meaning this won't get meaning this would evaluate to false and this will get executed right so we will get back a non and over here we have Fibonacci so the Fibonacci sequence starts at zero then one then zero plus one is one then one plus one is two then one plus two is three two plus three is five five plus three is eight and so on right and as you can see we have here distract Fibonacci that has a current field and a next field so as you can see current for example would hold zero and next would hold one and as you can see we are implementing the iterator for Fibonacci so we Define here the return type to be u32 right or basically the type of the items we are iterating over so these both of these fields hold u32 and over here we have a function Fibonacci which just returns an instance of the Fibonacci struct with current holding 0 and next holding one so notice something here when we call next we actually want to return someone and not some zero so this is important but let's now implement the next method so we have seen that it will return option type holding self item write the type that is defined in the associated type item and then over here I will create a new variable forward and this would then be self dot current plus cells dot next right because so forward in this example would be zero plus one right this would equal one so we can then to go one step forward we want to go like this and then like this right we can assign to self current self next meaning in the next iteration the current field will hold one right and self.next will hold forward right self to current plus self dot next meaning in the next iteration next we'll hold one so we will be at this point right and then all we need to do is we wrap it in sum because again we return an option and we return the current a field over here let's see methods that consume the iterator the iterator trade has a number of methods with default implementations provided by the standard Library consuming adapters some of these methods called the method next we use up the iterator so they are called consuming adapters so over here we have a vector and we put that into an iter notice we take here the iter method meaning it will just take immutable references to the elements and then we call on this iterator this sum method the sum method will take the ownership of the iterator and iterates through the items by repeatedly calling next method right so all this sum method does it will just add together all the elements in the vector notice sum will take ownership of this iterator meaning we can't use V1 eater again right so in this case the total will be six now I can't edit here let's see it in the playground so we have here a vector and then we put it into an iterator and then we call the sum method on the iterator meaning this should then hold i32 and the value should be 6 right just adding all of these together now that means we can't use V1 either again here this is not possible because it is some method will take ownership of the V1 eater variable let's see as you can see this is compiling let's actually print out the result as you can see we would have six collect other than converting a collection into an iterator we can also collect the result values into a collection collect will consume the iterator so over here we have an array which holds two tuples right and each Tuple has as and each Tuple has a string literal and an i32 right then we take this names array here put it into an iterator notice here into either meaning we take ownership of these elements and then we collect meaning we collect it into another collection which has to be annotated here meaning we will then create a hash map with string literals as keys and i32 values right then we print it out here and over here we have a vector of i32 types and we call The Ether method over here meaning we just take references to this vector and then over here we call collect meaning it will get collected into an iterator right because we want here V2 meaning and then we annotate here that we want a vector of i32 because as you can see V2 should hold a vector with these elements let's see and actually over here we would have references of i32s right because again ether here takes references of these elements meaning they would not equate we want a vector of I 32 elements meaning we can call the input ether and that means ownership of these elements will be transferred to V2 and this would be the output of the print line over here we are printing here out the hash map we have converted iterator adapters methods allowing you to change one iterator into another iterator are known as iterator adapters you can chain multiple iterator adapters to perform complex actions in a readable way but because all iterators are lazy you have to call one of the consuming adapters to get results from calls to iterator adapters so over here fill in the blanks we have a vector and we iterate over the elements just taking immutable references alright then over here you can see we want to modify the elements inside this Vector to look something like that basically just incrementing each element now we can use here map to do that right Now map will create another iterator it will take ownership of this iterator here and it will then create another iterator right but with the modified elements and then we can call here collect to actually put it into a collection meaning this Vector over here let's see all right this is compiling I guess this would be i32 so we have taken it from this vector so this is compiling let's actually output as you can see we have modified the elements but of course V1 is still accessible and that is because we have called here the eater method meaning we just take immutable references of the elements in this vector meaning the ownership will remain at V1 so we have now reached the end of this course and if you have made it this far then your dedication to this language is really impressive and this is only the beginning of your journey I hope this course was helpful don't forget to split the word about free software and I'm out
