With timestamps:

00:00 - if you're interested in blockchain
00:01 - development this in-depth course will
00:03 - teach you about the tasos ecosystem and
00:06 - how to develop distributed applications
00:08 - for it the only prerequisite for it is a
00:11 - little python knowledge this course was
00:13 - made possible through a grant from the
00:15 - tasos foundation back in 2022 in this
00:18 - module we will do a quick overview of
00:20 - the different applications the
00:21 - blockchain like tesos already makes
00:23 - possible the first type of application
00:26 - is to help the building of communities
00:28 - around brands or teams and to make it
00:30 - possible to own an internal and unique
00:33 - piece of History nfts make it possible
00:36 - for fans or customers to own and collect
00:39 - a token specific to their favorite team
00:41 - or to their favorite brand then
00:44 - marketplaces exchanges or Dows make it
00:47 - possible to build communities around
00:49 - them and help give fans a sense of
00:52 - belonging tesos is used for this in all
00:55 - kinds of fields for example fashion
00:57 - soccer Formula 1 Esports
01:00 - or even Spring Water another application
01:03 - of tesos is in the field of games where
01:05 - it can be used to add new features that
01:08 - help extend the life of games and
01:10 - provide a better experience for gamers
01:13 - it can be used to eternally preserve a
01:15 - player's achievements it can also be
01:17 - used to create multi-game challenges and
01:20 - it also lets users collect and trade in
01:22 - game assets tesos is also used a lot in
01:25 - the field of art it helps give artists A
01:28 - much wider and International audience
01:31 - and it brings new ways for artists to
01:33 - make a living thanks to direct sales or
01:36 - royalties it also enables the production
01:39 - and sale of new forms of art such as
01:42 - generative art a very strong field for
01:45 - blockchains is decentralized finance
01:47 - that brings new Financial products and
01:50 - make them available to anyone some
01:52 - examples on tesos include projects like
01:54 - lug a stable coin ped to the Euro or
01:58 - real estate tokenization projects
02:00 - that make it easy to own a piece of a
02:02 - property and decentralized lending
02:04 - markets that make it easy to borrow
02:07 - different types of tokens tesos can also
02:09 - help people develop initiatives around
02:12 - causes for example around protecting the
02:15 - environment it can be used to raise
02:17 - funds for nature preservation and to
02:19 - build communities around nature
02:21 - awareness these are only a few examples
02:24 - of what's possible with tasos and it is
02:26 - only the beginning by following this
02:28 - course and learning to develop your own
02:30 - smart contracts you will be able to
02:32 - invent your own applications in one of
02:34 - these fields or in other fields in this
02:36 - short module we'll do a quick overview
02:39 - of what you will learn during this
02:41 - course we'll start by showing you the
02:43 - different key components of a blockchain
02:46 - and it's ecosystem so we'll talk about
02:48 - accounts about wallets about blogs Etc
02:51 - so that you can understand all of these
02:53 - different elements and their names then
02:56 - you will practice by creating an account
02:58 - and performing a fut transactions
03:00 - calling smart contracts Etc in The Next
03:03 - Step we'll have a video that shows you
03:05 - all the different steps that a
03:06 - transaction takes from the moment you
03:08 - decide for example to purchase an nft to
03:11 - the moment that this transaction is
03:13 - final on the blockchain so that will
03:16 - help you understand what really happens
03:18 - internally and how things work in the
03:21 - blockchain then we'll focus on the heart
03:24 - of this course which is for you to learn
03:26 - to develop your own smart contracts
03:28 - using the smart P language one of the
03:31 - several languages that are available to
03:33 - write smart contracts on tesos while you
03:35 - learn to write your smart contracts you
03:37 - will also learn how to develop your own
03:39 - test scenarios for your smart contract
03:41 - to make sure that everything works and
03:44 - to avoid the main bugs you will practice
03:46 - all this on a variety of concrete
03:48 - exercises an example this will be a very
03:50 - practice oriented training and we ask
03:53 - you to play along and really try to
03:55 - solve each exercise because we really
03:56 - believe that this is by practicing that
03:59 - you really learn the best so you will
04:02 - learn smart contract Concepts from the
04:04 - very basic types like basic numbers and
04:07 - strings all the way to very Advanced
04:09 - smart contract Concepts such as inter
04:12 - contract calls or upgradable contracts
04:15 - and you'll realize that smart contracts
04:18 - are usually small projects so it's not
04:21 - very hard to write smart contracts but
04:23 - the hard part is to avoid flaws so to
04:26 - help you with that we will spend quite a
04:27 - bit of time teaching you how to detect
04:29 - protect flaws how to avoid them and how
04:32 - to fix them because a flaw in a smart
04:35 - contract can mean potentially losing
04:38 - Millions you will be creating smart
04:41 - contracts in all kinds of areas you will
04:43 - create nft smart contract marketplaces
04:46 - auctions yield farming smart contracts
04:48 - you will learn to build oracles
04:50 - decentralized autonomous organizations
04:52 - or will play with Randomness through a
04:54 - lottery smart contract then you will
04:57 - work on decentralized finance contracts
04:59 - so will talk about how flash loans work
05:01 - how fungible tokens can be created and
05:04 - how to exchange currencies using
05:07 - liquidity pools and take advantage of
05:09 - Arbitrage opportunities
05:11 - Etc so this will give you a good idea of
05:14 - what real smart contracts look like and
05:17 - put you on a path to write your own
05:19 - there are very few prerequisites for
05:21 - this course and what you really need is
05:24 - some basic experience with programming
05:28 - we don't expect you to be a very good
05:30 - developer but you do need some
05:32 - programming experience to be able to
05:33 - follow this course what you don't need
05:36 - is specific knowledge about python it
05:39 - may be helpful if you already know
05:40 - python because smart py is based on
05:43 - python but you'll be okay if you're not
05:45 - familiar with
05:47 - python and you also don't need prior
05:49 - blockchain experience we'll teach you
05:51 - the basics that you will need for this
05:53 - course in this module will give an
05:56 - overview of tesos and its different
06:00 - components and get an idea of what a
06:02 - blockchain is tesos is a public
06:05 - open-source blockchain protocol this
06:08 - means anybody can read the code of all
06:10 - the elements of the blockchain and
06:12 - anybody can access the data of the
06:15 - blockchain and even join the
06:17 - blockchain by setting up their own node
06:20 - we also say that tesos is a smart
06:22 - contracts platform this means it's a
06:24 - kind of blockchain where you can deploy
06:27 - and execute smart contracts when one of
06:29 - the key aspects of tesos is that it
06:31 - relies on an energy efficient proof of
06:34 - stake consensus algorithm that makes it
06:37 - very environmentally friendly compared
06:39 - to some other
06:40 - blockchains tesos has a self amending
06:43 - governance that makes it easy for the
06:45 - protocol to evolve without the need for
06:47 - hard
06:48 - Forks Community itself decides through
06:52 - rules defined by the protocol on
06:54 - evolutions of the protocols that we call
06:56 - amendments tesos has been designed to
06:58 - facilate code safety through a number of
07:01 - design choices and application of formal
07:04 - verification to the
07:06 - protocol so let's talk quickly about the
07:09 - history of tizzel when creating tizzel
07:12 - the creators wanted to address the
07:14 - weakness of the first blockchains there
07:17 - was a weakness in the governance the way
07:19 - that blockchain could evolve and how the
07:22 - community to decide and how to evolve
07:24 - the protocol it appears that the first
07:27 - blockchains didn't evolve as much as
07:29 - they could because they liked a
07:31 - governance
07:33 - mechanism another weakness was the high
07:35 - energy consumption of blockchains due to
07:38 - the use of proof of work as a consensus
07:41 - algorithm finally there were a number of
07:44 - security issues with existing
07:46 - blockchains that the creators of tesos
07:49 - wanted to address the first step in the
07:52 - creation of tesos was the publication of
07:54 - a white paper in 2014 that described its
07:58 - principles from 2014 to 2017 a prototype
08:03 - of the tsos protocol was developed then
08:05 - in July
08:07 - 2017 232 million USD were raised in
08:11 - Bitcoins and E to help develop the
08:13 - ecosystem and the tesos main net was
08:16 - launched in July
08:18 - 2018 after it's launched between 2018
08:22 - and so far
08:24 - 20123 the tesos protocol was upgraded 14
08:27 - times through the on chain governance
08:30 - system so when we talk about tesos we're
08:33 - talking about the tesos blockchain or
08:35 - the tesos network if we talk about the
08:38 - underlying cryptocurrency we will talk
08:40 - about the tees and when you talk about
08:42 - mounts you talk about how many Tes you
08:45 - have or for example Alice transfers
08:48 - tentes to Bob the ticker used when you
08:51 - want to check the conversion rates
08:54 - between different cryptocurrencies on
08:56 - exchanges is xtz and T has a logo that
09:00 - you can see here now we will describe
09:03 - the different key elements of tesos
09:07 - we'll talk about accounts transactions
09:10 - smart contracts the blockchain itself
09:12 - and its blocks we'll also talk about
09:15 - wallets nodes and
09:18 - Bakers tesos is based on a system of
09:21 - accounts where every account has its own
09:24 - balance in t but there are two types of
09:27 - accounts on tesos implicit accounts are
09:30 - the accounts directly held by users they
09:33 - have addresses that start with TZ then a
09:36 - digit typically tz1 but also tz2 or tz3
09:41 - are possible then we have originated
09:43 - accounts those are smart contracts that
09:46 - are a special kind of account that also
09:48 - holds data and code originated account
09:51 - addresses start with KT usually kt1
09:55 - we'll talk a lot about transactions a
09:57 - transaction is a transfer of TZ from one
10:01 - account to another or it can be a call
10:03 - to a Smart contract and it can be both
10:06 - you can call a smart contract while
10:07 - transferring TZ to the account of that
10:10 - smart contract and transactions are
10:13 - digitally signed by the caller to
10:15 - authenticate that they are the ones
10:17 - really wanting to do that transaction
10:20 - but transactions are one of many types
10:22 - of operations that can be applied on the
10:26 - blockchain we can have other types of
10:28 - operations such as creating accounts
10:30 - deploying smart contracts voting for an
10:33 - amendment to the protocol Etc smart
10:36 - contracts are a special type of account
10:39 - that like every account has a balance of
10:41 - TZ and an address but it also has some
10:45 - data that we call the storage of this
10:47 - smart contract and it has some
10:50 - executable code so a piece of code in
10:52 - the melon language that is executed
10:55 - whenever someone calls the smart
10:57 - contract so when you call a smart
10:59 - contract you may send some test to the
11:01 - smart contract and pass parameters for
11:03 - the code and the code will be executed
11:06 - and it may change the data the storage
11:08 - of the smart contract or generate new
11:11 - transactions and new operations that
11:13 - will be executed after the end of the
11:16 - execution once you deploy a smart
11:19 - contract its code is immutable you
11:21 - cannot change it anymore so that people
11:24 - who call the smart contract can know for
11:26 - sure what code will be executed we can
11:29 - take a small example of a smart contract
11:32 - let's imagine that we have a contract
11:34 - that tracks the ownership of tickets for
11:36 - a conert each ticket will have an owner
11:39 - and the owner of a ticket can transfer
11:42 - it to someone else or change the
11:43 - ownership of a ticket so in the storage
11:46 - we will store all of the different
11:48 - tickets and for each ticket we could
11:50 - have a row a seat number and the address
11:54 - of the current owner and then in the
11:56 - code of the smart contract you could
11:58 - have a entry point a function that can
12:01 - update the owner of a given ticket so
12:04 - you indicate the row the seat and what
12:07 - new owner you want then we will fetch
12:09 - the corresponding data from the storage
12:12 - verify that the caller is actually the
12:14 - current owner of the ticket and then
12:17 - replace this owner with a new owner the
12:20 - tesos blockchain stores its data in a
12:23 - chain of blocks of data so that's why
12:26 - you call it a blockchain and the
12:28 - blockchain is is maintained by a
12:30 - decentralized network of nodes every 15
12:33 - seconds at the moment at least a new
12:36 - block is added to the chain and each
12:39 - block will contain a sequence of
12:41 - operations and since we have a sequence
12:44 - of blocks the blockchain a blockchain is
12:46 - basically a very long sequence of
12:49 - operations split into blocks that are
12:52 - generated every 15 seconds and the state
12:55 - of the blockchain is the result of the
12:57 - execution of all the
12:59 - operations for example let's say that
13:02 - after the block number
13:04 - 1427 Bob's account has a balance of a
13:07 - th000 t if in Block 1428 Alice adds the
13:11 - transaction Alice transfers 100 T to Bob
13:15 - and this transaction is validated then
13:17 - in the state of the tizel blockchain
13:19 - after block
13:21 - 1428 Bob's balance will be 1100 T in the
13:26 - blog we have two parts we have the
13:27 - header that that contains the block
13:30 - number or the level basically how many
13:33 - blocks we have since the beginning of
13:34 - the blockchain then we have the hash of
13:37 - the previous block a timestamp and we
13:40 - also have the hash of all of the data in
13:42 - the block and the data consists in the
13:44 - list of all the operations of the Block
13:47 - in a certain order the fact that we
13:49 - store the hash of the previous block
13:51 - means that we are creating a chain of
13:53 - block each block references the previous
13:56 - Block in the chain that's why we call it
13:58 - the blockchain and you can check what a
14:01 - block looks like at this address that
14:04 - uses a block Explorer to analyze the
14:07 - block that has this number this level so
14:10 - here we can see this block we can even
14:13 - move to the next block or the previous
14:15 - block we can see the Tim stamp Etc and
14:19 - most of all we can see all the
14:20 - operations in that block so different
14:22 - transactions and in particular smart
14:24 - contract calls to interact with the
14:27 - blockchain we will use a wallet it's a
14:30 - piece of software or Hardware device
14:33 - that keeps your private Keys safe we saw
14:36 - earlier that transactions need to be
14:38 - signed so to sign your transaction you
14:41 - will need your private key that you will
14:43 - sign using your wallet so whenever you
14:46 - want to transfer some TZ or call a smart
14:48 - contract you will need to create a
14:50 - transaction and then sign it with your
14:52 - wallet the wallet doesn't store your TZ
14:56 - or any other asset it only stores the
14:58 - key keys to control these assets if you
15:01 - ever lose your private Keys you
15:04 - basically lose all access to your assets
15:07 - so make sure you keep your private Keys
15:09 - really safe as an example if we have
15:12 - this transaction transfer 100 test from
15:14 - Alice to Bob this transaction has to be
15:16 - signed by Alice using her wallet for it
15:19 - to be valid on tsos we have a number of
15:23 - wallets that you can use for example
15:25 - Temple kukai Umami and more under the
15:29 - hood the tesos network consists of
15:31 - hundreds of nodes run by the community
15:34 - each node is a computer that runs the
15:37 - tesos protocol and communicates with
15:39 - other nodes together these nodes form a
15:42 - peer-to-peer decentralized Network that
15:44 - we call the gossip Network these nodes
15:47 - share the responsibility of maintaining
15:49 - the blockchain and all the operations
15:52 - and blocks are propagated through this
15:54 - network of nodes and when your wallet
15:57 - interacts with a blockchain in practice
15:59 - is communicates with one of the nodes in
16:01 - this network all of the nodes execute
16:05 - every single transaction in every block
16:08 - and store the associated mate data
16:10 - update the state but only one entity can
16:14 - create the next block and decide which
16:16 - operations to include but as we want to
16:19 - keep tesos decentralized the
16:21 - responsibility of creating the next
16:23 - block has to be shared so the hard part
16:26 - of the design of a blockchain is to
16:28 - decide who gets to create this next
16:31 - block and do it in a fair way and then
16:34 - making sure that this block is valid and
16:36 - legitimate on tesos the entities that
16:39 - create new blocks are called Bakers
16:42 - anyone as long as they have at least
16:44 - 6,000 T at the moment can volunteer to
16:47 - be a baker and the baker for each block
16:50 - is randomly
16:51 - selected to make it fair the chance to
16:54 - be selected is proportional to the
16:56 - amount they staged that's what we call
16:59 - proof of stake and proof of stake is
17:01 - eco-friendly because we just need to
17:03 - pick randomly proportionally to some
17:06 - value this cost a lot less energy than
17:09 - proof of work where you need to do a lot
17:10 - of computations to determine who the
17:13 - next minor will be for example as it's
17:16 - done on Bitcoin in proof of work the
17:18 - chance of selection is actually
17:20 - proportional to how much energy and
17:22 - computational resources you waste when a
17:25 - new block is proposed by a baker it has
17:28 - to be validated
17:29 - so we have to check that it includes the
17:31 - correct hashes of the pre block and its
17:33 - own that all operations have a valid
17:36 - signature that the execution of
17:38 - transactions don't fail due to some
17:40 - limits or errors that the maximum size
17:43 - of a block is not exceeded Etc a block
17:47 - is officially added to the chain once it
17:50 - receives enough attestations from other
17:52 - Bakers the baker of a block is rewarded
17:56 - they receive 10 new T and and sometimes
17:59 - a bonus they also receive the fees of
18:03 - all the transactions in the block each
18:05 - transaction comes with some fees that
18:08 - the user can change a kind of a tip that
18:11 - is transferred to the Baker and to
18:13 - maximize their gains Bakers select among
18:16 - all of the transactions the most
18:18 - profitable ones so the ones that have
18:20 - the highest fees compared to their
18:22 - execution time if you're not a baker you
18:25 - can delegate your test to a baker and
18:28 - get a share of the rewards that the
18:30 - baker gets and there's also some test
18:33 - that I use as rewards for the bakers
18:36 - that attest the validity of the blocks
18:40 - if a baker propagates fake data in
18:42 - particular if a baker creates two blocks
18:44 - instead of one when it's their turn they
18:47 - lose some of their stake we say that
18:50 - their stake is slashed but if you
18:53 - delicated your test to a baker you have
18:55 - no risk of being slashed you cannot be
18:58 - punished so this was a key overview of
19:00 - the different elements of tzel we talked
19:02 - about accounts that can be either user
19:04 - accounts or smart contract accounts we
19:07 - described what transactions are our
19:10 - transfer of Tes or calls to Smart
19:12 - contracts we described what a smart
19:15 - contract is a special type of account
19:18 - with not only a balance but also storage
19:21 - and some code that can be executed we
19:24 - describe the blockchain as a sequence of
19:27 - operations grouped in into blocks we
19:30 - talked about interacting with the
19:33 - blockchain through a wallet that keeps
19:35 - your private Keys safe and is used to
19:37 - sign all the transactions you want to
19:39 - send to the blockchain we describe the
19:42 - blockchain itself as a peer-to-peer
19:44 - network of nodes that each execute the
19:47 - tesos protocol and execute every single
19:50 - transaction in the blocks they receive
19:53 - and finally we talked about bakers that
19:55 - share the responsibility of creating new
19:58 - blocks in this video you will learn how
20:00 - to set up your own Wallet create your
20:03 - private keys and then with that you will
20:05 - then be able to get some test create and
20:09 - sign transactions call Smart contracts
20:12 - Etc so using a wallet means creating an
20:15 - account and the first step to create an
20:18 - account is to generate a pair of keys
20:21 - most importantly you will generate your
20:23 - private key that is what you will use to
20:26 - digitally signed all of your
20:28 - transactions and prove your identity a
20:30 - private key has a corresponding public
20:33 - key that you make available to everyone
20:35 - so that they can verify your signatures
20:38 - and verify your identity so you sign
20:41 - your transactions with your private key
20:44 - and other people or software can verify
20:47 - that the transactions are signed by you
20:49 - by matching the signature with your
20:52 - public key so a wallet can generate a
20:55 - private key as a random sequence of
20:57 - bytes if it's extremely important that
20:59 - you never lose your private key but as a
21:02 - sequence of bites is hard to write down
21:04 - or remember the wallet will first
21:07 - generate a seed phrase It's a sequence
21:09 - of random English words that represent a
21:12 - random value but that are easy for you
21:15 - to write down and keep safely for
21:17 - example on a piece of paper then the
21:20 - wallet uses this sequence as a seed for
21:23 - the random generator to produce the
21:25 - private key it then stores this private
21:28 - key local
21:29 - encrypt it using a password of your
21:31 - choice and will'll then use it to sign
21:34 - your
21:35 - transactions on tles there are a number
21:37 - of different wallets available some of
21:39 - the main ones include Kai Umami temple
21:44 - in this presentation we'll be using the
21:46 - kai wallet it is available on kai. apppp
21:50 - but for our test we'll be using the
21:53 - ghostnet test Network so we will be
21:56 - using ghost net. kai. so the Tes will
21:59 - will manipulate with this wallet will be
22:02 - fake TZ in a sense not TZ from the main
22:05 - Network so if you go to ghost net. ci.
22:09 - apppp this is what you will see as the
22:11 - wallet will be directly in your browser
22:15 - you have two ways to create a wallet you
22:18 - can collect with one of several social
22:20 - networks for example Google Facebook
22:23 - Reddit Etc in which case it will use
22:27 - your o o cred credentials as a way to
22:30 - safeguard your keys that's the easiest
22:33 - way to do it if you simply connect for
22:36 - example click continue with Google your
22:38 - wallet will be instantly created and
22:41 - available we will use a way that is
22:44 - slightly longer you click on create new
22:46 - wallet here and then it will generate
22:49 - this seat phrase composed of a sequence
22:52 - of English word and the idea here is
22:55 - that you should write down these words
22:58 - on a piece of paper to keep them safe I
23:01 - avoid storing them in a file because
23:04 - this file could be accessed if anyone
23:06 - ever gets access to your computer so
23:09 - it's safer to Simply use a piece of
23:11 - paper and keep that piece of paper safe
23:13 - and make maybe copies of it that you
23:15 - keep safely because if you ever lose
23:17 - them then you're at risk of completely
23:19 - losing access to your private key
23:22 - therefore to your assets once you have
23:25 - written down these words you can click
23:27 - next and then it will check did you
23:30 - indeed save these words and it will tell
23:32 - you okay did you write down the second
23:35 - work the one that was between traffic
23:37 - and sustain and so on our piece of paper
23:40 - we see yes indeed we had the word Arrow
23:43 - then it asks what's the third word one
23:46 - that was between arrow and midnight and
23:48 - so that was
23:49 - sustain Etc then we have
23:53 - pause and we're done so it checked that
23:57 - we really did store or passphrase then
24:01 - it asks you to provide a password so
24:03 - that they can store an encrypted version
24:06 - of your key store file so that's a
24:08 - password that you remember so that your
24:10 - wallet can locally save your private key
24:13 - and public keyan Etc and then decrypt it
24:16 - anytime you provide your password so
24:18 - whenever you will need to sign a
24:20 - transaction it will use your password to
24:23 - decrypt the key and then sign the
24:25 - transaction with the key so you input a
24:27 - password
24:28 - confirm your password and then click
24:33 - next then your wallet is ready and you
24:36 - have here your public account address so
24:39 - that starts with tz1 and then
24:41 - something's based on the hash of your
24:43 - public key you can also download the
24:46 - encrypted key store file so that you can
24:49 - import it into this wallet or another
24:51 - wallet and it will be as safe as the
24:53 - password you pick to encrypt it so here
24:56 - you copy your public account address we
24:59 - download our file and then we can now
25:02 - open our
25:03 - wallet in the wallet we can see the
25:06 - balance of our account we can see our
25:09 - address here and of course we have no
25:11 - activity because we just created the
25:13 - account for real wallet on the main net
25:18 - you could get TZ using one of several
25:21 - providers and for example convert from
25:24 - dollars or euros and buy some Tes and
25:26 - then have them into your account through
25:30 - coinbase or other places for a test
25:33 - account on ghostnet there's an easier
25:35 - way to get some test you go to this
25:39 - website that we call a faucet and from
25:42 - this website you will be able to request
25:44 - some test so let's give it a try so this
25:47 - is a tesos costet foret that is a
25:50 - website that can give free fake Tes on a
25:54 - ghostnet account you can paste your
25:57 - address here
25:58 - and then select how many Tes you would
26:01 - like let's say A th000 tes and then you
26:04 - can request you need to wait a bit the
26:07 - more test you request the longer the
26:09 - competition will be because the
26:10 - challenge needs to be solved some proof
26:12 - of work and if you request a th000 t it
26:15 - can take a while so we'll maybe request
26:17 - a bit less let's say we only need 200
26:23 - T and after a couple minutes all the
26:26 - proof of cor challenges are solved and
26:28 - then 200 T are transferred to our
26:30 - account another way would have been to
26:33 - connect our wallet to automatically
26:35 - obtain the tz1 address but that would be
26:37 - the same result then we can
26:41 - check on the Block explorer that indeed
26:45 - our tz1 address has 200 T we can also go
26:49 - back to our wallet and we can see here
26:53 - that the 200 Tes are there after reling
26:55 - the page and we can see that we received
26:57 - them from this
26:58 - address it may take a little bit of time
27:01 - before we see it because we need a
27:03 - couple blocks to be validated but
27:05 - eventually we see the 200 test there
27:08 - from this you can already sign some
27:10 - transactions for example if you want to
27:12 - try to send a few test back to the facet
27:16 - we can take this address that's the
27:18 - address that sent us some test and you
27:20 - can send some Tes let's say two Tes to
27:27 - the address which just
27:29 - copied then we can preview the
27:31 - transaction we can see that there's a
27:33 - fee of 369 micr Tes and we can use our
27:38 - password to decrit our private key and
27:41 - sign a transaction and send it to the
27:44 - blockchain so we
27:46 - confirm and we can now see this
27:49 - transaction has been confirmed and we
27:51 - now have almost 198
27:54 - T again you can see the same thing in
27:57 - the block chain Explorer and we see this
28:01 - transaction where we send two Tes to
28:03 - this address and that's said your wallet
28:06 - is set up in this module I will give you
28:08 - an overview of the tesos layer one
28:10 - architecture and we will do that by
28:12 - following the path of a transaction from
28:15 - the moment it is created to the moment
28:17 - it is integrated forever in the tesos
28:21 - blockchain imagine you want to buy an
28:23 - nft a unique digital artwork on tesos
28:27 - The Cutting Edge blockchain platform you
28:30 - use adap a decentralized application
28:32 - that lets you browse and bid for nfts
28:35 - when you find the one you love you click
28:37 - on the buy button but what happens next
28:41 - how does your transaction get processed
28:44 - and recorded on the blockchain let's
28:46 - take a look behind the scenes tesos is
28:49 - powered by a network of nodes computers
28:52 - that run the tesos software and
28:54 - communicate with each other through a
28:56 - peer-to-peer Network these modes are
28:58 - operated by the tesos community a
29:00 - diverse and Global Group of enthusiasts
29:03 - developers and organizations your
29:05 - transaction will travel through this
29:07 - network undergo various checks and
29:09 - validations and eventually be included
29:11 - in a block by a baker a special node
29:14 - that creates new blocks once your block
29:17 - is added to the tsos blockchain your
29:19 - transaction is final and irreversible
29:22 - but how does this work exactly the T you
29:25 - use an nft Marketplace has a user
29:28 - interface a web page that you can access
29:31 - from your browser it lets you interact
29:33 - with the blockchain and the smart
29:34 - contract the programs that run on
29:36 - blockchain and Define the rules and
29:38 - logic of the nft marketplace when you
29:41 - click on the buy button the DB creates a
29:43 - transaction a message that tells the
29:45 - smart contract to transfer the nft to
29:48 - you and the TZ the native cryptocurrency
29:51 - of tezos to the seller the transaction
29:54 - is sent to your wallet a piece of
29:57 - software or a Hardware device that
29:59 - connects to your browser and the
30:00 - blockchain your wallet securely stores
30:02 - your private Keys the secret codes that
30:05 - prove your identity and ownership of
30:07 - your T and nfts your wallet is your
30:10 - gateway to the blockchain and the
30:11 - protector of your assets before asking
30:14 - you to confirm the transaction the
30:16 - wallet needs to test it check that it's
30:18 - valid and figure out how much it will
30:20 - cost you to do that it sends the
30:23 - transaction to one of the nodes of the
30:26 - network and asks this node to simulate
30:29 - what would happen if you sent it for
30:31 - real this node has a copy of the
30:33 - blockchain the history of all the
30:35 - transactions that have ever happened on
30:38 - tesos it also has the context the
30:41 - current state of the blockchain which
30:42 - includes the balance of every account
30:45 - and the code and data of every smart
30:47 - contract the node simulates your
30:49 - transaction by running the code of the
30:51 - corresponding smart contract it checks
30:53 - that the code doesn't cause errors for
30:55 - example that the nft you want to buy is
30:57 - indeed for sale
30:58 - at the price you indicate and that you
31:00 - have enough Tes on your account to pay
31:02 - for it it then computes the amount of
31:04 - resources running this code will consume
31:07 - on one side the amount of gas an
31:09 - estimation of how much Computing time
31:11 - your transaction requires on the other
31:13 - side the amount of storage how much
31:15 - extra data will need to be stored the
31:18 - node computes the cost for this gas and
31:20 - storage adds some fees then calculates
31:23 - how much you will need to spend to get a
31:24 - baker to add your transaction to a block
31:27 - all the this information like a quote
31:29 - for your order is sent back to the
31:32 - wallet the wallet then displays that
31:34 - information for you to check and lets
31:36 - you decide how much extra fee you want
31:38 - to add this extra fee is like a tip you
31:41 - pay to the baker to increase the chances
31:44 - that a baker will pick your transaction
31:46 - and add it to the
31:47 - blockchain once you check everything and
31:50 - agree to sign the transaction the wallet
31:52 - uses your secret private key to
31:53 - digitally sign your transaction using
31:56 - cryptography then sends it to a node
31:59 - from then on all you can do is wait and
32:01 - see if your transaction gets added to
32:03 - the chain the node sends a hash of the
32:05 - operation back to the wallet so that the
32:08 - wallet can keep track of it and ask for
32:10 - updates on its status before sharing
32:13 - your transaction with the whole network
32:15 - the node needs to check that it's
32:17 - legitimate to protect against attx that
32:19 - would saturate the network it checks
32:21 - that the signature is valid that the
32:23 - fees are not too low and that you have
32:25 - enough Tes on your account to pay for
32:27 - everything the node then stores your
32:30 - transaction in its M Pool a memory space
32:33 - that stores all the transactions that
32:35 - are waiting to get included in a block
32:37 - the mol also stores other types of
32:39 - operations that the nodes has received
32:42 - such as block attestations or votes for
32:44 - amendments to the protocol the Noe also
32:47 - sends your transaction to its neighbors
32:49 - which in turn check that your
32:51 - transaction is legitimate add it to
32:53 - their own M Pools and send it to their
32:55 - neighbors propagating it through the
32:58 - whole network every node needs to do
33:01 - these checks itself to make sure some
33:03 - bad nodes don't propagate malicious
33:05 - transactions while all this takes place
33:08 - one lucky Baker is getting ready to take
33:11 - charge of creating the next block it is
33:14 - lucky because it has randomly being
33:16 - assigned the first pot in the list of
33:18 - bakers that are responsible for making
33:20 - sure a block is created the next Baker
33:22 - in that list will wait a little longer
33:24 - ready to take over in case the first
33:26 - Baker doesn't do its job in time this
33:29 - time our first Baker is up and running
33:31 - and is ready to do its job and get
33:33 - rewarded for it it is carefully
33:36 - listening to all the transactions that
33:38 - arrive in the men poool of its node when
33:40 - it's time to create the block it sorts
33:42 - these transactions to decide which ones
33:44 - will end up in this block before it
33:46 - selects transactions it needs to pick
33:48 - the other types of operations such as
33:51 - attestations of the previous blocks or
33:53 - votes the baker is trying to make money
33:56 - by collecting all the fees so it selects
33:58 - transactions that have the highest fees
34:00 - compared to their cost in gas and
34:03 - storage but before adding them to the
34:05 - new block it does its own checks to make
34:07 - sure they are valid especially when they
34:09 - are executed in that specific order it
34:12 - adds the good ones to a new block until
34:14 - it's full or it runs out of transactions
34:16 - it wants to include it then executes all
34:19 - the transactions by applying them to the
34:21 - context produced by the produ block the
34:24 - storage of contracts and balances of
34:26 - accounts are updated in the context
34:28 - after each transaction as the validity
34:30 - of the next transactions depend on them
34:33 - once the block is full the baker comput
34:35 - is hash and sends the block with all its
34:39 - transactions to its node the node sends
34:41 - it to its neighbors and the block
34:44 - propagates through the network the node
34:46 - adds this block to the end of its copy
34:48 - of the blockchain in an unconfirmed
34:50 - state for now it also executes all the
34:53 - transactions and updates its own context
34:56 - other nodes do exactly the same as they
34:58 - receive the block a subset of the Bakers
35:01 - have been randomly selected to form a
35:03 - consensus committee for this block when
35:06 - the node that one of these Bakers is
35:08 - attached to receives the block this
35:10 - Baker starts checking all the operations
35:12 - it contains to make sure everything is
35:15 - valid if it's all good it creates a pre-
35:17 - attestation message along with a hash of
35:20 - the block and sends it to the node other
35:23 - Bakers from the consensus committee do
35:25 - the same and create their own pre
35:26 - attestation these are propagated through
35:29 - the whole network the same Bakers then
35:32 - start receiving all these
35:34 - prorations check them and count them
35:37 - once enough are received a quorum is
35:39 - reached and the baker considers that
35:41 - this block is attested we creates an
35:44 - attestation message and send it to its
35:46 - node nodes propagate them and add them
35:49 - to their me pool as these attestations
35:52 - will be added to the next block while
35:54 - all this is happening your wallet is
35:56 - still checking with with its node what
35:58 - the status of your transaction is when
36:01 - the block that contains your transaction
36:02 - reaches this node the wallet will update
36:04 - the status of the transaction and show
36:06 - it to you when another block arrives and
36:09 - is added at the end of the chain after
36:11 - the block that contains your transaction
36:13 - this new block contains attestations for
36:16 - that previous one having another block
36:18 - added in front of it brings it closer to
36:20 - a final State once a second block
36:22 - arrives and is added to the chain then
36:25 - your block is definitely final you can
36:28 - now be 100% sure that your transaction
36:30 - is permanently part of the tizel
36:32 - blockchain the wallet shows that the
36:34 - transaction is final tells the DB about
36:36 - it and the DB confirms to you that you
36:39 - now own this amazing nft congratulations
36:43 - you have just experienced the power and
36:45 - beauty of tesos in this module we'll
36:47 - talk about some of the reasons why it's
36:49 - a good idea to develop your DS on tesos
36:52 - there are many benefits that come with
36:54 - developing on tesos one of the key
36:57 - benefits of tesos is the unchain
36:59 - automated governance anyone who holds
37:02 - 6,000 TZ or more can vote for protocol
37:06 - amendments proposal there's already been
37:08 - 14 successful upgrades of the protocol
37:11 - since the beginning of tesos this
37:13 - onchain government makes tesos very
37:15 - Innovative with frequent new
37:17 - capabilities that are added to the
37:19 - network and the system reduces the need
37:22 - for hard work there's always a single
37:24 - official branch of the network another
37:27 - benefit of tesos is that it's energy
37:29 - efficient thanks to its use of proof of
37:32 - stake it was one of the first
37:33 - blockchains that uses proof of stake as
37:36 - part of its consensus mechanism tesos is
37:40 - focused on scaling with a lot of work
37:42 - going on right now scaling with smart
37:44 - rollups data availability layer and more
37:47 - and that is done without compromising
37:49 - decentralization or security a lot of
37:52 - work has been done to make sure that the
37:54 - security of tesos is of top quality and
37:58 - the tesos ecosystem itself is very
38:00 - decentralized and benefits from a
38:02 - friendly and diverse community that
38:04 - focuses on long-term Innovation and it
38:07 - has a great ecosystem from blockchain
38:09 - Enthusiast artists but also
38:12 - multinational companies it also benefits
38:15 - from great tooling and funding
38:17 - opportunities to help developers build
38:19 - their
38:20 - projects in 2017 a large amount was
38:24 - raised to fund the development of the
38:26 - tesos Network and this amount is managed
38:29 - by the tesos foundation the mission of
38:32 - the tesos foundation is to grow the
38:33 - tesos ecosystem through a system of
38:36 - grants in areas such as developer
38:38 - experience Education and Training
38:41 - security and privacy and and re users
38:44 - application for more information about
38:47 - how to apply for Grants and what the
38:49 - foundation does visit tesos foundation
38:52 - in this module you will learn how to
38:55 - write your first smart contract on tesos
38:57 - using smart pie it will be a very basic
39:00 - smart contract but a useful one what is
39:03 - a smart contract it's a type of account
39:06 - that like any account on tesos has an
39:09 - address and has a balance in TZ but on
39:13 - top of that it will have some executable
39:15 - code the program of the smart contract
39:18 - that says what it can do and it will
39:20 - have its own storage some data that the
39:23 - smart contract can store to interact
39:25 - with the smart contract we will use used
39:27 - two new types of transactions the first
39:30 - one consists in deploying the smart
39:33 - contract it means putting it out on the
39:35 - blockchain once it deployed its code
39:38 - cannot be changed we say that it is
39:41 - immutable the second type of transaction
39:44 - is to call a smart contract you call it
39:47 - like a function with some parameters
39:49 - that you pass and you may send to the
39:52 - contract as you call it now let's look
39:55 - at our first smart contract this is the
39:58 - smallest useful smart contract we can
40:01 - think of all it does is to store value
40:04 - on the blockchain forever or at least as
40:07 - long as the blockchain exists so here we
40:10 - will store this value in the blockchain
40:12 - forever when we deploy the smart
40:14 - contract and that's all it does we can
40:17 - see that to create a smart contract we
40:18 - have to create a class we give it a name
40:21 - and we said that it inherits from sp.
40:24 - contract here SP stands for smart p
40:27 - and that's the name we gave to the smart
40:29 - by Library when we imported we need to
40:32 - create this class inside a module that
40:35 - we call Main like this and inside the
40:39 - class we create a Constructor that is
40:42 - named in it with two underscores before
40:45 - and after and within this Constructor we
40:47 - can initialize the storage with an
40:50 - attribute that we decide to call value
40:53 - and the attributes are stored in self.
40:55 - data Dot and the name of the attribute
40:58 - so here the contract doesn't execute
41:00 - anything on blockchain WE simply Define
41:03 - its initial value of the storage that
41:05 - will be stored forever once it's
41:07 - deployed it won't be doing anything else
41:10 - if we want to test the smart contract in
41:12 - the smart P
41:13 - IDE we will need to add tests and you
41:17 - always want to add test to any contract
41:19 - you write and in smart P you can add
41:21 - them in the same file as the contract
41:23 - itself here we create a test by adding
41:25 - this test function with the ad test
41:28 - decorator and within this test we create
41:30 - a scenario that basically will contain
41:33 - the sequence of tests calls to Smart
41:35 - contract Etc we give it a name by
41:38 - calling the function test scenario and
41:41 - we declare what module it uses so here
41:43 - it will be using the main module then we
41:46 - create an instance of our store value
41:48 - contract like this we store it in a
41:51 - variable and then we add it to the
41:53 - scenario when we run the test it will
41:55 - simulate deploying the smart contract
41:58 - and show us the output one thing you
42:01 - should keep in mind especially if you're
42:03 - not a python developer is that every
42:06 - time in your code that you create a
42:07 - block the content of this block should
42:10 - be indented compared to the parent so
42:12 - for example here we have a class and
42:15 - inside the class we create a block
42:17 - that's the content of the class all the
42:20 - content of this block should be indented
42:21 - here it's indented by four spaces it
42:24 - could be more it could be tabulations
42:26 - but it has to be the same number for the
42:28 - whole block and then here we can see
42:30 - that inside the Constructor we create
42:33 - another block with a content of the
42:35 - Constructor and again it is indented by
42:37 - four spaces as soon as we reduce the
42:40 - number of indentation so for example
42:42 - here when we have this decorator it
42:44 - indicates that we Clos the previous
42:46 - opened block so here we close this block
42:49 - we also close this one and close this
42:52 - one let's test our contract inside the
42:55 - smart P IDE in this online IDE you can
42:58 - write your contract and an editor and
43:01 - then on the side panel you will be able
43:03 - to test it and see the output so here I
43:06 - put our original smart contract we see
43:09 - that if I just run it nothing happens
43:11 - because I needed a test for anything to
43:14 - happen so I'll add our
43:16 - test now I can run it and I can see that
43:19 - on the side panel I have this
43:21 - origination that is
43:23 - simulated and I Can See For example the
43:25 - address of my contract and I can see the
43:28 - storage value so here we can see that
43:30 - originated a contract that has this
43:32 - value and will store it in the
43:35 - blockchain we can check a few things for
43:37 - example we can see what the code of the
43:39 - smart contract in melon looks like it
43:42 - doesn't really do anything we can also
43:44 - check the content of the storage or the
43:46 - size of the storage Etc we could even
43:49 - deploy the contract directly from the
43:51 - smart by ID now it's your turn write
43:54 - your first smart contract you can name
43:57 - it store value it should store the value
44:00 - 42 and of course you need to add a test
44:03 - scenario and run it to simulate the
44:05 - deployment of this contract once you're
44:08 - done validate it on open Tel let's pause
44:11 - the video and give it a try before we
44:14 - continue so far our smart contract
44:16 - wasn't really doing anything except
44:18 - storing a value if we want the smart
44:21 - contract to do something we need to add
44:23 - entry points they are like methods or
44:26 - functions that we can add to our smart
44:28 - contract when you call an entry point
44:31 - they cannot do much they can only read
44:34 - the parameters that you pass to the
44:35 - function the current value of the
44:37 - storage of the smart contract a few
44:39 - special values like the balance of the
44:41 - contract or the amount that the color
44:44 - sent to the contract or the address of
44:46 - that color and a few more it will also
44:49 - have access to a global table of
44:51 - constants that all smart contracts have
44:53 - access to it also cannot do much it can
44:56 - only have two effects the first one is
44:59 - to modify the content of its own storage
45:02 - and the second one is to generate new
45:04 - transactions such as transfer t or CS to
45:07 - other smart contracts that will be
45:09 - executed at the end of the execution of
45:12 - the entry point itself and that's it now
45:16 - let's see how we can add an entry point
45:18 - to a Smart
45:20 - contract so we here created a contract
45:24 - called flipcoin that will store the
45:26 - curent ins side of a coin and then we
45:29 - will have a flip entry point that can be
45:31 - used to switch this side from 0o to one
45:34 - and then from 1 to zero Etc we can see
45:38 - here how we created an enter point we
45:40 - created a function with a s sp. entry
45:43 - point decorator and then inside that
45:46 - function well we change the value of the
45:49 - side attribute of our storage to one
45:52 - minus this value so if you start with
45:55 - zero you get 1 - 0 equal 1 and then if
45:58 - you call it again it goes back to 1 - 1
46:01 - = 0 Etc every time you call it it will
46:04 - flip the value of the coin to add test
46:07 - to our entry point we can simply add
46:11 - calls to this entry point in our test
46:13 - function so after we added the contract
46:15 - to the scenario we can call contract.
46:18 - Flip so that's the name of our Tre Point
46:20 - as many time as we like let's give it a
46:23 - try in the smartp IDE so here we have
46:27 - our contract and N test let's run
46:30 - it we can see again the origination with
46:33 - the initial value of side set to
46:36 - zero and then we have here our first
46:38 - call to our flip entry point and if we
46:41 - click on show details we can see that
46:44 - the new value of the storage is now
46:46 - one then we have the second call and
46:49 - here we can see that the value is
46:51 - zero and then one again Etc now the
46:55 - issue with this is that if we make a
46:57 - change to this contract we don't want to
47:00 - have to check again and click on show
47:02 - details Etc to see that all the value of
47:05 - the storage are still correct we would
47:08 - like to automate this and have Smart P
47:10 - tell us immediately if what we get is
47:13 - what we
47:14 - expected we can do that by automating
47:17 - those tests so to check the outcome
47:20 - automatically all we have to do is add
47:22 - this to our scenario after or before a
47:25 - call to an entry point
47:27 - scenario. verify and then some
47:30 - conditions so here for example we can
47:31 - check that the value of this field from
47:34 - the storage of our contract is equal to
47:37 - a specific value let's give it a try
47:40 - here after flip we can write
47:43 - scenario dot
47:46 - verify
47:48 - construct. data. side equals so after
47:53 - the first flip it should be equal to one
47:56 - then I can
47:58 - add it here should be equals to zero
48:01 - again and then to one again let's give
48:03 - it a try all good we get the same output
48:07 - if we had here written one then smart P
48:11 - would tell us hey this comparision is
48:14 - incorrect as an error so of course here
48:16 - that's just because the test is
48:18 - invalid but we put zero and then we run
48:22 - it and then we can make some changes and
48:24 - make sure that we never break this
48:26 - condition
48:28 - now it's your turn write your own smart
48:30 - contract call it count the calls and the
48:33 - goal of the smart contract is to count
48:35 - how many times we will call it so we
48:37 - will have a attribute NB calls in the
48:40 - storage that you initialize with zero
48:43 - and then every time we call the contract
48:45 - it should increment by one so to do so
48:48 - you will create an entry point make call
48:51 - and then increment by one the value of
48:53 - NB calls and then of course add a test
48:55 - scenario and run it let's give it a try
48:58 - and when you're done you can validate it
49:00 - on open tizel so please pause the video
49:02 - and give it a try let's take a look at
49:04 - the solution we created a class come the
49:07 - calls that inates from sp. contract we
49:10 - have a Constructor that initializes the
49:13 - value NB calls to zero then we create an
49:16 - entry point make call and every time we
49:19 - call it NB calls will be incremented by
49:22 - one you could also write NB
49:25 - call equals and equals + one but this is
49:29 - a shorthand operator that makes it
49:31 - easier to
49:32 - increment in our test we instant shed
49:35 - the cond the calls contract in the
49:37 - contract
49:38 - variable we can verify immediately that
49:41 - the value is zero we can use H2 to
49:45 - display a title that says what we're
49:47 - going to do next we call the entry point
49:50 - make call verify that the value is one
49:53 - then call it again verify that the value
49:55 - is two let's check if it
49:57 - works and it's all good we start with
50:00 - zero then we make the first call it's
50:03 - now one second call is not two
50:06 - everything is good and again I had
50:09 - change it to three it would let me know
50:11 - that this condition is invalid testing a
50:14 - smart contract is really important smart
50:16 - contracts manipulate tokens and other
50:19 - digital assets that can have very large
50:22 - economic values we can talk about
50:23 - millions of dollars in some cases or
50:26 - tens of millions of dollars in a single
50:28 - smart contract and the environment where
50:31 - you execute the code is what we call
50:33 - adversarial that means other people can
50:35 - attack it anyone in the world could look
50:37 - at your contract try to find a bug and
50:40 - if there's a bug someone will try to
50:42 - attack it and try to either steal some
50:45 - funds in it or make them stuck in the
50:47 - contract and people have very strong
50:50 - incentive to exploit bugs that you may
50:52 - leave in the contract and since once you
50:55 - deploy the contract it cannot be changed
50:57 - anymore it's immutable then bugs cannot
50:59 - be fixed as soon as you see them so that
51:02 - makes it even more dangerous there are
51:04 - unfortunately many examples of cases
51:07 - where people lost millions of dollars
51:09 - collectively as a consequence of small
51:11 - bugs in smart contract so it's very
51:13 - important when you write a smart
51:15 - contract to spend a lot of time testing
51:17 - it proofreading it Etc in general it's
51:20 - actually relatively simple to write a
51:23 - smart contract smart contracts are small
51:25 - projects compared to to other types of
51:27 - software projects but it's actually
51:30 - quite hard to make sure there are no
51:31 - bugs in those smart contracts so testing
51:34 - them and avoiding bugs is the hardest
51:36 - part in later modules we will study
51:39 - different flaws and best practice on how
51:41 - to avoid typical kinds of bugs in this
51:43 - module you will learn how to add entry
51:45 - points to your smart contracts so that
51:48 - you can create contracts that do
51:50 - something so far our smart contract
51:52 - wasn't really doing anything except
51:54 - storing a value if we want the smart
51:57 - contract to do something we need to add
51:59 - entry points they are like methods or
52:02 - functions that we can add to our smart
52:04 - contract when you call an entry point
52:07 - they cannot do much they can only read
52:10 - the parameters that you pass to the
52:11 - function the current value of the
52:13 - storage of the smart contract a few
52:15 - special values like the balance of the
52:17 - contract or the amount that the caller
52:20 - sent to the contract or the address of
52:22 - that color and a few more it will also
52:25 - have access to a global table of
52:27 - constants that all smart contracts have
52:29 - access to it also cannot do much it can
52:32 - only have two effects the first one is
52:35 - to modify the content of its own storage
52:38 - and the second one is to generate new
52:40 - transactions such as transfer t or calls
52:43 - to other smart contracts that will be
52:45 - executed at the end of the execution of
52:48 - the entry point itself and that's it now
52:52 - let's see how we can add an entry point
52:54 - to a Smart contract
52:57 - so we here created a contract called
53:00 - flipcoin that will store the current
53:03 - side of a coin and then we will have a
53:06 - flip entry point that can be used to
53:08 - switch this side from 0er to one and
53:11 - then from one to zero Etc we can see
53:14 - here how we created an entry point we
53:16 - created a function with a sp. entrypoint
53:20 - decorator and then inside that function
53:22 - well we change the value of the side
53:25 - attribute of our our storage to one
53:28 - minus this value so if you start with
53:31 - zero you get 1 - 0 = 1 and then if you
53:34 - call it again it goes back to 1 - 1al 0
53:38 - Etc every time you call it it will flip
53:41 - the value of the coin to add test to our
53:44 - entry point we can simply add calls to
53:47 - this entry point in our test function so
53:50 - after we added the contract to the
53:52 - scenario we can call contract. Flip so
53:55 - that's the name of our Treo
53:57 - as many time as we like let's give it a
53:59 - try in the smart P IDE so here we have
54:03 - our contract and N test let's run
54:06 - it we can see again the origination with
54:09 - the initial value of side set to
54:12 - zero and then we have here our first
54:14 - call to our flip entry point and if we
54:17 - click on show details we can see that
54:20 - the new value of the storage is now
54:22 - one then we have the second call and
54:25 - here we can see that the value is
54:27 - zero and then one again Etc now the
54:31 - issue with this is that if we make a
54:33 - change to this contract we don't want to
54:36 - have to check again and click on show
54:38 - details Etc to see that all the value of
54:41 - the storage are still correct we would
54:44 - like to automate this and have Smart P
54:46 - tell us immediately if what we get is
54:49 - what we expected we can do that by
54:51 - automating those tests so to check the
54:54 - outcome automatically all we have to do
54:57 - is add this to our scenario after or
54:59 - before a call to an entry point
55:02 - scenario. verify and then some
55:05 - conditions so here for example we can
55:06 - check that the value of this field from
55:09 - the storage of our contract is equal to
55:12 - a specific value let's give it a try
55:15 - here after flip we can write
55:18 - scenario dot
55:21 - verify
55:23 - construct. dat. side
55:27 - equals so after the first flip it should
55:29 - be equal to one then I
55:32 - can add it here it should be equals to
55:36 - zero again and then to one again let's
55:38 - give it a try all good we get the same
55:41 - output if we had here written one then
55:46 - smart P would tell us hey this uh
55:48 - comparison is incorrect as an error so
55:51 - of course here that's just because the
55:52 - test is
55:53 - invalid but we put zero and then we run
55:57 - it and then we can make some changes and
56:00 - make sure that we never break these
56:02 - conditions now it's your turn write your
56:04 - own smart contract call it count the
56:07 - calls and the goal of the smart contract
56:09 - is to count how many times we will call
56:11 - it so we will have a attribute NB calls
56:15 - in the storage that you initialize with
56:17 - zero and then every time we call the
56:19 - contract it should increment by one so
56:23 - to do so you will create an entry point
56:25 - make call and then increment by one the
56:28 - value of n calls and then of course add
56:30 - a test scenario and run it let's give it
56:33 - a try and when you're done you can
56:34 - validate it on open tsos so please pause
56:37 - the video and give it a try let's take a
56:39 - look at the solution we created a class
56:42 - come the calls and inates from sp.
56:44 - contract we have a Constructor that
56:47 - initializes the value NB calls to zero
56:50 - then we create an entry point make call
56:54 - and every time we call it and me call
56:56 - call will be incremented by one you
56:58 - could also write NB
57:00 - call equals n + one but this is a
57:05 - shorthand operator that makes it easier
57:06 - to
57:07 - increment in our test we instantiate the
57:10 - cond the Call's contract in the contract
57:14 - variable we can verify immediately that
57:16 - the value is zero we can use H2 to
57:20 - display a title that says what we're
57:22 - going to do next we call the entry point
57:25 - make call verify that the value is one
57:28 - then call it again verify that the value
57:30 - is two let's check if it
57:32 - works and it's all good we start with
57:35 - zero then we make the first call is now
57:39 - one second call is now two everything is
57:42 - good and again I had change it to three
57:45 - it would let me know that this condition
57:47 - is invalid testing a smart contract is
57:50 - really important smart contracts
57:52 - manipulate tokens and other digital
57:55 - assets that can have very large economic
57:57 - values we can talk about millions of
57:59 - dollars in some cases but tens of
58:01 - millions of dollars in a single smart
58:04 - contract and the environment where you
58:06 - execute the code is what we call
58:08 - adversarial that means other people can
58:10 - attack it anyone in the world could look
58:13 - at your contract try to find a bug and
58:15 - if there's a bug someone will try to
58:17 - attack it and try to either steal some
58:20 - funds in it or make them stuck in the
58:22 - contract and people have very strong
58:25 - incentive to exploit bugs that you may
58:27 - leave in the contract and since once you
58:30 - deploy the contract it cannot be changed
58:32 - anymore it's immutable then bugs cannot
58:34 - be fixed as soon as you see them so that
58:37 - makes it even more dangerous there are
58:39 - unfortunately many examples of cases
58:42 - where people lost millions of dollars
58:44 - collectively as a consequence of small
58:46 - bugs in smart contracts so it's very
58:49 - important when you write a smart
58:51 - contract to spend a lot of time testing
58:52 - it proof reading it Etc in general it's
58:55 - actually
58:56 - relatively simple to write a smart
58:58 - contract smart contracts are small
59:00 - projects compared to other types of
59:02 - software projects but it's actually
59:05 - quite hard to make sure there are no
59:07 - bugs in those smart contracts so testing
59:09 - them and avoiding bugs is the hardest
59:11 - part in later modules we will study
59:14 - different flaws and best practice on how
59:16 - to avoid typical kinds of bugs in this
59:18 - module you will learn how to deploy your
59:21 - contracts so that they are available on
59:23 - the chain for everyone to use well will
59:26 - deploy our contracts on a test Network
59:28 - so that you don't need to spend any test
59:30 - to do the deployment but the same
59:33 - approach will work on the main Network
59:35 - so the test network is called ghost net
59:38 - and it is very similar to the main
59:40 - Network so to originate or we can say
59:43 - deploy your contract you need to do two
59:45 - steps the first step is to produce the
59:48 - makerson contract so compile your smart
59:50 - pie contract into melon melson is the
59:53 - low-level language of every tesos smart
59:56 - contract and smart py is a highlevel
59:58 - language that makes contract easier to
60:00 - write but when you run smart py you
60:03 - compile the smart P code into mikelson
60:07 - so you generate the mikelson contract so
60:09 - that's the first step before you can
60:10 - deploy your contract and the Second Step
60:12 - will be to create and sign a transaction
60:15 - to deploy that contract the smart py IDE
60:18 - will help you prepare the transaction
60:21 - and we will be able to use our wallet to
60:23 - sign this transaction and then we'll
60:25 - send to ghost net this operation is what
60:28 - we call the origination of the
60:30 - contract so we start from the IDE with
60:34 - our contract and to deploy it we first
60:36 - need to run the code and on the right
60:40 - side in the top part we have the
60:42 - origination and here we can view the
60:44 - mikon version of the contract and then
60:48 - you can see at the bottom right deploy
60:50 - contract button so let's click on that
60:54 - and here it will prepare everything
60:56 - everything you need to originate your
60:58 - contract so here we'll select what
61:01 - network we use we can use ghost net or
61:04 - main net here you can provide the
61:07 - address of the node that you will be
61:09 - using to deploy the contract so for
61:11 - example by default it's the smartp node
61:14 - but I could use a node from another
61:17 - infrastructure then I can select my
61:20 - account and here I have a choice of a
61:22 - number of wallets if I wanted to use my
61:24 - Kai wallet I could select Bon and then
61:28 - Kai but smartp also offers its own
61:32 - system to manage accounts so here you
61:35 - can create accounts and here have
61:36 - created a couple so let's just use this
61:39 - one so we can see that this account has
61:42 - almost 100 t in it and it's revealed
61:45 - already on ghost net so I simply
61:48 - validate that
61:50 - account here I can provide any
61:52 - origination parameters I can say how
61:54 - many Tes I put in the contract as I
61:57 - deploy it and I can also set a delegate
61:59 - to indicate if I have test in the
62:02 - contract which Baker should I be
62:04 - delegated to then I have the estimates
62:07 - of the deployment cost that I obtain
62:09 - from RPC so that's contacting the node
62:11 - doing our RPC remote procedure call to
62:14 - the node I can check and it tells me
62:16 - okay this is how much the node expects
62:19 - that it will cost to deploy it so it's
62:21 - very cheap to deploy this tiny contract
62:24 - this is how much gas I will spend how
62:25 - much storage I will spend Etc and then I
62:30 - can simply click deploy
62:32 - contract it shows me all the information
62:35 - about the contract I'm going to deploy
62:37 - so it shows me the hash of the
62:39 - transaction the parameter so what
62:42 - account I use to originate it what's the
62:44 - counter what's the fee I'm going to be
62:46 - paying the gas limit the storage limit
62:48 - Etc and the balance initial balance for
62:51 - my contract in the full version I also
62:54 - have the full code of the contract in
62:58 - meason plus the initial value of the
63:01 - storage and then I can see the by
63:04 - encoded version of that so once I'm sure
63:07 - that this is the transaction I want to
63:08 - run I can accept it and then it contacts
63:11 - node originates the account and I have
63:14 - the address here if I copy this address
63:17 - and go to for example better call Dev I
63:21 - can search that contract and I can see
63:25 - here that better called Dev sees my
63:27 - contract on ghostnet and we can see that
63:30 - the operation was done just now here it
63:33 - says a few seconds ago so my contract is
63:36 - deployed I can check the contract on
63:39 - ghost net see the current value of the
63:41 - storage see the melson code and I can
63:44 - even interact with it directly from
63:47 - ghostnet so now that we have deployed it
63:50 - our contract and the associated data are
63:53 - now public so as we could see through
63:55 - better called Dev anyone can read the
63:57 - code and the storage without asking for
63:59 - permission the contract is immutable it
64:01 - can never be changed and it's Eternal so
64:04 - as long as a few nodes are running the
64:07 - tesos blockchain my contract will be
64:09 - available for anyone to use this is
64:12 - because tesos is run by hundreds of
64:14 - independent nodes that each maintain a
64:17 - copy of my contract and its data and
64:20 - changes to the contract may only be made
64:23 - if a super majority of participants with
64:25 - agreed to make changes which is
64:27 - something that doesn't actually happen
64:28 - people don't really change contracts
64:31 - when they have been deployed we will see
64:32 - later that we can integrate features in
64:35 - a contract to enable upgradability
64:37 - features of our contract and so due to
64:39 - this decentralized structure of the
64:42 - blockchain no single entity can cause my
64:45 - contract to fail and the network as a
64:47 - whole to fail so my contract is pretty
64:49 - much available for anyone to use forever
64:52 - and we'll keep counting how many times
64:54 - people call it I could try directly from
64:57 - baral
64:59 - Dev execute and directly using my
65:02 - wallet here it's sending to my Kai
65:05 - wallet so here it says I'm waiting for
65:08 - confirmation my Kai wallet is here so I
65:11 - just need to accept the
65:14 - transaction and I go back CA
65:18 - successfully submitted the operation
65:20 - transaction has been successful and now
65:22 - I if I see the storage I can see well
65:26 - this contract has been called
65:27 - once I can try it again
65:33 - execute
65:35 - confirm successfully executed I see this
65:40 - storage not updated
65:43 - yet and that's it now it's two so my
65:47 - contract is available forever and you
65:48 - could call it to using this address in
65:51 - this module you will learn that every
65:53 - value variable or parent parameter in
65:56 - smart Pi has a type but most of the time
65:59 - you won't need to tell smart Pi what the
66:01 - type of your variables are thanks to a
66:04 - very powerful tool called type
66:07 - inference but first let's talk about
66:10 - parameters we have already presented
66:13 - entry points since an entry point is a
66:16 - kind of method of your smart contract
66:20 - they can take parameters if you want to
66:22 - write an entry point with one parameter
66:24 - here is how you do it so when you define
66:26 - your entry point next to self you add a
66:29 - comma and the name of your parameter and
66:32 - then within the code of your entry point
66:34 - you can simply use the name of your
66:36 - parameter wherever you want to use this
66:38 - value in your test when you want to call
66:41 - an entry point with a parameter if it's
66:43 - a single parameter all you have to do is
66:46 - put the value of this parameter between
66:48 - the parenthesis when you call the entry
66:51 - point of your
66:52 - contract let's take a look at an example
66:56 - here we modified our store value
66:58 - contract by adding two entry
67:01 - points one entry point with a parameter
67:05 - called added value that we can call to
67:08 - add this value pass as a parameter to
67:11 - the stored
67:13 - value and then we can compare it to
67:15 - another entry point that doesn't have
67:16 - any parameter reset that simply resets
67:20 - the value to
67:21 - zero and then in our test scenario here
67:25 - here we call contract. add with a
67:28 - parameter five saying that we want to
67:30 - add five to the initial value 42 and
67:33 - then after the call we can verify that
67:36 - the new value of stored value is
67:40 - 47 and then to really make sure that the
67:42 - entry point works well if we call it
67:44 - several times we have a second test
67:47 - where we this time add two and then we
67:49 - verify that the result is 49 let's give
67:53 - it a
67:54 - try so we can see that it was successful
67:57 - we start with the origination with the
67:59 - value 42 then we call our entry point we
68:02 - see that the argument so the value
68:04 - passed for the parameter added value was
68:08 - five and then if you look at the detail
68:10 - we can see that the new stored value is
68:12 - changed to
68:14 - 47 and then we have another call with
68:16 - the argument two and the new stored
68:20 - value is 49 in smart Pi everything has a
68:23 - type whether it's a value or for a
68:25 - variable that always has the same type
68:28 - and can only contain values of the same
68:30 - type and the same with the parameter all
68:32 - of them have to have a type so far we
68:35 - have manipulated whole numbers but just
68:37 - for whole numbers we actually have two
68:39 - different types available the first one
68:43 - is int for
68:44 - integer and a value of type hint can
68:48 - hold a whole number that can be either
68:51 - positive or negative but there is a
68:53 - second type for whole number called nut
68:56 - for natural natural numbers that can
69:00 - also hold a whole number but this time
69:03 - only non- negative values so values
69:05 - starting at 0 1 2 3 Etc but not negative
69:09 - values when we want to use the whole
69:11 - numbers if we want to specify which one
69:15 - of those two we want we can either write
69:18 - sp. in of five for the integer five or
69:23 - sp. not of five for the natural five so
69:27 - those are two values of different types
69:30 - whenever we want to express the type
69:33 - itself in smart pile we will simply use
69:35 - sp. in and sp. notot in short when I
69:39 - talk about it I will just say int and
69:42 - net in smart Pi you cannot directly
69:45 - combine nut and int so for example if
69:48 - you have a variable of type int you can
69:50 - add assign a nut to it and vice versa so
69:54 - if we take this example of a contract
69:58 - that has a value where we assign a type
70:02 - int and then has an increment variable
70:05 - to which we assigned three then we
70:08 - cannot have an entry point that adds
70:10 - those two together because they are of
70:12 - different
70:14 - types but we can convert a nut into an
70:18 - INT for example using sp. 2 in of the
70:22 - value so if this value is an N we can
70:25 - con convert it to an integer with this
70:27 - function most of the time if you feel
70:30 - like you need to convert a value from
70:32 - one type to another it may be because
70:34 - you chose the wrong type to begin with
70:37 - so most of the time if you feel the need
70:39 - to
70:40 - convert try to think first if there's a
70:43 - way you can change the initial type of
70:46 - the variable rather than converting it
70:48 - to another
70:50 - type if every variable has a type you
70:53 - may wonder why we never had to to
70:55 - provide the type so far and the idea is
70:58 - that smartp uses a very powerful tool
71:00 - called type inference to automatically
71:03 - determine the types of many variables
71:06 - and parameters if you don't specify it
71:09 - it can deduce it from other Clues and
71:12 - there's a number of information that you
71:13 - can use for that the main one is the
71:16 - initial value you assign to the storage
71:19 - so for example if you have a variable in
71:21 - your storage and you say I sign it to
71:24 - sp. int of five then smart P can deduce
71:28 - that the variable is of type int if you
71:32 - combine operation in an operation for
71:34 - example if you add two values and one of
71:37 - them is of type nut then that means the
71:40 - other one and the results both have to
71:42 - be of type net and sometimes you can
71:46 - provide explicit information about the
71:48 - type of a value so for example if we
71:51 - have a parameter factor and we want to
71:53 - say we know and we want this parameter
71:55 - to be up type int then we can use sp.
71:58 - cast of factor and the type that we want
72:02 - to assign to this parameter not that
72:05 - this is not converting the type of this
72:08 - variable whatever value it contains to
72:10 - an NT it is simply saying that the type
72:13 - of this parameter or variable is an INT
72:17 - and should always be an INT it uses
72:19 - those information that it finds here and
72:21 - there in your contract and it propagates
72:24 - it to the rest of the contract whenever
72:27 - it can one thing that you should know is
72:29 - that sometimes smart P cannot determine
72:32 - if a value is of type int or of type not
72:36 - so it temporarily propagates a value
72:39 - that has an intermediate type int or not
72:41 - and then only at the end it will
72:43 - determine which one of the two it is and
72:46 - sometimes you may see error messages
72:48 - that tell you that it's expecting into
72:50 - not it's because so far it doesn't know
72:52 - yet if a variable containing a number
72:54 - will be of type int or of Type n so it
72:58 - is propagating this intermediate type
73:00 - but eventually it will have to pick
73:02 - between it and
73:03 - N if we look at our smart contract as an
73:07 - example here we saw that we didn't
73:10 - provide any type information and that
73:12 - means when I look at the type of the
73:15 - storage here we can see that the stored
73:18 - value is of type int or not because it
73:20 - doesn't know if this 42 is an INT or or
73:23 - not same thing with this parameter or
73:25 - this value it could be both but
73:27 - eventually since it has to pick when we
73:30 - look at the melson code we see that it
73:32 - picked an INT so if there's choice
73:35 - between in and nut at the end it will
73:37 - pick an INT but we could force it to be
73:40 - a nut by here initializing the value
73:44 - with sp.
73:46 - nut of
73:49 - 42 so type inference will be used to
73:53 - deduce that the type of this variable is
73:56 - net here since we add the value of this
73:59 - parameter to the stored value this means
74:02 - this parameter is also an out and here
74:06 - since we assign another value to store
74:08 - value then it knows that zero should be
74:11 - actually sp. nut of zero so here if we
74:15 - run it we can see that store value is
74:17 - now S as a n and then melon contract we
74:20 - see that we have nut everywhere as well
74:23 - the type inference could be used
74:26 - starting from any point so for example
74:28 - could use the reset entry point to say
74:30 - hey this zero is a
74:33 - nut and the result would be the same
74:36 - because it will deduce from this that
74:40 - stored value is a nut therefore 42 is a
74:44 - nut therefore the parameter added value
74:46 - is a nut so from this single information
74:49 - that this value is a nut it will
74:50 - propagate it to stored value then to
74:53 - added value then to other places like
74:56 - for example the value 42 it knows that
74:59 - it is
75:00 - n this is what we call type inference
75:03 - using a set of Clues to determine for
75:06 - sure what the type of each value
75:10 - is let's look at a different version of
75:12 - this contract that I prepared for an
75:15 - exercise here we have this add entry
75:18 - point and we say that we don't want to
75:20 - allow negative numbers to be added to
75:23 - the value and the reason is that we also
75:25 - have a sub entry point that substract a
75:28 - given value from the stored value and so
75:32 - since we have this entry point let's say
75:34 - we don't want add to be able to be used
75:37 - to add negative value which would be the
75:39 - same as subtracting so it's just a rule
75:41 - that we set for the purpose of this
75:43 - exercise so for this reason as a way to
75:45 - say I don't want negative value I say
75:48 - that this parameter should be of type
75:49 - net so I use sp. cast to say added value
75:53 - is of type net let's see what happens
75:56 - when I run so here we have a type issue
76:00 - on line 18 it's telling us that it's
76:03 - trying to combine an INT and a nut and
76:06 - as we said we cannot combine those two
76:08 - types in the same operation for most
76:11 - operations so here we have an issue
76:15 - because it deduced that stored value is
76:18 - a
76:19 - n from adding an N to it here but it
76:23 - also deduces that stored value is an
76:26 - integer because well we subtracted a
76:29 - value to it therefore it could become
76:31 - negative therefore it can hold negative
76:34 - values and should be of type int so your
76:38 - goal for this exercise is to try to find
76:41 - a way to fix this mod contract and make
76:43 - it compile while keeping this constraint
76:47 - of having added value B of Type n you
76:50 - will find the content of this smart
76:52 - contract either in the git Repository
76:54 - associated with this course or in the
76:57 - type inference section on open tzel
77:00 - please pause the video and give it a
77:04 - try Okay so let's see how we can fix
77:07 - this here the issue is that when we add
77:10 - a nut to this
77:12 - value it will deduce that this value
77:15 - should be a nut but we want this value
77:17 - to be an INT because we want to be able
77:19 - to subtract values to it and we want it
77:21 - to be potentially negative so this has
77:25 - to be an INT but this has to be a nut
77:28 - but we cannot combine the two together
77:30 - so what we do is we convert this value
77:32 - to an INT by
77:34 - writing SP do 2
77:38 - int of this value let's give it a
77:42 - try so I still have an error but a
77:44 - different one line 30 and again it says
77:48 - entry point expect parameter of type SP
77:50 - sp. unknown but it got int and it tells
77:53 - us that there is an int sln mismatch so
77:56 - the error message is not very clear on
77:58 - where the problem is but let's look at
78:00 - what we have on line 30 and we can see
78:03 - the content of this line here here we
78:06 - see that inest we called add but we
78:09 - passed an INT as a parameter so of
78:11 - course if we pass an INT as a parameter
78:14 - and then it tells us no this parameter
78:16 - should be of type nut then there's the
78:19 - discrepancy we cannot pass an in when it
78:22 - expects a n so all we have to do here is
78:25 - change this to nut let's give it a
78:28 - try and it works so now the type
78:32 - inference doesn't have any conflict it
78:34 - doesn't end up with a place where from
78:36 - one set of deductions it deduces that a
78:39 - value should be of a type in and then
78:41 - from another set of deductions it
78:42 - deduces that it should be a nut
78:44 - everything is coherent so it all
78:47 - works when particularity of tesos is
78:50 - that it cannot have bugs related to
78:53 - overflows so if you not familiar with
78:55 - overflows the idea is that in most
78:57 - languages values of different types have
78:59 - a minimum and a maximum value they can
79:02 - hold so for example in C++ if you use
79:05 - the type short you can only store values
79:08 - between those two numbers included if
79:11 - you use an operation that adds one for
79:13 - example to the maximum value that it can
79:16 - have it will loop back to the minimum
79:19 - negative value that you can have so from
79:20 - this number if you add one you go all
79:23 - the way back to the negative value
79:28 - 32,768 and this can cause very dangerous
79:32 - bugs right if you add a number to a
79:34 - value you expect it to increase you
79:35 - don't expect it to become a very
79:37 - negative value on tesos we cannot have
79:41 - this kind of bugs contrary to many
79:44 - blockchains and the reason is that on
79:47 - tesos most types don't have any limit
79:51 - there is no upper limit to the value
79:53 - that an in can hold hold and there is no
79:56 - negative limit to the value that an in
79:59 - can hold basically that means the value
80:01 - of an INT can be between minus infinity
80:03 - and plus infinity there's only one type
80:06 - the TZ that has a limit but in this case
80:10 - if there's an overflow if you try to add
80:12 - one to the maximum value for the type
80:15 - Tes you will trigger an error instead of
80:17 - getting an invalid result so you avoid
80:20 - very dangerous situations so you may
80:23 - wonder is there really no limit to
80:25 - values does it make any sense to talk
80:27 - about in being able to hold infinite
80:30 - values well of course not in practice
80:33 - the types of value you can hold in an
80:35 - INT are limited by the storage needed to
80:39 - hold these values so you may wonder how
80:42 - much storage is used by a value and we
80:46 - can say that it's roughly proportional
80:48 - to the number of digits so if you have a
80:50 - number with 100 digits it will use about
80:53 - 50 bytes
80:55 - of memory so it's about one bite for
80:57 - every two digits approximately so the
81:00 - next question will be to wonder if uh
81:02 - the limit is the amount of storage and
81:05 - there's no limit to how much you can put
81:07 - in a value how do we prevent abuse how
81:09 - do we prevent people from storing
81:12 - numbers with billions of digits for
81:15 - example and the idea is that users have
81:17 - to pay whenever they increase the size
81:20 - of the storage of a smart contract so
81:22 - when you uh deploy a smart contract or
81:25 - when you call a smart contract in some
81:28 - cases the result of that is that you
81:30 - will change the value in the storage of
81:32 - the contract and therefore you may
81:34 - increase the amount of storage needed to
81:37 - store these values so whenever that
81:40 - happens you have to pay for that storage
81:44 - so now we may wonder who gets paid if we
81:46 - pay who do we pay to and the answer is
81:49 - no one we actually burn those tests and
81:52 - that's because there's really no easy
81:54 - way to determine who should deserve that
81:57 - amount and in a way by burning the test
82:00 - we pay everyone in the community because
82:02 - if you burn test you destroy them you
82:04 - make them unavailable you reduce the
82:07 - total amount of test available for
82:09 - everyone so by doing that indirectly you
82:12 - increase the value of the Tes so it's
82:14 - basically value that is shared with a
82:17 - community when do you pay well when you
82:20 - call a smart contract you're doing
82:22 - through a transaction that you will need
82:24 - to sign with your wallet and your wallet
82:26 - will simulate the transaction compute
82:29 - how much extra storage will be needed
82:32 - due to your transaction calling smart
82:34 - contracts and increasing their storage
82:37 - and so compute how many bytes you may
82:39 - increase the storage and then uh lets
82:42 - you know basically how by how much how
82:45 - many Tes you may burn and you can
82:47 - specify the maximum amount of Tes that
82:49 - you are willing to burn for this
82:51 - transaction to happen and when the
82:53 - transaction happen the exact amount will
82:55 - be burned okay now let's work on an
82:58 - exercise so you will take the smart
83:00 - contract store value that we have used
83:02 - so far and add a multiply entry point to
83:06 - the
83:07 - contract this multiply entry point
83:09 - should take a parameter called factor
83:12 - that should have type int and the
83:15 - multiply entry point should multiply the
83:17 - value of the storage by this
83:19 - parameter and of course we ask for you
83:23 - to add the Cor corresonding test to your
83:26 - scenario so please pause the video and
83:29 - give it a try and you can validate your
83:31 - Solution on open
83:32 - Tel let's take a look at the solution
83:35 - here we added this entry point multiply
83:38 - that takes a factor
83:40 - parameter and we multiply stored value
83:43 - by this
83:45 - factor and then of course we call it in
83:49 - our scenario to verify let's give it a
83:53 - try and we can see see here that when we
83:55 - call multiply by 10 we started with the
83:58 - storage that was five multiply by 10 and
84:01 - we can see the result is indeed 50 in
84:04 - this module you will learn to manipulate
84:06 - text on tesos using the type string
84:09 - tesos supports a string type that you
84:12 - can use to manipulate text but it is
84:14 - limited to non- accented characters so
84:17 - what you can use is the set of
84:18 - characters from the non-extended S key
84:21 - standard composed of 128 different
84:24 - possible characters when you want to
84:26 - express a string literal you write it
84:29 - between double quotes like this example
84:32 - so double quote your text and then
84:34 - double quote again and just like for INT
84:37 - and nut there is no limit to how long
84:40 - this text can be you can write a string
84:41 - as long as you like the only limitation
84:44 - is the storage and how much it costs to
84:47 - store this string on the blockchain the
84:50 - most common operation we can do on
84:52 - strings is to concate Different Strings
84:55 - so you can concate different elements
84:58 - like this using the plus operator so
85:00 - here we Show an example where we create
85:03 - a
85:04 - URL by conting this bit with this
85:07 - parameter with this text with this
85:09 - parameter let's directly try it on an
85:12 - exercise so you will create a contract
85:15 - that will illustrate the concept of
85:17 - Eternity and immutability of the
85:20 - blockchain so for that you create a
85:23 - smart contract called edness wall and
85:26 - the idea is that it will store a string
85:29 - that we will call Wall
85:31 - text and anyone will be able to call an
85:34 - entry point called write message that
85:37 - will take a message as a parameter and
85:40 - will add it to this text basically it's
85:42 - a very long string of text that anyone
85:44 - will be able to add to so people like to
85:48 - leave their name U maybe carve their
85:50 - name on a rock for tunity or on a tree
85:52 - for a long time Etc there often a need
85:55 - for people to leave a trace so this is a
85:58 - contract that will let people leave a
86:01 - trace forever without destroying the
86:03 - environment in any way so the right
86:06 - message entry point should add a comma
86:09 - to the text to worldex then a space and
86:13 - a message then the string forever so for
86:17 - example if you call write message of
86:21 - tesos it will add a comma space and then
86:24 - tesos forever to wall
86:27 - texts and so if we start with hello and
86:29 - then we call WR message then we end up
86:32 - with hello tesos
86:33 - forever and of course once you're done
86:36 - writing the contract you should create
86:38 - the corresponding test scenario and you
86:41 - can validate your contract on open tizel
86:43 - let's pause the video and give it a try
86:45 - okay let's look at this
86:47 - solution so we created this endless wall
86:50 - contract we initialize the storage with
86:53 - a wall text variable that takes the
86:56 - parameter initial text that sets the
86:58 - initial value we will initialize this
87:01 - value with hello in our
87:03 - test then we have this entry point write
87:06 - message it takes the message as a
87:09 - parameter and it adds to World text a
87:12 - comma and the space then the message
87:15 - then forever and we use the plus
87:17 - operator to concatenate them and then
87:19 - plus equal to add them to W text in our
87:23 - test again we initialize the contract
87:27 - with the initial text hello then we
87:30 - create our scenario we add the contract
87:32 - to the scenario we call write message a
87:34 - first time with Anna and Jack we then
87:37 - verify that everything went well and W
87:40 - text contains hello comma and I inject
87:42 - forever then we call it again with tesos
87:46 - as the message and we verify that what
87:49 - text contains hello and inject forever
87:51 - then Tes us forever let's give it a try
87:56 - so it works we see that at the
87:58 - origination the content is hello then
88:00 - after the first call with the argument
88:03 - and un Jack and the result is hello and
88:06 - unj forever and then with another call
88:08 - with the argument tsos the new storage
88:11 - is hello un inject forever comma tsos
88:14 - forever all good in this very short
88:17 - module we will talk a little bit about
88:19 - the history of smart contracts the
88:22 - concept itself of smart contract was
88:24 - first proposed in 1996 by Nick Zabo in
88:29 - the first blockchains you only have a
88:31 - few types of
88:33 - transactions but some of them could run
88:35 - very basic scripts but those scripts are
88:38 - very limited on purpose you couldn't do
88:40 - any Loops for example for security
88:43 - reasons ethereum was the first
88:45 - blockchain with support for smart
88:48 - contracts and it was launched in 2015
88:51 - tesos was launched in 200 18 as a new
88:55 - smart contract blockchain that was built
88:58 - from scratch it focuses on the security
89:00 - of smart contracts along with unchain
89:04 - governance in a way the whole point of a
89:06 - smart contract is to say if you do that
89:10 - this will happen no matter what no one
89:13 - can stop it in this module you will
89:16 - learn how to write smart contract that
89:18 - do that through performing
89:20 - verifications the code of an entry point
89:23 - of have the same structure and should
89:25 - have the same structure first it checks
89:29 - that the call is allowed that you should
89:30 - be able to call at this time with this
89:33 - address with these parameters Etc then
89:36 - after checking that everything is good
89:38 - do stuff computations changing the
89:41 - content of the storage sending tests to
89:44 - people do all kinds of transactions and
89:47 - maybe check all the things to do the
89:50 - first part checking that things should
89:53 - be allowed we use the assert command and
89:57 - we give it the condition that should be
89:58 - checked so basically write assert then
90:01 - the condition so for example we could
90:03 - write assert this parameter should be
90:06 - lower than some Maximum value we can
90:10 - also provide an error message so that
90:12 - when the contract fails we know why it
90:15 - failed so we just write assert the
90:17 - condition comma and the string
90:20 - containing the error message if the
90:23 - assert fail so if the condition is not
90:26 - met everything that was done since the
90:29 - beginning of the transaction is
90:31 - cancelled it's just as if nothing had
90:34 - happened so if we take this example we
90:37 - assign the value for it to to some
90:40 - attribute of the storage and then we
90:42 - check assert that this value is lower
90:45 - than 10 so of course this assert will
90:48 - fail so that means if you put this in a
90:50 - smart contract the whole smart contract
90:53 - will fail and the value will never be
90:55 - set to 42 and this is no matter what the
90:58 - cause of the failure is so if you cause
91:01 - a failure of the contract because of a
91:03 - false condition of an asset or if you
91:06 - for example try to send more test from
91:08 - the contract then the contract has in
91:11 - its balance or if you call another
91:13 - contract and this other contract ends up
91:16 - failing for similar reasons whatever the
91:18 - reason why the contract fails or one of
91:21 - the transactions it's try to do fails
91:24 - then everything this contract was doing
91:27 - is cancelled and it's as if nothing at
91:29 - all had happened so basically it's all
91:32 - or nothing either everything works or
91:34 - nothing
91:35 - happens when you do verifications you
91:38 - can use the regular python comparison
91:41 - operators so for example if we have a
91:43 - variable C that contains an integer four
91:46 - we can check if it's greater than three
91:49 - lower than three greater or equal than
91:52 - four equal to four are different from
91:56 - five let's look at this example where we
91:59 - take our store value contract and we
92:02 - have simply an add entry point that
92:04 - takes a parameter and adds it to the
92:06 - store value we don't specify any
92:08 - constraint it could be a positive
92:10 - negative value anything you like we can
92:14 - try it and we see that we start with
92:16 - zero if we add one we end up with one
92:19 - and then at nine we end up with 10 as we
92:21 - verify here now let's say we want to
92:24 - make sure whoever it calls it doesn't
92:26 - add more than 10 for example so we could
92:28 - have an assertion assert added
92:33 - value is lower than 10 say and otherwise
92:38 - we display message
92:41 - too
92:43 - much okay now if we run it again it just
92:46 - works because we only try to add one
92:48 - nine but now let's try to
92:50 - add 10
92:57 - here we see that it fails and it
92:59 - displays the unexpected error too
93:02 - much we could also add an
93:10 - aerion that is a positive for
93:17 - example and again we can
93:22 - add minus
93:26 - 5 and then check and we will have the
93:29 - error needs to be
93:32 - positive we can also use Smart Pi's
93:35 - Boolean
93:36 - conditions so we introduce a type boan
93:40 - where value can be true or false and
93:42 - then we can create an Expression A and B
93:46 - that is true if and only if both A and B
93:49 - are true and then we can have the or
93:51 - operator that is true if either a or b
93:55 - or both are true and we can even use the
93:58 - exclusive or using the binary python
94:00 - operator um this side that means
94:02 - exclusive or that will be true if a is
94:07 - true or B is true but not both so
94:11 - exactly one of them has to be true for
94:13 - the whole expression to be true
94:14 - otherwise it's false and of course we
94:16 - have the not operator that text the
94:18 - opposite of the value of a so in our
94:20 - example instead of having two values we
94:23 - could just write
94:24 - here let's put this here the value is
94:29 - greater than zero and added value below
94:33 - 10 and let's say uh had a message not
94:38 - between Zer and let's say nine
94:42 - included so now if we write it we still
94:45 - have the error with the value minus 5
94:48 - that is not between 0 and 9 and if we
94:50 - come in this ver this line and try with
94:53 - 10
94:54 - then we have the same value for OD 10
94:57 - then this message appears so the issue
95:00 - here is that we do want to check that
95:03 - this fails when we add 10 but if we do
95:06 - that then it just stops our test right
95:07 - if I want to check that both Min -5 and
95:11 - 10 return an error well when I run it it
95:14 - stops at minus5 so I don't know for sure
95:17 - that um adding 10 also causes an error
95:20 - so to help with that we can add code in
95:24 - the scenario that will check when
95:25 - something should be failed so we
95:27 - actually test that the failures work so
95:30 - basically when we test a smart contract
95:32 - we need to both check that the contract
95:35 - doesn't fail when it should succeed so
95:37 - by testing with valid parameters making
95:39 - sure that it works but we should also
95:41 - check that if we pass the wrong
95:43 - parameters or call it the wrong time Etc
95:46 - the smart contract actually fails it's
95:48 - very important to test it so to test
95:51 - that without having the whole scenario
95:53 - completely stop we can make a call to a
95:56 - Smart contract entry point by passing
95:59 - invalid parameters but then we say we
96:01 - know that this is invalid and that's
96:03 - what we want to check so to do that you
96:05 - add an extra parameter with underscore
96:08 - valid equals false to say I know that
96:11 - this is false and this should fail and I
96:13 - expect it to fail so when you run it if
96:16 - it actually succeeds you will get an
96:18 - error message if it fails then all good
96:21 - it's going to continue to the rest of
96:24 - your scenario and of course if you put
96:26 - true here it will be the other way
96:27 - around true will means I expect this to
96:30 - be valid so it should work but true it's
96:32 - a default value so you don't need to put
96:33 - it when you expect it to work and you
96:35 - can also check what message is output by
96:39 - the error so you can add underscore
96:42 - exception equals and then the exact
96:45 - string that should be produced when this
96:48 - entry point fails with this parameters
96:51 - so let's give it a try here my fire
96:54 - should fail so we can write valid equals
97:02 - false so now it will run minus F will
97:05 - work and we only have the add 10 that
97:07 - doesn't do what is expected so we change
97:10 - the expectation by
97:12 - adding valid equals
97:16 - false then
97:18 - everything works so now you can see here
97:21 - this transfer failed but this is
97:24 - expected so it doesn't cause an error so
97:26 - it's displayed in the output of smart Pi
97:28 - you even have the value of the
97:30 - expression here not between zero and
97:32 - five so you can still check everything
97:34 - but it is tested automatically in your
97:37 - scenario if we want to check the error
97:40 - message we can add exception equals not
97:45 - between 0 and 9 so let's say I do the
97:49 - wrong exception and it's going to tell
97:50 - me no that's not the exception I
97:52 - expected I expect 09 and you sent
97:58 - 08 and of course I can put the
98:01 - same right here for this
98:03 - call and everything
98:06 - works I don't have to use
98:09 - strings when I generate exceptions
98:12 - exceptions can actually be of any type
98:15 - so for example if I want to send two
98:17 - values I cannot easily build a string
98:20 - using Python's F strings F strings if
98:23 - you no pythons are not supported so I
98:25 - cannot concatenate a piece of string
98:27 - with a number that was a smart contract
98:29 - there's no easy way to convert a number
98:31 - into a strings for example so you can
98:33 - create a mixed message that has text and
98:36 - numbers but what you can do is generate
98:38 - an error that is not a string but for
98:40 - example that is a pair I can use this
98:42 - syntax I put two values between
98:45 - parentheses and with a comma between
98:47 - them that is a pair we'll talk about it
98:49 - later and so instead of returning just
98:52 - this string I return a pair that
98:54 - contains this string and then this value
98:56 - let's give it a
98:58 - try so here instead of putting not
99:01 - between zero and five I can create a
99:03 - pair and add added
99:08 - value comma not between Z and nine and
99:12 - then here if I run it of course it will
99:14 - tell me I was expecting the string but I
99:16 - got a pair conents minus 5 and not
99:19 - between 0 and 9 so here I just change it
99:22 - to -
99:25 - 5 and then same
99:27 - here
99:32 - 10 okay so I can check here what the
99:35 - exact error was and including a value
99:38 - not it's your turn to give it a try I'm
99:40 - asking you to change the endless to
99:43 - contract to add verifications to it so
99:47 - the idea is to add verification so that
99:49 - people only add strings that have a
99:51 - length between three and three
99:54 - characters
99:55 - included this seems like a reasonable
99:57 - size for a message that will stay on the
99:59 - Chain forever and once you do that in
100:02 - your scenario please add test that make
100:04 - sure your contract does this very well
100:07 - you will need to get the length of a
100:10 - string so for that you can use this
100:11 - syntax sp. Len and then your string
100:14 - between
100:15 - parentheses and then you can validate
100:17 - the whole thing on open
100:19 - tiesos please pause the video and give
100:21 - it a try let's look at the solution
100:24 - so we still have our endless wall
100:25 - contract with the wall text that we
100:27 - initialize to this parameter and then in
100:29 - the right message entry point we add
100:32 - this line where we assert that the
100:35 - length of the message is lower or equal
100:37 - to 30 and the length of the message is
100:41 - greater or equal to three if not we
100:43 - simply produce the error in valid length
100:47 - if everything is good then we add the
100:48 - message and forever to the text in or
100:51 - test here
100:54 - we have to test both
100:57 - sides of each
100:59 - limit so here we have it limited 30 so
101:03 - 30 should be allowed but 31 should be
101:06 - rejected same here three should be
101:08 - allowed but two should be rejected so we
101:12 - test here with a message that contains
101:14 - 31 letters and we make sure it is
101:18 - failing then we test with two characters
101:21 - and we test that it is failing
101:23 - then we check that when the message is
101:26 - right above the limit so three
101:28 - characters should be the smallest text
101:30 - that works so we check that it works and
101:33 - same thing with this 30 character text
101:35 - we check that it works as well here
101:37 - would be good to check that the message
101:39 - is invalid length so let's add this
101:42 - exception equals invalid
101:50 - length and same here let's give it a try
101:54 - all good you can see here those two
101:56 - errors but it's just as
101:59 - expected Lo explorers like Bal Dev
102:02 - provide a user interface to explore
102:05 - contracts and accounts so we can find
102:07 - data about accounts their balance Etc
102:10 - find information about contracts what
102:13 - operations there have been on this
102:14 - contract was the current storage and you
102:17 - can even interact with the
102:20 - contract there's other kinds of
102:22 - explorers like TZ KT and TZ stats that
102:25 - have different types of
102:27 - features the contract that we just saw
102:30 - has already been deployed on ghostnet
102:32 - with this address so we can paste this
102:36 - address here and we will find this
102:38 - contract and we can explore so we can
102:40 - see that has been originated a long time
102:42 - ago and it's been used just a few times
102:46 - to call the right message entry point we
102:49 - can see the melon code we can see the
102:53 - current value of the storage so we can
102:55 - see a few
102:57 - messages and we can
103:00 - even interact with it so here I can
103:04 - interact with the default entry point so
103:06 - there's only one entry point called
103:08 - write message in this contract so the
103:11 - name is not kept it's just the default
103:13 - the only entry
103:14 - point and here I can put the value let's
103:19 - say smart pi
103:24 - and then I don't need any options I can
103:26 - simply execute it and I can use my
103:30 - wallet on
103:32 - ghostnet let's take
103:35 - Kai so it's asking me to confirm the
103:38 - transaction where I send zero TZ to this
103:41 - contract to call the default entry
103:44 - point so I confirm so the call was made
103:48 - it's
103:48 - confirmed I can go back to Bar Dev and I
103:52 - can check that a few seconds ago this
103:56 - right message was called I can check to
103:59 - see the details I can view the raw
104:01 - message you can see that the value of
104:02 - the parameter was smart
104:05 - pi and and I can see that it changes in
104:08 - added smart pie forever if I go back
104:11 - here and go to
104:14 - storage I can see smart P
104:20 - forever can see that each oper operation
104:23 - has a hash that I can use if I want to
104:26 - track this operation check that it's
104:29 - been added to the block and check that
104:31 - it's final before I do anything else so
104:34 - you can play around with baral Dev call
104:37 - this contract and see what
104:40 - happens now let's say we try to call it
104:42 - with an invalid value for example two
104:48 - characters let's give it a try I'll use
104:52 - my wallet
104:54 - then we can see here parameters invalid
104:58 - some of the parameters you provided are
105:00 - invalid and the request could not be
105:02 - completed please check your inputs and
105:03 - try again so we can see that I cannot
105:06 - call it with go and the same thing if I
105:09 - try to put let's say 31
105:14 - characters can do it like that 10 20
105:18 - 31
105:20 - execute using my wallet
105:23 - again it tells me parameters are
105:26 - invalid so if I go back to the operation
105:30 - I can see that this operation has never
105:32 - been run I don't have this new operation
105:34 - the last two that failed are not
105:36 - appearing I didn't pay for them the
105:38 - wallet just didn't let me run it because
105:40 - it simulated it realized this is not
105:43 - going to work don't even try don't even
105:45 - send it to the blockchain and so it was
105:48 - stopped before it was propagated and
105:50 - added to a block so to recap so far we
105:54 - have learned how to create our first
105:55 - smart contract we have learned how to
105:58 - create and deploy a smart contract to
106:00 - store a value in the contract using the
106:03 - types net int and
106:05 - string and we have learned to create one
106:07 - or more entry points each with a single
106:10 - parameter that checked the value of the
106:12 - parameter and then changed the value of
106:14 - the storage of the smart contract and
106:17 - finally we have learned to do test
106:19 - scenario that could check that
106:21 - everything was as EXP expected so far
106:24 - our smart contracts only stored one
106:26 - value and we only had entry points with
106:29 - one parameter it's pretty
106:31 - straightforward to add multiple
106:33 - parameters but there's a few important
106:35 - things to pay attention to if we want to
106:37 - put multiple values in the storage it's
106:40 - pretty basic we just need to have one
106:42 - line to assign a value to each value in
106:45 - the storage and we give them different
106:47 - names and we just have multiple
106:49 - parameters to the constructure so Min
106:52 - value
106:53 - will be stored in the minan value
106:55 - variable the storage and same thing with
106:57 - max value if we want to have multiple
106:59 - parameters for an entry point it's the
107:02 - same we just add another parameter with
107:04 - a comma behind the first parameter and
107:07 - we just give it another name and then we
107:09 - can use them for example to replace the
107:11 - values in the
107:12 - storage the part where you should be
107:14 - really careful is that when you call a
107:17 - smart contract entry point from your
107:19 - test
107:20 - scenario if the entry point has multiple
107:23 - parameters you need to name
107:25 - them so instead of just putting the two
107:28 - values separated by a comma I give the
107:30 - name of the first value equals the value
107:33 - I want to pass comma the name of the
107:36 - second parameter equals the value I want
107:38 - to the syntax doesn't work if I only
107:41 - have one
107:43 - parameter so if I only have one
107:45 - parameter I simply put the value if I
107:47 - add the name it it will not work the
107:49 - reason is that entry points actually
107:51 - only have one one parameter behind the
107:54 - scenes in the melon language so when we
107:57 - do this what we send is a single
107:59 - parameter in the form of a record so we
108:02 - create a record that contains those two
108:04 - values those two attributes and we send
108:06 - that record as the single parameter of
108:08 - the smart contract but we have a
108:10 - simplified syntax when we declare the
108:12 - entry point instead of saying we use a
108:14 - record that has multiple values Etc we
108:16 - just simply give the list of the
108:19 - attributes of the record and we will
108:21 - talk later about exactly how we use
108:23 - record but here records are used
108:25 - implicitly anyway all you have to
108:27 - remember is that when you call an entry
108:30 - point from a test scenario use the names
108:34 - if there's more than one parameter and
108:36 - don't put the name if there's only one
108:39 - parameter we can use an example we will
108:42 - change our store value contract to store
108:45 - a range of value with two numbers minan
108:48 - value and max value then we will have an
108:51 - true Point set that will change these
108:54 - values and we will also have an entry
108:56 - point add number that would add the same
108:58 - value to both the num minm and the
109:01 - maximum value of our wrench and of
109:03 - course we'll create a test scenario to
109:05 - check
109:06 - everything and again remember in a test
109:08 - scenario when we pass multiple
109:10 - parameters we have to name
109:12 - them let's look at our example so here
109:16 - we have our constructure and as
109:18 - parameters we have the two initial
109:20 - values that we want to set in the
109:21 - storage Min value and max value we want
109:25 - to set that those are integers using sp.
109:29 - cast of minan value s sp. in then we
109:32 - just assign them to the storage then we
109:34 - have an entry point set that takes again
109:37 - two parameters actually it's just one in
109:39 - the form of a record but we see them as
109:41 - two parameters new Min value and new max
109:44 - value we assign them to the two
109:46 - variables in the storage then we have
109:49 - ADD number where we have one value that
109:51 - we will add to both minan value and max
109:54 - value and we have a test where we create
109:57 - an instance with minan value equals zero
110:00 - max value equal to five then we call set
110:03 - again naming the parameters new minan
110:05 - value and new max value we verify that
110:08 - they have been set and here I can show
110:11 - that if instead of calling
110:16 - this I simply call this directly with
110:19 - the value
110:22 - then I get an error because it says
110:25 - entry point expects paramet of type of
110:27 - Nots but it got in or not and it says
110:29 - expected a record with two attributes
110:32 - new max value and new my value Etc but
110:36 - instead we got one number so that's
110:38 - because it's just checking the first
110:40 - parameter it sees that it's not a record
110:43 - it's just a number and it's checking
110:45 - that against the rec cord that contains
110:48 - both parameters and it doesn't like it
110:49 - because it doesn't look the same so if
110:52 - you see this kind of error message that
110:54 - talks about records then remember that
110:57 - it may be because you forgot to give
111:00 - names to your parameters in your
111:08 - scenario okay so then we add a number
111:11 - check the result add a number again
111:17 - everything so here you may wonder why uh
111:20 - explicitly said that Min value was an
111:23 - integer and the reason is that if I
111:26 - don't do that smart P tells me that
111:30 - there is an unresolved constraint so
111:32 - basically it says here those cannot be
111:35 - added and basically that's because it
111:37 - doesn't really know the
111:39 - type of minan value so when I add
111:42 - something to minan Value it doesn't
111:44 - really know what to type we had no hint
111:46 - other than this to tell us if Min value
111:49 - is a nut an INT a string or something
111:52 - else so we have to give some information
111:57 - about what type it is but if we only
111:59 - give the type of Min value the type
112:02 - inference system can infer that since
112:06 - Min value is of type int the parameter
112:09 - Min value is of type in therefore the
112:12 - storage is of type int therefore a has
112:16 - to be of type int therefore max value
112:19 - also has to be of type int therefore
112:21 - this max value has to be of type int
112:24 - this one has to be of type int this one
112:26 - has to be of type int so just by adding
112:28 - this single information that says Min
112:31 - values and int everything else can be
112:34 - determined by the type inference so
112:37 - we're starting to write contracts are a
112:40 - little bit more complex and that means
112:42 - sooner or later we will have bugs so
112:44 - it's important to learn how you can
112:46 - debug smart contracts one way to debug
112:49 - smart contracts is to cut them into
112:51 - pieces for example if I have an error
112:53 - that I don't understand I could try to
112:55 - see well let's see in which entry point
112:57 - causes the error so I could easily
113:00 - delete this entry point
113:03 - delete the calls to this entry point and
113:06 - check do I still have my error if I'm
113:08 - completely lost I can just use binary
113:10 - search basically by deleting half of the
113:12 - contract to see if that
113:15 - helps but another tool to help me debug
113:20 - is to get some information about what's
113:22 - going on inside of an entry point and
113:24 - for that I can use the trace function to
113:27 - print any value that I use in my entry
113:31 - point if I'm using the smart Pi IDE the
113:34 - output will be in the browser console
113:37 - and if I run it on the common line it
113:40 - will be simply sent to the uh standard
113:43 - output so for example I have this entry
113:46 - point make call after I increment and
113:48 - because Trace so output on the console
113:51 - or on the stand
113:53 - output the value that number call has
113:56 - now let's give it a
113:58 - try here if right after and because plus
114:02 - equals one I use Trace to put a string
114:06 - and then Trace to Output this
114:09 - value I run it I don't see anything
114:12 - special here but if I open the browser
114:14 - console so on Google Chrome it's control
114:17 - shift
114:18 - J I can see here the output and we call
114:22 - 1 and equals 2 so I can clear it with
114:26 - contrl L to make sure I only see what's
114:28 - the output of the execution I run it I
114:31 - see okay n equals one n equals 2 I could
114:34 - also use pairs so for
114:37 - example I put parenthesis here
114:43 - comma here I'll do contrl L and if I run
114:48 - it I can see n equals 1 n equals 2 it's
114:50 - a bit easier to read that can help me
114:53 - understand what's going on in my
114:54 - contract and fix
114:57 - bugs let's practice on an exercise I
115:00 - will ask you to modify the endless wall
115:03 - contract so that it now counts the
115:06 - number of times it's been called so the
115:08 - number of times that messages have been
115:10 - added to the text in a new variable in
115:13 - the storage and then please change the
115:17 - right message entry point so that it
115:19 - takes two
115:20 - parameters both a name and a
115:24 - message it should check that the length
115:27 - of the name is between three and 10
115:29 - letters you should still check the
115:31 - length of the message itself is between
115:34 - three and 30 letters but you just add
115:36 - this new check on the name and then with
115:38 - these parameters it will add a comma
115:41 - then the name a column a space then the
115:45 - message and finally forever to the text
115:48 - so we'll have the name and then the
115:50 - message and then forever
115:52 - and of course please check everything in
115:55 - your test scenario and use this as an
115:58 - opportunity to practice using trays and
116:01 - print internal values and see how it
116:03 - works so please pause the video and give
116:05 - it a try let's take a look at a solution
116:08 - so in the storage we added this variable
116:11 - NB calls that we initialize at
116:15 - zero then we modified the right message
116:18 - entry point to add a name parameter we
116:22 - still have our assertions on the length
116:24 - of the message we change the error
116:27 - message to clarify that it's an invalid
116:30 - message length then we added a second
116:33 - assertion this time on the length of the
116:35 - name with a message that says invalid
116:38 - name
116:39 - length and then we change W text to add
116:43 - comma the name column message and
116:46 - forever then finally we increment the
116:49 - value of NB calls at every call in our
116:51 - test
116:53 - scenario whenever we call write message
116:56 - we need to give the name of the first
116:58 - parameter message equals the value we
117:01 - want to send and same thing with the
117:03 - second parameter the name equals and the
117:06 - value we want to send so we make a
117:09 - couple calls that are valid we verify
117:12 - that the output is what we expect we
117:14 - verify that the number of calls is what
117:16 - we expect and finally we try a few calls
117:19 - that would fail we try to send message
117:22 - that is 31 letters long and so this is
117:25 - false and should generate an invalid
117:28 - message length error same thing with a
117:31 - message that is too short a name that is
117:34 - too short a name that is too long and
117:38 - then finally we write some messages that
117:41 - are exactly the minimum we need so three
117:44 - letters in the message three letters in
117:46 - the name and then the maximum so 30
117:49 - letters in the message and then 10
117:51 - letters in the name this is exactly 10
117:53 - letters and we check again that the
117:55 - number of calls is correct we can give
117:58 - it a try and we see that it worked we
118:02 - start with hello then we call it with a
118:06 - message an Jack and the name Anna we can
118:08 - see that we now have Hello Anna Colin
118:11 - Anna and Ja forever and after another
118:14 - call from Joe we have Joe Tes us forever
118:18 - and then two calls we have those four
118:22 - test that didn't work and then finally
118:25 - another two that
118:27 - worked all good in this module you will
118:31 - learn how to manipulate addresses in a
118:33 - smart contract which will make your
118:35 - smart contracts a lot more powerful as
118:37 - tesos is a public blockchain it is
118:39 - permissionless that means anyone can
118:42 - participate in the network anyone can
118:44 - emit transactions anyone can create
118:46 - accounts Etc however when they do so
118:49 - they are authenticated based on their
118:51 - address
118:52 - so their address is attached to their
118:54 - balance and their transactions are
118:56 - attached to their balance and whenever
118:59 - we execute a transaction we can know for
119:02 - sure that this transaction has been
119:04 - emitted by whoever owns the private key
119:07 - of this address so they are directly
119:09 - attached to a specific address and when
119:12 - you use addresses in smart contract that
119:15 - makes it very powerful you can
119:17 - authenticate users that call the smart
119:19 - contract so you can basically Implement
119:21 - fine grain access
119:24 - control and you can also use these
119:26 - addresses to assign ownership to any
119:29 - digital asset you have already
119:31 - manipulated addresses you know that TZ
119:34 - addresses correspond to user accounts
119:37 - and KT addresses correspond to the
119:41 - address of smart contracts you
119:43 - deploy and each of these addresses
119:46 - uniquely identify either a user or a
119:49 - contract and the TZ addresses are based
119:52 - on the hash of the public key of the
119:55 - users also include a check sum so you
119:57 - cannot just write a random sequence of
119:59 - numbers after TZ the checkm has to be
120:02 - valid from a smart contract you can
120:04 - manipulate addresses for example you can
120:08 - obtain the address of the direct Coler
120:11 - of the contract it could be a user or it
120:13 - could be another smart contract you can
120:16 - also compare two addresses so you can
120:19 - check if the address of the color is
120:22 - equal to some expected address so that
120:25 - enables Access Control you can also send
120:28 - TZ to a given address or you could call
120:31 - another smart contract based on its
120:33 - address on the other hand there's a few
120:35 - things you cannot do you cannot check
120:37 - the test balance of some address whether
120:40 - it's a user or of a contract from a
120:42 - smart contract you only have access to
120:44 - your own
120:45 - balance and you cannot read the storage
120:48 - of another contract either you can only
120:50 - read the storage of the cont cont ract
120:52 - that you're
120:53 - executing let's look at some syntax to
120:56 - manipulate addresses so if you want to
120:58 - create an address value you simply write
121:01 - sp. address and then between parenthesis
121:04 - and between double quotes you just give
121:06 - the actual value of the address so a tz1
121:09 - address or a kt1 address if you want to
121:14 - express the type of an address you
121:16 - simply write sp. address you have access
121:19 - to the address of the direct color of
121:21 - the smart contract through sp. sender
121:25 - and if you want to know the address of
121:27 - the contract itself that you are
121:29 - currently running you can use sp. self
121:33 - address So that's its own address in
121:35 - your test
121:37 - scenario you can create test accounts
121:40 - for fake accounts just for the purpose
121:42 - of the test using sp. test account and
121:46 - then a name that you can give so you can
121:49 - store it in in a variable
121:52 - then when you call Smart contract and
121:55 - need to send the address of one of these
121:57 - accounts as a parameter of your smart
121:59 - contract you can simply use the name of
122:02 - the variable where you store the account
122:05 - do address so this will send tz1 address
122:09 - of that user and finally if you want to
122:12 - call a smart contract and say this call
122:14 - has been made by this user so the sender
122:19 - of this transaction is this specific
122:21 - user
122:22 - you can add a parameter when you call a
122:24 - smart contract entry point underscore
122:27 - cender equals then the variable that
122:31 - contains the account so here you're
122:33 - saying I'm calling the increment entry
122:36 - point with the parameter five as Alice
122:39 - using Alice as the center of this entry
122:43 - point so from the smart contract sp.
122:45 - Center will be the address of Alice
122:47 - let's work on an example we will change
122:50 - the store value cont contract so that
122:53 - only the owner of the contract is able
122:56 - to call the reset entry point and then
122:58 - of course we will add test to this new
123:01 - version of the store value contract here
123:03 - is our modified store value contract so
123:06 - on top of storing the value 42 initially
123:11 - the Constructor takes a parameter owner
123:14 - that we assigned to another variable in
123:16 - the
123:17 - storage then in the reset entry point we
123:20 - add an assertion we checked the sender
123:23 - so whoever is calling that entry point
123:26 - we check that is actually the owner that
123:29 - we stored here so we check that this
123:31 - address is equal to this address so that
123:34 - only the owner can reset in our test
123:37 - scenario we create a couple of account
123:39 - Alice and Bob and then when we
123:42 - instantiate our contract we say that the
123:44 - owner is
123:45 - Alis and finally when we call reset we
123:49 - first try with a sender being Bob so we
123:54 - call it with an address that's different
123:56 - from the owner that we defined here so
123:59 - of course we say valid equals false
124:01 - because we expect this to
124:03 - fail and then we try a call that should
124:07 - work by calling reset as alist so this
124:10 - is not sending in a parameter this is
124:12 - just saying that we simulate this call
124:14 - to reset with no parameter but where the
124:17 - transaction is emitted by
124:20 - Alice finally we verify that reset was
124:23 - correct and we check that is equal to
124:25 - zero let's give it a
124:26 - try here we can see that when we insten
124:29 - the contract the value of the owner is
124:32 - tz1 WXR so this is Alice's address then
124:37 - we call the add entry point we see that
124:39 - here the sender is not defined because
124:41 - we didn't specify any sender
124:44 - here when we try to reset as Bob we can
124:48 - see that the sender here is a different
124:50 - address so not Alice Alice was tz1 WX
124:55 - Etc here we call it as tz1 RP Etc so it
124:59 - doesn't work only owner can reset then
125:02 - we do another transfer this time as
125:04 - alist tz1 WX Etc and this one works and
125:08 - of course we reset the value to zero now
125:10 - it's your turn modify the endless wall
125:14 - contract so that the same user can't add
125:17 - text twice in a row basically we want to
125:20 - do a very basic spam prevention so we
125:23 - don't want the same user to send two
125:25 - messages in a row which means between
125:28 - two calls from a given user at least one
125:31 - other user should have added text
125:35 - otherwise we reject the call please
125:37 - pause the video and give it a try let's
125:39 - take a look at a
125:41 - solution here in the constructure we
125:44 - take two parameters the initial value of
125:46 - the text and the address of the owner so
125:50 - we initialize well text to this initial
125:52 - value we initialize the number of calls
125:54 - to zero and then we initialize the last
125:57 - sender as the
126:00 - owner so this address this is an address
126:03 - where we will store who is the last
126:05 - person who called right message but we
126:09 - have to initialize it with some address
126:11 - so we decided that we would use some
126:13 - address that is the owner of the smart
126:15 - contract so we say the owner deploys
126:18 - their contract they shouldn't be the one
126:20 - sending the first mess message and if
126:22 - they want to be the one sending the
126:23 - first message they can just send a
126:25 - different address
126:26 - here then in the right message entry
126:29 - point so we have this version where we
126:31 - only send a message we add an assertion
126:34 - that the value of the sender so whoever
126:38 - is calling this entry point should be
126:40 - different from whoever we have stored in
126:43 - last sender then we add the message to
126:45 - the wall we increment the number of
126:47 - calls and then we update last sender to
126:50 - whoever is calling this entry point so
126:53 - this means that once we have a first
126:54 - call the next call cannot be by the same
126:57 - person because the next call shouldn't
126:59 - have sp. sender equal to last sender we
127:02 - can have our test scenario where we
127:04 - again create a few
127:06 - accounts and then we first write a
127:10 - message using Eve as the sender then we
127:14 - write a second message where we use Bob
127:17 - as sender this should be fine but then
127:20 - we add another message where it's Bob
127:22 - again try to send some messages so this
127:25 - should fail and then the next one we
127:28 - send it at Alice again so it works and
127:31 - in between we tried with Alice but with
127:33 - a wrong length of the message so this
127:36 - entry point was never executed and it's
127:38 - cancelled so now Alice can send a
127:41 - message again because the previous
127:43 - person to send a message successfully
127:45 - was Bob let's give it a
127:48 - try okay we can see here that initially
127:51 - we have last sender that's the address
127:53 - of Alice tz1 WX
127:56 - Etc then we have write message sent by
128:00 - Eve tz1
128:03 - NW then we have write message sent by
128:06 - Bob so a different address tz1 RP and
128:09 - every time we can see that the last
128:11 - sender has been updated to whoever is
128:13 - calling this message so I'm here now
128:16 - send her update to
128:18 - Eve so now again we have Bob train to
128:21 - call but L sender is set to this value
128:24 - so this is
128:25 - rejected we can try again then we send a
128:29 - message that's too long then we have
128:31 - another person try to send it Etc all
128:34 - good in this module you will learn how
128:37 - to create your own nft smart contract
128:40 - and you will find out that the few
128:42 - features we have presented in the
128:43 - previous modules already make smart
128:45 - contracts very powerful and useful the
128:48 - few Concepts we have presented so far
128:51 - integers Naturals strings addresses
128:55 - entry points storage and
128:58 - verifications already give smart
129:00 - contracts a lot of power you can use
129:02 - them to store data forever you can
129:05 - attach users to data through their
129:08 - address which can enable ownership and
129:10 - with verifications access control and
129:13 - smart contracts are unique thanks to
129:15 - their address on a unique blockchain
129:19 - finally they can execute code that will
129:21 - change this data and perform
129:23 - transactions based on pretty fine and
129:26 - most importantly unalterable
129:28 - rules all this makes it possible to
129:32 - create any type of digital asset with
129:35 - two properties scarcity and ownership
129:38 - anyone can create their own unique
129:40 - digital assets on tizel you probably
129:43 - already have heard about nft so nft
129:45 - stands for non-fungible tokens and an
129:49 - nft is a digital asset
129:52 - that is unique uniquely identifiable it
129:55 - contains some information it's metadata
129:58 - that could be anything an image for
130:00 - example or some text it has an owner and
130:05 - it can be transferred and that's it
130:07 - that's what defines an nft non Venable
130:09 - token so a token that cannot be split
130:13 - that is unique and that can be
130:15 - transferred because they clearly
130:18 - identify the ownership of an item nfts
130:22 - can identify the ownership of any
130:25 - digital or physical art or collectible
130:28 - such as paintings music or in-game
130:31 - assets they can also represent real
130:34 - estate or any other physical assets or
130:37 - they could be used to represent more
130:39 - temporary assets such as tickets for a
130:42 - concert or any event passes and if you
130:44 - also provide a number of benefits like
130:47 - everything on a blockchain when used
130:49 - well they don't depend on a third party
130:52 - so for example you could transfer an nft
130:54 - without having a third party authorize
130:57 - or be the intermediate for this transfer
131:00 - they also provide a temper proof record
131:02 - of the ownership of the Em which makes
131:05 - it easier to track if you're really
131:07 - buying the right thing if basically it
131:09 - prevents
131:10 - counterfeiting you know that what you're
131:12 - buying is the original nft and you can
131:15 - see who sold it first Etc they make it
131:18 - possible to trade on new marketplaces
131:21 - that are available worldwide without
131:23 - restrictions so this increases
131:26 - accessibility as well as liquidity and
131:28 - can increase the value of these assets
131:31 - and finally they offer the possibility
131:33 - to add a number of features such as
131:36 - automatically paying royalties to
131:39 - artists when you transfer the nfts
131:41 - there's actually nothing new to learn
131:43 - for you to be able to create your own
131:45 - nft contract so based on what we just
131:47 - described you can already write your
131:50 - first nft contract so the idea is to
131:53 - create a contract that will represent a
131:55 - single nft to do that you have to keep
131:59 - in mind that the nft needs to be
132:01 - uniquely
132:02 - identifiable that it will contain some
132:04 - information that we call metadata that
132:08 - it has an owner and that it can be
132:11 - transferred so give it a try pause the
132:14 - video and try to create your own NFD
132:17 - contract if you're stuck come back and
132:20 - we'll give you some hints okay let's
132:21 - talk about some hints on how to create
132:24 - an nft smart contract when you create
132:27 - your smart contracts the most important
132:29 - thing is to determine what you will
132:31 - store in your smart contract and what
132:33 - the different entry points will be then
132:35 - it gets easier to write the code of each
132:38 - entry point so if we think about what
132:40 - the contract would store we need to
132:43 - think about its different
132:44 - properties we said that the nft contract
132:48 - has to be unique but every contract is
132:50 - already unique as it is identified by
132:52 - its address so it makes it unique on a
132:55 - given
132:56 - blockchain so we actually don't need to
132:58 - do anything about that we just rely on
133:00 - the uniqueness of our smart contract the
133:04 - nft has to have an owner we can simply
133:06 - store it as an address in our contract
133:10 - same thing for metadata we can have
133:12 - metadata in the storage of our contract
133:14 - for example as a string it could simply
133:16 - be your names first
133:18 - nft finally it has to be transferable
133:21 - so for that we need to be able to change
133:23 - the owner so that means we need an entry
133:27 - point that will update the address of
133:29 - owner but of course only the current
133:32 - owner should be able to initiate this
133:34 - transfer with those hints in mind pause
133:36 - the video give it a try make sure
133:39 - everything's good in your smart contract
133:41 - and don't forget to test it well let's
133:43 - look at a
133:44 - solution so we can see here this single
133:47 - basic nft smart contract and we can see
133:49 - that it's very
133:51 - lightweight in the storage as we
133:54 - described in the hints we have the owner
133:56 - that we initialize with the first owner
133:58 - so whoever is deploying this contract
134:00 - can set this value to their own address
134:03 - then we have the metadata here we uh
134:06 - simply hardcode it in the Constructor we
134:08 - could also pass it as a parameter but
134:10 - the same thing is when you deploy your
134:11 - contract you define what the value of
134:14 - the storage is initial as we already
134:17 - described the uniqueness of the enf is
134:19 - already given by the unique address of
134:22 - the smart contract so there's nothing
134:24 - you need to do about that and finally we
134:27 - create this transfer entry point where
134:30 - we pass the address of the new
134:32 - owner then the entry point checks that
134:36 - the current owner is indeed the one
134:39 - who's trying to do the transfer so we
134:40 - check that the sender is equal to the
134:43 - owner otherwise we have this exception
134:46 - and if that's the case we assign the new
134:49 - owner to the storage
134:51 - that's it and of course we need to test
134:54 - it well so we create a few accounts we
134:57 - instantiate our nft we say Alice is the
135:00 - original owner we keep this metadata as
135:02 - the original metadata then we can create
135:05 - our test scenario and we try a few
135:07 - transfers here we transfer to Bob we
135:10 - check that indeed it was transferred to
135:12 - Bob we check the metad data is what we
135:14 - think then Bob can transfer to Eve so we
135:18 - check that the new owner is inde the eve
135:23 - then Bob can transfer the nft to Eve and
135:26 - we check that Eve is indeed a new owner
135:29 - and finally Eve can transfer to Alis and
135:32 - we check that this is good so here we
135:35 - missed something right our test is not
135:38 - complete it's important to keep in mind
135:41 - that you should always test the case
135:43 - where everything goes well but also test
135:46 - cases where people try to do things that
135:49 - are not allowed so of course here we
135:52 - have this assertion that checks that
135:53 - whoever is trying to do the transfer is
135:55 - the current owner we need to make sure
135:58 - we check this assersion in our test so
136:01 - we need to add this
136:02 - verification of trying to
136:05 - transfer for example to
136:09 - Bob but
136:12 - as someone who's not the current owner
136:15 - so Alice is the current owner so let's
136:17 - try transfer to Bob as Eve and and we
136:21 - expect this to be failing so we write
136:24 - valid equals false and the
136:29 - exception
136:32 - equals not your
136:35 - property let's give it a
136:38 - try all good so we start with this owner
136:43 - this is Alis tz1 H4 Etc metadata first
136:47 - nft we have this unique address that
136:50 - identifies contract therefore nft so
136:53 - Alice transfers to this person that's
136:56 - Bob and so we can show that the owner
136:59 - has changed then we transfer to Eve we
137:02 - can see that the owner has changed Etc
137:06 - and finally we tried transfer to Bob by
137:10 - Eve but we have the exception as
137:12 - expected not your property so everything
137:15 - is good and now we have our first nft
137:18 - smart contract if we deploy this smart
137:21 - contract we are creating an nft that
137:23 - will be on the blockchain forever that
137:26 - we can transfer and that has its own
137:28 - metadata of course you want to create
137:30 - nfts with maybe more interesting
137:33 - metadata than this but this is actually
137:36 - really an
137:37 - nft of course it's still a very
137:40 - lightweight nft and it's missing some
137:43 - features that we really expect to make
137:46 - nfts convenient the main one is that
137:50 - doesn't make it easy to securely trade
137:52 - it against currency or other nfts in
137:55 - particular you can transfer it but
137:57 - there's no secure way to sell it without
137:59 - taking a risk that's really the main
138:02 - issue with this smart contract the next
138:04 - one is having one contract for each nft
138:07 - is not very convenient it makes it
138:09 - expensive because you have to pay for
138:11 - each deployment T us the fees are
138:14 - reasonable enough but still you have to
138:16 - pay for the storage of each contract
138:18 - that's not ideal and finally it doesn't
138:22 - follow any standards there are nft
138:25 - standards that make it easy for nfts to
138:28 - interact with different tools with
138:30 - wallets with uh marketplaces Etc so if
138:33 - you use this very simple nftd contract
138:35 - you really won't be able to trade it
138:38 - much and benefit from all the
138:40 - possibilities of
138:42 - nfts but in the next modules you will
138:45 - learn how to address these issues and
138:47 - add these possibilities and more to your
138:50 - nft control on blockchains everything is
138:53 - about trust on one side it's about not
138:57 - having to rely and trust a third party
139:00 - for things to happen as
139:03 - expected and on the other side it's
139:05 - about trusting that things will happen
139:09 - exactly as they are supposed to exactly
139:11 - as a smart contract announced things
139:13 - would happen and blockchain is also
139:15 - about the underlying cryptocurrency in
139:17 - the case of tesos it's all about TZ
139:21 - in this module we will see that both
139:23 - complement each other that TZ can
139:25 - increase the trust you have and its
139:28 - trust that gives the value to the
139:31 - cryptocurrency a public blockchain is a
139:33 - system that anyone can use without
139:36 - necessarily revealing their
139:38 - identity and it's also a system that has
139:40 - a lot of value at stake so if anyone can
139:43 - use it without revealing who they are
139:45 - and if there's a lot of value at sck
139:47 - what could possibly go wrong all this
139:50 - can only work if most participants
139:52 - behave well so the question is how can
139:55 - we make sure they do pause the video and
139:58 - think about it for a moment before you
140:00 - continue if we take our previous example
140:04 - of a contract that allows people to post
140:06 - text on a wall forever how can we
140:09 - prevent someone from flooding or wall
140:13 - with all kinds of messages we tried
140:16 - preventing the same user from calling
140:18 - twice in a row as an example on how to
140:21 - use addresses but this doesn't really
140:24 - protect from anything it's very easy for
140:27 - a user to create many different
140:28 - addresses and in our case we only needed
140:31 - to create two addresses and switch back
140:34 - and forth between the two addresses to
140:36 - post as many messages as we
140:38 - wanted another approach could be to
140:40 - restrict access to a set of trusted
140:43 - people but that would really defeat the
140:46 - purpose of the contract and the whole
140:48 - idea of blockchains where anyone can can
140:51 - join so it would be too limiting and
140:54 - complicated to use it's possible but
140:56 - it's not really the goal of this
140:58 - contract it also wouldn't be 100% safe
141:01 - just because you think you trust someone
141:03 - doesn't mean they're going to behave
141:04 - well still focusing on this endless wall
141:07 - contract can you think of an approach
141:10 - that could work to prevent people from
141:12 - spamming the wall with tons of
141:14 - messages give it a moment and pause the
141:17 - video before you continue one way to
141:19 - prevent excess iive use of a smart
141:21 - contract is to rely on a financial
141:24 - incentive all you have to do is charge
141:27 - one Tes every time someone wants to add
141:30 - a message to the wall if you really want
141:32 - to post a message and keep it forever
141:34 - one test is not much but if all you're
141:37 - trying to do is to spam the wall with
141:39 - all kinds of junk then one test for
141:42 - every message is starting to be
141:44 - expensive so by charging one t for each
141:47 - message you make sure that people don't
141:49 - abuse it at the same time you can use
141:52 - this test as a way to fund the
141:54 - development of our nice app that
141:56 - showcases this wall contract and makes
141:59 - it easier for users to post their
142:02 - messages on it as we're starting to see
142:04 - cryptocurrency is useful for much more
142:06 - than speculation or simply storing value
142:10 - you can use it as part of the blockchain
142:13 - security you can use it as a punishment
142:15 - for bad behavior that's what we do to
142:18 - prevent double baking through the
142:20 - slashing of the baker deposits you can
142:23 - use it as a reward for behaving well so
142:26 - for Bakers it's about a reward for
142:28 - baking or denting bad behavior and you
142:32 - can also use it as a way to prevent
142:34 - excessive use that's what we do when we
142:37 - have this system of gas to prevent
142:39 - people from using excessive computation
142:41 - from the network or storage fees to
142:45 - prevent people from using excessive data
142:47 - on the network so we can see that
142:49 - cryptocurrency is is used to increase
142:51 - the trust that we have in the blockchain
142:54 - and the fact that it behaves well and
142:56 - reliaable the same can be said about
142:58 - smart contract and you can use
143:01 - cryptocurrency as a way to increase the
143:04 - security of smart contracts you can use
143:07 - it as punishment by asking people to
143:09 - deposit some Tes that may not be
143:12 - returned if they don't behave correctly
143:15 - you can use it as rewards that users can
143:18 - obtain for providing a service
143:21 - or maybe dening bad behavior and you can
143:24 - use it in your smart contract to prevent
143:26 - excessive abuse by charging fees as we
143:29 - discussed instead of setting strict
143:32 - limits and rules that may limit
143:34 - legitimate use of your smart contract
143:37 - how do we do that when you call a smart
143:40 - contract the caller may send some Tes to
143:44 - this contract these ts are added to the
143:46 - balance of the contract and they also
143:49 - may be sent to to another address by the
143:51 - contract so that's how we can have a
143:54 - contract that charges a fee for example
143:57 - let's look at the syntax we have Type M
144:00 - TZ that can be used to express amounts
144:03 - of Tes that we manipulate in the
144:05 - contract we can create values for
144:08 - example if we want to have a variable
144:10 - that stores 12 TZ we can write sp. TZ of
144:14 - 12 or we can write it in the actual unit
144:18 - that's underneath that is the mutes a
144:20 - millions of Tes and so we can write sp.
144:24 - mes of 12 million this is the same as
144:27 - this so sp. T of 12 is a shortcut when
144:30 - you want to manipulate a whole number of
144:32 - Tes but the actual type is the mess of
144:35 - Tes the mutas within a smart contract
144:39 - you can check how much the color of the
144:42 - smart contract transferred to this
144:44 - contract by using sp. amount you can
144:48 - also check how much is currently in the
144:50 - balance of the contract with sp. balance
144:53 - that includes the amount that has just
144:56 - been sent by the caller but finally you
144:58 - can send some Tes to an address by using
145:02 - sp. send the address and then the amount
145:05 - that you want to send not that this is
145:08 - generating a transaction that is not
145:10 - immediately executed it's added to a
145:13 - list of transactions that will happen
145:15 - after the end of your entry point in
145:18 - your test you can test the transfers of
145:22 - Tes so for example when you call an
145:25 - entry point you can specify who is
145:27 - calling it and how much they're sending
145:29 - to the entry point by adding underscore
145:33 - amount equals and the amount you want to
145:36 - send from this user to the
145:40 - contract within your test you can also
145:42 - check the balance of the contract just
145:45 - simply by writing contract. balance on
145:48 - the other hand it's not currently
145:49 - possible and smart P to check the
145:51 - current balance of a test account so
145:54 - after here Alice sends some test to the
145:57 - entry point you cannot check that the
146:00 - amount Alice has on her balance has
146:02 - indeed decreased by five you could do it
146:05 - by using a smart contract instead of a
146:07 - regular account we'll see later how we
146:09 - can do that so it's really important to
146:12 - understand that on tesos at least on the
146:14 - L1 that we're working on with smart py
146:18 - when a contract charges a fee for a ser
146:20 - Serv the contract doesn't take the test
146:23 - from the account it's the caller of the
146:26 - contract who is the one who sends the
146:28 - right amount of test to the contract all
146:32 - the contract does is to check if it's
146:35 - happy with the amount that the caller
146:37 - sent and if it's not happy with it it
146:39 - can fail and basically reject the call
146:43 - but by default any Tes that are sent
146:46 - during a call are automatically added to
146:48 - the contract's balance so the contract
146:50 - does doesn't have anything to do to
146:51 - accept the Tes all it can do is
146:54 - potentially reject it if the amount is
146:58 - not what it wants so this is important
147:00 - in particular because this is not the
147:02 - case for all blockchain but that's how
147:04 - it works on tesos let's look at a
147:05 - version for Endless W contract where we
147:08 - charge one Tes every time someone calls
147:10 - right
147:11 - message all we had to change was to add
147:15 - this line where we check that the amount
147:18 - of Tes sent by the sender
147:20 - is one test if not we generate an error
147:24 - incorrect amount and everything is
147:27 - cancelled that's all we need to make
147:29 - sure people pay one test whenever they
147:31 - want to write a
147:33 - message in our test
147:36 - scenario we can check that if we indeed
147:39 - do send one test everything works but to
147:43 - check that it's really exactly one t we
147:45 - can check a little bit less and this
147:47 - should fail and cause the exception
147:48 - incorrect amount and same thing if we
147:51 - send a little bit
147:53 - more it will cause the same error and
147:56 - it's always good to have a second call
147:58 - to check that we can indeed call twice
148:01 - by paying the right amount let's give it
148:03 - a
148:04 - try everything worked so we can check
148:07 - towards the end this is the first call
148:10 - where we send one t with we can see that
148:15 - it added the
148:17 - text testing the right amount
148:22 - and then here we tried with a tiny bit
148:24 - less and generate the error same here
148:27 - with a tiny bit more and then if we send
148:30 - one test again everything
148:31 - works this contract actually has a very
148:35 - terrible flaw and things would end sadly
148:39 - for the author of the contract and it's
148:41 - a real flaw that people have made in the
148:44 - past and have lost large amounts of fund
148:47 - so it's very important to have this flaw
148:49 - in mind and avoid having it in your own
148:52 - contract so the question is can you
148:54 - figure out what that flaw is and then
148:58 - can you fix it take a good look at the
149:00 - contract pause the video and try to find
149:03 - the flaw as we stated earlier the test
149:06 - sent to a contract or added to its
149:08 - balance and by default that means these
149:11 - T are stuck forever in the contract
149:15 - there is no notion of owner or author of
149:18 - a contract on tesos unless you
149:21 - specifically assign a value to an oral
149:23 - variable in the smart contract so that
149:26 - means by default no one can get these
149:28 - Tes out of the contract that means the
149:32 - Tes in the balance of the contract are
149:35 - wasted if we want to avoid wasting them
149:38 - we need to specify an owner of the smart
149:40 - contract that will receive this T and
149:43 - make it possible for this owner to
149:45 - collect the
149:47 - tests to do that one way is every time
149:51 - someone writes a message to send the
149:53 - corresponding Tes to the
150:02 - owner so we can send the amount
150:08 - received and that's it and we see here
150:11 - that after a call where the caller sends
150:14 - one test to the
150:15 - contract then the contract generates a
150:17 - transaction that sends one test to the
150:20 - owner
150:21 - unfortunately this is not enough there's
150:23 - another big flaw can you figure out why
150:26 - pause the video and think about it for a
150:28 - moment I'll give you a hint the idea is
150:31 - that this version of the contract
150:33 - doesn't really enjoy all of the benefits
150:35 - of the
150:36 - centralization so I'll recap Main
150:39 - benefits the centralization provides
150:42 - relability it gets rids of the
150:44 - dependence on the third party and it
150:47 - prevents censorship
150:50 - so one of these aspects has been lost in
150:53 - this version of our smart contract can
150:56 - you figure out which one and why and how
150:58 - to fix it take a look at our contract
151:00 - and think about what could go wrong
151:02 - pause the video and think about it for a
151:04 - moment to find out what the flaw is you
151:07 - have to remember that a smart contract
151:09 - is a kind of account and like any
151:12 - account its address can be the
151:14 - destination of some transfer so instead
151:17 - of using a user account address as the
151:20 - owner you could use a contract address
151:22 - as the own and so when you send some
151:25 - test you can send them to a contract
151:27 - address if the address isn't that of a
151:30 - contract in
151:32 - practice sending test to a contract
151:35 - address will call the default entry
151:37 - point of that
151:39 - contract it's simply an entry point
151:41 - called default that takes no parameter
151:45 - and if you want to create a default
151:46 - entry point that accepts TZ as TZ or by
151:49 - default accepted all you need to do is
151:51 - to do nothing and as a way to show that
151:54 - we write pass as the only instruction in
151:57 - the contract to indicate that yes we
151:59 - know we don't want to do anything in
152:01 - this entry point so we write pass to say
152:04 - do
152:05 - nothing this will be an entry point that
152:08 - accepts simple transfers of TZ to the
152:12 - contract now the issue is that if the
152:14 - owner of a contract is a smart contract
152:18 - this smart contract could change change
152:20 - the behavior of its default entry point
152:23 - and reject the Tes if as the owner of
152:26 - the contract you can reject the test you
152:29 - can reject calls to write messages that
152:32 - means users have to trust you they have
152:35 - to trust the owner of the contract that
152:38 - this owner will not disable the smart
152:40 - contract or prevent someone from posting
152:44 - their messages the whole idea of
152:47 - decentralization and not relying on the
152:49 - third party is that you don't want to
152:51 - have to trust that the owner of the
152:52 - contract will not stop the service for
152:55 - any reason so here if whoever deployed
152:58 - the contract made the owner another
153:01 - smart contract and that smart contract
153:04 - can prevent transfer of test then they
153:07 - have full control on whether Our Endless
153:09 - World contract works or not and that's a
153:12 - problem we don't want that to better
153:14 - understand this let's look at an example
153:16 - so we have our endless World contract
153:18 - here that whenever we call right message
153:23 - checks that the user sent one test and
153:25 - then sends that one test to the owner so
153:28 - let's see how we can make this owner a
153:30 - smart contract that will then have full
153:33 - control on whether it's possible to call
153:35 - right message or
153:38 - not the idea is that we can create this
153:40 - owner contract that will store the owner
153:44 - of this contract and we'll have a
153:47 - Boolean called blocked that says where
153:49 - whether it's accepting or blocking
153:51 - transactions so we set it as false
153:54 - initially everything works then we have
153:56 - an entry point set block where the owner
154:00 - can change the value of blocked to true
154:03 - or false finally we have our default
154:06 - entry point if blocked is
154:09 - false then this condition will be
154:12 - true and then the contract will not only
154:16 - receive the test but send the balance
154:19 - back to the owner owner of this
154:21 - contract but if blocked is set to true
154:25 - then it will reject any transfer to it
154:28 - so if this contract is the owner of this
154:31 - contract then whoever owns this contract
154:34 - can decide to block any call to write
154:37 - message we can write the corresponding
154:39 - test
154:40 - scenario here we create a scenario we
154:43 - create an instance of our owner contract
154:46 - and Alice is the owner of that owner
154:48 - contract we added to the scenario then
154:51 - we create an instance of Our Endless
154:53 - World contract and we say that the owner
154:55 - is actually this contract's
154:58 - address we add that to the scenario as
155:00 - well then we
155:03 - can check that if we simply write a
155:07 - message and send one t everything works
155:11 - but if we then call set block of that
155:15 - contract as Alice who's in charge of
155:17 - this contract then the next call the
155:20 - same call is going to fail with the
155:23 - exception wall is blocked returned by
155:25 - this contract when we call the default
155:28 - entry point let's give it a try so it
155:31 - worked and we can see that indeed when
155:35 - we did the second right message call
155:38 - it's call the the default entry point of
155:40 - our owner contract and raise the
155:43 - exception wall is blocked so the
155:45 - transfer didn't happen and Eve was not
155:48 - able to write on the
155:51 - wall this is not something we want we
155:53 - don't want some unique person some third
155:57 - party to have full control on the
155:59 - contract and prevent other people from
156:01 - using this service so how do we prevent
156:04 - that well the issue here and that you
156:06 - should always be careful about is that
156:08 - this entry point called by any regular
156:11 - person is sending T to another address
156:14 - and this is the dangerous part because
156:16 - this could fail and prevent any call
156:18 - from right bling
156:20 - so the solution is to avoid calling send
156:24 - to another address as part of the entry
156:26 - point that the first person is calling
156:29 - to do that we just split it into a
156:31 - separate entry point that this owner
156:34 - will have to call to get their money
156:36 - back so we create a separate entry
156:43 - point that we call claim
156:50 - that can be used by the
157:03 - owner to request the balance to be sent
157:06 - to them here we checked that it was
157:10 - actually the owner calling this but we
157:12 - don't really need to if someone else
157:13 - calls it then it's going to send test to
157:16 - the owner and that's fine that's what we
157:17 - want in the end we just didn't want it
157:20 - to happen as we write message because
157:22 - this call could be blocked so we don't
157:23 - actually need this
157:28 - assertion so now we don't have an
157:32 - exception anymore so expected exception
157:34 - but not occurred so we can change that
157:37 - and say yes now this
157:43 - works but for
157:45 - Alice to get her money she would have to
157:48 - call the claim entry point so now that
157:50 - we know a little bit about transferring
157:52 - TZ to and from a smart contract let's
157:55 - see how we can use it as a way to add a
157:58 - feature to our nft smart contract so
158:01 - that the current owner of an nft can
158:03 - sell it with the transfer entry point
158:07 - that we already had in our basic nft
158:09 - smart contract we could imagine a sell
158:13 - that would take two steps two
158:15 - transactions the first transaction would
158:18 - be for the buyer to send
158:19 - a certain amount of t to the owner of
158:22 - the nft to pay for that nft and then in
158:25 - a second transaction the owner could say
158:27 - okay you paid me now I will call
158:30 - transfer on that nft with the address of
158:33 - the buyer so that's a typical
158:34 - transaction right if you go to the
158:36 - bakery and you want to buy some bread
158:38 - you give 1 to the Baker and then the
158:41 - baker gives you your bread so the
158:43 - question is what could go wrong with
158:45 - such a system and how could we change
158:48 - our basic nft smart contract to fix this
158:51 - issue here was the
158:53 - contract so pause the video and think
158:56 - about it for a moment so the issue when
158:59 - you use two
159:00 - transactions is that it relies on the
159:03 - two parties to trust each other that's
159:06 - the case no matter in which order the
159:08 - two steps are performed if it's the
159:10 - buyer who sends the money first then
159:13 - they have to trust that the seller will
159:15 - indeed transfer the item to them on the
159:18 - other hand if it's the seller who
159:21 - transfers the item first then the seller
159:23 - needs to trust that the buyer will then
159:26 - send the money without the blockchain so
159:29 - for example in our Bakery the same thing
159:32 - can happen you could pay 1 EUR for your
159:34 - bread and the baker could take your the
159:36 - Euro and not give you your bread or if
159:39 - the baker gives the bread first you
159:41 - could take it run away without paying
159:44 - the one Euro in this sitation we can
159:47 - rely on the police we can Ry on the
159:49 - justice system Etc as a way to handle
159:53 - conflicts or more generally we can
159:55 - involve a third party for example an
159:58 - online shop as an intermediate between
160:01 - the buyer and the seller but again you
160:03 - need to
160:04 - trust that the police will care about
160:08 - your bread or your one Euro that you
160:09 - lost that the justice system will be
160:12 - effective Etc it's really a hassle and
160:15 - can be actually very expensive and time
160:17 - consuming and you have to trust that the
160:19 - police police or the justice system will
160:21 - do their job well but thanks to
160:23 - decentralization blockchains can provide
160:26 - this kind of trust without a third party
160:29 - within a smart contract you can perform
160:32 - what we call an atomic
160:34 - exchange where either the two steps of a
160:37 - transaction succeed or neither of them
160:40 - will happen so either you both transfer
160:44 - the item and get the money or nothing
160:48 - happens
160:49 - simply by having the two steps within
160:52 - the same entry point since any step that
160:55 - fails cancels the whole entry point
160:58 - let's put this in practice with an
161:00 - exercise where your goal is to change
161:04 - the basic nft contract so that users can
161:08 - buy or sell their nfts so your goal is
161:11 - to add a buy feature such that the
161:13 - following can happen the owner of the
161:16 - contract should be able to set a selling
161:19 - price price for their
161:20 - nft the buyer should then send the
161:23 - corresponding amount of Tes the seller
161:26 - should be able to get these T and
161:29 - finally the ownership of the nft should
161:32 - be transferred to the buyer when
161:34 - everything goes well the contract should
161:37 - make sure that the buyer only gets the
161:39 - nft if they sent the right amount and
161:41 - the seller should only receive the paid
161:44 - amount if the nft ownership was
161:47 - transferred so how can we we do that
161:50 - pause the video and try to work on it so
161:52 - to help you we can think of what entry
161:55 - points we will need we will need two
161:57 - different entry points one for the
161:59 - current owner of the nft to be able to
162:01 - set the price at which they want to sell
162:04 - that nft and the second entry point will
162:07 - be the buy entry point that the buyer
162:10 - can call to purchase the nft will have
162:13 - to check that the buyer transfer the
162:16 - correct amount using sp. amount it will
162:19 - need to send that amount to the seller's
162:22 - address from the balance of the contract
162:26 - and then it will have to transfer the
162:27 - ownership of the nft to the buyer so
162:30 - please implement this you can then
162:33 - validate it on Open tizel let's take a
162:35 - look at the solution in our Constructor
162:38 - we added this new value the price that
162:41 - we need to store then we have an entry
162:44 - point set price that takes the new price
162:47 - as parameter we make sure only the owner
162:51 - of the nft can call this entry point and
162:54 - once we've done that we simply replace
162:57 - the current value of price with the
162:59 - value of the
163:00 - parameter finally we can have a buy
163:03 - entry point that doesn't need to take
163:05 - any parameter the buyer don't need to
163:06 - say how much they send they simply send
163:09 - it as they call the buy entry point and
163:12 - it's the contract that checks that the
163:14 - amount sent is equal to the price cuz if
163:19 - if it was a parameter the buyer could
163:20 - just claim whatever amount without
163:22 - actually sending the test so the amount
163:24 - to send is available from sp. amount and
163:27 - that's the value you want to check so
163:30 - once you check that the buyer sent the
163:32 - right amount you can send that amount to
163:36 - the owner so here as we have seen this
163:39 - could fail but if that fails that means
163:41 - the owner doesn't really want to sell it
163:43 - so that's fine we don't need to separate
163:45 - that into a claim entry point here
163:48 - finally once we have created the
163:50 - transfer of price to the owner we can
163:53 - change the owner to the address of the
163:56 - caller who's the buyer and that's
164:00 - it then we can test
164:02 - this here we call set price with a price
164:06 - of seven from Alice who's the original
164:09 - owner of the
164:11 - nft we check that if someone else like
164:13 - Bob tries to change the price this will
164:16 - cause an exception you cannot update the
164:17 - price
164:19 - and finally we try to buy the nft as Bob
164:23 - paying the right price 710 and we check
164:28 - that if we try to buy it at the wrong
164:30 - price this will cause an exception
164:32 - saying wrong price let's give it a
164:36 - try all
164:38 - good we Chang the price here we can see
164:41 - that the price has changed we can see
164:43 - that this
164:45 - failed then we actually purchase and we
164:49 - can see that the amount was sent back to
164:51 - Alis then we can try to purchase with
164:53 - the wrong amount and we get an exception
164:56 - all good so just by doing this we made
165:00 - our nftd contract a lot more convenient
165:03 - so now you can buy and sell nfts in this
165:06 - module we'll give you the answer to a
165:08 - question you may already have asked
165:10 - yourself what if I don't want to put any
165:12 - value for example what if I don't want
165:15 - to set a price for my nft it's not for
165:18 - sale for that we can use options but we
165:21 - also see that in many cases you probably
165:24 - shouldn't use them so far our variables
165:28 - always had a value but sometimes you
165:31 - simply want to say that there is no
165:32 - value for example when you initialize
165:35 - the endless wall and we keep track of
165:37 - who called the right message entry point
165:40 - for the last time initially you want to
165:43 - set this last caller value to nothing
165:45 - right nobody has called it yet so how
165:49 - could we support this
165:50 - possibility pause the video and think
165:52 - about how you would support this
165:54 - possibility if it was up to you so how
165:56 - can we allow variables of some type to
165:58 - have no value at all one possibility
166:01 - could be to use a special null value but
166:04 - this could be quite risky if an INT
166:07 - variable is new then any arithmetic
166:11 - operation you apply to it would fail if
166:14 - you want to avoid bugs you want to make
166:16 - sure that if there's Theos possibility
166:19 - of a Nal case your code always handles
166:22 - it but you don't want to have to handle
166:25 - the newal case even for variables that
166:28 - actually always have a value how can we
166:30 - solve this dilemma again pause the video
166:33 - and think about it for a minute if we
166:35 - want to both Force the code to always
166:38 - handle the possibility that a variable
166:40 - has no value but at the same time avoid
166:43 - having to write such code for variables
166:46 - that will always have a value then we
166:48 - would need to use a different type for
166:50 - both situations right so for any type
166:54 - int not TZ address Etc we would have a
166:57 - version that always has a value and then
166:59 - another variation of that type that
167:02 - sometimes may not have a value how can
167:04 - we avoid having to support two versions
167:06 - of every type a steel handle both cases
167:09 - so instead of having two versions of
167:11 - every type the int that always has a
167:14 - value and then it that may have no value
167:17 - we use a special type that wraps around
167:20 - all the types and we call it options an
167:23 - option is like a box that may or may not
167:26 - contain a value of a given type so for
167:29 - example an option on an INT may contain
167:33 - either nothing or an INT all you can do
167:36 - with an option is create the option with
167:39 - or without a value check if an option
167:42 - has value compare two
167:45 - options unwrap the options that
167:48 - basically means is getting the value
167:50 - that it contains out of the option and
167:53 - any other operation can't be done
167:55 - without first unwrapping the option so
167:58 - for example if you want to add two
167:59 - values of two options so two options on
168:02 - the NIT you need to unwrap both options
168:06 - and then add the actual values so here
168:10 - is how you create an option you simply
168:12 - write SP do sum and then between
168:15 - parentheses the value that you want to
168:18 - put inside an option but of course you
168:21 - also want to be able to create an option
168:23 - with no value for that we simply write
168:26 - none two options are equal if they
168:28 - contain the same value so we can compare
168:31 - sp. sum 42 to sp. sum of 42 and those
168:36 - would be equal or if they both contain
168:39 - nothing so none equals none any other
168:42 - case they are different so for example
168:45 - you could do assert my option equals sp.
168:50 - sum of 42 or S my option equals n you
168:53 - could also use the other type of
168:55 - comparison operators lower than greater
168:59 - than Etc if the two options contain a
169:02 - value it will compare these values if at
169:05 - least one of the options is none it will
169:07 - return false so for example sp. sum of
169:12 - 33 is lower than sp. sum of
169:16 - 42 but none is not not lower than sp.
169:20 - sum of 42 and it's not greater either or
169:23 - equal to sp. sum of 42 so those two will
169:27 - return false if you want to extract the
169:29 - value out of an option you can write
169:33 - your option do unrap
169:35 - sum and this will trigger an error if
169:38 - the value of the option is none because
169:41 - there is no value to get out of it the
169:44 - Box doesn't contain anything if you want
169:46 - to check if an option has a value you
169:48 - can see simply write assert my option
169:50 - different from none it's usually a bad
169:52 - idea to use unwrap sum to compare an
169:56 - option to a value for example if you do
169:59 - if my option do unrap sum equals my
170:02 - value then this will fail if the option
170:04 - doesn't contain any value which is
170:06 - probably not what you want you just want
170:08 - to do something if it's exactly this
170:11 - value and not fail if it's not so what
170:14 - you would rather do is compare to an
170:17 - option so if my option equals sp. sum of
170:21 - the value you want to compare it to so
170:23 - instead of unwrapping your option you
170:25 - wrap the value that you want to compare
170:27 - it to this will never fail whenever you
170:31 - need to describe the type of an option
170:33 - you can write SP do option and between
170:36 - square brackets you put the type of the
170:39 - value inside the option so for example
170:42 - for a n the type would be sp. option and
170:45 - square brackets sp. n for for none type
170:49 - inference is used to determine the
170:51 - correct type let's check an example in
170:55 - Our Endless wall contract when we wanted
170:58 - to check that the same address was not
171:00 - used to call right message twice in a
171:02 - row we used last
171:05 - sender and before we initialize it to
171:08 - the address of the owner but instead we
171:11 - could say the initial value of SL sender
171:14 - is none right we haven't made any call
171:17 - yet then when we want to update it
171:20 - instead of assigning it to sp. Sender we
171:23 - assign it to sp. sum of sp. sender when
171:27 - we want to check if it's the same color
171:30 - as last time we compare last sender to
171:34 - sp. sum of sp. Senter again you ripe the
171:38 - value you want to compare it to rather
171:40 - than unwrap your option does this would
171:42 - fail if the value was
171:44 - none so if we make that change and run
171:48 - it everything works and we can see that
171:50 - the initial value of L sender is
171:53 - none and then sum and the address
171:57 - Etc my recommendation is actually to
172:01 - avoid options when there is an
172:03 - alternative the reason is that when you
172:06 - use an option you need to add code every
172:09 - time you manipulate its value you need
172:12 - to add code to verify if it's none you
172:15 - need to add code to extract the value
172:17 - you need to add code code to compare it
172:19 - to a special value Etc every time
172:22 - there's something extra you need to do
172:24 - to handle the fact that it's an option
172:27 - this overall makes the code longer
172:29 - harder to read slower and more expensive
172:34 - so if there's an alternative that works
172:36 - we recommend using that
172:39 - alternative what would an alternative be
172:41 - well as we have done before we introduce
172:44 - option we can simply use a default value
172:46 - if there is one that can do the job
172:49 - so for an address we can initialize the
172:51 - value with an invalid address and give
172:53 - it a name so for example this is a
172:56 - contract address that is correct the
172:58 - check some works but it doesn't
173:00 - correspond to any actual contract and so
173:03 - you could use this address but most of
173:05 - the time using the address of the owner
173:08 - also works so that's what we had done
173:10 - for Our Endless World contract and the
173:13 - last
173:14 - sender value here if instead of using
173:18 - option we simply initialize with
173:22 - owner then we remove code right we don't
173:25 - need to do this we just directly compare
173:27 - to the sender and here we remove code
173:31 - again we directly compare to the sender
173:34 - so it makes the code easier to write and
173:36 - to read the only issue with this is that
173:39 - owner cannot be the one who makes the
173:41 - first call but if we want owner to be
173:43 - able to make the force go to write
173:45 - message we can just initialize with a
173:47 - different value that that we know for
173:48 - sure will not be the one writing the
173:51 - first message such as an invalid
173:54 - value of course sometimes it's necessary
173:58 - to use options because there is no
173:59 - better choice so for example if you need
174:02 - to call another contract that has an
174:05 - entry point that takes an option as a
174:07 - parameter of course you need to use an
174:10 - option but sometimes you need to create
174:12 - your own entry point that has an
174:14 - optional parameter maybe because you
174:16 - want to be compatible with a standard
174:18 - that uses options if no matter what you
174:20 - need to have some specific code to
174:23 - handle the case where there is no value
174:25 - then you definitely want to use an
174:27 - option it's a lot nicer to compare to
174:29 - none than to compare to some arbitrary
174:32 - value that you use instead of N and
174:34 - finally if there's no default value that
174:36 - would work nicely then you should use an
174:39 - option for example for the nft contract
174:42 - if you want to make sure that nobody can
174:44 - buy your nft putting a very huge price
174:47 - on an nft would Weir would be a weird
174:49 - way to handle it it would mean like
174:51 - you're pretending that your nft is
174:52 - extremely expensive so it's a lot better
174:55 - to say my nft is not for sale the
174:57 - current price is none finally there's a
174:59 - number of cases where you need to access
175:01 - return values from Instructions that may
175:03 - cause errors and such instructions often
175:06 - return an option here are a few
175:10 - examples if you use the function is n to
175:13 - check if a value is a nut this will
175:16 - return none if the the value is negative
175:19 - and it will return an option on the
175:21 - value if it is zero or positive another
175:25 - example is sp. slice that extracts a
175:28 - substring of a given string but it will
175:31 - return none if for example the offset or
175:35 - the length are invalid there is no such
175:37 - extract and it's beyond the bounds of
175:40 - the string for example but if it is
175:42 - valid then it returns an option on the
175:45 - result another case is when you want to
175:48 - interact with another contract you use
175:50 - sp. contract and provide the type of the
175:53 - contract the address and the entry point
175:55 - and it will return none if there is no
175:57 - such tree point for the contract at this
175:59 - address otherwise it will return an
176:02 - option on the contract let's put it in
176:05 - practice with an
176:06 - exercise change your nft orell contract
176:11 - so that it uses an option to indicate
176:14 - that the nft is not for sale so if you
176:17 - want to say it's not for sale you will
176:20 - use the set price entry point but pass
176:22 - none as a parameter to say I don't want
176:25 - it to be on sale and similarly right
176:29 - after somebody buys it you want to set
176:31 - the price back to none so that it cannot
176:33 - be bought again immediately by someone
176:35 - at the same
176:37 - price here is a smart contract that we
176:40 - asking you to change pause the video and
176:42 - give it a try so here when we initialize
176:45 - the contract we don't need to put any
176:47 - initial value value so we can remove the
176:50 - price and initialize It To None when we
176:53 - set the price well we need to pass an
176:56 - option anyway so we just save it as is
176:58 - it's already an option and when we buy
177:02 - then we need to compare the amount sent
177:04 - to the price so we don't unwrap the
177:06 - price we wrap the amount using sp.
177:11 - sum and finally we need to set the price
177:14 - back to none
177:20 - you know test here we need to wrap this
177:23 - into an
177:28 - option same here
177:49 - and line 21 we need to unwrap this
177:53 - because we need to send the value but
177:55 - since we already compareed the amount to
177:57 - the price instead of unwrapping this we
178:00 - can simply send the amount
178:08 - received and so when we initialize the
178:11 - contract we decided not to put any
178:15 - price so all good but now if we want to
178:19 - say it is not on sale all we have to do
178:22 - is C1 do set
178:25 - price
178:36 - none and so we can see that end we put
178:39 - the
178:41 - price Back To
178:43 - None So options are pretty easy to use
178:46 - but remember that when you can it's
178:49 - better to avoid using them to simplify
178:51 - your code in this module we will talk
178:53 - about blockchains and time blockchains
178:57 - have a deep relationship with time you
178:59 - could say that a blockchain has a pulse
179:02 - it's like a heartbeat ticking very
179:04 - regularly from the Genesis block towards
179:07 - eternity every few seconds we have a new
179:10 - block another connection between
179:11 - blockchain and time is that a blockchain
179:14 - can be used by anyone to safely store
179:16 - information forever
179:19 - to send information far in the future it
179:22 - also has a relationship with the past as
179:24 - a blockchain can be used to certifiably
179:27 - timestamp information and prove
179:30 - interiority basically prove that at some
179:33 - time in the past you already had this
179:36 - information and you can prove it finally
179:39 - it is possible to use a blockchain to
179:41 - lock assets until a specific time in the
179:45 - future in a way use it as a Time cap
179:48 - capsule the only issue is that a smart
179:51 - contract actually can't tell time when
179:54 - you execute the smart contract you
179:56 - cannot read the current time from the
179:59 - computer that executes it the reason is
180:03 - that a smart contract should always
180:05 - produce the exact same result no matter
180:08 - which node execut it no matter when it
180:11 - executes it so if you run the same
180:13 - program on different nodes and at
180:15 - different times the current time will be
180:17 - different right so the code cannot
180:19 - depend on the actual current time of the
180:21 - computer that runs it however you really
180:25 - often need to manipulate time within a
180:27 - smart contract you want a smart contract
180:30 - to be able to check if it's been called
180:32 - before or after a deadline you want to
180:35 - be able to check how much time has
180:37 - passed between two given events and you
180:40 - also want to be able to store and
180:41 - saveguard the date of specific events so
180:45 - the question is how can we solve this
180:48 - dilemma we cannot access to a time of
180:51 - the computer the contract is running on
180:54 - but you do need to know the time pause
180:57 - the video and take a minute to think
180:58 - about it so the solution is that every
181:01 - block includes its own timestamp and a
181:05 - smart contract can access this timestamp
181:08 - using sp. now and every smart contract
181:12 - call within the same block will read the
181:15 - exact same Tim stamp and it doesn't
181:18 - matter which node executed or when we
181:20 - execute it the time stamp of a block is
181:22 - always the same so whenever you execute
181:24 - a contract from a block the value of the
181:27 - time stamp is always the same and then
181:30 - of course for the next block it will be
181:31 - a different value corresponding to when
181:34 - this block was created but the time
181:36 - stamp of a block is actually predictable
181:39 - the value of sp. now is predetermined by
181:43 - a time stamp stored in the previous
181:45 - Block in practice there's two time
181:47 - stamps in the block the one that can be
181:49 - read through sp. now and the actual
181:52 - creation time of the block that will
181:55 - only be used by the next block to
181:57 - compute value of sp. now in the next
182:00 - block so the time stamp of a block is
182:03 - predictable based on the content on the
182:05 - previous block but more than that in
182:08 - practice blocks are created very
182:11 - regularly at the time of recording there
182:13 - is a block being created every 15
182:15 - seconds and if you look at the ual time
182:18 - the difference between two block
182:20 - creation is really precisely 15 seconds
182:23 - most of the time there's very little
182:26 - variation that's something important to
182:28 - keep in mind in smart Pi we have a type
182:31 - dedicated to time stamps s. timestamp
182:36 - and it represents a number of seconds
182:39 - relative to January 1st 1970 at midnight
182:43 - internally it's like an integer it can
182:46 - be infinitely positive so it can
182:48 - correspond to any date as far as you
182:50 - like in the future but it can also be
182:52 - infinitely negative so represent any
182:55 - time as far as you like in the past if
182:58 - you want to create a time stamp you can
183:00 - use sp. timestamp and provide the number
183:03 - of seconds since January 1st
183:06 - 1970 again it could be a negative number
183:09 - if you want to access the time stamp of
183:11 - the current block you can use sp. now if
183:15 - you want to add some time to a time
183:17 - stamp you can use SP do add seconds your
183:21 - time stamp and number of seconds or if
183:24 - you want to add a number of days you can
183:26 - use sp. add days your time stamp and the
183:30 - number of days finally if you want to
183:32 - compute the difference between two time
183:34 - stamps you can subtract them and the
183:37 - result will be a number of seconds so
183:40 - that's very convenient to measure how
183:41 - much time has elapsed since a given
183:44 - event finally there's a way to create a
183:46 - time stamp using a list of parameters
183:49 - where you provide the year the month the
183:51 - day the hours minutes and second this is
183:54 - using sp. timestamp from
183:58 - UTC so it's a time in the UTC time zone
184:01 - when you test a smart contract time
184:03 - doesn't pass between your different
184:05 - calls doesn't matter how long the
184:07 - computation takes you can make as many
184:09 - calls to your smart contracts in your
184:11 - test the time is not going to pass
184:12 - automatically SP do now will always be
184:15 - Zero by default but you can specify what
184:19 - value of sp. now you want to use by
184:22 - adding a parameter to your entry point
184:24 - calls underscore now equals and then the
184:27 - value of your time stamp this way you
184:29 - can simulate time passing without
184:31 - actually having to wait if you have a
184:33 - contract that has to wait 10 days for
184:36 - some event to happen you don't have to
184:38 - test it by waiting 10 days you can just
184:40 - simulate time passing by changing the
184:42 - value of now let's work on an example
184:45 - we'll take or unless we count contract
184:48 - and add a
184:49 - deadline the idea is that we will change
184:52 - a contract so that people only have
184:54 - until the end of
184:56 - 2025 to write a message on it from then
185:00 - on the wall won't change ever again so
185:03 - how do we do that well for one we we
185:06 - need to change our storage and add a
185:08 - deadline that we can initialize in the
185:12 - Constructor then in the right message
185:15 - entry point we will add a check is this
185:20 - before the deadline so we check if sp.
185:24 - now is lower or equal to our deadline
185:29 - otherwise we have an exception after
185:31 - dead line and that's it that's all we
185:34 - need to have this feature that the
185:37 - endless wall expires after a given
185:40 - deadline in or test to check that it
185:44 - does work right before the deadline but
185:46 - stops working after that line we call
185:49 - write
185:50 - message with a date that is just before
185:54 - the end of 2025 December
185:57 - 31st at 11:59 and 58 seconds this one
186:02 - should pass but then a couple seconds
186:05 - later on January 1st 2026 after 1 second
186:10 - this should fail so we add valid equals
186:12 - F we use underscore now to specify the
186:16 - time we can initialize using time stamp
186:18 - from UTC let's give it a try it
186:23 - works we can see
186:26 - here that this call was met at this time
186:30 - so something that ends with 598 and it
186:33 - worked but a little bit later 3 seconds
186:36 - later 601 this one failed because it's
186:39 - after the
186:41 - deadline now it's your turn to practice
186:43 - on an
186:44 - exercise this time you will change your
186:47 - nft contract to add some notion of time
186:51 - in it and the idea is to make it so that
186:54 - you cannot sell on nft less than 5 days
186:58 - after the last time it was bought pause
187:01 - the video and give it a try let's look
187:04 - at our
187:05 - solution in the storage we will need to
187:08 - add a date that is the last time that
187:12 - somebody bought this nft so we
187:14 - initialize it in the constructure
187:17 - and then in the buy entry point we will
187:21 - store the new value so assign it to sp.
187:24 - now but before we allow the user to buy
187:27 - this nft we check that the current time
187:30 - is more than 5 days after the last date
187:34 - so here we have the last date that it
187:36 - was bought and we use sp. add days to
187:39 - add five days to it if this fails then
187:43 - we have an exception that says you need
187:44 - at least 5 days so here you may want
187:47 - Wonder should we use options so that
187:51 - initially The Bu date should be set to
187:54 - none and the answer is no as I said
187:57 - earlier when you have a way to avoid
187:59 - using options I recommend avoiding it
188:02 - here there's a very simple date that we
188:04 - can use as a default value and that
188:06 - could be sp. timestamp of zero so
188:10 - January 1st
188:13 - 1970 so there's no need to use an option
188:17 - any call we could make of course will be
188:19 - more than 5 days after that date so
188:21 - there's really no need for an option in
188:23 - this
188:24 - situation now let's look at our test so
188:28 - here we have the test that check the
188:30 - deadline when we initialize a smart
188:33 - contract we initialize with sp. time
188:36 - stamp of zero and then when we try to
188:39 - buy it the first time at the right price
188:42 - we set a value for the current date that
188:45 - is four days so so that's four times the
188:48 - number of seconds in a day after the
188:51 - time stem zero so that's of course way
188:53 - in the past but what matters is the
188:55 - difference and so this one should fail
188:58 - because it's less than 5 days after the
189:00 - initial value of BU date but then if we
189:03 - do a second call this time six days
189:06 - after the time St zero then it should
189:08 - work let's give it a try and it's all
189:11 - good we can see that this attempt was
189:15 - done at this time and in
189:18 - and a bit later this attempt was done
189:21 - and it passed well good so this is a
189:25 - good time for a recap of all the
189:28 - benefits of a smart contract that we
189:29 - have seen so far we have seen that smart
189:32 - contracts add trust in a sense that they
189:35 - allow us to eliminate the need for
189:38 - trusted third parties when we perform
189:41 - transactions by eliminating these
189:43 - intermediaries they also allow us to
189:46 - reduce cost
189:48 - they also have the benefit of
189:49 - transparency the code of a smart
189:51 - contract is public on a public
189:53 - blockchain so it's possible to check
189:55 - everything that will happen before you
189:58 - call a smart contract and use its
190:00 - service there is no surprise you should
190:02 - take the time to check the code we also
190:05 - saw that smart contracts are immutable
190:08 - and even the owner may not change the
190:11 - code at least by default so you are
190:13 - guaranteed that those rules will not
190:15 - change after you decide decided to use
190:18 - the
190:18 - service finally one of the benefits of
190:21 - decentralization is that there can be no
190:23 - censorship so nobody in particular can
190:26 - be stopped from calling a smart contract
190:29 - finally there is no single point of
190:32 - failure thanks to decentralization you
190:35 - can be certain that the service will
190:37 - always be
190:39 - available in this module you will learn
190:42 - to manipulate arithmetic operators and
190:45 - we will take as an example our first
190:47 - decentralized Finance contract a yield
190:50 - forming contract you have already
190:52 - manipulated some arithmetic operators
190:54 - but let's take a look at all of the ones
190:57 - that are available we already
190:58 - manipulated the addition using the plus
191:01 - operator subtraction and multiplication
191:03 - using the usual python operators as you
191:06 - would expect and we also have the
191:09 - negation to take the opposite of a value
191:12 - the integer Division and that's the only
191:14 - division we have and the single slash
191:16 - actually does an integer division on
191:18 - tesos because we don't have any floating
191:21 - Point operations those would be
191:23 - dangerous as they can lead to
191:25 - approximation issues maybe a different
191:27 - result depending on the architecture
191:30 - you're running it on Etc so to keep it
191:32 - safe we only manipulate whole numbers on
191:36 - tesos you can do modulo using the sp.
191:40 - mod function that takes two values and
191:43 - Returns the remainder of the division of
191:46 - the first one by the second one and you
191:50 - already manipulated some shorthand
191:52 - operators so we can use plus equals to
191:55 - add a value to this so Value Plus equals
191:59 - x adds X to Value same with minus equals
192:03 - or multiply it equal instead of having
192:06 - to write self data. Val equals self
192:09 - data. Val plus X Etc so this can keep
192:13 - things short for all these arithmetic
192:16 - operators both operants have to be of
192:19 - the same type this is because smartp is
192:23 - using Python and overloads the python
192:26 - operators and you can only overload
192:28 - operators if the two operant have the
192:30 - same type if you need to do arithmetic
192:33 - operations that combine two different
192:35 - types for example if you want to mix int
192:38 - and N operant you have two
192:41 - choices you can convert the nut value
192:44 - into an INT using SP do two int of the N
192:48 - value or you could convert the int value
192:51 - to a nut using SP do as int if you know
192:54 - for sure that the value is positive or
192:57 - zero or you could use dedicated
193:00 - functions for multiplication addition or
193:03 - division sp. add sp. Mo and sp. ediv
193:08 - that work even if the two types are
193:11 - different now the type of the result
193:14 - it's usually what you would guess based
193:16 - on what the result result can be so for
193:18 - the addition multiplication and division
193:20 - if both operants are Naturals the result
193:23 - will be a natural as well right you can
193:25 - never end up with a negative result if
193:27 - you add multiply or divide positive
193:30 - numbers but if at least one operant is
193:33 - int therefore could be negative then the
193:36 - result could be negative therefore it
193:38 - has to be of type int so if you multiply
193:41 - an INT with a n the result will be an
193:43 - INT same with addition and division for
193:46 - subtraction and negation the result can
193:49 - always be negative if you subtract two
193:51 - positive numbers if the second number is
193:54 - bigger than the first one and the result
193:55 - will be negative so the result will
193:57 - always be of type int whether the
194:00 - operant are Nots or inss for the module
194:04 - it's always a nut so the remainder of a
194:06 - division is always the positive
194:09 - remainder for the EDF function it
194:12 - returns an option on a pair of values q
194:15 - and R where Q is the quo so the result
194:18 - of the division and R is the
194:21 - remainder the reason why it's an option
194:24 - is because you divide by zero it could
194:26 - fail and in this case instead of raising
194:29 - an exception it returns none and if it
194:32 - doesn't fail then it returns an option
194:34 - on this pair we already discussed pairs
194:37 - a bit before let's look at it in more
194:39 - detail so to create a pair of values you
194:43 - put them between parenthesis and with a
194:46 - comma in between so A1 comma A2 between
194:50 - parenthesis and they can be of different
194:52 - types so for example you could have a
194:53 - pair where the first element is 42 an
194:56 - INT and the second element is a string
194:59 - and there the type would be sp. pair and
195:02 - between square brackets sp. in comma sp.
195:06 - string if you want to extract values
195:09 - from the pair you can extract the first
195:12 - element by using sp. FST for first the
195:17 - this would get you 42 here and for the
195:19 - second element you use sp. snd D this
195:22 - would give you ABC it's also possible to
195:26 - extract both components at once into two
195:29 - variables so here if on the right hand
195:32 - side of the equal operator you have some
195:34 - pair on the left hand side you can put
195:36 - the name of two variables between
195:38 - parentheses this will extract the first
195:41 - value of the pair in a and the second
195:44 - value of the pair in B and of course
195:46 - here it could simply be a variable that
195:48 - contains a pair or anything else it
195:50 - doesn't have to be the actual values so
195:52 - that's a good way to obtain a Content a
195:55 - pair into two variables in one single
195:57 - instruction this actually works for
195:59 - topples so so values that have more than
196:01 - two elements you could write a tole with
196:03 - three elements like this and you could
196:05 - extract all these three elements into
196:08 - three variables a b and c like this if
196:11 - you want to do arithmetic operations on
196:15 - mutes for the addition addition and
196:17 - subtraction if you add or subtract mutes
196:20 - the result will be a mutes if you
196:22 - subtract and the result is negative you
196:24 - will get an exception if you want to
196:26 - multiply mes you have to multiply them
196:29 - with a n if you have five T you can have
196:31 - twice that so five T times the natural
196:34 - two or you could do 2 * 5 T and the
196:38 - result will be a number of t 10 t for
196:42 - that you use sp. null since the two
196:44 - operant are of different types and so
196:47 - you multiply X by your natural value
196:51 - where X is of type mutes if you want to
196:54 - divide mutes by on that we have a
196:56 - special instruction for that to do
196:58 - computations we will see in a little bit
197:01 - that we call sp. split tokens that can
197:04 - do divisions and more on mutes if you
197:07 - want to do any other type of operations
197:09 - with mutes you will need to convert the
197:12 - values into other kinds of types when
197:15 - manipulating mutes you you need to be
197:17 - careful about
197:19 - overflows for inut we already saw that
197:22 - there is no upper limit or negative
197:24 - limit on how big or small a value can be
197:28 - except for the storage and the cost of
197:30 - storing these
197:32 - values but for mutes it's different
197:35 - mutes are currently stored using 64 bits
197:38 - integers and as mutes is a very small
197:41 - unit it's a million of AES that means
197:44 - you pretty quickly end up with big value
197:47 - so for example if we take 5,000 T that's
197:50 - 5,000 time a million mes so the actual
197:53 - value you store is 5 billion so if you
197:56 - need to square 5,000 test for example if
197:59 - you want to do some Financial
198:01 - computation that involves the square of
198:03 - the price Etc you may end up squaring a
198:06 - number of tests but you only need to
198:09 - square 5,000 T to get a result that
198:13 - won't fit in 64 bits because you're
198:15 - squaring 5 billion new TZ and 5 billion
198:19 - squared doesn't fit in 64 bits of course
198:22 - you cannot multiply 5,000 TZ by 5,000
198:25 - Tes so you would have to use a type
198:27 - conversion to multiply a number of Tes
198:30 - with a number of nut and that get this
198:31 - result but it's really important to keep
198:33 - in mind because if you end up with a
198:36 - value that causes an overflow then the
198:39 - call to the smart contract will fail so
198:41 - you won't get the wrong result but the
198:44 - call Will Fail therefore you could be
198:46 - stuck and the funs would be stuck in
198:48 - your contract so be really careful when
198:52 - multiplying Tes with big values talking
198:55 - about type
198:57 - conversions we already said that if you
198:59 - can avoid it it's better to avoid any
199:02 - kind of type conversions usually it's a
199:04 - bad sign if you need to convert a type
199:06 - into another but sometimes you really do
199:08 - need to convert type so when you do need
199:11 - to convert types here is how you do it
199:14 - first for some of them you will need a
199:17 - special module the sp. utils module to
199:20 - make it available in your contract you
199:22 - need to declare it in your test scenario
199:25 - so in the test scenario after the name
199:27 - of the test we before had just made the
199:29 - only module that contain your smart
199:31 - contract but now we need a list of
199:33 - modules to have sp. UTS and then still
199:38 - main so between square brackets you put
199:40 - the list of the modules separated by a
199:43 - comma so now that you have the utils
199:45 - module available in your contract you
199:47 - can do some conversions you can convert
199:50 - a mutes value to a natural so for
199:53 - example if you convert one mutes you
199:55 - will get the number one as a nut and in
199:59 - the other direction you can convert any
200:01 - nut to a number of mutes or to a number
200:03 - of Tes so if you use not two mes and
200:06 - then you pass one you will get one mes
200:09 - but if you want to avoid having to put
200:10 - big numbers you can directly convert to
200:12 - T so if you call not toes with the value
200:15 - one you will get one TZ which is a
200:19 - million mutes if you want to convert a
200:22 - nut to an INT you simply write SP do2
200:25 - int of the natural you don't need the SP
200:27 - doils module and then of course you will
200:29 - get an in to convert an in to a nut if
200:33 - you know for sure that the int is
200:35 - positive you can use SP do as n of your
200:38 - int value if the number is negative this
200:42 - will fail and make your contract fail
200:44 - let's play with an example in the
200:46 - storage we will store an integer value
200:50 - that we initialize with the int one and
200:52 - a n value that we initialize with a n
200:54 - zero the values don't really matter and
200:56 - I created one entry point per basic
200:59 - operation so one for add subtraction
201:02 - multiplication
201:03 - negation Division and the module and
201:06 - some with a shorthand operators that you
201:08 - can play with and then we have some test
201:10 - where we just call each of
201:13 - them if I simply run it it doesn't work
201:18 - it tells me I cannot subtract unknown
201:20 - and unknown for the subtraction
201:23 - operator so here that's
201:26 - because when we do the subtraction the
201:29 - result is an INT but the result of our
201:30 - subtraction is always an NT so we don't
201:33 - know what those are they could be
201:35 - Naturals they could be integers there's
201:36 - no way to know for sure what the type of
201:39 - X and the type of Y are just by knowing
201:42 - that the result is an integer so we have
201:44 - to help the type inference system so we
201:48 - simply
201:50 - say that X let's say is a
201:55 - nut and
201:58 - Y we could say it's um in
202:05 - maybe but now if we do that it will say
202:08 - no there's a problem the subtraction
202:10 - operators must have two arguments of the
202:13 - same type and I put an INT and a n so of
202:16 - course I could simply put a nut here and
202:19 - it would work now I have an issue with
202:22 - division so similarly it doesn't know
202:24 - what I'm
202:26 - dividing by so I need to say what the
202:29 - types
202:33 - are so I'll just say I'm dividing two
202:36 - Naturals so not works so here since the
202:40 - result is an end it deduces that X and Y
202:44 - are ends let's say X is a
202:54 - nut now if I run this it's telling me
202:56 - nope you cannot mismatch int and nut
202:59 - because the result is an INT if one is a
203:02 - nut maybe the other one may be an INT
203:04 - but we cannot add n an INT and if it's
203:08 - if the other one isn't n then the result
203:09 - wouldn't be an INT so here what I could
203:13 - do is either use SP
203:17 - do
203:18 - add X and
203:21 - Y but then it tells me I don't know what
203:24 - Y is so let's
203:26 - say
203:29 - Y is a
203:33 - NT and it would
203:35 - work or we could say well we first
203:37 - convert X to an
203:39 - in so let's say SP do 2 N of x plus
203:48 - Y and this would work as well so what I
203:51 - recommend you do is take this ample and
203:53 - play with it change the types of
203:55 - different values and see what happens
203:58 - and find ways to fix it and look at what
204:00 - the error messages look like Etc so for
204:03 - example one thing we could do is try to
204:07 - put the result of the subtraction as a
204:12 - n so this up course would fail because
204:15 - the result is an in I try to store it in
204:17 - the nut but I could try to do sp do as
204:22 - nut of the result which would work but
204:27 - that's only because I'm subtracting
204:29 - three from five so if I subtract seven
204:33 - here then it would tell me nope it
204:36 - doesn't work the result fails but here
204:39 - the message is not very clear because
204:41 - it's internally it's using options to
204:43 - manipulate the result because the
204:45 - underlying op operation returns an
204:47 - option and is none if the result is
204:51 - invalid so if before I use asut I need
204:54 - to make sure I know for sure that X is
204:58 - greater than y so play around with
205:02 - it now we can have a similar example
205:05 - where we play around with mutes here we
205:08 - have this financial value that's of type
205:10 - Tes and then we have operators to add
205:13 - subtract multiply and divide if I simp
205:16 - run it like that it's going to tell me
205:19 - it doesn't like multiplying two mutas
205:22 - and that's because my example multiply I
205:26 - did T time T so this doesn't work I can
205:29 - only multiply a mutes with a nut so
205:32 - let's say I want to do five T *
205:35 - three but it still doesn't work because
205:40 - again The
205:41 - Operators expect the two values to be of
205:44 - the same type and that's not the case
205:47 - here so before I even tries to run my
205:50 - test is just inferring from the type of
205:54 - financial value that those two values
205:56 - should be of the same type and type T so
205:59 - here I need to use sp.
206:09 - M then again for the subtraction it
206:12 - tells me I don't know what those are so
206:14 - I need to cast them
206:27 - and if I cast the first one it's going
206:29 - to deduct that the second one is the
206:31 - same
206:32 - type and now it's telling
206:35 - me that the multiplication it doesn't
206:38 - know what I'm trying to multiply because
206:39 - with sp. Mo can mully all kinds of
206:42 - things and obtain all kinds of types so
206:44 - I should say that X is of type mutas and
206:47 - Y is of type
206:53 - not for division same thing I need to
206:56 - provide the
206:58 - types let's
207:00 - say x is a
207:03 - mutas why let's try with not doesn't
207:07 - like it I need to use
207:11 - ediv of X comma y so this will return an
207:17 - option on a pair so I can do do
207:22 - unwrap
207:25 - sum and if I want to get the result I
207:29 - can
207:29 - do sp.
207:32 - FS of that
207:38 - pair and here it's telling me it's
207:40 - expected a nut but got mes so that's
207:43 - because when I call it I want to divide
207:45 - by but I simply put it as
207:51 - here and now it
207:56 - works so again play around with it and
207:59 - see what
208:01 - happens one operation we really often
208:04 - want to do when manipulating money is
208:07 - compute
208:08 - percentages but because there is no
208:11 - floating Point type on tesos um to avoid
208:15 - bugs
208:17 - related to approximations Etc we cannot
208:20 - compute 20% of a value by simply
208:23 - multiplying by
208:24 - 0.2 so we have to multiply by 20 then
208:29 - divide by 100 to make that easier
208:33 - especially when it comes to the types we
208:35 - have a special operation that we can use
208:37 - to compute any kind of
208:39 - percentages it's called split tokens and
208:43 - split tokens will take three parameters
208:46 - an amount a quantity and a total
208:48 - quantity and they will do the
208:50 - computation amount times quantity
208:53 - divided by the total quantity Where
208:56 - amount is a number of T and quantity and
208:59 - total quantity are of Type n and so this
209:03 - can be used to compute percentages so if
209:05 - we want to compute 20% of some amount we
209:07 - can call sp. split tokens of that amount
209:11 - comma 20 comma 100 of course we could
209:14 - also do the same with one and five as
209:17 - long as the ratio between this number
209:19 - and this number is what we want 20% it's
209:22 - not always 100 because we can consider
209:25 - having other kinds of percentages that
209:27 - are maybe smaller than 1% for example
209:31 - 0.1% so here all we would have to do is
209:33 - do one per thousand so we use quantity
209:37 - one total quantity 1,000 and this will
209:40 - compute 0.1% of 5,000 T okay let's use
209:45 - all this in an example and for an
209:47 - example we'll create our first
209:50 - decentralized Finance contract I'm
209:52 - definitely not an expert in finance and
209:55 - this is not a contract that we audited
209:57 - Etc it's really for educational purposes
210:00 - but we can show you how you can create a
210:03 - contract that people can lend money to
210:06 - for the purpose of gaining some interest
210:09 - over time we already presented the idea
210:13 - of baking and the fact that while baking
210:15 - ERS put some Tes at stake to get the
210:18 - rewards people who don't want to be
210:20 - Bakers by themselves can delegate their
210:23 - own TZ to the baker of their choice to
210:26 - get a share of the rewards when you pick
210:28 - a baker you can pick them based on
210:30 - multiple criteria you can check how much
210:33 - of the rewards they will share with you
210:34 - different bakers will share different
210:36 - percentages you can also check if they
210:39 - do their job well so if they ever miss
210:41 - the opportunity to create a blog because
210:43 - that's when they do create a blog that
210:44 - they get their reward and then share
210:47 - them with you so check how often this
210:49 - happens and of course you also want to
210:51 - check how they vote when there's a call
210:54 - for a vote for a new
210:55 - Amendment usually the reward you get
210:59 - when delegating your TZ is around 5% a
211:03 - year but there is no guarantee of that
211:06 - there's always a risk that after you
211:09 - delegate your test to a baker this Baker
211:12 - doesn't do their job well and misses a
211:15 - lot of blocks
211:16 - or doesn't pay you your Rewards or
211:19 - simply disappears and stop being a baker
211:22 - or changes address for example so when
211:24 - you delegate your Tes if you want to
211:26 - make sure that you get your share of the
211:28 - rewards you need to regularly check what
211:31 - your Baker is doing so you cannot just
211:34 - sit down wait a year and then get your
211:36 - profit there's a risk you wouldn't get
211:38 - anything your test themselves are not at
211:41 - risk because even if the baker behaves
211:44 - badly and gets slashed your own test
211:46 - that you delegate don't get
211:48 - slashed but the risk is that you won't
211:51 - get your
211:52 - rewards so the example we work on is a
211:55 - smart contract that offers the service
211:58 - for anyone who doesn't want to worry
212:00 - about that still want to delegate their
212:02 - test to some Baker They Don't Really
212:04 - necessarily want to worry about which
212:06 - Baker they just want to be assured to
212:09 - have some yearly interest without any
212:12 - risk at all so pause the video and think
212:16 - how you would create such a contract
212:18 - that guarantees to whoever is putting
212:21 - their money that they will get their
212:24 - rewards so what we will do is our first
212:27 - decentralized Finance
212:29 - contract that will enable the
212:32 - externalization of the baker selection
212:36 - and monitoring Etc making sure your
212:38 - Baker does a good job in exchange it
212:41 - will take a small share of your rewards
212:43 - so it will guarantee you that you will
212:45 - get get a fixed reward of 4% a year to
212:49 - make sure that whatever happens you will
212:51 - get this
212:53 - 4% this amount for a whole year will be
212:57 - deposited in advance in the contract and
212:59 - stuck there for you to get your
213:02 - guaranteed interest but the owner if
213:04 - they do their job well delegate the
213:06 - balance of the contract to the right
213:07 - Baker monitor it Etc and make sure they
213:10 - get 5% and they will be able to keep
213:13 - anything that's beyond the 4% that they
213:16 - owe you in exchange for taking the risks
213:19 - and we will do that in a contract that
213:21 - handles only one lender at a time so
213:23 - only one person will be using this
213:26 - contract at a time pause the video and
213:29 - think a bit about how you would do that
213:31 - okay so we will have two people
213:34 - interacting with this contract the
213:36 - lender so that's the one that has money
213:39 - to invest in the contract and want to
213:41 - get 4% back so the lender will be able
213:45 - to deposit their funds using a deposit
213:47 - entry point and put some test on the
213:50 - contract and at some point in the future
213:52 - when they want to get their deposit back
213:54 - plus their earnings they will call a
213:57 - withdraw entry
213:58 - point on the other side the owner will
214:02 - be able to control what beger to
214:04 - delegate the balance of the contract to
214:08 - and they will have a set delegate and
214:09 - true point to say I want to delegate to
214:12 - this Baker and they can change it at any
214:14 - time is their responsibility to make
214:16 - sure they pick the right Baker because
214:17 - it will impact how much they earn of
214:21 - course at some point they may want to
214:23 - withdraw their own funds so we need to
214:26 - have an owner withdraw entry point for
214:28 - the owner to collect any amount that
214:31 - they are allowed to withdraw they always
214:33 - need to make sure there's enough Reserve
214:35 - in the contract to pay whatever the
214:38 - lender has deposited plus one year of
214:41 - yields finally since the need is
214:44 - reserved in the contract need to have a
214:46 - default entry point to deposit this
214:48 - Reserve at the beginning before the
214:49 - lender deposits their own funds but this
214:52 - is also the entry point that Bakers use
214:57 - to send money to the contract when a
215:00 - baker send their rewards to an address
215:02 - that delegated to them they simply send
215:05 - test to this address so we need to make
215:07 - sure that our smart contract has a
215:09 - default entry point that accepts the
215:12 - rewards quick reminder the default entry
215:14 - point of a smart contract is the entry
215:18 - point that is called whenever you simply
215:20 - send some test to the contract if there
215:22 - is no such entry point the transfer will
215:24 - fail and if this entry point fails then
215:27 - the transfer will fail and you won't get
215:29 - the test so if all you want to do is
215:32 - accept direct transfers from anyone you
215:35 - can create this entry point called
215:38 - default that doesn't take any parameter
215:40 - and doesn't do anything so with the
215:42 - instruction pass but remember that any
215:45 - entry point can accept TZ as long as the
215:48 - call is valid okay so in our yield fing
215:51 - contract we will do a number of
215:54 - computations so first we need to add a
215:56 - ramp of period so it's a period of time
215:59 - where you don't get any yield and the
216:01 - reason is that when you delegate your
216:03 - Tes to a baker you don't immediately
216:05 - start earning you need to wait for the
216:08 - baker to get the opportunity to bake a
216:10 - block so to keep it simple we simply
216:12 - wait let's say 3 weeks before we start
216:15 - paying interest to the lender after that
216:18 - ramp period the yield becomes
216:21 - proportional to the time between the
216:24 - deposit after that rer period and the
216:27 - withdrawal so if you live your money for
216:29 - one year you would get exactly the
216:32 - annual yield rate if you wait for 6
216:35 - month you will get half of that as
216:37 - interest as we said earlier we always
216:39 - want the owner to leave a reserve so
216:42 - that they can always pay one year of
216:45 - Interest
216:46 - so we will have a computation to do that
216:48 - where we multiply the deposited amount
216:51 - so deposited amount is whatever the
216:53 - lender has deposited multiply that by
216:56 - one because they at least should have
216:58 - that amount kept in the balance of the
217:00 - contract plus the annual yid rate so
217:04 - let's say 4% of that amount when the
217:06 - lender
217:08 - withdraws from the contract the amount
217:11 - they should get is their deposit times
217:14 - one plus their deposit multiply by the
217:18 - annual yield rate and multiply by what
217:22 - percentage of the Year
217:24 - passed since the deposited so the
217:27 - duration since the deposit after the
217:29 - rampant period divided by one year and
217:33 - here is how we compute this direction so
217:34 - we take the current date minus the
217:37 - deposit date and we substract the rampup
217:39 - duration now if we look at the contract
217:42 - in more detail we can focus on what we
217:44 - need to store so we need to store the
217:47 - address of the owner the address of the
217:49 - lender how much money was deposited on
217:53 - the contract when it was deposited we
217:57 - can store the annual yield rate that we
217:59 - promise that we will give to the lender
218:03 - and then how much time we need to wait
218:05 - before the yield starts so the ramp up
218:08 - duration then we have our different
218:10 - entry points we already talked about the
218:11 - default entry point we need the owner
218:14 - withdraw entry point for the owner to be
218:16 - able to withdraw some amount from the
218:19 - contract and then we will check that
218:21 - it's indeed the owner calling we check
218:24 - that the amount they leave in a contract
218:27 - is sufficient and then we send the
218:29 - amount request to them if everything is
218:32 - good we'll have the set delegate entry
218:34 - point that takt an address it's
218:36 - technically an option on an address as a
218:39 - parameter it will simply check that the
218:41 - caller is the owner only the owner may
218:43 - decide which Baker to delegate to to and
218:46 - then they will simply change the
218:48 - delegate to this address we need the
218:50 - deposit entry point for the lender to
218:52 - deposit funds and when we do that we
218:55 - check that there's not already some
218:56 - amount been deposited so we cannot
218:58 - increase how much we have in the
218:59 - contract we can simply deposit once then
219:02 - withdraw and if we want to start again
219:04 - we can deposit a bigger amount or a
219:06 - smaller amount so when we deposit keep
219:08 - things simple we check that the current
219:12 - deposit is zero and then we update this
219:15 - value and we keep track of when it was
219:18 - deposited finally when the lender tries
219:21 - to withdraw some funds we check that the
219:24 - caller is indeed the lender then we
219:26 - compute how long it has been since the
219:29 - lender deposited the amount and we
219:31 - subtract the ramp up duration from that
219:34 - and finally we
219:36 - compute how much they should get back so
219:38 - that the amount that deposited plus this
219:42 - amount times the yield so they are
219:46 - guaranteed annual yield rate times the
219:49 - proportion of the year that they got the
219:51 - money for then finally to say that the
219:54 - money has been reimbursed so we can say
219:56 - deposited amount is back to zero so that
219:59 - the owner can now withdraw everything
220:02 - because they don't need to leave any
220:03 - reserve anymore since there's no nothing
220:05 - deposited so now we can check the actual
220:07 - code so we see the constructure that
220:10 - initializes everything the owner the
220:13 - lender deposited demount deposit date
220:16 - here we set the deposit data at zero we
220:18 - could say well nothing has been
220:20 - deposited yet so why not use an option
220:23 - but again an option will make things
220:25 - more complicated here it's easier to
220:27 - just set the data at
220:29 - zero we see that we have our default
220:32 - entry point that doesn't do anything
220:34 - just
220:35 - pass uh we have our set delegate entry
220:39 - point that simply takes the address of
220:42 - the new delegate technically an option
220:45 - we check that it's the owner wanting to
220:47 - change a delegate and then we call sp.
220:50 - set delegate so this sets the Delegate
220:53 - for the whatever test are in the balance
220:56 - of the contract to this
220:59 - address we have a deposit entry point
221:01 - for the lender to deposit their money so
221:04 - we check that it's the lender we check
221:08 - that there's not already some money
221:09 - being deposited which would cause a mess
221:12 - in all the
221:13 - computations we then store the amount in
221:16 - deposit amount and we store the current
221:18 - date in deposit
221:21 - date now when the user wants to withdraw
221:24 - their funds again we check that it's
221:26 - indeed the lender we compute the
221:29 - duration since they put the money in so
221:32 - for that we take the deposit date we add
221:35 - the ramp up duration that's a number of
221:37 - seconds we subtract that from the
221:39 - current
221:40 - time and then we convert it to that
221:43 - there's an easy way easier way to
221:45 - convert to n here we can simply do
221:48 - as
221:50 - nut so that's the duration and then we
221:53 - take the duration of a year so that's
221:54 - approximate um but it's good enough we
221:57 - say year is 365 days and then we compute
222:01 - the yield for one year so we multiply
222:04 - the deposited amount times the annual
222:06 - yield rate that's at percentage let's
222:10 - say 4% this would be four so that's one
222:12 - year yield multipli by 100
222:17 - then using the duration we compute the
222:19 - duration yield so how much for if this
222:22 - is how much for one year multiply by 100
222:25 - this would be how much for this
222:27 - direction so we use split tokens to take
222:30 - one year
222:32 - yield and we for this duration divided
222:35 - one one year times 100 so that g us how
222:39 - much yield we should get for this
222:42 - duration then we simply send that amount
222:46 - plus the deposit itself back to the
222:49 - lender and then we reset everything
222:51 - deposited amount to zero and deposit de
222:53 - to
222:55 - zero finally the owner May withdraw at
223:00 - any time but always needs to keep a
223:02 - reserve that's enough to pay for one
223:04 - year of Interest so here we check that
223:07 - the owner calling owner withdraw we
223:10 - compute one year of yield again using
223:12 - split tokens so we take the deposit
223:15 - amount and we take the annual yeld rate
223:18 - out of that so 4% of that amount and the
223:22 - reserve should be whatever the user has
223:25 - deposited plus that
223:28 - interest if the amount that the owner is
223:31 - requesting to withdraw leaves enough so
223:36 - the balance minus whatever we take is
223:38 - more than this Reserve that we have to
223:40 - leave then we can send them that amount
223:43 - and that's it if we run
223:47 - it we can see that we initialize it with
223:49 - an annual y rate of 4% initially
223:52 - everything is
223:53 - zero then we set up this random duration
223:57 - ramp up duration I think that's 3
224:01 - weeks the owner transfers five TZ to
224:05 - allow for some amount of deposit then
224:08 - the user deposits 100 T then we check
224:12 - that if we try to deposit again this
224:14 - doesn't work we can only have one
224:16 - deposit at a time on the contract if we
224:20 - try to withdraw with the wrong owner we
224:21 - cannot do that if we try to withdraw too
224:25 - much it doesn't work either but we can
224:28 - here withdraw one TZ and we still have
224:30 - enough to pay for one year of
224:33 - yields here we use set delegate to
224:37 - change the delegate of the contract so
224:40 - which Baker We delegate
224:42 - to and then here the owner withdrawals
224:46 - after some anount of time that we set
224:48 - here that corresponds to a year plus the
224:52 - ramp
224:53 - period and we see that they received 104
224:56 - Tes so they deposited 100 Tes and now
224:59 - they get 104
225:03 - back so that could be a very nice way to
225:06 - provide a
225:07 - service but again this contract has not
225:10 - been audited um this is just for
225:12 - educational purposes so don't trust it
225:15 - as
225:16 - is now it's your turn to work on an
225:19 - exercise where you do some
225:21 - computations and we'll take this
225:24 - opportunity to play a little bit with
225:26 - interesting nfts so the idea is that
225:28 - with smart
225:29 - contract we could show that you can
225:31 - create digital objects that has an owner
225:34 - that can be bought Etc but you can add
225:36 - interesting properties that can be very
225:39 - unique either Collectibles or you can
225:41 - even run interesting social experiments
225:43 - so let's try to do one
225:46 - we will create an nft that has a price
225:49 - that automatically increases by 10%
225:51 - after every sale so the owner of the nft
225:55 - doesn't set the price at which they sell
225:57 - it the price is automatically 10% more
226:00 - than whatever they paid for so pause the
226:02 - video think of how you would do that and
226:05 - give it a try so if we want to create an
226:07 - nft that has a price that increases by
226:10 - 10% after every sale we will need to
226:13 - remove the set price entry point point
226:15 - from our nft contract and then we will
226:18 - need to change the buy entry point so
226:21 - that it automatically sets the new price
226:24 - at 10% more than the previous price
226:26 - after the sale so if we do that and you
226:30 - start with an nft that's worth one TZ
226:32 - after the first sale it would be 1.10 TZ
226:35 - after 10 sales it will be 2.59 TZ and
226:38 - after 100 sales only this is exponential
226:41 - it will be
226:43 - 13,780 t
226:45 - pause the video and think about how you
226:47 - would change your contract and implement
226:49 - this let's look at the solution the
226:52 - contract we get is actually pretty basic
226:55 - we have three values in the storage the
227:00 - owner the Met data and our price that we
227:02 - set with an initial price and we only
227:05 - have one entry point left the buy entry
227:09 - point that simply checks that whoever is
227:12 - trying to buy is sending the right price
227:15 - then sends that amount to the owner and
227:18 - changes the owner of the nft and then
227:22 - computes the new price using sp. split
227:25 - tokens so we take the old price and we
227:28 - take 10% of that price and we add it to
227:31 - the old
227:33 - price and we can give it a try and
227:36 - calling a couple times the buy entry
227:39 - points and we see okay we initialize
227:41 - with five Tes so the first purchase
227:46 - is the actual price five T so we
227:48 - transfer five T back to the owner then
227:51 - the next time someone wants to buy then
227:53 - it became 5.5 T So 10% more and so we
227:57 - transfer 5.5 t to the new owner and
228:00 - finally if we try to purchase with the
228:03 - wrong amount so six t it's incorrect
228:06 - because now the
228:10 - price is
228:13 - 6.05 as we ver ify
228:16 - here so all good so the sad thing about
228:19 - this is that if you deploy this contract
228:22 - all you will get is those initial five
228:24 - tests if the price keep increasing and
228:27 - many people buy it and sell it it would
228:29 - end up being worth tens of
228:31 - thousands but as the initial creator of
228:34 - this great idea you will only get
228:37 - 5% wouldn't it be nice if you could get
228:40 - a percentage of every sale and therefore
228:43 - if your experiment Bec very successful
228:46 - then you would get a nice reward so what
228:49 - we want to do is create an nft that
228:52 - gives royalties to its author the idea
228:55 - is that every time the nft is sold we
228:58 - want the author of The nft to get 5% of
229:02 - the price of the sale and of course the
229:04 - 95% remaining should go to the owner of
229:07 - the nft so try to add this feature to
229:11 - your nft contract of course you will
229:13 - need to add an author in in the storage
229:15 - that is separate from the owner and when
229:17 - you will compute the shares that the
229:19 - owner and the author have you can use
229:22 - sp. spit tokens so pause the video and
229:26 - give it a try let's take a look at the
229:28 - solution here we added two fields in the
229:31 - storage the author and the percentage of
229:35 - each cell that the author should get
229:38 - then we modified or buy entry point to
229:41 - compute the share that the author should
229:43 - get so for that we use split tokens and
229:46 - we take the price and we compute the
229:48 - author rate so
229:50 - 5% and for the owner share we take
229:54 - whatever is left so the price that was
229:58 - just paid minus the share of the
230:00 - author it's important to do that rather
230:04 - than do another speed token maybe with
230:07 - 95% because there's always a risk that
230:10 - with some approximations and running Etc
230:14 - the total wouldn't be 100% in which case
230:17 - the sale couldn't happen because you try
230:19 - to send even a tiny bit more than 100%
230:21 - everything would fail so it's
230:23 - safe for the last person you send test
230:26 - to to send whatever is left after
230:28 - everything else has been added we'll
230:30 - talk about that a bit more in a minute
230:33 - then we
230:34 - send the owner share to the owner and
230:38 - the author share to the
230:40 - author finally we still have our formula
230:43 - to increase the price and then we update
230:45 - the
230:47 - owner you could wonder why we didn't
230:50 - send simply the balance to the last
230:52 - person for example to the owner after
230:55 - sending their share to the author but
230:58 - it's important to have in mind that when
231:00 - you send
231:02 - Tes using sp. send it's not actually
231:05 - directly sending the Tes to the owner
231:07 - it's adding a transaction to the list of
231:09 - transactions that will be executed after
231:12 - the end of our entry point
231:15 - so it's not executed immediately and it
231:17 - definitely doesn't change the balance
231:19 - the balance that you read in this entry
231:21 - point stays the same for the whole
231:23 - direction of the entry point but later
231:25 - on the transfer will be done to the
231:27 - owner and then the transfer will be done
231:29 - to the author or at least will be
231:31 - attempted again you need to be careful
231:34 - when splitting the
231:36 - balance if we did it this way it's a bit
231:39 - unusual but if we did it by subtracting
231:42 - to the price the share that the other
231:45 - person would get so here we do split
231:47 - tokens we take the
231:48 - price uh whatever is sent to the author
231:52 - as a percentage then 100 minus other R
231:54 - so we subtract 95% of the price from the
231:58 - price for to get what is sent to the
232:00 - author and here we do the same with the
232:02 - owner if we did it in this bit unusual
232:05 - way but when you look at the computation
232:08 - everything seems to be good you send the
232:11 - price minus 95% to the author and then
232:15 - you send the price minus 5% to the owner
232:19 - this should give 100% right but if you
232:22 - do that with some value of the price you
232:25 - would end up with running issues where
232:28 - this value is a tiny bit less than 95%
232:32 - therefore the Alor share is a tiny bit
232:34 - more than 4 or five% so it would be if
232:39 - the um rate is 4% I would be 4.1 and
232:43 - then the owner share would be 96
232:45 - 6.1 so the total would be
232:49 - 100.2 and therefore this would fail
232:52 - because there's not enough money in the
232:54 - balance of the contract you cannot send
232:56 - 100 point something per of the amount
232:58 - this would
232:59 - fail so again the best practice is for
233:03 - the last amount that you sent compute it
233:05 - as the total that you have so the
233:08 - balance of the contract for example the
233:09 - price minus whatever you send to the
233:12 - others this would avoid
233:15 - failures due to running issu that would
233:17 - get your contract completely stuck
233:18 - unfortunately there's still a flaw in
233:20 - our contract so if you look at this
233:22 - piece of code can you identify the flaw
233:27 - please pause the video and think about
233:29 - it so this is a flaw we already talked
233:31 - about the author could block any sale
233:35 - and the reason is that the author here
233:37 - could be the address of a smart contract
233:40 - that has a default entry point that they
233:42 - can switch to reject any payment so this
233:47 - transaction could be blocked by the
233:49 - author so the author would say nope the
233:52 - nft I created years ago I don't want it
233:54 - to be sold anymore or maybe they could
233:57 - try to use it to extort money from the
233:59 - current owner that really wants to sell
234:01 - it and needs the money so this could be
234:03 - dangerous so again the best practice is
234:06 - to let the author claim their share
234:09 - using a separate claim entry point that
234:11 - they can call you could say the owner
234:13 - can do this same and reject the the
234:16 - transfer but in this case it doesn't
234:18 - really matter here the whole point is
234:19 - that the owner wants to sell so if they
234:22 - refuse to sell well they just don't get
234:24 - their money this is not a big deal but
234:26 - for the author it's really important
234:28 - they shouldn't be able to block the sell
234:30 - so the way to do it is to remove this
234:34 - line so that we don't directly send the
234:37 - money to the author but we add an entry
234:40 - point claim author rate that the author
234:43 - can use to get whatever is left in the
234:46 - balance of the contract so we check that
234:48 - it's indeed the author and we send them
234:51 - the current balance of the
234:53 - contract so you may wonder if there
234:57 - could be a flaw if the author called
234:59 - this at the wrong time so for example
235:01 - when we
235:03 - buy we send the test to the balance of
235:06 - the contract then we check okay is the
235:09 - amount right we compute the share of the
235:12 - author Etc and then we send the owner
235:16 - but you could think in the meantime the
235:18 - balance contains all the money that is
235:21 - owed to the owner so couldn't the author
235:24 - call this right at the right time in the
235:27 - middle of this to steal the balance of
235:31 - the contract and the answer is no
235:33 - thankfully because the execution of an
235:36 - entry point is atomic nothing else can
235:38 - happen while this is running there is no
235:42 - race condition there's no parallel
235:43 - execution
235:45 - everything is serialized so this code
235:49 - and any transaction generated by the
235:51 - entry point will be completely finished
235:55 - before anyone can call any other entry
235:58 - point everything is serialized and done
236:00 - in sequence so you'll safe from that
236:02 - kind of issues in this module you will
236:04 - learn how to use records in smart p and
236:08 - will'll apply this to an example your
236:10 - first Dynamic
236:12 - nft a record is a data structure that
236:15 - allows you to group several values
236:18 - within a single object single value each
236:22 - of these values has its own name within
236:24 - the record and the different values may
236:26 - have different types for example you
236:29 - could create a record to store data
236:31 - about a person so you would have their
236:33 - first name that is a string their last
236:35 - name also a string and for example their
236:38 - age that would be a n we already
236:41 - manipulated records implicitly when we
236:44 - call called a smart contract with
236:46 - multiple parameters so when you call an
236:48 - entry point and you have to give the
236:49 - name of every parameter that was
236:51 - creating a record since in reality an
236:54 - entry point only takes one parameter so
236:57 - if you want to pass multiple ones you
236:59 - have to use uh record but now we'll work
237:02 - on explicit
237:03 - records to create a record you use the
237:07 - syntax sp. record and between
237:10 - parentheses the list of fields with the
237:13 - name equals the value and all separated
237:17 - with commas so here we have a record
237:19 - with a integer or natural named field
237:22 - one and then the string named field
237:25 - two once you have a variable that
237:28 - contains a record you can access any
237:30 - field simply by using the name of the
237:32 - record Dot and the name of the attribute
237:35 - so here if you create a record with two
237:37 - values X and Y we can extract the value
237:40 - of x by doing record. X
237:45 - when you need to describe the type of a
237:47 - record this is how you do it so you may
237:50 - notice that anytime we Define a type for
237:53 - example when we created a pair or an
237:55 - option we used square brackets after the
237:59 - name of the type uh the record is
238:01 - basically the exception to that for
238:03 - technical reasons related to how python
238:06 - works so in this case we use regular
238:09 - parenthesis so creating a record type
238:12 - looks very similar to creating a record
238:15 - value so we do sp. record and then
238:18 - between parenthesis the list of fields
238:21 - and this time the only difference is
238:23 - that instead of providing the value of
238:25 - each field we provide the type of each
238:27 - field so here field one equals sp. not
238:30 - and field 2 equals sp. string you may
238:34 - sometimes end up having to provide the
238:36 - type of a record multiple times within
238:39 - your code and it can become quite large
238:41 - if you have many fields in a record
238:44 - so to save your time you can name the
238:48 - type by creating what we call a type
238:50 - abbreviation that you would put outside
238:52 - of any contract within the main module
238:55 - so for that you would create a tie by
238:58 - giving the name you want to associate to
239:00 - it so here I wrote T record as the name
239:03 - for some example then colum and the
239:06 - keyword type equals and then the
239:10 - description of the type and then within
239:12 - your contract every time you needed to
239:14 - describe the type of your recard you can
239:16 - put this name instead let's work on an
239:19 - example and we will create a dynamic nft
239:23 - so usually an nft is associated with
239:25 - some static image or maybe some video or
239:28 - some music that you may actually want to
239:30 - store offchain and then you only store
239:33 - the hush in the metadata but for things
239:37 - like games you may want to have nfts
239:39 - that have different properties that
239:41 - evolve over time and with a set of rules
239:43 - on how they can evolve so we'll create
239:46 - this kind of nft and we will make our
239:48 - nft contract an nft of some creature
239:51 - that we would use in a game so we will
239:54 - give this creature two attributes a name
239:57 - and a size and we want to store both of
240:00 - them in the metadata field of our nft
240:03 - then we'll be able to add a feed entry
240:06 - point where we can pay one TZ and that
240:09 - will increase the size of the creature
240:11 - by one so we will increase this at
240:13 - distribute by one every time we call
240:16 - feed so let's look at the contract here
240:19 - in the Constructor we don't actually
240:21 - change anything because we still store
240:24 - whatever metadata is sent and we don't
240:26 - need to specify the type it will be
240:28 - specified directly in the taste case or
240:31 - inferred from other aspects of the
240:34 - contract for set price nothing changed
240:37 - buy nothing changed but now we add this
240:39 - new entry point feed where we check that
240:43 - the color paid one t and we simply
240:47 - change the size attribute of metadata
240:50 - and increase it by one so that's all we
240:54 - had to change in the contract
240:56 - itself and in the test that's where we
240:59 - initialized the storage with a metadata
241:02 - that is composed of a record so we
241:04 - create sp. record with an attribute name
241:07 - say let's call it beast and a size that
241:11 - we initialize at 10 so here here we used
241:14 - to just have a single value a string and
241:16 - now we provide a record and that's about
241:19 - it in our test we add this call to feed
241:22 - where we pay one TZ using Alice's
241:25 - account you may notice that anyone is
241:27 - allowed to feed the beast it doesn't
241:29 - have to be the
241:32 - owner so let's run it and we can see
241:35 - that now in the metadata we have this
241:37 - record presented using two columns one
241:40 - for the name one for the size and so we
241:42 - have the name Beast size 10 and we set
241:46 - the price and we fit it and when we
241:47 - check the details you can see that now
241:50 - the med contains a name that's Ste beast
241:52 - but then we crease the size to
241:55 - 11 records are actually not supported by
241:59 - the underlying mikon language there is
242:02 - no such thing as a record in mikon so
242:06 - what you do to create a record is to use
242:09 - nested pairs so as you remember pairs
242:13 - enable you to group two values with
242:15 - different types and so if you create a
242:17 - record with just two values then it's
242:19 - just simply a pair but if you create a
242:22 - record with three values then we need to
242:26 - use two pairs and the idea is that the
242:28 - first element of the pair would simply
242:30 - be the first of the three element but
242:32 - the second element of the pair would be
242:34 - another pair with the next two elements
242:37 - so like this so we have a pair that
242:39 - contains an regular element an integer
242:42 - and then another pair pair with two
242:45 - values in mikon we write it like this or
242:48 - a first pair with 42 and then the second
242:50 - element is a pair with 12 and three this
242:53 - way of organizing it is what we call the
242:55 - right C presentation so if we were to
242:58 - add another element we would again
243:00 - replace the last element of the inside
243:03 - pair and then replace it with another
243:05 - pair that contains three and then the
243:08 - next value we would like to add so if we
243:11 - keep adding it looks like that it just
243:13 - looks like a com with a handle and a
243:16 - different teeth it would be possible to
243:19 - represent a record in using a different
243:21 - approach and instead of always using the
243:24 - second
243:25 - element and replacing it with a new pair
243:28 - we could do the same but on the left
243:30 - side so take the first element of the
243:32 - pair and then replace it with its own
243:33 - pair we would still put the value in
243:35 - this order so if you Traverse the tree
243:38 - from left to right you would obtain all
243:40 - the different values so this would be
243:43 - what we call the left com
243:45 - representation both are perfectly valid
243:47 - and both are possible with mikin and
243:50 - it's really a matter of convention
243:52 - whether we use right comb or left com
243:55 - different languages actually may use
243:57 - different representations but if you
243:59 - want to be able to make two contracts
244:02 - compatible and make sure they understand
244:03 - each other you can specify what layout
244:07 - you want to use so if you want to use
244:09 - the righton approach after the creation
244:11 - of your record you can add dot layout
244:14 - out and then between parenthesis you
244:16 - describe the structure so here we have
244:18 - the first element of the pair and then
244:20 - another pair with the two elements the
244:22 - names of the two elements between double
244:25 - quotes on the other hand if you want to
244:27 - use the left C layout we would have to
244:30 - do dot layout and then the first pair
244:33 - with A and B comma name of the last
244:36 - element so sometimes you your contract
244:39 - has to interact with another contract
244:40 - that uses a specific layout that may be
244:43 - different for the default layout your
244:45 - language is producing so that's why you
244:47 - need that now it's your turn to work on
244:50 - an exercise let's change this uh Dynamic
244:53 - nft contract to add an extra attribute
244:56 - to the metadata we will call it strength
244:59 - and then we will add a train entry point
245:02 - that somebody can call but only once
245:05 - within a window of 24 hours you may
245:08 - never call it more than once within a
245:10 - given 24 hours window so with a strain
245:14 - and two point if the size is more than
245:17 - 10 it will reduce the size by one and
245:20 - then in exchange increase the strength
245:22 - by one so you train you lose a bit of
245:24 - weight but you gain some strength pause
245:27 - the video and give it a
245:30 - try let's look at a solution so in the
245:34 - constructure we still don't change
245:36 - anything to the metadata but we need to
245:38 - add an extra field in the storage to
245:42 - keep track of one is the last last time
245:44 - we trained our creature so we add this
245:47 - last training parameter we set it at a
245:49 - time St zero of course this is way in
245:52 - the past so we don't need to worry about
245:53 - how soon we're going to be able to train
245:55 - it again we don't need to use an option
245:57 - we don't change set price or buy or the
246:00 - feed entry point but we add this train
246:02 - entry point we check that the size is
246:06 - not too small for it to be trained so it
246:08 - should be at least 10 we check that it's
246:11 - been more than one day since the last
246:13 - time we trained it so we add one day to
246:15 - last training and we compare that to the
246:17 - current time and if we're not yet passed
246:20 - this then we output too soon then we
246:23 - Mark the last training at the current
246:26 - time and then we apply the changes we
246:28 - reduce the size by one and we increase
246:30 - the strength by
246:33 - one in our test we initialize the
246:36 - strength at zero and then we try
246:39 - different tests so we start by feeding
246:42 - the Beast to increase the size by one
246:45 - then we train it to increase the
246:47 - strength by one and reduce the size by
246:50 - 10 we fit it again to train it a
246:53 - different time and see if everything
246:55 - works it would be good here to add
247:04 - scenario at C1 do data do
247:09 - strength equals 2 then we try to train
247:13 - it it again but the size is still 10
247:17 - let's verify that
247:21 - too so we're too small to train it so we
247:24 - need to feed it again then train it
247:26 - again and then we can
247:30 - verify that the strength is three and
247:33 - the size is back to 10 and we fit it one
247:37 - more time but we're trying to train it
247:40 - right away so it's 3 days plus 1 second
247:44 - and this should fail because it's too
247:46 - soon but if we wait a bit more then this
247:49 - should work and we can
247:52 - check that we had the strength at four
247:55 - and the size is back to 10 let's give it
247:57 - a
248:00 - try and here of course I forgot to put
248:03 - strength within the method record so I
248:06 - need to change
248:08 - that and add this here here
248:20 - here and
248:22 - there and it's all good so now we can
248:28 - check that we start with the name Beast
248:30 - size 10 strength zero and after we feed
248:34 - it the size increased after we train it
248:37 - the strength increased the size
248:39 - decreased we feed it again Etc then we
248:43 - try right too small too soon and at the
248:47 - end as we already check in the code the
248:49 - size is at 10 and the strength is back
248:51 - to four all good in this video you will
248:55 - learn how to use maps and big maps in
248:57 - the storage of your smart contracts and
248:59 - this will enable you to go from small
249:01 - smart contracts that only store a few
249:03 - informations uh single nft uh long
249:07 - single string to large scale smart
249:10 - contracts that can store whole databases
249:13 - of data many ffts and potentially the
249:16 - assets of millions of users a map is a
249:19 - data structure that store key value
249:21 - Pairs and the keys and values in a map
249:24 - can be of almost any type all the keys
249:27 - have to be of the same type and all the
249:29 - values have to be of the same type so
249:32 - for example we could store data about
249:34 - different countries we could create a
249:36 - map that stores the population of each
249:38 - country where the key would be the name
249:41 - of the country a string and the value
249:43 - would be the population of a country and
249:46 - that so for France you would have the
249:49 - population of France for the key Italy
249:51 - you would have the population of Italy
249:52 - Etc similarly you could create a map
249:55 - that stores multiple informations about
249:57 - each country where each entry would be a
249:59 - record so the key would still be a
250:01 - string but the value would be a record
250:03 - with not only the population but the
250:05 - size of the country and other
250:07 - information to create a map all you have
250:10 - to do is write a pair of curly brackets
250:13 - that that would create an empty map but
250:15 - you can also create a map that already
250:16 - has a few elements so you put the key
250:20 - column the value and then comma the next
250:23 - element you can put as many element as
250:25 - you want in the initial map separated
250:27 - with commas and every time the key
250:29 - column the value if you need to specify
250:33 - the type of your map you simply write
250:36 - sp. map and between square brackets two
250:39 - values separated by comma first type of
250:42 - the key
250:44 - comma the type of the value when you
250:47 - want to manipulate entries you use the
250:50 - name of your map and the value of the
250:53 - key between square brackets so to add or
250:56 - update an entry you write the name of
250:58 - your map and then between square
251:00 - brackets the key that you want to change
251:02 - and then you can assign a value to it if
251:05 - you want to delete an entry you simply
251:07 - write Dell and then the name of your map
251:09 - and between square brackets the value of
251:11 - the key that you want to delete from
251:13 - your map and more generally anytime you
251:16 - want to access any entry and value
251:19 - corresponding to a key you write the
251:21 - name of the map and between square
251:23 - brackets the value of the key if you
251:25 - want to check if a map contains a
251:28 - certain entry based on its key you can
251:31 - write my map dot contains then between
251:34 - parentheses the value of the key this
251:36 - will return true if the map contains an
251:39 - entry with this key and false otherwise
251:42 - with the map you you can also get
251:44 - information such as its size you can
251:46 - write sp. Len of your map and this will
251:49 - return the size of the map the number of
251:52 - entries in the map so for example if I
251:54 - have a map with two entries then if I
251:57 - call sp. Len of that map it would return
252:00 - to I can also request the list of items
252:05 - within my map and we'll talk about list
252:07 - later but basically if you call for
252:10 - given map do items it will turn a list
252:14 - where each element will be a record that
252:16 - contains two field a field key with the
252:18 - value of the key of that element and a
252:20 - field value with the value of the
252:23 - corresponding entry so this way we'll
252:26 - see that you can access all the elements
252:28 - of the map and look through them by
252:30 - numerating elements of the list if you
252:33 - only want a list of keys you can use dot
252:36 - keys and so for example if you do this
252:39 - map. Keys it will return a list of keys
252:42 - so one and two in the list similarly if
252:45 - you only want the values you use dot
252:47 - values and then will return a list that
252:49 - contains all the values before you start
252:51 - manipulating map there is something
252:53 - really important you have to have in
252:55 - mind and it concerns the costs and
252:57 - limitation associated with storing a lot
253:00 - of data between uses of a smart contract
253:04 - the storage of this contract is
253:08 - serialized so it is stored as a sequence
253:11 - of btes in a compact way and whenever
253:15 - you call the conract the sequence of
253:17 - bytes needs to be distalized to make it
253:21 - in the form that is convenient uh to
253:23 - manipulate so distalizing is taking this
253:27 - packed bite sequence and then converting
253:29 - it into a format that's really easy to
253:32 - use and manipulate that is typed Etc
253:34 - where we can efficiently access the data
253:38 - but once the entry point is over the new
253:41 - content of the storage has to to be
253:43 - serialized again until the next Call of
253:45 - the smart contract so convert it again
253:48 - to a simple squence of bites and this is
253:51 - done to save memory and make it possible
253:54 - to store this data on disk in an
253:57 - efficient manner but distalizing the
254:00 - storage at the beginning of every smart
254:02 - contract call and resizing it consumes
254:06 - CPU there's quite a few competition that
254:08 - you need to do to deserialize and resize
254:12 - so as the size of your storage gets
254:14 - bigger you increase the amount of CPU
254:16 - that you're using to call this smart
254:18 - contract and we cannot use an infinite
254:21 - amount of CPU for calling a smart
254:23 - contract uh we need every node to be
254:26 - able to run it so it has to be fast
254:28 - enough and there's only so much
254:30 - computation we can reasonably do to
254:33 - execute all of the transactions in a
254:35 - given block So to avoid abuse and
254:39 - transactions that take huge amount of
254:41 - CPU to be executed
254:43 - we have a system called Gaz that is an
254:46 - estimation of the amount of CPU needed
254:49 - to execute a given transaction like even
254:51 - smart contract calls for example we
254:54 - cannot know exactly how much CPU will be
254:56 - used because it really depends on what
254:58 - kind of computer you're running what
255:00 - kind of microprocessor Etc so this is
255:03 - why we need not the exact amount of CPU
255:07 - but some estimation that would be the
255:09 - amount of CPU that an average computer
255:11 - would spend to execute this uh
255:13 - transaction so for every operation every
255:17 - addition every cryptographic operation
255:20 - that we can run in a smart contract we
255:23 - have an estimation of how much CPU it
255:25 - will consume and so we have a
255:26 - corresponding gas cost of this operation
255:31 - so to limit the amount of computation
255:32 - that is done for a transaction and more
255:34 - generally for a block we use a financial
255:37 - incentive by having the color of this
255:40 - transaction pay for this spend Gap
255:43 - so as part of the fee they pay to the
255:46 - baker they pay for the amount of gas
255:48 - needed to execute the transaction and
255:51 - therefore they pay for the CPU they will
255:53 - be using on all the nodes and for each
255:56 - transaction there's an upper limit of
255:58 - how much gas we can spend and similarly
256:01 - for each block there's a limit on how
256:04 - much gas all of the transactions of the
256:06 - block can spend so these limitations
256:09 - mean that if the storage of your smart
256:11 - contract gets too big simply the fact
256:13 - that you need to deserialize and res
256:16 - serialize content before and after the
256:18 - execution of your smart contract means
256:20 - that you could reach this limit and the
256:22 - contract would fail so if you do a smart
256:25 - contract call and dis realizing all of
256:27 - the storage and resizing it costs more
256:31 - in terms of gas than the maximum amount
256:34 - of gas you can spend in one transaction
256:37 - then your call will fail and not be
256:39 - executed at all we already discussed the
256:42 - fact that most types have no limits in
256:45 - terms of how much you can store so we
256:47 - can store nuts and ins that are can be
256:50 - as large as you like time stamps can be
256:53 - as far in the future as you want strings
256:55 - don't have a specific length limits and
256:57 - similarly there is no hardcoded limit to
257:01 - how many entries you can store in a map
257:04 - but in practice there are two limits the
257:07 - first one is that every time you
257:09 - increase the storage so every time you
257:11 - add an entry to your map you have to pay
257:14 - for that extra
257:15 - storage and the second limit again is
257:18 - that if the storage gets too big the
257:20 - realizing and resizing it may exceed the
257:23 - gas limit so for these two reasons
257:26 - there's a limit to how many entries you
257:27 - can add in your map this limit will
257:29 - depend on how big the keys and values
257:31 - are and again if this happens to you
257:34 - your contract will be stuck any call
257:37 - will fail and any funds you have in the
257:39 - contract may be stuck forever to avoid
257:42 - the issue of exceeding the gas limits of
257:44 - a transaction due to having too much in
257:47 - your
257:48 - storage we can use a data structure that
257:51 - is similar to map and is called Big Maps
257:54 - big maaps are pretty much the same as
257:56 - Maps but with a few differences when
257:59 - your storage contains a big map instead
258:01 - of deserializing all of the content of
258:04 - the big map and resizing it at the end
258:06 - of your call we only deserialize and
258:10 - serialize individual entries in the big
258:13 - map that the contract call uses so
258:16 - instead of having to distalize the whole
258:18 - content of the big map you only
258:20 - distalize and resize the entries that
258:22 - you access to during your smart contract
258:24 - call so this removes the limitation of
258:28 - how much you can put in a big map as
258:30 - long as you only access a few entries
258:32 - within a single call of a smart contract
258:35 - there is no limit on how many entries
258:38 - you can have in your big map the syntax
258:41 - to use a big map is pretty much the same
258:44 - as the map except that you will use sp.
258:47 - big map instead of sp. map but many of
258:50 - the operations like getting the length
258:52 - of the big map getting the list of all
258:55 - the entries the keys the values are not
258:58 - available for big Maps so that means if
259:01 - you want to get any information about
259:02 - the content of a big map you have to
259:04 - know the key to the entries you cannot
259:07 - list all the keys you cannot enumerate
259:09 - them all you can say is is this key a
259:12 - available in my big map and what is the
259:15 - value for this key this limitation only
259:18 - applies on chain as everything is public
259:20 - on a blockchain outside of a smart
259:23 - contract you can request information
259:25 - about a map from a node and you can find
259:28 - out all of the entries in the a big map
259:30 - but on chain from within a smart
259:31 - contract you cannot list all the entries
259:34 - you can only request the entries that
259:37 - you already know the key so if we recap
259:40 - the syntax of a big map to create a big
259:42 - map instead of Simply a pair of curly
259:45 - brackets we have to use sp. big map so
259:49 - this will create an empty big map and if
259:51 - we want to have values then the syntax
259:54 - is the same for map curly brackets the
259:56 - different entries separated with comma
259:59 - and for each entry the key column and
260:02 - the value if we want to express the type
260:04 - of a big map we write sp. big map and
260:07 - between square brackets the type of the
260:09 - key comma the type of the value so very
260:11 - similar to map except we add big map
260:14 - here accessing deleting entries Etc is
260:19 - done exactly the same as for maps no
260:23 - difference but getting the size of the
260:26 - big map getting the list of entries the
260:28 - keys and values is simply not available
260:31 - because that would require dis realizing
260:33 - the whole big map which defeats the
260:36 - purpose of using big Maps let's take an
260:39 - example so far Our Endless wall was
260:43 - using a string to store all of the
260:45 - content so it was not really endless if
260:48 - the string got too long eventually it
260:51 - would be too big to be deserialized
260:53 - within a single call it would use too
260:55 - much G just to deserialize the content
260:57 - of our string so with a big map we can
261:00 - fix this instead of storing a long
261:02 - string we can store a big map of Records
261:06 - so in our big map the key would be for
261:07 - example the address of the sender so who
261:11 - is writing on on the wall and the value
261:14 - would be a record that contains the
261:17 - message a string and the date a time
261:21 - stamp so let's take a look at the
261:23 - contract we have this truly endless
261:25 - World contract and in storage we have a
261:29 - messages attribute that we initialize
261:31 - with an empty big map we then indicate
261:35 - what the type of this big map is by
261:37 - using sp. cast the attribute and then
261:41 - the type so SP big map and it between
261:43 - square brackets the type of the key an
261:46 - address so that would be the address of
261:49 - the user who sends the
261:50 - message and then the value a record that
261:54 - contains the content of the message a
261:56 - text or a string but also the date of
261:59 - the last message a time stamp in the
262:02 - right message entry point we have a text
262:05 - parameter so that's a message that the
262:07 - user wants to write we create a data
262:11 - that contains the record we would add if
262:14 - this is a new entry so with the content
262:17 - of the text and the current date but
262:20 - then we check if our big map already
262:24 - contains an entry for this sender then
262:28 - instead of using this new record we
262:31 - fetch the current data we have for the
262:33 - sender then we add the new text after a
262:38 - comma and we update the time stamp to
262:41 - the current time
262:43 - finally we write the data in the big map
262:46 - at the address of the sender so this
262:48 - will create a new entry if there is none
262:51 - and it will update the existing entry if
262:54 - there was already one now that this is
262:57 - necessary in both cases so even if we
262:59 - got the existing entry and modified it
263:03 - this wouldn't be sufficient to actually
263:05 - write the new entry to memory we always
263:09 - have to have this instruction to write
263:11 - back the data in the big map so we're
263:14 - not manipulating a reference to some
263:16 - data in the big map we have to
263:17 - explicitly write again and overwrite the
263:21 - content of this entry so we have this
263:23 - small test where we simply write a
263:26 - couple messages using Bob's
263:29 - address and so we can see that initially
263:32 - we have this empty big map then after
263:35 - the first
263:37 - call we have an entry for this key
263:40 - that's Bob's address and then we have
263:42 - this first message and sometime St zero
263:46 - and then after another call then we see
263:48 - that we updated the text with an extra
263:52 - message so here we have used a new
263:54 - syntax that we need to introduce the if
263:58 - and if lse syntax that's the typical
264:01 - python if and IFL syntax so you can
264:04 - write if this condition colon and then
264:06 - you have a block of code that you will
264:09 - execute only if this condition is true
264:12 - and if if you want to have an
264:13 - alternative piece of code you can write
264:15 - if the condition column and then the
264:18 - block indented block where you put a
264:19 - code to execute if the condition is true
264:22 - and then at the same indentation level
264:25 - as the if we can do else column and then
264:28 - we put here the code that we execute if
264:30 - the condition is not true we don't use a
264:33 - lot of conditional instructions in smart
264:36 - contracts so you won't see a lot of if
264:38 - and L's but once in a while it's
264:41 - necessary okay so now it's your turn to
264:43 - work on an exercise you will create a
264:46 - smart contract that is able to handle
264:49 - multiple nfps the approach we use so far
264:51 - to have one contract for each nft is
264:54 - really not ideal it can be unnecessarily
264:57 - costly to deploy one contract for each
265:00 - nft you want to Min and also makes it
265:03 - pretty hard to keep track of all the
265:05 - nfts so it's a lot better to have a
265:08 - smart contract that can store many nfts
265:11 - and for example a whole collection of
265:13 - nfts so pause the video and think about
265:16 - how you would do that and don't hesitate
265:18 - to start writing the code so if we want
265:20 - to handle multiple nfts we can store all
265:23 - of their content in a big map now that
265:26 - we know that we have to think okay what
265:28 - should be the key and what should be the
265:30 - value for this big map and so we have to
265:33 - think again about what an nft is it
265:35 - needs a unique identifier and it's an
265:37 - owner some metadata and a way to
265:40 - transfer or sell it and in this
265:42 - situation we will need to be able to
265:44 - create new nfts within our contract so
265:46 - we will need a mint entry point to
265:49 - create new nfts so if that helps you
265:52 - pause the video and try to continue
265:54 - working on your contract if we think
265:56 - more precisely about what we need to
265:58 - have in our storage we have to think
266:00 - about what we will use as a unique
266:03 - identifier for each nft this time the
266:06 - contract address won't be sufficient
266:08 - anymore it is still necessary so that
266:11 - you cannot simply write a separate
266:13 - contract with nfts that have the same
266:15 - ideas of all contract so the address of
266:18 - the contract will be part of the
266:20 - uniqueness of each nft but we will need
266:22 - something extra to differentiate between
266:25 - nfts that are stored in the same
266:27 - contract to do that we can simply assign
266:30 - each nft in our contract with a number
266:33 - so we can just start with one for the
266:35 - first nft two for the second Etc it's
266:38 - really that simple as long as these
266:40 - numbers are unique so we can store a nut
266:43 - that starts at one and every time we
266:44 - mint a new nft we increment it by one so
266:48 - this gives a number for each of our nft
266:50 - and we can use it as a key for the big
266:52 - map that will store all the information
266:54 - about our
266:55 - nfts again if that helps you please
266:58 - pause the video and continue to work on
267:00 - the code if not we can continue with
267:02 - some help so let's look at the code
267:04 - structure of this new smart contract in
267:07 - the storage we want to keep this counter
267:10 - this next idea that will will use as the
267:13 - value for the key for the next nft we
267:16 - want to make and everything else can be
267:18 - stored in a big map that stores all the
267:21 - information about the nfts we meant the
267:24 - key would be this token ID so the value
267:26 - of the cter that's with one for the
267:29 - first nft then two Etc and then in the
267:32 - value we have all of the data associated
267:34 - with this nft so we will have a record
267:37 - that contains the owner of this nft the
267:40 - current owner the original author of The
267:43 - nft as this is the type of nft where we
267:46 - still want to pay royalties and increase
267:48 - the price by 10% every time we sell it
267:51 - then we have the metadata and the
267:53 - current price then we need two entry
267:56 - points one entry point to Mint a new nft
267:59 - where we pass the Mt data so this will
268:02 - create a new
268:03 - entry in the tokens big map with as key
268:08 - the current value of next idea we can
268:11 - set the owner and the author to the
268:13 - address of the caller we can set
268:15 - metadata to the value of the parameters
268:18 - and to Mint and then we can initialize
268:21 - price to one test finally we need to
268:23 - increment next ID so that we have a new
268:26 - idea for the next token that will be
268:28 - minted then we need to buy entry point
268:30 - for someone to buy a given token and so
268:33 - this time we pass a parameter that is
268:35 - the number of the nft we want to
268:38 - purchase so it's token idea first we can
268:41 - check that is token exists in our big
268:44 - map then we can check that the amount
268:47 - sent by the buyer is equal to the
268:49 - token's price then we can send 5% of the
268:52 - price to the
268:53 - author then send the rest to the current
268:57 - owner finally we can replace owner with
269:00 - a new owner and then we can increase the
269:03 - price by
269:04 - 10% let's take a look at the contract in
269:08 - the storage we have this counter next
269:10 - idea that we initialized to one and then
269:13 - we have the tokens big map that we
269:16 - initialize with an empty big map you
269:18 - will notice that we don't add a cast
269:21 - instruction to specify what the type of
269:23 - the big map with the type of the key and
269:25 - the type of value we will use type
269:28 - inference and let it determine those
269:33 - types in the mint entry point we use
269:37 - cast to indicate what the type of the
269:39 - Met data is because all we do is stor it
269:42 - so there's no way in the contract to
269:44 - determine what its type is so we say
269:47 - this is going to be a
269:48 - string then we use the current value of
269:51 - next ID as a key to the new entry we put
269:56 - in our tokens big map and we store a
269:59 - record that will contain the metata a
270:03 - price initialized at one TZ the owner
270:06 - and the author that are the address of
270:09 - the sender finally we increment next ID
270:13 - to have it ready for the next
270:16 - nft in the buy entry point we need to
270:20 - take as parameter the token idea that we
270:22 - want to
270:23 - buy we check that there is such a token
270:27 - we fetch the data from the big map then
270:30 - we check that the amount sent was inde
270:32 - the current price we compute the fee
270:35 - that we have to send to the author we
270:38 - send everything but that fee to the
270:40 - current owner and then we send that feed
270:42 - to the author finally we update the
270:46 - address of the owner to this address and
270:50 - we compute the new
270:52 - price and that's it here we have a very
270:54 - basic test that only runs a call to each
270:57 - entry
270:58 - point and we can see the content of the
271:02 - storage so next idea is set to one we
271:04 - have this empty big map initially after
271:07 - the first
271:09 - mint we can see that in the tokens big
271:13 - map we have this entry with a key one
271:15 - the address of the author the metadata
271:18 - the owner and the price and then when we
271:21 - buy it we can
271:24 - see that the owner hasn't
271:29 - changed and the reason why the owner
271:31 - hasn't changed is that we have forgotten
271:35 - to rewrite the content of the token into
271:39 - the big map so it's very important here
271:41 - to add self. data. tokens of token idea
271:48 - equals token otherwise all these changes
271:52 - are simply ignored so if we run it
271:56 - again this time we can see that the
271:59 - owner goes from tz1
272:02 - H4 to tz1 HJ so it hasn't been been
272:06 - bought by Bob and we can see that the
272:08 - price has changed of course it would be
272:10 - good to do a lot more tests to make sure
272:13 - that the contract is
272:15 - good but keep in mind that passing all
272:17 - the tests and as carefully as you can
272:19 - write your test doesn't mean that
272:20 - there's no bug in your contract and here
272:23 - in this contract we have a big flaw that
272:25 - you should be able to recognize that
272:28 - probably wouldn't have been noticed even
272:30 - by extensive tests pause the video take
272:32 - a look at the code and see if you can
272:34 - find the
272:37 - flaw and here the flaw is one that we
272:39 - have already mentioned before when when
272:41 - we have those two lines the author could
272:44 - be a contract that has a default entry
272:47 - point that fails and this would prevent
272:49 - the sale so the author of the contract
272:52 - could use this as a way to extort funds
272:55 - from the current owner now how can we
272:57 - fix this flaw pause the video and try to
273:02 - change the contract so that it doesn't
273:04 - have this flaw anymore one idea that you
273:06 - could have is that since the cause of
273:10 - the flaw is that all
273:12 - can be smart contracts we could try
273:15 - preventing people from minting their
273:18 - nfts through a contract so basically in
273:21 - the Min entry point you could say okay
273:23 - let's check if the sender is a regular
273:26 - user or a smart contract and there's
273:29 - multiple ways to do it like comparing
273:31 - the address of the user to the smallest
273:34 - possible address of a smart contract for
273:36 - example and other ways so it is possible
273:39 - in practice but I really don't recommend
273:41 - it and the reason is that you don't want
273:43 - to write smart contracts that can only
273:46 - be used by regular users and couldn't be
273:49 - used by other contracts you really want
273:51 - to be able to benefit from all the
273:53 - potential users of your contract and as
273:56 - a user it's really convenient to be able
273:58 - to call your contracts through some
274:01 - other contract could be a joint account
274:03 - like we presented earlier could be a
274:05 - multisig that multiple people can
274:08 - control collectively and the idea is
274:11 - that contracts should be bricks that can
274:14 - interact each other so if you limit the
274:16 - author of your nfts to regular users you
274:19 - will prevent many useful use cases so I
274:23 - really don't recommend differentiating
274:25 - between regular users and smart
274:27 - contracts even though it's possible and
274:29 - it would indeed prevent this issue
274:32 - there's a much better way to prevent the
274:34 - issue but this will required an extra
274:36 - big map pause the video think about it
274:39 - and try to implement this fix
274:42 - so the solution is to avoid sending test
274:46 - directly to the author in the buy entry
274:48 - point and instead as we have done before
274:50 - we let the author claim their own test
274:53 - through a claim entry point the
274:55 - difference here is that we need to keep
274:57 - track of many different authors and
275:00 - store how much each author is being owed
275:03 - by the contract so for that we will
275:05 - create a new big map in the contract
275:08 - that we will call Ledger and it will
275:11 - have a key the address of a user and the
275:14 - value will be the amount that the
275:16 - contract owes to that user and so
275:19 - whenever the user calls claim entry
275:21 - point we check this Ledger if there's an
275:23 - entry for them we just send them that
275:26 - amount and then we delete the entry
275:28 - let's take a look at the modified
275:30 - contract so here in the Constructor we
275:32 - add this new big map The
275:35 - Ledger the mint entry point doesn't need
275:38 - to be changed at
275:39 - all so it's only in the bu entry point
275:43 - instead of directly sending the author
275:45 - fee to the author we check if there's
275:48 - already an entry in The Ledger if not we
275:51 - create one with zero Tes so we don't owe
275:54 - anything yet to them then we add the fee
275:58 - to their entry in The
276:00 - Ledger and that's it that's all we need
276:03 - to change instead of sending test
276:05 - directly to the author we add an entry
276:08 - in The
276:09 - Ledger and then we add the claim entry
276:12 - point where we check if there's an entry
276:17 - for the color of this entry point in The
276:19 - Ledger big map not we just cause an
276:21 - error saying we don't owe any test to
276:23 - that user then we send the amount stored
276:26 - in ledger to the user and to say that we
276:29 - don't own anything anymore we simply
276:31 - delete the entry in The
276:36 - Ledger so if we run a simple test we M
276:40 - an nft somebody buys an
276:43 - nft and then the author can
276:47 - claim the test and they are being
276:49 - transfer their 5% of the
276:52 - cell all good so with this big Maps we
276:57 - can start creating really powerful
276:59 - contract that store data for all kinds
277:01 - of users in this module you will learn
277:03 - the basics of mikelson the lowlevel
277:06 - language that all high level languages
277:08 - on tesos layer one compiled to and and
277:11 - this will give you a deeper
277:13 - understanding of what happens behind the
277:14 - scenes when you execute a smart contract
277:17 - all of the tesos Slayer one smart
277:20 - contract languages generate mikon they
277:23 - make it easier for you to write smart
277:25 - contracts but the actual smart contracts
277:27 - that you execute are in the michelon
277:30 - language it's a low-level smart contract
277:32 - language that was designed specifically
277:35 - for tesos you can think of it as the
277:37 - Assembly Language for the tesos layer
277:40 - one blockchain as a low-level language
277:43 - it doesn't have any variables everything
277:45 - is based on the use of a stack but even
277:48 - though it's lowlevel it offers quite a
277:50 - few features in particular it has a
277:52 - static type system with a number of
277:54 - basic types such as int not TZ string
277:57 - Etc it has built-in data structures such
278:00 - as pairs lists Maps sets or big maps and
278:04 - it has an API for you to access to the
278:06 - tesos protocol such as cryptographic
278:09 - curves transactions Etc it benefits from
278:12 - a number of design choices that reduce
278:14 - the risk of bugs so as we said mikon is
278:18 - a stack language at any time it has
278:21 - access to a number of values organized
278:24 - like a stack of plates where each plate
278:26 - contains a value most of the melson
278:29 - instructions affect a number of values
278:32 - at the top of this stack there are some
278:34 - instructions that can reach beyond the
278:36 - top of the stack but they always express
278:39 - the location of the elements they read
278:41 - relative to the top of the stack so to
278:44 - give you a quick idea of how this stack
278:46 - works if you want to compute three plus
278:49 - 4 * 5 we write this piece of michelon
278:52 - code first we push elements on the stack
278:55 - so we push three at the top of the stack
278:58 - then four becomes the new top of the
279:00 - stack with three below it then we put
279:03 - five at the top so in the stack we have
279:05 - three then four then five then we
279:08 - execute the multiplication operation mu
279:11 - it will consume the top two elements
279:14 - four and five compute their product 20
279:17 - and then put it at the top of the stock
279:19 - so after a mo we end up with three at
279:21 - the bottom of the stack and then 20 at
279:24 - the top of the stack then we can use the
279:26 - add instruction that will add those two
279:29 - values remove them from the stock and
279:31 - instead put the results so we get rid of
279:33 - 20 and three and we add 23 instead in
279:37 - the stack we'll see more examples of
279:39 - that the hardest is expect when you
279:41 - write mikelson code is to keep track of
279:44 - the content of the stack after in
279:46 - instruction and we will use commments
279:48 - and tools to help us with that let's
279:50 - take a look at a few instructions from
279:52 - the melon language we won't see them all
279:54 - in this module we will focus on the ones
279:56 - that manipulate the stack or allow you
279:58 - to do some arithmetic operations so that
280:01 - we can practice a little bit
280:03 - manipulating the stock the first
280:05 - instruction is an instruction to put
280:07 - something on the stack so we use the
280:09 - word push then the type for example int
280:12 - not t string Etc then the value so if
280:15 - you want to put the integer five at the
280:17 - top of the stack you write push in five
280:21 - next instruction is an instruction to
280:22 - duplicate whatever is at the top of the
280:24 - stack for example if you have three at
280:26 - the bottom of the stack and then five at
280:28 - the top of the stack and you call dub
280:31 - then you end up with three five and
280:33 - another five at the top of the stack the
280:35 - drop instruction simply gets rid of the
280:37 - top element of the stack so if we had
280:39 - three five5 we end up with three and
280:41 - five in the stack we say that it
280:44 - consumes the top element of the stack
280:47 - the Dig instruction is an instruction to
280:49 - move things around within the stack so
280:51 - you indicate a position related to the
280:53 - top of the stack and it will move that
280:56 - element to the top of the stack so if
280:58 - you have 553 and we do Dig Two it will
281:01 - take the third element from the top and
281:03 - bring it to the top so we end up with
281:05 - five at the bottom five in middle and
281:07 - then three at the top we took the three
281:09 - from the bottom we brought it back to
281:11 - the top the arithmetic operations
281:13 - consume elements from the top of the
281:16 - stack they remove them and then put the
281:18 - results back at the top so the add
281:20 - instruction takes the top two element in
281:22 - the stack consumes them so remove them
281:24 - from the stack and put the result back
281:26 - at the top of the stacks if we have
281:28 - let's say three five three then we take
281:31 - the three and five from the top add them
281:33 - to get eight and then we end up with
281:35 - three at the bottom and eight at the top
281:37 - for the product we use mole that takes
281:40 - the two elements consumes them puts a
281:42 - result of the mation at the top of the
281:44 - stack in mikas we have pairs so a pair
281:48 - is a value that contains two other
281:50 - values of any type and we use pairs a
281:53 - lot in meason so if you have a pair in
281:56 - your stock and you want to unpair them
281:59 - so that you get the two values as
282:00 - separate elements at different level of
282:02 - the stack then you can use unpair if you
282:04 - want to do the opposite take two
282:06 - elements and then pair them to replace
282:09 - them with a single element that contains
282:11 - them both as a pair you simply use the
282:14 - pair instruction finally you will see
282:16 - that even basic contracts will need to
282:19 - push an empty list of elements of a
282:21 - given type in the stack and for that we
282:23 - use the instruction nil and then we
282:25 - indicate the type that we want to put on
282:27 - the stack when you think about what a
282:29 - Merson contract does you really have to
282:31 - think about its input and its output
282:35 - because it's really all it does take
282:37 - some input and compute some output a
282:40 - melson contract
282:41 - starts with a stack that contains only a
282:44 - single value and this value is a pair
282:47 - that contains two elements the parameter
282:49 - of the contract that you pass when you
282:51 - call the contract and the current value
282:54 - of the storage so it can read those
282:57 - value and it also has access to some
283:00 - special values like the balance of the
283:02 - contract the address of the sender so
283:04 - whoever called the contract the
283:07 - timestamp of the blog that contains the
283:09 - current transaction this smart contract
283:11 - call belongs to and the amount that was
283:14 - sent by the caller to the contract Etc
283:17 - it can also access a table of Conant
283:19 - that all smart contracts have access to
283:22 - and finally it can obtain values from
283:26 - other smart contracts using onchain
283:28 - views but that's all it can read in
283:31 - particular cannot read the storage of
283:33 - other smart contract or any outside
283:36 - information can only read its own
283:38 - storage special values and then call
283:41 - onchain views from other contracts to
283:42 - obtain information from them and as the
283:45 - output the contract will produce a
283:48 - single element in the resulting stack
283:51 - and this single value will be a pair of
283:53 - two elements the first one will be a
283:56 - list of operations to execute after the
283:59 - execution of your smart contract your
284:01 - smart contract itself doesn't directly
284:04 - execute operations if your contract
284:06 - needs to transfer a few tests to an
284:07 - address what it will do is generate an
284:10 - operation and added to this list of
284:13 - operations that will be executed once
284:15 - its own execution is over the second
284:18 - value of the pair is the new value of
284:20 - the storage so you rewrite the whole new
284:22 - value of the storage that will replace
284:25 - the one you obtained at the beginning
284:26 - with an exception for the way we handle
284:28 - big Maps where you can write values
284:31 - individually so it's important to keep
284:33 - in mind that a smart contract doesn't
284:36 - have any effects other than Computing
284:38 - this pair and updating values in big
284:40 - Maps
284:41 - so let's take a look at an example this
284:44 - is a very basic smart contract in M that
284:47 - takes as a parameter a pair of integers
284:50 - A and B and all it will do is compute
284:54 - the expression 2 b + a and then put this
284:57 - value in the storage so here we can see
285:01 - the description of the type of the
285:03 - parameter so the parameter is a pair
285:06 - with two integers the first one we add
285:09 - anotation to say the it's named a and
285:12 - the second one is named B the storage
285:15 - only contains an integer we will put the
285:17 - result of the last computation in it and
285:20 - then we can see the code is put with the
285:22 - keyword code and then a pair of curly
285:25 - brackets and then we have the sequence
285:27 - of instructions one per line separated
285:30 - with
285:31 - semicolons so we start by unpairing the
285:35 - value that we have on the stack at the
285:36 - beginning so the storage and the
285:38 - parameter so then we have the parameter
285:41 - at the top of the stack and the storage
285:43 - at the bottom then we unpair the top of
285:46 - the stack so the parameter and we get a
285:49 - and b we use dig two to go get the
285:52 - storage back from the two levels below
285:55 - the top back to the top then we drop it
285:58 - we get rid of that element because we
285:59 - don't need the pr value of the storage
286:01 - we'll replace it with the result of the
286:03 - computation anyway then we call dig one
286:06 - that will get the B bring it to the top
286:08 - so we basically swap the top two El
286:10 - elements of the stack then we push the
286:13 - integer two at the top of the stack
286:16 - we'll multiply it with the second
286:18 - element so we do 2 * B and we get 2 B at
286:21 - the top of the stack we consume those
286:23 - two elements then we call add to add
286:26 - these two elements and replace them with
286:28 - a result so we get a single integer
286:30 - that's worth 2 b + a then since we need
286:34 - to end up with a list of reparation and
286:37 - the new value of the storage we need to
286:40 - create an empty list of operations so
286:43 - nail operation is an instruction that
286:45 - will generate this empty list of
286:47 - operations and then we pair them so that
286:49 - we end up with a pair that has this
286:51 - empty list of operations then the new
286:54 - value of the storage you will notice
286:57 - that we made a good use of the comments
286:59 - to keep track of what was in the stack
287:01 - at any time remember that the hardest
287:03 - part when you write code in mikon is to
287:06 - keep track of what's in the stack so in
287:09 - each comment we write what do we have on
287:11 - the stack after we execute this
287:13 - instruction so it's a good practice to
287:16 - put a commment for every line to
287:18 - describe what's in the stack after the
287:20 - execution of this instruction and then I
287:22 - recommend putting the bottom of the
287:24 - stack on the left and the top of the
287:26 - stack on the right this way when the
287:28 - bottom doesn't change we can see that
287:30 - it's exactly the same and the changes
287:32 - are always on the right so it's easy to
287:34 - just align the left so that the bottom
287:37 - of the stack doesn't move and only the
287:38 - top of the stack is changed for example
287:41 - between this instruction and this
287:42 - instruction we can clearly that the only
287:44 - change is to add two at the top of the
287:47 - stack if we use vs code with the melson
287:51 - extensions we can have a syntax
287:53 - highlighting but much better than that
287:55 - we can see that anytime we select an
287:59 - instruction on the right side the first
288:02 - extension will show us what is the
288:04 - current content of the stack and what it
288:07 - is before we execute this instruction
288:10 - and what what it is after we execute
288:12 - this instruction so we see can see that
288:14 - before we execute the first instruction
288:16 - we only have one element in the stack
288:19 - and it's a pair that contains the
288:21 - parameter itself a pair of two values A
288:24 - and B and the storage and we can see
288:27 - that after we execute and pair we have
288:29 - two values in the stack so at the bottom
288:32 - we have the storage and H and then at
288:34 - the top of the stack we have the
288:35 - parameter or pair
288:38 - a and if I click here here then again
288:41 - see that um before I have the two
288:44 - integers and the storage and after I
288:46 - execute drop I only have the two
288:48 - elements and that's it so it's very
288:50 - inconvenient to check that the type of
288:52 - what we have in stack at any moment is
288:54 - what we expect the second extension
288:57 - allows us to debug mikon code so I can
289:01 - click here to execute this code run and
289:05 - debug it will ask me the value of the
289:09 - contract parameter so here here this is
289:11 - a pair so I write it between curly
289:13 - brackets and for example I will write 1
289:16 - for a and 10 for B so that's my input
289:21 - parameter then it asks me for the value
289:23 - of the storage of type in so I don't
289:26 - need the storage I'm not using it in
289:28 - this contract so I'll just keep it at
289:30 - zero then I can debug line by line and
289:34 - on the left side I will see the content
289:37 - of the stock so I can use this to run my
289:42 - code step by step so I can see that I
289:45 - will unpair this value that compet my
289:47 - parameter and the storage so I can see
289:50 - that at the bottom of the stack I have
289:52 - my storage zero and at the top I have my
289:55 - pair one and 10 we can see that the pair
289:57 - here is represented differently from the
289:59 - syntax I Ed for input for the input I
290:02 - used curly brackets with the sual in the
290:04 - between here it is represented using a
290:07 - pair of parentheses and then a comma in
290:10 - between so be careful not to mix up the
290:12 - two but they both represent the same
290:14 - pair if I unpair this top element in the
290:18 - stock 110 then I will get one at the top
290:23 - and then 10 and then zero at the bottom
290:25 - of the stock now I execute dig two so I
290:28 - get the second element from the top of
290:30 - the stack and then bring it back to the
290:31 - top so we see Zero is not at the top
290:35 - then I drop the top element of the stack
290:38 - then I do dig one so I get the the
290:41 - element at one position from the top
290:42 - bring it back to the top then I push the
290:45 - value two and I multiply the top two
290:48 - elements so I consume two and 10
290:50 - multiply them to get 20 and then push 20
290:53 - at the top of the stack then I add those
290:55 - two 20 + 1 I put 21 back on the stack
291:00 - then I generate this empty list of
291:02 - operations that we have here here it
291:04 - just chose it as a pair of square
291:06 - brackets but here we can see that it's
291:09 - indeed a list of operations
291:11 - and then finally I can pair them to get
291:13 - the end result so a pair containing a
291:15 - list of operations to execute after the
291:17 - smart contract and the new value to put
291:20 - in the storage of the smart contract and
291:23 - that's it so there's a couple things you
291:25 - need to be careful about when you write
291:28 - your smart contract um the first one is
291:30 - when you debug your smart contract if at
291:33 - one point you realize you want to make a
291:35 - change to your contract for example here
291:37 - you actually wanted to push three
291:39 - instead of two
291:41 - you should be careful because when you
291:43 - get to this instruction we will see that
291:45 - it actually pushed two on the stack
291:47 - because it's still running the previous
291:50 - version of the code the changes you make
291:52 - while you debug don't affect your
291:55 - current debugging session so that means
291:58 - anytime you want to make a change to
292:00 - your contract you need to make sure you
292:02 - stop debugging and then start debugging
292:05 - again otherwise it can be really
292:07 - confusing because what you see doesn't
292:09 - correspond to what code you have there
292:11 - and you can spend a lot of time trying
292:13 - to understand what's going on why why do
292:15 - I have this result it doesn't really
292:16 - correspond to what I wanted to do Etc
292:18 - and that's because you're not actually
292:19 - running the code you see so always make
292:21 - sure you stop it run it again and of
292:24 - course then when you execute it you can
292:26 - see that we indeed push three of course
292:29 - here we really wanted to push two
292:31 - another situation you can run into is
292:34 - when you for example add an extra
292:36 - instruction
292:37 - here you can see that everything is in
292:40 - red and it tells us that we have a type
292:43 - check error it doesn't really help us
292:45 - with anything it just says what we have
292:47 - at the end is not right it just not
292:50 - helping us that's because since I added
292:53 - an instruction what I end up at the end
292:55 - on my stack is of the wrong type I get
292:58 - two elements instead of one and that
293:00 - really confuses the type checking and it
293:02 - doesn't help us understand what's going
293:04 - on it just says type check error and if
293:06 - you don't remember that you just added
293:08 - this instruction it can be pretty hard
293:10 - to figure out what is wrong so there's a
293:13 - trick that you can use to do that which
293:15 - is to add a fail instruction at the end
293:17 - and this way the type checking always
293:20 - works because a contract that fails
293:23 - doesn't have to return anything in the
293:24 - stack it just fails and it's always of
293:26 - the right type this way you can check
293:29 - every instruction and see okay what do I
293:32 - have in my stack is that what I wanted
293:35 - Etc and then when you get here you can
293:37 - see oh actually have a one too many
293:38 - elements this doesn't correspond to what
293:40 - I have Etc so you can fix the bug and
293:43 - then once you're good you can remove
293:45 - this extra fail instruction so that's a
293:47 - good trick when you're confused and
293:49 - everything is red and you don't know
293:51 - what to do you'll notice that we put
293:53 - annotations here for each element that
293:55 - we have in the parameter and that's
293:57 - something you can do to help you better
293:59 - understand what's in the stack so here
294:01 - we can see that we have this information
294:03 - that this integer is actually a so
294:06 - basically this annotation was propagated
294:08 - all the way to this position but as soon
294:11 - as you do the computations what you end
294:13 - up doesn't have any annotation it
294:15 - doesn't tell you that this is actually
294:17 - 2B it just tells you it's it's an N so
294:20 - this can be helpful but very quickly you
294:22 - don't really benefit from it anymore so
294:24 - it's much better to use comments that
294:27 - really describe what we have on the
294:29 - stock one thing you may wonder is why do
294:32 - I need to learn meason I write just fine
294:35 - in my higher level language um and I can
294:37 - write smart contracts without knowing
294:39 - meason so why do I need to learn mikin
294:42 - we teach you a little bit of mikin
294:44 - because it can be quite useful in a few
294:47 - situations so for once deployed
294:49 - contracts that you can check with your
294:51 - block explorers are in meason so if you
294:54 - want to read a contract that has already
294:56 - been deployed and that you want to use
294:58 - you have to read the mikon code that's
295:01 - the only thing that's always available
295:03 - sometimes authors U make the original
295:06 - smart contract in the high level
295:08 - language available to you but not always
295:10 - so it's good to be able to read the
295:12 - contract another thing is that while you
295:14 - write your smart contract sometimes you
295:16 - want to make sure you understand what's
295:18 - really going on behind the scenes is it
295:21 - generating a lot of computation or is it
295:23 - something very simple even in a
295:25 - low-level language so it can be a good
295:27 - idea to once in a while look at the
295:29 - mikon code generated by your highle
295:32 - language compiler and understand what
295:34 - really happens behind the scenes another
295:37 - time where you will need to understand
295:39 - some mikon is that sometimes you can
295:41 - have compiler errors that are actually
295:43 - expressed in meason it's often type
295:46 - errors so it's important to have some
295:48 - basic idea of uh what mikon is to help
295:51 - you understand these
295:53 - errors more generally it's good to have
295:55 - a deep understanding of what's going on
295:57 - behind the scenes you don't need to be
296:00 - an expert in mikon but it's good to know
296:02 - the basics I advise you to take the
296:05 - habit of reading the mikelson version of
296:07 - contracts you write little by little you
296:09 - will get used to at least reading mikon
296:12 - code and understanding it's not too hard
296:14 - to understand again the hardest part is
296:16 - to keep track on what's in the stack
296:18 - after each
296:19 - instruction as an exercise you will
296:22 - write your own melon smart contract that
296:25 - does some arithmetics so write a
296:27 - contract that takes a pair of integers A
296:29 - and B as a parameter just like we did in
296:32 - our example but then this time computes
296:35 - a * 2 b + 3 a and again puts the result
296:39 - back in the storage pause the video and
296:42 - give it a
296:45 - try let's take a look at the solution so
296:48 - here we have our contract that takes a
296:51 - and b as a parameter with the storage of
296:54 - type int so we start by
296:58 - unpairing our storage and parameter and
297:01 - pairing our two values A and B then we
297:04 - get rid of the storage because we won't
297:06 - need it then this time we will need to
297:09 - duplicate a because in our final
297:11 - expression a * 2 b + 3 a we need a twice
297:15 - so we duplicate a so that we can make
297:18 - use of it twice that's something we
297:21 - often need to do in a stack based
297:23 - language so now we want to compute two B
297:26 - so we dig twos to obtain B at the top of
297:29 - the stack then we push the value two and
297:33 - we multiply them to obtain 2 B now we
297:36 - want to compute 3 a so we dig one to get
297:39 - a a back to the top we push three we
297:43 - multiply them to get 3 a at the top of
297:46 - the stack then we want to compute this
297:49 - expression 2 b + 3 a so we add those two
297:53 - values to get 2 b + 3 a at the top of
297:56 - the stack then all we have left to
297:58 - compute the final expression is to
298:00 - multiply a with this value 2 + 3 a so we
298:05 - have our result here but now we need to
298:07 - add an empty list of operations on the
298:10 - stack so we call nil operation at this
298:14 - empty list of operation we see here that
298:18 - we have indeed a list of operations in
298:20 - the stack and then the new valuable
298:22 - storage we pair them and we get the
298:26 - results in the stack we can give it a
298:29 - try we can use one for a 10 for B zero
298:34 - for the storage and so we compute let's
298:37 - compute a few things
298:40 - so let's see here after doing the
298:43 - addition we still have a = 1 at the
298:46 - bottom then we have 2 B so that's 20
298:50 - plus 3 a that's three so we get 23 at
298:53 - the top of the stack then we multiply
298:55 - that by a so by one and we get
298:59 - 23 and we compute we have the empty list
299:02 - and 23 if I run it again but this time
299:07 - with two and 10
299:10 - then I can execute
299:12 - it so I should get 3 * 2 so that's 6 +
299:17 - 20 * 2 so that's 26 * 2 52 which is
299:22 - correct all
299:24 - good in this module you will learn how
299:27 - to install Smart py in your own
299:30 - environment which is what we recommend
299:32 - when you start creating contracts for
299:35 - your real projects the installation
299:37 - procedure of smartp is very
299:39 - straightforward forward all you need is
299:42 - Python 3 and pip which is the tool to
299:44 - install modules for Python 3 there's one
299:47 - exception if you use a Mac and have an
299:50 - Intel processor you will also need to
299:53 - install Docker we'll refer you to the
299:56 - corresponding documentation of these
299:57 - tools to install them if you want to
300:00 - find the latest installation procedure
300:02 - you can go to smart py. I and in the
300:05 - manual in the installation section you
300:08 - will find the commands the version we
300:10 - will use for this demo is a version
300:12 - that's not officially released yet but
300:14 - that you can find here so if you go to
300:17 - the coresponding website you can go in
300:20 - the
300:21 - manual installation and here you find
300:24 - the installation procedure where you
300:26 - have one command that you should run and
300:29 - that's all you need to install Smart Pie
300:31 - as long as you have the prerequisite
300:33 - python pip and maybe Docker for our demo
300:37 - we will do this in the gpen environment
300:40 - prepared and you can try it yourself in
300:42 - the same environment if you don't want
300:44 - to install it on your own computer so
300:47 - we'll create a new workspace with this
300:49 - environment where we don't have anything
300:51 - specific to smartp installed yet so you
300:54 - may need to create a gitp pod. iio
300:56 - account using your gitlab or GitHub
300:58 - authentication if you don't already have
301:00 - a gitpod account then it asks you to
301:02 - create a new workspace which we will do
301:05 - it may take a couple minutes make sure
301:07 - you have the tab open in your your
301:10 - browser with the focus so that it
301:12 - doesn't take too
301:18 - long so once your git pod environment is
301:21 - running I'll Zoom a little
301:24 - bit but all you do is go copy the common
301:28 - line provided in the smart P manual so
301:31 - we copy this
301:34 - line you paste it here it may ask you if
301:37 - you authorize pasting content on git pod
301:39 - so of course you need to authorize and
301:41 - then you simply execute this command it
301:45 - downloads everything needed and
301:47 - everything is ready now you create a
301:52 - folder so will test or endless wall
301:55 - contract so I'll create a endless W
302:02 - folder and I'll open the uh vs code
302:06 - editor where I will put my contract file
302:08 - but you can use any editor you
302:12 - like your contract file should have the
302:16 - py extension and I will paste the count
302:20 - of our contract once you've done that
302:22 - all you need to do is run python
302:26 - contract.
302:28 - py I forgot to save contrl
302:31 - s run it again well good and we see here
302:36 - that created is a test folder with a lot
302:39 - of files so we'll go through them to
302:41 - understand what just happened so all you
302:45 - need to do to run a contract and it's
302:47 - scenarios is simply to run Python and
302:50 - then your contract and this will produce
302:53 - a folder for each of the test scenarios
302:55 - you have in your contract and in each
302:58 - folder you will have a number of files
303:00 - you would have the main file which is
303:02 - log.txt that will contain all of the
303:05 - steps of the execution and you will have
303:07 - files for each contract or Reg ation
303:10 - with the content of the contract in mson
303:12 - the content of the initial storage and
303:15 - you will also have files for each call
303:17 - to an entry point we can see here with
303:21 - the names those are files for the
303:23 - contract for the initial storage the
303:25 - type of the storage and parameter Etc
303:28 - and then for each step we have the files
303:31 - for the parameters of the entry point
303:33 - calls so if we look more precisely at
303:36 - the content of the log.txt file it will
303:39 - contain sections for every step of the
303:42 - execution of your scenario you will have
303:45 - the contract origination with the
303:46 - initial storage of your contract and you
303:50 - will have an entry for each call to an
303:53 - entry point with the parameter and the
303:55 - resulting new value of the storage you
303:58 - will also find the comments produced by
304:01 - calls to the scenario. H1 Etc and you
304:05 - will also see lines for calls to
304:07 - scenario. verify where it will show what
304:10 - conditioning checked and what the result
304:12 - is the output of calls to sp. trace that
304:15 - you use for debugging are not visible in
304:18 - log.txt but they are directly displayed
304:20 - in your terminal as the error output so
304:24 - here we can see the content of some sp.
304:27 - Trace that we added here so we can see
304:30 - that it's displayed directly in the
304:32 - terminal and then if we open the log.txt
304:35 - file we can see the origination of the
304:38 - contract so our contract
304:40 - simply contains a big map so here we can
304:43 - see the initial content of the big map
304:45 - it's empty then it will list all the
304:47 - different files with the storage the
304:49 - types and the contract so for the
304:51 - storage we can see the content either
304:53 - expressed in smart Pi or in mikon or the
304:58 - Michelin version so the Jon version of
305:01 - mikon here we can see the types of the
305:05 - storage the parameter private and Views
305:09 - directly smart p and you can see the
305:11 - contract itself either in the Michelin
305:14 - Json
305:15 - representation or directly in melon as a
305:19 - TZ file so you can see what the melon
305:23 - code that you generate looks like and
305:24 - you can see that after every instruction
305:27 - it shows the content of the stack after
305:30 - the execution of this instruction with
305:32 - the top element of the stack on the left
305:35 - so for example here after impairing the
305:37 - content we have the parameter in the
305:39 - storage and after running now we have
305:41 - now at the top of the stack for each
305:44 - section you can see the corresponding
305:46 - smart pie code so you can follow what
305:50 - part of the code corresponds to what
305:51 - part of your smart pie code that can be
305:55 - quite useful if you want to understand
305:57 - what your code really generates on
305:59 - chain so to recap for each contractor
306:02 - origination you will have the files with
306:04 - the initial storage in different formats
306:07 - the file containing the different types
306:09 - in the smart P format and files with a
306:12 - compile me contract both in the TZ and
306:15 - Json format then for each smart contract
306:18 - that you call some files will be
306:20 - produced they will contain the content
306:22 - of the parameter both in the TZ Jon and
306:26 - smart P formats so we can take a look
306:29 - here for a call we can see that the call
306:32 - had one parameter that was a string with
306:35 - Bob's message here we simply have the
306:38 - string and same here in the meason
306:42 - format so we can see here in the log. XT
306:46 - we originate the contract we see the
306:49 - corresponding initial value of the
306:51 - storage here we can see the output of a
306:54 - call to scenario. H1 here we can see
306:57 - that we call WR message with the
307:00 - parameter and we can see here the new
307:03 - value of the storage so the content of
307:04 - the big map with the key here which is
307:07 - Bob's address and then the corresponding
307:10 - entry then we make another call so we
307:13 - can see that the content of the storage
307:15 - change for the key that is Bob's address
307:19 - and then finally when we make a call to
307:22 - send a message as Alice we see that we
307:24 - have another
307:25 - key in the big map with Alice message
307:29 - and finally you can see here when we
307:32 - verify so if we check
307:35 - our contract here we have a verification
307:40 - that the Tim stamp for Bob's message is
307:43 - zero because we didn't specify any other
307:45 - Tim stamp in log. TT file we can see
307:48 - this verification with the corresponding
307:51 - condition and the result so this is
307:54 - everything you need there to check that
307:56 - everything goes well and to look in
307:59 - detail what happened during the
308:01 - execution of your scenario and remember
308:03 - that for each scenario you will have a
308:05 - similar folder so you can organize your
308:08 - test very nicely okay now it's your turn
308:10 - to give it a try and run smart P locally
308:13 - so what you should do is simply
308:15 - reproduce the demo but you with your own
308:17 - smart contract so you install Smart py
308:19 - in your own environment you execute your
308:22 - own smart contract uh you can take the
308:24 - one from the previous excise make sure
308:26 - you include contract calls verifications
308:29 - comments and calls to trace to see what
308:32 - happens in each case and if you have
308:34 - trouble for some reason to install Smart
308:36 - p in your own environment on your own
308:38 - machine you can test all this using or
308:41 - gitpod environment at this address so
308:45 - pause the video and give it a try in
308:47 - this module we will talk about DS
308:50 - decentralized applications and what it
308:52 - means to develop your own DS adap is an
308:57 - application that is built on top of one
308:59 - or more smart contracts it stands for
309:03 - decentralized application but it is a
309:06 - regular application with or without a
309:09 - user interface that may interact with
309:12 - smart contracts but also a wallet one or
309:15 - more nodes indexers decentralized file
309:19 - systems like ipfs and sometimes a
309:22 - regular back end but you have to be
309:24 - careful in spite of their name
309:26 - decentralized applications only the
309:29 - smart contract part of adap is always
309:32 - decentralized the interaction with
309:34 - different tools are made available
309:36 - through libraries and depending on the
309:38 - type of front end or back end you use
309:41 - you may use different libraries on tesos
309:44 - we usually use takito for web based daps
309:48 - we may also use py tesos for python
309:51 - based daps or we can use the unity SDK
309:54 - for tesos for DS that can work on the
309:57 - web desktop and mobile using the same
310:00 - code base and that is particularly
310:02 - useful for games that you develop using
310:04 - the unity SDK and there are more such
310:07 - libraries for other languages and pl
310:09 - platforms there are also tools like
310:12 - Factory or cleum that can help you by
310:15 - analyzing contracts and generating
310:17 - bindings and make it easier to develop
310:20 - and debug your DS the main capabilities
310:23 - of these libraries are the same but they
310:25 - run on different platforms and with
310:28 - different ease of use a key aspect of DS
310:31 - is their interaction with wallets the
310:33 - role of the wallet is to allow DBS to
310:35 - interact with smart contracts while
310:38 - providing security for the end user it
310:40 - keeps the private keys of the end user
310:43 - safe and it gives them the opportunity
310:45 - to check the transactions before those
310:48 - transactions are sent by the DAP to the
310:50 - node so the D interacts with the wallet
310:53 - at different steps first it uses the
310:55 - wallet for the user to authenticate on
310:57 - the DB then it uses the wallet to
311:00 - simulate transactions and check how much
311:02 - the felds will be the fees to pay to the
311:04 - Baker and the amounts to burn for the
311:06 - storage then the wallet is used to sign
311:09 - and emit the transactions send them to
311:11 - the blockchain but it can also be used
311:13 - to sign other types of messages or to
311:16 - verify signatures from other users we
311:19 - use a standard protocol Bon to interact
311:22 - between deps and wallets so that you
311:24 - don't have to write code specific to
311:26 - each wallet in your DBS and connection
311:29 - between the DBS and wallet can be done
311:31 - either through a QR code or through dip
311:34 - link DBS can also communicate with nodes
311:37 - either through the wallet or or directly
311:40 - they do so to obtain information about a
311:42 - given blog for example its level its
311:44 - timestamp the transactions it contains
311:47 - Etc they can read the balance of an
311:50 - account or a smart contract directly
311:53 - from a node or they can read the storage
311:55 - of a smart contract and they can also
311:57 - execute views and obtain other kinds of
312:00 - data these interactions are done through
312:02 - RPC calls directly to the nodes all of
312:05 - the data is available through the nodes
312:08 - but only block by block and it's not
312:10 - very convenient to access the data this
312:13 - way so to make it easier we use what we
312:16 - call indexers the role of indexers is to
312:19 - fetch data from the node blog by block
312:21 - as the blocks arrive and then make it
312:23 - easily available to the deps so you have
312:27 - apis to find accounts contracts and
312:30 - operations based on many different types
312:32 - of criteria and you can also obtain
312:34 - aggregated or sorted data and more
312:37 - generally you can access data in more
312:39 - digestible format in particular for
312:42 - standardized tokens and the access to
312:45 - data is much faster than you if you try
312:47 - to access directly through a node a good
312:50 - way to get an idea of what is available
312:52 - through an indexer is to look at block
312:54 - explorers because behind each block
312:56 - Explorer such as Bal Dev TZ KT or TZ
313:00 - stats there is a corresponding indexer
313:03 - that stores all that data and makes it
313:05 - easily available so typically the work
313:08 - of an indexer is to keep track of new
313:10 - blocks fetch all of the data store that
313:13 - data in a relational database with
313:16 - indexes to allow for good access
313:18 - performance and then reply to simple or
313:21 - complex queries through a rest API there
313:25 - are a number of public indexers that are
313:26 - available for tesos such as TZ KT or TZ
313:30 - stats but you can also install your own
313:32 - local copy of these indexers but keep in
313:35 - mind they use significant resources
313:37 - because they have to index all of the
313:39 - data from the blockchain a more
313:41 - lightweight approach consists in using
313:44 - selective or custom indexers that only
313:47 - inexs the data you really need for utap
313:50 - there are tools like DP dap or dzer that
313:53 - make it easy for you to create your own
313:56 - selective or custom indexer blockchains
313:59 - and in particular layer ones are not
314:01 - good for storing data in large
314:03 - quantities because every single node on
314:05 - the blockchain stores everything so the
314:08 - St storage on the layer one is expensive
314:11 - in practice when possible we only store
314:14 - a hash of the data in the smart contract
314:17 - we only store the data itself in the
314:19 - smart contract if the smart contract
314:21 - needs to directly interact with the data
314:24 - but even though you don't store all of
314:26 - the data in the contract itself it's
314:28 - important to make sure that the data is
314:30 - available in a decentralized manner so
314:32 - decentralized file systems play this
314:35 - role of storing this data and make it
314:38 - available to everyone everyone ipfs is
314:40 - currently the most used such
314:42 - decentralized file system it stands for
314:44 - interplanetary file system it consists
314:48 - of a protocol for organizing and
314:50 - transferring data through a peer-to-peer
314:52 - Network an ipfs also represents a number
314:55 - of implementations of this protocol and
314:57 - a decentralized network based on this
314:59 - protocol on ipfs or any similar tool any
315:03 - file is identified by its
315:06 - hash that has multiple advantages
315:09 - because it guarantees that the content
315:10 - has not been tempered with you can check
315:13 - that it matches the hash and even if at
315:15 - some point the content is lost by your
315:17 - system if some content is not available
315:19 - on ipfs anymore anyone can add it back
315:23 - and it's identified by the sash as long
315:25 - as the content matches is hush then you
315:28 - can add it back and you have to be
315:30 - careful because nodes of ipfs are free
315:32 - to decide what data they store just
315:34 - because you put some data on ipfs at
315:37 - some point doesn't mean it stays there
315:38 - for dri so it doesn't guarantee that
315:41 - availability if you want to make sure
315:43 - some content stays available you can use
315:46 - spinning services that take care of that
315:48 - for a to recap adap is an application
315:52 - that is built on top of one or more
315:55 - smart contracts and you have to see it
315:57 - as a regular application that may or may
315:59 - not have a user interface and that may
316:02 - interact with smart contracts with a
316:04 - wallet with a node with indexers with
316:08 - decentralized file systems like
316:10 - lpfs and maybe with a regular back end
316:14 - so again be very careful in spite of the
316:17 - name only the smart contract part of a
316:19 - DB is always
316:21 - decentralized the front end of a Dap is
316:23 - often hosted on a centralized server and
316:27 - the deps often interact with a
316:29 - centralized indexer they also interact
316:31 - with a specific node or a specific set
316:33 - of nodes and they often have a
316:36 - centralized backend so when that's the
316:39 - case only the smart contract part gets
316:41 - the benefits of
316:43 - decentralization furthermore many smart
316:46 - contracts depend on the third bodyy to
316:48 - make some calls so you have to keep in
316:50 - mind that the technology makes
316:52 - decentralization possible but it doesn't
316:55 - require it so it's possible to write AAP
316:57 - and smart contracts that are not fully
317:00 - decentralized so many of the benefits of
317:03 - blockchains can be lost if you don't
317:05 - apply them correctly you can take the
317:07 - example of what happened with f PX for
317:09 - example and see what could go wrong but
317:12 - you also have to keep in mind that to
317:13 - attract users you need to make it easy
317:16 - for them so the hard part is to benefit
317:19 - from all of the aspect of
317:20 - decentralization while still making it
317:23 - easy for users to use one of the
317:25 - barriers of Entry op ups for your final
317:29 - users is that to call any smart contract
317:32 - they need to pay fees and in order to
317:34 - pay fee that means you have to buy TZ
317:37 - which implies doing a K1 YC know your
317:39 - customer prove your identity Etc even if
317:43 - it's a very small fee so this is a
317:45 - barrier for many users when starting to
317:48 - use your product your D so to make it
317:51 - easier one possibil is for you to pay
317:54 - for your users fees users can set up a
317:57 - wallet but don't go through the kyc or
318:01 - obtain TZ and that means instead of
318:03 - signing and paying the fees for a
318:05 - transaction they can use their wallet to
318:07 - sign a message that will allow a
318:09 - transaction but then they send this
318:12 - message to your server and your server
318:14 - receives this message and calls a
318:16 - contract that will then receive the
318:18 - message and do the corresponding
318:20 - transaction so this way the users give
318:23 - their authorization by using their
318:25 - wallet to sign the message but you're
318:28 - the one paying the fee on your server so
318:30 - that's a method that you can use to make
318:32 - it easier for your users to start using
318:35 - your D and there's a standard on tesos
318:37 - on how to do that called tzip
318:40 - 17 one issue that can come up when you
318:43 - do D and in particular when you use Fess
318:45 - transactions comes from the fact that
318:47 - each transaction has to include a
318:49 - counter to avoid replace but that means
318:52 - from a given address you can only emit
318:55 - one transaction with one value of the
318:57 - counter per block but some services
319:00 - including in the case of Fess
319:01 - transactions require sending many
319:04 - transactions per block so to solve this
319:06 - issue we have a system of batches of
319:08 - transaction actions a batch of
319:10 - transaction can contain one or more
319:12 - transactions from the same account and
319:15 - either all of the transactions in the
319:16 - batch are included and are successful or
319:19 - they all fail and issue is that the
319:21 - bigger your batch is the higher the risk
319:24 - that the batch and all of its
319:26 - transactions will be rejected so to
319:28 - manage your chances you will have to
319:31 - split your transactions into several
319:33 - batches that you emit from multiple
319:35 - addresses for a given block so that's
319:38 - one of the things things that you may
319:39 - need to take into consideration When
319:41 - developing Advanced apps and in
319:43 - particular if you use Fess
319:45 - transactions so that give you an
319:47 - overview of the kind of issues you have
319:49 - to deal with When developing
319:51 - daps in this module you will learn how
319:53 - to make inter contract calls and this
319:56 - will open many interesting
319:59 - possibilities the possibility for a
320:01 - contract to call another contract really
320:04 - expands the potential of smart contracts
320:07 - you can create Market Place contracts
320:09 - that interact with nftd contracts or Dow
320:12 - decentralized autonomous organization
320:14 - contracts that allow people to
320:16 - collectively own and trade assets
320:19 - through the interaction of the Dow
320:21 - contract with other contracts you can
320:23 - also build the centralized Finance
320:25 - contract that build on top of one
320:27 - another with Landing contracts that
320:30 - allow you to invest in yield forming
320:32 - contracts Etc or you could create game
320:35 - contracts that interact with dynamic
320:37 - nfts
320:38 - there's really a lot you can build
320:40 - thanks to the possibility of contracts
320:42 - interacting with each other but all this
320:44 - potential also opens up many potential
320:47 - flaws and risk associated with interc
320:50 - contract calls for example if you're not
320:54 - careful it would be possible to trigger
320:56 - a contract on behalf of a user without
320:59 - them realizing that that contract is
321:02 - called in their name and interc contract
321:04 - calls can in some cases give attackers
321:06 - access to potentially Unlimited funds
321:09 - for their attx so when dealing with
321:11 - interc contract calls it's important to
321:14 - be very careful about what you're doing
321:16 - and we'll show some of examples of that
321:19 - the syntax of inter contract calls is
321:21 - pretty
321:22 - straightforward if you have the address
321:24 - of a contract you can use these two
321:27 - instructions to call an entry point of
321:29 - this contract so first you get a
321:32 - contract object by doing sp. contract
321:35 - and then you have to pass three values
321:39 - you pass the parameter type of the entry
321:42 - point you want to call then the address
321:46 - of the contract that has this entry
321:47 - point and finally the name of the entry
321:51 - point and this returns an option on the
321:54 - contract because there may not be an
321:56 - entry point for the contract this
321:58 - address with this parameter
322:01 - type so since it's an option if you know
322:04 - for sure that you press the right
322:06 - argument you can unwrap the option using
322:09 - unwrap sum and store the result in this
322:11 - contract variable once you have this
322:14 - contract variable you can do the
322:17 - contract call by using sp. transfer
322:21 - because calling contract is also
322:22 - transferring some test to a contract
322:25 - then you pass the value of the parameter
322:27 - for the entry point it should have the
322:29 - type that you provided here you indicate
322:32 - how many Tes you want to send as you
322:35 - call this entry point and you pass the
322:38 - object that you just obtained with the
322:40 - previous instruction and this will
322:43 - create a transaction to call the entry
322:47 - point with this name from the contract
322:49 - at this address and with this value as a
322:52 - parameter setting along this amount of
322:55 - Tes this transaction is cued in the list
322:59 - of transactions that you execute at the
323:01 - end of the execution of your current
323:03 - entry point it is never called
323:05 - immediately to test several contracts
323:08 - that interact each other in your test
323:11 - you start by creating instances of your
323:14 - contract in the usual Way by calling the
323:17 - constructure of each contract then you
323:20 - simply have to pass the address of one
323:22 - of the contracts to the other contract
323:25 - for example in an entry point call or it
323:27 - could also be in one of the Constructor
323:30 - parameters so this make the contract
323:32 - address available for the entry point to
323:35 - run these commands let's take an example
323:39 - with contracts that can interact with
323:41 - other contracts we could create a
323:43 - contract that serves as an intermediate
323:45 - between the user and another contract
323:49 - and this adds a lot of new possibilities
323:51 - on how existing contracts can be used so
323:55 - for example if a contract has an owner
323:58 - you could use an intermediate contract
323:59 - to change it to two owners so if we take
324:02 - the case of an nft we can create an nft
324:06 - joint account contract so that two
324:08 - people can jointly own the same nft so
324:12 - let's see how this would work so we have
324:15 - this nft for sell contract that
324:18 - represents a single nft that can be
324:20 - bought and sold in its storage we have
324:23 - the current owner we have its metadata
324:26 - and we have its current price then we
324:29 - have our two entry points one to buy
324:32 - this nft at the current price and one
324:34 - for the owner to set a new price for the
324:37 - nft
324:38 - and so the idea is that we can create
324:40 - this nft joint account that will become
324:43 - the owner of one or more such
324:47 - nfts and then we will have two owners
324:51 - for this contract that will be jointly
324:54 - the owner of this contract and therefore
324:57 - both control the associated nfts and
325:01 - here since it's a joint account each
325:03 - owner has full power on the
325:05 - contract so either one of them can
325:09 - either buy nfts set the prices Etc so
325:12 - for this contract to be able to buy and
325:14 - sell nfts through this um nft for sell
325:17 - contract we need the following entry
325:19 - points the first one will be to buy an
325:22 - nft and so for that we say which nft we
325:25 - want what's the address of the contract
325:28 - corresponding to the nft we want to buy
325:30 - and this entry point will call the buy
325:33 - entry point of the corresponding n Fe
325:36 - and then the contract will become the
325:38 - new owner for that nft once it owns that
325:42 - nft either of the owner could call set
325:45 - nft price again indicating which nft
325:48 - contract this will be and then passing
325:51 - the new price and this entry point will
325:53 - in turn call the set price entry point
325:56 - of that NFD
325:58 - contract finally once someone buys the
326:02 - nft the funds will be sent back to the
326:06 - owner of the nft for sale
326:08 - so it will be sent to the default entry
326:11 - point of our nft joint account contract
326:13 - so we need to make sure we have a
326:15 - default entry point that accepts
326:18 - TZ otherwise we would never be able to
326:21 - sell those
326:22 - nfts so if we look at our contract in
326:25 - more detail so we have those two owners
326:29 - that are both addresses in our buy nft
326:32 - entry point we first check that the
326:34 - caller is either owner one or owner two
326:37 - then we simply call nft address. bu with
326:41 - the amount that was sent to by nft so
326:44 - sp. amount next he set nft price entry
326:50 - point checks again that the color is
326:53 - either owner one or owner two and then
326:56 - simply calls the set price entry point
326:59 - of the nft contract with the new price
327:04 - finally if the default entry point is
327:07 - called we do nothing we simply accept
327:10 - the test let's take a look at the
327:12 - contract so here in the same file we can
327:16 - have our nft for sale contract and our
327:20 - new nft join account contract so the nft
327:23 - for sale contract is one of the versions
327:25 - we used in the past that has a basic set
327:28 - price entry point that checks if the
327:30 - caller is the owner and then updates the
327:32 - price and then the buy entry point check
327:35 - that the amount sent is the right amount
327:38 - sends it to the owner and then changes
327:40 - the
327:42 - owner so now we have this nft join
327:45 - account contract that simply stores the
327:48 - two owners and in the buy nft entry
327:52 - point we get the address of the nft
327:55 - contract that we want to interact with
327:58 - so keep in mind that this joint account
328:00 - could own many different contracts using
328:02 - many different addresses so every time
328:05 - we want to interact with one of these
328:07 - nft contracts we just pass the address
328:10 - but first we check that the caller is
328:13 - either owner one or owner two and then
328:16 - we execute those two instructions I was
328:18 - showing before so we get the buy entry
328:21 - point of this address since the bu entry
328:25 - point doesn't take any parameter we have
328:27 - to say that the type of the parameter is
328:29 - nothing and nothing can be pressed by
328:32 - the type unit so we use sp. unit as the
328:36 - type when we have no parameter at all
328:39 - and since it's an option we need to
328:41 - unwrap it we store it in this variable
328:44 - then we can call transfer we pass the
328:46 - value of the parameter so when we have
328:48 - no value to pass the value for nothing
328:52 - for the type unit is expressed as a pair
328:55 - of parentheses with nothing in it so
328:57 - that means sending no parameter in a
328:59 - when but we need to put something here
329:01 - so we have to put this pair of
329:03 - parenthesis that represents the unit
329:05 - value which means sending nothing then
329:08 - we pass the amount so since we just buy
329:10 - the nft we just forward whatever amount
329:13 - was sent by the caller so one of the two
329:16 - owners to this entry point and we just
329:18 - pass it along to the buy entry point of
329:21 - our nft contract and then we pass the
329:24 - contract object that we got from the
329:25 - previous line and that's it this simply
329:28 - calls the buy entry point of the
329:30 - contract at this
329:32 - address very similarly for the set nft
329:35 - price entry point we check if if it's
329:38 - the owner one or owner two then we
329:40 - obtain the corresponding contract using
329:43 - the same thing the main difference is
329:45 - that this time the name of the entry
329:46 - point is set price and this time we have
329:50 - a parameter the new price that is of
329:52 - type newest so we indicate this new
329:54 - price here and again we unra the option
329:57 - then we call sp. transfer we pass the
330:00 - value of the parameter so the new price
330:02 - that we got from this
330:04 - parameter this time we don't pay so we
330:06 - send zero Tes to the set price entry
330:10 - point and the contract is what we
330:12 - obtained from the previous
330:14 - instruction when we test this contract
330:17 - here we instantiate the two contracts so
330:20 - one for the nft one for the joint
330:22 - account we add them both to the
330:25 - scenario so that they can be both
330:27 - originated within the scenario then we
330:30 - call the set price entry point to set an
330:34 - initial price for this nft so that we
330:36 - can buy it at that price
330:38 - then with the second contract with our
330:40 - joint account we call by nft and we give
330:43 - the address of the nft contract we say
330:46 - okay Bob who is one of the two owners of
330:50 - that join account is calling the buy nft
330:52 - entry point and sending seven TZ to buy
330:57 - this nft the nft with this address that
330:59 - we just created then we can try to
331:02 - change the price from the nft directly
331:05 - so this won't work only the contract is
331:08 - allowed to change the
331:10 - price and here we see that we try to use
331:15 - this join account again called by Eve so
331:18 - Eve is one of the two owners of the
331:20 - joint account and we try to buy it at 7
331:23 - T but this doesn't work and the reason
331:27 - why this doesn't work is because we
331:31 - didn't add our default entry point yet
331:34 - so if we want this to work and turn this
331:36 - to a true
331:38 - we need to add the default entry point
331:41 - so that when somebody even us buy the
331:44 - nft again then we can receive the money
331:50 - so we can add the default entry
331:57 - point that doesn't do anything but pass
332:01 - and now if we run it then this time it
332:03 - works so we basically bought the nfg
332:06 - from ourselves not very
332:08 - exciting but this can only work if we
332:11 - have the default entry point then we
332:13 - call the set nft price to change the
332:17 - price to 50 TZ so we can see
332:23 - here and the new price has been set
332:26 - to 50 test here if we show the contract
332:31 - we see here the new price and here we
332:34 - verify that the need the new price has
332:36 - been set to 50 St and and that the
332:38 - address is in the address of the
332:40 - contract so not a lot of test but this
332:42 - illustrates the different calls we can
332:44 - make and how we can have a joint account
332:48 - contract that can interact with an nft
332:51 - contract unfortunately this join account
332:54 - contract has a big flaw can you find it
332:58 - and fix it take a good look at the
333:00 - contract and see if you can identify the
333:02 - flaw and find a way to fix it pause the
333:06 - video and give it a try
333:08 - so the issue here is a situation that
333:11 - can be pretty sad once you realize what
333:14 - the flaw is these two users who are the
333:17 - owners of that joint account could
333:20 - jointly buy and sell many nfts for many
333:23 - years accumulate funds by selling nfts
333:26 - selling them later for a higher price
333:28 - and accumulating money on their joint
333:31 - account but there's one small
333:33 - issue the day they decide to retire and
333:38 - get the test out of the contract is the
333:40 - day they realize that they forgot to add
333:42 - a way to get the funds out so it's very
333:46 - important to always remember to add an
333:48 - entry point to claim any profits if the
333:51 - contract is meant to accumulate funds
333:54 - make sure you have this way to get the
333:56 - funds out otherwise all the funds you
333:59 - may accumulate all the time by the
334:00 - service your contract is providing uh
334:04 - will be lost and will be stuck in the
334:06 - contract for forever so the solution of
334:10 - course would simply be to add this claim
334:12 - entry point that either owner one and
334:15 - orer two can call the idea here is that
334:17 - you have two addresses that you can use
334:19 - to the same thing it could be two people
334:21 - that trust each other or the same person
334:24 - that has two different keys and one
334:27 - that's a safe key in case they lose the
334:29 - first one for example and after checking
334:33 - who is calling all the entry point we
334:35 - have to do is send the balance of the
334:37 - contract to the caller so it's very easy
334:40 - to fix the problem is to make sure you
334:43 - don't forget to have this entry point in
334:45 - your smart contract there's been real
334:48 - situations where people accumulated
334:49 - significant money and had no way to get
334:52 - them out but now let's imagine you
334:54 - actually did this and you deployed this
334:57 - contract without the claim entry point
335:00 - so you cannot change the contract itself
335:02 - once it's deployed right it is immutable
335:05 - so the question is can you find a way
335:08 - that you could still get your funds out
335:11 - of this contract I mean imagine that you
335:13 - have millions of TZ stuck in this
335:15 - contract so you really have to try hard
335:18 - and see if there's any way that you can
335:20 - get those funds out pause the video and
335:22 - think about it so again assuming that
335:24 - you have millions of Tes stuck in this
335:26 - contract how can you get them out
335:30 - there's actually one way to change the
335:32 - contract once it's deployed at least in
335:35 - theory can you tell what that way it
335:38 - would be pause the video and take a
335:40 - minute to think about it so this
335:42 - theoretical
335:43 - solution is that on tesos anything is
335:46 - possible thanks to unchain governance
335:49 - all you have to do to get your funds out
335:52 - is to propose a new Amendment to the
335:54 - tesos
335:56 - protocol and you can make any changes
335:58 - you like in amendments so you could
336:00 - propose an amendment that changes your
336:03 - contract so that you can get the test
336:05 - out but the next step would be much
336:08 - harder The Next Step would be to
336:09 - convince the community to vote for your
336:12 - new Amendment and Save You by letting
336:15 - you change your contract so in theory it
336:17 - is possible in practice unfortunately
336:20 - for you this is extremely unlikely to
336:23 - succeed that's because the whole point
336:25 - of a blockchain and of our smart
336:26 - contracts is that you should be able to
336:28 - trust that it won't be changed that it's
336:31 - what is written in the contract is what
336:33 - will happen so it would be really hard
336:36 - to convince the community to go against
336:38 - this principle just so that you can get
336:41 - your Tes out that got stuck there
336:44 - because of your own negligence but
336:46 - really you have millions of STS tuxed in
336:48 - your contract isn't there a way to get
336:50 - them out so you can't change the
336:52 - contract you can't convince the
336:54 - community to let you change the contract
336:56 - and add a claim entry point but you
336:59 - still have access to those existing
337:01 - entry points the buy nft entry point the
337:05 - set nft price entry point and the
337:07 - default entry point and that's all you
337:10 - have to work with calling those entry
337:12 - points is the only way you can interact
337:14 - with your smart contracts so using just
337:17 - this can you figure out a way to get
337:19 - your TZ out of your contract pause the
337:22 - video and think about it for a while
337:24 - imagine that there is millions of stake
337:27 - okay so all we can do with our contract
337:29 - is buy and sell nfts but we could use
337:32 - that to our
337:33 - advantage we could use the TZ in our
337:36 - balance to buy one or more nfts at their
337:40 - market price using our jointed account
337:44 - so those should be nfts that are easy to
337:47 - buy and sell and that have a clearly
337:49 - identifyed market value so that you know
337:52 - that if you buy them at the marketplace
337:54 - you will be able to sell them at a
337:55 - similar price then you change their
337:59 - price to a very low price close to zero
338:03 - and then right after that you buy them
338:05 - with another account let's say a regular
338:07 - account at this very low
338:09 - price and now that you own it and
338:12 - control it you can sell them with your
338:13 - regular account to a buyer at the market
338:16 - price or maybe a bit less than what you
338:18 - paid for and by doing that you got your
338:21 - money out or most of them this sounds
338:25 - good right there's only one small
338:27 - problem if you do this you could
338:29 - actually lose everything can you figure
338:32 - out how pause the video and think about
338:34 - it for a minute so the problem is that
338:36 - if you can do do it someone else can too
338:39 - after you bought the
338:41 - nft with the joint account and changed
338:44 - their price to a very low price so that
338:46 - you can buy it at this very low price
338:49 - with another account someone else could
338:52 - buy it too and could buy it before you
338:54 - do anyone can buy it at this very low
338:57 - price so if anyone or even a bot notices
339:01 - that there is this nft that has a very
339:04 - high value but somehow got a price set
339:08 - to a very low price then there is a good
339:10 - chance that somebody will notice that
339:12 - and immediately buy it then sell it to a
339:15 - buyer at the market price and profit
339:17 - instead of you so there's a risk that
339:20 - you will lose everything and someone
339:21 - else will make the profit thankfully
339:24 - there's a way that we can prevent this
339:26 - the idea here is that between the time
339:28 - that you change the price to a very low
339:30 - price and the time that you buy it with
339:33 - another account you would like to make
339:35 - sure that no one else can do anything
339:37 - and buy it before you do and you can do
339:39 - this using batches of
339:43 - transactions the idea is that on tsos a
339:45 - given user can submit a batch of
339:48 - transactions so it's a sequence of
339:51 - transactions from the same user and that
339:54 - will be executed automically that means
339:56 - right after another without anything
339:58 - being able to happen in between and
340:01 - either nothing happens of the whole
340:04 - sequence of transaction happens with
340:06 - nothing in between so by creating a
340:09 - batch of transaction from the same user
340:12 - so that has to be one of the two people
340:14 - who own the joint account will call the
340:16 - joint account to change the price of the
340:18 - nft then with the same account they will
340:21 - buy that nft at that very low price and
340:24 - now we know for sure that no one can buy
340:26 - it before we do and we manage to get our
340:29 - Millions out of the nft
340:31 - contract we were pretty lucky because
340:33 - this approach worked in this specific
340:35 - case but in many cases they would be no
340:37 - such approach so we get lucky but it may
340:40 - not be the same next time let's look at
340:42 - some other interesting situation that
340:44 - can happen with interc contract
340:47 - calls suppose you are the owner of an
340:50 - nft that has an automatically increasing
340:53 - price and royalties that you worked on
340:56 - before and let's assume that you got
340:58 - smart and bought this nft through a
341:01 - contract that can contemporarily prevent
341:04 - Sal so it has a default entry point with
341:06 - a switch that you can turn on or off to
341:09 - allow prevent sales and you pause the
341:12 - sale so you own the nft at some price
341:15 - the price has increased by 10% since
341:17 - then and then you pause the sales by
341:20 - making sure no one can buy it because
341:22 - the account that owns it will reject the
341:24 - money and prevent the sale now let's say
341:28 - that enough time has passed and for some
341:30 - reason you know that somebody is ready
341:33 - to pay a very high price to acquire this
341:35 - nft somehow it got really famous and
341:38 - someone is really eager to acquire it
341:41 - unfortunately for you the price is
341:44 - already set so if you unlock the sale
341:49 - well that then person is likely to buy
341:52 - it at that price so the question is how
341:55 - could you bypass the increasing price
341:59 - rule so that you can sell this nft that
342:03 - someone really really wants to buy and
342:05 - is ready to pay a high price for it so
342:07 - how can you bypass this increasing price
342:10 - Rule and sell your nft for more and take
342:13 - advantage of the fact that somebody is
342:14 - willing to pay a very high price for it
342:17 - pause the video and think about it for a
342:19 - minute one easy way for you to do that
342:23 - is to increase the price by selling it
342:26 - to yourself and and increasing the price
342:29 - by 10% and you keep doing that until you
342:32 - reach the Target price that you really
342:34 - think you're able to sell it for
342:37 - so every time you sell it to yourself
342:40 - whatever you pay is sent back to you the
342:43 - only issue is that the 5% of royalties
342:45 - fees will go to the author for every
342:47 - sale it's still a good way to increase
342:50 - the price so that you can get the most
342:52 - out of your
342:54 - nft you can use a batch of transaction
342:56 - to make sure that nobody else buys it
342:59 - between the time that you unlock the
343:01 - sale and the time that you buy it now
343:04 - knowing that this is possible and you're
343:06 - the auor author of this automatically
343:09 - increasing price contract you would like
343:12 - to make sure people don't do that and
343:13 - cheat and go around your rule of the
343:16 - price automatically increasing by
343:18 - exactly 10% so if you're the author of
343:21 - the smart contract how can you change
343:24 - the smart contract before you deploy it
343:27 - and prevent users from bypassing this
343:30 - rule pause the video and think about it
343:33 - one idea that wouldn't really work would
343:36 - be to add a rule in your buy entry point
343:39 - to make sure that the current owner of
343:41 - an nft cannot buy the nft from
343:45 - themselves so basically in the buy
343:47 - contract you could check that the caller
343:50 - sp. sender is not the owner otherwise
343:53 - you reject the sale and this wouldn't
343:56 - work because it's very easy for the
343:58 - owner to use a second address to buy the
344:01 - nft so they could go back and forth
344:03 - between two addresses increase the price
344:05 - until that value and since there's no
344:07 - way to know if two addresses are the
344:09 - same person there's really no way to
344:11 - fully enforce this increasing price Rule
344:14 - and preventing the same person from
344:16 - buying a contract again and again to
344:18 - increase the price and you really have
344:20 - to keep in mind when you see nfts that
344:23 - seem to be bought and sold at very high
344:26 - price this may make it look like those
344:29 - nft are really worth a lot but it could
344:33 - be that it's actually the same person
344:35 - buying it and selling it it's just money
344:38 - changing from one address to another but
344:40 - owned by the same person so it doesn't
344:42 - cost anything to sell and buy an N at a
344:45 - very high price if you're selling and
344:47 - buying it from yourself so that's a good
344:50 - way to inflate the apparent price of an
344:53 - nftd so you should be very careful about
344:55 - that so now let's think about a more
344:58 - interesting question what if you want to
345:00 - sell it for
345:01 - Less how could you bypass the increasing
345:04 - price rule so that you can sell your nft
345:07 - for Less let's say it went to a
345:09 - ridiculous price nobody wants to buy it
345:11 - anymore you really want to get rid of it
345:13 - and sell it for less than its automated
345:16 - price and the value of the price in the
345:19 - storage of your contract is really
345:22 - computed by the ENT Point bu and there's
345:24 - no way to change it in any other way all
345:26 - it can do it be increased by 10% when
345:29 - you buy the
345:30 - nft so how could you bypass this buy
345:34 - entry point and sell the nft at a lower
345:37 - price pause the video and think about it
345:41 - one solution could be to not sell the
345:44 - nft itself but sell the address that
345:48 - owns the nft so for example you could
345:50 - sell the private key of the account that
345:53 - owns the nft to someone else and then
345:56 - they would be in control of that nft
345:59 - this is a very dangerous idea especially
346:01 - for the person buying your private key
346:04 - the reason is that there is really no
346:06 - trustless way to automatically
346:09 - verify that a private key has been
346:12 - transferred so we have this issue of who
346:16 - goes first do I send you the private key
346:18 - first or do you send me the Tes first
346:20 - who pay for it so you cannot use the
346:23 - blockchain to do this kind of things
346:25 - safely but most of all there's no way to
346:28 - prevent the original owner of the
346:30 - private key to sell their private key
346:33 - multiple times when you sell a private
346:35 - key then two people I'll have this
346:37 - private key and basically it's like a
346:39 - joint account that both people control
346:41 - so it's not safe at all to buy someone's
346:44 - private key it just doesn't work but
346:47 - this could give you an idea for another
346:49 - approach that relies on inter contract
346:52 - calls can you figure out how pause the
346:56 - video and think about it so the idea is
346:59 - that although you cannot sell the
347:01 - address of a regular account so the
347:03 - private key of the regular account you
347:05 - can sell a smart contract and a contract
347:09 - can own an nft so instead of buying the
347:12 - nft with a regular account and then
347:14 - trying to sell that account you can
347:16 - simply buy it with a new smart contract
347:19 - and then sell that smart contract so we
347:22 - can custom build a smart contract so
347:24 - that it can purchase or sell nfts and
347:28 - also be purchased and sold itself and
347:31 - the rules for selling and purchasing
347:34 - this contract that will own the nft are
347:37 - completely independent of the rules that
347:39 - set the price of the nft itself so in a
347:42 - way we are wrapping the nft into another
347:45 - new contract that we can buy and sell
347:49 - and since this contract owns the nft
347:52 - it's really like selling the nft itself
347:55 - except that it's wrapped into this other
347:57 - contract so we can call this contract
348:00 - nft wrapper and the idea is that whoever
348:03 - owns the nft rapper contract that owns
348:06 - or nft effectively owns the nft through
348:09 - this contract but owning our nft through
348:11 - this nft raer contract will really allow
348:14 - us to go go around any restrictions not
348:17 - only on the price but also on the
348:20 - royalties when you sell that new rapper
348:22 - contract you don't have to pay royalties
348:25 - to the original author because you're
348:27 - not even using the buy entry point of
348:29 - the nft you simply using the buy entry
348:32 - point of the
348:33 - wrapper to change the owner of the
348:35 - wrapper let's look at how this contract
348:37 - would work in the storage we would have
348:41 - three
348:42 - values one we need to be able to say if
348:47 - we allow or disallow sales of the nft it
348:51 - owns so those will simply be a Boolean
348:53 - that we set to True when we allow sales
348:55 - on nft and false
348:58 - otherwise then we need to store the
349:00 - price of the wer and the current owner
349:04 - of the wrapper now we have a number of
349:06 - entry points so we can use this rer to
349:08 - buy nfts and this will simply call the
349:11 - buy entry point of the nft contract with
349:13 - that address so this is just about okay
349:16 - let's have this wrapper buy an
349:18 - nft then we can set the price for our
349:22 - wrapper so when we call it we check that
349:24 - the caller is the actual owner of the
349:26 - wrapper and then we replace price with a
349:29 - new price in the
349:30 - storage we can have this buy entry point
349:33 - for anyone to buy or wrapper we check
349:36 - that the amount it transferred is equal
349:38 - to the price of a rapper we send that
349:42 - price to the current owner and then we
349:44 - replace the owner with a caller so we
349:47 - simply sell this rapper like we sold an
349:51 - nft before now we have this entry point
349:53 - to set the value of this allow sales
349:57 - Boolean all it does is check that the
349:59 - caller is the owner of the rapper and
350:02 - then replace allw sales with a new value
350:04 - and the point of that is that we find
350:06 - have this default entry point that can
350:09 - control whether the owned nfts so the
350:13 - nft that this rapper owns can be sold or
350:16 - not and if allow sales is true then the
350:20 - default entry point will accept any test
350:23 - that is sent to them and not doing
350:25 - anything but if we set aw sales to fals
350:28 - then the default entry point will fail
350:31 - whenever someone tries to buy one of the
350:33 - nfts its owned because that's part of
350:35 - that buy entry point it's sending says
350:37 - to its owner so to the rapper and if the
350:40 - default entry point says Nope sales are
350:42 - not allowed then it will fail and the
350:45 - nft cannot be sold so we can control
350:48 - whether the nft we own can be sold or
350:50 - not we can buy nfts and then we have the
350:53 - entry points for people to buy and sell
350:56 - the rapper itself so your exercise is to
350:59 - implement this nft wrapper so you will
351:03 - have two contracts one is the nft for
351:06 - sale cont contract you have used
351:07 - previously and the second contract will
351:10 - be this nft wrapper contract with this
351:13 - structure so pause the video and give it
351:16 - a try so let's look at the solution here
351:19 - we have a old NFD for sale contract that
351:23 - has an owner metadata and a price or
351:26 - basic nft we have the set price entry
351:30 - point that checks that it's the owner
351:33 - that is calling and then updates the
351:35 - price and finally the buy entry point
351:38 - where we check that whoever is trying to
351:40 - buy sends the right price then we send
351:43 - that amount to the current owner and we
351:45 - change the
351:47 - owner now let's look at the wrapper
351:51 - contract so we have this allo sales
351:54 - Boolean that we initialize when calling
351:56 - the
351:57 - Constructor we have a price and we have
352:00 - the owner of this repper
352:04 - contract we can call the buy and nft
352:07 - entry point to have this rapper buy one
352:10 - or more nfts so we give it the address
352:13 - of the contract that we want to buy we
352:16 - check that the caller is indeed the
352:19 - owner of the rapper contract then we fet
352:22 - a contract for the buy entry point
352:25 - associated with that address again
352:28 - there's no parameter so we put sp. unit
352:31 - as a type and then we call the entry
352:34 - point with no parameter so two
352:37 - parentheses for the unit value and we
352:40 - send the amount that we got so that we
352:43 - can purchase the corresponding
352:47 - nft now we can have the entry points to
352:50 - buy and sell the wrapper itself so the
352:53 - owner can call set price to set a price
352:58 - for the rapper we check that it is
353:01 - indeed the owner that called this and
353:03 - then we update the price for the NF
353:07 - wrapper then we have the buy entry point
353:10 - so we check that whatever amount was
353:13 - sent is the price of the wrapper we send
353:17 - that price back to the owner of the
353:19 - wrapper and then we change the
353:22 - owner very similar to what we do in the
353:26 - nft itself it's just the two entry
353:29 - points we need to buy and cell or
353:31 - contract then we have the set allow cell
353:34 - entry point that simply let the owner of
353:38 - the rapper contract change the value of
353:40 - allo sales and finally we have this
353:43 - default entry point that will fail if
353:46 - our sales is
353:48 - false we don't really need
353:50 - to write that
353:52 - here but if all sales is false then it
353:56 - will fail and then prevent anyone from
353:59 - buying any of the nfts that this
354:01 - contract
354:03 - owns so here we have a test so we create
354:07 - instances of the two contracts initially
354:09 - we said that the sales are
354:12 - allowed we add both contracts to our
354:16 - scenario we set the initial price of the
354:18 - nft to 7
354:20 - TZ then we have the rapper contract by
354:24 - this uh C1
354:26 - nft and Bob is the owner of that nft
354:30 - rapper contract so Bob can say buy this
354:34 - C1 nft cont contract through my rapper
354:38 - contract and pay 7
354:41 - T now we can verify that indeed the
354:44 - owner of this contract is the second
354:48 - contract the rapper
354:49 - contract Bob canot say I don't want to
354:52 - allow anyone to buy the NT I just bought
354:55 - through my
354:56 - wrapper Bob can then set the price of
354:59 - the wrapper itself to 50 TZ and then
355:03 - even though the current price of the nft
355:06 - itself s is at seven we cannot buy it
355:09 - for seven T because buying it would try
355:13 - to send the seven Tes to the reper
355:15 - contract the reper contract has allow
355:18 - sales at false so its default entry
355:20 - point will reject the TZ sent to it and
355:23 - therefore reject the sale but on the
355:26 - other hand someone like Dan can buy or
355:30 - rapper contract at 50 TZ and then take
355:34 - control not only of the repper contract
355:37 - but also of the nfts that this repper
355:40 - contract owns So with this idea of a
355:44 - repper you can see that although it is
355:46 - possible to have all kinds of rules such
355:49 - as paying royalties to the order or
355:52 - having rules on how the price can
355:54 - involve smart contracts are also very
355:57 - powerful and through inter contract
355:58 - calls we can go around certain Rules by
356:01 - wrapping contracts into other
356:04 - contracts and this IDE IDE of wrapping
356:07 - nfts and tokens in general is also one
356:10 - of the ways that we can transfer nfts
356:13 - across blockchain in this module you
356:16 - will learn how to use lists and
356:19 - enumerate elements of lists using Loops
356:21 - you may be surprised that it comes so
356:24 - late as in general programming Loops is
356:27 - one of the first things you learn but in
356:29 - smart contracts we actually try to avoid
356:31 - using loops and lists and we'll talk
356:34 - about why a list is an ordered
356:38 - collection of values of the same type or
356:41 - we could say sequence of values of the
356:43 - same type if you want to create an empty
356:45 - list just like in Python you put two
356:48 - square brackets and if you want to
356:50 - create a list with already some elements
356:52 - you put the elements between the two
356:55 - square brackets separated by commas to
356:58 - describe the type of a list we write sp.
357:00 - list and between square brackets the
357:03 - type of the elements in the list so
357:06 - contrary to python list for example we
357:08 - cannot access any particular element in
357:11 - the list using an index or insert
357:14 - element in the middle or at the end all
357:16 - we can do is add an element at the
357:19 - beginning and for that we can use sp.
357:21 - conson the new element we want to add at
357:24 - the beginning and then a list and this
357:27 - returns a new list that contains all the
357:29 - elements that we already had plus the
357:32 - new element at the beginning of the list
357:34 - and finally you can obtain the length of
357:36 - a list using the Len function the main
357:39 - thing we typically do in a smart
357:41 - contract with lists is Loop over the
357:43 - elements of this list do something with
357:45 - each element so for example if we want
357:48 - to add up all the values in our list of
357:51 - numbers we can initialize a variable
357:53 - total to zero and then we write a loop
357:56 - similarly to how we would write it in
357:58 - Python so four the name we want to give
358:01 - to the variable that will contain each
358:03 - element during each iteration of the
358:05 - loop in and then the list so for the
358:08 - variable in and the list column and then
358:12 - indented the operations we want to do
358:15 - using this variable to access the
358:18 - current value so here we Loop through
358:20 - all the elements and then we add each
358:22 - one to the total to compute the sum if
358:25 - you want to repeat something three times
358:28 - or have a variable that goes from 3 to
358:32 - six for example you can create a list
358:35 - using the range function and if you give
358:38 - it one parameter it will simply create a
358:41 - list with elements that go from zero to
358:44 - that value minus one so with range of
358:46 - three you get zero one and two if you
358:49 - give two values you get all the values
358:51 - between this element and then this
358:54 - element minus one so range of 3 to 7
358:57 - gives 3 4 5 6 and you can add a step to
359:01 - say that you jump 2 by two so this would
359:03 - be three then five and then It Stop So
359:07 - this way you can create a loop with a
359:09 - variable that takes every value between
359:12 - two values and potentially with a step
359:15 - let's work on an example we want to
359:18 - change our nft joint account contract so
359:21 - that we can purchase multiple nfts at
359:24 - once this can be a good idea because
359:28 - instead of having to call one
359:30 - transaction every time we want to
359:31 - purchase one nft if we have many nfts to
359:34 - purchase it can reduce gas fees to
359:37 - purchase multiple nfts in a single
359:40 - transaction because each transaction
359:42 - involves signature verification Etc so
359:44 - it involves extra gas costs and the
359:47 - calization and serialization of the
359:49 - storage of the contract you Call Etc so
359:51 - if you can do several in one call then
359:54 - you can save some gas fees and therefore
359:56 - some money so let's take a look at the
359:59 - code here we have our usual nft for sale
360:03 - contract where we store one nft with an
360:05 - owner the metadata and the price and we
360:08 - have a set price and a buy entry
360:11 - point but in our nft join
360:14 - account here instead of having code to
360:17 - buy a single nft we pass a list of nfts
360:21 - to buy and then with this list we can do
360:24 - a loop to Loop through every nft in this
360:26 - list so nft will contain the current
360:29 - element in the list and then we call as
360:34 - we did before the Buy entry point of our
360:37 - nft contract by passing the amount
360:40 - stored in nft so here the idea is that
360:43 - we pass a list of Records where each
360:46 - record contains an address so the
360:49 - address of the nft contract that
360:51 - contains it and the price the amount
360:54 - that we are willing to pay for when you
360:56 - call byy nfts you have to send the total
360:59 - amount that you will spend buying all
361:01 - these nfts and then in the list you
361:03 - indicate the address of each nft you
361:05 - want to buy and then how much you're
361:07 - willing to pay for it and that's it in
361:10 - the test we call here joint account buy
361:12 - nfts and we passed a list of records
361:16 - with here two records one with the first
361:19 - nft we minted here and then amount of
361:22 - seven T and then another one with the
361:25 - second nft with the amount of five T
361:28 - which are the current prices of those
361:30 - nfts after we initialize them at five T
361:33 - and then change the price of the second
361:35 - one to 7 T so let's give it a try we can
361:39 - see that we originate the two
361:43 - nfts then we originate the joint
361:48 - account we set the price to seven t for
361:52 - one of the
361:53 - nfts and then we called buy nfts and
361:57 - here you can see that the argument is a
362:00 - list where each element is a record with
362:03 - the address and the amount so we buy the
362:06 - nft at this address for seven T and the
362:09 - nft at this address for five T and we
362:12 - can see that there were two calls to the
362:14 - buy entry point so one to buy the first
362:17 - nft at 7 T and then we can see that the
362:20 - transfer of the 7 t to the original
362:22 - owner has been done and here the second
362:26 - purchase now it's your turn to practice
362:29 - on an exercise so the goal here will be
362:32 - to change this nft joint account
362:35 - contract so that this time both owners
362:38 - have to agree before they buy nfts in a
362:42 - way this becomes a multi where multiple
362:44 - people have to sign on an operation to
362:47 - happen but this one will be a very
362:48 - specialized one that can only be used to
362:51 - buy nfts and your goal will be to change
362:54 - the buy nfts entry point so that the
362:58 - process works as follows so first one of
363:02 - the two owners of the jointed account
363:04 - can propose a list of nfts to buy by
363:08 - calling buy nfts the first time with a
363:11 - list of nfts to buy and the
363:14 - corresponding price and so during the
363:16 - first call we don't purchase anything we
363:19 - simply store that list for the nfts to
363:22 - actually be purchased the other owner of
363:26 - the joint account contract then has to
363:30 - call by nfts again this time with their
363:33 - own list and then what happens is that
363:35 - the nfts that are listed in both lists
363:38 - the one we stored during the first call
363:40 - by the first owner and the one just
363:43 - provided by the new owner we take the
363:46 - nfts that are in both lists and if they
363:50 - are listed with the same number of tests
363:53 - the same amount then the contract buys
363:56 - them and any nft listed by the second
364:00 - owner that had not been
364:02 - bought should be left in the stored list
364:05 - list so that the first owner can then in
364:08 - turn send another list and maybe confirm
364:11 - some of those proposed nfts to buy if
364:14 - the same owner calls buy nfts twice in a
364:18 - row we consider that this overrides any
364:21 - previous list they have sent so at any
364:24 - time we only store the list proposed by
364:26 - the last
364:27 - caller and whenever one of the owner
364:31 - calls byy nfts and the stored list is
364:33 - from the other owner then we check the
364:36 - intersection between the list is sent
364:39 - and the list that is stored check if the
364:42 - prices are the same and when they are we
364:45 - buy the corresponding nfts so pause the
364:47 - video and give it a try let's look at
364:50 - the
364:51 - solution so we don't change the nft for
364:54 - sale
364:55 - contract but we will change the nft
364:58 - joint account and add in the storage two
365:01 - values the list proposed by the last
365:04 - caller in initialized to an empty list
365:08 - and the address of the owner who
365:11 - proposed this list so whoever called byy
365:13 - n FTS
365:14 - last then we Chang the buy nfts entry
365:19 - point we still check that it's only one
365:22 - of the owners calling it if the caller
365:26 - is the same person who called it last so
365:28 - if the owner is the last proposer or if
365:31 - we start with an empty list then we
365:34 - simply store
365:36 - the list that this caller is proposing
365:38 - and that's it if it's the other owner
365:41 - who's calling it then this time we will
365:43 - compute intersection with the currently
365:46 - stored list so there's different ways to
365:48 - do that but we don't have a lot to work
365:51 - with if we simply use lists I mean at
365:55 - the moment pretty much anything you can
365:56 - do with a list is Loop through all the
365:58 - elements so if we simply use that we
366:00 - would have to Loop through all the
366:02 - elements of the new list and for each of
366:05 - them try to search for the same nft in
366:09 - the stored list so we have to look
366:11 - through all the elements in the stored
366:13 - list and see okay if the current element
366:16 - in the stored list is the same address
366:19 - as the current element in the new list
366:23 - with the same amount then we buy this
366:25 - contract otherwise we add it to a new
366:28 - list that we create that will be
366:31 - replacing the old list in the storage of
366:33 - the contract and then we remember that
366:37 - the last color is the
366:40 - sender so this would work but this is a
366:44 - very slow if we have let's say 10 nfts
366:48 - in each list then for each of those 10
366:50 - nfts in the first list we would have to
366:52 - Loop through 10 nfts in the new list so
366:55 - we basically have N squared iteration of
366:59 - this element so this can get pretty
367:01 - expensive pretty quickly because of all
367:04 - the computation we have to do to compare
367:07 - the two
367:08 - lists so we can do a lot faster than
367:11 - that but to do that we have to use
367:14 - another data structure that you already
367:16 - have learned about oh here we have a bug
367:20 - you forgot to store the proposer so this
367:22 - should be stored whatever happens so the
367:25 - indentation here was
367:27 - incorrect pause the video and think
367:30 - about it for a
367:31 - minute so to take advantage of a map we
367:34 - will take
367:36 - the proposed list and put all of its
367:39 - element in a map where the key is the
367:41 - address of the
367:43 - nft and the value is the amount so this
367:47 - is assuming that uh the same nft address
367:51 - is not listed twice in our list that's a
367:54 - rule we can set for the users of the
367:57 - contract we just say you're not allowed
367:58 - to try to buy the same nft at two
368:01 - different prices in the same list so
368:04 - assuming that will will have one entry
368:06 - for each nft in this map and then when
368:09 - we Loop through the new list of nfts all
368:13 - we have to do is check if it's in the
368:16 - map using the contains instruction with
368:19 - the address as a key then check if the
368:23 - amount for that nft is the one we have
368:26 - in the new list if yes we buy it if not
368:29 - we add it to our new list of remaining
368:33 - nfts so this makes it a lot faster
368:35 - faster to find intersection between the
368:37 - two lists but it's still not the
368:40 - approach I would recommend cuz although
368:43 - this code is less than 20 lines it's
368:46 - still a bit more complicated than
368:49 - necessary so the idea is that we want to
368:52 - avoid doing any unnecessary computation
368:56 - within a smart contract if it can be
368:58 - done off chain and here there's really
369:01 - no need for the smart contract to handle
369:03 - the negotiation between the two owners
369:06 - to find a way to determine which nfts
369:08 - they both agreed to buy they could have
369:11 - this negotiation completely offchain
369:13 - through a d when it's just two people
369:16 - there's really no need for anything in
369:18 - between them for them to agree on which
369:21 - nfts they want to buy the role of the
369:23 - smart contract here is simply to make
369:26 - sure that they do agree before the
369:29 - purchase actually happens and so the way
369:31 - we do that is that we have a first owner
369:34 - could be either one of the two
369:35 - call byy nfts with a list that they
369:39 - allegedly came up with as a list that
369:42 - they both want to buy and so we store
369:44 - that list and we store the address of
369:47 - the owner who proposed that list and
369:50 - then all we have to do is have the other
369:52 - owner called and approve nfts to say yes
369:56 - I agree with the current list that's
369:58 - fine with me so we check that they're
370:00 - indeed one of the owner they're not the
370:02 - proposer it's not the same person
370:03 - agreeing with themselves
370:05 - and then we Loop through all the nfts in
370:08 - the list and simply buy them so that
370:11 - simplifies our contract by quite a bit
370:14 - and so there less risk of bugs but
370:17 - actually in this specific
370:20 - implementation there's a potential flaw
370:22 - that would make it possible for one of
370:24 - the owners to
370:26 - cheat can you figure out how pause the
370:30 - video and think about it for a
370:33 - minute so the way that one owner here
370:36 - could cheat would be to detect when the
370:40 - other owner is calling the approve nft
370:43 - entry point and right before that moment
370:47 - in the same blog potentially but making
370:49 - sure their transaction is accepted first
370:52 - they would call buy nfts again with a
370:54 - new list so basically they would switch
370:58 - the list of nfts right before the person
371:01 - approves it and after they send the
371:03 - transaction so it's too late for them to
371:05 - notice that the list has changed and
371:07 - they're not approving the list they
371:09 - thought they would buy so we need some
371:11 - way when the user calls approve nfts we
371:16 - need a way to make sure that they are
371:18 - approving the list that is currently
371:20 - stored and not a previous list that they
371:23 - have checked before so how would you do
371:26 - that pause the video and think about it
371:27 - for a
371:29 - minute so there's several ways that we
371:32 - could do it one way would be be to ask
371:36 - the caller to send the whole list again
371:38 - and then we compare the two lists and
371:41 - and compare every element and check if
371:43 - they're all the same but that would be a
371:45 - bit more code we could think about
371:48 - Computing the hash of that list and
371:50 - storing it and then we would have the
371:52 - other users send the hash of the list
371:55 - they approve of and a hash is guaranteed
371:58 - in practice to correspond to the same
372:00 - data it's impossible to create another
372:02 - list at the last moment that would have
372:04 - the same hash so this would be safe
372:06 - enough but Computing a hash is a little
372:08 - bit expensive so it's maybe not the
372:11 - cheapest way to do it all we need to do
372:13 - is to have a unique value associated
372:16 - with that list and it doesn't have to be
372:18 - the hash it could be a counter so we
372:21 - could have some counter that uh we
372:24 - increment every time someone makes a new
372:26 - proposal and then when we approve you
372:28 - send the value of that counter so that
372:30 - would be one way to do it so we could do
372:34 - here
372:38 - set to
372:39 - one and then here we increment
372:47 - it and here we check we pass
372:56 - counter and we
372:59 - check the approved
373:03 - counter is is equal to the stored
373:09 - counter so this way we know that by nfts
373:13 - hasn't been called at the last
373:16 - minute before we call approved nfts and
373:18 - if it has been called then the approved
373:20 - counter wouldn't match the current
373:22 - counter so that's a good way to protect
373:25 - against the other user trying to switch
373:28 - the list at the very last
373:30 - moment so making the codes simple is a
373:33 - good way to avoid bugs but it doesn't
373:36 - guarantee that there's no Buon you
373:37 - should always think about ways that
373:40 - someone could cheat it's just easier to
373:43 - think about it if the code is
373:45 - simpler so as I said in introduction we
373:48 - actually try to avoid using lists and
373:51 - Loops in smart contracts when we can
373:55 - that's because using lists in a contract
373:57 - can be dangerous can you figure out why
374:00 - pause the video and think about it for a
374:02 - minute so there's two reasons why lists
374:04 - can be dangerous
374:05 - as we discussed before serializing and
374:09 - deserializing the storage cost gas and
374:12 - so if you have a list in your
374:14 - contract this can increase the cost of
374:17 - calling your contract in some cases it
374:19 - could increase it so much that your
374:22 - contract could get stuck it wouldn't be
374:23 - possible anymore to distalize and resize
374:27 - the current content of the list so you
374:29 - should be very careful about having a
374:31 - list in your storage that people can
374:33 - fill arbitrarily up to the point where
374:36 - it's not possible to dis realize it
374:38 - anymore the second related reason why
374:41 - list can be dangerous is that simply
374:44 - looping through their elements cause gas
374:47 - and as the number of iteration increases
374:50 - the cost increase and similarly your
374:53 - contract can get stuck just because you
374:55 - have to Loop through a very long list
374:58 - and perform some computation on every
375:00 - item so it's important to remember only
375:03 - to use lists if you know that their size
375:05 - is bounded if it's simply a list that
375:08 - you pass as a parameter it's up to the
375:10 - caller to decide the length of the list
375:12 - that passes a parameter there's not much
375:14 - risk of course you're going to pay
375:16 - more if your list is longer but it's
375:19 - really up to you when you do the call to
375:22 - reduce the number of elements of your
375:24 - list if you want to pay less or if you
375:25 - want to make sure that the gas cost
375:27 - doesn't exceed the limit of how much you
375:29 - can spend in a single transaction but if
375:31 - it's a list that you store in your
375:33 - storage then that's when it becomes
375:35 - dangerous and you should be really
375:36 - careful and make sure that the length of
375:38 - the list cannot increase indefinitely so
375:41 - now the question is if we shouldn't use
375:43 - list and we can't use list in the
375:45 - storage with a length that could
375:47 - increase indefinitely what would be the
375:50 - alternative if you feel that you need a
375:52 - list that type of data structure so an
375:55 - ordered sequence of elements of the same
375:58 - type what could you use instead of a
376:00 - list pause the video and think about it
376:02 - for a minute the alternative when you
376:04 - want to store for a lot of data with no
376:07 - limits on how much data you can have is
376:09 - always the big map because that's the
376:11 - only data structure that is not limited
376:13 - by the gas costs and if you pick the
376:15 - right key you can use a big map to
376:18 - emulate all kinds of data structures so
376:21 - for a list the idea is to use a counter
376:24 - to indicate the position in the list so
376:27 - you could store two fields in your
376:31 - storage let's say field elements that's
376:33 - your big map
376:35 - and then a value that counts the number
376:37 - of elements in your big map that starts
376:39 - at zero and if you want to add an
376:41 - element all you have to do is write your
376:45 - value with a key being the current value
376:49 - of NB elements and then you increment NB
376:51 - Elements by one then you can create a
376:53 - loop that just Loops from zero to NB
376:56 - elements minus one so that you can
376:58 - iterate through all the elements in the
377:00 - big map but if you Loop through all the
377:03 - elements in the big map This Way well
377:06 - again if the size of the big map gets
377:08 - too much and you could get stuck again
377:11 - let's say you want to compute the sum of
377:12 - all the elements but there's too many
377:14 - elements to Loop through in a single
377:18 - transaction without exceeding the gas
377:20 - limit then you have the same problem so
377:23 - how would you solve that pause the view
377:25 - and think about it for a minute one way
377:28 - to avoid the very long loops and avoid
377:30 - Loops that cannot go through in a single
377:32 - contract call is to Simply use multiple
377:35 - contract calls you could split the loop
377:38 - into multiple calls that maybe do only
377:41 - 100 iterations in one call so you could
377:44 - keep in your storage where you're at in
377:46 - this big loop so you could have a loop
377:48 - counter in the storage and then you have
377:51 - this continue sum entry point where you
377:54 - pass how many iterations you want to go
377:56 - through at the most and then you Loop
377:58 - through them you increase your counter
378:00 - for every iteration you do and if you
378:03 - didn't exceed the number of elements in
378:05 - your big map then you add the
378:07 - corresponding value to your sum so this
378:11 - could be one way that you can make sure
378:13 - that no matter what you will be able to
378:15 - Loop through all the elements in your
378:16 - big map and compute the sum this could
378:20 - end up being expensive this if there's
378:22 - millions of elements but you will be
378:24 - able to do that if you're ready to pay
378:25 - the price but for this specific example
378:28 - of computing the sum we can do much
378:31 - better can you find out how pause the
378:34 - video and think about it so the idea is
378:36 - that instead of looping to compute the
378:38 - sum when we need this sum it's a lot
378:41 - better to maintain the sum as we add
378:44 - elements all we did to the list is ADD
378:48 - elements to it and maybe we could have a
378:50 - way to remove element from them but as
378:52 - long as we don't do anything more
378:53 - complicated we can maintain the sum as
378:56 - we modify this data structure so we add
378:59 - this sum elements variable in our
379:02 - storage and then every time we add an
379:04 - element we simply add the value to some
379:07 - elements this way when we need the sum
379:09 - we just have to read it in the
379:11 - storage so this is pretty basic and
379:14 - pretty easy to do but it's something to
379:16 - really keep in mind because that's
379:18 - something we use a lot and this works if
379:20 - you want to compute the sum if you want
379:22 - to compute the smallest element in a
379:25 - list or the maximum element in a list or
379:28 - even the average value in your list but
379:31 - a lot of times just like we did a bit
379:33 - earlier this other approaches to reduce
379:36 - the gas consumption that really mostly
379:38 - consist in doing work off chain that's
379:41 - really the best way to avoid paying too
379:43 - much gas is to do as much as the
379:45 - computation as possible off chain in
379:47 - this video you will learn a new way that
379:50 - contract can interact with each other
379:52 - and that will make it even easier to
379:55 - build projects composed of multiple
379:57 - contracts that interact with each other
379:59 - and this new way is what we call views
380:02 - more precisely onchain views but we'll
380:05 - just say views to keep it short and it's
380:07 - a mechanism that allow contract calls
380:11 - that are really meant for one contract
380:13 - to obtain information about another
380:15 - contract and Views are readon so when
380:18 - you call a view of another contract that
380:21 - view cannot modify the storage of that
380:23 - contract and cannot emit its own
380:27 - operations so that means it doesn't have
380:29 - any side effect so by calling that view
380:31 - you not have any effect on this contract
380:34 - all you can do is obtain some
380:37 - information from that contract there can
380:39 - be some computation to obtain that
380:41 - information but there won't be any side
380:43 - effect other than returning the data
380:45 - from that smart contract when you call a
380:48 - view you can pass arguments as
380:51 - input that will be used by the view in
380:53 - addition to the content of the contract
380:55 - storage of that view and uh the view may
380:58 - call other views from other contracts
381:01 - again with no side effects no
381:02 - modification of their storage or no
381:05 - emitted operations calling a view in
381:08 - itself is not an operation all it does
381:11 - is return a result as an output and
381:14 - unlike contract calls or transfers of
381:18 - Tes they are executed immediately they
381:21 - are synchronous so as soon as you call
381:24 - it the view is called in the other
381:26 - contract the C of that view in the
381:28 - contract is immediately executed and the
381:31 - result is immediately available to the
381:33 - caller contract
381:35 - that's very different from inter
381:36 - contract calls that we have seen before
381:39 - where an inter contract call is really a
381:41 - new transaction that you add to a queue
381:43 - but here with views there's no new
381:45 - transactions you immediately execute the
381:48 - code and obtain the result so let's take
381:51 - a look at how we create and call an
381:54 - onchain view creating an onchain view is
381:57 - very similar to creating an entry point
382:00 - we use a different decorator sp. onchain
382:03 - view to indicate that that this is a
382:05 - view then it's like a method that takes
382:08 - one or more parameters just like entry
382:10 - points we can have any kind of
382:12 - computation within the entry point
382:15 - except for modifying the storage and
382:18 - creating new
382:20 - transactions and then the other
382:21 - difference with an entry point is that
382:23 - it returns a value with a keyword return
382:27 - to call a view within an entry
382:30 - point you write sp. View and then
382:33 - between parenthesis and number of values
382:36 - the name of the view so that's the name
382:39 - you gave to the method in your contract
382:42 - then you provide the contract address so
382:44 - the address of the contract that
382:45 - contains this view then you provide the
382:48 - value of the parameter so it could be a
382:50 - single value like here it could be a
382:52 - record it could be anything and then you
382:54 - provide the address of the return type
382:57 - so here we are returning the address of
382:59 - the owner of a token so we pass the
383:02 - token and we say the return type is an
383:05 - address what you will get is then an
383:08 - option on a value from this type so you
383:10 - have to unwrap it to obtain the actual
383:13 - address let's work on an example there
383:17 - was an issue with our nft join account
383:20 - contract which was that if when you pass
383:23 - a list of items you want to buy and a
383:27 - corresponding price a corresponding
383:29 - amount for each nft if one of the nfts
383:33 - in your list list has a price that has
383:36 - changed since you built your list then
383:39 - the purchase of that nft will fail but
383:42 - not only that since one call Will Fail
383:46 - then your whole contract will fail and
383:48 - none of the nfts will be bought so that
383:51 - can be a bit frustrating So to avoid
383:53 - that we will use views by simply
383:56 - checking the price of an nft the current
383:59 - price of an nft right before we try to
384:01 - buy it if it's the wrong price then
384:04 - we'll just skip it and avoid having the
384:07 - whole transaction being cancelled so in
384:10 - our basic nft for sale contract we will
384:14 - add an onchain view get price that only
384:18 - does one thing which is to return the
384:20 - current price of the nft so we just
384:22 - return that value and this way in our
384:25 - join account
384:28 - contract here when we are trying to buy
384:33 - a given n
384:35 - we use the get price view we pass the
384:38 - address of the contract our parameter
384:42 - here is of type unit there's no
384:43 - parameter so we put a pair of
384:45 - parenthesis and what we get is a price
384:47 - so the return type will be
384:49 - mutes and we unwrap the option that we
384:52 - get into a variable price then we can
384:56 - check if the price is the amount we
384:58 - expected to pay then we do the
385:01 - transaction and here we know for sure
385:03 - that this trans transaction will succeed
385:06 - because the price cannot change between
385:08 - the time that we call this
385:11 - contract and the time that the buy code
385:14 - is run so that makes it really
385:16 - convenient and it's easy enough to use
385:18 - so that before we actually do a
385:20 - transaction with another contract we can
385:22 - check information about that contract to
385:24 - make sure we do something that will not
385:27 - fail if we combine interc contract calls
385:30 - and
385:31 - views we can split complicated contracts
385:35 - into simpler contracts which is
385:37 - something really recommend it has
385:39 - several advantages but most of all it
385:42 - makes contract simple for example if we
385:45 - keep the topic of nfts we can split two
385:48 - key roles between two contracts we would
385:52 - have one contract that only takes care
385:54 - of storing the nfts with their IDE their
385:57 - metadata their owner we would call that
386:00 - a ledger contract that just keeps track
386:02 - of Who Wants What
386:05 - nft and we could have a separate
386:07 - contract that will handle all the
386:09 - trading of nfts we would call that a
386:11 - Marketplace contract if the Ledger
386:14 - contract can allow the marketplace
386:17 - contract to change the owner of
386:19 - nfts then we can use this pair of
386:22 - contracts to have people trade
386:25 - nfts and we will keep each of the
386:27 - contracts pretty simple and it will also
386:31 - make it possible to reuse contracts and
386:33 - com combine them with new contracts for
386:35 - example a new type of marketplace or a
386:37 - new type of nft let's look at the
386:40 - structure of The Ledger
386:42 - contract so we would need to store and
386:45 - admin that's who is allowed to change
386:47 - the owner of the contracts that will be
386:49 - our Marketplace contract then we have
386:52 - our usual next token idea to keep track
386:55 - of the idea for the next token we will
386:57 - mint then we have our token speak map
387:00 - that will store all information so we
387:02 - use the token ID as a key and then for
387:06 - each token we store the address of the
387:08 - owner and the metad dator then we have
387:10 - three pretty basic entry points first
387:13 - the mint entry point where we pass
387:15 - metadata and we will simply create a new
387:18 - entry in the tokens big map with the
387:20 - next token ID as a key the caller as the
387:24 - owner and the past metadata as the
387:27 - metadata then we increment the next
387:29 - token ID then we have an entry point to
387:32 - change the owner of a given token so we
387:34 - pass the ID of the token and the new
387:37 - owner we check that the caller is the
387:39 - admin so the admin is allowed to do
387:41 - anything we trust this admin we trust
387:43 - the marketplace because we have read the
387:46 - code before we do that and then we
387:48 - simply change the owner within the
387:52 - tokens to the new owner and for the
387:55 - marketplace to be able to interact with
387:58 - the Ledger it will need to be able to
388:00 - find out who's the current owner of a
388:02 - given token so we have an unchain view
388:04 - get owner that Tex this parameter a
388:06 - token ID and then will simply return who
388:09 - is the owner of that token now let's
388:12 - look at the nft marketplace contract the
388:15 - goal is simply for owners of nfts to be
388:19 - able to put them for sale at a a given
388:21 - price and then buyers will be able to
388:24 - buy them so here we will store all the
388:27 - offers in a big map for the key we will
388:30 - use a composed key a pair of two values
388:34 - the address of the nft contract so in
388:36 - which contract is our nft we can have a
388:39 - Marketplace that can handle multiple
388:40 - collections of nfts in multiple
388:42 - contracts within the collection we need
388:45 - to know the token ID so a given offer
388:49 - has a key that is the description of
388:51 - which nft it is through the address of
388:53 - the contract and the token ID within
388:55 - this contract and then for the value we
388:57 - simply have the price at which the
388:59 - seller is willing to sell this
389:02 - nft then we need three entry points one
389:05 - entry point for the owner of nft to
389:08 - create an offer so again we say what's
389:11 - the contract that stores this nft what's
389:14 - the token idea within this contract and
389:16 - at what price we want to sell it using
389:18 - the get owner view of the nft contract
389:21 - we will check that the caller is indeed
389:23 - the owner of this
389:24 - nft and if it is then we'll add an entry
389:27 - to the offer is big map we give a chance
389:29 - for the owner to cancel their offer so
389:32 - they indicate what what's the nft
389:34 - address and what's the token idea we
389:36 - check that the caller is the owner of
389:37 - the nft again using the view and we
389:40 - simply remove that entry from offers and
389:43 - finally when a buyer wants to buy
389:46 - rft they indicate which contract which
389:49 - token idea so basically they indicate
389:51 - which one they provide the key to the
389:53 - entry in the offers big map so using
389:57 - that we check that the amount they send
390:00 - as they call the buy entry point matches
390:03 - the price stored in the big map we
390:06 - transfer that amount to the current
390:08 - owner that we obtain again using the get
390:11 - owner view of the nft contract and
390:14 - finally we change the owner by calling
390:18 - the change owner entry point of that
390:20 - contract and so we pass them the address
390:22 - of the new owner that is the call and
390:25 - when we're done we remove the entry from
390:27 - the offers big map so your job now using
390:30 - this description is to implement these
390:32 - two contracts
390:34 - so you implement The Ledger then the
390:36 - marketplace and you create the
390:38 - corresponding test to make sure
390:40 - everything works pause the video and
390:43 - give it a try so let's take a look at
390:45 - the solution we will start with the
390:47 - ledger so for The Ledger we store the
390:50 - admin that will be the address of the
390:52 - marketplace contract we create a tokens
390:55 - big map that will store the content of
390:58 - The Ledger all of our tokens their price
391:00 - and
391:01 - owners then we have this counter next to
391:03 - token idea that we initialize at one in
391:07 - the mint entry point we obtain the
391:09 - metadata as a parameter we indicate that
391:11 - this Matera is a string there's no other
391:14 - way to find out by just checking the
391:15 - contract so type inference won't work so
391:18 - we say this is a string then we add an
391:21 - entry to the tokens big map using as a
391:25 - key the next token idea and the value is
391:28 - a record that contains the owner so
391:31 - whoever is calling this entry point and
391:33 - the materal data and of course we
391:35 - increment next token idea so that next
391:37 - person Ms with a different idea then we
391:39 - have this onchain view get owner that
391:42 - takes as parameter the token ID and that
391:44 - simply Returns the owner of that token
391:47 - finally the change owner entry point
391:49 - takes the token ID as parameter and the
391:52 - address of the new owner we check that
391:54 - the caller is the admin of this nft
391:58 - contract so that would be the
392:00 - marketplace and then we assign the new
392:02 - owner to this to toen so that makes it a
392:06 - pretty basic contract pretty easy to
392:08 - proof read and check now let's see how
392:11 - we can create the marketplace contract
392:13 - that interacts with it it's very simple
392:17 - as well we have a storage that only
392:20 - contains this big map with the offers we
392:22 - have an entry point new offer where we
392:24 - indicate which contract and which token
392:26 - idea we are selling at what price then
392:31 - we call our view get owner from from the
392:34 - nft contract we pass the token ID and
392:37 - the return value is the address of the
392:39 - owner so we provide that type and then
392:42 - we unwrap the option to obtain the owner
392:46 - so here of course the idea was to check
392:48 - that it's the owner calling so we have
392:51 - to add assert
392:53 - owner is sp
392:58 - sender and once we've checked that then
393:01 - we create the entry in the offers big
393:05 - map with a key that is a pair containing
393:08 - the address of the nft contract and the
393:10 - token idea and the value is simply the
393:13 - price that we are willing to sell this
393:16 - nftg for then we simply have a buy entry
393:20 - point for any buyer to try to buy this
393:22 - nft tesas parameter again the
393:25 - description of which nft it is through
393:27 - the contract and the token ID within
393:28 - this contract so we first check what's
393:32 - the price of the corresponding offer and
393:35 - if there is no such offer this will fail
393:37 - so the contract will fail so there's no
393:38 - need to check that the offer exists we
393:42 - simply try to read from it and it will
393:44 - fall if it doesn't exist then we check
393:47 - that the amount sent was indeed the
393:50 - price so if this is the case we will
393:53 - change the owner of the nft by calling
393:56 - the change owner entry point of the
393:58 - contract so we use those usual two
394:00 - instructions obtaining the contract
394:02 - object we pass has the type of the
394:04 - parameter the address of the contract
394:07 - and the name of the entry point for the
394:09 - type of the parameter here we have
394:13 - used uh type definition here where we
394:16 - say okay this is a record that contains
394:20 - a token ID an integer and the new owner
394:23 - an address this is a good habit when you
394:25 - do inter contract calls it's a good idea
394:27 - to have the type defined as a type
394:30 - abbreviation at the beginning of your
394:32 - code
394:34 - so now that we have the contract we
394:36 - prepare the parameter so a record with
394:38 - the token ID and the new owner so
394:42 - caller sp. cender and then we call the
394:46 - contract so here it's not going to do a
394:49 - call right away we are simply adding a
394:51 - transaction to the queue that will call
394:54 - this contract with this parameter and
394:57 - sending zero test but we know for sure
395:00 - that if this fail everything will be
395:02 - cancelled so here one thing we didn't do
395:05 - is send the amount to the previous owner
395:09 - so for that we'll need to
395:12 - obtain the address of the previous owner
395:14 - so we can just copy that
395:17 - code and then we can
395:20 - send to the
395:22 - owner the
395:28 - amount also creating a transaction that
395:30 - will send this amount to the owner and
395:33 - at the end and we need to make sure we
395:35 - delete the offer to make sure someone
395:37 - doesn't buy it again right away and
395:39 - immediately take it from this
395:43 - buyer so here we have a very basic test
395:46 - that doesn't check much but shows the
395:50 - two calls we have here created two
395:52 - different ledgers to show that we can
395:54 - have the same Marketplace interact with
395:56 - multiple nfts and when we create each of
395:59 - these Ledger we pass as the admin of The
396:02 - nft Ledger the address of the
396:04 - marketplace that we have created here
396:07 - then we Mint one nft in
396:10 - each then we create an offer in the
396:13 - first Ledger for the token ID one so
396:17 - this NFD that we have minted here we say
396:20 - we want to sell it for Tes and it's
396:23 - Alice selling it so she's the owner of
396:25 - that nft then someone else can buy the
396:28 - nft by NE getting okay I want to buy a
396:31 - token from this contract with this token
396:34 - idea and it's Bob buying it and he's
396:37 - paying those 10 so we can run
396:42 - it and we can see the origination of the
396:47 - marketplace then the two
396:51 - ledgers then we have the minting of
396:53 - those two
396:54 - nfts then offer is being
396:57 - made and stored in a big map of
397:01 - offers and then we have this uh purchase
397:04 - it sends the test to the previous owner
397:07 - and then calls change owner so we see
397:09 - that here the calls to the Views are not
397:12 - shown they're not individual
397:14 - transactions so they're not visible but
397:16 - they have definitely worked to check who
397:18 - to send the test to for
397:20 - example one thing to know about onchain
397:23 - views is that although they are called
397:25 - onchain views they can also be used
397:27 - offchain so this means from adap for
397:31 - example or from any offchain software
397:34 - you can execute this view to obtain some
397:37 - information about a given smart contract
397:40 - so if you want to know the current owner
397:43 - of an nft for a given nft contract you
397:46 - can do an RPC call so remote procedure
397:49 - call to the node to say hey I want to
397:52 - execute this view to obtain information
397:55 - about this smart contract and then you
397:57 - will get the result at different
397:59 - libraries like takito make it easier to
398:01 - do that and this can be very useful if
398:04 - you want to standardize option read
398:06 - access to contract so if you want to
398:09 - know who is the owner of an nft of
398:11 - course you could directly access to the
398:12 - Mig map you have access to everything
398:14 - from of chain but if you want a standard
398:16 - way to find out and work with all kinds
398:19 - of nft contracts that maybe store their
398:21 - owners in different ways if they follow
398:24 - the contract they should all have this
398:26 - um onchain view that Returns the owner
398:29 - of a given token idea and so the same
398:31 - code will be able able to interact with
398:34 - all different contracts through this
398:37 - standardized view so this means we can
398:40 - write a standard on how to obtain the
398:42 - owner of a contract without having to
398:43 - specify how the owner of an nft is
398:46 - stored and very often those views are
398:49 - usedful both onchain and offchain one of
398:52 - the reasons they are called onchain
398:54 - views is that there are other types of
398:56 - views that we have been using in the
398:59 - past and are still using in some cases
399:00 - on tesos there is the term offchain
399:04 - views or that we call metadata views so
399:07 - those used to be melon code that you
399:10 - could call from offchain to obtain
399:12 - information about a smart
399:14 - contract but with nothing executed on
399:17 - chain so it's basically the old way to
399:19 - do the offchain use of the views that we
399:22 - just
399:23 - described and there's a standard that
399:25 - describes it called tzip 16 it is still
399:29 - part of some well-used standards like
399:31 - aa2 that we'll talk about later there
399:34 - was another type of views that we were
399:36 - using before onchain views were created
399:39 - and this was called Lambda views it was
399:42 - also a standard um defined as called
399:45 - tzip 4 and it was not a feature but more
399:48 - of a pattern on how to implement your
399:52 - own views using a system of call backs
399:54 - so it was using inter contract calls but
399:56 - passing a call back to the contract you
399:59 - were calling to say hey compute this
400:01 - information and then when you're done
400:03 - send it to this call back so it served
400:06 - the same purpose onchain as our onchain
400:10 - views but was a lot less convenient to
400:13 - use and so this new onchain view concept
400:16 - is basically replacing both those old
400:19 - ways to do views but again they are
400:22 - still in use for legacy reasons in
400:24 - existing standards but for your new
400:26 - contracts onchain views are really the
400:29 - way to go and make it really convenient
400:31 - in this module we will talk about custom
400:33 - types a piece of syntax that will save
400:36 - you a lot of time when you use interc
400:39 - contract calls or onchain views you
400:42 - often have to specify the type of the
400:44 - parameter and the type of the return
400:47 - value and those types can be a bit long
400:50 - here we present a short example of a
400:53 - typical type that we may pass as a
400:55 - parameter where we specify a destination
400:57 - address a token ID an amount and to
401:01 - match the specifications of Standards we
401:03 - have have to specify the corresponding
401:04 - layout putting this whole piece of code
401:08 - every time you have to specify the type
401:10 - or calling a smart contract that uses
401:13 - this kind of parameter is very
401:15 - inconvenient and if you make changes to
401:17 - the type then you have to make sure you
401:19 - change it everywhere but more generally
401:21 - it makes the code hard to read and hard
401:23 - to maintain So to avoid this and make it
401:27 - things easier we can give a name to a
401:29 - type directly in the main module here
401:32 - for this type Ty we declare the name
401:35 - transaction type we say it's a custom
401:37 - type by putting a column then the
401:40 - keyword type then equals and then the
401:42 - description of the type from then on we
401:45 - can use this name everywhere we need to
401:48 - provide this type so be very careful
401:50 - this only works if you put it in the
401:52 - module itself you cannot Define a custom
401:55 - type within a smart contract for example
401:58 - so typically you would have all your
402:00 - custom types at the beginning of your
402:02 - module as an exercise create a joint
402:05 - account contract with a deadline so you
402:08 - take the existing joint account contract
402:11 - and change it so that they can purchase
402:13 - nfts where prices have a deadline that
402:16 - means to buy the nft at that price you
402:19 - have until that date and after that date
402:21 - the price is not valid anymore while you
402:24 - work on this exercise the whole point is
402:26 - for you to use a custom type to avoid
402:29 - having to put the full type every time
402:31 - you call the smart contract for this
402:33 - exercise there probably will be only one
402:35 - call but the point is to practice
402:37 - grading custom types pause the video and
402:40 - give it a try let's take a look at the
402:42 - solution so here we will need a type
402:46 - record that takes the new price and the
402:49 - deadline so that we call the entry point
402:51 - to update the price we give both the
402:53 - price and the deadline so we create a
402:56 - custom type for this that we Define at
402:58 - the beginning of our main
403:00 - module then when we we call the contract
403:04 - here instead of doing sp. contract and
403:06 - then describing the whole record type in
403:09 - detail we simply put entry pointcore
403:12 - type the name of our custom type and we
403:15 - can give it a try and it works all good
403:19 - in this video we will talk about the set
403:21 - data structure and we will work on the
403:24 - membership contract that can be used to
403:26 - define which users are allowed to access
403:29 - specific features of a smart
403:31 - contract a set is an unordered
403:34 - collection of values of the same type
403:37 - it's a bit similar to a list except in a
403:39 - list the same value can be present
403:41 - multiple times and we worry about the
403:43 - order of values but in a set all we care
403:46 - about is whether a value is or is not in
403:49 - the set you can do three main operations
403:52 - in the set very efficiently you can add
403:55 - an element to the set you can remove an
403:57 - element from a set and you can check if
404:00 - a given element is or is not in the set
404:03 - and those three can be done pretty
404:05 - efficiently because internally the
404:07 - values are stored in a balance tree
404:10 - sorted by value the syntax to use sets
404:14 - is pretty straightforward you can create
404:17 - a set in two ways using sp. set for
404:21 - empty set or you can provide the list of
404:24 - values in the set between curly
404:27 - brackets if you want to specify the type
404:29 - of a set you write sp. set and between
404:32 - square brackets the type of the
404:34 - values then you can do the three
404:37 - operations adding an element with add a
404:40 - your value you can remove an element
404:42 - with remove and the value and you can
404:45 - check if the set contains an element by
404:47 - calling your set do contains of the
404:50 - value and will return true or false
404:52 - depending on whether your set contains
404:54 - it you can obtain the number of elements
404:57 - in the set using Len and then you can
404:59 - obtain the list of elements sorted by
405:02 - values by calling your set. elements so
405:06 - let's work on an exercise where we will
405:09 - create a membership contract it can be
405:11 - quite useful to have a contract
405:13 - dedicated to storing a set of
405:15 - members we can use it to restrict access
405:18 - to features of a smart contract based on
405:20 - some conditions that's what we call
405:22 - allow listing so the list of users that
405:24 - allowed to do
405:26 - something and we can use it to create
405:28 - artificial scarcity for example if an
405:31 - nft can only be bought by members of a
405:34 - club then that makes this nft a bit more
405:36 - exclusive which can increase its value
405:39 - we can also use a membership contract to
405:42 - create a community for example da a
405:44 - decentralized autonomous organization
405:46 - where we store the members in a
405:48 - membership contract and it's often a
405:51 - good idea to separate this data into a
405:53 - dedicated contract that focuses on
405:56 - membership and then this list of members
405:59 - can be reused in other contracts not
406:01 - just this initial contract contct that
406:03 - we meant it for okay so your job for
406:06 - this exercise is to think about how you
406:09 - would Implement such a membership
406:11 - contract and we want to make it
406:13 - exclusive so the idea is that we only
406:15 - want rich people to be able to join this
406:19 - contract or this elite club we don't
406:21 - want them to pay a fee to join but we
406:24 - want them to prove that they do have
406:27 - access let's say to 10,000 T so if you
406:30 - don't have access to 10,000 T you you
406:33 - are not allowed to join this exclusive
406:35 - club we also want to restrict the size
406:38 - of this club to 100 people and of course
406:41 - we want members to be able to leave this
406:43 - community if they want to your contract
406:45 - will need to have an onchain view so
406:48 - that any contract can check if a user is
406:51 - a member of this club or not pause the
406:54 - video and think about what you would
406:56 - store in this contract and what the
406:58 - entry points would be and would do so
407:00 - it's a pretty simple contract in a
407:02 - storage we can store the threshold how
407:05 - much you need to show that you have to
407:07 - be able to join the club we will of
407:10 - course store members the set of
407:12 - addresses that are members of this club
407:15 - and we can store the maximum size that
407:17 - we want the club to have of course those
407:19 - two values could also be hardcoded but
407:22 - here we decided to make them values in
407:24 - the storage then you have three entry
407:27 - point or two entry points and one on
407:29 - chain view the main entry point is the
407:31 - join entry point for someone to join the
407:34 - club so first you have to check that the
407:37 - club is not full so the members doesn't
407:39 - already contain Max size
407:41 - entries then we check that whoever wants
407:45 - to join is actually sending the amount
407:48 - required to join the club to the
407:50 - contract we won't keep that value we
407:52 - will send back here back to the sender
407:55 - but this is a way to prove that they do
407:57 - have access to this money because they
407:59 - are able to send it to the contract
408:01 - before they get it back so if they do
408:03 - have this amount and send it to the
408:05 - contract we can add their address to the
408:07 - members set our onchain view will simply
408:11 - return whether user so the address
408:13 - passed as a parameter is in the members
408:16 - set and then we have a leave entry point
408:18 - where we simply remove whoever is
408:20 - calling this entry point from the set of
408:23 - members pause the video and implement
408:25 - this smart contract let's take a look at
408:27 - the solution we can see here that we
408:30 - have a Constructor that takes the
408:31 - membership thr so and Max size as
408:34 - parameters and stores them and then it
408:36 - creates this members empty set in the
408:39 - join entry point we check that the
408:41 - caller did send the required amount we
408:45 - check that we still have fewer than Max
408:49 - siiz members in the set we check that we
408:53 - still have fewer than Max siiz members
408:55 - in our
408:57 - club then we add this uh color in the
409:01 - set of members and we send them back the
409:04 - amount since we don't want to keep it in
409:06 - the
409:06 - contract we have our is member onchain
409:10 - view that takes a user as a parameter
409:13 - and we simply returns whether it is in
409:16 - the member set or not finally you can
409:18 - call the leave entry point and then we
409:21 - simply remove this address from the
409:23 - members we have a basic test where we
409:27 - create a rich
409:29 - Community by calling this contract with
409:31 - a threshold of 10,000 TZ and a maximum
409:34 - number of members of
409:37 - 100 we then have Alice join by sending
409:40 - the right amount Bob first tried to join
409:43 - with the wrong amount so it shouldn't
409:44 - work then he tries again with the right
409:47 - amount from the scenario we can call the
409:50 - onchain view to check that Alice is
409:52 - indeed a member and that Carl who never
409:55 - joined is not a member then we can test
409:58 - that we can leave so Bob is leaving the
410:00 - community and here we check that indeed
410:03 - he's not a member anymore if we can give
410:06 - it a try we see that we first create an
410:09 - empty set Alice join Bob tries to join
410:13 - and fails Bob then succeeds in joining
410:16 - we can see that we have Alice and Bob
410:19 - here and then we send the 10,000 back to
410:22 - Bob and then Bob leaves and only Alice
410:25 - is a member all
410:28 - good it's important to know when not to
410:31 - use sets and there are situations where
410:33 - you really shouldn't use them pause the
410:36 - video and think about why for a minute
410:39 - the issue as often is with the amount of
410:42 - storage that you have to serialize or
410:44 - deserialize when you call the contract
410:46 - if you have a set and this set gets too
410:49 - big then this amount could be so big
410:52 - that the amount of gas you spend in a
410:54 - transaction exceeds the maximum amount
410:56 - that you allowed so your contract could
410:58 - get stuck if your set keeps growing
411:00 - arbitrarily
411:02 - in our exercise we don't have this issue
411:04 - because we had a limit of 100 members in
411:06 - the set so we were safe it could never
411:08 - grow to more than 100 members but what
411:11 - if you didn't want to have this size
411:13 - limit how could you make sure that your
411:16 - contract never gets stuck pause the
411:18 - video and think about it for a minute so
411:20 - as often when you want to use a data
411:23 - structure doesn't have any size limit
411:26 - you can use a big map and big map can
411:29 - associate a value with a key here we
411:31 - don't have a value but we still can use
411:33 - keys so we could use the values of the
411:36 - set as keys to our big map and then for
411:39 - every key we simply store unit which is
411:42 - nothing so when we want to add a member
411:45 - to our big map we simply say members of
411:48 - this address equals sp. unit so it
411:51 - creates the entry even though the entry
411:53 - doesn't contain anything we can remove
411:56 - it using Dell and we can check
411:58 - membership simply by checking if there's
412:01 - an entry for that address
412:03 - then we can have membership contract
412:05 - that has as many people as we like
412:07 - without having to worry about the costs
412:09 - so big Maps is always what you have to
412:11 - think about when you want to store a lot
412:14 - of data but you should be careful it
412:16 - doesn't always solve all of your gas
412:19 - issues in particular you have to keep in
412:21 - mind that whenever you access a given
412:24 - entry in your big map you still have to
412:26 - deserialize and resize this
412:29 - entry so if you store for example a full
412:32 - set within a single entry then it could
412:35 - be risky because that single entry could
412:37 - get really big and then you would end up
412:40 - with the same problem again so big maps
412:42 - are part of the solution when you want
412:44 - to store a lot of data but it's not
412:46 - always sufficient so you should still be
412:49 - careful in this module we will talk
412:51 - about variance a piece of syntax that
412:53 - allows you to create your own types
412:56 - let's start with simple variants a
412:59 - variant is a type that we use to
413:01 - represent one of several predefined
413:04 - values for example you could Define a
413:06 - type called day of week for values that
413:10 - represent a weekday so a variable of
413:13 - this type could hold any of these values
413:16 - Monday Tuesday Wednesday Thursday Friday
413:18 - Saturday and Sunday simple variant are
413:21 - similar to inms in some other languages
413:25 - that you may be familiar with the syntax
413:27 - to create a variant type is to write sp.
413:31 - variant and then between parentheses the
413:33 - list of possible values and a type unit
413:37 - we'll see later how we can have variance
413:40 - with parameters where the type is
413:42 - different but for now you simply put a
413:44 - list where each element is a name then
413:47 - equals sp. unit meaning nothing to avoid
413:51 - repeating this every time we use a type
413:53 - we usually create a named type a custom
413:55 - type in the main module so in our main
413:58 - module we would write day of week column
414:01 - type equs and then sp. variant with all
414:04 - the different values then within your
414:07 - smart contract you can use values of
414:10 - this type for example in assignments or
414:13 - comparisons here we create an attribute
414:16 - in the storage called day and with
414:19 - initial value of Tuesday so when you use
414:22 - the value you put the name and then a
414:24 - pair of parentheses then you can compare
414:27 - this value to different possible value
414:30 - of this variant here we compared to
414:32 - Sunday or Saturday to determine if this
414:35 - is the weekend and the price for some
414:38 - work is more expensive during the
414:40 - weekend when you use variance you need
414:42 - to keep type inference in mind because
414:45 - if you don't specify the type it can be
414:48 - determined automatically using type
414:51 - inference but it will only be determined
414:54 - based on the actual values that you use
414:56 - so if you have a variant for all the
414:58 - days of the week but you only use some
415:01 - of the days in your code
415:02 - then the type inferred by the type
415:05 - inference algorithm will only contain
415:08 - the values that you have used but you
415:10 - may need the other values in some other
415:12 - cases so that could be a problem so in
415:15 - this example the type inference only
415:17 - creates this variant it only has Tuesday
415:20 - Sunday and Saturday type inference can't
415:23 - guess that there are other weekday than
415:26 - the ones you use in your code if you
415:29 - want to execute different code depending
415:31 - on the value of a Varian
415:32 - you can use sp. match as an alternative
415:36 - to using ifs and elves and
415:39 - comparisons sp. match works like this
415:42 - you write with sp. match and then
415:45 - between parentheses the value then you
415:47 - put one section for each value where
415:50 - each section start with with and then
415:53 - sp. case do the name of the variant
415:56 - colum and then the corresponding code in
415:59 - the test scenario with the current
416:02 - version of smart Pi the way you use
416:04 - variance within your test is a different
416:08 - syntax from the syntax you use within
416:10 - the smart contract itself this may
416:12 - change in the future but that is the
416:15 - case at the moment of recording to
416:17 - describe a given value of the variant
416:19 - instead of writing sp. variant Dot and
416:22 - the name of the value like you do in
416:25 - your smart contract in the scenario you
416:27 - will write sp. variant and then between
416:30 - parentheses the name of the variant
416:33 - between double quotes comma the value
416:36 - unit as a pair of
416:38 - parentheses and then if you want to
416:40 - check if a value is a given variant
416:43 - instead of writing your value do is
416:46 - variant Dot and then name of your
416:48 - variant and parenthesis you write is
416:52 - variant and then between parentheses the
416:55 - name of the variant between double
416:57 - quotes again most likely in the future
416:59 - version of smart py they should be
417:01 - Unified to the same version we use in
417:04 - smart contracts let's take a look at a
417:06 - full example that uses variant here we
417:10 - Define our custom type for the days of
417:12 - the week from Monday to Sunday then in
417:15 - our smart contract we initialize the
417:18 - storage attribute day with the value
417:20 - Tuesday we use sp. cast to make sure
417:24 - that we don't let the type infer
417:26 - determine the type of day but we say
417:28 - this is day of week to make sure that
417:30 - all the days are possible then in our
417:33 - work entry point we compare the value to
417:36 - Sunday or Saturday and determine the
417:39 - price based on that and finally in our
417:42 - test scenario we can call set day with a
417:45 - different syntax to create a value
417:48 - Sunday and then we can verify that the
417:51 - value has been set to Sunday using this
417:54 - test specific syntax we can give it a
417:57 - try and everything works as an exercise
418:00 - to practice variance
418:02 - write a contract that has an order drink
418:05 - entry point and that entry point should
418:07 - take the identifier of a drink as a
418:09 - parameter in the form of a variant it
418:12 - should charge the user the corresponding
418:15 - prices so if you order water you pay
418:18 - nothing if you order a Coca-Cola you pay
418:22 - one TZ or if you order Fanta you pay two
418:25 - TZ and the smart contract should store
418:27 - the items you order in a list named
418:30 - items POS video and give it a try let's
418:34 - take a look at the solution here we
418:36 - Define the custom type drink type as a
418:39 - variant that can have the values cooka
418:42 - Fanta water and we added seven up in our
418:46 - smart contract we simply Define a list
418:49 - we don't need to specify the types here
418:51 - but in the order drink entry point here
418:53 - we cast drink as the type drink type to
418:56 - make sure we have all the different
418:58 - types including seven up as possible
419:00 - values of our variant
419:02 - we set the default price at zero then we
419:05 - use sp. match to check the different
419:08 - possibilities so one test for Coca two
419:10 - test for Fanta and zero test for water
419:14 - Etc we could add more then we check that
419:17 - the person who ordered the drink paid
419:19 - the right price and then we add the
419:21 - drink to the list of items in our test
419:26 - we use the other syntax to create
419:28 - variants to order drinks can give it a
419:31 - try
419:32 - and everything
419:34 - works all good so you may wonder when
419:38 - you should use Simple variants simple
419:41 - variant are quite convenient when you
419:43 - already know the final full list of
419:45 - possible values so in the case of days
419:48 - of the week we know that they are not
419:50 - expected to change we're not going to
419:51 - add an eighth day of the week anytime
419:54 - soon so you're pretty safe with that
419:56 - variant or if you create a game of chess
420:00 - the list of chess pieces is also very
420:02 - unlikely to change in your game so
420:04 - varant in those situations are a very
420:07 - good way to make sure you never attempt
420:08 - to assign an invalid value and they make
420:10 - it convenient to use names in your code
420:13 - the alternative could be using Naturals
420:16 - from 0 to six four days of the week and
420:19 - same for chess pieces but it's very
420:22 - convenient to name each chess piece but
420:25 - variance could be problematic if you
420:27 - ever want to allow a new value in your
420:30 - list for example for a menu item in our
420:33 - examples where we use drinks we could
420:36 - easily want to extend the list of drinks
420:39 - for example we could add root beer or
420:41 - Sprite so in this situation using
420:44 - variance is actually not a great idea
420:47 - and for anything that could change where
420:49 - new possible values are likely to be
420:52 - added using numerical values or even
420:55 - string values are preferable to variant
420:58 - for example here we have prepared a
421:01 - smart cont contract split in two so this
421:04 - restaurant smart contract is pretty much
421:07 - the one we just worked on where you can
421:09 - order different drinks but then we added
421:11 - an entry point quick drink that uses
421:15 - another contract that stores the
421:18 - favorite drink of each user this
421:20 - favorite drink smart contract has a big
421:23 - map and for each user it will store the
421:26 - favorite drink that this user has
421:28 - recorded and then there's a view
421:30 - favorite that can can request the
421:33 - favorite drink of a user and then the
421:35 - restaurant can have an entry point quick
421:38 - drink that checks what the favorite
421:40 - drink of the color is and then orders
421:42 - that drink here it happens to be a free
421:46 - drink if you order your favorite drink
421:49 - now let's say we want to have a new
421:50 - version of the restaurant where we allow
421:53 - a new type of drink so for example we
421:56 - add stri so we create this drink type
421:59 - new where we have the same list of
422:01 - values but we add this Pride value that
422:04 - we might want to use in the new
422:06 - restaurant then we PR drink contract so
422:10 - that we don't lose all of the data and
422:11 - can keep honoring this quick drink offer
422:15 - but if we do that then when we create an
422:18 - instance of the new restaurant it won't
422:22 - work we can check
422:25 - it we can see here that we're missing
422:28 - the variant Sprite in the type variant
422:31 - that we use in line
422:33 - 71 so that's really the type inference
422:36 - that is not happy when here we try to
422:39 - push a drink in our list because the
422:42 - type of drink is not the same
422:47 - type that we have used in our favorite
422:49 - drinks contract and there's no way to
422:52 - make them compatible because from the
422:54 - point of view of the type inference
422:56 - those two types are really different so
422:59 - this shows that if you ever want to add
423:01 - add a possible value to a variant you
423:04 - could be stuck and unable to use
423:07 - existing smart contracts that you are
423:09 - used to interact with you would have to
423:12 - rewrite the favorite drink and then lose
423:14 - all of its data so that it can be
423:16 - compatible with a new restaurant so
423:18 - that's clearly one case where it might
423:20 - not be a good idea to use variant and
423:22 - instead you could just use strings or
423:25 - numbers so we presented simple variance
423:28 - where you simply have a list of possible
423:30 - values but you can do a lot lot more on
423:32 - tesos with variant you can have variance
423:35 - with parameters for example let's say
423:37 - you want to store a value that
423:39 - represents the current status of a
423:41 - worker the worker could be available
423:44 - could be absent could be away could be
423:46 - in a call or could be in a meeting if
423:48 - you know for sure that this list will
423:50 - never change and this could be a good
423:53 - use for variants but in some cases we
423:56 - may want to add extra information
423:58 - specific to one of the status so for
424:00 - example if the status is away we might
424:03 - want to store the expected date of the
424:05 - next availability of the user so we
424:08 - would want to add an time stamp to this
424:11 - away status or if the person is in a
424:13 - call you may want to add the URL of the
424:16 - online call so that somebody can join
424:18 - that call so here the parameter would be
424:21 - a string and of course we could also
424:23 - want to store multiple information in
424:26 - this case you would use a record for a
424:28 - meeting you may want to store the floor
424:30 - and the room of the meeting associated
424:33 - with the meeting value of the variant
424:35 - you may want to store a record with a
424:37 - string and an INT if you want to create
424:39 - a variant with one or more parameters
424:41 - you can create values directly like this
424:46 - so for no parameters we do as we have
424:48 - done before but then you can create a
424:50 - variant with a parameter where between
424:52 - the parentheses you simply put the value
424:54 - of the parameter and here for a record
424:57 - you simply put the value of the record
425:00 - of course we recommend
425:02 - using a type declaration as we have
425:04 - suggested before so that you can have a
425:06 - precise definition of the variant so
425:09 - here we would say that for the status
425:12 - away the type is sp. time St this is
425:15 - where you understand why we put sp. unit
425:18 - before this was to say that there's no
425:20 - information no parameter associated with
425:22 - this status so for simple variant you
425:25 - put sp. unit but for variance with
425:27 - parameter you put the type of the
425:28 - parameter so sp. time 10 for away sp.
425:32 - string for call and sp. record and the
425:35 - different attributes for
425:36 - meeting now how do you check the value
425:39 - of a variant that has a parameter so
425:42 - let's say we have a status variable in
425:44 - the storage that has one of the
425:45 - following value it can be either absent
425:47 - or away and with this time stamp to test
425:50 - if the status is absent we can use a
425:53 - simple comparison as we have done before
425:55 - you can check assert self. dat. status
425:58 - equals sp. variant. absent but this one
426:01 - won't work if we want to check if the
426:03 - status is away whatever the time stamp
426:06 - value is you cannot just compare to away
426:09 - because it could be a way and a value so
426:12 - if you want to check if a value is of a
426:14 - specific variant independently of the
426:17 - value of the parameter you can use this
426:19 - syntax you can do assert self. dat.
426:23 - status. isore variant. away this will
426:28 - make sure that the status is away with
426:32 - some value if you want to extract the
426:35 - value of the parameter from a variant
426:38 - you can use unwrap so you take your
426:41 - variable status and then dot unwrap Dot
426:44 - and the name of your variant so for
426:46 - example if you want to extract the time
426:48 - associated with the status away that we
426:51 - have defined like this s p. variant.
426:53 - away of this time stamp then you can
426:56 - extract the value of this time temp like
426:59 - this you can say deadline equals self
427:01 - dat. status. unwrap do away this should
427:07 - return the value sp. time stem of 1 2 3
427:10 - 4 5 that is contained in the variant as
427:13 - we defined here if the current value of
427:16 - the status is not of the away variant
427:19 - then it will raise an error as before in
427:22 - the current version of smart pi as we
427:25 - record this video the test scenario is
427:27 - still using an old syntax to unwrap the
427:30 - value of a
427:31 - variant you will write contract. dat.
427:35 - status. opencore variant of double quote
427:39 - away so this is different from what you
427:41 - use in the smart contract itself where
427:44 - you use status. and
427:46 - r. we can expect that in the future you
427:49 - will be using this syntax in the test
427:51 - scenarios as well so earlier when we
427:54 - were working with simple variant we used
427:56 - the match and with construct to handle
427:58 - the possible values of a variant we can
428:01 - use that for variants with parameters as
428:04 - well at the end of the width line for a
428:07 - given variant we can use as and the name
428:11 - of a
428:11 - variable and when the variant matches
428:14 - this case this variable name will
428:16 - contain the value of the parameter
428:18 - here's an example where deadline will
428:20 - contain the value of the parameter when
428:22 - the status is away so we write with sp.
428:25 - case. as deadline then we can use the
428:28 - value deadline that is basically
428:30 - unwrapped from the value of
428:33 - status and compare to some value if the
428:37 - parameter is a record the variable will
428:38 - simply contain the value of the entire
428:40 - record nothing special there let's try
428:44 - this on an example we'll create a
428:47 - contract that manages the status of an
428:49 - employee and so the employee can be
428:51 - available absent away until a certain
428:54 - date in the call but we store the URL
428:57 - where the call can be joined or in a
429:00 - meeting in a given room of a given name
429:03 - and on a given floor where the floor is
429:05 - a natural number the employee should be
429:08 - able to set their status with a set
429:10 - status entry point and their boss should
429:12 - be able to invite them to a meeting
429:14 - unless they are currently
429:17 - unavailable let's take a look at the
429:19 - code the beginning of our module we will
429:22 - Define two custom types the main custom
429:25 - type is for the status where we have a
429:28 - variant that can be available with no
429:30 - parameter absent with no parameter away
429:33 - with a Tim stamp call with a string that
429:35 - is the URL to join the call and then
429:38 - meeting with the floor and the room
429:41 - we'll talk about the other type in a
429:43 - little bit we have a contract employee
429:46 - status that will store the status of a
429:49 - given employee we initialize it with
429:53 - available and we also store the owner of
429:55 - the contract and the boss of that
429:57 - employee we have an ento set status
430:01 - where where the owner of the contract
430:02 - can change the testes so the owner here
430:05 - would be the employee themselves we have
430:07 - a set status entry point where the
430:10 - employee is allowed to change the status
430:14 - to a new value so here this is where we
430:16 - indicate that status is of this type to
430:19 - make sure the type inference doesn't
430:21 - forget any possible value for the
430:24 - variant then we have our invite entry
430:28 - point that allows the bus of that
430:30 - employee to invite them to a call or to
430:34 - a meeting and here we indicate what type
430:37 - of event they want to invite the
430:39 - employee to so this is why we need to
430:41 - describe this event type that can be a
430:44 - subset of the different values of the
430:46 - status type so in this other type we can
430:50 - have two possible values either a call
430:53 - with a URL or a meeting with a floor and
430:56 - a
430:57 - room we make sure the caller is the bus
431:00 - and then we'll have this first section
431:02 - where we determine if the employee can
431:04 - be interrupted and is available for this
431:06 - call so by default they can be
431:08 - interrupted if they're available that's
431:11 - fine if they're absent well they cannot
431:13 - be interrupted they're not here if
431:15 - they're already in a call or already in
431:16 - a meeting then they cannot be
431:18 - interrupted but if they Mark that they
431:20 - were away until a certain date then they
431:22 - can be interrupted if that deadline is
431:24 - passed so if we are after the time that
431:27 - they were supposed to be away then we
431:29 - check that indeed they can be interrup
431:31 - erupted and then depending on the type
431:33 - of event we set the status to a call or
431:37 - to a meeting here you can see that we
431:39 - cannot set the status to the value of
431:40 - the event itself because they're not of
431:42 - the same type those are two different
431:44 - variants so we recreate the call and
431:47 - recreate the meeting here with the
431:49 - meeting information that we extract from
431:51 - the
431:53 - event and we have a simple corresponding
431:55 - test and we can check that everything
431:57 - works well good let's do a recap of the
432:01 - the syntax you use when you manipulate
432:04 - variants if you want to define a variant
432:07 - type you write sp. variant and in
432:10 - between parentheses the list of
432:12 - potential values where each value
432:15 - consists in a name then equals and then
432:19 - the type of parameter Associated to that
432:21 - name if there's no type you can write SP
432:24 - sp. unit then when you want to create a
432:26 - value you write sp. variant Dot and the
432:30 - name of your variant
432:31 - if there is no parameter then you just
432:34 - put a pair of parentheses with nothing
432:36 - in between but you can also put a value
432:38 - of a parameter if it's a variant with a
432:41 - parameter if you want to check if it's a
432:43 - given variant when it's a simple variant
432:46 - you could simply compare it to the exact
432:48 - same value to sp. variant and then
432:50 - variant name one but if it has a
432:53 - parameter you cannot do that so you do
432:55 - assert your variable do is variant dot
432:59 - the name of the variant so that ignores
433:01 - the parameter and checks if you're that
433:04 - variant if you want to extract the value
433:07 - of a variant with a parameter you use
433:09 - unwrap so you take your variable do
433:11 - unwrap Dot and the name of the variant
433:14 - and then this will return the value of
433:17 - the parameter to execute different code
433:19 - depending on the value of a variant we
433:21 - saw that you can use the sp. match
433:23 - syntax so you write with sp. match then
433:27 - between parentheses your value and then
433:30 - you have different cases starting with
433:32 - withth sp. case the name of a variant
433:36 - column then the code you execute if that
433:38 - value is of that Vari if the variant has
433:41 - a parameter you use the same syntax but
433:43 - you add as value this is the name of a
433:46 - variable that you give and where the
433:49 - value of the parameter will be put then
433:52 - you can use it during this code at the
433:54 - moment in a test scenario you use a
433:57 - syntax that's a bit different if you
433:58 - want to create a value you use sp.
434:01 - variant and then between parentheses a
434:03 - string that contains the name of the
434:05 - variant then the value and if the value
434:07 - is nothing you put a pair of parentheses
434:09 - to represent the value unit
434:12 - nothing if you want to check if it's a
434:14 - given variant you can write s scenario.
434:17 - verify of your variable do is variant
434:21 - and then between parentheses the string
434:23 - that represents the name of the variant
434:25 - if you want to extract the value from a
434:27 - variant in a test scenario then you
434:30 - write your variable. open variant then
434:33 - the name of your variant between double
434:36 - quotes we discussed earlier when to use
434:39 - Simple variance we can ask the same
434:41 - question about when to use variance with
434:43 - a parameter or when to use parameters
434:45 - with a variant as we stated before a
434:48 - variance can be convenient if the list
434:49 - of possible values never changes the
434:52 - same applies in the case of variance
434:54 - with parameters both for the list of
434:57 - cases for the variant and for each case
435:00 - for the type of the parameter but you
435:02 - don't need to know all the values of the
435:04 - parameter in advance for this to work
435:06 - you just need to know their type the
435:09 - main use of variance with parameters on
435:11 - tesos is actually an internal use
435:14 - because in meason entry points are
435:16 - really variants each entry point you
435:19 - call has a parameter that corresponds to
435:21 - a different value of a variant where the
435:23 - name of your entry point is the name of
435:25 - the variant so the parameter of a smart
435:28 - contract is a variant type which with
435:31 - the different entry points and their
435:33 - parameters internally variant types are
435:36 - represented as a binary tree if we look
435:39 - at the melson code for a status example
435:42 - where it can be either absent available
435:44 - away on a call or on a meeting
435:47 - internally we have this structure of
435:49 - nested ores and we can represent it as a
435:52 - tree with the main ore here with two
435:55 - children each of them being an or
435:57 - between two values this one is between
436:00 - absent and EV available and the other
436:02 - one is between a way with a parameter
436:05 - Tim stamp and either call or meeting and
436:09 - when you want to describe a value of a
436:12 - variant what you describe is a path in
436:14 - that tree where you go left or right at
436:16 - each step so for example if you want to
436:19 - describe the value available you go left
436:22 - and right so in mikon you write Left
436:25 - Right unit for the value available if
436:29 - you wanted to have the value call you
436:31 - would write right right left and then a
436:34 - string to represent the variant call so
436:37 - this is good to know if you ever see
436:39 - errors related to variant or even entry
436:42 - points that talk about
436:44 - variants okay so under then exercise to
436:47 - work with variance and parameters let's
436:50 - create a new version of our fast food
436:53 - contract where we add more choices and
436:56 - here we listed all the different choices
436:58 - you can either buy a hamburger an ice
437:01 - cream a drink or a brownie the hamburger
437:04 - will be h t by default it has a
437:07 - parameter for the type of sauce that is
437:10 - a string a parameter for the quantity of
437:12 - sauce that is natural and the price will
437:15 - be increased by 0. two Tes for each
437:19 - sauce beyond the first two so the first
437:21 - two units of sauce will be free but then
437:24 - after that you need to pay 0.2 t for
437:27 - each then you can have a side dish with
437:30 - your hamburger
437:31 - that itself is a variant it can be
437:34 - either fries or potatoes and the price
437:37 - will be zero test for fries and one test
437:39 - for potatoes so you have a variant
437:41 - within a variant for the hamburger for
437:44 - the ice cream we have two parameters the
437:47 - flavor a simple string and the extra
437:50 - topping that is a Boolean do you want
437:52 - extra topping on your ice cream or not
437:55 - the price by default will be four Tes
437:58 - and if you add an extra topping you
438:00 - would pay an extra two test and we have
438:02 - no choice in what topping it will be for
438:05 - the drink we simply have a parameter
438:07 - that is the flavor and here instead of
438:09 - using a variant because we know we want
438:11 - to add more types of drinks later we
438:14 - decided to use a string and to keep it
438:17 - simple we said that every drink is three
438:19 - T finally you can order a brownie so
438:23 - this will be a variant without a
438:25 - parameter and which charge fight test so
438:28 - write a version of our fast food cont
438:31 - that can handle all these different
438:33 - choices pause the video and give it a
438:35 - try let's look at a solution here are
438:38 - the main part is to define the variant
438:42 - type so we Define a custom type food
438:44 - type that is the variant where the
438:47 - different possible values are hamburger
438:50 - ice cream drink and brownie brownie is a
438:54 - simple variant with parameter type sp.
438:57 - unit so no parameter drink has a string
439:00 - p parameter for ice cream we have as
439:03 - parameter a record with a flavor a
439:06 - string and an extra topping a Boolean
439:10 - for hamburger it's a bit more
439:11 - complicated so hamburger is a recur that
439:14 - has a type of sauce that is a string a
439:17 - quantity of sauce that is a natural and
439:20 - a side dish that is itself a variant
439:23 - that we hear Define directly in line we
439:25 - don't create its own custom type so we
439:28 - create a variant that is either fries
439:31 - with no parameter or potatoes with no
439:35 - parameter then in our place food order
439:38 - entry point we make sure we cast the
439:41 - parameter as food type using our custom
439:44 - type then we initialize the price at
439:46 - zero and then we will add to it
439:47 - depending on the type of food so we use
439:50 - sp. match on the parameter food if it's
439:54 - a hamburger we extract the parameter in
439:57 - the variable
439:58 - composition we set the initial price at
440:01 - eight TZ we extract the hamburger side
440:04 - the sauce quantity we check if the
440:07 - quantity of sauce is more than two then
440:09 - we add 0.2 T So 200,000 mes for each
440:14 - amount of SCE Beyond two so here we need
440:17 - to write minus two and do sp do ASN
440:23 - because we
440:24 - know this will be a natural then we
440:27 - match the side dish to either Varian
440:31 - fries in which case we add zero or the
440:34 - Varian potatoes in which case we add
440:37 - one if it's an ice cream we extract the
440:40 - parameter in composition and we check if
440:42 - there is extra tupping in which case we
440:44 - add two tees and if it's a drink or
440:47 - bronie the price doesn't depend on the
440:49 - value then we check the price is good we
440:53 - have a test where we buy a hamburger
440:54 - with fries an ice cream with extra
440:57 - topping and a Coca and finally a br
441:01 - we can give it a try and it works well
441:04 - good in this module you will learn about
441:07 - the fa2 standard and this will allow you
441:10 - to create tokens contract that can
441:13 - interact with all kinds of existing
441:15 - tools in the tesos ecosystem so when we
441:18 - talk about tokens we talk about any
441:20 - digital representation of an asset or
441:23 - utility fa2 stands for financial asset
441:28 - number two and it's a token stand
441:30 - standard that we use for tokens on tesos
441:33 - this token standard enables smart
441:35 - contracts to interact with each other
441:37 - and to interact with tools such as
441:39 - wallets and it does so by using a set of
441:42 - rules conditions and functions that any
441:46 - F2 contract need to apply the fa2
441:49 - standard supports both fible and
441:51 - non-fungible tokens there's also the fa
441:54 - 1.2 standard that is an earlier standard
441:57 - that is simpler but only supports
442:00 - fungible
442:01 - tokens there's also a new version of A2
442:04 - called a2.1 that is in preparation and
442:07 - it is retro competible with fa2 so
442:09 - anything you learn about fa2 will also
442:11 - apply to fa 2.1 so the standard defines
442:15 - three mandatory entry points that your
442:18 - contract needs to have to be compatible
442:20 - with the fa2 standard the balance off
442:23 - entry point is meant to return how many
442:26 - tokens of a given token ideas one or
442:29 - more users
442:31 - then the transfer entry point will be
442:32 - used to change the ownership of a number
442:34 - of tokens owned by a user and then we
442:37 - have a update operators entry point that
442:40 - will update the list of addresses that
442:42 - are allowed to perform transfers for a
442:45 - given token the standard also defines
442:49 - some value that you should have in the
442:51 - storage of your contract called metadata
442:54 - and it should contain information about
442:56 - the contract following another standard
442:58 - called tzip 16 we won't go into the
443:01 - details of that standard there's also a
443:04 - number of optional mikas Sun storage
443:06 - views get balance total supply all
443:10 - tokens is operator and token meta data
443:13 - we provide pieces of code that you can
443:15 - execute offchain to obtain information
443:18 - stored in the contract but obtain them
443:21 - in a standard way so if we try to
443:23 - implement a very basic A2 contract in
443:26 - the storage we will need to store two
443:28 - things we will need to store the Ledger
443:31 - that keeps track of who owns Which
443:32 - tokens and what information there are
443:34 - about each token so we will store a big
443:37 - map the key will be the idea of the
443:39 - token and the value will be both the
443:41 - owner and the metadata if we don't have
443:44 - any quantity value then we will only be
443:48 - able to handle nft types of token then
443:52 - we need to store operators so that's who
443:55 - is allowed to interact with a given
443:58 - token we'll stall them in a big map and
444:00 - the key will be composed of the address
444:03 - of the owner who set this operator the
444:06 - address of the operator who is allowed
444:08 - to perform actions on that token and the
444:10 - idea of that token and that's it there's
444:13 - no value so the value will be unit so as
444:16 - long there's an entry in the operator's
444:19 - big map for a given owner operator and
444:22 - token idea that means this owner allows
444:24 - this operator to perform actions in its
444:27 - name for this token the balance of entry
444:30 - point takes as parameter two values a
444:34 - call back that will need to be called to
444:37 - provide the result and a list of
444:39 - requests where each request is a record
444:43 - with the owner and the token and it's
444:45 - basically asking for each of these
444:47 - records please give me how many of the
444:50 - token this user owns and then the
444:54 - balance off entry point is supposed to
444:56 - call the call back function passed as
444:59 - parameter and send it a corresponding
445:02 - list of results and it will do that by
445:04 - sending a list of Records where each
445:06 - record contains the content of the
445:09 - request again with the owner and the
445:11 - token ID and the balance for that
445:14 - particular token so it basically says
445:17 - this user owns this much of this token
445:21 - the transfer entry point is used to
445:23 - transfer tokens from one address to
445:25 - another its parameter is a list of
445:28 - batches of transfer
445:30 - and each batch represents the transfer
445:34 - of one or more tokens from a given owner
445:38 - so it will contain a field from that
445:40 - will represent the owner and a list of
445:43 - transfers where each transfer contains a
445:45 - token ID and a destination so basically
445:48 - each patch will say we transfer tokens
445:51 - from this owner this token ID we
445:54 - transfer this amount to that other
445:56 - person and we'll say that for this token
445:59 - idea we transfer this amount to this
446:02 - destination so when we execute it for
446:04 - each transfer we will check if the Coler
446:07 - is either the owner of that token ID or
446:10 - an operator for this owner and token ID
446:14 - here as we only want to transfer nfts
446:17 - we'll simply check if the amount is one
446:19 - so is this nft owned by this owner so we
446:23 - will check that the owner really owns
446:24 - this token ID then when we're done
446:27 - checking all this we can transfer the
446:29 - ownership of the token to the
446:31 - destination given in the parameter
446:34 - finally we have the update operator
446:36 - where we want to say okay either say
446:39 - that we allow this address to transfer
446:42 - tokens in our name or on the other hand
446:45 - we want to remove this operator from the
446:47 - list of operators for a given token so
446:50 - the parameter of this entry point is a
446:52 - list of updates where each update will
446:55 - say if it's an addition of operator for
446:59 - a token or if we're removing an operator
447:01 - for this token then we say uh who is the
447:04 - owner of the token what operator we want
447:07 - to add and what's the token idea that we
447:10 - are updating this operator for so for
447:13 - each update if it's of type ad operator
447:16 - we will add an entry in the operator's
447:18 - big map we talked about earlier and the
447:21 - entry will contain the owner of the
447:23 - token the operator we're adding and what
447:26 - token this is about and if it's soft
447:28 - type remove operator we simply remove
447:30 - the corresponding entry the errors that
447:33 - those entry point May emit are also
447:36 - standardized so there's a list of
447:38 - different errors but here are a few you
447:40 - can have the fa2 token undefined that's
447:43 - when we make a request about a token IDE
447:45 - that doesn't exist at all or we could
447:47 - have A2 insufficient balance if you try
447:50 - to transfer more tokens than the owner
447:52 - has let's take a look at a simplified
447:55 - fa2 contract so that you have some idea
447:58 - of how it works so here we Define a few
448:01 - types we Define a transaction type so a
448:05 - record that authenticates a destination
448:07 - address for a token ID and a given
448:10 - amount then we have the operator type to
448:13 - Define who is allowed to transfer tokens
448:16 - for a given owner so we specify the
448:19 - owner the address of the operator and
448:22 - what token idea we talking about you
448:24 - will notice that we'll specify a layout
448:26 - because this is a standard melon
448:28 - representation has to be a very specific
448:30 - way for this to fit the standard and the
448:33 - representation is that it should be
448:35 - organized as a right com so a pair where
448:39 - the owner is the first element and the
448:42 - second element is a pair containing the
448:44 - address of the operator and the token
448:47 - idea so we use do layout to specify that
448:50 - it should have exactly this structure
448:52 - then to manage operators we have a
448:54 - variant that can be either adding an
448:57 - operator in which case the value is are
448:59 - recorded with the OWN owner the operator
449:01 - and the token idea and then remove
449:03 - operator where the value is also of the
449:08 - same
449:09 - type then we have our contract we see
449:12 - that we store a big map of tokens and
449:14 - next token ID it's started at once so
449:17 - every time we mint we will increment
449:18 - this value and add a new token in the
449:21 - Mig map in the mint entry point we
449:23 - simply take a metata that is a string
449:26 - and then we will create an empty set of
449:28 - operators that are allowed to transfer
449:31 - this token so it's a set of values where
449:34 - each value is operator type that we just
449:36 - Define with the owner operator and token
449:39 - ID then we create the nft itself that is
449:42 - a record with the owner the metadata and
449:45 - the set of operators and now we can
449:48 - increment next token idea so that the
449:50 - next token will have a different idea so
449:53 - we have the balance of entry point so
449:56 - that people can check how many tokens of
449:58 - a given ID I user has so the request is
450:02 - a list where each element is a record
450:05 - with the owner and the token idea so we
450:07 - basically asking how many of this token
450:09 - idea this owner has and we prepare a
450:12 - list for the results where we add for
450:14 - each request the corresponding answer we
450:17 - check that this token ID exist otherwise
450:20 - we have the standard error fa2 token
450:23 - undefined we fetch it from the big map
450:26 - we assume by default that the balance is
450:28 - zero but then if the token owner is the
450:32 - request owner then their balance is one
450:35 - so we add this information to the
450:38 - results so it's a list so we use sp.com
450:40 - to add to the result list a record where
450:43 - we specify the request again and the
450:46 - balance that this owner owns for this
450:49 - token idea so one if he owns it zero if
450:52 - he doesn't finally we send the result
450:55 - back by using this call back and doing
450:57 - an interc contract call where we send
451:00 - this result and zero test to that call
451:03 - back we then have our update operator
451:05 - entry point with a list of actions and
451:08 - each action is either variant add
451:10 - operator or remove operator if it is ADD
451:14 - operator we unwrap the information from
451:16 - the variant to get the data we cast it
451:19 - as operator type to make sure we are
451:21 - compatible with the standard we fetch
451:24 - the token corresponding to the Token ID
451:27 - that's in the operator data we check the
451:30 - that the owner of the token is the user
451:33 - who's trying to update the operators for
451:35 - that token we also check that we are
451:38 - setting the operator for this owner so
451:40 - the sender is the owner in the operator
451:44 - data and if that's all good then we add
451:48 - this operator data to that token so we
451:50 - say yes the operator address that's
451:53 - defin in operator data is allowed to
451:56 - make transfers for the token idea in the
451:59 - name of this owner if the type of the
452:02 - variant is remove operator then we do
452:05 - something similar except this time we
452:07 - remove it from the set of
452:10 - operators finally we have the transfer
452:12 - entry point where we take transfers a
452:15 - list of transfer as parameters and each
452:18 - transfer contains a list of transactions
452:21 - of type transaction type we check that
452:23 - we trying to transfer one of this nft
452:27 - because it's an nft you can only have
452:29 - one we check that the owner of the nft
452:32 - is indeed who we're trying to transfer
452:35 - from so that the transfer is valid we
452:37 - fetch that token and then we create the
452:41 - operator that indicates that we are
452:44 - looking for an operator for this owner
452:46 - the operator is a sender and we
452:49 - manipulate this token idea so we want to
452:51 - check if this user is an operator in the
452:56 - name of the owner to do transfers for
452:59 - this token ID here so if it is if there
453:01 - is such an operator in our set of
453:03 - operators for this token then we
453:06 - transfer the ownership of that token
453:08 - idea to this address and that's about
453:11 - all we have to do for a simplified A2
453:14 - contract then we have a Marketplace
453:16 - contract that will interact with this
453:18 - fa2 contract it needs to store the
453:20 - address of the corresponding token
453:23 - contract and it will have a big map of
453:26 - offers every time we make an offer we
453:28 - increment this offer ID so when somebody
453:31 - makes a new offer we say I want to make
453:33 - an offer for this token at this price in
453:36 - the sense that I'm willing to sell this
453:39 - token at this price here we don't check
453:43 - that the seller actually owns that token
453:45 - we will check it when we do the transfer
453:48 - in the buy entry point and in the buy
453:50 - entry point so someone a buyer will call
453:53 - this buy entry point and say I accept
453:55 - this offer so we fetch the offer we
453:57 - check that the buyer pays the amount
453:59 - specified in the offer then we obtain
454:02 - the token contract based on this address
454:06 - we provide the type of the transfer
454:08 - entry point to obtain the address of the
454:12 - transfer entry point then we prepare the
454:15 - parameter so we create a transaction
454:18 - that is a record with the sender so
454:21 - that's the destination so the color to
454:23 - whom we will transfer the nft here is
454:26 - the token idea of the nft and here is
454:28 - the amount of the that nftd that they
454:30 - want to transfer we make sure it's of
454:33 - the right type transaction type and then
454:36 - we call the transfer entry point passing
454:38 - a list of transfers where each transfer
454:42 - is from the seller from the address of
454:44 - the seller and we have a list of
454:47 - transactions with only one transaction
454:49 - which is what we just created here so
454:51 - the marketplace says I want to transfer
454:54 - this token that is supposed to be owned
454:57 - by the seller and I want transfer it to
455:00 - the caller the buyer and the amount is
455:03 - one token so when I ask the transfer the
455:07 - token will verify that I'm allowed to
455:09 - the marketplace is an operator for this
455:13 - owner and this token idea we will of
455:17 - course check that the seller is the
455:18 - owner of the nft and if it is we will
455:21 - change the ownership and then I send the
455:25 - price to the
455:26 - seller and here we have a test where
455:29 - where we create a few accounts we create
455:32 - The Ledger itself we create the
455:34 - marketplace we main nft the owner of
455:37 - that NF Alice creates an offer to sell
455:41 - her token for tentes then we add an
455:44 - operator to say that the marketplace
455:47 - should be an operator for Alis for the
455:50 - token id1 so we add an operator and then
455:55 - we tested by having Bob try to purchase
455:58 - the token for 10 is so if we give it a
456:01 - try it all works so this should give you
456:04 - an idea of what an fa2 contract is and
456:07 - what a contract that interacts with it
456:09 - is so here we use the standard for the
456:12 - marketplace to interact with the token
456:15 - and it should be able to interact with
456:17 - other tokens that are also compatible
456:19 - with the fa2 standard in this module you
456:22 - will learn how to develop oracles a
456:25 - special type of smart contract that
456:27 - allows all the contract to obtain
456:31 - information from the offchain world and
456:34 - we will see that this makes many type of
456:36 - applications possible many smart
456:38 - contracts need to access offchain data
456:41 - for example if you want to create an
456:43 - insurance contract that can insure an
456:46 - event against some heavy rain then the
456:49 - insurance contract will need to access
456:52 - to weather data to decide if there was
456:55 - Indeed heavy rain during your event so
456:57 - you should be reimbursed for the Cor
456:59 - Corr responding loss or you could have
457:01 - decentralized Finance contract that need
457:04 - to access exchange rates for example
457:07 - some contract may need to determine what
457:09 - the exchange rate between the US dollar
457:12 - and the euro is to take some other
457:14 - decisions or you could create supply
457:17 - chain contracts that track shipments and
457:20 - may need to access to the current
457:23 - location of a ship in order to assess
457:26 - the current situation of the stock for
457:28 - example
457:30 - or you could imagine that some contracts
457:32 - may require some heavy computations that
457:35 - cannot reasonably be done on chain and
457:38 - so those could be done offchain with the
457:40 - help of an
457:41 - oracle now if we want to access offchain
457:44 - data could we simply call the API of
457:48 - some oft service for a smart contract
457:51 - when we need the data what issues do you
457:54 - think this could cause pause the video
457:56 - and think about it for a minute so if
457:59 - you tried to call a rest API directly
458:02 - from a contract assuming this was
458:04 - possible it really wouldn't work at all
458:07 - you would have three types of issues you
458:10 - would have consistency issues when you
458:14 - execute a smart contract the result has
458:17 - to be the same on every single node but
458:20 - if you use a rest Epi you have no
458:22 - guarantee that this rest API will always
458:25 - give the exact same answer every time
458:27 - you call it so when each of the the
458:29 - nodes of the network would call this
458:32 - rest API then some of the nodes may get
458:34 - a different answer from other nodes and
458:36 - that would create a mess then you have
458:39 - performance issues if the smart contract
458:41 - has to wait for the response from AR
458:43 - rest API that means pausing the
458:46 - execution of all the transactions in the
458:48 - current block and you need everything to
458:51 - be done in a specific order specified by
458:54 - the sequence of transactions in Block so
458:57 - while you wait you don't do anything SO
458:59 - waiting for AR rest API within a
459:01 - contract will slow down the execution of
459:03 - each block
459:05 - considerably finally there are
459:06 - reliability issues the execution of a
459:09 - smart contract needs to always work no
459:12 - matter what this includes running the
459:15 - contract weeks or years later when you
459:19 - want to reexecute all the transactions
459:21 - from Genesis for
459:23 - example so the execution of a smart
459:26 - contract and the result can't depend on
459:29 - the availability of some external
459:31 - service at the moment of the execution
459:34 - of the contract now can you think of a
459:37 - way to obtain this data without being
459:41 - confronted with those three
459:42 - issues pause the video and think about
459:45 - it so one solution is to pay for an
459:49 - offchain service to fetch the data from
459:52 - the original source of data and then
459:55 - call your contract with this data as a
459:58 - parameter
460:00 - so instead of pulling the data from the
460:02 - smart contract you push it from an
460:04 - offchain Source doing that solves all
460:07 - three issues it solves the consistency
460:10 - issue because once you created the
460:12 - transaction with the data as a parameter
460:15 - and injected into a block every node
460:17 - will get the same transaction therefore
460:19 - we'll get the same data it also solves
460:22 - the performance issue because when you
460:25 - execute the contract the data is
460:26 - immediately available to the node they
460:28 - are just part the parameters of the
460:30 - transaction so it doesn't need to wait
460:32 - for anything to execute the contract
460:33 - once it's in the block everything is
460:35 - available finally it solves the
460:38 - reliability issues because we can rely
460:41 - on the resilient architecture of a
460:43 - decentralized blockchain once data is in
460:45 - the Block it's available to all the
460:47 - nodes very quickly but we're not really
460:50 - solving the problem here we are just
460:52 - moving the problem somewhere else can
460:55 - you think of what could go wrong with
460:58 - this approach pause the video and think
461:00 - about it so the issue is that if you
461:02 - rely on an off service to send the data
461:05 - to the contract you lose the benefits of
461:08 - the
461:09 - centralization you lose the reliability
461:12 - aspect of the centralization because the
461:14 - offchain servers that you rely on could
461:16 - simply stop sending the data to your
461:18 - contract and your contract would just
461:20 - stop
461:21 - working you also lose the trust aspect
461:24 - because you have to trust that the
461:26 - offchain service will send correct data
461:28 - to you your contract whoever is in
461:31 - control of it could cheat and make it
461:33 - send invalid data and and make it take
461:35 - all kinds of wrong
461:37 - decisions finally it wouldn't solve the
461:40 - censorship issue because the offchain
461:42 - service could decide to refuse to send
461:44 - some of the data based on all kinds of
461:47 - different criteria including refusing to
461:49 - send some data that wouldn't be
461:51 - beneficial to whoever is in charge of
461:54 - that service so you could say okay if I
461:56 - cannot trust some off server to send me
461:59 - the data what about if I run my own
462:02 - service to fetch data from the original
462:04 - source and then send it to my contract
462:07 - would it solve all these issues I
462:09 - wouldn't need to trust some offchain
462:11 - service I would just run it by myself so
462:13 - pause the video and think about what
462:14 - issues this could
462:16 - create so the idea is that if you run
462:19 - your own offchain servers to provide
462:21 - data to your contract then yes you can
462:24 - trust yourself but you move the problem
462:27 - again cuz
462:29 - the whole point of a smart contract and
462:32 - of a blockchain is that users of the
462:34 - smart contract don't need to trust a
462:36 - third party so here instead of trusting
462:39 - this offchain service that some other
462:42 - party runs they will need to trust you
462:45 - the author of the contract to keep
462:47 - running your own
462:49 - service and so the problem is they
462:51 - cannot be certain that you will always
462:53 - keep your service running they also
462:55 - cannot be certain that you want change
462:57 - the data yourself before before sending
462:59 - it they really have to trust you and
463:02 - that's what we want to avoid to need
463:04 - when we use a blockchain so even the
463:07 - owners of a contract shouldn't need to
463:09 - be trusted once the contract is deployed
463:13 - so this approach may still be used if
463:15 - you are the original source of the data
463:17 - anyway and so you need to be trusted no
463:20 - matter what then you should directly
463:22 - inject the data in smart contracts
463:25 - sometimes the application makes it so
463:27 - that we have to trust you anyway at
463:30 - least for that part another idea if
463:32 - you're not the original source of the
463:34 - data itself is to have this original
463:37 - Source send the data instead of you
463:39 - going to fetch it and then provide it to
463:41 - the contract you could try to convince
463:44 - the original source of the data to
463:46 - directly call your
463:47 - contract then your contract could simply
463:50 - verify that the caller who's sending the
463:52 - data is indeed this official Source you
463:55 - could check the address the issue is
463:57 - that convincing official source process
463:59 - of data to call many contracts on many
464:01 - blockchains is unrealistic so for
464:04 - example if you imagine that we are
464:06 - interested in the weather data and we
464:09 - want to convince the weather agency to
464:12 - call your smart contract and send
464:14 - today's weather to your contract it's
464:17 - going to be quite hard to convince them
464:19 - to do so they probably don't worry much
464:21 - about blockchains at the moment so
464:23 - instead of having those sources try to
464:25 - call every contract that is interested
464:28 - in weather
464:29 - we could simplify things for them and
464:32 - have a single contract on the blockchain
464:34 - that is dedicated to receiving data from
464:37 - this source and this type of contract
464:40 - that centralizes all the data from a
464:43 - given type and makes it available to
464:45 - other contracts is what we call an
464:48 - oracle that's a contract that collects
464:50 - offchain data one way or another and
464:53 - makes it available for all the
464:55 - contracts but still even convincing this
464:59 - uh Weather Service to send its data to a
465:03 - single Oracle contract is not easy at
465:06 - all most potential sources of data are
465:09 - not involved in blockchains at all at
465:11 - least not yet so we can't really expect
465:13 - them to call oracles themselves before
465:16 - we continue I really want to bring your
465:20 - attention to the fact that incentives
465:23 - for people to inject false data into an
465:25 - oracle can be very strong because when
465:28 - you get incorrect data from an oracle
465:30 - your contract can make really bad
465:33 - decisions so for example if you have a
465:36 - contract that relies on knowing the
465:38 - exchange rate between two currencies but
465:41 - obtains the wrong exchange rate then it
465:43 - can make a terrible decision that could
465:45 - lose millions of dollars so it can be
465:48 - very profitable for an attacker to cause
465:51 - an oracle to return an invalid value if
465:55 - you check the news about blockchains and
465:58 - about attacks and millions that are
466:00 - being lost many times those millions are
466:02 - lost because of exploits related to
466:05 - oracles where the value provided by the
466:07 - Oracle is manipulated and as a result
466:10 - Millions were lost or stolen here I
466:13 - listed a few example just within a
466:16 - window of a few months where several
466:18 - millions of dollars were lost due to
466:20 - Oracle manipulations so it's really
466:23 - important to have ways to obtain
466:25 - accurate data from the offchain world so
466:28 - if we can't come convince official
466:29 - sources to send their data to many
466:32 - different blockchains and their
466:34 - oracles something that's a bit easier to
466:37 - convince them to do is to have these
466:39 - original data sources published signed
466:43 - versions of their data so instead of
466:45 - Simply publishing on an API here is the
466:48 - weather today in this city we would just
466:51 - ask them to add a signature to that
466:54 - message then we could run a service that
466:57 - would fetch this data an offchain
466:59 - service and I would send it to the
467:02 - Oracle contract and the Oracle contract
467:05 - could then verify the signature and
467:07 - therefore check the data indeed comes
467:10 - from the original data source doing this
467:13 - has multiple advantages whoever takes
467:16 - the data from the original Source API
467:19 - and then sends it to the arle by calling
467:23 - a entry point of the Oracle we will call
467:26 - them an intermediate they can't temper
467:29 - with the data because if they change the
467:32 - data the signature will be invalid and
467:34 - they can't sign themselves because the
467:36 - signature has to be done with the
467:38 - private key of the original source so we
467:42 - don't actually need to trust whoever is
467:45 - taking care of transferring the data
467:46 - from the official source to the Oracle
467:49 - because they have no way to change that
467:51 - data it's also quite reliable because
467:55 - you don't have to trust that some
467:56 - intermediate will do their job you can
467:59 - rely on multiple people to do it anyone
468:02 - can run their version of that service to
468:04 - increase reliability and go themselves
468:07 - call this API fetch design data and call
468:10 - the Oracle to make it available on chain
468:13 - of course this still assumes that the
468:16 - original Source will keep publishing
468:18 - correct signed data they stop doing it
468:20 - then your Oracle will stop working this
468:22 - kind of approach that relies on sources
468:25 - publishing signed data is used on tesos
468:28 - by what we call Harbinger oracles and
468:31 - the typical source of such data is
468:33 - coinbase where we can find exchange
468:36 - rates between different currency pairs
468:38 - okay let's work on an exercise where we
468:40 - have a contract that will use an
468:43 - oracle so we created a contract called
468:46 - binary bets that lets user bet on the
468:49 - outcome of sport matches and to keep
468:52 - Simple we will assume the following
468:56 - we'll assume that every game is
468:58 - identified by a unique value that we
469:00 - will call game ID again to keep it
469:03 - simple we will assume that the game only
469:05 - has two possible odomes true or false
469:09 - true may be that the first player won
469:11 - and false means the first player lost
469:13 - and therefore the second player one and
469:16 - we also assume that there is an official
469:17 - Sports Federation that publishes the
469:20 - signed result of every game and that we
469:23 - can trust so for the exercise we
469:25 - prepared most of the code of this simple
469:28 - binary bets contract and your job is to
469:31 - write the code of an Oracle and change
469:33 - the binary bets contract so that it
469:36 - calls this Oracle to obtain the outcomes
469:39 - of the sport matches and then reward the
469:41 - winner of the bets let's take a look at
469:44 - the
469:44 - code so here we have this binary bets
469:48 - contract that will store a big map of
469:50 - Bets with the usual next bet ID that we
469:53 - increment every time someone bets then
469:55 - we have the Oracle address and we have
469:59 - the fee that we need to pay the Oracle
470:02 - to obtain the result oracles are servers
470:05 - that want to make money so they may Char
470:07 - a fee when you request some
470:10 - information then users can call the
470:13 - create bet entry point to make a bet and
470:16 - propose a bet to someone on a given
470:19 - unique game ID and they say I bet that
470:22 - the result will be this so again to
470:24 - simplify we say the result will either
470:26 - be true or false so I bet that the
470:28 - result would be this and we set a
470:31 - deadline we say okay the result should
470:33 - be determined before this deadline if
470:36 - it's not then that means we couldn't get
470:37 - the data so we cancel the bet so we
470:41 - simply
470:42 - create an entry in the bets big
470:46 - map we say whoever called this entry
470:50 - point is player one we don't know player
470:52 - two yet so we just store the smart
470:55 - contract address in player two as a way
470:58 - to indicate there is no player to it's
471:00 - easier to do than using options and
471:02 - setting none but using options would be
471:04 - another possibility we store the game
471:07 - Ida we say how much we want to bet so we
471:09 - send that money to say I bet 10 T this
471:13 - team will win and we store of course the
471:15 - expected result the deadline and we say
471:18 - this has not been
471:20 - cancelled then another player could say
471:23 - I accept this bet so they provide the
471:26 - idea of that bet and then we fetch bet
471:29 - we check that the amount they provide is
471:31 - the amount that the other person bet
471:33 - plus the fee for the Oracle so here
471:35 - whoever accept bet is in charge of
471:38 - paying the fee to the Oracle person who
471:40 - creates the BET has a small Advantage we
471:43 - check that nobody else already accepted
471:45 - bet so player two is still the address
471:48 - of the contract itself and we check that
471:50 - the BET has not been cancelled we store
471:54 - the address of player 2 and we store the
471:57 - bed and here since we just accepted the
472:01 - BET here we create a request on the orle
472:03 - to say please send me the result of the
472:06 - game that we bet on and do so before the
472:10 - deadline that the user set so this part
472:13 - of the code is for you to
472:16 - write then we have uh withdrawal entry
472:20 - point that's when something wants to get
472:22 - our money back because the BET was
472:25 - cancelled so here we get the BET which
472:28 - check what amount we should be paid back
472:31 - if we are the player one then we can
472:34 - withdraw the funds either because the
472:36 - BET has been cancelled or because nobody
472:40 - else has accepted the BET yet so in this
472:42 - case we replace player one with self
472:44 - address to make sure that player one
472:46 - cannot call this a second time and be
472:49 - reimbursed twice then we make sure it's
472:52 - set as cancelled and then we send the
472:54 - amount to whoever was calling if the
472:57 - caller is not player one then we make
473:00 - sure it's player two otherwise they have
473:02 - no reason to call this entry point we
473:05 - check that it has been cancelled and
473:08 - then we delete Player Two by saying okay
473:11 - the address is now the address of the
473:13 - contract so it's not a real user and we
473:16 - add to the amount the Oracle fee that
473:19 - player two has paid and then we do the
473:23 - same so the way it could be cancelled is
473:26 - if somebody calls cancel after a
473:28 - deadline for a given
473:30 - bit and here basically the idea is to
473:34 - say if the Oracle didn't provide the
473:37 - result before the deadline that we set
473:40 - then the beted can be cancelled so here
473:42 - your work is to call the erle and get
473:46 - information about whether the result was
473:49 - provided or not to the Oracle and if not
473:53 - then that means people can be reimbursed
473:55 - so the bet is cancelled
474:00 - finally when someone has won the bet
474:04 - they can call claim prize to get their
474:06 - funds so here we check that the BET
474:09 - hasn't been cancelled then we get the
474:11 - result from the
474:13 - Oracle this should only be called once
474:15 - the Oracle has the result we can check
474:17 - that off chain before we make the call
474:21 - if the caller is player one then we
474:23 - check okay did they win is the result
474:26 - what they expected the result would be
474:29 - and if it's not player one then we make
474:32 - sure it's player two and if it is we
474:35 - make sure that the result is not what
474:38 - the first player expected it to be so if
474:41 - we don't fail that means the caller has
474:45 - one so we send them the amount of the
474:47 - BET times two and then we delete the bet
474:51 - so that they cannot claim the price a
474:53 - second time and we need the default
474:55 - entry point because in case everything
474:58 - is cancelled we need here the Oracle to
475:01 - reimburses and the way they reimburses
475:04 - is by simply sending the fee back to
475:06 - this contract through the default entry
475:07 - point so we should have a default entry
475:10 - point to be able to receive the
475:12 - test and here we have started trading
475:16 - the Oracle contract and it's going to be
475:18 - for you to implement it but all you know
475:21 - is that the Constructor takes an admin
475:24 - and then the public key of the source
475:26 - from which you will get the
475:30 - data and so the idea is that when you
475:32 - get data from The Source you will verify
475:36 - that it contains a signature that
475:38 - matches this public key we can now take
475:41 - a look at the
475:42 - test so here we have created three usual
475:46 - accounts and a special account that we
475:48 - call data source that will be the
475:50 - account that won't be an account that
475:52 - directly interacts with the blockchain
475:54 - but that will be the account whose key
475:56 - is used to sign the data
475:59 - so we first create our Oracle so you
476:01 - provide the address of the admin Alice
476:04 - and then the public key of the data
476:06 - source so that we can use it to verify
476:08 - signatures then we create the Ping
476:10 - contract and we say the fee for the
476:12 - Oracle is two
476:14 - TZ then we have a first test where
476:17 - everything goes as planned so we have
476:21 - Alice create a bet on game with ID one
476:25 - she expects the result to be true and
476:27 - she says okay the result should come
476:30 - before this deadline and she bets five T
476:34 - then Bob first tries to accept the bet
476:37 - but by paying only five Tes so this
476:39 - should not be good because Bob needs to
476:42 - pay for the Oracle fee which he does in
476:45 - the next attempt paying seven test then
476:48 - Alice tries to claim the prize before
476:51 - the Oracle even got the result so this
476:53 - should not work so here you will add the
476:56 - part where you send the assigned result
476:59 - to the Oracle that the Oracle will
477:01 - verify after the Oracle got the result
477:04 - Bob will try to claim the price but Bob
477:08 - actually lost because you sent true and
477:10 - Alice bet that the result was true so
477:12 - Bob lost but then Alice one so she can
477:15 - claim the price and this should work
477:18 - then we have a second test case where
477:20 - this time we cancel after the deadline
477:23 - so in this case the orod never obtains
477:26 - data so as soon as the deadline passed
477:28 - test at 1,1 we cancel and everybody
477:32 - should be able to get their money
477:35 - back and finally we have another one
477:38 - where this time Bob
477:40 - wins so your job is to complete this
477:45 - contract by writing the code for the
477:47 - eracle writing all the different calls
477:50 - and completing the test to send sign
477:52 - data to the
477:55 - Oracle and check that everything works
477:59 - pause the video and give it a
478:02 - try let's look at a solution so we will
478:06 - first start by looking at the Oracle
478:09 - contract in the Constructor we store the
478:12 - admin and the public key but we also
478:15 - create a big map of requests that the
478:17 - Oracle will receive and we also store
478:21 - the fee there will be two test when a
478:24 - user requests the result for a given
478:26 - game they need to pass
478:28 - a bet idea so that we can identify their
478:32 - request using their bet idea for a given
478:35 - color we'll see that in a minute and
478:38 - then of course they need to say for
478:40 - which game ID they request the
478:43 - result and what's the deadline for the
478:45 - Oracle to provide this result we
478:48 - indicate that bet ID and game ID are
478:50 - Naturals and deadline is a Tim stamp we
478:54 - check that they paid the fee and we will
478:57 - create an entry with the key being the
479:00 - BET ID and the address of the caller
479:03 - because multiple contracts may call this
479:06 - Oracle and each contract uses its own
479:09 - system of ideas for their bet but for
479:12 - this contract we have a unique bet ID
479:15 - that identifies this request we check
479:19 - that this is not already an entry for
479:22 - this bedge from that contract otherwise
479:24 - they may overwrite a previous request
479:27 - and M things up and then we create the
479:29 - entry where we store that for this bet
479:33 - ID and this sender this is the game idea
479:36 - that they request information for this
479:38 - is the deadline and we set a result that
479:43 - is an option that we initially set at
479:45 - none to indicate that we didn't receive
479:47 - the result
479:50 - yet when we do receive the result some
479:53 - servers will be constantly looking from
479:56 - offchain at what request
479:58 - the Oracle has received and when it sees
480:01 - a new request it will go fetch the data
480:04 - from the original Source the sign data
480:07 - and then send the result of that request
480:10 - to this entry point so when they do that
480:13 - they know all the information about the
480:15 - bet so they can provide the BET idea
480:16 - they can say which contract was doing
480:19 - this request so that we can rebuild the
480:22 - key for that request and they send the
480:25 - message that will contain the result
480:28 - plus the signature associated with that
480:32 - message the message itself will contain
480:35 - the game ID and the result if you only
480:38 - sent the signed result but without
480:41 - saying which game this is then the same
480:44 - result could be used for many games and
480:47 - so people could cheat it's really
480:49 - important to have all the information in
480:51 - the message so that the message is the
480:53 - proof that the source that signed this
480:55 - message claims that the result for this
480:58 - game is this result so after getting the
481:03 - key we fetch the request from our
481:06 - requests big map we check that the game
481:09 - for this request is indeed the game
481:12 - indicated in the message and then we
481:14 - check that the signature that we've
481:16 - received corresponds to this public key
481:20 - signing this message that we pack when
481:24 - we check a signature it has to be a
481:26 - sequence of bytes that we check so we
481:28 - need to pack the message before we sign
481:30 - it and before we verify its
481:32 - signature then we can store the result
481:35 - and we have to store it as an option so
481:37 - we store the result as an option on the
481:40 - result that was in the message finally
481:43 - since we did our job we received the
481:46 - result before the deadline then we can
481:48 - send the fee to the
481:50 - admin actually here we need to
481:53 - check that we didn't already get the
481:56 - results so we need to assert
482:02 - but it was
482:05 - none otherwise we could send the result
482:07 - multiple times and get the fee multiple
482:11 - times the Oracle will have an unchain
482:13 - view so that the contract can
482:16 - immediately fetch the result it will
482:18 - simply pass the key and it will return
482:20 - the result for this
482:22 - key and finally if the contract didn't
482:26 - get the result before the deadline they
482:28 - can call cancer after deadline to get
482:31 - their fee back because the Oracle didn't
482:33 - perform their service so they shouldn't
482:35 - get paid so we say for which bet ID we
482:39 - didn't get the result we fetched the
482:41 - corresponding request we checked yes
482:44 - indeed the deadline is passed we check
482:46 - that the result is still none so the
482:48 - actual result of the game has not been
482:50 - provided then we send the feedback and
482:54 - to make sure somebody cannot cancel
482:56 - twice we Del
483:01 - delete this
483:04 - request so another we have an oracle
483:07 - where we can make requests receive the
483:11 - results signed by the
483:13 - source obtain the result from the
483:16 - contract and cancel the request and get
483:19 - the
483:20 - feedback if nobody sent the
483:26 - results so in our betting contract when
483:29 - we accept the BET then we call the
483:31 - request game entry point from the error
483:34 - call we pass the best idea the game idea
483:37 - the deadline and we make the
483:40 - call when we want to cancel after the
483:43 - deadline similarly here we call the
483:46 - cancel of the deadline entry point here
483:49 - but we do that after verifying through
483:52 - the get game result view that the result
483:56 - has not been provided for the the result
483:58 - is
484:00 - none finally when we claim the prize we
484:03 - call the get game result view to obtain
484:07 - the result we unwrap it and then we
484:11 - award the player if this player has one
484:13 - based on the
484:16 - result in the test here we send the
484:20 - result to the eror call so we prepare a
484:23 - message that contains a game ID and the
484:26 - result we sign that message with the
484:28 - private key of the data source so of
484:31 - course this in practice would happen in
484:34 - some service of chain that sees the
484:37 - request and then calls the smart
484:40 - contract and here we call the receive
484:43 - result entry point we say for which P it
484:46 - is we say for which contract we send the
484:49 - message and the corresponding
484:51 - signature and we do the same here with
484:54 - the version that shouldn't work let's
484:57 - give it try
484:59 - try everything
485:01 - works and we can let you play with the
485:03 - code and
485:06 - check that everything works as
485:09 - expected the Oracle was presented was a
485:12 - very simple Harbinger type of
485:15 - Oracle but it relied on a single source
485:19 - which means we have to trust that
485:21 - source and a lot of cases we really
485:24 - don't want to trust a single Source
485:26 - because a source of data could simply
485:29 - avoid publishing data that doesn't
485:31 - benefit them and similarly if we rely on
485:34 - a single transmitter this single
485:36 - transmitter could avoid transmitting
485:39 - data that doesn't benefit them in some
485:40 - cases when it's about data that changes
485:42 - on a very freaking basis maybe the
485:46 - source of the data or the transmitter
485:48 - could decide to only publish or transmit
485:51 - the values that benefit them and skip
485:52 - the ones that don't benefit them when
485:55 - the value of a token for example goes up
485:57 - and down with time and preventing this
486:00 - behavior from a single Source or a
486:02 - single transmitter is really hard
486:04 - finally if you rely on a single source
486:07 - of or on a single transmitter this
486:09 - causes reliability issues if this source
486:12 - of this transmitter stop doing their job
486:16 - so what we want to do in practice to
486:19 - avoid especially relying on a single
486:21 - source is to combine multiple sources of
486:24 - data so we can fetch data for multiple
486:28 - sources one available if there are
486:31 - multiple sources for example for the
486:32 - weather there may be different agencies
486:34 - that publish information about the
486:36 - weather or for the exchange rate between
486:40 - the US dollar and the Euro you can
486:43 - expect a lot of places to be able to
486:45 - provide that information
486:47 - independently and you could also rely on
486:49 - multiple transmits to take care of
486:52 - sending this data to the Oracle so you
486:54 - should never rely on single transmitter
486:57 - and check the address anyone should be
486:59 - able to send this data the data is
487:01 - signed anyway so we don't need to trust
487:02 - the transmitters so we could have
487:04 - multiple transmitters running at any
487:06 - time and then the oracles that would get
487:09 - information for multiple sources would
487:11 - have to check that enough sources agree
487:14 - with the result and enough sources
487:16 - provided the result and if the set of
487:18 - different values we could take the
487:20 - median of the value as the actual value
487:23 - that the Oracle would return and if this
487:26 - is about a value that changes over time
487:28 - at high frequency such as an exchange
487:30 - rate we also want to average it over a
487:33 - short period of time so that we can
487:35 - avoid flukes like between two different
487:38 - calls it goes up down up so you want to
487:40 - average it over a period of time to to
487:42 - have a better estimate of what's the
487:44 - current value we won't go into detail of
487:47 - different ways to do that but some of
487:48 - the ways to do that include doing some
487:51 - of this work of chain so this idea of
487:53 - using messages that are signed by
487:55 - official sources is great but in
487:58 - practice unfortunately very few sources
488:00 - of data publish such sign data for
488:04 - blockchains for the moment but even if
488:07 - they didn't plan to publish signed data
488:10 - they actually do so for other reasons in
488:12 - particular when you access the website
488:15 - of a service or you access a rest API
488:19 - you usually do so through the https
488:22 - protocol but using
488:24 - https means that the data is encrypted
488:28 - using the private key of the domain's
488:31 - certificate so this means you can verify
488:34 - the authenticity of the data when you
488:36 - decrypt the data that the API returns
488:40 - through the public key of the
488:41 - certificate using
488:43 - SSL so this cannot really be done in a
488:46 - smart contract you cannot send the full
488:48 - https response to an Oracle and expect
488:51 - the Oracle to decrypt it so what we need
488:54 - is a service that we can trust and that
488:57 - will take care of doing this https
489:00 - request to the web page or the API of
489:03 - the original source that publishes the
489:04 - data then decrypt the https response
489:09 - extract the data you need from that
489:10 - response and then sign it and send it to
489:14 - an oracle so if we do trust the service
489:17 - that does that then everything is good
489:20 - of course the issue is how can we run a
489:22 - service off chain that does all that and
489:25 - that we can trust to have such a service
489:28 - we will need to set it up on an
489:30 - architecture that really guarantees that
489:32 - it Run unified code so you write the
489:34 - piece of code that does all that and you
489:36 - have to run it on Art architecture it
489:38 - will tell you yes this is the code what
489:41 - was actually executed and this service
489:44 - will fetch the data directly from a
489:46 - source using https request and then
489:49 - we'll call the Oracle contract with that
489:51 - data along with the proof that all the
489:55 - codee was executed and modified IED and
489:58 - all the Oracle would have to do is check
490:00 - that proof to verify that the service
490:03 - has not been tempered with and indeed
490:05 - the script that you wanted to execute is
490:08 - the one that was
490:09 - executed this is actually possible using
490:12 - what we call trusted execution
490:14 - environment or tees for short tees are
490:20 - architectures that guarantee that the
490:22 - software that is run by the service has
490:25 - not been modified and corresponds to a
490:28 - specific hash so you provide the code
490:30 - you compute its hash and the service
490:32 - will be able to provide a proof that the
490:35 - code that was run was the code that
490:37 - matches this hash and it can also
490:39 - guarantee that the SSL connection it
490:41 - used to fetch the data was secured and
490:44 - the data hasn't been tempered with there
490:47 - are a number of providers of trusted
490:48 - execution environments and this really
490:51 - means running some specific Hardware in
490:55 - a special mode that
490:57 - guarantees that nobody has tempered with
491:00 - the machine even the people who have
491:02 - physical access to the machine there are
491:05 - different solutions to do that but one
491:07 - of it is to use some Android phones that
491:11 - have the right Hardware to be able to
491:13 - provide this kind of security on tesos
491:16 - we can use the acurus service that
491:18 - specializes in using tees using Android
491:23 - and provides a service where we can set
491:25 - up this type of oracles BAS based on the
491:28 - safety net architecture you run your
491:30 - mobile phone in a special mode where you
491:32 - cannot do anything else all they can do
491:35 - is execute scripts in such a way that
491:37 - you cannot interfere with them if you
491:40 - want to learn more about oracles we
491:41 - invite you to check the indepth oracles
491:44 - article on
491:45 - open.com in this module and the next few
491:48 - ones you will learn how to detect flaws
491:50 - in smart contract and learn about best
491:53 - practices to avoid these flaws in your
491:56 - own smart contract
491:58 - the first flaw is related to the use of
492:00 - the sp. source
492:03 - command there are two ways in a smart
492:06 - contract to check who called the
492:08 - contract so far we have used sp. sender
492:12 - that gives you the address of the direct
492:14 - color of your contract but you can also
492:17 - use sp. source which gives the address
492:21 - of the user who is at the origin of the
492:24 - chain of calls of smart contracts so for
492:26 - example if a user a calls a contract B
492:30 - and that contract B then calls a
492:32 - contract C from within the contract c
492:35 - sp. cender will correspond to the
492:37 - address of B so the direct color of
492:40 - contract C but sp. Source will
492:43 - correspond to the address of a the user
492:46 - who is at the beginning of the chain of
492:47 - call so user a called contract B that
492:50 - called contract C but since a is the
492:53 - initial caller that's what you get when
492:55 - you use sp. Source but it's never a good
492:58 - idea to use sp. source and it may Ed for
493:02 - attack so I recommend for you never to
493:05 - use sp. source so for example if you
493:08 - look at this small smart contract can
493:11 - you find the flaw and how someone could
493:13 - take advantage of it so this is a
493:16 - contract for charity where people can
493:18 - deposit some funds using a deposit entri
493:21 - Point here and then the admin can decide
493:24 - to donate some of the funds that have
493:26 - been given to a specific charity so you
493:30 - say how much you send and to which
493:32 - charity so think about how someone could
493:35 - take advantage of a flaw in this
493:37 - contract related to the use of sp. sour
493:41 - pause the video and think about it for a
493:43 - minute so the issue is that an attacker
493:46 - could convince the admin of Charity fund
493:49 - to donate to a fake charity and could be
493:53 - a very small charity and could be just
493:55 - for a few test but when the charity fund
493:57 - donates to the fake charity transfer of
494:00 - TZ to this other contract would call the
494:03 - default entry point of that fake charity
494:06 - contract and that entry point could then
494:09 - call Charity fund. donate and by doing
494:12 - that impersonate the nmin so from the
494:15 - point of view of donate if we look at
494:16 - the code here we check that the original
494:19 - Coler is the nmin but if we call the
494:23 - fake charity from here then the fake
494:25 - charity calls donate again
494:27 - but with a different amount for the
494:29 - donation and with a different charity
494:31 - then they could trick the admin into
494:34 - donating all of the balance of the
494:36 - contract to some destination address the
494:40 - different steps would be that the admin
494:41 - calls charity fund. donate of one test
494:44 - to the fake charity then charity fund.
494:48 - donate would transfer some test to fake
494:50 - charity therefore calling the default
494:53 - entry point of fake charity and then
494:55 - this default entry point will would call
494:57 - Charity fund. donate let's say with a
494:59 - thousand T and with the destination
495:02 - being the attacker
495:04 - address and so charity fund. donate
495:07 - would check that SP source is indeed the
495:09 - admin and assume okay the source is the
495:12 - admin therefore it's the intention of
495:14 - the admin to do that transfer and then
495:16 - we transfer a thousand test to the
495:18 - attacker address so basically the admin
495:21 - thinks they're just donating one test to
495:23 - some contract but in practice a th000 as
495:27 - well be spent so this is very dangerous
495:30 - there is a very easy way to fix that
495:31 - flaw it's simply to avoid using sp.
495:34 - source and instead use sp. sender so to
495:37 - require the admin to make a direct call
495:40 - to char fund. donate and this way they
495:43 - cannot be tricked into doing something
495:45 - else more generally if a contract uses
495:48 - sp. source to identify who is calling
495:51 - the contract all he have to do is Trick
495:55 - the admin to call a small small smart
495:57 - contract you created that only requires
495:59 - a small amount to be transferred but
496:01 - then your smallart contract could do
496:03 - anything in the name of the admin with
496:06 - that contract that uses sp. source so
496:08 - make sure you simply avoid using sp.
496:11 - Source there's never any good reason to
496:13 - use it as far as I know here is the code
496:16 - of the fake Char ready contract it
496:18 - stores the address of the contract to
496:20 - attack so the charity fund stores the
496:23 - address of the attacker and then when
496:25 - it's default entry point is called here
496:28 - when the charity fund sends some test to
496:30 - it then it calls the Donate entry point
496:34 - of the charity font but with the
496:36 - donation of thousand t to the address of
496:39 - the attacker and that's it all you need
496:41 - to do then is convince the admin to
496:44 - donate one t from the contract to your
496:47 - fake
496:48 - charity you can give it a
496:51 - try and you see that
496:54 - indeed thousand T our trans to the
496:57 - attacker's
496:59 - address a second type of flaw that is
497:02 - extremely common so you should always be
497:05 - very careful is when using sp. send
497:09 - especially if it's a destination that is
497:11 - not the caller of the contract and even
497:14 - in some case when it is the color of the
497:16 - smart contract so you should be very
497:18 - careful when using esp. sent here is an
497:21 - example of a part of a contract that is
497:24 - likely to have this kind of flaw where
497:26 - we send 10 Tes to some address and then
497:30 - 10,000 Tes to you to the caller here
497:35 - some address could actually be the
497:36 - address of a smart contract that means
497:39 - when we call send to transfer 10 test to
497:42 - this address it calls the default entry
497:44 - point of that contract and that default
497:48 - entry point could fail and this would
497:50 - make the whole smart contract fail
497:52 - therefore it would prevent the transfer
497:55 - of 10,000 test to your address
497:57 - so you should always be careful whenever
497:59 - you send some test to some address you
498:02 - should think about what if this address
498:05 - is actually a smart contract that has a
498:07 - default entry point that rejects the
498:09 - funds so for example let's say the
498:11 - destination of this ver call is this
498:13 - contract we see that it has a default
498:16 - entry point that checks if the Boolean
498:19 - open is set to true so we initially set
498:22 - it to true but we have this set State
498:24 - entry point where the admin can set the
498:27 - state of the open value to true or false
498:32 - so this way you can control when you're
498:34 - allow to receive the funds and therefore
498:36 - control when this contract is going to
498:40 - fail or work so by using this contract
498:45 - you could block some user from getting
498:47 - their the money that is owed to them and
498:49 - then extort some extra money from them
498:52 - as a condition for you to enable the
498:54 - transfer of test your contract with
498:56 - changing the state of open so you can
498:58 - tell okay I know you have 10,000 test
499:01 - stuck in this contract I have the power
499:03 - to unlock it so give me a th T and I
499:07 - will unlock it for you so that's a way
499:08 - to extort
499:09 - funds so the best practice to avoid this
499:12 - kind of flaw is to always let users
499:15 - claim their own Tes through a separate
499:18 - claim entry point we have already seen
499:20 - that in the nft with royalties contract
499:23 - where we had this exact issue and
499:26 - allowing this claim entry point may
499:28 - require you to add a ledger to your
499:30 - contract if there are multiple users
499:31 - that may have Tes in the balance of the
499:33 - contract that need to claim so if you
499:36 - add a ledger a big map that for each
499:38 - user address keeps track of how much is
499:40 - owned to them by the contract then
499:43 - anytime you want to send some test to
499:45 - someone instead of doing the sp. send
499:48 - you simply add that value to their entry
499:51 - in The Ledger that's something we
499:53 - already did with a multiple nft with
499:55 - fixed contract that we all in another
499:57 - module another common flaw is related to
500:01 - unlimited computations and we talked
500:03 - about this already on tesos we have this
500:06 - notion of gas that is an estimate of the
500:09 - amount of CPU used by a transaction and
500:12 - when you emit this transaction you have
500:15 - to pay a fee that covers this gas but
500:19 - there is a limit to how much G you can
500:22 - spend in a single transaction there's
500:24 - also a limit to how much G you can spend
500:26 - spend in a given
500:28 - block but if a contract call exceeds
500:31 - that limit of how much gas you can spend
500:33 - in a transaction the call will fail and
500:37 - this may mean funds will get stuck in
500:39 - the contract so it is very important to
500:42 - make sure that the gas consumption of a
500:44 - contract can't grow indefinitely and
500:47 - exceed that amount to avoid this kind of
500:49 - flaw you have to avoid storing data that
500:52 - can grow indifferently because you have
500:55 - to remember that the store of a smart
500:57 - contract has to be deserialized at the
500:59 - beginning of every call to an entry
501:01 - point and has to be res serialized at
501:03 - the end of the entry point and this cost
501:05 - gas so you need to make sure that you
501:07 - check this whenever you use lists sets
501:10 - and maps and even basic types that can
501:13 - grow IND definently for example strings
501:15 - can be as long as you want or in nuts
501:17 - and Tim stamp in general the idea is to
501:21 - use big Maps whenever you want to store
501:23 - unlimited amount of data because you can
501:25 - have as many entries as you like in a
501:27 - big map you only pay for the
501:28 - distalization and calization whenever
501:31 - you access a specific entry of the big
501:34 - map but of course if that entry is too
501:37 - big then you still could spend too much
501:39 - to diser realize it so it doesn't
501:41 - guarantee that you won't have any issue
501:43 - so make sure you don't store too much in
501:45 - a single entry of a big map another
501:48 - option in some cases is to consider
501:50 - storing data off chain if you don't
501:52 - actually need the data on chain you
501:54 - don't need the smart contracts to have
501:56 - access to it you may store them off
501:58 - chain so for example you could store it
502:00 - on ipfs so the second part to avoid
502:04 - unlimited competions is to avoid Loops
502:06 - where the number of iterations of the
502:08 - loop can grow indefinitely and to avoid
502:11 - that you can usually do the computations
502:13 - off chain and let the contract focus on
502:16 - verifying that everything you computed
502:18 - is correct and when you cannot do the
502:20 - computation of chain another possibility
502:22 - is to split the computations into
502:24 - multiple contract calls so that in the
502:27 - first call you do part of the
502:29 - computation and then in the second call
502:32 - you can continue the computation that
502:33 - might be necessary the best option is to
502:36 - try to do the competitions of chain
502:38 - whenever you can for example let's take
502:41 - a look at this contract this contract
502:44 - called time save can store deposits that
502:48 - will be stored in the balance of the
502:49 - contract and can only be withdrawn by
502:52 - the owner after a certain deadline so
502:54 - whenever you deposit some money fall the
502:56 - owner you set a deadline and you say
502:58 - okay they will only be able to withdraw
503:00 - that amount after this deadline and here
503:04 - we add all the deposits in the list and
503:07 - whenever the user wants to withdraw we
503:10 - Loop through the list find out all the
503:13 - deposits that I have deadline that is
503:15 - expired and then count the corresponding
503:17 - amount and then transfer that amount to
503:20 - the owner so here we clearly have a data
503:24 - structure in the storage that can grow
503:27 - indefinitely someone could make very
503:29 - small donations and deposit many many
503:31 - different amounts but very tiny amounts
503:33 - like one MCR at a time so much so that
503:37 - the size of the list would be so big
503:39 - that diser realizing the data would take
503:42 - too long and exceed the maximum of guys
503:44 - you can spend in a transaction so here
503:46 - are the ideas that this list can grow
503:48 - indifferently nobody can control how
503:50 - much it can grow there are some ways to
503:54 - limit it you could just set a hard limit
503:56 - on how many deposits there can be at a
503:58 - given time and then delete the deposit
504:00 - when you withdraw the corresponding
504:02 - money or you could make it that deposit
504:05 - has to be at least 100 Tes so it would
504:07 - be extremely costly for someone to add
504:11 - so much to make so many deposits that
504:13 - the contract could get stuck but a
504:16 - better approach is to use a different
504:18 - data structure and use a big map here is
504:21 - a version of the contract that use a big
504:23 - map for the deposits we count how many
504:26 - deposits are been so that we can use
504:28 - this as a key for the big map with all
504:30 - the deposits and whenever somebody calls
504:32 - deposit we create an entry with the key
504:36 - being the current value of the counter
504:38 - and in this entry we record the center
504:42 - the deadline and the amount and this way
504:45 - each entry with all the entries in a big
504:47 - map the data structure can never be so
504:50 - big that just calling an entry point
504:52 - would distalize the whole thing and then
504:54 - exceed the maximum amount of gas you can
504:56 - spend in a transaction however we still
504:59 - have a loop here that goes through all
505:02 - the different elements of the big map by
505:04 - trying every possible counter and so in
505:07 - practice we still have to deserialize
505:09 - everything when we try to withdraw so we
505:12 - can of solve the problem for the deposit
505:14 - entry point that can never fail because
505:16 - it's not going to deize the whole
505:18 - content of the big map but then in
505:19 - withdraw we have a loop so the loop
505:21 - itself may have too many iterations and
505:23 - exceed the total amount of gas you can
505:25 - spend in a transaction
505:27 - but more so you will have to deserialize
505:30 - all of the content of the big map so
505:32 - that doesn't solve the problem to solve
505:35 - this problem instead of a loop that goes
505:38 - through all of the elements we can do
505:41 - the computation of chain of which
505:43 - entries have expired deadlines so
505:46 - instead of looping through every single
505:48 - entry in the big map and then checking
505:50 - if the deadline is expired we do that
505:53 - computation of chain and then when we
505:56 - call withdraw we send a list of keys
505:59 - where the deadlines have expired and so
506:02 - the loop here only enumerates all the
506:04 - entries that have been listed in the
506:07 - parameter it could still be possible
506:10 - that the list is so long that we cannot
506:12 - execute the whole Loop but then we can
506:15 - split the call into multiple calls and
506:17 - then maybe do only half of the list so
506:19 - that we only need to Loop through half
506:21 - of them and distalize half of the entry
506:24 - the caller has control over how many
506:26 - items they put in the list so in this
506:28 - case we are safe we avoided using the
506:31 - type of data structure that can go
506:33 - indefinitely by instead using a big map
506:36 - and we avoided doing a loop that can
506:38 - grow indefinitely and instead did the
506:41 - competition of chain and let the user
506:44 - send a list of items they get money from
506:47 - and that solves our problem in this
506:49 - module you will learn how you can reduce
506:52 - the amount of fees you need to pay when
506:55 - using a micro payments contract where
506:57 - you have to perform a lot of
506:59 - transactions to buy lowcost items so the
507:03 - challenge is to create a micro payments
507:05 - contract let's say a person a very often
507:09 - wants to buy cheap items from a seller B
507:13 - and wants to pay using TZ so we will
507:17 - have transactions where user a gives
507:20 - some amount of M to be a small amount
507:24 - compared to transaction fees
507:26 - and then B will give some item to a so a
507:30 - buys an item from B but at a very small
507:33 - price so the question is how can we do
507:36 - that in the cheapest possible way we
507:39 - don't want to have to pay a transaction
507:41 - fee for every purchase if the item is
507:44 - very cheap we might end up paying more
507:46 - inunction fees than what we actually
507:49 - need to pay for the item but we want to
507:52 - do that by still enjoying the security
507:55 - of the block blockchain we don't want B
507:57 - to have to trust a or a to have to trust
508:01 - B but we can allow for a little bit of
508:03 - risk so for example B could accept that
508:06 - maybe they will lose the amount for one
508:09 - sale but no more than one so B might
508:14 - accept that they will lose the price of
508:17 - one item purchased by a but no more than
508:19 - that so with this constraint try to
508:22 - think about a way you can reduce the
508:25 - transaction fees to the the minimum
508:27 - pause the video and think about it for a
508:29 - minute if we really want to avoid paying
508:31 - too many transaction fees the best way
508:33 - is to avoid doing transactions at least
508:36 - onchain every time you do an onchain
508:38 - transaction you need to pay a fee but we
508:40 - could handle most of these transactions
508:42 - of chain using signed messages the idea
508:47 - is that we would create a micro payment
508:49 - contract where user a will put some
508:53 - amount of test a deposit on the micro
508:55 - payment contract
508:56 - that it is reserved for A's future
508:59 - purchases from B so that amount is
509:02 - really strictly reserved for B and we
509:05 - set a deadline the idea is that a May
509:09 - withdraw those funds but only after that
509:11 - deadline so the idea is that b knows
509:15 - that there is some amount for them that
509:17 - will be available in the contract until
509:20 - that deadline once we have that deposit
509:23 - in the micro payment contract every time
509:25 - a wants to purchase an item from b
509:28 - instead of doing a transaction on the
509:30 - chain and calling the contract and
509:32 - paying the fee a will send a signed
509:35 - message to b so a message would say I
509:38 - hereby declare that I owe you this
509:40 - amount of money more precisely I can say
509:43 - the amount I owe you is now X
509:46 - mutes signed a and of course the
509:49 - signature will be a cryptographic
509:51 - signature that a smart contract could
509:53 - verify so this message is directly sent
509:56 - to be off chain without going through
509:59 - any smart contracts any way they could
510:01 - be by email could be any means and then
510:04 - once B receives that message they have a
510:07 - proof that a owes them money and so they
510:11 - can send the corresponding item to a
510:14 - whenever B wants to get paid whether
510:17 - it's because the deadline is getting
510:18 - closed so they want to make sure a
510:20 - doesn't withdraw the deposit from the
510:22 - contract or whether there's quite a bit
510:25 - of money or that they want to to have
510:28 - and they are ready to pay a transaction
510:29 - fee to get that money then B could call
510:33 - the macro payment contract and sendeth
510:36 - the last sign message signed by a that
510:40 - says I owe this mat to be the smart
510:44 - contract could then verify the signature
510:46 - and if the signature is valid then the
510:49 - contract could send whatever amount a
510:51 - owes to B so to do that we need to be
510:55 - able to sign and verify
510:58 - signatures on tesos you can sign any
511:02 - piece of data as long as it is in the
511:04 - form of a sequence of bytes that's the
511:07 - only type of data you can sign but
511:10 - thankfully we can convert pretty much
511:12 - any data to a sequence of bytes and back
511:15 - we can use the pack instruction to
511:17 - convert type data into a sequence of
511:20 - bytes and later we can unpack this
511:24 - content to extract the typed content so
511:27 - it could be a record for example we pack
511:29 - the record we just get a simple sequence
511:31 - of bytes then later on we can unpack it
511:34 - and get the record back once we have a
511:37 - sequence of bytes we can use a function
511:40 - called make signature to generate a
511:43 - signature for a given sequence of bite
511:47 - and of course we use a given private key
511:49 - to generate this signature on the other
511:52 - side the destination of the message can
511:54 - use check signature to verify the
511:56 - validity of a signature verify that it
511:59 - corresponds to the public key of whoever
512:02 - is sending it so let's look at the
512:04 - syntax to pack and unpack data it's
512:07 - pretty straightforward you can call sp.
512:10 - pack of your type data could be almost
512:13 - anything could be a number could be a
512:16 - record could be a list anything you
512:18 - liked and then you get a pack data that
512:20 - is of type B then you can unpack this
512:24 - data by calling sp.
512:27 - unpack you pass the data and then you
512:31 - pass the description of the type of this
512:33 - data this returns an option it could be
512:36 - done if it's impossible to unpack this
512:39 - data into this type it could be a
512:41 - different type so we use unwrap sum to
512:45 - get the original data back once we have
512:49 - packed data we can use make signature to
512:53 - create a corresponding signature
512:56 - and we pass the secret key of the user
513:00 - and the pack data and we obtain a
513:02 - signature when we want to check the
513:04 - signature we call sp. check signature we
513:08 - pass this time the public key of the
513:10 - user who is supposed to have signed this
513:13 - message we pass the signature and we
513:15 - pass the pack data so this verifies if
513:18 - the signature corresponds to this pack
513:21 - data signed by the person who has this
513:24 - public key we don't need the secret key
513:27 - to verify the signature and this returns
513:30 - true if this is indeed a signature that
513:33 - corresponds to this message and this
513:35 - public key with that your job is to
513:38 - write the corresponding contract with
513:41 - its tests the storage will simply need
513:44 - to contain a big map with all the
513:46 - deposits what is the key and the value
513:48 - for each entry is up to you and we will
513:51 - have three entry points one entry point
513:53 - for someone to deposit some funds for a
513:57 - given seller so we say who are these
513:59 - funds for we set a deadline after which
514:03 - we will be able to withdraw the money
514:05 - back and we send our public key so that
514:08 - we can sign messages and have the
514:09 - contract verified that they come from us
514:12 - so whatever amount is sent to deposit
514:14 - sp. amount will be stored as a deposit
514:18 - from the center to this destination so
514:21 - we create an entry in this big map or
514:23 - update it if there's already one when
514:25 - seller wants to get paid they can call
514:28 - claim payments they say I want to get
514:31 - some funds from this user and here is
514:34 - the message they last sent me and here
514:37 - is the corresponding signature so the
514:40 - contract will check that the signature
514:42 - is valid for this message so the
514:44 - signature is indeed a signature for this
514:47 - message using the public key we stored
514:50 - for this source so the public key we
514:52 - passed here once it checked that the to
514:56 - valid it can transfer the amount that
514:59 - the source owes to the caller and then
515:02 - it will update the corresponding deposit
515:05 - entry finally when a user wants to close
515:08 - their account and withdraw their Deposit
515:11 - they say I want to close my account that
515:13 - I have with this seller so we fetch the
515:15 - corresponding entry in the big map we
515:18 - check that the line has passed and we
515:20 - transfer any funds that haven't been
515:22 - withdrawn yet here we purposely left
515:25 - some details for you to work on so your
515:29 - goal is to implement this contract and
515:31 - try to make sure that there is no flaws
515:34 - that somebody could use to steal some
515:36 - funds or get funds stuck pause the video
515:38 - and give it a try let's look at a
515:40 - potential solution here in the deposit
515:43 - big map we will create entries where the
515:46 - key is composed of the source and the
515:49 - destination so a deposit is really some
515:51 - funds we store for our source and a
515:54 - destination so it makes sense to have an
515:55 - entry for each pair source of
515:57 - destination here we use the record we
515:59 - could also use a pair as a
516:01 - key then we check if there's already an
516:05 - entry and if not we create one we store
516:08 - the deadline the amount that was sent
516:10 - the public key and we also store how
516:13 - much has been spent so far out of this
516:17 - amount and if there is already an entry
516:19 - we verify that the new deadline is after
516:21 - the previous deadline we can only extend
516:23 - the deadline we cannot bring it closer
516:26 - to the present otherwise it would be too
516:28 - easy for a to get their money back even
516:31 - though be trusted that that money would
516:32 - be available in the contract so we can
516:35 - only extend the deadline and here we
516:38 - update the deadline and we add the newly
516:40 - deposited amount to the amount stored in
516:43 - the
516:44 - deposit once there is a deposit for some
516:48 - user reserved for Destination then this
516:51 - user and this destination this seller
516:54 - can freely exchange messages where a
516:57 - sends messages that says I now owe you
517:01 - this much and then B says okay then I
517:04 - can send you this item Etc and the
517:06 - amount a owes to be increases
517:09 - increases and when the deadline gets
517:11 - near or when the amount is quite a bit
517:13 - and B wants to get it out of the
517:15 - contract B can call claim payments they
517:19 - I want to claim the payments from this
517:20 - source and here's the last message that
517:23 - sent me this last IO you and here is the
517:27 - signature that proves that it comes from
517:29 - them so we get the key for the
517:32 - corresponding deposit then we check the
517:36 - signature so we check that this
517:38 - signature corresponds to this pack
517:40 - message with this public key so it has
517:41 - indeed been signed by the public key we
517:44 - stored for this user then we unpack the
517:48 - message and in the message we store the
517:52 - destination and how much the author of
517:56 - this message owes to this
517:59 - destination so the total they owe so far
518:02 - since the beginning which check that the
518:04 - destination is the person who's claiming
518:07 - the payment then we compute how much
518:10 - they need to pay to them now and that
518:12 - amount is the amount indicated in the
518:15 - message so how much I owe you so far
518:18 - minus how much we already sent them
518:21 - before so how much they already spent in
518:24 - the previous message
518:26 - so the idea is that a always increases
518:28 - the amount they o to B since the very
518:31 - beginning because if a sent I ow you 10
518:35 - more tests than last time we would need
518:38 - a complicated system to track okay when
518:40 - was this message sent how much did we
518:42 - owe last time Etc it would be hard to
518:45 - really know how much we need to send to
518:47 - B but if we simply accumulate how much a
518:51 - has pened in the beginning and then how
518:53 - much we already took from the deposit
518:55 - and send to B then it makes the
518:57 - computation simple so the amount we need
519:00 - to pay is the amount AO so far minus
519:05 - what we already got from them we make
519:09 - sure they have enough in their deposit
519:10 - to pay for that amount if not that means
519:14 - B accepted payments for which there was
519:17 - no corresponding deposit so B made a
519:20 - mistake and they could maybe send a
519:22 - previous message where a didn't owe as
519:24 - much then we update the amount in the
519:28 - deposit we subtract the amount we are
519:29 - paying to B we increase the total amount
519:32 - that we are paying to be so far we add
519:35 - amount to pay and then we send that
519:38 - amount to the sender so send that amount
519:40 - to the seller to B finally when a wants
519:44 - to close their account we fetch the key
519:48 - we check that this is after the
519:50 - deadline and then we send whatever is
519:53 - left in the deposit and and we delete
519:56 - the
519:57 - deposit in the test we create different
520:00 - accounts and here in the test we create
520:03 - a deposit from Alice that deposits 100 t
520:08 - for the seller Bob with a deadline a
520:13 - th000 then when Alice wants to spend a
520:16 - little bit of money and purchase
520:18 - something from Bob she can create a
520:20 - message that says I know all five T to
520:24 - Bob she has to pack the message and then
520:27 - sign it with her secret key so this is
520:29 - done offline she could send more and
520:32 - more of these messages increasing the
520:34 - amount every time by the price of the
520:37 - item she wants to
520:39 - purchase and then eventually when Bob
520:41 - feels okay now it's time for me to get
520:43 - paid Bob will call claim payment saying
520:47 - I want to be paid using the deposit from
520:50 - Alice here's the last message I received
520:54 - here is the Corr opening signature I'll
520:56 - is sent me and Bel gets paid we can give
521:00 - it a
521:01 - try and we can see that indeed Bob gets
521:07 - paid unfortunately there is a big flaw
521:10 - in this
521:12 - contract pause the video and take a
521:15 - minute to try to find
521:17 - it there's a couple similar flaws in
521:21 - this version of the
521:22 - contract the first one
521:26 - is that if Alice closes her account we
521:31 - delete everything and later on she
521:33 - decides to do some business again with
521:35 - Bob then she would deposit some money
521:37 - again saying okay I'm depositing some
521:40 - money I want to make new
521:42 - purchases Bob could steal her money can
521:46 - you figure out how pause the video and
521:49 - think about it for a
521:51 - minute so the issue is that if Bob saved
521:55 - this message and the corresponding
521:57 - signature Bob could send the message
522:00 - again to claim payments and get the same
522:04 - amount again Alice didn't make any new
522:06 - purchase but Bob still has a copy of
522:09 - this IOU 5 test from Alice and the
522:13 - signature is still valid the message is
522:14 - still valid so claim
522:16 - payments would simply send the five test
522:20 - to Bob now how can we avoid this pause
522:24 - the video and think about it for a
522:27 - minute so what we really want is to make
522:30 - sure that the same message cannot be
522:33 - used Again by Bob there's a couple ways
522:37 - to do that one way would be to never a
522:41 - close deposit here instead of sending
522:44 - everything and deleting the deposit and
522:46 - resetting everything and then forgetting
522:48 - that there was already a history between
522:50 - Alice and Bob we could simply reduce the
522:54 - amount deposited to Z but keep the
522:57 - record in our big map this way we
523:00 - remember that the amount spent so far is
523:03 - already five TZ so if BB sends a message
523:08 - that says Alice owes me five TZ then we
523:10 - check well you already received five
523:13 - test from Alice so there's nothing Alice
523:16 - owes you and if Alice wants to make a
523:19 - new purchase she would have to say okay
523:21 - I now owe you five plus xas then Bob
523:25 - could claim the extra xas so that's one
523:28 - way to do it never to close the account
523:31 - another more typical way to do it is to
523:34 - make each deposit entry a bit more
523:37 - unique by adding some information adding
523:40 - a counter similarly to what we do to
523:43 - transactions if you remember a
523:45 - description of how transactions are
523:47 - verified transactions have a signature
523:49 - but to avoid transaction being replayed
523:51 - we add a counter to each transaction
523:54 - that says how many transactions has this
523:57 - user signed so far so we could do
524:00 - exactly the same here when we deposit we
524:02 - could add some
524:06 - counter that we
524:09 - store and
524:11 - that the author of the deposit should
524:14 - increment every time they deposit some
524:16 - money if we are simply adding to the
524:20 - existing funds we shouldn't count the
524:22 - counter this is a counter of how many
524:24 - times we recreated the deposit and then
524:27 - when we claim payments in the pack
524:30 - message we should have the value of the
524:36 - counter and here we could
524:40 - check that the counter for the
524:46 - message equals the counter for the
524:53 - deposit of course when we sign messages
524:57 - we need to add a counter as
525:03 - well so if we close the contract created
525:06 - a new one then we would use accounter
525:08 - two so that messages for a given deposit
525:13 - cannot be reused next time we recreate a
525:21 - deposit and here when we deposit we have
525:25 - to send the counter so
525:38 - counter all
525:41 - good but we still have a
525:43 - flaw and the flaw comes from the same
525:46 - idea of the same signed message being
525:50 - replayed being reused in a different
525:53 - context so now that we have this Contra
525:56 - in the message that says okay this is
525:58 - the third time that we create a
526:00 - deposit and so everything should be
526:02 - reset and every message from previous
526:05 - deposits are not valid anymore but still
526:09 - it would be possible in some cases for
526:12 - Bob to steal money from
526:15 - Alice pause the video and think about it
526:17 - for a
526:19 - minute so the issue here is that we
526:23 - could have multiple instances of this
526:25 - micro preman
526:27 - contract and there is
526:29 - nothing in the
526:31 - messages that says that those messages
526:34 - are about this
526:36 - contract so we could even imagine that a
526:38 - very different contract just happens to
526:41 - have a structure of messages that
526:43 - contains a record with a destination
526:45 - with an amount and with a counter that
526:48 - would have nothing to do with micro
526:50 - payments it's just used for something
526:51 - else and then Alice and Bob happened to
526:55 - be using that other
526:57 - contract so using a message with the
527:00 - same structure for a different contract
527:02 - Bob could call claim payments and
527:06 - extracts funds from this contract that
527:07 - has nothing to do with this message and
527:10 - the way to solve that is to add to the
527:12 - message the address of the contract that
527:14 - we are talking about so here we would
527:17 - need to add
527:20 - contract equals micro payments
527:25 - address to make sure this is about this
527:29 - contract and then here we would get
527:35 - Contract sp.
527:38 - address and then we
527:41 - check message. contract equals sp. self
527:50 - address this time a message dist to a
527:53 - different contract couldn't be reused in
527:55 - our contract this makes everything a lot
527:57 - safer so this idea of always having some
528:00 - kind of Contra in the messages and
528:03 - identifying for which contract the
528:05 - message is and really making sure that
528:09 - the information is complete that says
528:11 - everything we need to
528:12 - verify then you can avoid this flaw of
528:15 - being able to replace signed messages in
528:18 - this video we'll look at a smart
528:20 - contract that enables people to play a
528:23 - geocaching game and will will discuss a
528:26 - number of potential flaws in this smart
528:29 - contract geocaching is a game where one
528:33 - person hides one or more Little
528:36 - Treasures somewhere in the world it
528:38 - could be anywhere and then they publish
528:40 - hints about the location of these
528:43 - treasures and the players use this hints
528:46 - to try to find those items so here the
528:51 - goal is to create a smart contract that
528:53 - makes it easy to play this game for each
528:56 - treasure we assign a unique identifier
529:00 - and a password so if you find the
529:02 - capsule containing a treasure you can
529:06 - call a contract to prove that you indeed
529:09 - found the treasure and the password and
529:12 - ID that it contains and so we could make
529:15 - it into a game where the person who
529:17 - finds the most Treasures gets a
529:20 - reward so the interesting part in this
529:23 - contract is that we will need to be able
529:25 - to verify that a player found a given
529:27 - password but we can't simply store the
529:30 - passwords directly in the contract as we
529:33 - discussed before the storage of the
529:35 - smart contract is public so if we simply
529:38 - store the passwords in the contract
529:41 - anyone can simply see the password and
529:43 - then send them to the contract and
529:45 - pretend that they found the treasure so
529:47 - the question is how can we verify
529:50 - passwords without storing them pause the
529:53 - video and think about it for a
529:56 - minute so a typical way to verify
529:59 - passwords without saving them is to
530:01 - store the hash of the passwords that's
530:04 - what most authentication systems use
530:07 - they store hashes of passwords typically
530:10 - with added salt so that they can
530:12 - authenticate users without keeping the
530:14 - actual password in the database so here
530:17 - we will use a cryptographic hash
530:20 - function that we apply to passwords and
530:23 - those have a few key prop properties for
530:25 - the same input they always produce the
530:28 - same output that we call the hash of
530:30 - that input and if you're given a hash it
530:35 - is virtually impossible to find an input
530:39 - that produces this hash unless you
530:42 - actually know the original input or
530:44 - unless you try every single possible
530:46 - value which typically would take way too
530:48 - long for anyone to ever find the correct
530:51 - input value so the input value here the
530:54 - actual password that we will hash needs
530:56 - to be large enough that it's impossible
530:58 - to simply try every single password and
531:01 - check if it gives a given hash so
531:03 - instead of comparing the password to a
531:06 - store password a contract can verify a
531:09 - password by Computing its hash and then
531:12 - comparing it to the stored hash so let's
531:15 - take a look at the first version of this
531:17 - mod contract in the storage we will keep
531:20 - a big map with all the treasures and we
531:23 - will see that for each treasure the key
531:25 - is an identifier a simple number that we
531:28 - increment every time we add the treasure
531:31 - and the Valu is a record that will
531:33 - contain the hash of the password and a
531:36 - flag that says if somebody found this
531:40 - treasure then we will keep the scores of
531:43 - the different players so for each player
531:45 - we will keep their current score we will
531:47 - maintain the address of the current
531:49 - winner we initialize it with the owner's
531:52 - address and then we also need to
531:54 - initialize the score of the owner to
531:56 - zero so that as soon as somebody finds a
531:58 - treasure they can become the current
532:00 - winner and we can compare their score to
532:03 - the score of the owner we separately
532:05 - store the address of the owner we store
532:08 - a deadline after which we will give the
532:11 - award to the winner and then uh we count
532:14 - the number of
532:15 - treasures the owner is able to create a
532:18 - number of treasures and all he needs to
532:20 - send to the smart contract is the hash
532:23 - of the password
532:25 - we check that he does that before the
532:27 - deadline and that only the owner can
532:29 - call this contract we increment the
532:31 - number of treasure and then we store the
532:33 - information and say this treasure has
532:35 - not been found yet then when somebody
532:38 - discovers a treasure they need to send
532:40 - the ID of the treasure and corresponding
532:43 - password so we check that they do so
532:45 - before the deadline we obtain
532:47 - information about the treasure we check
532:49 - that it hasn't been found yet then we
532:52 - compute the hash of the password was
532:54 - send Using sp. blake2b and we compare it
532:58 - to the hash of the treasure if it's
533:02 - correct then that means the treasure has
533:04 - been found and we just have to increment
533:08 - the score of the player so if there's no
533:10 - entry for that player in the big map we
533:12 - create one with score zero and then we
533:15 - increment their score by one and if
533:19 - their score is more than the score of
533:21 - the current winner then they become the
533:23 - new current winner finally after the
533:27 - deadline the owner can call this award
533:30 - prize entry point we check that he does
533:33 - so after the deadline and then we simply
533:36 - send the whole balance of the contract
533:38 - to the winner so whatever the owner
533:41 - decided to send as a reward when they
533:43 - called for example pre
533:46 - treasure and then we have a test where
533:49 - we check that everything goes well now
533:52 - unfortunately there are a couple of
533:54 - flaws with this contract pause the video
533:58 - and try to see if you can figure them
534:00 - out
534:02 - already to help you remember that flaws
534:05 - in smart contracts can typically have
534:07 - two types of
534:09 - consequences either someone can steal
534:12 - some value from the contract and other
534:15 - users or some value can get stuck in the
534:19 - contract pause the video and try to see
534:21 - if this helps you find the bugs in
534:24 - cashing contract so the first flaw is
534:27 - that you can have funds stuck in the
534:29 - contract and this is due with the way
534:32 - that the award prize entry point has
534:35 - been
534:35 - implemented how could this piece of code
534:38 - make it so that the funds are stuck in
534:40 - the contract what could possibly go
534:42 - wrong and think about it from the point
534:45 - of view of the winner how could your
534:47 - funds get stuck after you won the game
534:51 - pause the video and think about it for a
534:52 - minute well the issue is is that here
534:54 - for the winner to get their prize we
534:57 - need the owner to call the entry point
535:00 - but you could imagine that the owner
535:01 - doesn't call the entry point for a
535:03 - number of reasons for example they could
535:05 - simply forget to call that entry point
535:07 - or they may be unable to call it for
535:09 - example what if they lost their private
535:11 - key and they could also do that on
535:13 - purpose they could say okay I'll give
535:15 - you your prize but you have to do this
535:18 - for me and they could try to extort
535:20 - money from the winner before they give
535:22 - them their price here they would be able
535:24 - to weird but that could be one of the
535:25 - reasons why the owner doesn't call the
535:27 - entry point that Awards money to the
535:29 - winner and you could say well that's the
535:32 - organizer of the price I mean yes if the
535:34 - organizer of a game um is not available
535:36 - anymore and decides not to play well
535:38 - yeah it's okay to imagine and in this
535:40 - kind of situation the winner wouldn't
535:42 - get their prize but the whole point of a
535:44 - blockchain the whole point of using
535:46 - smart contracts is to avoid having to
535:48 - trust that some specific person will do
535:51 - what they are supposed to do we don't
535:53 - want to have to trust a third party and
535:56 - here we don't want to have to trust that
535:58 - the organizer will do what they're
536:00 - supposed to do so the question for you
536:02 - is how can we solve this how can we make
536:04 - sure that we don't have to trust the
536:06 - owner pause the video and think about it
536:09 - for a minute the solution is simply to
536:11 - let the winner or actually anyone call
536:14 - the entry point themselves there's
536:15 - really no need for it to be the owner we
536:17 - simply verify that the deadline has
536:20 - passed and then if it has and somebody
536:22 - calls that entry point then we send the
536:24 - funds to the winner so the best practice
536:27 - in your smart contract is to avoid
536:30 - unnecessarily requiring that a specific
536:32 - third party performs an action if
536:34 - there's really no need for that to be
536:36 - the owner of the contract or someone
536:38 - else then just don't verify it and let
536:40 - anyone call the entry point so here we
536:43 - can simply delete that line and
536:46 - everything still works just fine even if
536:49 - the owner forgets to call that entry
536:51 - point so that fixes the first flaw now
536:55 - the second flaw is that somebody can
536:57 - actually steal money that should go to
537:01 - someone and by that I mean somebody who
537:04 - didn't find a treasure could still
537:07 - become the winner so posi video and
537:10 - think about how you would do that how
537:12 - could you claim the prize without
537:15 - actually having found any real
537:18 - treasure so the second flaw is due to
537:21 - the fact that all transactions are
537:23 - public so as soon soon as you send a
537:24 - transaction to a node you can assume
537:27 - that everyone can see it it will be
537:30 - known by whoever owns that node then
537:32 - this node will send the transaction to
537:34 - all its neighbors and then to other the
537:36 - neighbors Etc so all the nodes will
537:38 - receive the transactions before it's
537:41 - even considered for being added in the
537:43 - block and if you send the password and
537:47 - the ID in your transaction then
537:48 - everybody sees your password so anyone
537:51 - can create their own transaction
537:54 - with the same password and pretend that
537:56 - they found that treasure and to make
537:58 - sure that they get the point and not you
538:01 - they can add a fee for their transaction
538:04 - that is a bit higher than yours so that
538:06 - the baker is more likely to take their
538:09 - transactions first before they take
538:11 - yours and they will get the point and
538:13 - you won't this kind of attack is what we
538:16 - call bpev flaws block producer
538:20 - extractable values and sometimes also
538:23 - calls me maximum extractable value so
538:26 - the idea is you can have Bots that
538:28 - always analyze all the transactions that
538:30 - travel through the peer top Network and
538:33 - they analyze those transactions to see
538:36 - if there's any valuable information in
538:38 - in there and especially they simulate
538:40 - what would happen if they perform this
538:43 - transaction from their own address and
538:46 - if the outcome of that transaction
538:48 - benefits them if they see that after the
538:50 - transaction is over their balance has
538:52 - been increased then will emit the
538:54 - transaction but with a higher fee than
538:57 - the original one so there's whole bunch
539:00 - of bots on all
539:02 - blockchains that look for this kind of
539:04 - transactions and then copy them and send
539:07 - them again but with their own address
539:09 - and a slightly higher fee and so since
539:13 - you have many different Bots that do
539:15 - that eventually the fee goes up and up
539:17 - and up right up to the Limit where it's
539:19 - not profitable anymore to keep
539:21 - increasing the fee so in the end it's
539:24 - likely to be the baker who will make the
539:26 - most profit because they benefit from
539:28 - that higher fee so that's why we call it
539:30 - block producer extractable value because
539:32 - whoever creates the block gets all the
539:34 - benefits of these increased fees and the
539:37 - baker the block producer can even make
539:40 - sure that they are the ones whose
539:42 - transaction is taken because they get to
539:44 - pick which transaction are added to the
539:47 - next block so they could just decide
539:48 - okay I'm going to get the treasure I'm
539:50 - going to be the one creating a copy of
539:52 - this transaction and getting the
539:54 - benefits so one way or another the block
539:57 - producer is able to take advantage of
540:01 - this flaw so here someone who didn't
540:04 - find the treasure could just look for
540:05 - the password in one of transactions and
540:08 - then claim to have fun the Treasure by
540:11 - sending the same password but with a
540:13 - higher fee so the question is how can
540:16 - you protect your contract so that this
540:18 - kind of attack wouldn't work pause the
540:22 - video and think about it for a couple of
540:24 - minutes so to protect against block pess
540:27 - or extractable values there are a number
540:29 - of approaches and none of them is ideal
540:32 - but we can try to find one that would
540:35 - work well for this construct a good way
540:38 - to think about this is to try to imagine
540:40 - that you're in a real room with a number
540:42 - of people and there's a transparent box
540:44 - in that room and your goal is to go
540:46 - around and find treasures and when you
540:49 - find them you need to put a piece of
540:51 - paper in the transparent box and and so
540:54 - you can write the password on a piece of
540:56 - paper and you add the ID of the treasure
541:00 - and your name so that you can claim to
541:02 - be the first one who found that treasure
541:05 - and of course you destroy the password
541:07 - so that another person cannot claim it
541:09 - and then there are will be 10 minutes
541:12 - until the game master opens the box then
541:15 - this game master will look at all the
541:17 - messages and check the passwords and
541:20 - count who found the most Treasures so if
541:22 - you imagine this situation
541:24 - how would you make sure that other
541:26 - people don't copy your password that
541:29 - they can see through the transparent box
541:31 - so that they can lie and claim that they
541:33 - found that treasure and if you can think
541:36 - of a way to do that in this room with
541:38 - this transparent box think about a way
541:41 - that you could apply this idea to a
541:43 - Smart contract pause the video and think
541:46 - about it for a minute so the solution
541:48 - would be that as you write the treasure
541:50 - idea the password and your name to a
541:53 - piece of paper
541:54 - to prevent other people from copying it
541:57 - you would just simply fold the piece of
541:59 - paper this way the game master would
542:02 - have to unfold each piece of paper
542:04 - before counting who found the most
542:06 - treasures and you would make sure that
542:08 - once the game master starts unfolding
542:11 - the pieces of paper making them visible
542:13 - for
542:14 - everyone you wouldn't let anyone else at
542:17 - their own piece of paper to the box so
542:19 - this way as the pieces of paper are
542:22 - folded nobody can read them
542:24 - until it's too late to add a piece of
542:27 - paper in the box now how could you do
542:29 - something similar in your smart contract
542:32 - on the blockchain pause the video and
542:34 - think about it for a minute so one way
542:36 - we could do this would be to encrypt
542:38 - that information so instead of sending
542:41 - the treasure ID password and your
542:43 - address as a clear message in a
542:45 - transaction you would first encrypt it
542:48 - of course the contract wouldn't be able
542:50 - to know the decryption key because
542:53 - anything that the contract knows is
542:55 - public so you cannot have a key in the
542:58 - contract that they would use to decrypt
542:59 - that information so instead you wait
543:03 - until the deadline is passed and then
543:05 - you send the description key so that the
543:08 - smart contract can extract the value
543:10 - from your encrypted message so this way
543:14 - you have to know all the information so
543:17 - that you can encrypt the message before
543:19 - the deadline and then after the deadline
543:22 - you reveal the message by sending
543:24 - the key that you use to encrypt it so
543:26 - that the smart contract can decrypt it
543:28 - and check if you did indeed find the
543:30 - treasure it's important to include your
543:34 - address in this encrypted message
543:36 - otherwise people could still copy a
543:38 - transaction and send the same message
543:40 - and later send the same decryption key
543:44 - so this approach would work but it's a
543:46 - bit costly because encryption functions
543:48 - are pretty costly so you don't want to
543:50 - run them in the smart contract can you
543:53 - think of another way to do that similar
543:55 - way but that may be a little bit less
543:57 - costly pause the video and think about
544:00 - it for a minute so a second approach to
544:02 - solve this but very similar is what we
544:06 - call the commet and reveal scheme and
544:08 - the idea is instead of encrypting the
544:10 - information we simply send a hash of the
544:14 - information and then in the second phase
544:16 - we send the actual information so we
544:18 - have two phases the first phase is the
544:21 - comet phase where each player can s the
544:24 - hush of their message containing the ID
544:27 - of the treasurer the password and their
544:30 - address and then we have a reveal phase
544:33 - where after the deadline each player can
544:36 - send the message itself then the
544:38 - contract compute the hash of the message
544:41 - compare it to the one that the user has
544:44 - sent before and if it is correct they
544:46 - canward the point to that user and
544:49 - Computing a hash is less costly than
544:52 - using any encryption algorithm but it's
544:55 - actually possible to make it even faster
544:57 - and to help you think that the best way
545:00 - to save gas is to do as much as you can
545:04 - offchain rather than onchain so if
545:06 - there's any competition you can avoid
545:08 - doing in the smart contract itself but
545:11 - instead do an offchain then you can save
545:14 - a lot of CPU therefore
545:16 - guys pause the video and think about it
545:19 - for a minute so the third approach is to
545:21 - still use this commit and reveal scheme
545:24 - so you still commit before the first
545:27 - deadline by sending a hash of the
545:29 - message with the ID the password and
545:31 - your
545:31 - address and then you steal reveal after
545:35 - the first deadline where every player
545:37 - sends the actual message but instead of
545:41 - immediately having the smart contract
545:43 - check if the hash corresponds to their
545:45 - produced message you let other players
545:49 - check themselves and if they see a
545:52 - message from a player that doesn't
545:54 - correspond to the hash that this player
545:56 - sent earlier then they can call an entry
545:59 - point to to say hey this player is
546:01 - trying to cheat they're sending a
546:03 - message that doesn't correspond to the
546:05 - hush to sent earlier and if the player
546:08 - indeed cheated then the smart contract
546:10 - can check verify yes indeed this message
546:13 - doesn't match the hash that they sent so
546:15 - I will eliminate them or maybe even
546:17 - punch them so this way we don't always
546:20 - check and compute the hash to verify
546:23 - that the hash of the message corresponds
546:25 - to the hash that the user previously
546:28 - sent we only do it if somebody complains
546:31 - so we have a second deadline and people
546:34 - have some time to complain before we
546:36 - award the prize in practice you can
546:39 - expect that nobody will try to cheat so
546:43 - the actual computation of the hush will
546:44 - never need to be done so let's take a
546:46 - look at the updated contract so here on
546:50 - top of the treasures and score per users
546:53 - we store for a big map with all the
546:55 - comments that people make once they find
546:58 - the
546:59 - treasure and we also keep a value of a
547:03 - deposit that every player will have to
547:05 - send to the contract as their register
547:08 - this way they can be punished if they do
547:10 - something bad and other people can be
547:12 - rewarded for denting anything bad that
547:15 - they did so we'll see that in a minute
547:17 - and then this time we will have three
547:18 - different deadlines the deadline for
547:22 - people to commit the hash of their
547:24 - message the deadline for revealing the
547:28 - actual message and the deadline for
547:30 - other players to dispute a message if
547:33 - they think somebody tried to
547:35 - cheat we add a register player entry
547:38 - point so that people can register before
547:40 - the deadline to commit and send their
547:44 - deposit and we use this as an
547:46 - opportunity to set their score to
547:49 - zero then we still have our create
547:52 - treasure and point for the owner to
547:54 - create treasures and they still store
547:57 - the hash of the
548:00 - password then once somebody finds a
548:02 - treasure they can send a hash of their
548:05 - message to this commit discover treasure
548:08 - entry point so they send the IDE of the
548:10 - treasure and the corresponding message
548:13 - and this is a hashed message so it will
548:16 - be of types sp. bytes we check that the
548:20 - owner themselves cannot uh play so we
548:23 - don't allow the owner to commit a
548:25 - message we check that this is before the
548:27 - deline to commit we check that we didn't
548:30 - already receive this message this is not
548:33 - really necessary I can remove that then
548:36 - we Mark that we received that
548:39 - comment then we have the entry point
548:43 - that people call once the comment
548:45 - deadline is passed and it's time to
548:47 - reveal their message and this time they
548:50 - send the actual password we check that I
548:53 - do that before the deadline to reveal we
548:57 - get the corresponding treasure we check
548:59 - that the treasure has not been found
549:01 - then we Mark the treasure as found we
549:03 - store the password for this treasure and
549:06 - we also store the player who found it
549:10 - then we increase the score of that user
549:13 - assuming that they are not lying that
549:15 - they actually did send a password that
549:17 - corresponds to their previous comment
549:20 - and we check did they get more points
549:23 - than the the current winner and if they
549:25 - did then we store them as the new
549:27 - current
549:29 - winner but now if somebody says hey this
549:33 - person claimed to have F found this
549:35 - treasure but that's not true that's not
549:37 - the case somebody else found it then we
549:39 - can call this dispute Discovery entry
549:42 - point we check that it's not too late to
549:45 - dispute it we obtain the corresponding
549:47 - treasure we check that indeed somebody
549:49 - claimed that they found it then we check
549:53 - did the password that Des send actually
549:56 - correspond to the password for that
549:58 - treasure so does it match the hash of
550:00 - the treasure we didn't even check that
550:02 - they sent the right password when we
550:04 - called reveal this discovered treasure
550:05 - we assume that the person can be trusted
550:08 - but here somebody disagrees so we check
550:10 - did they send the right
550:12 - password so we generate the message that
550:16 - they should send that includes the
550:19 - password and the address of the user so
550:21 - whoever claimed one we compute the hash
550:26 - and we check that indeed this person
550:28 - didn't commit a message corresponding to
550:31 - this hash so that means this whoever is
550:34 - disputing is correct because the hash of
550:37 - that message was not
550:39 - committed then we simply eliminate that
550:42 - player if that have not already been
550:44 - eliminated by someone else and then we
550:47 - send the deposit from that player to
550:49 - whoever calls this a dispute entry point
550:53 - if that player was the current winner
550:55 - then we reset the current winner to the
550:58 - owner we Mark treasure as not having
551:02 - been found so that if someone else has
551:05 - actually found it they can reveal that
551:07 - they found it so they can call the
551:09 - reveal discover treasure if it's still
551:12 - not too late and to make sure they have
551:14 - time to do so we add some time to the
551:16 - reveal deadline an hour and we also add
551:20 - one hour to the dispute deadline so one
551:23 - issue here is that we don't have the
551:25 - winner anymore and we cannot Loop
551:27 - through all the different scores to see
551:29 - who is the new winner now that we
551:30 - eliminated someone so we have to add an
551:34 - extra entry point update winner where we
551:37 - will check this is before the deadline
551:40 - to dispute anything and then we check
551:43 - that whoever is calling this actually
551:45 - has a higher score than whoever is
551:46 - marked as a current winner and then if
551:49 - they do then we update them as the new
551:51 - current winner so anyone can say hey I'm
551:54 - actually the winner look my score is
551:56 - better than Whoever has claimed to be
551:58 - the winner so far finally when the
552:01 - deadline for the dispute time is over
552:04 - then the current winner can claim their
552:06 - funds so the code here and especially
552:09 - the code of dispute discover is a bit
552:11 - more complicated but in practice since
552:14 - there is a way for anyone to tell if you
552:17 - cheit it and you will be punished if you
552:20 - cheit it this part of the code is very
552:23 - likely never to be executed so you won't
552:25 - pay for the cost of it but you need to
552:27 - make sure that there's no bug in there
552:30 - so as you can see preventing block
552:31 - producer extractable value can be a bit
552:34 - complicated make the code a bit more
552:36 - complicated but this is necessary to
552:38 - make sure nobody steals your
552:41 - funds it's actually still a way to cheat
552:46 - at least in some situations and this way
552:49 - is to prevent people from scoring P TR
552:53 - Treasures that they found but this can
552:55 - be costly so can you think about it for
552:58 - a minute and find a way that somebody
553:00 - could prevent you from getting the
553:02 - points for your treasure if they're
553:04 - really motivated to make sure you don't
553:06 - win pause the video and think about it
553:08 - for a minute so that approach that can
553:10 - be used in some situations is to
553:13 - actually attack the blockchain itself
553:16 - preventing some transactions from going
553:18 - through by sending so many transactions
553:21 - that the these users transaction may not
553:24 - be accepted and for that you have to
553:26 - keep in mind that Bakers typically
553:28 - select the most profitable transactions
553:31 - and most profitable means you add an
553:33 - extra fee on top of the minimum fee that
553:36 - you should send to pay for the gas so
553:39 - this means that if you send enough
553:41 - transactions with relatively High fees
553:44 - you could prevent legitimate
553:46 - transactions from being added to
553:48 - blocks so if you send many transactions
553:51 - with high fees you will feel the blocks
553:53 - until the deadline and none of the
553:56 - regular transactions will be added
553:58 - unless somebody notices and pays a
554:00 - higher fee this would be very costly but
554:03 - if there's just a little bit of time
554:05 - left for other players to submit their
554:08 - Treasures they find at the last minute
554:10 - then it could be worth it depending on
554:12 - what the reward would be so the
554:14 - different ways to avoid this kind of
554:16 - situation uh can be to give enough time
554:19 - between deadlines for this to be really
554:22 - expensive of course you could always
554:24 - prevent people from submitting their
554:26 - commit or reveal at the very last moment
554:29 - but then it's up to them if they don't
554:31 - do that so make sure you give people
554:33 - enough time so that nobody can block
554:35 - transactions during the whole window of
554:38 - time and another way to avoid this is
554:41 - for players to be a baker themselves so
554:45 - that they can make sure they give
554:47 - priority to their own Comet and reveal
554:50 - transactions and so this could be either
554:53 - if you're the owner of the contract and
554:54 - you want to make sure nobody can do that
554:56 - for your contract you can be a baker and
554:59 - then once in a while you make sure the
555:00 - transactions for your contract are
555:02 - accepted so that you can guarantee that
555:04 - your service is always reliable but of
555:08 - course anyone Els players themselves
555:10 - could make sure they are Bakers so that
555:13 - they can do that themselves so when the
555:15 - stakes are high it makes sense for big
555:19 - entities that uh rely on Smart contracts
555:22 - to be Bakers themselves so that they can
555:25 - make sure that their transactions go
555:27 - through in this module we will talk
555:29 - about Randomness picking random numbers
555:32 - in a smart contract is a very
555:34 - interesting but hard problem so let's
555:37 - say you want to organize a raffle where
555:39 - every participant can register and pay
555:43 - 100 Tes and after a deadline one of
555:46 - these participants is picked randomly
555:50 - and they get the whole balance of the
555:51 - contract as a prize so the questions for
555:54 - you are how would you structure this
555:57 - contract what would you store what would
555:59 - be the entry points Etc and most
556:02 - importantly how would you pick the
556:04 - winner among all these
556:06 - participants pause the video and think
556:08 - about it for a minute the structure of
556:10 - the contract itself is relatively easy
556:13 - in the storage you will store all the
556:16 - participants you need to use a big map
556:18 - to avoid any gas issues and the key will
556:21 - be an ID and the value will be the
556:24 - address of the participant for the idea
556:26 - we will simply use a counter and we will
556:29 - count the number of participants so a
556:31 - natural that we initially set at zero
556:33 - and every time a new participant
556:35 - registers we will increment this value
556:39 - then we set a deadline for everybody to
556:41 - register now we have two entry points
556:44 - one for participants to bid where we
556:47 - check that they do indeed send 100 test
556:50 - to the contract we check that they do
556:53 - that before the deadline we assign their
556:56 - address to their ID so the current
556:59 - number of participants and then we
557:00 - increment this value by one so we
557:03 - basically register that they
557:04 - participated in the raffle finally after
557:08 - the deadline they can claim their prize
557:10 - whoever is the winner will be able to
557:12 - claim their prize we check who the
557:14 - winner is by picking a random value
557:17 - between zero and the number of
557:19 - participants minus one and then we send
557:22 - the balance of the contract to the
557:24 - corresponding participant so that's for
557:26 - the structure now the hard question is
557:29 - there is no such random function
557:31 - available on tesos so without such a
557:33 - function how can you pick the winner
557:37 - pause the video and think about it for a
557:39 - couple of minutes in a regular program
557:41 - you run on your computer when you pick a
557:43 - random number it usually consists in
557:45 - calling a function that uses a
557:47 - mathematical function that produces a
557:50 - randomish sequence of numbers so we show
557:53 - here an example of such a basic version
557:56 - of a function where you take the current
557:58 - value you multiply it with a big prime
558:00 - number you add some value Etc and then
558:03 - to make it between zero and some value
558:06 - you take the module of that value and
558:09 - then to make sure that every time you
558:10 - run the program you don't get the same
558:12 - sequence you initialize with some
558:14 - randomish source of entropy and we
558:17 - typically will take the current time
558:19 - step because on the regular computer
558:21 - that can be in micros seconds so that
558:24 - changes all the time and it's hard to
558:27 - predict so the question is can you do
558:29 - that in a smart contract using sp. now
558:32 - for you seed and if you can or cannot
558:36 - try to think about why pause the video
558:38 - and think about it for a minute so using
558:41 - sp. now as a source of Randomness to
558:44 - initialize the seed of your function is
558:46 - a terrible idea first the value of sp.
558:49 - now is expressed in seconds so there's
558:52 - really nothing not much Precision it
558:53 - doesn't change too often and since you
558:55 - have blocks every 15 seconds there's
558:59 - really only a few values that are
559:00 - possible for a given block but more than
559:03 - that the baker of the previous block
559:07 - actually gets to pick the exact value so
559:09 - it's not random all all it's just some
559:11 - person on the computer I mean their
559:12 - computer picks it one way or another but
559:15 - the baker has control over that value so
559:18 - the idea is that in practice the value
559:19 - sp. now is not the actual time stamp of
559:22 - the current Block in the sense of when
559:24 - was this block created it's actually 15
559:28 - seconds plus the actual creation time of
559:31 - the previous block and the idea is that
559:34 - in each block there's really two time
559:35 - stamps there's the time stamp that's the
559:38 - actual time where the block was created
559:40 - at least according to the Baker and then
559:43 - there is the value of sp. now that is 15
559:46 - seconds plus the time stamp of the
559:49 - previous block so really the baker of
559:52 - the blog to pick what will be the value
559:55 - of sp. now in the next blog so in
559:58 - practice when you look at the actual
560:00 - value of sp. now it tends to be every 15
560:03 - seconds so it makes it extremely
560:04 - predictable which makes it a really bad
560:07 - source of Randomness it can be predicted
560:10 - and it can be controlled by a baker okay
560:13 - so now that we get this idea out of the
560:15 - way can you think of any better ideas
560:19 - pause the video and think about it for a
560:20 - minute some ideas people tend to have
560:22 - have is to use hashes as sources of
560:24 - Randomness when you look at a hash it
560:26 - looks pretty random you just change one
560:28 - bit of the input and it changes
560:30 - everything in the output so it looks
560:32 - pretty random but be careful it may look
560:35 - random it's actually very predictable if
560:37 - you know the input of course the output
560:38 - will always be the same but more than
560:41 - that just like the time the baker can
560:43 - manipulate it because the hash of a
560:46 - block is really computed based on the
560:48 - content of the block based on what
560:50 - transactions they are and so if a Baker
560:53 - wres a block with a number of
560:54 - transactions then compute a hash and
560:57 - somehow that hash is not good for them
560:59 - it will not produce the right random
561:02 - number when you run the smart contract
561:04 - then they could just try a different set
561:06 - of transactions to obtain a different
561:09 - hash for their block so they do have
561:11 - some control on the value of the hash
561:13 - simply because it can make multiple
561:15 - attempts at traing a block and it will
561:17 - give different values for the hash
561:19 - therefore different random values for
561:22 - who is using this hash as a source of
561:25 - Randomness another reason why you
561:27 - shouldn't use the hash of a block as a
561:30 - source of Randomness is simply that you
561:33 - cannot access a has of a block from a
561:35 - smart contract so this is clearly not a
561:37 - possibility another idea would be to
561:40 - deploy a contract because when you
561:42 - deploy a contract from a smart contract
561:45 - you can obtain the hash of the operation
561:48 - that is created and this is something
561:50 - you can do from within the smart
561:52 - contract unfortunately the value of this
561:55 - hash depends on different things that
561:57 - the baker can control so the baker again
562:00 - can manipulate it in the same way as the
562:02 - hash of the block so we cannot use that
562:05 - as a source of Randomness finally an
562:08 - idea people sometimes have is to use the
562:10 - address of participants but if you do
562:13 - that for example if you add up all the
562:15 - addresses of the different participants
562:18 - to compute a random number then whoever
562:21 - is the last participant to consider
562:23 - bidding can predict the outcome of their
562:26 - choice they will see okay if I bid
562:28 - here's what the outcome will be by
562:30 - adding my address to the total number so
562:33 - they can decide if they want to bid or
562:35 - not depending on whether it makes them
562:36 - win so the address of participants again
562:39 - is predictable and so the results would
562:41 - be not only predictable but controllable
562:44 - by some participants so that wouldn't
562:46 - work either another idea people tend to
562:50 - have is to increase the Run as by mixing
562:53 - different values some ideas people have
562:56 - is to get the exchange rate between two
562:59 - currencies for example the current
563:00 - exchange rate between the Euro and the
563:02 - US dollar and you would say well if
563:04 - somebody could control that then they
563:06 - could be rich and obviously nobody can
563:08 - control precisely what the exchange rate
563:11 - will be on the Dex but then you cannot
563:14 - predict it within maybe a few tens of
563:16 - percents but of course you can predict
563:18 - the main value so you don't have too
563:20 - much Randomness that come out of that
563:22 - just just a few bits then you say okay I
563:24 - can combine that with other sorts of
563:26 - Randomness for example other pairs of
563:29 - currencies this is something you should
563:31 - be careful about when you try to combine
563:34 - different sources of
563:35 - Randomness you get more bits of
563:38 - Randomness for sure so you increase the
563:40 - range of different values you can pick
563:42 - from but the whole result is actually as
563:46 - weak as the weakest of these sources so
563:49 - if somebody can manipulate one of the
563:51 - exchange rates one way another then they
563:54 - can manipulate the outcome so it's
563:57 - actually dangerous from the point of
563:59 - view of making sure people cannot
564:00 - control the outcome to mix multiple
564:02 - sources of
564:04 - Randomness another issue is that the
564:06 - exchange rate of a decentralize exchange
564:09 - can be manipulated for example you could
564:11 - do a couple of transactions you could
564:14 - first buy or sell one of the two
564:17 - currencies of the Dex that may impact
564:21 - the exchange rate if you buy dollars it
564:23 - makes dollars a bit more expensive and
564:25 - then if right after that you call the
564:27 - contract that will compute the random
564:29 - number then your initial call will
564:32 - impact the results of your random number
564:35 - selection since everything is
564:37 - deterministic you can compute in advance
564:39 - what the impact of any peress of sale of
564:42 - currencies on that de will have as a
564:44 - result so you can just try different
564:47 - values and see which one generates the
564:49 - random value you're looking for so you
564:52 - can control it and know exactly in
564:54 - advance what the outcome will be so that
564:56 - doesn't make it a good source of
564:57 - Randomness either another idea people
565:00 - can have is to use a Randomness Oracle
565:03 - so rely on some offchain source to
565:05 - generate that random number but it's not
565:08 - as easy as it sounds if you use a basic
565:10 - oracles just some guy who's sending
565:12 - random numbers to a Smart contract and
565:15 - whoever that person is controls every
565:18 - single number and if they forget to send
565:21 - the number you are also stuck so this
565:23 - can be dangerous so you could use more
565:26 - advanced oracles such as chain link vrf
565:30 - verif fireable random functions this
565:32 - could work if it was available from
565:34 - tesos but you're basically moving the
565:37 - problem away the kind of problem that
565:38 - chain link has to solve is exactly what
565:40 - we trying to solve here and even in that
565:43 - case you should be very careful about
565:45 - trusting this kind of oracles sometimes
565:48 - there's possibility for collusions
565:51 - between different people that make it
565:53 - not as random as you would like finally
565:56 - as we discussed in oracles you can use a
565:58 - trusted execution environment
566:00 - Oracle like Acuras this may be the best
566:04 - solution based on oracles at the moment
566:06 - but again you need to make sure that the
566:08 - whole solution is safe and it's not
566:10 - always easy to have all the details
566:13 - about a given oracles to really be
566:15 - convinced that the randomness is really
566:18 - secure but this last option might be the
566:21 - best for an Oracle that produces random
566:24 - numbers at the moment on
566:26 - tesos but what we really want is to make
566:29 - sure nobody in particular controls the
566:32 - random value and that you don't need to
566:34 - trust some entity to keep producing
566:37 - those random values so we want to use a
566:40 - decentralized source of Randomness how
566:43 - can we do that it's actually possible so
566:45 - the idea is for multiple users and here
566:48 - it could be the participants in the
566:49 - ruffle to cooperate and produce a random
566:53 - number together and the hard part in
566:56 - that is to make sure that none of the
566:57 - participants can manipulate the outcome
566:59 - and make it be something they like so to
567:02 - try to think about a decentralized way
567:03 - to do that try to imagine that you are
567:06 - in a room in a physical room with 10
567:08 - people and there 10 people you have no
567:11 - dice no coins Etc you just each have a
567:15 - pen and a piece of paper so the question
567:17 - is in that situation how would you
567:19 - generate a random number that none of
567:22 - you can control pause the video and
567:25 - think about it for a minute so one way
567:27 - that people could pick a winner among
567:30 - themselves would be if each of the 10
567:33 - people could assign a direct number to
567:35 - each of them so one way to randomly pick
567:38 - a winner among those 10 people is to
567:40 - First assign a direct number to each of
567:42 - them from 0 to 9 then each of them would
567:46 - write a random number on their piece of
567:48 - paper and show it to everyone then each
567:51 - person could write a number on their
567:53 - piece of paper and show it to everyone
567:56 - then anyone can sum all these 10 numbers
567:59 - and obtain a big random number then you
568:02 - could take the last digit of this number
568:04 - of the sum which would be a value
568:06 - between 0 and 9 and that gives you the
568:09 - winner would this work try to think
568:11 - about issues with this approach pause
568:14 - the video and think about it for a
568:15 - minute so the issue is that someone
568:17 - could cheat and control the outcome if
568:20 - they wait for everyone to reveal their
568:23 - number and if they're fast at Computing
568:26 - they just quickly sum up all these
568:27 - numbers the nine other people to obtain
568:30 - the current total and then from that it
568:32 - can decide what number they should give
568:35 - so that when they add this number to the
568:37 - total it gives a result that makes them
568:39 - win so that's pretty easy to cheat how
568:42 - can we avoid this pause the video and
568:44 - think about it so the solution is to use
568:46 - something we presented earlier with the
568:49 - geocaching smart contract we want
568:52 - prevent users from changing their
568:54 - numbers once others start revealing
568:57 - theirs so in our physical room we could
568:59 - have each person write a random number
569:00 - on their piece of paper that do so
569:03 - discretly and then they immediately turn
569:05 - the paper over to hide the number from
569:07 - others or they just fold it in half and
569:10 - then when everybody's done writing the
569:12 - numbers we ask everyone to put their
569:14 - pencil down so that they cannot change
569:16 - their numbers anymore and once it's all
569:18 - done every participant can reveal their
569:21 - number show it to everyone and then
569:24 - everybody can sum up the value and pick
569:26 - the winner if we do that there's still a
569:29 - flaw in this process can you figure out
569:31 - what it is pause the video and think
569:34 - about it for a minute so the issue is
569:36 - that someone could decide not to reveal
569:38 - the number to help a teammate so let's
569:42 - say we have these 10 users numbered from
569:44 - 0 to 9 and they all already committed a
569:48 - random value from 0 to 9 that we have
569:51 - here
569:53 - but then two people Eve and Gwen have
569:57 - not revealed yet but let's say Eve and
569:59 - Gwen are actually friends and teamed up
570:02 - and they already waited for everyone to
570:04 - reveal and they know okay the current
570:06 - total is
570:07 - 33 now they get to decide okay if Gwen
570:10 - reveals her number but Gwen doesn't and
570:14 - we just add all the numbers that we
570:16 - revealed before the deadline then we add
570:19 - 33+ 4 so the total would be
570:22 - 37 that would make Iris win so in the
570:25 - last digit would be
570:27 - seven but if Eve reveals her number but
570:32 - Gwen doesn't then the total would be 35
570:35 - and Gwen would win so by doing this just
570:39 - deciding who between Eve and Gwen
570:41 - reveals then they can decide the best
570:44 - strategy to increase their chance of
570:46 - winning so basically the two of them can
570:48 - generate three outcomes that gives them
570:50 - a chance at winning either are they both
570:51 - reveal so we get 2 + 4 or only Eve
570:55 - reveals so we get two or only Gwen
570:58 - reveals so we get four that we add to 33
571:03 - and for each of these three
571:04 - possibilities it generates a different
571:06 - outcome a different winner so they can
571:08 - pick out of these three possibilities
571:10 - which one is the best for them and the
571:12 - question is how can we avoid this issue
571:15 - so the idea here is to force people to
571:17 - reveal to make sure that nobody is going
571:19 - to want to use this strategy
571:22 - the first approach is to use a financial
571:25 - incentive you ask each player to deposit
571:28 - some extra money on top of their bed at
571:31 - the beginning of the game and if they
571:33 - don't reveal they simply lose their
571:36 - deposit so they have a very strong
571:38 - incentive to reveal because otherwise
571:40 - they would just lose some money but then
571:43 - the question is how much would this
571:45 - deposit be and the issue is that for
571:47 - this to work as with just a few people
571:49 - that can control the outcome if you have
571:51 - 10 people in a team out of 100 people
571:53 - who bid 10 people can generate
571:57 - 1,023 different outcomes so they're very
571:59 - likely to have one strategy that makes
572:02 - one of them win so you pretty much want
572:05 - the deposit to be as large as the reward
572:08 - so if it's a big ruffle where you can
572:09 - win one million test nobody will want to
572:12 - deposit 1 million test but this could
572:14 - work for a small ruffle there's another
572:17 - approach that is using Brute Force then
572:19 - we will see in a moment if it's in the
572:21 - the physical room we have someone steal
572:24 - Gwen's paper and reveal it for everyone
572:27 - I would call that brute force and we can
572:29 - actually give people an incentive to
572:31 - that if Gwen doesn't reveal we can
572:34 - reward that person with Gwen's deposit
572:37 - so if we can do that when one dare to
572:39 - cheat so then the question is how can we
572:41 - do this on the blockchain we've already
572:43 - seen it in the geocaching smart contract
572:46 - if we use incentives but no BR Force we
572:49 - can use a set of phases and deadlines so
572:51 - we have a registration phase where
572:54 - participants bid and deposit T each
572:57 - participant is assigned a number then we
573:00 - have a comment phase where each user
573:02 - gets to pick a random value and they
573:04 - send a hash of that value to the
573:07 - contract we have the revealed phase
573:09 - where each user sends their chosen value
573:12 - this value must match their hash finally
573:16 - after the reveal phase ends and
573:18 - everybody revealed the winner can
573:20 - collect all the bits and then everybody
573:21 - who revealed gets their deposit back so
573:24 - your job is to write a smart contract
573:27 - that uses this approach to organize a
573:30 - raffle pause the video and give it a try
573:33 - let's take a look at the solution in
573:35 - this raffle contract we store the bid
573:39 - amount so how much people need to bid to
573:41 - take part in the raffle then we store
573:44 - how much they need to deposit for the
573:47 - financial incentive then we store two
573:49 - deadlines the deadline for them to
573:51 - commit the hash of their random number
573:54 - and then the deadline for them to reveal
573:56 - the random number they picked that
573:59 - corresponds to the hash in the big map
574:02 - we store all the information about the
574:03 - players we will store the address we
574:06 - will store the hash of the random number
574:08 - and we will store whether they're
574:09 - already revealed or not then we store
574:12 - the number of players and this will
574:14 - serve as a key for the player big map
574:18 - then we'll store how much has been
574:19 - deposited how much has been bid so that
574:21 - we can know what the total price will be
574:24 - and then we have a total that will be
574:26 - the sum of all the random values finally
574:29 - we need to keep track of how many people
574:31 - have revealed then the bid entry point
574:34 - this is the entry point that people call
574:36 - during the commit phase where they need
574:38 - to send the hash of the random value
574:41 - that they picked they need to send their
574:43 - bid and their deposit so we check that
574:46 - the amount is equal to the sum of both
574:49 - they need to do so before the deine to
574:51 - commit so we check that then we store
574:54 - all the information about the player
574:55 - address the hash of their value and they
574:58 - haven't revealed yet we can then
575:00 - increment the number of players and
575:03 - update the total amount of the deposits
575:05 - and the total amount of bids in the next
575:08 - phase the reveal phase each player has
575:11 - to reveal their actual random value
575:14 - since we use an ID as the key for
575:16 - players we ask people to send their ID
575:19 - instead of sending their address for
575:22 - and they can easily find it out of chain
575:25 - we check that they call this entry point
575:28 - before the end of the reveal phase we
575:31 - check that they have not revealed yet
575:33 - otherwise they would be able to reveal
575:35 - multiple times and then manipulate the
575:39 - outcome we check that the hash of the
575:41 - random value they sent is the same as
575:44 - the hash that they sent during the
575:45 - commit phase then we Mark that they now
575:48 - have
575:50 - revealed we update the total of the
575:53 - random numbers by adding their random
575:55 - value then we increment the number of
575:58 - people who
575:59 - revealed after the deadline to reveal
576:02 - the winner can claim their price so we
576:05 - check that they do so after the
576:07 - deadline then we determine who is the
576:10 - winner to do that we divide the total of
576:13 - the random values by the number of
576:15 - players and we take the remainder using
576:17 - sp. mod and this gives us the ID of the
576:21 - wi of the
576:22 - raffle we fetch their
576:25 - address we make sure they're revealed if
576:28 - they did reveal they cannot win so they
576:30 - cannot claim the price then we compute
576:33 - how much we need to send to them so we
576:35 - send them the price the total amount of
576:37 - bids plus their share of the deposits so
576:41 - the idea is that if somebody didn't
576:43 - reveal they don't get their deposit back
576:44 - and we share it among the other players
576:47 - so to send their share to the winner we
576:49 - divide the total amount deposited
576:52 - by the number of people who revealed
576:54 - using split tokens so they get a
576:58 - fraction of the total deposit one over
577:01 - the number of people who revealed we
577:02 - send them that amount and then we delete
577:05 - them from the players so that they
577:06 - cannot try to claim the prize
577:09 - again then we have an entry point to
577:12 - send their deposits back to players who
577:14 - did reveal but didn't
577:16 - win we don't need to check who is
577:19 - calling it it doesn't matter I mean most
577:21 - most likely they will be calling it but
577:23 - there's no need to check
577:24 - it they need again to send their ID we
577:28 - check that they try to get their deposit
577:32 - after the
577:33 - deadline we make sure they're revealed
577:36 - we get their address and then we need to
577:38 - compute the amount that needs to be
577:40 - shared between the players who revealed
577:44 - to do that we take the total amount of
577:46 - deposits but then we need to find out if
577:48 - to that total we need to add the price
577:50 - if there is no winner if the winner
577:52 - didn't reveal then we need to share the
577:55 - prize between all the players who did
577:57 - reveal so we compute again similarly as
578:00 - here the ID of the winner we check if
578:05 - they are still a player if not that
578:06 - means they already claimed their price
578:08 - so we don't need to worry about uh
578:10 - sharing the
578:12 - price and if they didn't reveal then we
578:15 - add the total price the total of bids to
578:17 - the amount to share then we divided the
578:20 - amount by the number of people who View
578:21 - field we send it to the user and we
578:23 - delete that user from the players to
578:26 - make sure they cannot claim
578:28 - again then we have a test where we have
578:30 - a few people play commit their hash of
578:34 - their numbers then reveal them and some
578:37 - don't reveal and then the winner can
578:40 - climb their price Etc it's a small test
578:43 - in a real test you need to do a lot more
578:45 - than this to check all the different
578:47 - possibilities we can give it a try and
578:50 - we see that everything
578:52 - works all
578:54 - good now the issue with this approach of
578:58 - using Financial incentives to force
579:00 - people to reveal is that the amount they
579:02 - need to deposit should be similar to the
579:05 - total amount that they may win but in a
579:08 - ruffle if you imagine a big ruffle where
579:11 - there's thousand players and a million T
579:13 - to win very few people would have the
579:16 - means to put a million Tes as a deposit
579:20 - and if they did probably wouldn't want
579:22 - to risk it just for a small raffle where
579:24 - they have a small chance of winning so
579:27 - Financial intensive work if it's a small
579:30 - raffle if it's a deposit can be small
579:33 - enough but in some cases the deposit
579:36 - itself makes it unlikely that people
579:38 - will take part so we need a better
579:41 - solution and for that we will use
579:44 - cryptography so the solution is to force
579:47 - people to reveal or at least make sure
579:50 - that their number is re reveal by using
579:52 - cryptography and A cryptographic
579:54 - Primitive called time lock in a sense
579:57 - it's using Brute Force to reveal number
580:00 - for them for people who didn't reveal
580:02 - themselves and time lock is a
580:05 - cryptographic primitive that we will use
580:07 - instead of a hash so instead of hashing
580:10 - and sending the hash of the number we
580:11 - picked we send a time lock of that value
580:15 - and the time lock has the properties
580:18 - that it's like an encryption mechanism
580:21 - but where if you are given enough time
580:23 - anyone can actually decrypt it but it
580:26 - has the property that if you only have a
580:28 - certain number of minute let's say x
580:30 - minutes we could say 10 minutes then
580:32 - nobody will be able to crack it and and
580:35 - decrypt it without the private key even
580:37 - if you have the most powerful computer
580:39 - in the world even if you have a
580:40 - specialized ASC so A specialized
580:43 - Hardware dedicated to decrypting time
580:46 - locks or even you have fpga that you
580:49 - program to decrypt time locks really
580:51 - fast
580:51 - you still won't have time to decrypt it
580:54 - in this number of minutes on the other
580:57 - hand if you have enough time let's say
581:00 - 100 times that amount then anyone can
581:03 - decrypt it even with a regular computer
581:06 - without the private key and so the idea
581:09 - is that the encryption algorithm takes a
581:11 - number of iterations on a single
581:13 - processor you cannot paraliz the
581:14 - computation so you cannot use hundreds
581:17 - of computers in the data center you have
581:20 - to use a single processor
581:21 - and so given enough time whatever
581:24 - computer you have you will be able to
581:26 - decrypt it so this duration of how long
581:28 - it takes at the minimum with the fastest
581:31 - possible computer you may find has to be
581:34 - more than the amount of time people have
581:37 - in the commit phase so that between the
581:39 - time the first person commits their
581:42 - number and the time that the last person
581:44 - can commit theirs this amount of time
581:47 - should be shorter than the smallest
581:49 - amount that anyone with a fastest
581:51 - computer will need to cck the time lock
581:54 - cck the chest and find out what your
581:58 - number was then has to be still small
582:01 - enough that during the reveal phase if
582:03 - somebody didn't reveal somebody with a
582:06 - regular computer can correct the value
582:09 - in a reasonable amount of time let's say
582:11 - 10 hours and reveal for that person and
582:15 - the idea is that if somebody doesn't
582:17 - reveal then someone else can reveal for
582:20 - them and be rewarded so there's really
582:23 - no point for someone to not reveal
582:26 - because they will lose their deposit and
582:28 - someone will reveal their number for
582:30 - them anyway and be rewarded for doing
582:33 - that computation so you gain no benefit
582:36 - in not revealing your number so with
582:38 - this approach we can have a commit and
582:40 - reveal system where we make sure that
582:44 - everybody's value is revealed and we
582:46 - find the right in this module we will
582:48 - talk about re-entrancy flaws it's a type
582:51 - type of flaw that is particularly hard
582:53 - to detect but easy to prevent
582:56 - re-entrancy bugs happen when the
582:59 - contract calls another contract and then
583:01 - that other contract calls the original
583:04 - contract again in such a way that it
583:06 - breaks the assumptions you make in this
583:08 - original contract there was a very
583:11 - famous re-entrancy attack that caused
583:14 - the da hack on ethereum in June
583:17 - 2016 and that attack was so serious that
583:20 - it eventually led to the fork of
583:22 - ethereum into the current ethereum and
583:25 - ethereum classic as the community split
583:28 - between deciding to rewrite history to
583:32 - avoid the attack or simply accept it
583:34 - with ethereum Classic on tesos the
583:37 - languages are designed in such a way
583:40 - that reentrancy bugs are less likely but
583:45 - we will see that rency bugs are still
583:47 - possible on tesos we will also see a way
583:51 - that we can prevent them we'll take an
583:53 - example where we have two contracts that
583:56 - manage unique tokens identified by the
583:58 - ideas the first contract is a ledger
584:01 - contract that simply keeps track of who
584:04 - owns each token so it has an admin
584:07 - contract that can collect and make
584:09 - changes and it simply stores a big map
584:12 - of tokens with the token ID as a key and
584:16 - the address of the owner as a value then
584:18 - we have an unchain view to obtain in the
584:21 - current owner for a given token idea and
584:24 - then an entry point to change the owner
584:26 - of a given token idea to a new owner and
584:29 - only the admin contract is able to
584:32 - change this owner then we have a
584:35 - purchaser contract that is the admin of
584:39 - The Ledger contract and this purchaser
584:41 - contract is simply in charge of
584:43 - purchasing tokens are predefined prices
584:47 - so we store the address of The Ledger
584:49 - contract and in a big map a list of
584:51 - prices so for each token idea we store
584:55 - the corresponding price and that's the
584:57 - price at which the purchaser is willing
584:59 - to buy a given token then the owner of a
585:03 - token is allowed to call the apply offer
585:07 - entry point for a given token idea say
585:10 - okay I'm willing to sell you that token
585:12 - at the price you listed so we check that
585:15 - the caller is indeed the owner of the
585:18 - token by calling this view get token
585:20 - owner
585:21 - of The Ledger then the contract sends
585:23 - the corresponding price to the caller
585:26 - and one thing to keep in mind is that
585:28 - the transfer of test is not immediate
585:30 - but we create a transfer that will be
585:32 - executed after this entry point is over
585:36 - then we call the change owner entry
585:39 - point of The Ledger to say okay I'm the
585:42 - new owner so the purchaser contract
585:44 - becomes the new owner of token ID and
585:47 - again we add this to the list of
585:49 - operations to execute after the end of
585:52 - this entry point with that in mind can
585:54 - you figure out how this contract could
585:57 - be attacked and by attacked we mean how
586:00 - could funds or assets be stolen from
586:03 - this contract or get stuck in this
586:05 - contract pause the video and think about
586:08 - it for a minute so the key idea of the
586:10 - attack is to call this apply offer entry
586:14 - point twice and get paid twice before
586:18 - the ownership change actually
586:21 - happens so while apply offer is taking
586:26 - place and all its consequence is taking
586:28 - place but before the actual change to
586:30 - the owner is made we call apply offer a
586:33 - second time note that on a blockchain
586:36 - you cannot run two transactions in
586:39 - parallel if a user simply creates two
586:42 - transactions to call apply offer twice
586:45 - the first goal will be completely over
586:47 - before the second one can be executed we
586:49 - don't have concurrent execution of
586:52 - different transactions so you never need
586:54 - to worry about that but it's still
586:56 - possible to have a call to apply offer
586:59 - before the owner is changed can you
587:01 - figure out how this can be done pause
587:04 - the video and think about it for a
587:06 - minute so let's look at the code of an
587:09 - attacker contract so we will assume that
587:12 - the contract below is the owner of the
587:15 - token with ID 42 and we also assume that
587:19 - the purchaser contract list this token
587:22 - for a price of 100 T so it's ready to
587:25 - purchase it for 100 T and then we will
587:28 - call attack attack of the purchaser with
587:31 - token idea 42 in the storage we will
587:34 - store a number of calls and the token
587:37 - idea for the token that we are trying to
587:40 - attack during the attack we set the
587:42 - number of calls to two we'll talk about
587:44 - why in a minute and we store the token
587:46 - idea and then all we do is accept the
587:50 - offer by calling purchaser do apply
587:53 - offer saying yes I'm willing to sell you
587:55 - my token 42 for the price listed which
587:58 - is 100 T so far nothing special you
588:02 - simply have a contract that accepts the
588:03 - offer from the purchaser contract but
588:06 - the trick is to also have a default
588:09 - entry point in this attacker contract
588:12 - and to have this default entry point
588:15 - also call apply offers and the idea is
588:18 - that we accept the offer a second time
588:20 - before before the ownership of our token
588:23 - is transferred to the purchaser and to
588:26 - avoid doing that indifferently since
588:28 - when we accept the offer a second time
588:31 - the purchase contract will again send us
588:34 - 100 Tes and call the default entry point
588:37 - again and So to avoid an infinite
588:39 - recursion we have this NB call variable
588:42 - in the storage that we set initially at
588:44 - two and every time the default entry
588:46 - point is called we decrement it by one
588:49 - and when it reaches zero we stop calling
588:51 - apply offer so in practice we only call
588:53 - it twice we call it here the first time
588:56 - and then the first time we receive 100 T
588:58 - then we'll call it again but the second
589:00 - time we receive 100 T we don't call it
589:03 - anymore so this contract uses
589:05 - re-entrancy to steal 100 test from the
589:08 - purchaser contract again the idea is
589:10 - that when the attacker calls apply offer
589:14 - for the token ID 42 so the attacker is
589:17 - indeed the owner of token 42 we send
589:21 - TZ to this attacker but you have to keep
589:24 - in mind that we don't directly transfer
589:26 - TZ we add a transaction to the list of
589:29 - transactions that will be executed after
589:31 - we execute apply offer then we add
589:34 - another transaction to this list which
589:36 - is to call The Ledger to change the
589:39 - owner of that token to ourself to the
589:42 - purchaser contract those two
589:44 - transactions are added to a stack of
589:47 - transactions to execute after the apply
589:49 - offer and point is completed so once
589:52 - it's completed we take the top of the
589:55 - stack which is this transaction we
589:58 - transfer 100 test to the caller but we
590:00 - also call the default entry point of the
590:03 - attacker which then create another call
590:06 - that will be added at the top of the
590:08 - stack and that calls apply offer a
590:11 - second time and when apply offer is
590:14 - called a second time we check that the
590:16 - owner is the caller and it's still the
590:18 - case because we haven't changed the
590:19 - ownership yet then we will add two
590:22 - transactions to the stack at the top of
590:25 - the stack we will add a transaction to
590:27 - transfer 100 test to the attacker again
590:30 - and then right below it another call to
590:33 - change the ownership of the token to the
590:36 - attacker then we execute the transaction
590:39 - at the top of the stack which is to
590:41 - transfer 100 test to the caller call the
590:43 - default entry point but this time NB
590:46 - calls gets to zero so nothing happens
590:49 - and then finally we have have this call
590:52 - to change the ownership of the token to
590:55 - the purchaser that was added to the top
590:57 - of the stack by the second apply offer
591:00 - call and then finally we have the same
591:03 - one but this one that was created by the
591:05 - first call to apply offer so let's look
591:08 - at the succession of steps that happen
591:11 - in detail we first have the call to our
591:14 - attacker contract to say okay let's
591:16 - attack this purchaser contract and try
591:19 - to steal funds through through the token
591:21 - we owned so token ID 42 this creates a
591:24 - call to the apply token entry point of
591:27 - the purchaser saying yeah I accept the
591:29 - offer to sell token ID 42 to you then
591:33 - this applyer offer entry point is
591:35 - executed at first time it checks that
591:37 - the call is the owner it creates a
591:39 - transfer of handes to the attacker and a
591:43 - call to the change owner entry point of
591:46 - The Ledger then for the first call the
591:48 - default entry point is executed
591:50 - decrements the NB calls from 2 to one
591:55 - creates a call to purchaser apply offer
591:58 - of 122 and while it does that hand has a
592:01 - transfer from the purchaser contract to
592:03 - the attacker contract then the second
592:05 - call to apply offer is executed it
592:08 - checks that the caller is still the
592:10 - owner so the attack contract and creates
592:12 - a second transfer of 100 test to the
592:15 - attacker then a second call to change
592:18 - owner so this one against is executed
592:21 - first which calls the default entry
592:23 - point that thec end to zero so nothing
592:26 - else happens but 100 Tes are transferred
592:29 - from the purchaser to the attacker again
592:32 - and finally we execute the change owner
592:35 - call that was created here in the second
592:37 - call to apply offer so we set the
592:40 - ownership of the token to purchaser and
592:43 - then we have finally the initial call to
592:46 - change owner that is executed that sets
592:48 - the ownership to the token again to
592:51 - purchase her a second time in the end
592:53 - the attacker contract received 200 Tes
592:56 - from a token that was priced at 100 T so
592:58 - it stole 100 T from the purchaser
593:01 - contract if we had initially set n be
593:03 - calls to 10 it would have stolen 900 T
593:06 - from the purchaser contract by accepting
593:08 - the offer 10 times before before
593:11 - transferring the ownership of the token
593:13 - to the purchaser contract so the
593:15 - question is how can we avoid this type
593:17 - of flaw so you have to keep in mind that
593:19 - what makes this flaw possible and hard
593:21 - to detect is that a new call to the
593:23 - purchase contract can be initiated in
593:26 - the middle of the execution of its
593:27 - different steps and Our intention in the
593:31 - purchas contract was to Simply send
593:33 - usest to the seller and then take
593:34 - ownership of the token but what really
593:37 - happened is that we sent test to the
593:39 - seller but then the seller did all kinds
593:42 - of things including trying to sell its
593:44 - token a second time and only after that
593:47 - did we take ownership of the token so
593:49 - with that in mind how can we avoid this
593:51 - type of flaw pause the video and think
593:53 - about it for a minute so the first
593:55 - approach is to Simply order the steps of
593:58 - your contract in a safe way and the idea
594:01 - is to start with the steps that will
594:03 - prevent future similar calls so in our
594:07 - example we could have avoided the flaw
594:09 - by swapping these two instructions so
594:11 - the instruction to send the 100 test to
594:14 - the caller and instruction to change the
594:17 - ownership to the purchase contract if we
594:20 - simply changeed the ownership first and
594:22 - then transferred hand test to the caller
594:24 - then during that transfer any call to
594:27 - accept the offer again would have been
594:29 - rejected because the attacker contract
594:30 - wouldn't be the owner anymore so this
594:33 - approach can work if you're really
594:35 - careful you make all the changes that
594:37 - will prevent future calls first and then
594:40 - the consequences and in particular
594:42 - transfers of TZ afterwards it's possible
594:45 - to avoid them but as contracts become
594:47 - more complex it can become really hard
594:50 - to be 100% sure that you cover all cases
594:54 - and that no re-entrance attack can
594:56 - happen so there's a second approach that
594:58 - is a bit more radical and that simply
595:00 - prevent any re-entrancy at all and
595:03 - therefore any re-entrancy attack the
595:05 - idea is to use a Boolean flag for
595:07 - example we can call it is running that
595:09 - we put in the storage of the contract
595:12 - and that will be said to True while the
595:14 - contractor is being used so that it
595:16 - cannot be called a second time and so
595:19 - the entry point will have this structure
595:20 - we first check that is running is false
595:24 - then we set is running to true then we
595:26 - do all the logic including creating
595:28 - calls to other contracts transfer of
595:30 - test Etc and then we call an entry point
595:34 - that set is running to false it's
595:36 - important to do it through a call to an
595:38 - entry point that simply set is running
595:40 - to fals because all of these calls
595:43 - created here all this transfers will
595:45 - happen after the end of the execution of
595:47 - our entry point so we cannot just simply
595:49 - set it to false again we have to call an
595:52 - entry point that will set it to false
595:55 - after all the consequences of this
595:58 - section will be done if we look at the
596:00 - fixed contract it will look like that in
596:03 - apply offer we first check that is
596:05 - running in false then we set it to true
596:09 - then we check that the caller is the
596:10 - owner of the token that we are trying to
596:13 - purchase then we change the ownership of
596:16 - the token to ourselves so the purchase
596:19 - or contract then then we transfer her
596:21 - test to the color and then finally we
596:24 - call stop running that will check that
596:27 - the color itself so that no one else can
596:29 - change the value of is running and then
596:32 - we set is running to false so this way
596:35 - apply offer can't be called during the
596:38 - transfer of test to the attacker and the
596:40 - attack would
596:41 - fail here we can look at a more complete
596:44 - version of this attack and test it we
596:48 - have this Ledger that's stes tokens and
596:52 - has
596:52 - anmin we can Min tokens then check the
596:55 - ownership of a current token or change
596:58 - the owner or token then we have our
597:00 - purchaser contract that has a list of
597:03 - offers here we have a system of escrow
597:06 - so you put funds in a processor contract
597:10 - in case somebody wants to sell the token
597:13 - to you the buyer has the funds available
597:16 - in an escroll big map in the purchase
597:19 - contract
597:21 - then when someone accepts an offer we
597:23 - send the price to the current owner of
597:26 - the token and then we call change owner
597:29 - to change the ownership and we can see
597:31 - here the attacker contract that does
597:34 - exactly what we said we initialize and
597:36 - calls at zero we call the accept offer
597:40 - entry point of the purchaser contract
597:42 - and in the default entry point we
597:45 - decrement and be calls and if it's
597:47 - greater than zero then we call accept
597:49 - offer again and if we run a test that
597:53 - has an attack for token ID
597:57 - one then we can look at the
598:00 - details and see that we get 100es
598:04 - transferred twice once here and once
598:07 - here so the attack worked in this module
598:10 - we will look at an auction contract that
598:13 - has multiple flaws and your goal will be
598:15 - to find the flaws in this contract let's
598:18 - take a look at this auction contract in
598:21 - the storage we will store a map of
598:24 - tokens each token will store the
598:26 - metadata of the nft and the current
598:29 - owner and the key will be a token ID
598:32 - that will start at one and that we
598:34 - increment every time someone meets a new
598:37 - nft then we have a map with all the
598:39 - options where the key is the IDE of the
598:42 - token that is put for auction people can
598:46 - mint nfts using the mint entry point
598:49 - that pass the data of the NFD they want
598:51 - to Mint we check that they pay a fee of
598:55 - one TZ to Mint that will be used to fund
598:58 - the website and the advertisement
599:01 - everything to bring users to this
599:04 - project and then we simply add an entry
599:07 - to the tokens map that will contain the
599:10 - metadata and the initial owner of the
599:13 - nft then we increment the token
599:17 - ID once somebody wants to open that
599:19 - auction for a given token they provide
599:23 - the token ID and a deadline for the
599:25 - auction that means people will have anth
599:27 - this deadline to bid and the highest
599:31 - bidder will become the new owner of that
599:33 - token so in this entry point we store
599:36 - that the caller is the seller we store
599:39 - the deadline we store the current top
599:42 - bid and here instead of using an option
599:44 - to set that there isal top bid we simply
599:47 - set it at zero and we say that the top
599:50 - bidder is the cender so whoever is
599:52 - putting the item on auction bids zero
599:55 - but then anyone can bid so that if
599:58 - nobody bids anything then they can get
600:01 - the ownership of the token
600:03 - back then once somebody bids for this
600:06 - token they indicate what token ID they
600:09 - bid for we get the data of the
600:11 - corresponding option we check that
600:14 - they're bidding more than the current
600:16 - top bid for this nft and we check that
600:19 - they bid before for the deadline so
600:21 - since they bid more than the current top
600:23 - bidder we send the amount that the
600:26 - previous top bidder have bid back to
600:29 - them and then we set the new top bid to
600:32 - be the amount sent by this sender and
600:35 - then they become the new top bidder and
600:38 - we save it back into the map finally
600:41 - after the deline the seller can claim
600:44 - the top bid and get the funds while
600:47 - transferring the ownership of the token
600:49 - to the top bid
600:50 - so we fetch the auction object we check
600:55 - that this is after the deadline we check
600:58 - that the caller is the seller of the
601:00 - token we send them the value of the top
601:02 - bid and we change the owner of the nft
601:06 - to the top bidder now your job is to
601:08 - find all the bugs from this contract and
601:12 - there are at least seven bugs in this
601:14 - small
601:15 - contract pause the video and give it a
601:18 - try
601:20 - so for the first bug I will give you a
601:23 - hint remember that if the storage of a
601:26 - smart contract gets too big the time it
601:29 - takes to derealize all of the data in
601:32 - the storage before any contract call and
601:36 - then res serialize it after the end of
601:38 - the entry point May exceed the amount of
601:40 - gas that you can spend in a transaction
601:43 - so it's always important to think about
601:46 - how large the storage can be and make
601:48 - sure there is no risk of exceeding that
601:51 - maximum amount of gas to spend in a
601:53 - transaction so with that in mind can you
601:56 - figure out what the issue is pause the
601:58 - video and think about it for a
602:01 - minute so the issue here is that we used
602:04 - maps to store the nfts themselves and to
602:08 - store the information about the auctions
602:11 - but maps are stored directly in the
602:13 - storage which means the serializing them
602:16 - takes an amount of gas that is
602:18 - proportional to the number of entries so
602:20 - as people mint more and more tokens and
602:22 - put them into more and more auctions the
602:25 - size of the storage that you need to
602:26 - distalize will get bigger and the gas
602:29 - could exceed the maximum amount you can
602:31 - spend in the transaction so this is bug
602:33 - number one and to fix it all we need to
602:35 - do is change these into big Maps like
602:39 - this and this as big map are serialized
602:44 - and deserialized On Demand there always
602:46 - the data structure you need to use for
602:49 - any data I can keep growing indefinitely
602:52 - a second bug is in the open auction
602:56 - entry point there's actually two bugs in
602:58 - this entry point because we don't need
603:01 - nearly enough
603:02 - verifications so pause the video and
603:04 - focus on that entry point for a
603:07 - minute the first bug in this entry point
603:11 - is that we never check that the sender
603:14 - who is trying to sell this token in an
603:17 - auction is actually the owner of the
603:20 - corresponding entry point and we don't
603:22 - even check that this token exists so we
603:25 - need to start by checking is the color
603:28 - the actual owner of this so we can write
603:31 - assert of.
603:37 - data so we
603:40 - check that the owner of this token is
603:43 - the cender so they're allowed to sell it
603:47 - this automatically checks that this
603:49 - token exists otherwise this would fail
603:51 - anyway so we don't have to add an extra
603:53 - verification to check that this token ID
603:56 - exists for the next issue you can use a
603:59 - method that I always recommend to apply
604:01 - when proofreading a smart contract which
604:04 - is to think about what would happen if
604:07 - somebody calls a given entry point twice
604:11 - with the same information so let's
604:13 - imagine that we call open aution a first
604:16 - time with a given token ID for example
604:19 - 20
604:20 - and the deadline so we first check that
604:23 - the caller is the owner of the token 20
604:27 - and then we create a record and save it
604:31 - in the big map for the key token it here
604:34 - then if we call open auction again with
604:36 - the same parameters we will again check
604:39 - that the sender is the owner but then we
604:41 - will overwrite the previous auction with
604:44 - a new record so in this case it's fine
604:46 - we just redo the same thing but if in
604:49 - the mid time somebody has bid for this
604:52 - auction then we lose all the information
604:55 - about the top bidder and the top Bid And
604:58 - so basically any funds that any bidder
605:01 - has sent to the contract would be lost
605:04 - because they're not recorded as the top
605:06 - bidder anymore and they won't be
605:07 - reimbursed if someone else bids Etc so
605:11 - here we have a clear bug that the owner
605:13 - of a token can basically cancel
605:16 - everything that has happened with an
605:18 - auction by creating in a new auction so
605:21 - to fix this we need to verify that there
605:24 - is no auction going on for this token so
605:27 - we
605:30 - assert that self data
605:37 - auctions does not
605:40 - contain the token ID the next bug that
605:44 - is reasonably easy to find is on the
605:48 - claim top bit
605:50 - entry point so focus on this and try to
605:53 - use the techniques that we presented
605:56 - thinking about what happens if we call
605:59 - an entry point twice but also what
606:02 - happens if we don't call an entry point
606:05 - if the person supposed to call it
606:06 - doesn't call it pause the video and
606:08 - think about it for a
606:10 - minute so here the issue is if somebody
606:14 - doesn't call the entry point we can see
606:17 - that here we expect the seller so the
606:20 - owner of the token to call claim tub bid
606:24 - but the seller may not call it for a
606:28 - number of reasons it could be because
606:30 - they're not available because they
606:31 - forgot or it could be for nefarious
606:34 - reasons for example they could say well
606:37 - I'm not happy with the auction I feel I
606:39 - want to get more than the current top
606:42 - bid so since I have their money stuck in
606:45 - the contract anyway I will try to
606:47 - pressure them to to give me more money
606:49 - if they don't well too bad their money
606:51 - is stuck they don't get the nft and
606:54 - that's their problem I don't lose
606:55 - anything so somebody could pressure the
606:58 - top bidder to try to distort a bit more
607:01 - money for example and it's always the
607:03 - case when somebody needs to do something
607:05 - we have to trust that they will do it
607:07 - and if we depend on them to do it then
607:09 - they have some leverage over us so it's
607:12 - not good to require that the seller call
607:15 - this entry point the whole point of a
607:17 - blockchain is that we don't want to have
607:19 - to trust someone to do something so here
607:22 - we could say well maybe the top bidder
607:24 - themselves could also run this entry
607:27 - point and so if the seller doesn't do it
607:29 - then the top bidder will do it so we can
607:32 - add here or SP sp. sender equals top
607:35 - bidder but we actually don't really care
607:37 - who calls this entry point so we can
607:39 - simply delete this line and as long as
607:42 - somebody calls it then everything is
607:45 - good the next bug is actually a bug that
607:48 - we now have in in two places we have it
607:51 - both in this entry point and in this
607:54 - entry point the version in this entry
607:56 - point is the most dangerous one because
607:59 - somebody could really steal all of the
608:02 - tokens that are P for sale through this
608:04 - auction contract so try to focus on this
608:08 - entry point and think about a way that
608:10 - somebody could steal all of the tokens
608:14 - are put for auction pause the video and
608:17 - think about it for a minute
608:20 - so here I may give you another hint when
608:23 - you send funds to an address if it's a
608:26 - regular cheesy address of a basic
608:28 - account you simply send the TZ to that
608:32 - user address but if the address is that
608:34 - of a smart contract then what happens is
608:37 - that this calls the default entry point
608:41 - of the contract while sending the test
608:43 - to that smart contract if the smart
608:46 - contract doesn't have a default entry
608:47 - point the transaction fail if it has a
608:50 - default entry point but the default
608:52 - entry point fails then the transaction
608:55 - fails so for a contract to be able to
608:57 - receive direct transfers using sp. send
609:01 - and without explicitly calling a smart
609:04 - contract it needs to have a default
609:06 - entry point like
609:14 - this that for example doesn't do
609:17 - anything so when you try to turn
609:19 - transfer some test to this contract with
609:22 - sp. send it will call default it
609:25 - shouldn't have any parameters otherwise
609:27 - it's not the right entry point and it
609:28 - will fail and it shouldn't fail so here
609:31 - we put pass so it doesn't do anything
609:35 - and doesn't fail but if the destination
609:39 - of this transaction either doesn't have
609:41 - a default entry point or has a default
609:43 - entry point that maybe checks for
609:45 - Boolean something like that and maybe
609:48 - has another entry point point that
609:50 - allows them to change the value of
609:52 - accept test then they would be able to
609:54 - control at any time if they allowed
609:57 - transfers of test to them or not so here
610:00 - if the top bidder is the address of a
610:02 - contract with this kind of default entry
610:04 - point that has a Boolean to accept or
610:07 - reject transfers of Tes they could bid
610:11 - for the nft with a very small amount as
610:13 - soon as the nftd is put for auction then
610:16 - they could set this to false to to
610:19 - reject any future transfers of test if
610:22 - somebody else bits a higher amount for
610:24 - the same token idea we will check yes
610:26 - they bit more yes it before the deadline
610:28 - but then when we try to reimburse the
610:30 - previous St bidder that previous St
610:32 - bidder would reject the transfer and
610:35 - therefore this new bid would fail and
610:38 - then this initial bidder who's trying to
610:40 - steal the token just has to wait until
610:42 - the deadline and then claim the top bit
610:45 - and get the nft so with this we have a
610:48 - system for anyone to bid a very small
610:51 - amount and then prevent anyone from
610:54 - bidding above them until finally they
610:56 - get the item so it's really important to
610:59 - be very careful every time you have an
611:02 - entry point that calls sp. send
611:04 - especially if you're not sending Tes to
611:07 - the colar of the entry point itself we
611:09 - have the same issue here here we sending
611:13 - Tes to the seller but the seller could
611:15 - be the address of a smart contract that
611:17 - has a default entry point that may or
611:19 - may not accept TZ and they could use
611:22 - that as a way to prevent anyone from
611:24 - calling the claim to bid entry point and
611:26 - finalizing the transaction so we have
611:29 - the same issue here and here and this
611:31 - issue is an issue we can have quite
611:33 - often in smart contract you should be
611:34 - really careful anytime you call sp. S
611:39 - now what do you think the solution would
611:40 - be to fix this issue pause the video and
611:44 - think about it for a
611:46 - minute so one solution people often
611:48 - think about is to prevent contracts from
611:52 - bidding or prevent contracts from trying
611:54 - to sell Etc so if we know that this is
611:57 - not the address of a smart contract then
611:59 - we know that it's impossible to block
612:01 - the transfer but preventing smart
612:03 - contracts from using your smart contract
612:06 - is really cutting yourself from a lot of
612:08 - potential use cases for example no
612:12 - entity that is using a multi-seed
612:14 - contract to collectively take decisions
612:17 - on how to use their assets would not be
612:20 - able to use your contract there's many
612:23 - occasions where we don't want to
612:25 - directly interact with a contract with a
612:27 - TZ address but instead through a smart
612:30 - contract so I really don't recommend
612:32 - testing if the caller is a smart
612:35 - contract or a regular user account an
612:37 - implicit account instead what we want is
612:41 - to let the top beider here and let the
612:43 - seller here get their friends back
612:46 - themselves through a separate entry
612:48 - point but for that we need to use a
612:51 - ledger that keeps track of how much the
612:54 - contract owes to each
612:57 - user so here we will add a big
613:02 - map
613:05 - Ledger where the key will be the user
613:08 - and the value will be the amount that
613:10 - the contract owes to
613:13 - them so here instead of sending test we
613:18 - check if there's already an entry for
613:20 - that
613:37 - user so if it doesn't exist we create
613:40 - the entry
613:49 - with zero T and then we add the amount
613:54 - that we wanted to send
613:59 - them like this and we also need to add a
614:04 - claim entry
614:09 - point where we
614:12 - send to the
614:14 - color the amount that is in The Ledger
614:17 - for them
614:23 - and then we delete the
614:29 - entry and here in claim to bid we can do
614:33 - the same thing I'll just copy
614:40 - this but here it's going to be action
614:43 - auction seller
614:50 - and that's it so that's fixing the next
614:52 - bud so it's really it's a good habit to
614:56 - to have a ledger in your smart contract
614:59 - so that instead of directly sending test
615:02 - to different addresses you just keep it
615:04 - in The Ledger and you let people
615:06 - withdraw the funds through a claim entry
615:08 - point the next bug is in claim Tob bid
615:13 - and again think about what happens if
615:15 - you call the same entry point twice
615:18 - pause the video and think about it for a
615:21 - minute if we call claim Tob Bild the
615:24 - first time let's say for 2
615:27 - id20 we check that the deadline to be is
615:31 - passed we send the amount of the top bed
615:34 - to the seller Through The Ledger and
615:37 - then we change the ownership of the
615:39 - token to the top bidder now if we do it
615:43 - again we call claim top bid a second
615:45 - time with the same parameter 20 then we
615:49 - do everything again we check it still
615:51 - past the deadline but then we transfer
615:54 - the amount of the top bit again to the
615:56 - seller the seller didn't change then we
615:59 - assign the ownership of the nft again to
616:01 - the top bid so this doesn't change
616:03 - anything but here we add the top bid a
616:06 - second time to the seller so the seller
616:09 - could keep calling this entry point many
616:11 - times and get the amount from the top
616:13 - bit again until the balance of the
616:16 - contract is lower than the top bit by
616:19 - doing that basically the seller would
616:21 - steal funds from top biders of other
616:24 - auctions that are currently ongoing to
616:27 - avoid this we can delete the entry so
616:30 - that the entry point cannot be called
616:32 - again and maybe another auction can be
616:36 - set later the last bug that I know of is
616:42 - related to The Mint entry point and to
616:45 - the fact that we charge one test for
616:47 - someone to Mint and through this
616:49 - contract pause the video and think about
616:51 - what the issue could be with that here
616:54 - are the issues that we have accumulated
616:57 - TZ in the balance of the contract but
617:00 - the owner of the smart contract whoever
617:03 - is managing the website that goes with
617:05 - the smart contract has absolutely no way
617:08 - to get this money so they may look at
617:11 - the contract see yes many people are
617:13 - minting nfts and accumulating money Etc
617:16 - until one day when they say Okay I want
617:18 - to use this money for something else to
617:20 - pay for some developer some marketing
617:23 - Etc then they realize that they have
617:25 - absolutely no way to get the Tes out of
617:28 - the contract this may sound silly but
617:30 - this kind of issues forgetting to create
617:33 - an entry point to get the money out of
617:35 - the contract is something that has
617:36 - happened to multiple companies with
617:39 - their smart contract so when you test
617:41 - your smart contract make sure you test
617:43 - the whole life cycle of the contract
617:46 - including the time where you want to get
617:48 - the money out
617:49 - so here there's an very easy way to fix
617:51 - that which is to Simply add these T to
617:55 - The Ledger but for that we need to
617:58 - specify who the owner of the smart
618:00 - contract is so we have to specify an
618:03 - owner and store
618:07 - it as there is no default owner of a
618:11 - smart contract just because you deploy
618:13 - the smart contract doesn't make you the
618:14 - owner so we have to store it in the
618:16 - storage there is really no default
618:18 - notion of owner that we can access to so
618:21 - here as soon as we get the
618:27 - one so here we can use this piece of
618:31 - code
618:31 - [Music]
618:46 - again and we add one test to the The
618:51 - Ledger you may notice that I have copied
618:54 - the same piece of code multiple times
618:57 - and there is a way to put it in the
618:58 - function but we will see it later in the
619:01 - module about Lambda so for now we simply
619:04 - copy this piece of code in each of the
619:06 - smart contract that uses it and that's
619:08 - it to recap we found seven flaws in our
619:13 - simple auction smart contracts we forgot
619:16 - to check that the seller of an nft was
619:18 - actually the owner of that nft there was
619:21 - a way for a bidder to bid a very small
619:24 - amount and then prevent anyone else from
619:26 - out bitting them and therefore making
619:29 - sure they could win the auction with a
619:31 - very small price and therefore stealing
619:33 - all the tokens we noticed that the
619:36 - seller could never call claim top bid
619:40 - and maybe use this as a way to extort
619:42 - money from the top bidder so if we fix
619:45 - that we also notice that the seller or
619:48 - anyone could call claim top bid multiple
619:51 - times and steal t from other auctions
619:55 - and we noticed that the admin the owner
619:57 - of the contract could never claim their
619:59 - earnings so we added a way for them to
620:02 - do that through the Ledger we also
620:04 - noticed that the usage cost of the
620:07 - contract was increasing little by little
620:10 - as people created new tokens Etc in the
620:13 - map in the storage until the contract
620:15 - would be completely stuck once the
620:18 - amount exceeded the total amount of gas
620:21 - we can spend in a transaction and we
620:23 - simply fix that by using big maps and
620:26 - finally we noticed that it was possible
620:29 - for a seller to delete an auction and
620:32 - everything that was already bid by
620:34 - overwriting the auction with a new one
620:37 - so you can see that in a very small
620:39 - smart contract it's quite easy to have
620:41 - many different bugs and so it's very
620:44 - important not only to test very
620:46 - carefully have people other than
620:48 - developer proof fre the contract and
620:51 - also go through checklists and making
620:53 - sure you don't have any of the typical
620:55 - bugs we just presented on
620:58 - open.com we have a page about all the
621:01 - typical flaws we can have in smart
621:03 - contracts and you can use that page as a
621:05 - checklist when you review your own
621:07 - contract in this video we will talk
621:09 - about the type of contract used in
621:11 - decentralized finance called flash loan
621:15 - and we will see that with a flash loan
621:17 - you can become temporarily very
621:20 - rich so we'll start with an
621:23 - exercise in a previous module about sets
621:26 - we presented a membership contract that
621:29 - only rich people could join and the way
621:32 - we did that was that the join entry
621:34 - point that people had to call in order
621:36 - to join this club required you to
621:38 - transfer a large amount of TZ to the
621:41 - contract that the contract will then
621:44 - reimburse you so in order to join the
621:46 - club you needed to have access to a
621:49 - large amount of money so the question
621:51 - for this exercise is let's say you don't
621:54 - have access to a large amount of funds
621:57 - is there a way you could still join this
621:59 - club pause the video and take a minute
622:01 - to think about how you could create a
622:03 - smart contract that would make this
622:05 - possible so the solution is that you
622:08 - have to borrow some
622:09 - Tes and so the idea is to create a
622:11 - contract that can lend TZ to users and
622:15 - of course users would have to pay back
622:18 - later with some interest so the question
622:21 - is how can you have a contract that
622:23 - lends you money but then makes sure that
622:26 - the user will pay back pause the video
622:29 - and think about it for a minute so the
622:31 - usual way that even Banks use to reduce
622:35 - the risk when they lend you money is
622:37 - that you have to have some kind of
622:39 - collateral it could be a house it could
622:41 - be anything on the blockchain is
622:43 - typically money but in a different
622:45 - currency so let's say you want to borrow
622:47 - some amount of T let's call it X from a
622:51 - contract we could deposit some amount of
622:53 - token a so a different
622:56 - cryptocurrency that is worth more than x
622:59 - Tes for example it could be 130% of X
623:05 - then in exchange we receive this amount
623:08 - X of Tes then for some amount of time we
623:11 - can use those T but at some point in the
623:14 - future we pay back that amount plus the
623:17 - interest
623:19 - once we do that we can get our deposit
623:21 - back in the token a so the amount we
623:25 - deposited in the token a was never used
623:27 - was never invested or anything it was
623:29 - just kept by the contract so that we
623:32 - could get it back once we returned the
623:35 - amount of
623:36 - Tes one thing to keep in mind when you
623:38 - do that is that the value of token a may
623:41 - change over time it's a different
623:44 - cryptocurrency so the exchange rate
623:46 - between a and the T could vary over time
623:50 - so if the value of your deposit in the
623:52 - form of tokens a becomes so low that
623:55 - it's starting to get close or even lower
623:58 - than the amount that you got the
624:00 - contract can liquidate the loan to make
624:03 - sure it doesn't lose money for example
624:06 - let's say the value of token a gets
624:08 - close to 110% only of xegs then it will
624:12 - use an exchange to exchange your deposit
624:14 - for some T so that's what we call
624:17 - liquidating the loan so this is the way
624:19 - the contract makes sure and no matter
624:22 - what it will get the test back plus some
624:25 - interest either you pay it back or if
624:28 - you don't pay it back or if your deposit
624:31 - is starting to lose value then it will
624:34 - get back the money by liquidating your
624:37 - deposit so this is a type of loan but
624:39 - not the one that would work for us
624:42 - because in our membership contract the
624:44 - whole point was that we want to join but
624:46 - we are not rich we don't have any funds
624:49 - whether it's in form of Tes or another
624:51 - token so we cannot pay in any way and we
624:54 - cannot provide a
624:55 - collateral basically this kind of loan
624:58 - doesn't work if we just
625:00 - poor so if a user doesn't have any funds
625:04 - how could someone lend to them without
625:06 - taking a risk so I can give you a hint
625:10 - in our situation we only need the money
625:12 - very briefly so how could we do that
625:15 - pause the video and think about it for a
625:17 - minute so the idea
625:19 - is to do everything in a single
625:21 - transaction in the same transaction we
625:24 - could borrow money from a contract then
625:27 - use that money to join the membership
625:30 - contract and then immediately get it
625:31 - back then we could pay the money back to
625:34 - the contract plus some very small
625:37 - interest if all this is in the same
625:40 - transaction then if we fail to pay the
625:43 - money back then everything will be
625:44 - cancelled right because when it's a
625:46 - single transaction a single contract
625:48 - call if one of the part fails then
625:51 - everything fails and is cancelled so
625:53 - basically the contract never lends you
625:55 - money if you don't actually pay it back
625:58 - so there is no risk for the lending
626:00 - contract so this type of contract where
626:03 - you borrow some funds without any
626:05 - collateral use it immediately and then
626:08 - pay back plus some interest that's what
626:11 - we call a flash loan contract so in a
626:14 - Flash loan the key idea is that funds
626:17 - have to be borrowed bored and repaid
626:19 - within the same
626:20 - transaction so you borrow some amount
626:23 - from The Flash loan contract you use it
626:25 - for any kind of financial operation that
626:29 - generates a profit or at least where you
626:31 - don't lose any money then you repay the
626:34 - funds plus the interest to the flash
626:37 - loan contract and you can keep any
626:40 - profit you made so in the case of our
626:42 - membership contract your profit is
626:44 - simply that you manage to become a
626:45 - member of this membership contract so
626:48 - there's really no risk if anything goes
626:50 - wrong the transaction fails entirely so
626:52 - it's as if nothing has happened which
626:55 - means anybody can be temporarily as rich
626:58 - as needed in particular to profit from
627:01 - an opportunity okay so let's work on the
627:04 - implementation of such a contract think
627:07 - about how you would Implement a simple
627:09 - flash loan contract you have to have an
627:12 - owner who will deposit t on the contract
627:15 - and eventually claim them back when he
627:17 - needs to to those Tes will be used to
627:20 - lend Tes to other people then anyone can
627:23 - borrow these Tes with no limits other
627:25 - than the total balance of the contract
627:27 - so the amount deposited by the owner and
627:30 - then the lender needs to repay the loan
627:32 - with interest in the same transaction so
627:36 - again there is no risk if the lender
627:38 - can't repay the loan the entire
627:39 - transaction is
627:41 - cancelled let's look at the structure of
627:44 - such a smart contract in the storage we
627:47 - would need to have the owner so the
627:49 - person who puts the funds in the smart
627:51 - contract to lend to other people we
627:53 - provide the interest rate so what
627:56 - percentage of the funds you borrow you
627:58 - have to pay on top of reimbursing the
628:00 - loan itself we only need to make one
628:02 - loan at a time since we're going to pay
628:04 - it back right away so there's only one
628:06 - Loan in the flash loan contract so we
628:08 - can store the amount that is being
628:10 - loaned we need to keep track of whether
628:13 - there is actually a loan in progress
628:15 - we'll see why a little bit later we need
628:17 - to know who who borrowed this amount and
628:20 - then we'll need to know if the amount
628:22 - has been repaid then we have five entry
628:25 - points we have a deposit entry point
628:27 - where the owner will deposit the initial
628:29 - funds and a claim entry point where the
628:32 - owner will claim their bance back at the
628:35 - End plus their interest and people can
628:37 - call the borrow entry point and specify
628:39 - how much they want to borrow and they
628:42 - willing to provide a call back that says
628:45 - what is the next step right after a the
628:48 - money this entry point will transfer the
628:50 - amount to the sender and then we'll call
628:53 - this call back and within this call back
628:55 - the funds will be used profit may be
628:58 - made and then the call back will repay
629:01 - the loan so after we call the call back
629:04 - we need to call a function that will
629:06 - check if the loan has indeed been
629:09 - repaid while the call back is running at
629:12 - some point it has to call
629:14 - repay and send the funds back to the
629:18 - flash loan contract then
629:20 - finally check repail will be called and
629:23 - we will check that the loan was repaid
629:26 - otherwise we fail and everything is
629:28 - cancelled so the idea is that the
629:30 - contract that borrows the money will
629:32 - call
629:33 - borrow and pass its profit entry point
629:37 - as a call back so let's say we want to
629:39 - borrow 10,000 TZ and as soon as we have
629:42 - those funds The Profit entry point
629:45 - should be called so we call borrow
629:49 - borrow transfers 10,000 Tes to the
629:51 - sender then it calls this function call
629:55 - back then it calls check repaid to make
629:58 - sure that indeed call back has repaid
630:01 - the loan the next step is that profit is
630:04 - being called so the tests that have been
630:06 - transferred to it can be used to buy
630:09 - something for example then we can sell
630:11 - it for more somewhere else that's one
630:13 - way to make a profit and finally we need
630:16 - to call Flash loan. repay with the
630:19 - amount borrowed plus some interest so
630:22 - when we call repay the repay entry point
630:24 - of course checks that the amount sent is
630:27 - the amount of the loan plus the interest
630:30 - and it sets the repaid flag to True
630:33 - finally the check repaid entry point is
630:36 - called and here we check that repaid is
630:39 - true otherwise we fail so we make sure
630:41 - that indeed the amount sent was repaid
630:44 - So based on this try to implement this
630:47 - fles loan contract and call it from the
630:50 - borrower contract and note that you will
630:52 - need a total of three contracts The
630:54 - Flash loan contract the membership
630:57 - contract and the attacker contract the
631:00 - contract that will borrow the funds so
631:04 - that it can be then become a member of
631:06 - the membership
631:07 - contract we'll pause the video and
631:10 - Implement those contracts let's take a
631:12 - look at the
631:14 - solution so here is our flash loan
631:16 - contract
631:18 - we instantiate it with an owner and some
631:22 - interest rate we store those two we Mark
631:26 - that the flash loan is not in progress
631:29 - we have no loan so we set the loan
631:31 - amount currently to zero we have to set
631:34 - a borrow to avoid uh using an option so
631:37 - we set it to owner and then we say the
631:40 - flash loan hasn't been repaid so we set
631:43 - repaid to
631:44 - Falls we then have the deposit entry
631:47 - point that the owner can call to deposit
631:49 - some funds that will be used to lend
631:52 - funds to
631:53 - anyone only the owner should call it but
631:56 - we don't have to check it if somebody
631:57 - else wants to send money to the flash
631:59 - laan contract that's fine the owner will
632:02 - be able to claim it so nobody else is
632:05 - likely to send some
632:07 - Tes then we have our borrow entry point
632:11 - that takes an amount someone wants to
632:13 - borrow and the call back to be called
632:16 - after the money has been sent
632:19 - we check that there is not already a
632:22 - loan in
632:23 - progress because if we can borrow while
632:26 - there's a loan progress that will
632:28 - complicate things we would have to keep
632:29 - track of the list of people who borrowed
632:31 - Etc so we only want to have one loan at
632:34 - a time so we say it's in progress the
632:37 - money is being used so we set it to true
632:40 - and we won't be able to borrow again
632:42 - until the loan is paid back we record
632:45 - who is borrowing we record how much is
632:47 - being
632:49 - loaned then we send that amount to the
632:52 - caller and then we call the call back it
632:56 - has to be an entry point that doesn't
632:58 - take any parameter so we send unit to it
633:02 - then after the call back is acculate we
633:05 - will call the check repaid function so
633:07 - the call back is supposed to use the
633:09 - money make some profit and then call the
633:12 - repay entry point so here we call the
633:16 - check repaid entry point here to check
633:18 - that indeed
633:20 - repay was called by the
633:22 - Callback so when the call back calls
633:25 - repay we check that indeed there's a
633:27 - loan in progress and we check that the
633:30 - amount paid back is equal to the loan
633:34 - amount plus the loan amount times the
633:37 - interest rate so for example if the
633:38 - interest rate in one and we need to pay
633:40 - back
633:42 - 101% of the loan amount then we can Mark
633:46 - repaid to true so the loan has been paid
633:49 - back so later when we call check repaid
633:53 - we check that it's in progress we check
633:56 - that the loan has been repaid and we say
634:00 - okay the loan is over it's not in
634:01 - progress anymore everything goes well
634:03 - and the whole transaction
634:06 - happens if check repaid is called but
634:09 - the call back didn't call repay then
634:11 - this will fail and everything will be
634:13 - cancelled and the money will be safe
634:16 - finally the owner can call claim at any
634:20 - time unless there's a loan in progress
634:24 - so we check that is indeed the owner
634:26 - calling we check that the loan is not in
634:29 - progress and then we send the balance of
634:31 - the contract to the owner who's calling
634:36 - claim we have our membership contract
634:39 - that checks when we
634:41 - joined that the caller sent a certain
634:46 - amount and then we send it by to
634:48 - them then we have the attack contract
634:51 - that will borrow some funds then join
634:54 - the membership contract then pay the
634:56 - funds back to the flesh
634:58 - Loan in the constructure we take the
635:01 - address of the membership contract the
635:04 - address of the flesh loan contract and
635:06 - then the amount that we will need to pay
635:08 - to join this club therefore that we will
635:11 - need to loan we store all three then we
635:15 - have the impersonate rich person entry
635:17 - point point we will call the borrow
635:20 - entry point of The Flash loan contract
635:23 - and we will pass it the amount we want
635:25 - to borrow plus the address of the call
635:28 - back entry point so here we get the
635:31 - attack call back entry point so that we
635:33 - can pass its address when we call the
635:36 - loan
635:37 - contract so we say we want to borrow
635:40 - this amount when you're done please call
635:43 - this call back which is this entry
635:45 - point so in the call back we call the
635:49 - membership entry point and we send it
635:51 - that amount of money so that we can join
635:54 - the club and then we repay the contract
635:58 - so we compute the amount to repay which
635:59 - is the amount we borrow plus 1% here we
636:03 - hardcoded that it's 100
636:06 - T then we call the repay entry point of
636:10 - The Flash loan
636:12 - contract and send that amount of T to it
636:15 - so that we can repay the contract
636:18 - and of course we need a default entry
636:20 - point so that we can receive the funds
636:23 - that the flash loan contract sends to us
636:26 - and that's it so then we can see the
636:29 - test we create a membership contract we
636:32 - say the amount to have in order to join
636:35 - this club is 10,000
636:37 - TZ then we create the flash loan
636:39 - contract we say Alice is the owner the
636:42 - interest rate is
636:44 - 1% and note that this is not 1% per year
636:48 - or per any unit of time it's just that
636:50 - any time you borrow you have to pay back
636:52 - with 1% of Interest
636:54 - immediately Alis sends 100,000 Tes to
636:58 - the flash loan contract so that people
637:01 - can use it to borrow some
637:04 - funds then we create the attacker
637:06 - contract we pass the address of our
637:08 - membership contract the address of our
637:10 - flashl contract and then the 10,000 test
637:13 - or the amount that we will need to pay
637:15 - to join the club and we simply call
637:18 - impersonate rich person we have to send
637:22 - some extra test to be able to pay the
637:25 - interest let's give it a
637:28 - try so here we can see that we originate
637:31 - the membership
637:33 - contract we originate the flash laan
637:37 - contract Alice deposits 100,000 t to the
637:40 - flash loan contract then we originate or
637:43 - attack a contract with the address of
637:45 - those two flash loan and M ship
637:49 - contract then the attack starts we call
637:52 - imperson at reach person we pass 500 T
637:55 - so here we
637:57 - borrow some funds 10,000 T and we say
638:01 - here is the call
638:03 - back the flash loan transfers 10,000
638:07 - test to the default entry point of our
638:10 - attacker then it calls the call
638:13 - back so this
638:15 - function where we join Jo the membership
638:18 - contract by sending 10,000 TZ we get the
638:22 - 10,000 TZ back into the balance of our
638:24 - attacker contract then we can repay
638:28 - 10,000 plus 100 T back to the flash loan
638:32 - and so when the flash loan calls check
638:34 - repaid everything was good so everything
638:38 - works but if anything went wrong and for
638:41 - example we didn't pay the full amount
638:43 - back or we paid without interest let's
638:45 - say we pay only 10 T of Interest
638:47 - interest and if we run it we can see
638:50 - that this didn't work so everything was
638:55 - cancelled all good in this video you
638:58 - will learn how to create your own fible
639:00 - tokens in particular you will be able to
639:03 - create your own currency on chain fible
639:06 - tokens can be used in many different
639:09 - ways they can represent an existing
639:11 - fible resource for example we can create
639:14 - a stable coin or we can create an
639:16 - in-game C currency represented by a
639:19 - token we can also use fible tokens to
639:22 - fractionalize the ownership of a
639:23 - tangible asset for example we can have a
639:27 - token that represents a piece of real
639:29 - estate or a piece of art and the tokens
639:32 - make it a lot easier for the owners of
639:35 - this real estate to split their
639:37 - ownership and then Trade It Etc fible
639:41 - tokens can also be used to raise capital
639:43 - for a project similarly to stock the
639:46 - fible aspect ECT of tokens means that
639:48 - different units of the same token are
639:51 - interchangeable and if you own an amount
639:53 - of token you can split it into sub
639:56 - amounts this is very different from
639:58 - non-f B tokens nft where each nft is
640:01 - unique and cannot be split into sub
640:05 - nfts with all that in mind try to think
640:08 - about the structure of a basic contract
640:11 - that would represent a fible token I'll
640:14 - give you a hint think about the test
640:17 - token it is a fible token and what we
640:20 - want to be able to do with our fible
640:22 - token is very similar to what we are
640:25 - able to do with the native
640:27 - test so with that in mind think about
640:29 - how you would structure a contract to
640:31 - handle this pause the video and think
640:34 - about it for a minute so with the native
640:37 - TZ we have accounts and we have a
640:40 - balance for each account and we can
640:41 - transfer Tes from one account to another
640:44 - so we need to be able to do that with
640:45 - our token contract so we need to store
640:48 - the balance of each user in that token
640:51 - and we need to be able to transfer
640:53 - tokens to other people for that all we
640:56 - need is to have in the storage of our
640:59 - contract or Ledger a big map that
641:02 - contains the balances of all the users
641:05 - the key would be the address of the user
641:07 - and the value would be the amount of
641:10 - this token that the user owns and we
641:12 - need a transfer entry point where a user
641:15 - can say I want to send this amount of
641:18 - token to this destination and the ENT
641:21 - triport will check that we have enough
641:24 - tokens in our balance to transfer that
641:26 - amount if the destination does already
641:28 - have an account we create it by setting
641:31 - the balance for this address to zero
641:34 - then we can do the transfer we add that
641:36 - amount to the balance of the destination
641:39 - and then we subtract the amount from the
641:41 - balance of the sender so that's great
641:44 - but with the test we can do more than
641:46 - that so try to think about what else we
641:48 - can do with the TZ that this doesn't
641:50 - support and I'll give you a hint think
641:53 - about what you can do with Tes within
641:56 - smart contracts or when you use Smart
641:58 - contracts pause the video and think
642:01 - about it for a minute I'll give you
642:02 - another hint think about how you would
642:05 - write a version of the Endless wall
642:08 - contract where it would charge one token
642:12 - instead of charging one TZ to add a
642:15 - message to the wall what would you need
642:18 - in The Ledger contract to be able to
642:21 - support this here is the code of the
642:25 - Endless W contract that uses TZ so what
642:28 - would you need to do to be able to write
642:29 - a similar code but by charging using
642:33 - your own token instead of one TZ pause
642:36 - the video and think about it for a
642:38 - minute so with the native TZ token you
642:40 - can transfer test to a contract when you
642:43 - call an entry point then within the
642:45 - entry point you can use speeded amount
642:48 - to check how much was sent to the
642:49 - contract to pay for some service or to
642:53 - deposit some amount Etc so we need to be
642:55 - able to do something similar with our
642:57 - token one way would be to call the
643:01 - transfer entry point to send tokens to
643:03 - the address of the contract just before
643:05 - making a call to an entry point so that
643:07 - we can send some amount of token to the
643:09 - contract we are just about to
643:11 - call but if we do that we there would be
643:15 - no way for the contract to check
643:17 - how much we just sent to it so we need a
643:20 - way for the contract to be able to check
643:22 - who transferred how much to it and we
643:25 - need to make sure that the same transfer
643:27 - of tokens cannot be used for two calls
643:30 - by the same user to the same smart
643:32 - contract one way to do that would be to
643:35 - store information about every transfer
643:38 - to a given contract call and we could
643:41 - store that in a big map where we store
643:44 - all the
643:44 - transfers the key would be the source so
643:47 - who is calling this entry point and
643:50 - sending tokens to it and then we will
643:53 - store the destination address so the
643:55 - address of the smart contract and how
643:57 - much we are transferring so we would add
643:59 - an entry to this big map when we make a
644:02 - transfer to a Smart contract and the
644:04 - destination contract will then be able
644:05 - to call some entry point of the token
644:08 - contract of The Ledger to check that
644:10 - there is indeed a transfer that has been
644:13 - made with the right amount and they will
644:15 - then delete that transfer so that it
644:17 - cannot be reused so that could work but
644:20 - in practice the standards we use to
644:23 - write such fible tokens contract do it a
644:25 - bit differently so that we can mble more
644:27 - your cases instead of keeping track of
644:31 - how much we just sent to the contract we
644:33 - calling we will allow the contract to
644:38 - take some money from the caller so we
644:41 - allow a given contract address to spend
644:43 - some amount of tokens in the name of a
644:46 - given user or contract so users can say
644:51 - okay this contract is allowed to spend
644:54 - this amount of tokens from my balance
644:58 - and then the contract can directly
645:00 - transfer that amount to itself or to
645:02 - some other destination so instead of
645:05 - sending some token to the contract and
645:07 - having a way for the contract to check
645:09 - it we allow the contract to use some of
645:12 - our tokens and then the contract can do
645:14 - it itself so instead of storing
645:16 - transfers
645:17 - we store allowances in the storage of
645:19 - our Ledger where for a given account and
645:23 - a given operator that's the address of
645:25 - the contract we allow to use some of our
645:27 - tokens and we say how many tokens it can
645:30 - spend we create an allowance by calling
645:33 - an allow entry point that takes the
645:35 - address of the operator that is allowed
645:37 - to spend some of our funds and the
645:39 - amount that we allow this operator to
645:41 - spend if there's no entry we create one
645:46 - and then we add this amount to the entry
645:48 - so with the account and the
645:51 - operator then when we call transfer we
645:53 - specify the source because the source
645:55 - may not be the sender so we say I want
645:57 - to transfer this amount from this source
646:00 - to this
646:01 - destination and within the entry point
646:03 - we check if the source is not us then we
646:06 - check if there's an allowance that
646:08 - allows us to spend at least that amount
646:11 - then we subtract that amount from the
646:13 - Alan so that you cannot spend it a
646:15 - second time so now it's your turn to
646:17 - implement this contract so your job is
646:20 - to write a ledger contract such that a
646:23 - user can create a new token and set an
646:26 - initial amount of tokens that he
646:28 - owns then anyone May transfer their
646:31 - tokens to other users so this first user
646:35 - can distribute their token the way they
646:37 - wish then The Ledger will keep track of
646:40 - how many tokens each user owns in their
646:43 - balance with a system of accounts and
646:45 - balances and finally users can allow
646:48 - contracts to spend some amount of tokens
646:51 - in their
646:52 - name once you've done that use this
646:55 - Ledger in a version of the Endless wall
646:57 - contract such that anyone can add text
647:00 - to the wall as long as they pay one of
647:03 - your tokens and the tokens that are paid
647:06 - can be directly transferred to the owner
647:08 - of the Endless W contract to help you we
647:11 - provide you an incomplete code that you
647:13 - can find either in the G repository or
647:16 - on open tesos and your goal is to
647:20 - complete the contracts and the tests
647:22 - let's take a look at the
647:23 - solution so in our Ledger we store the
647:27 - balances so a big map initialized with
647:30 - the owner of The Ledger who owns the
647:32 - total Supply that we provide then we'll
647:35 - have another big map that will store all
647:37 - the
647:38 - allowances when we transfer some amount
647:42 - from a source to a
647:43 - destination we check if the source is
647:47 - not whoever is calling the transfer
647:49 - point then we check that they're allowed
647:51 - to transfer that amount so we check if
647:54 - there's an entry in the allowances for
647:56 - this source and this callar we check
648:00 - that the allowed amount is more than
648:02 - what we want to transfer and then we
648:05 - subtract the amount from the allowed
648:08 - amount this could be negative except
648:10 - that we check that it's not so we can
648:13 - convert it to a natural and then update
648:15 - the allenes
648:18 - we also check that the balance of the
648:20 - source is sufficient to transfer that
648:22 - amount then we update that amount by
648:25 - subtracting the amount we transfer from
648:28 - the balance of the
648:30 - source
648:31 - finally if the destination doesn't
648:34 - already have a balance we create one
648:36 - with the value zero and then we add the
648:39 - amount we transfer to their
648:43 - balance we will use a get balance
648:46 - onchain view so that any contract can
648:48 - figure out what's the current balance of
648:50 - a user for this token and then we have
648:53 - our allow entry point where a user can
648:57 - allow a given operator so the address of
649:00 - a smart contract to spend some amount in
649:02 - their name it could be a regular user
649:04 - but in practice it's almost always a
649:06 - smart contract if there's no entry in
649:11 - the big map for that key composed of the
649:13 - sender and the operator then we create
649:15 - one and we say the allowance is zero and
649:18 - then we add the amount we want to allow
649:22 - to this allowance and that's it for The
649:25 - Ledger now let's look at the modified
649:28 - version of the Endless wall contract all
649:30 - we have to do here in the contract is to
649:34 - do the transfer so we get the entry
649:36 - point transfer from that ledger contract
649:39 - the type of the parameter will be a
649:42 - source a destination and the amount and
649:46 - then we do the call to the transfer
649:48 - entry point we say the color of WR
649:51 - message is the source the destination is
649:55 - the owner of the unless will contract
649:57 - and we transfer one token we don't need
650:00 - to transfer any Tes and so this is just
650:04 - a way to say transfer one token from
650:07 - whoever is calling right message to the
650:09 - owner of the UN listable contract of
650:12 - course for this to work the user who is
650:14 - calling right message has to have
650:17 - allowed us to do
650:18 - so then we
650:21 - change the
650:24 - text in our test we create the ledger so
650:27 - Alice creates a ledger with a million
650:30 - tokens then we create an endless wall
650:33 - where Bob is the owner of that endless
650:36 - wall but the endless wall needs to know
650:38 - the address of the ledger so we pass the
650:40 - address of The Ledger here to Our
650:43 - Endless W Constructor that we store here
650:47 - and then
650:48 - finally Alice will need to allow the
650:51 - endless wall contract to spend one token
650:55 - in her name and once she's done that
650:57 - then she can call right
650:59 - message and this one token will be taken
651:02 - from her balance and transferred to Bob
651:06 - we can give it a
651:09 - try so here we originate The Ledger
651:12 - where only Alice has an entry with 1
651:16 - million
651:17 - tokens then we originate the endless
651:20 - wall with the initial text
651:22 - hello then we allow the endless World
651:27 - contract to spend one token in the name
651:30 - of Alis then Alice can call the right
651:34 - message entry point and this will
651:36 - trigger a transfer of one token to Bob's
651:41 - address all
651:43 - good when we create fible tokens on
651:46 - tesos we need to make them compatible
651:49 - with tools and contracts and wallets so
651:52 - that generic tools can be used for you
651:54 - to view your balance and spend your
651:56 - tokens Etc so we have a set of standards
651:59 - that are used to create fible tokens the
652:02 - first standard was the a 1.2 standard
652:06 - that is dedicated to contract that
652:09 - manage fible tokens only then we have
652:11 - the A2 standard that also supports
652:14 - non-fungible tokens we talk about it in
652:17 - another module and at the time of
652:19 - recording we're about to release the AA
652:22 - 2.1 standard so an updated version of
652:25 - the fa2 standard these standards all
652:29 - include support for some system of
652:31 - operators and or
652:33 - allowances that can be done in different
652:35 - ways depending on the standard but the
652:38 - idea is always the same that we allow
652:40 - some address to do some operations in
652:42 - our name they also include A View to
652:44 - access the balance of a given user from
652:47 - another contract and they have
652:50 - additional metadata about the tokens in
652:52 - this video we will talk about how you
652:55 - can trade tokens for example if you
652:58 - create your own token you can trade it
653:00 - against TZ or against tokens from other
653:03 - people and we'll talk about how the
653:05 - value of a token can be calculated so in
653:08 - the module and fungible tokens we saw
653:10 - how we could transfer tokens from one
653:12 - address to another and how we could
653:14 - spend tokens in smart contracts using a
653:17 - system of operators and
653:19 - allowances but we also want to be able
653:21 - to trade our tokens with t or to trade
653:24 - them with other tokens so for example we
653:27 - can take the simple case of trading
653:29 - between a pair of tokens we create our
653:31 - token a and we want to be able to trade
653:34 - tokens a versus TZ so if someone has an
653:38 - amount of token a they want to able to
653:40 - sell it for some mon of t or vice versa
653:44 - so the question for you is think about
653:47 - how you would create a contract that
653:49 - would allow anyone to either quickly
653:53 - purchase tokens a using TZ as a way of
653:57 - payment or quickly sell tokens a in
654:01 - exchange for TZ and the important part
654:03 - is to do so at a fair price how can you
654:06 - make sure the exchange is on the right
654:08 - price pause the video and think about it
654:11 - for a minute so we can think about a
654:13 - multiple ways to determine the price a
654:17 - basic idea would be to set a fixed
654:19 - exchange rate once and for all so you
654:21 - could say well I create this token for
654:23 - my game currency and I will say that one
654:26 - token is worth exactly 0.3 T for example
654:30 - but if you do that no trading would
654:33 - probably happen because if some people
654:35 - think the currency in your game should
654:37 - be worth more than 0.3 TZ for each token
654:41 - then they will never sell it at that
654:43 - price or vice versa if people who may
654:45 - want to buy your token think well it's
654:48 - worth a bit less then they won't be
654:50 - willing to buy it at that price the
654:52 - whole point of creating your own
654:54 - currency is for the token to be able to
654:57 - have its value changed based on demand
654:59 - so if your game becomes very popular and
655:02 - lots of people want to earn some
655:04 - currency in your game then the price
655:06 - should go up and vice versa if the game
655:09 - is not too popular then the price should
655:11 - be able to go down so that people still
655:13 - can buy and sell those tokens so a fixed
655:16 - exchange rate wouldn't work another way
655:20 - would be to try to have a group of
655:22 - people decide together what the current
655:24 - exchange rate they could have meetings
655:25 - every day say okay we think it should be
655:27 - lower it should be higher let's change
655:29 - it a bit that would be a bit complicated
655:32 - and it wouldn't really help because it
655:34 - wouldn't adjust fast enough to the
655:36 - demand and this group of people wouldn't
655:38 - have a good way to know what's the right
655:40 - exchange rate it would say okay
655:42 - yesterday people bought it but didn't
655:44 - sell it so it's probably too cheap or
655:48 - vice versa and it's probably too
655:50 - expensive we need a way to instantly
655:53 - adjust to the demand we could think
655:55 - about using auctions like we do for nfts
655:59 - but auctions are slow you need to set a
656:02 - deadline in the future you need to make
656:04 - sure there's people who know this your
656:06 - auction Etc and they're hard to use
656:08 - because you would put an as an auction a
656:11 - certain amount and this amount may not
656:14 - match what the buyer wants to
656:17 - purchase and if you make an offer while
656:20 - setting up the offer at the right price
656:22 - is not easy either so we want something
656:24 - that really determines the right price
656:26 - automatically and
656:28 - instantly if you want the trading of
656:31 - tokens to be effective we need liquidity
656:33 - it should always be possible to buy and
656:35 - sell at any moment you shouldn't have to
656:38 - wait for someone to be available and
656:40 - agree to sell to you or buy from and the
656:44 - prices should be adjusted automatically
656:47 - and
656:48 - instantaneously based on the offer and
656:51 - demand for your token and the token you
656:53 - want to trade it for so to support that
656:57 - we could use a contract that will store
657:00 - some amount of the two tokens that you
657:02 - want to trade so we will store some
657:04 - amount of token a and some amount of TZ
657:07 - so that if people want to buy or sell
657:09 - there is some amount that is available
657:11 - immediately for trading and this
657:14 - contract will have to automatically
657:15 - adjust the price based on the offer or
657:19 - on the demand for your token so think
657:22 - about how you would design a contract
657:24 - that will store some amount of tokens a
657:27 - and of TZ and then will automatically
657:29 - adjust the price based on offer and
657:32 - demand and will let anyone trade at that
657:36 - price pause the video and think about it
657:38 - for a minute this type of contract is
657:40 - what we call a liquidity pool and a
657:43 - liquidity pool enables users to easily
657:46 - trade between Pairs of tokens let's
657:49 - imagine that we have token a and TZ in
657:52 - our liquidity pool some investors could
657:56 - deposit initial amounts of token a and a
657:59 - corresponding amount of
658:01 - TZ these tokens would form a reserve of
658:05 - liquidity for each of the two tokens
658:08 - then users would be able to trade
658:10 - amounts of one token for the
658:12 - corresponding amount of the other token
658:14 - at the current price and this current
658:16 - price the exchange rate would be based
658:19 - on the available amounts of both tokens
658:22 - in the pool we will see that when we do
658:25 - that any deviation from the real
658:27 - exchange rate based on the offer and
658:29 - demand the price that people are willing
658:31 - to buy it for or sell it for can't last
658:34 - very long because as soon as the price
658:35 - is cheap then somebody will quickly buy
658:38 - and it will increase the price or if the
658:40 - price is too much people will sell and
658:42 - this will reduce the price and there
658:45 - will be a system of Arbitrage
658:46 - opportunities that makes sure that the
658:49 - exchange rate is the right rate the
658:51 - investors who deposited the liquidity on
658:54 - this liquidity pool will be rewarded
658:57 - using Exchange fees so percentage of
659:00 - every trade that they will receive in
659:02 - exchange for providing this liquidity so
659:05 - the main question is how can we
659:07 - determine the exchange rate that we will
659:09 - use typically liquidity Pools use what
659:12 - we call an automated Market maker or am
659:16 - mm mechanism it's a mechanism that
659:18 - determines the token prices based on the
659:22 - amount of token a and of TZ in the pool
659:25 - for example of be a TZ there can be a
659:28 - number of different formulas you can use
659:30 - but the most common formula that is used
659:33 - is called the constant product formula
659:36 - and with this formula the prices are
659:38 - such that the product of the balance of
659:41 - both
659:41 - tokens remain constant so the balance of
659:45 - token a multiply by the balance of TZ
659:48 - that is in the reserve of the liquidity
659:51 - pool should always be equal to some
659:54 - constant K that we set when we create
659:57 - the liquidity pool and the idea is that
659:59 - with this formula the more of a given
660:02 - token you have out of the two the
660:04 - cheaper that token gets and of course
660:07 - the less of a token you have the more
660:09 - expensive it get because it's rare so
660:12 - it's more expensive than if it's really
660:14 - abundant so the the idea is that
660:16 - whenever we buy or sell a given token we
660:19 - compute the price to make sure that
660:22 - after the transfer this product is still
660:25 - constant so with that in mind let's
660:28 - Implement a very basic liquidity pool
660:30 - contract at the beginning we will have a
660:32 - single user who will provide liquidity
660:34 - to this pool a single time then other
660:38 - users should be able to trade tokens for
660:41 - tez or vice versa there should be a way
660:43 - for contracts to be able to check the
660:45 - current exchange rate and again the idea
660:48 - is that the balance of the two token in
660:51 - the pool should always verify this
660:53 - formula token a balance time token B
660:55 - balance equals K so first think about
660:59 - what you would store in this smart
661:01 - contract and what would the entry points
661:04 - be pause the video and think about it
661:07 - for a minute so in the storage of the
661:09 - contract we will need the address of The
661:12 - Ledger because we will interact with the
661:14 - Ledger that stores the token
661:17 - we also need the address of the owner
661:19 - who is the single user who put liquidity
661:23 - at the creation of the liquidity pool
661:24 - and they will be able to get it out when
661:26 - they want to close the liquidity pool we
661:29 - need to store the constant K so since we
661:32 - multiply a natural number with a number
661:35 - of TZ then K has unit TZ and finally on
661:40 - top of the balance in t that we will
661:43 - have access to using sp. balance we also
661:45 - need to store how many
661:46 - tokens the liquidity pool owns and we
661:50 - could of course check in The Ledger but
661:52 - it might be more convenient to store it
661:54 - directly in the storage then we will
661:56 - have five entry points the first entry
661:59 - point is for the creator of the
662:01 - liquidity pool to transfer some
662:03 - liquidity and so they send some amount
662:05 - of Tes to the entry point along with a
662:08 - number of tokens they want to deposit in
662:11 - the balance of the liquidity pool so you
662:13 - add to the balance in TZ and to the
662:15 - balance
662:16 - in this token some
662:18 - amount based on this you can compute the
662:21 - value K that's the product between this
662:23 - amount and the amount of test
662:26 - transferred and so we can store these
662:28 - two values and then we of course need to
662:31 - transfer this number of deposit tokens
662:34 - to the address of the smart contract
662:36 - through the ledger so this assumes that
662:38 - the caller has allowed the liquidity
662:40 - tool to transfer these tokens to itself
662:43 - at the very end owner should be able to
662:46 - withdraw their liquidity so when they
662:47 - call it withdraw liquidity we simply
662:49 - send all the tokens in the balance of
662:52 - the contract and all the Tes in the
662:54 - balance of the contract to the owner and
662:56 - this closes the liquidity pool then we
662:59 - have the two main entry points for for
663:01 - users to sell or buy tokens so our sell
663:05 - tokens entry point we will say how many
663:08 - tokens we want to sell but as a safety
663:11 - measure to make sure we don't sell them
663:14 - for cheaper than what we expect we
663:17 - indicate how many Tes we expect to get
663:20 - at the minimum when we sell our token so
663:22 - it's a safety measure to make sure that
663:24 - if the price goes temporarily very low
663:28 - then maybe we just don't want to sell so
663:31 - we can set some minimum value of how
663:33 - much we will get for those tokens and so
663:35 - in this entry point we will compute
663:36 - using the formula how many Tes the
663:40 - tokens that we want to sell are worth
663:43 - and if this is more than the Tes we
663:45 - requested then we simply transfer the
663:47 - tokens and T accordingly so we transfer
663:51 - the tokens to the liquidity pool
663:54 - contract and then we take test from the
663:56 - balance of the liquidity pool to send
663:59 - them to the seller the buy tokens entry
664:03 - point Works
664:04 - similarly we send some amount of TZ to
664:07 - the contract and we say with that amount
664:10 - of Tes I expect to buy at least this
664:12 - number of
664:14 - tokens if the price price of the token
664:16 - goes too high then maybe I just don't
664:18 - want to buy them and here again we start
664:21 - by Computing how many tokens I can get
664:24 - for that amount and if this is more than
664:27 - the minimum that I want to buy then we
664:30 - transfer the tokens and the test
664:32 - accordingly we keep the test sent by the
664:35 - user in the balance and then we transfer
664:38 - tokens to the color finally we will have
664:41 - a view get token price that will compute
664:44 - and return how much it would cost to buy
664:47 - one token right now so your job is to
664:51 - implement this contract and keep in mind
664:54 - that this formula should always be
664:56 - maintained the product between the
664:58 - balance of one token and the balance of
665:00 - the other token should always be equal
665:02 - to K before and after each call to an
665:05 - entry point again you can start with the
665:08 - incomplete code that we provide in the G
665:11 - repository or on open tzel pause the
665:14 - video and give it a track let's look at
665:16 - a solution here we have our Ledger that
665:19 - we didn't
665:21 - change and here we have this liquidity
665:23 - pool
665:24 - contract where we store the address of
665:28 - The Ledger contract the address of the
665:30 - owner the constant K that we initialize
665:33 - at zero before we know the value it will
665:36 - have and then we keep track of how many
665:39 - tokens the liquidity pool has on its
665:42 - balance and then this will be used to
665:45 - simplify the calls to The Ledger
665:47 - contract so basically this is a variable
665:49 - where we will store the address of the
665:51 - transfer entry point for that contract
665:53 - so that we don't have to compute it
665:55 - every
665:56 - time we have the provide liquidity entry
665:59 - point where the owner will deposit some
666:02 - amount of tokens and some amount of Tes
666:04 - initially to the liquidity pool we check
666:08 - that whoever is calling is the
666:10 - owner we check that we have never sent
666:13 - anything so the liquidity pull is
666:16 - not open yet so the value of K was
666:18 - Zero then we compute the value of K as
666:22 - the product of the balance of the
666:24 - contract after the transfer of TZ from
666:27 - the user and the number of deposited
666:30 - tokens so here K is set once and for
666:34 - all and finally we keep track of how
666:36 - many tokens the liquidity pool
666:39 - owns finally we do the transfer to
666:42 - obtain those tokens from the user
666:46 - through the
666:47 - ledger so this is where we initialize
666:49 - this Ledger contract up variable with
666:53 - the address of the transfer entry point
666:55 - of The
666:57 - Ledger you may notice that to avoid
667:00 - having to repeat the type everywhere we
667:02 - created this perm
667:05 - type that we Define here as the record
667:09 - that contains a source a destination and
667:11 - some
667:13 - amount so that we don't have to repeat
667:15 - it every
667:16 - time
667:18 - once the owner has provided some
667:20 - liquidity in the form of TZ and some
667:22 - amount of
667:24 - tokens we have the withdrawal
667:27 - liquidity that will be called at the End
667:30 - by the owner to withdraw all of these
667:31 - tokens so we check that this is indeed
667:34 - the owner calling and then we simply
667:37 - send the balance of the contract to the
667:40 - owner and then transfer the tokens
667:42 - themselves to the owner finally we just
667:45 - say now the tokens own are zero and then
667:47 - we set K back to zero so that maybe the
667:50 - contract can be used again later by the
667:53 - owner but this effectively closes the
667:55 - liquidity pool for
667:58 - now let's look at the get token price on
668:01 - chain view so that we can figure out how
668:04 - we compute the current price of the
668:06 - token and here the idea is to compare
668:10 - what the current balance in T is to what
668:14 - it would be if we had one less
668:18 - token and this difference is how much
668:20 - the balance needs to change so that the
668:23 - product between the two balances stays
668:26 - the same so here we divide K by the
668:30 - number of tokens we currently own this
668:33 - should tell us what the current balance
668:36 - is and then we do the same but with the
668:39 - current amount of tokens owned minus one
668:43 - and so this tells us what the balance
668:44 - should be
668:46 - after we sell one token so if we have
668:49 - the balance before we sell one token and
668:51 - the balance after we sell one token then
668:54 - the difference between the two should be
668:57 - how many Tes we get for that
669:00 - token and so this is how we compute the
669:02 - current price of a token now in the sell
669:06 - tokens entry point we do something
669:09 - similar we compute what the balance
669:12 - would be if we had this number of tokens
669:15 - on top of the token we have and so we
669:19 - compute how many Tes we are supposed to
669:21 - send by Computing the difference between
669:24 - the current balance and what we should
669:27 - have once we obtain those extra
669:31 - tokens so this is not the same as
669:33 - Computing the current price of one token
669:36 - and then multiplying this by the number
669:38 - of tokens sold because the more you sell
669:42 - token to the liquidity pool the cheaper
669:46 - they become because the more tokens the
669:48 - liquidity pool has then the cheaper each
669:52 - token becomes so we cannot simply use
669:55 - the price of the first token and then
669:57 - multiply that by the number of tokens so
669:59 - this is why we use this formula as a way
670:02 - to check what is the current balance and
670:05 - what should be the balance after we
670:07 - obtain those tokens and the difference
670:10 - between the two tells that the price
670:12 - that we should pay for those tokens so
670:14 - here we check that this price is more
670:17 - than what the seller is
670:19 - requesting and once we have that it's
670:22 - very easy we transfer the
670:24 - tokens we transfer the TZ and we keep
670:27 - track of how many tokens we still
670:29 - own the buy tokens Works in a similar
670:33 - way we compute the number of tokens we
670:36 - should get for the price that the user
670:39 - sends so sp. amount by Computing the
670:43 - difference between how many Tok tokens
670:45 - we currently own and how many tokens we
670:49 - should own based on the new balance that
670:52 - we have so we divide K by the New
670:55 - Balance to determine was the number of
670:58 - token we should own after we got this uh
671:01 - new
671:02 - amount and again we check that this
671:05 - number of tokens is more than what the
671:07 - buyer is expected to receive and if it
671:10 - is then we send tokens to them and we
671:14 - update the number number of tokens we
671:16 - own now in the test we create The Ledger
671:20 - we create the liquidity pool Alice
671:22 - provides 2,000 tokens and 2,000 Tes and
671:27 - C provide liquidity to the pool this
671:30 - means K will be 2,000 * 2,000 so 4
671:34 - million then we have Bob bu at least 90
671:39 - tokens for 100 TZ then Carl buys a th000
671:45 - T worth of tokens and expect to get at
671:47 - least 500 of
671:50 - them then finally we have Bob sell his
671:55 - tokens so it allows the liquidity pool
671:57 - to withdraw 96 tokens that's the number
672:00 - that he will actually be able to buy
672:02 - here and then calls sell tokens to sell
672:05 - those 96 tokens and he expect to get at
672:08 - least 200 TZ so if this works so Bob
672:12 - spent 100 TZ to buy 96 tokens then Carl
672:16 - spent a th000 TZ to buy a lot of tokens
672:18 - so this increased the price of a token
672:22 - so that Bob can sell his 96 tokens at at
672:26 - least 200 and make a big profit of at
672:29 - least 100 T so let's give it a
672:34 - try so we can see here that we created
672:38 - The
672:39 - Ledger with 1 million tokens then we
672:43 - created the liquidity p
672:46 - cool with K set to zero no tokens own we
672:52 - provide some liquidity after allowing
672:55 - 2,000 tokens to be provided we provide
672:58 - 2,000 tokens and 2,000
673:01 - Tes the transfer is made for these
673:03 - tokens to be
673:04 - transferred then we have
673:07 - Bob by 100 T worth of token and he wants
673:12 - at least 90 tokens for that price with
673:15 - see that the amount computed for 100 T
673:18 - is 96
673:21 - tokens then Carl buys for a th000 TZ
673:25 - worth of token expect to get at least
673:28 - 500 and we see that he indeed gets 614
673:32 - tokens for 1,000 Tes we can see that the
673:35 - price of the token went up for 100 TZ
673:39 - Bob got 96 token but for a th000 TZ Carl
673:44 - only got six 114 and the price keeps
673:47 - increasing as the supply of tokens in
673:50 - the liquidity pool gets lower we can see
673:53 - here that the number of tokens owned is
673:56 - down to
673:58 - 12290 whereas the balance is up to
674:02 - 3,100 so tokens are getting rare which
674:05 - means they're getting more
674:10 - expensive then Bob
674:12 - allows for his 96 Tok tokens to be
674:15 - transferred back to the liquidity pool
674:18 - and then sells them and says I should
674:20 - get at least 200
674:22 - T and we can see that his 96 tokens are
674:27 - taken from him but then he gets
674:31 - 23997 T so he indeed made a profit of
674:35 - almost 114 TZ for his initial 100 T
674:40 - purchase so here there's high demand for
674:42 - these tokens so people who bought tokens
674:44 - early can make a
674:46 - profit all good in this video we will
674:49 - talk about the concept of Arbitrage and
674:52 - we will see that if there are two
674:53 - liquidity pulls or in other word two
674:55 - exchanges for the same pair of tokens
674:58 - but the price is not the same for both
675:02 - then there's an opportunity for
675:03 - Arbitrage where we can make some profit
675:06 - so the idea is that you could have two
675:07 - contracts two liquidity pools to
675:10 - exchanges where the exchange rate
675:12 - between the two tokens A and B or a in
675:15 - TZ are
675:17 - different when this happens this creates
675:20 - an opportunity for anyone who owns some
675:23 - token to purchase some tokens a in the
675:27 - contract with the cheaper price paying
675:29 - with the other token and then to sell
675:32 - these tokens in the contract with a
675:35 - higher price and you get a higher amount
675:37 - of token B that what you initially paid
675:40 - so you make a profit this happens all
675:43 - the time on block chains but also other
675:46 - markets and we presented a very simple
675:49 - opportunity where it's just a direct
675:51 - exchange rate between tokens but it
675:52 - could be path where you go through
675:54 - intermediate tokens but then find a way
675:57 - to make a profit with a succession of
676:00 - exchanges so there's always many many
676:03 - users and in practice Bots that
676:06 - constantly look for search Arbitrage
676:09 - opportunities and as soon as they see W
676:12 - they purchase some tokens in one exch
676:14 - change and then sell them for more in
676:17 - the other exchange by doing that they
676:21 - make a profit but they also help to make
676:23 - sure that the exchange rate for a given
676:25 - pair of tokens stays approximately the
676:28 - same across all the different liquidity
676:30 - pool contracts all the different markets
676:32 - and you can do this even if you don't
676:34 - have money by using flash loans so that
676:38 - you can take advantage of any such
676:40 - Arbitrage situation if you notice two
676:44 - liquidity pull contracts that have
676:45 - different exchange rates for the tokens
676:47 - A and B you could borrow tokens of type
676:51 - B from a flash loan contract then you
676:54 - can purchase tokens a at the cheaper
676:56 - price using your tokens B that you just
676:58 - borrowed immediately sell your tokens a
677:01 - at the higher price in the other
677:03 - liquidity pool getting more tokens B
677:06 - than you spent and with these tokens you
677:09 - could reimburse a flash loan and the
677:11 - interest but still make a profit so you
677:15 - don't actually need to own any tokens b
677:18 - or a to take advantage of an Arbitrage
677:22 - situation thanks to flash loans because
677:24 - Flash loans can make you temporary rich
677:27 - in any of the tokens and of course if
677:30 - you make a mistake and cannot reimburse
677:32 - The Flash loan everything is cancelled
677:34 - so there is no risk for
677:36 - anyone let's work on an exercise where
677:39 - you will take advantage of an Arbitrage
677:42 - situation you will use the Ledger and
677:44 - liquidity pool contract and create a
677:47 - test that does the following with a user
677:51 - Alice you will create a token with a
677:54 - supply of 10 million tokens then Alice
677:57 - will create two instances of the
678:00 - liquidity pool contract and each of
678:03 - those instances she will provide
678:06 - liquidity with 1 million tokens and
678:09 - 1,000 TS once this is ready we will have
678:13 - Bob purchase 100 TZ worth of tokens from
678:16 - the first liquidity pool and this will
678:19 - create an arbitr situation because it
678:21 - will change the price of the tokens that
678:23 - was initially the same in both pools but
678:26 - not at Bob bought from one pool it will
678:29 - change the price of the token in this
678:31 - pool so Carl will take advantage of this
678:34 - Arbitrage opportunity and earn some TS
678:38 - so using the example contracts that we
678:41 - provide on a g repo and on open tesel
678:45 - pause the video and write a test where
678:48 - Carl makes as much of a profit as
678:50 - possible in this situation let's take a
678:52 - look at the solution so here we have our
678:55 - Ledger contract and the liquidity pool
678:58 - contract that we didn't
679:00 - change and so in or test we here create
679:04 - a ledger in the name of Alice with a
679:07 - total supply of 10 million tokens then
679:11 - we create two identical liquidity pools
679:14 - lp1 one and LP2 each liquidity pool is
679:17 - created in the name of Alis attached to
679:21 - this Ledger and Alis provide 1 million
679:24 - tokens and a thousand T of liquidity
679:28 - initially the price is the same for both
679:30 - tokens then we have Bob buy 100 T worth
679:34 - of tokens from the first liquidity pool
679:37 - and he expects to get at least 80,000
679:40 - token so this creates an arbitr
679:42 - opportunity because the tokens on the
679:44 - first liquidity pool will be worth more
679:47 - than the tokens on the second liquidity
679:50 - pool because there are now fewer tokens
679:53 - in the first liquidity pool so Carl can
679:56 - buy some tokens from the second
679:57 - liquidity pool and then sell them for
680:00 - more in the first liquidity pool and the
680:04 - question is how many should he buy and
680:06 - at what price and the idea here is that
680:09 - since Bob only bought a small amount of
680:13 - tokens compared to the the whole pool
680:15 - then the price won't change by much so
680:18 - we could use some math to compute what's
680:19 - the right amount but by triy and error
680:22 - we can see that the best amount is to
680:24 - spend 48
680:26 - TZ and this will buy
680:29 - 4,82 tokens and with this numberous call
680:33 - we'll make a profit of 4.76
680:36 - T and if he bought for 49 T then the
680:40 - profit would be a bit less and same for
680:43 - 47 T profit would be a bit less so maybe
680:46 - the ideal value is not precisely 48 T
680:49 - but this will be close enough so Carl
680:52 - will buy this amount of TZ worth of
680:55 - tokens and he expects to get exactly
680:58 - this amount but that's the minimum he
681:00 - says he wants to get then he will sell
681:03 - those tokens back on the first liquidity
681:06 - pool so allows this number of tokens to
681:09 - be transferred by the first liquidity
681:12 - pool and then sells them so so let's
681:14 - give it a
681:18 - try so we can see the creation of The
681:21 - Ledger creation of the first liquidity
681:25 - pool then we allow transfer of
681:29 - liquidity to this first liquidity pool
681:32 - we do the same for the second liquidity
681:34 - pool and then we have Bob who buys 100 T
681:39 - worth of token we see that with this
681:41 - amount he actually got 9,910
681:47 - token then Carl buys for 48 T worth of
681:53 - tokens with see that indeed the number
681:55 - of tokens he bought is
681:57 - 45,8 two and that by looking at this
682:00 - value that we actually set this exact
682:02 - value
682:03 - here then the tokens are transferred and
682:07 - then Carl allows for these tokens to be
682:11 - transferred when he sells it and he to
682:14 - sell this amount of token and he expects
682:18 - well he doesn't expect anything he'll
682:19 - just see what he can get but we can see
682:23 - here that the tokens are transferred and
682:26 - then we have
682:28 - 52.76 TZ transferred so he bought them
682:31 - for 48 T and he sells them on the other
682:35 - liquidity pool for
682:37 - 52.76 making a profit of
682:40 - 4.76
682:42 - T if we want to better understand what
682:47 - happens we could check the
682:51 - prices at different moments of the
682:54 - different liquidity Pools by calling
682:56 - scenario. verify and then I get the
682:59 - token price and check that for example
683:01 - it's at least 90 mutes some rary
683:05 - value and the get token price can be
683:08 - instrumented with some Trace
683:10 - instructions to find out what the
683:13 - different values are what the ratio are
683:15 - what the current price should be and so
683:18 - we can run it then open the console to
683:22 - see here the price of the token return
683:25 - is 1,000 so when we call it here right
683:29 - after we created the liquidity pool then
683:31 - one token equals 1,000
683:34 - mutes but
683:37 - after Bob buys some token then we can
683:41 - run it again and we see that this time
683:44 - the price increased to 1210 mutas Etc so
683:48 - you can use this instruction at
683:50 - different places with the two liquidity
683:52 - pools to check exactly what's happening
683:55 - very convenient to help you understand
683:58 - you can play around and see what happens
684:01 - in this video we will show that in some
684:03 - situations it's possible to manipulate
684:06 - prices of
684:07 - tokens and cheat if contracts are not
684:10 - protected against this manipulation
684:12 - contracts that want to attract wide
684:15 - audience may offer users to pay in a
684:19 - choice of multiple tokens so you could
684:22 - accept payment in TZ but also accept
684:24 - payment in number of other tokens that
684:27 - people own so that they don't have to
684:28 - First Trade their tokens before they can
684:30 - use your contract so for example we
684:33 - could change our membership contract to
684:36 - sell the access to a club we could set
684:39 - the entry price at A th000 T but people
684:42 - could also pay the equip equivalent
684:44 - price using token a for the contract to
684:48 - be able to do that and use the right
684:50 - price it will need to obtain the
684:53 - exchange rate between those two
684:56 - tokens but this can be done through the
684:58 - liquidity pool you could use the view
685:00 - get token price from the liquidity pool
685:02 - to find out what's the current exchange
685:04 - rate let's take a look at this version
685:06 - of the membership contract it will use a
685:09 - ledger it will use our liquidity
685:13 - pool that we don't change and here is
685:16 - the membership contract when we created
685:18 - we initialize the membership price in TZ
685:21 - we said the owner we give the address of
685:23 - The Ledger and the address of the
685:25 - liquidity pool and we have our set of
685:28 - members
685:29 - here then users have two ways to join
685:33 - the club they could
685:36 - join by simply paying the membership
685:39 - price in TZ so we check that they pay
685:41 - the right amount we add them to the list
685:45 - of members and we send the amount to the
685:48 - owner this is a extra usess line here
685:52 - but users could also join this club by
685:54 - paying with
685:56 - tokens and when they call they say how
685:58 - many tokens they
686:00 - pay we will then check the current token
686:04 - price by using the get token price
686:07 - onchain view from the liquidity
686:09 - pool and then we check that if you
686:13 - multiply the number of tokens that the
686:14 - user is willing to pay with this current
686:18 - price it should be at
686:20 - least the membership price in TZ and if
686:24 - that's the case then we transfer the
686:26 - tokens from The Ledger to the
686:30 - owner and then we add this user to the
686:35 - club then we have our test where we
686:37 - create a ledger liquidity pool we
686:40 - provide liquidity to the liquidity pool
686:42 - then we create the membership contract
686:44 - with a entry price of a th000 TZ we have
686:48 - Bob simply join the club by paying a
686:51 - th000
686:51 - TZ then we have Carl joined by paying
686:55 - 1,000 tokens let's give it a
686:59 - try it
687:01 - worked so we see that we created The
687:04 - Ledger the liquidity
687:07 - pool we provide liquidity to the
687:10 - liquidity pool then create the
687:13 - membership
687:16 - contract and then we transfer a thousand
687:19 - TZ from Bob's account so that Bob can
687:22 - join we can see here that Bob is a
687:26 - member then Alice transfers 2,000 tokens
687:29 - to Carl so that Carl can join using
687:33 - tokens and Carl allows for 1,000 T to be
687:37 - spent by the membership contract and
687:39 - then calls joins with tokens with a
687:42 - thousand token
687:44 - and the tokens are transferred and so
687:46 - the current
687:48 - price paying 1,000 token
687:51 - works now the issue is that
687:54 - unfortunately this contract has a very
687:56 - serious flaw and the question is can you
687:59 - figure out a way to obtain membership at
688:02 - a very low price and as a hint I can
688:05 - tell you that the idea is that the
688:07 - exchange rate can be
688:10 - manipulated look at this membership
688:12 - contract and think about how we can
688:14 - manipulate the price so that people can
688:16 - join the club without paying much pause
688:20 - the video think about it for a minute so
688:23 - the way you can manipulate the price to
688:26 - join the membership contract is that you
688:28 - can manipulate the exchange rate of
688:31 - token a versus T to do that you would
688:35 - first buy a lot of tokens a from the
688:38 - liquidity pool this will automatically
688:41 - increase the price of token a by a lot
688:43 - in this liquidity pool then you can
688:46 - purchase membership in the club using
688:50 - just a few tokens a because those tokens
688:52 - are worth a lot now and then you can
688:55 - sell your tokens a back to the liquidity
688:57 - pool at the same price you bought them
689:00 - so you temporarily increase the price of
689:03 - token a by a lot by purchasing most of
689:05 - the tokens a from the liquidity pool to
689:08 - make them be worth a lot then you use
689:11 - them to purchase membership and it will
689:13 - check the price using this liquidity
689:15 - pool and then you can sell all your
689:18 - tokens back but for this to work you
689:21 - need to have enough funds to buy tons of
689:23 - tokens a from the liquidity pool and you
689:26 - also need to make sure that nobody jumps
689:29 - on the abrage opportunities because if
689:30 - you bought a lot of tokens then people
689:33 - can sell tokens to the liquidity pool
689:35 - because the price is very high before
689:38 - you get to purchase membership in your
689:40 - contract and remember that there's
689:41 - always Bots looking for these
689:43 - opportunities so as soon as you buy a
689:45 - lot of tokens a some bot will purchase
689:48 - tokens a from a different pool and then
689:50 - sell them to the liquidity pool to make
689:52 - a profit and your attack won't work so
689:55 - for this attack to work we need to make
689:58 - sure we have enough funds and we need to
689:59 - make sure nobody can jump on the
690:01 - Arbitrage opportunity that you create by
690:03 - buying so many tokens because if this
690:05 - happen when you sell them back you won't
690:07 - be able to sell them at the right price
690:08 - and you will lose money so if you assume
690:11 - that you only have 200 Tes how could you
690:14 - still join this club without spending
690:17 - much pause the video and think about it
690:20 - for a minute so the solution to both
690:22 - issues with our attack is to use a flash
690:25 - loan you could borrow enough TZ through
690:29 - a flash loan to purchase lots of token a
690:33 - and therefore impact the
690:35 - price and then you could pay back the
690:37 - loan within the same transaction and if
690:40 - you do everything within a single
690:41 - transaction nobody will be able to use
690:44 - Arbitrage because nobody can run any
690:46 - smart contract call or any transaction
690:48 - at all within your transaction as an
690:51 - exercise you will try to simulate this
690:55 - using The Ledger the liquidity pool The
690:57 - Flash loan and the membership contracts
691:00 - you will create an attack manually in
691:02 - your test that will make it possible to
691:04 - purchase a membership from an account
691:06 - that only spends 200
691:08 - test to create this attack you need to
691:11 - be careful with the execution or of a
691:14 - transaction remember that when from an
691:16 - entry point you call a smart contract
691:19 - you're not actually executing that smart
691:21 - contract right away you're adding it to
691:23 - a stock of transactions that will be
691:26 - executed after the execution of your
691:28 - entry point and the Order of execution
691:31 - of the different transactions is
691:32 - important for you to be able to create
691:34 - this attack and to help you we prepared
691:38 - a file that you can find on open tesos
691:40 - or on git with all the contracts you
691:42 - need and you just have to write a test
691:45 - pause the video and give it a try let's
691:47 - look at the
691:48 - solution so we have our Ledger we have a
691:52 - liquidity pull we have a fles loan
691:58 - contract then our membership contract
692:00 - and then we will create an attor
692:02 - contract that it will temporarily use a
692:05 - flash loan to increase the value of our
692:09 - token then use just a few token to pay
692:11 - for the membership and then pay pay the
692:14 - loan back so this attacker will need the
692:17 - address of all the different constructs
692:19 - it will interact with we will need to
692:22 - calculate how many tokens we buy so this
692:25 - is a value you can calculate and we
692:29 - initialize how many Tes we will borrow
692:32 - from The Flash loan and we have the
692:35 - price of membership and so the attack
692:38 - needs to be in three parts that's
692:40 - because the first part will borrow some
692:43 - test from The Flash loan but since we
692:47 - don't get the funds immediately we
692:48 - cannot do the second part immediately so
692:51 - what we do is we then call the second
692:53 - part to make sure the second part is
692:55 - executed After we receive the funds from
692:58 - the flash Loan in the second part we
693:02 - will buy tokens from the liquidity pool
693:05 - and then call the next part because the
693:07 - next part needs to happen after we
693:09 - receive the tokens from the liquidity
693:10 - pool so that we can then benefit of the
693:13 - new of the token in the liquidity pool
693:15 - to purchase the
693:17 - membership so here we borrow funds from
693:22 - the flash
693:23 - loan here we buy a lot of tokens from
693:27 - the liquidity
693:30 - pool and here we buy the membership at a
693:34 - low price we sell our tokens back to the
693:37 - liquidity pool and then we replace the
693:39 - flash loan we can check the details and
693:43 - here we can see see that we use the view
693:45 - from the liquidity pool to compute how
693:47 - many tokens we need to pay to the
693:49 - membership
693:52 - contract and send here so we compute
693:55 - here pricing
693:56 - tokens by getting the current price of
694:00 - our token and then we see how many do we
694:03 - need to pay for the membership price we
694:05 - add one to take into account running
694:08 - issues and that's the amount we will
694:11 - transfer when paying for the membership
694:13 - ship then in the test we can see that we
694:16 - create the liquidity pull The Ledger the
694:19 - membership flash loan we deposit some
694:21 - funds on the fles loan and then we
694:24 - simply call or attack your contract
694:27 - after allowing the liquidity pool in the
694:29 - membership address to withdraw some
694:31 - tokens from the funds of the attacker
694:34 - contract so the question you may now ask
694:36 - is how do we prevent such a tax and for
694:39 - that you need to really understand
694:41 - what's the cause of the flaw and the
694:42 - cause of the flaw is that the liquidity
694:44 - pool may not always reflect the real
694:47 - exchange rate it only reflects the real
694:50 - exchange rate if you get enough time for
694:53 - Arbitrage opportunities to be taken
694:55 - advantage of by Bots or other
694:58 - users so knowing that how can we avoid
695:02 - this issue this type of attack pause the
695:04 - video and think about it for a minute so
695:07 - if you want to prevent a tax based on
695:08 - price manipulations one way is to keep
695:11 - track of prices within some time frame
695:14 - so for example within some number of
695:16 - blocks like five blocks then across
695:19 - those five blocks you could use the
695:20 - medium price within that time frame as
695:23 - given by the liquidity pool this gives
695:26 - enough time for Bots to take care of
695:30 - Arbitrage opportunities and you avoid
695:32 - flukes in the price of the liquidity
695:34 - pool and most of all you make sure you
695:36 - don't take the instant price returned by
695:38 - the liquidity pull based on the current
695:40 - balances you take a price that has
695:43 - computed before your current
695:46 - transaction there's another approach
695:49 - that consists in combining multiple
695:50 - sources multiple liquidity pools and
695:53 - again taking the median of their prices
695:57 - but you should make sure you don't take
695:59 - instant prices because multiple
696:01 - liquidity pools could be manipulated at
696:04 - the same time in this module you will
696:06 - learn how to generate events from a
696:08 - smart contract a feature that makes it a
696:11 - bit easier to create that
696:14 - that react to Smart contracts so smart
696:17 - contracts May emit events that you can
696:20 - observe from an offchain app and so the
696:23 - goal of events is to standardize how
696:26 - external apps can keep track of some
696:29 - aspects of a contract instead of having
696:32 - to go look at its storage analyze
696:35 - transactions in the block Etc they will
696:38 - simply be able to listen to events some
696:40 - examples where events could be used to
696:43 - inform for apps and their users an event
696:46 - that corresponds to the sale of an nft
696:48 - within a collection or an update to some
696:51 - value provided by an oracle or the
696:54 - operation of a new proposal for a multi-
696:56 - or a dow contract where the user is
696:59 - expected to participate and vote after
697:02 - checking what the proposal is in all of
697:04 - those cases it's convenient for the
697:07 - contract to emit events and for apps to
697:09 - observe those events so that they can
697:11 - react to it or warn the user about it to
697:14 - emit an event from an entry point you
697:16 - can add this instruction sp. Emit and
697:20 - then you have up to three parameters the
697:22 - first one is the only one that's
697:24 - mandatory the other two are optional the
697:26 - first one is a value attached to the
697:28 - event it can have the type of your
697:30 - choice here we put a string but it could
697:33 - be an integer it could be a record
697:35 - almost anything you like then you have
697:37 - an optional tag so it's a word with no
697:40 - spaces that is attached to the event
697:44 - and that deps can use in filters so you
697:47 - could listen to all of the events that
697:49 - have a specific tag for example so
697:52 - finally there's a wi type attribute and
697:55 - when you set it to True some extra
697:57 - content will be added to the event that
698:00 - describes the type of the value in a way
698:03 - that is fully annotated so events have
698:06 - absolutely no effect on chain it's not
698:09 - going to change anything about the
698:10 - behavior of your smart contract it's
698:13 - only only for offchain apps to observe
698:16 - they are emitted by a transaction and
698:18 - are listed in its result in the order
698:21 - that they are emitted and an app can
698:24 - obtain the list of events emitted by a
698:26 - transaction with their values their
698:29 - types and their tags they can do so
698:31 - through RPC calls directly to the node
698:34 - or they can use the dedicated API of
698:37 - indexers that support events for example
698:40 - TZ KT let's take a look at an example
698:43 - we'll take the basic C the calls
698:45 - contract that simply counts the number
698:47 - of times we call make call but now when
698:50 - we call make call it will emit three
698:52 - events one just with a string hello one
698:55 - that will have both a string and a tag
698:58 - my tag then finally one a bit more
699:01 - advanced where we include a full record
699:03 - with two attributes a tag and we include
699:07 - the annotated type of this record so
699:10 - whenever somebody calls my call all
699:12 - these three events will be generated in
699:15 - this order in the smart P IDE when we
699:18 - run it we can see that we have this meel
699:21 - entry point being called and then the
699:23 - hello event the second event and then
699:26 - this event with a record that's about it
699:30 - if you go to a block Explorer on the
699:34 - contract that emits event here we can
699:36 - see in the melon code emission of some
699:38 - event with a pair of ins then you can
699:42 - see that you have an event events tab
699:44 - that is only present for contracts that
699:46 - emit events and if you go to the events
699:49 - tab then you can see the different
699:52 - events from different transactions here
699:55 - we can see one in this block one in this
699:57 - block Etc in this module we will talk
700:00 - about how we can upgrade contracts
700:03 - whether it is to fix a bug or add new
700:06 - features so by Design and thanks to
700:10 - decentralization a Smart contract can't
700:12 - be mod ified by the author this is so
700:15 - that users can trust that the contract
700:18 - will always do what it says but the
700:20 - author of a smart contract sometimes
700:22 - really want to be able to make some
700:25 - changes it could be because they need to
700:27 - fix a bug that was found in the contract
700:29 - or it could be to add a new feature or
700:32 - make it compatible with a new standard
700:35 - or to fine-tune the business Logic for
700:37 - example how rewards are distributed or
700:40 - votes are counted Etc so the question is
700:44 - how can we solve this Dilemma on one
700:46 - side you want to make it possible to
700:48 - change a contract but on the other side
700:50 - you want to allow users to trust that
700:53 - the contract won't be changed to their
700:56 - disadvantage so how can you solve this
700:58 - dilemma pause the video and think about
701:01 - it for a minute a common solution is the
701:04 - simplest one you can simply replace the
701:07 - contract with a new one and sometimes
701:09 - it's just that simple you simply Point
701:11 - your dab to the new contra contract but
701:14 - this approach has limitations first you
701:17 - have to warn everyone that the new
701:19 - contract is being used and that the
701:21 - address that the DAP points to has
701:23 - changed and if users have Assets in the
701:25 - old contract they have to move these
701:27 - assets to the new contract and then stop
701:30 - using the old contract but these assets
701:33 - may be locked in the old contract for
701:35 - example into the deadline that is quite
701:37 - far in the future let's start with an
701:39 - exercise where you will take the endless
701:41 - World contract we use a version that has
701:44 - an unchain view that gives access to
701:46 - messages from each user and then your
701:49 - goal is to create a new version of this
701:51 - contract where we now require new
701:53 - messages to be at most 30 characters
701:56 - where we charge one test per message and
702:00 - we allow users of the old contract to
702:02 - transfer their messages to the new one
702:05 - for free without paying the one test per
702:08 - message so we have our existing endless
702:11 - World contract here that stores all the
702:14 - messages in the big map and that stores
702:16 - the owner with the right message entry
702:19 - point and then we have this onchain view
702:22 - read messages that simply returns all
702:25 - the messages for a given user so start
702:29 - from this contract and write a new
702:32 - version of the contract that can
702:34 - transfer all the messages using this
702:36 - view into the new contract you will have
702:39 - to have both contracts in your files so
702:41 - that you can create a test that makes
702:43 - them interact with each other pause the
702:46 - video and give it a try let's take a
702:49 - look at a solution so here we have the
702:52 - old contract and here this is the new
702:55 - version of the contract so we still have
702:57 - a big map to store all the content we
702:59 - still store the owner but we also store
703:02 - the address of the old contract so that
703:04 - we can interact with it in the right
703:06 - message entry point we simply make the
703:09 - changes to the logic where we charge one
703:12 - TZ and we check that the messages are
703:15 - shorter than 30 characters everything
703:18 - else is the same as the previous right
703:20 - message but now we add this new transfer
703:23 - old messages entry point where we call
703:26 - the view read messages from the old
703:29 - contract to obtain the data associated
703:32 - with that user the user who's calling
703:35 - this transfer old messages entry point
703:37 - and we simply store this old data in the
703:39 - new contract without charging anything
703:42 - we ass assume that the user never called
703:46 - right message so we simply create or
703:48 - replace uh the entry with the sender as
703:52 - the address finally we keep the same
703:55 - onchain view in case we want to upgrade
703:57 - the contract
703:59 - again and then in the test we first
704:01 - create the first contract with some
704:04 - message and we need and then we test the
704:07 - new contract where we write messages and
704:10 - of course longer messages are not
704:12 - allowed we need need to make sure we pay
704:13 - one t but we can also transfer messages
704:16 - from the old contract here by calling
704:18 - transfer old messages as Bob and then
704:22 - Bob can finally add new messages an
704:25 - issue with this approach is that it
704:27 - requires the initial contract to have
704:30 - views so that the new contract can
704:32 - access the old data so the question for
704:35 - you is how would you manage the transfer
704:37 - of data without having an onchain view
704:40 - in the old contract positive and think
704:43 - about it for a minute so if the old
704:45 - contract doesn't have any views we have
704:47 - to count on the owner to validate every
704:50 - transfer of data we can think of three
704:53 - approaches to do that the owner could
704:55 - simply initialize the contract with all
704:58 - of the data from the old one the issue
705:00 - with this approach is that this could
705:02 - exceed the gas limit for the deployment
705:05 - the origination transaction would be too
705:08 - large to fit in a single block and it
705:10 - would also be quite expensive the next
705:13 - option would be for the owner to have an
705:15 - entry point to transfer Bunches of data
705:18 - from the old contract and split the
705:20 - transfer between many different calls
705:24 - and the main issue with that is that the
705:26 - owner themselves will have to pay for
705:28 - all the storage costs and all the
705:29 - transaction costs required for all these
705:32 - calls and that could be quite expensive
705:34 - if the contract is very successful a
705:37 - better option would be for the owner to
705:40 - publish signed messages that allow users
705:44 - to repost each of their old messages so
705:47 - the idea here is that users should be
705:49 - able to post old messages for free but
705:52 - for any new message they would have to
705:53 - pay one TZ so the owner can send them
705:57 - signed messages of chain as a proof that
706:01 - the owner of the contract allows them to
706:03 - post this messages for free with this
706:06 - approach each user will pay for the
706:08 - transaction fees and the storage fees
706:10 - for the transfer of their own data
706:13 - they just don't have to pay the one Tes
706:15 - to the owner again so let's do this as
706:18 - an exercise you will start with the same
706:21 - initial endless walk contract as in the
706:23 - previous exercise but this time without
706:26 - the onchain view and then you can create
706:29 - a new version of the contract or modify
706:31 - your new version of the contract so that
706:33 - users can repost their old messages for
706:36 - free so you can assume that offchain the
706:39 - owner will publish a signature for every
706:42 - existing message and the signatures will
706:44 - guarantee that the old messages sent by
706:46 - users were present in the old contract
706:49 - so you will have to write a tests and in
706:51 - the test generate all the signatures and
706:54 - then call the new contract in the name
706:55 - of different users with the content of
706:58 - the messages and the corresponding
706:59 - signatures pause the video and give it a
707:02 - try let's take a look at the solution
707:05 - here we have the old contract that we
707:07 - didn't change except we remove the
707:08 - onchain view and here is the new version
707:12 - of the contract
707:13 - here we don't store the address of the
707:15 - other contract we don't interact with
707:17 - the other contract instead we store the
707:19 - public key of the owner that we will be
707:21 - able to use to verify signatures sent to
707:24 - the contract the right message entry
707:26 - point didn't change so we only change
707:29 - the transfer all messages entry point
707:32 - and we take as parameters the all data
707:35 - packed as a sequence of bytes and the
707:37 - corresponding signature then in the entr
707:39 - point we check that the signature is
707:42 - valid so we check that it corresponds to
707:44 - the public key of the owner for the
707:46 - signature and this packed data then we
707:49 - unpack the data the data contains the
707:53 - text of the messages from the user and
707:56 - the corresponding timestamp and the user
707:59 - address so we unwrap the data and then
708:02 - add it to the big map and in the test
708:05 - here after creating the new contract we
708:08 - fetch all data from the old contract off
708:11 - chain anybody has access to this data so
708:13 - we can simply fetch that data we create
708:16 - a record where we add the user address
708:18 - we pack it into a sequence of bite and
708:21 - then we call make signature using the
708:24 - secret key of Alice to generate a
708:27 - signature for this data and then we call
708:29 - transfer all messages let's give it a
708:32 - try and we can see that everything
708:34 - worked well in the version we just
708:37 - presented an issue is that all the
708:40 - messages were duplicated into the new
708:42 - cont contract and we had to have each
708:44 - user pay for the storage and transaction
708:46 - fees again this can be a bit costly but
708:49 - another issue is that if the data
708:51 - represents assets duplicating them could
708:54 - be problematic for example imagine that
708:57 - the assets are nfts if you duplicate
708:59 - nfts this would mean both the original
709:02 - nft and the copy could be sold
709:04 - separately and exist at separate nfts so
709:07 - the question for you is can you think of
709:09 - a solution in the case of an nft cont
709:12 - contct that avoids duplicating the nfts
709:15 - one solution in the case of an nft
709:17 - contract is to wrap the nfts we already
709:21 - use this approach as a way to go around
709:23 - paying royalties and the idea is that
709:26 - the new contract can buy an nft from the
709:29 - old contract and then Min its own
709:31 - version of the nft and this copy would
709:34 - become the new official version and
709:36 - could have a different set of rules for
709:38 - trading the nft compared to the old
709:40 - version but this can be considered as
709:42 - upgrading a contract this approach only
709:45 - works when the ownership of assets can
709:47 - be immediately transferred to a new
709:49 - owner that will be the contract if you
709:52 - can plan things in advance there are
709:54 - better approaches available so you can
709:57 - make upgradability a feature of your
710:00 - contracts we already saw that if you
710:02 - planned an onchain view in your contract
710:05 - this can allow you to duplicate the data
710:07 - but what we really want is to avoid
710:10 - duplicating the data but instead move
710:12 - the data or the assets into a new
710:14 - contract without duplicating them so the
710:17 - question is how can we make sure that
710:20 - data can be moved into a new version of
710:22 - the contract pause the video and think
710:25 - about it for a minute really
710:26 - transferring the data to another
710:28 - contract can be costly or complicated
710:32 - you have to repay for all of the storage
710:34 - costs in the new contract and you also
710:37 - have to split the transfer into many
710:39 - transactions so what we really want is
710:42 - to keep the the data in the same
710:44 - contract but since we want to upgrade
710:46 - the contract and have a new contract a
710:49 - good way to keep the data in the same
710:51 - contract is to separate the logic into a
710:54 - separate contract that interacts with
710:56 - the data contract so you have one
710:58 - contract that takes care of storing the
710:59 - data and then one contract that takes
711:02 - care of the logic and the contract in
711:04 - charge of the logic could easily be
711:07 - replaced so only the ownership of the
711:10 - data contract would then need to be
711:11 - transferred instead of the ownership of
711:14 - every asset in the old contract let's do
711:17 - it as an exercise so your goal is to
711:19 - create a version of the Endless World
711:21 - contract that is upgradeable and you do
711:24 - that by splitting it in two you will
711:27 - have one contract that will be in charge
711:29 - of storing the data and then a second
711:31 - contract that will contain the logic and
711:35 - access the data through the first
711:37 - contract then you will show how it can
711:39 - be upgraded by using a new contract that
711:43 - accesses to the data contract and again
711:46 - it should only allow messages to be of
711:47 - length less than 30 characters and it
711:50 - should charge one test for each new
711:52 - message let's take a look at the
711:54 - structure of such a contract so first we
711:56 - look at the data contract in the storage
712:00 - we will have all the content in the big
712:01 - map W content and then we store the
712:04 - owner of the contract but this time the
712:06 - owner is the address of the other
712:08 - contract the logic contract then we have
712:11 - two entry points that will be be called
712:13 - by the logic contract the first one is
712:15 - the right message entry point that takes
712:17 - the message and the user as parameter
712:20 - the caller will be the logic contract so
712:23 - we check that indeed only the logic
712:25 - contract can call this entry point and
712:28 - then we simply store this data into W
712:30 - content with the user as the key then as
712:33 - the goal is to be able to upgrade the
712:35 - logic contract we need another entry
712:37 - point update owner where the previous
712:40 - logic contract can say okay okay I need
712:42 - to be upgraded here is the address of
712:45 - the new contract that will take over the
712:46 - logic and so we pass the address of the
712:49 - new contract as parameter and we check
712:51 - that the caller is indeed the current
712:53 - owner before updating to the new owner
712:57 - then let's look at the structure of the
712:59 - logic contract that we call upgradable
713:02 - endless wall in the storage here we
713:04 - don't store much we simply store the
713:06 - address of the data contract and the
713:09 - address of the owner of this contract in
713:11 - the entry points we simply have the
713:14 - usual WR message entry point that takes
713:16 - a message as a parameter and all it will
713:19 - do is call the right message entry point
713:22 - of the data contract with the message
713:25 - and the address of the caller then when
713:27 - we want to upgrade this contract we call
713:29 - an entry point upgrade with the address
713:31 - of the new contract we check that it's
713:33 - the owner of this contract that calls
713:36 - and then we call the data contract to
713:38 - say update the owner to the address of
713:41 - the new contract so your goal is to
713:43 - implement these two contracts and
713:46 - demonstrate the upgrade procedure to a
713:48 - new contract in your test and of course
713:51 - again the new version of the contract
713:53 - should only allow messages of length
713:55 - below 30 and charge one test for each
713:58 - new message pause the video and give it
714:00 - a try let's take a look at a solution so
714:03 - we start with the data contract we see
714:06 - here that we have our big map and the
714:08 - address of the owner contract here in
714:11 - write message we check that the caller
714:14 - is the owner so the logic contract and
714:17 - then we simply add the content as usual
714:20 - in the big map and then the update owner
714:23 - entry point simply checks that the
714:25 - caller is the Old owner and replace it
714:28 - with a new address of the logic
714:31 - contract then in logic contract we store
714:34 - the owner and the address of the data
714:36 - contract in the right message all we do
714:39 - is call the right message entry point of
714:41 - the data contract contract and then in
714:43 - the upgrade contract we call the update
714:46 - owner entry point of the data contract
714:49 - to change the owner after checking that
714:52 - this is the owner of the logic contract
714:54 - doing the transfer in the new version of
714:56 - the logic smart contract we keep exactly
714:59 - the same structure and the same content
715:01 - the only thing we need to change is to
715:03 - add the assertions that about the length
715:05 - of the message and at about the one test
715:08 - price to call right
715:10 - message and in the test
715:12 - we first create the first version we
715:15 - pass we first create the data contract
715:18 - we pass it to the first version of the
715:21 - logic contract then we upgrade to the
715:23 - new version and continue adding messages
715:26 - we can give it a
715:30 - try and we can see that we can keep
715:33 - adding
715:34 - messages and then we have all the
715:36 - messages sent through the old logic
715:39 - contract and the messages sent with the
715:41 - new log contract so one issue with this
715:44 - new solution is that sometimes we really
715:47 - don't want the address of our contract
715:49 - to change because then we need to send
715:51 - everybody to the new address so to deal
715:54 - with that we can use a proxy contract a
715:57 - proxy contract is a contract that
715:59 - forwards all of the calls to the real
716:02 - contract so it's an inter intermediate
716:04 - between the user and the real contract
716:06 - and the address of this real contract
716:09 - can be changed while your proxy contract
716:11 - never changes
716:13 - as long as the API the entry points and
716:15 - the parameter of the entry points stay
716:17 - the same so let's give it a try as an
716:20 - exercise try to make the endless wall
716:22 - contract upgradable using this proxy
716:25 - pattern then show how it can be upgraded
716:29 - to add the rules about the length of the
716:31 - message without changing the address
716:33 - that people use to interact with the
716:35 - contract so here we would have again two
716:39 - contracts the inner andless W contract
716:42 - would have the usual storage with the
716:43 - big map and the address of the owner
716:45 - that will be the proxy contract and
716:47 - we'll simply have one entry point write
716:49 - message the TT this parameter the
716:51 - message and the user check that the
716:53 - caller is the owner and update the data
716:56 - and in the proxy contract we will store
716:59 - the owner and the address of the inner
717:01 - contract in the right message contract
717:04 - we simply call the inner contract write
717:07 - data entry point with a message and the
717:09 - user that is the caller and and then we
717:12 - have an entry point to upgrade to a new
717:14 - contract we check that the caller is the
717:16 - owner and then we replace inner contract
717:19 - with the address of the new contract so
717:22 - your goal is to implement these two
717:23 - contracts and demonstrate the upgrade to
717:26 - a new inner contract pause the video and
717:29 - give it a try let's take a look at the
717:31 - solution so here we have our inner
717:33 - contract with the wall content and the
717:36 - owner the right message entry point is
717:40 - the usual nothing special about it
717:43 - then we have here our main proxy
717:46 - contract where we store the owner and
717:48 - the address of the inner contract and
717:50 - whenever we call write message we simply
717:52 - forward that call to the inner contract
717:56 - and when we want to upgrade we simply
717:59 - store the new address of the inner
718:01 - contract and if we want to upgrade this
718:03 - contract we only upgrade the inner
718:06 - contract and so we can update the
718:07 - address of this inner contract and keep
718:09 - using the same address for the main
718:12 - contract so here we have a new version
718:15 - of the inner contract this is pretty
718:17 - much the same as the initial one but
718:19 - with this extra
718:23 - assertion and here again we have the
718:25 - test that first creates the proxy then
718:28 - initializes the inner contract and then
718:31 - we upgrade to the new inner contract can
718:35 - give it a try and see that it works so
718:38 - once more there is an issue with this
718:40 - approach is that which is that when we
718:43 - upgrade the inner contract all the data
718:46 - is lost and again deploying the new
718:48 - inner contract with a copy of all of the
718:50 - data would be too costly but we could
718:53 - combine the two approaches that we just
718:55 - saw the proxy W contract on one side and
718:59 - splitting the contract between the logic
719:01 - and the data on the other side so we
719:04 - would have three contracts it starting
719:06 - to be a bit complicated but it can work
719:09 - in the next module we will see another
719:11 - approach that is based on a feature
719:13 - called Lambda in this module we will see
719:17 - another approach that can be used to
719:19 - upgrade contract and that is using a
719:21 - feature of the language called landas on
719:25 - tesos it is possible to store pieces of
719:28 - code in a variable or in the storage of
719:31 - a smart contract using lambdas a Lambda
719:35 - is a piece of code that can be stored
719:37 - then executed in particular it's a piece
719:40 - of code that can take some parameters
719:42 - and that returns a value this value
719:45 - could contain operations to execute but
719:47 - by default they have no side effect so
719:51 - executing Lambda itself won't change the
719:54 - storage or emit operations but with
719:57 - smart P there's a syntax that makes it
719:59 - transparent to include feature that
720:01 - allows to do either of these so let's
720:04 - see how to create a Lambda to create a
720:07 - Lambda we declare a function within the
720:09 - main module that takes one parameter
720:12 - error and return a value we can keep
720:15 - this Lambda in the storage by simply
720:17 - using the name of the function as the
720:20 - value as we do here we store a default
720:23 - rule that is defined here in the data.
720:27 - rule attribute of the storage then we
720:29 - can call it from an entry point so here
720:32 - when we call execute rule we can call
720:36 - self. data. Rule and pass the current
720:39 - value as a
720:40 - parameter and then we get the result and
720:43 - store it again in the contract so here
720:45 - this is a rule that simply increments
720:47 - the value that we passed as a
720:49 - parameter then we can have another entry
720:52 - point that updates the rule to a new
720:54 - function so here we can call we can
720:57 - simply change self. data. value equals
721:00 - new rule where we use a different Rule
721:02 - and store it so our Lambda really only
721:04 - takes one parameter so if we want
721:07 - multiple parameters we have to use a
721:09 - record in the definition of your
721:11 - function
721:12 - you actually declare multiple parameters
721:14 - separated with commas but these
721:16 - parameters will correspond to different
721:18 - attributes of the record that you will
721:21 - send when you make a call so here we
721:23 - have two parameters A and B and the rule
721:26 - simply adds A and B and Returns the
721:28 - result but when we call this Lambda we
721:31 - need to create a record with the
721:34 - attribute a with the first value and the
721:36 - attribute B with the second value so
721:39 - here it looks like separate parameters
721:42 - but when you make the call it's a single
721:43 - parameter that is a record containing
721:46 - two
721:46 - attributes although internally lambdas
721:49 - do nothing except doing some computation
721:52 - and returning a value and cannot modify
721:54 - the storage or create transactions in
721:56 - smart Pi we have added syntax that you
721:59 - can use in Lambda to allow you to modify
722:01 - the storage and create transactions so
722:03 - in practice what really happens is that
722:05 - the internal lamb does simply return the
722:08 - changes to apply to the storage and also
722:11 - return a list of transactions to be
722:13 - added to the list of transactions of the
722:15 - entry point let's work on an exercise
722:18 - where you will create an upgradeable
722:20 - contract using a Lambda so you will
722:23 - start again with the endless wall
722:25 - contract and then make it upgradeable by
722:28 - the author using a Lambda so that you
722:30 - can support rules about the amount to
722:33 - pay when writing a message and rules
722:36 - about the content of the messages that
722:38 - are allowed for example the length of
722:40 - those messages so everything about that
722:43 - should be handled by a Lambda and then
722:45 - you add an entry point to allow the
722:47 - author of the contract to change this
722:49 - rule so the initial rule should be that
722:52 - any message is allowed and it's free and
722:54 - the new rule should be that the messages
722:56 - length should be less than 30 characters
722:59 - and the amount to pay should be one test
723:02 - pause the video and give it a try let's
723:04 - take a look at a solution here in the
723:07 - main module we create two versions of
723:09 - the internal rule the first version
723:11 - doesn't do anything we don't check
723:13 - anything we allow every message and it's
723:14 - free the second rule simply checks that
723:17 - the length of the message is less than
723:20 - 30 characters it should be strictly less
723:24 - and you will notice that we don't check
723:25 - anything about the price yet we'll talk
723:27 - about it in a
723:29 - minute so in the endless World contract
723:32 - we as usual store the content in the big
723:35 - map the owner but then we store this
723:37 - extra value that will be a Lambda verify
723:40 - that takes care of very verifying if we
723:43 - allowed to send a given message so we
723:45 - initialize it with default verify
723:47 - message in the right entry point we do
723:50 - the usual but at the beginning we simply
723:53 - call at s. data. verify with the
723:57 - message and then we have an entry point
723:59 - to change the rule set verify that TT
724:02 - the new Ru as parameter and we verify
724:04 - that it's the owner calling it and we
724:07 - simply store this new rule so one issue
724:10 - here is that we did didn't plan in our
724:13 - right message entry point that we would
724:16 - be able to change the price of calling
724:20 - message so since we didn't plan it and
724:23 - didn't pass the amus parameter we will
724:25 - be stuck here and cannot verify the
724:28 - price so when you use a Lambda you have
724:31 - to think ahead of time everything that
724:33 - you want to be able to change on one
724:36 - side it's good because people who read
724:37 - this contract know that all you can do
724:40 - is check if this is allowed based on the
724:42 - content of the message and if they read
724:44 - this they see okay you won't be able to
724:46 - charge ever in the future so I'm free to
724:49 - use this it's always going to be free I
724:51 - don't need to worry about so in a way
724:54 - that's a good thing so you have to think
724:56 - about everything you may want to change
724:58 - in the future so if we want to make sure
725:01 - we can decide later on to add a price we
725:05 - need to send the
725:08 - amount to the
725:10 - Lambda but again we cannot simply send
725:13 - two parameters we have to create a
725:14 - record so we
725:16 - create parm equals sp.
725:19 - record
725:21 - [Music]
725:26 - message like this and then we send that
725:35 - parameter and now we need to change each
725:39 - of these lambdas to add the
725:42 - price here and here and then we can
725:48 - assert price
725:51 - equals one t so if we give it a
725:56 - try we can see that here we didn't send
725:59 - one TZ because I just changed the rule
726:01 - but here we can pay one
726:09 - t and then it works
726:12 - all good so when using lambdas as we
726:16 - just saw you can only change aspects
726:18 - that were already planned to be changed
726:21 - another example is that in the code we
726:24 - just presented we couldn't add a rule
726:26 - about the total length of a text G a
726:29 - given user may have we can only make a
726:31 - rule about the new messages that we add
726:34 - but not the total amount of text that
726:36 - they store in the contract but as we
726:39 - said this is a good thing the Min users
726:41 - can read the contract and know the
726:43 - limitations of what changes you may make
726:46 - in the future so that they can trust
726:48 - that everything else won't change which
726:51 - is a really important part of using
726:53 - smart contracts in a decentralized
726:56 - blockchain in this short module we will
726:58 - list all the different ways we presented
727:00 - on how to upgrade contracts we presented
727:04 - four different ways the first one was to
727:06 - Simply Point The Depths to a new
727:09 - contract which implied supporting
727:12 - transfers of data or assets to the new
727:15 - contract but we saw that the transfer
727:17 - may be inconvenient or costly and that
727:20 - for nfts we could use wrapping as a way
727:23 - to transfer the assets the second
727:26 - approach was to store the data in a
727:28 - separate contract that could be used by
727:31 - the New Logic contract but of course
727:34 - this means we cannot change the
727:35 - structure of the storage between
727:37 - versions since we keep this data
727:40 - contract between
727:42 - upgrades the third version was to use a
727:45 - proxy contract so that we could keep the
727:47 - same address for the contract but the
727:50 - limitation is that this means the API
727:52 - has to be the same between versions and
727:55 - finally we just saw how we can use
727:57 - lambdas to place some of the logic in
728:01 - the storage of the contract so this
728:04 - means there are limitations to what the
728:06 - owner can change in the contract which
728:08 - can add trust for the users but that
728:11 - also means that all the aspects that the
728:14 - owner may want to change need to be
728:16 - thought about in advance so here we
728:19 - talked about how to upgrade the contract
728:21 - but in each case the owner could
728:23 - unilaterally make changes to the
728:25 - contract at any moment so we could limit
728:29 - what the owner could change but still
728:32 - they could change quite a bit whenever
728:34 - they
728:35 - wanted but we really want users to be
728:38 - able to trust that the contract won't be
728:40 - changed so easily
728:42 - as this really defeats the whole point
728:44 - of using a disiz blockchain so there are
728:47 - two ways to help reduce the risk of a
728:49 - better surprise for the user when a
728:52 - contract is being upgraded the first one
728:55 - is to have a delay between the time the
728:57 - change is made public and the time this
729:00 - change is effective so for example you
729:02 - could have a two weeks delay that allows
729:05 - users of the contract to exit the
729:07 - contract and get their assets out before
729:10 - the changes applied if they dis like
729:13 - that change but this may not always be
729:15 - possible the assets could be stuck in
729:17 - the contract for a very long time
729:20 - another approach is to use contract
729:23 - governance basically letting users vote
729:27 - and only apply changes that users
729:30 - approve this can be done through a
729:32 - multi- or a da a decentralized
729:35 - autonomous organization contract which
729:38 - will we present in the next module in
729:40 - this mod module we will talk about
729:42 - multisig and DOW contracts contracts
729:46 - that allow people to work together as
729:48 - one for example to collectively manage
729:51 - some assets so first we'll talk about
729:54 - decentralized autonomous
729:56 - organization or Dao a Dao is a smart
729:59 - contract that enables communities to
730:02 - collectively manage resources the
730:04 - participants in a DA can contribute
730:07 - funds or resources that are stored in
730:09 - the contract then in exchange they
730:12 - receive tokens or shares representing
730:15 - their ownership and influence within the
730:17 - Dow then they can propose ideas projects
730:21 - or
730:22 - changes then vote to determine which of
730:24 - these ideas are accepted or rejected and
730:28 - people may receive Rewards or incentives
730:31 - based on their contribution work or
730:33 - voting
730:34 - participation so the good thing with
730:36 - Dows is that the decision process to
730:38 - manage the shared assets is
730:40 - decentralized fair and transparent dials
730:44 - can be used in many different
730:46 - situations for example you can have
730:48 - collective decision making on a project
730:51 - development where you allocate resource
730:53 - manage the budget and distribute rewards
730:56 - those can also be used in various
730:58 - Industries such as Finance art
731:01 - governance social impact and
731:03 - decentralized
731:05 - applications in finance daos can
731:08 - facilitate decentralized investment
731:10 - funds lending platforms or decentralized
731:14 - exchanges finally Dows can Empower
731:17 - communities to collectively manage
731:19 - digital assets develop open-source
731:22 - software curate content platforms or
731:25 - govern decentralized protocols as an
731:28 - example let's look at the C Finance
731:31 - protocol col is a defi protocol that
731:34 - allows users to borrow stable coins
731:37 - against T it uses smart contracts and
731:41 - each smart contract is referred to as an
731:43 - oven to collateralize TZ versus the
731:46 - stable coin kusd each oven has multiple
731:51 - functions you can deposit some Tes into
731:54 - the oven you can withdraw TZ from the
731:58 - oven you can borrow kusd against the
732:01 - oven using TZ as collateral then you can
732:04 - repay K USD that was borrowed against
732:07 - the oven finally you can liquidate and
732:10 - your OV is liquidated automatically if
732:13 - your borrowed stable coin exceeds your
732:16 - test
732:17 - deposit so let's look at how a DA is
732:20 - used to manage the governance of the C
732:23 - Finance protocol Kow is the governance
732:26 - token used for the cber finance protocol
732:29 - and you need to own Kow to participate
732:31 - in the governance of the protocol you
732:33 - can vote or submit proposals to submit a
732:37 - proposal you need 1,000k D and you
732:40 - submit it it on the c. Finance protocol
732:43 - by pushing a piece of code a Lambda as
732:47 - an example we can take a look at
732:48 - proposal 41 it was proposed after a
732:51 - white hat hacker had found two critical
732:54 - vulnerabilities in the C protocol that
732:57 - could have led to a drain of all of the
733:00 - funds of the protocol this white hat
733:02 - hacker disclosed those vulnerabilities
733:05 - and the developers took actions to patch
733:07 - the bugs but as a reward the community
733:10 - decided to make an unchain proposal via
733:13 - the Dao implementation in order to
733:16 - transfer 50,000 USD to the white hat
733:19 - hacker we can go to the Cur governance
733:22 - website to check all the different
733:24 - proposals and we see here proposal 41
733:26 - pay security researcher for bug
733:29 - disclosure and we can see that people
733:31 - voted yes by a wide majority and some
733:34 - people abstained and we can click here
733:37 - to see the detail of The
733:39 - Proposal with a short description a link
733:42 - to some details and here we can see the
733:44 - melson code of the Lambda that was sent
733:48 - and that included a transfer of tokens
733:50 - to the
733:51 - researcher another example of Da is the
733:55 - tesos ecosystem da it was designed to
733:59 - curate and vote on the distribution of
734:02 - TZ for various tesos ecosystem
734:04 - initiatives it's governed by a small
734:07 - number of key holders that include the
734:08 - tesos comments TR TCH tesos domain
734:11 - Foundation the tesos foundation itself
734:14 - and the tesos India Foundation anyone
734:17 - can submit any initiative to the DA via
734:20 - the tesos Agora Forum then the
734:22 - initiatives will be curated by tesos
734:24 - comments and proposed to the DA on chain
734:28 - and the objective is to facilitate
734:30 - Community engagement in funding
734:32 - decisions and to promote the growth and
734:34 - development of the tesos
734:36 - ecosystem basically it's a way for
734:38 - people to be rewarded to contribute to
734:41 - the tesos
734:42 - ecosystem now let's take a look at what
734:45 - the smallest Dow could be we can have a
734:48 - variety of different types of dows with
734:50 - different features including governance
734:52 - tokens rewards Etc but they all include
734:55 - a voting system with various rules on
734:58 - how votes are counted for example with
735:01 - quorums Etc so a minimal Dow would
735:05 - include a list of participants a system
735:08 - to propose decisions and a voting
735:10 - process where decisions are executed
735:13 - when approved by a given number of
735:15 - participants this kind of minimal Dow is
735:18 - already very useful it even has its own
735:20 - name we can call it a
735:22 - multisig so what is a multisig it's a
735:25 - contract that requires multiple
735:27 - signatures in order to execute a given
735:29 - transaction this is a way to enhance
735:32 - security by ensuring that no single
735:34 - party has complete control over a
735:36 - transaction for example if you have a
735:38 - company you don't want to have one
735:40 - single person in charge of the private
735:42 - keys and instead you can use a multi
735:45 - where multiple people have to agree
735:47 - before a transaction is confirmed multi
735:50 - contracts operate on the principle of
735:52 - consensus where a predetermined number
735:54 - of signatures are required to authorize
735:57 - a transaction each signature is
735:59 - associated with a specific participant
736:02 - or key holder and the contract verifies
736:05 - that the required number of signatures
736:07 - is provided multis contracts are
736:10 - commonly used to secure funds or assets
736:13 - especially in cases where multiple
736:15 - parties are involved or an added layer
736:18 - of trust and oversight is desired multi6
736:22 - can be used in a number of use cases for
736:24 - example for escr services multis
736:27 - contracts can be used when funds are
736:29 - held in a contract until specific
736:32 - conditions are met and multiple parties
736:34 - must provide their approval for the
736:36 - release of the funds it can be used in
736:38 - decentralized organizations where they
736:40 - facilitate this centralized decision
736:41 - making within organizations by requiring
736:45 - multiple keyh holders to approve
736:47 - proposals or fund
736:48 - location finally they can be used to
736:51 - secure wallets multi contracts can be
736:53 - used to create secure wallets where
736:55 - multiple signatures are required to
736:57 - authorize outgoing
736:59 - transactions which provides enhanced
737:01 - protections against unauthorized access
737:04 - or theft as an exercise your job will be
737:07 - to create a multi- contract where in the
737:10 - storage you have a a predefined set of
737:12 - participants and a number of required
737:14 - votes to approve a proposal and you will
737:18 - have an entry point to make a proposal
737:20 - in the form of a Lambda to execute with
737:22 - a deadline and another one to vote for
737:26 - that proposal and have it executed when
737:28 - the number of votes is reached pause the
737:31 - video and give it a try let's take a
737:33 - look at our solution so here we have a
737:37 - Lambda that we will use as an example of
737:39 - proposal that simply sends some Tes to a
737:43 - given address in the contract
737:45 - itself we will have a set of
737:49 - participants a big map with all the
737:52 - proposals a number of required votes for
737:55 - a proposal to be accepted and then the
737:58 - ID that we use as a key for the
738:00 - proposals
738:02 - bigma in the proposed entry point people
738:05 - can call the proposed entry point to
738:07 - send a piece of code a Lambda with with
738:10 - a deadline for people to vote we check
738:14 - that the caller is one of the
738:16 - participants in the
738:18 - multi then we store the proposal with
738:20 - the next ID and we store the code the
738:22 - deadline number of approvals at zero and
738:25 - then a set of people who have already
738:29 - voted to make sure people cannot vote
738:31 - twice on the same proposal then we
738:33 - increment the ID when somebody votes
738:36 - they indicate for what proposal they
738:38 - vote and then we check that they vote
738:41 - before the deadline we check that there
738:43 - are indeed a participants in the multi
738:45 - seek and we check that they have not
738:47 - already voted then we Mark they have
738:50 - voted we increment the number of
738:52 - approvals and then we check if the
738:55 - number of approvals is equal to the
738:57 - required number of votes then we execute
739:00 - the proposal we don't need to delete the
739:03 - proposal because we have to be exactly
739:05 - at the number of approved so if one more
739:07 - person votes then we will exceed the
739:09 - number of proposals and so this will not
739:11 - be
739:13 - executed and in the test we simply
739:16 - instantiate the multi seek with a set of
739:18 - participants and a required number of
739:21 - votes at two so both Alice and Bob have
739:24 - to approve a proposal for it to be
739:27 - executed then we propose a Lambda and
739:31 - have both people vote for it
740:10 - for

Cleaned transcript:

if you're interested in blockchain development this indepth course will teach you about the tasos ecosystem and how to develop distributed applications for it the only prerequisite for it is a little python knowledge this course was made possible through a grant from the tasos foundation back in 2022 in this module we will do a quick overview of the different applications the blockchain like tesos already makes possible the first type of application is to help the building of communities around brands or teams and to make it possible to own an internal and unique piece of History nfts make it possible for fans or customers to own and collect a token specific to their favorite team or to their favorite brand then marketplaces exchanges or Dows make it possible to build communities around them and help give fans a sense of belonging tesos is used for this in all kinds of fields for example fashion soccer Formula 1 Esports or even Spring Water another application of tesos is in the field of games where it can be used to add new features that help extend the life of games and provide a better experience for gamers it can be used to eternally preserve a player's achievements it can also be used to create multigame challenges and it also lets users collect and trade in game assets tesos is also used a lot in the field of art it helps give artists A much wider and International audience and it brings new ways for artists to make a living thanks to direct sales or royalties it also enables the production and sale of new forms of art such as generative art a very strong field for blockchains is decentralized finance that brings new Financial products and make them available to anyone some examples on tesos include projects like lug a stable coin ped to the Euro or real estate tokenization projects that make it easy to own a piece of a property and decentralized lending markets that make it easy to borrow different types of tokens tesos can also help people develop initiatives around causes for example around protecting the environment it can be used to raise funds for nature preservation and to build communities around nature awareness these are only a few examples of what's possible with tasos and it is only the beginning by following this course and learning to develop your own smart contracts you will be able to invent your own applications in one of these fields or in other fields in this short module we'll do a quick overview of what you will learn during this course we'll start by showing you the different key components of a blockchain and it's ecosystem so we'll talk about accounts about wallets about blogs Etc so that you can understand all of these different elements and their names then you will practice by creating an account and performing a fut transactions calling smart contracts Etc in The Next Step we'll have a video that shows you all the different steps that a transaction takes from the moment you decide for example to purchase an nft to the moment that this transaction is final on the blockchain so that will help you understand what really happens internally and how things work in the blockchain then we'll focus on the heart of this course which is for you to learn to develop your own smart contracts using the smart P language one of the several languages that are available to write smart contracts on tesos while you learn to write your smart contracts you will also learn how to develop your own test scenarios for your smart contract to make sure that everything works and to avoid the main bugs you will practice all this on a variety of concrete exercises an example this will be a very practice oriented training and we ask you to play along and really try to solve each exercise because we really believe that this is by practicing that you really learn the best so you will learn smart contract Concepts from the very basic types like basic numbers and strings all the way to very Advanced smart contract Concepts such as inter contract calls or upgradable contracts and you'll realize that smart contracts are usually small projects so it's not very hard to write smart contracts but the hard part is to avoid flaws so to help you with that we will spend quite a bit of time teaching you how to detect protect flaws how to avoid them and how to fix them because a flaw in a smart contract can mean potentially losing Millions you will be creating smart contracts in all kinds of areas you will create nft smart contract marketplaces auctions yield farming smart contracts you will learn to build oracles decentralized autonomous organizations or will play with Randomness through a lottery smart contract then you will work on decentralized finance contracts so will talk about how flash loans work how fungible tokens can be created and how to exchange currencies using liquidity pools and take advantage of Arbitrage opportunities Etc so this will give you a good idea of what real smart contracts look like and put you on a path to write your own there are very few prerequisites for this course and what you really need is some basic experience with programming we don't expect you to be a very good developer but you do need some programming experience to be able to follow this course what you don't need is specific knowledge about python it may be helpful if you already know python because smart py is based on python but you'll be okay if you're not familiar with python and you also don't need prior blockchain experience we'll teach you the basics that you will need for this course in this module will give an overview of tesos and its different components and get an idea of what a blockchain is tesos is a public opensource blockchain protocol this means anybody can read the code of all the elements of the blockchain and anybody can access the data of the blockchain and even join the blockchain by setting up their own node we also say that tesos is a smart contracts platform this means it's a kind of blockchain where you can deploy and execute smart contracts when one of the key aspects of tesos is that it relies on an energy efficient proof of stake consensus algorithm that makes it very environmentally friendly compared to some other blockchains tesos has a self amending governance that makes it easy for the protocol to evolve without the need for hard Forks Community itself decides through rules defined by the protocol on evolutions of the protocols that we call amendments tesos has been designed to facilate code safety through a number of design choices and application of formal verification to the protocol so let's talk quickly about the history of tizzel when creating tizzel the creators wanted to address the weakness of the first blockchains there was a weakness in the governance the way that blockchain could evolve and how the community to decide and how to evolve the protocol it appears that the first blockchains didn't evolve as much as they could because they liked a governance mechanism another weakness was the high energy consumption of blockchains due to the use of proof of work as a consensus algorithm finally there were a number of security issues with existing blockchains that the creators of tesos wanted to address the first step in the creation of tesos was the publication of a white paper in 2014 that described its principles from 2014 to 2017 a prototype of the tsos protocol was developed then in July 2017 232 million USD were raised in Bitcoins and E to help develop the ecosystem and the tesos main net was launched in July 2018 after it's launched between 2018 and so far 20123 the tesos protocol was upgraded 14 times through the on chain governance system so when we talk about tesos we're talking about the tesos blockchain or the tesos network if we talk about the underlying cryptocurrency we will talk about the tees and when you talk about mounts you talk about how many Tes you have or for example Alice transfers tentes to Bob the ticker used when you want to check the conversion rates between different cryptocurrencies on exchanges is xtz and T has a logo that you can see here now we will describe the different key elements of tesos we'll talk about accounts transactions smart contracts the blockchain itself and its blocks we'll also talk about wallets nodes and Bakers tesos is based on a system of accounts where every account has its own balance in t but there are two types of accounts on tesos implicit accounts are the accounts directly held by users they have addresses that start with TZ then a digit typically tz1 but also tz2 or tz3 are possible then we have originated accounts those are smart contracts that are a special kind of account that also holds data and code originated account addresses start with KT usually kt1 we'll talk a lot about transactions a transaction is a transfer of TZ from one account to another or it can be a call to a Smart contract and it can be both you can call a smart contract while transferring TZ to the account of that smart contract and transactions are digitally signed by the caller to authenticate that they are the ones really wanting to do that transaction but transactions are one of many types of operations that can be applied on the blockchain we can have other types of operations such as creating accounts deploying smart contracts voting for an amendment to the protocol Etc smart contracts are a special type of account that like every account has a balance of TZ and an address but it also has some data that we call the storage of this smart contract and it has some executable code so a piece of code in the melon language that is executed whenever someone calls the smart contract so when you call a smart contract you may send some test to the smart contract and pass parameters for the code and the code will be executed and it may change the data the storage of the smart contract or generate new transactions and new operations that will be executed after the end of the execution once you deploy a smart contract its code is immutable you cannot change it anymore so that people who call the smart contract can know for sure what code will be executed we can take a small example of a smart contract let's imagine that we have a contract that tracks the ownership of tickets for a conert each ticket will have an owner and the owner of a ticket can transfer it to someone else or change the ownership of a ticket so in the storage we will store all of the different tickets and for each ticket we could have a row a seat number and the address of the current owner and then in the code of the smart contract you could have a entry point a function that can update the owner of a given ticket so you indicate the row the seat and what new owner you want then we will fetch the corresponding data from the storage verify that the caller is actually the current owner of the ticket and then replace this owner with a new owner the tesos blockchain stores its data in a chain of blocks of data so that's why you call it a blockchain and the blockchain is is maintained by a decentralized network of nodes every 15 seconds at the moment at least a new block is added to the chain and each block will contain a sequence of operations and since we have a sequence of blocks the blockchain a blockchain is basically a very long sequence of operations split into blocks that are generated every 15 seconds and the state of the blockchain is the result of the execution of all the operations for example let's say that after the block number 1427 Bob's account has a balance of a th000 t if in Block 1428 Alice adds the transaction Alice transfers 100 T to Bob and this transaction is validated then in the state of the tizel blockchain after block 1428 Bob's balance will be 1100 T in the blog we have two parts we have the header that that contains the block number or the level basically how many blocks we have since the beginning of the blockchain then we have the hash of the previous block a timestamp and we also have the hash of all of the data in the block and the data consists in the list of all the operations of the Block in a certain order the fact that we store the hash of the previous block means that we are creating a chain of block each block references the previous Block in the chain that's why we call it the blockchain and you can check what a block looks like at this address that uses a block Explorer to analyze the block that has this number this level so here we can see this block we can even move to the next block or the previous block we can see the Tim stamp Etc and most of all we can see all the operations in that block so different transactions and in particular smart contract calls to interact with the blockchain we will use a wallet it's a piece of software or Hardware device that keeps your private Keys safe we saw earlier that transactions need to be signed so to sign your transaction you will need your private key that you will sign using your wallet so whenever you want to transfer some TZ or call a smart contract you will need to create a transaction and then sign it with your wallet the wallet doesn't store your TZ or any other asset it only stores the key keys to control these assets if you ever lose your private Keys you basically lose all access to your assets so make sure you keep your private Keys really safe as an example if we have this transaction transfer 100 test from Alice to Bob this transaction has to be signed by Alice using her wallet for it to be valid on tsos we have a number of wallets that you can use for example Temple kukai Umami and more under the hood the tesos network consists of hundreds of nodes run by the community each node is a computer that runs the tesos protocol and communicates with other nodes together these nodes form a peertopeer decentralized Network that we call the gossip Network these nodes share the responsibility of maintaining the blockchain and all the operations and blocks are propagated through this network of nodes and when your wallet interacts with a blockchain in practice is communicates with one of the nodes in this network all of the nodes execute every single transaction in every block and store the associated mate data update the state but only one entity can create the next block and decide which operations to include but as we want to keep tesos decentralized the responsibility of creating the next block has to be shared so the hard part of the design of a blockchain is to decide who gets to create this next block and do it in a fair way and then making sure that this block is valid and legitimate on tesos the entities that create new blocks are called Bakers anyone as long as they have at least 6,000 T at the moment can volunteer to be a baker and the baker for each block is randomly selected to make it fair the chance to be selected is proportional to the amount they staged that's what we call proof of stake and proof of stake is ecofriendly because we just need to pick randomly proportionally to some value this cost a lot less energy than proof of work where you need to do a lot of computations to determine who the next minor will be for example as it's done on Bitcoin in proof of work the chance of selection is actually proportional to how much energy and computational resources you waste when a new block is proposed by a baker it has to be validated so we have to check that it includes the correct hashes of the pre block and its own that all operations have a valid signature that the execution of transactions don't fail due to some limits or errors that the maximum size of a block is not exceeded Etc a block is officially added to the chain once it receives enough attestations from other Bakers the baker of a block is rewarded they receive 10 new T and and sometimes a bonus they also receive the fees of all the transactions in the block each transaction comes with some fees that the user can change a kind of a tip that is transferred to the Baker and to maximize their gains Bakers select among all of the transactions the most profitable ones so the ones that have the highest fees compared to their execution time if you're not a baker you can delegate your test to a baker and get a share of the rewards that the baker gets and there's also some test that I use as rewards for the bakers that attest the validity of the blocks if a baker propagates fake data in particular if a baker creates two blocks instead of one when it's their turn they lose some of their stake we say that their stake is slashed but if you delicated your test to a baker you have no risk of being slashed you cannot be punished so this was a key overview of the different elements of tzel we talked about accounts that can be either user accounts or smart contract accounts we described what transactions are our transfer of Tes or calls to Smart contracts we described what a smart contract is a special type of account with not only a balance but also storage and some code that can be executed we describe the blockchain as a sequence of operations grouped in into blocks we talked about interacting with the blockchain through a wallet that keeps your private Keys safe and is used to sign all the transactions you want to send to the blockchain we describe the blockchain itself as a peertopeer network of nodes that each execute the tesos protocol and execute every single transaction in the blocks they receive and finally we talked about bakers that share the responsibility of creating new blocks in this video you will learn how to set up your own Wallet create your private keys and then with that you will then be able to get some test create and sign transactions call Smart contracts Etc so using a wallet means creating an account and the first step to create an account is to generate a pair of keys most importantly you will generate your private key that is what you will use to digitally signed all of your transactions and prove your identity a private key has a corresponding public key that you make available to everyone so that they can verify your signatures and verify your identity so you sign your transactions with your private key and other people or software can verify that the transactions are signed by you by matching the signature with your public key so a wallet can generate a private key as a random sequence of bytes if it's extremely important that you never lose your private key but as a sequence of bites is hard to write down or remember the wallet will first generate a seed phrase It's a sequence of random English words that represent a random value but that are easy for you to write down and keep safely for example on a piece of paper then the wallet uses this sequence as a seed for the random generator to produce the private key it then stores this private key local encrypt it using a password of your choice and will'll then use it to sign your transactions on tles there are a number of different wallets available some of the main ones include Kai Umami temple in this presentation we'll be using the kai wallet it is available on kai. apppp but for our test we'll be using the ghostnet test Network so we will be using ghost net. kai. so the Tes will will manipulate with this wallet will be fake TZ in a sense not TZ from the main Network so if you go to ghost net. ci. apppp this is what you will see as the wallet will be directly in your browser you have two ways to create a wallet you can collect with one of several social networks for example Google Facebook Reddit Etc in which case it will use your o o cred credentials as a way to safeguard your keys that's the easiest way to do it if you simply connect for example click continue with Google your wallet will be instantly created and available we will use a way that is slightly longer you click on create new wallet here and then it will generate this seat phrase composed of a sequence of English word and the idea here is that you should write down these words on a piece of paper to keep them safe I avoid storing them in a file because this file could be accessed if anyone ever gets access to your computer so it's safer to Simply use a piece of paper and keep that piece of paper safe and make maybe copies of it that you keep safely because if you ever lose them then you're at risk of completely losing access to your private key therefore to your assets once you have written down these words you can click next and then it will check did you indeed save these words and it will tell you okay did you write down the second work the one that was between traffic and sustain and so on our piece of paper we see yes indeed we had the word Arrow then it asks what's the third word one that was between arrow and midnight and so that was sustain Etc then we have pause and we're done so it checked that we really did store or passphrase then it asks you to provide a password so that they can store an encrypted version of your key store file so that's a password that you remember so that your wallet can locally save your private key and public keyan Etc and then decrypt it anytime you provide your password so whenever you will need to sign a transaction it will use your password to decrypt the key and then sign the transaction with the key so you input a password confirm your password and then click next then your wallet is ready and you have here your public account address so that starts with tz1 and then something's based on the hash of your public key you can also download the encrypted key store file so that you can import it into this wallet or another wallet and it will be as safe as the password you pick to encrypt it so here you copy your public account address we download our file and then we can now open our wallet in the wallet we can see the balance of our account we can see our address here and of course we have no activity because we just created the account for real wallet on the main net you could get TZ using one of several providers and for example convert from dollars or euros and buy some Tes and then have them into your account through coinbase or other places for a test account on ghostnet there's an easier way to get some test you go to this website that we call a faucet and from this website you will be able to request some test so let's give it a try so this is a tesos costet foret that is a website that can give free fake Tes on a ghostnet account you can paste your address here and then select how many Tes you would like let's say A th000 tes and then you can request you need to wait a bit the more test you request the longer the competition will be because the challenge needs to be solved some proof of work and if you request a th000 t it can take a while so we'll maybe request a bit less let's say we only need 200 T and after a couple minutes all the proof of cor challenges are solved and then 200 T are transferred to our account another way would have been to connect our wallet to automatically obtain the tz1 address but that would be the same result then we can check on the Block explorer that indeed our tz1 address has 200 T we can also go back to our wallet and we can see here that the 200 Tes are there after reling the page and we can see that we received them from this address it may take a little bit of time before we see it because we need a couple blocks to be validated but eventually we see the 200 test there from this you can already sign some transactions for example if you want to try to send a few test back to the facet we can take this address that's the address that sent us some test and you can send some Tes let's say two Tes to the address which just copied then we can preview the transaction we can see that there's a fee of 369 micr Tes and we can use our password to decrit our private key and sign a transaction and send it to the blockchain so we confirm and we can now see this transaction has been confirmed and we now have almost 198 T again you can see the same thing in the block chain Explorer and we see this transaction where we send two Tes to this address and that's said your wallet is set up in this module I will give you an overview of the tesos layer one architecture and we will do that by following the path of a transaction from the moment it is created to the moment it is integrated forever in the tesos blockchain imagine you want to buy an nft a unique digital artwork on tesos The Cutting Edge blockchain platform you use adap a decentralized application that lets you browse and bid for nfts when you find the one you love you click on the buy button but what happens next how does your transaction get processed and recorded on the blockchain let's take a look behind the scenes tesos is powered by a network of nodes computers that run the tesos software and communicate with each other through a peertopeer Network these modes are operated by the tesos community a diverse and Global Group of enthusiasts developers and organizations your transaction will travel through this network undergo various checks and validations and eventually be included in a block by a baker a special node that creates new blocks once your block is added to the tsos blockchain your transaction is final and irreversible but how does this work exactly the T you use an nft Marketplace has a user interface a web page that you can access from your browser it lets you interact with the blockchain and the smart contract the programs that run on blockchain and Define the rules and logic of the nft marketplace when you click on the buy button the DB creates a transaction a message that tells the smart contract to transfer the nft to you and the TZ the native cryptocurrency of tezos to the seller the transaction is sent to your wallet a piece of software or a Hardware device that connects to your browser and the blockchain your wallet securely stores your private Keys the secret codes that prove your identity and ownership of your T and nfts your wallet is your gateway to the blockchain and the protector of your assets before asking you to confirm the transaction the wallet needs to test it check that it's valid and figure out how much it will cost you to do that it sends the transaction to one of the nodes of the network and asks this node to simulate what would happen if you sent it for real this node has a copy of the blockchain the history of all the transactions that have ever happened on tesos it also has the context the current state of the blockchain which includes the balance of every account and the code and data of every smart contract the node simulates your transaction by running the code of the corresponding smart contract it checks that the code doesn't cause errors for example that the nft you want to buy is indeed for sale at the price you indicate and that you have enough Tes on your account to pay for it it then computes the amount of resources running this code will consume on one side the amount of gas an estimation of how much Computing time your transaction requires on the other side the amount of storage how much extra data will need to be stored the node computes the cost for this gas and storage adds some fees then calculates how much you will need to spend to get a baker to add your transaction to a block all the this information like a quote for your order is sent back to the wallet the wallet then displays that information for you to check and lets you decide how much extra fee you want to add this extra fee is like a tip you pay to the baker to increase the chances that a baker will pick your transaction and add it to the blockchain once you check everything and agree to sign the transaction the wallet uses your secret private key to digitally sign your transaction using cryptography then sends it to a node from then on all you can do is wait and see if your transaction gets added to the chain the node sends a hash of the operation back to the wallet so that the wallet can keep track of it and ask for updates on its status before sharing your transaction with the whole network the node needs to check that it's legitimate to protect against attx that would saturate the network it checks that the signature is valid that the fees are not too low and that you have enough Tes on your account to pay for everything the node then stores your transaction in its M Pool a memory space that stores all the transactions that are waiting to get included in a block the mol also stores other types of operations that the nodes has received such as block attestations or votes for amendments to the protocol the Noe also sends your transaction to its neighbors which in turn check that your transaction is legitimate add it to their own M Pools and send it to their neighbors propagating it through the whole network every node needs to do these checks itself to make sure some bad nodes don't propagate malicious transactions while all this takes place one lucky Baker is getting ready to take charge of creating the next block it is lucky because it has randomly being assigned the first pot in the list of bakers that are responsible for making sure a block is created the next Baker in that list will wait a little longer ready to take over in case the first Baker doesn't do its job in time this time our first Baker is up and running and is ready to do its job and get rewarded for it it is carefully listening to all the transactions that arrive in the men poool of its node when it's time to create the block it sorts these transactions to decide which ones will end up in this block before it selects transactions it needs to pick the other types of operations such as attestations of the previous blocks or votes the baker is trying to make money by collecting all the fees so it selects transactions that have the highest fees compared to their cost in gas and storage but before adding them to the new block it does its own checks to make sure they are valid especially when they are executed in that specific order it adds the good ones to a new block until it's full or it runs out of transactions it wants to include it then executes all the transactions by applying them to the context produced by the produ block the storage of contracts and balances of accounts are updated in the context after each transaction as the validity of the next transactions depend on them once the block is full the baker comput is hash and sends the block with all its transactions to its node the node sends it to its neighbors and the block propagates through the network the node adds this block to the end of its copy of the blockchain in an unconfirmed state for now it also executes all the transactions and updates its own context other nodes do exactly the same as they receive the block a subset of the Bakers have been randomly selected to form a consensus committee for this block when the node that one of these Bakers is attached to receives the block this Baker starts checking all the operations it contains to make sure everything is valid if it's all good it creates a pre attestation message along with a hash of the block and sends it to the node other Bakers from the consensus committee do the same and create their own pre attestation these are propagated through the whole network the same Bakers then start receiving all these prorations check them and count them once enough are received a quorum is reached and the baker considers that this block is attested we creates an attestation message and send it to its node nodes propagate them and add them to their me pool as these attestations will be added to the next block while all this is happening your wallet is still checking with with its node what the status of your transaction is when the block that contains your transaction reaches this node the wallet will update the status of the transaction and show it to you when another block arrives and is added at the end of the chain after the block that contains your transaction this new block contains attestations for that previous one having another block added in front of it brings it closer to a final State once a second block arrives and is added to the chain then your block is definitely final you can now be 100% sure that your transaction is permanently part of the tizel blockchain the wallet shows that the transaction is final tells the DB about it and the DB confirms to you that you now own this amazing nft congratulations you have just experienced the power and beauty of tesos in this module we'll talk about some of the reasons why it's a good idea to develop your DS on tesos there are many benefits that come with developing on tesos one of the key benefits of tesos is the unchain automated governance anyone who holds 6,000 TZ or more can vote for protocol amendments proposal there's already been 14 successful upgrades of the protocol since the beginning of tesos this onchain government makes tesos very Innovative with frequent new capabilities that are added to the network and the system reduces the need for hard work there's always a single official branch of the network another benefit of tesos is that it's energy efficient thanks to its use of proof of stake it was one of the first blockchains that uses proof of stake as part of its consensus mechanism tesos is focused on scaling with a lot of work going on right now scaling with smart rollups data availability layer and more and that is done without compromising decentralization or security a lot of work has been done to make sure that the security of tesos is of top quality and the tesos ecosystem itself is very decentralized and benefits from a friendly and diverse community that focuses on longterm Innovation and it has a great ecosystem from blockchain Enthusiast artists but also multinational companies it also benefits from great tooling and funding opportunities to help developers build their projects in 2017 a large amount was raised to fund the development of the tesos Network and this amount is managed by the tesos foundation the mission of the tesos foundation is to grow the tesos ecosystem through a system of grants in areas such as developer experience Education and Training security and privacy and and re users application for more information about how to apply for Grants and what the foundation does visit tesos foundation in this module you will learn how to write your first smart contract on tesos using smart pie it will be a very basic smart contract but a useful one what is a smart contract it's a type of account that like any account on tesos has an address and has a balance in TZ but on top of that it will have some executable code the program of the smart contract that says what it can do and it will have its own storage some data that the smart contract can store to interact with the smart contract we will use used two new types of transactions the first one consists in deploying the smart contract it means putting it out on the blockchain once it deployed its code cannot be changed we say that it is immutable the second type of transaction is to call a smart contract you call it like a function with some parameters that you pass and you may send to the contract as you call it now let's look at our first smart contract this is the smallest useful smart contract we can think of all it does is to store value on the blockchain forever or at least as long as the blockchain exists so here we will store this value in the blockchain forever when we deploy the smart contract and that's all it does we can see that to create a smart contract we have to create a class we give it a name and we said that it inherits from sp. contract here SP stands for smart p and that's the name we gave to the smart by Library when we imported we need to create this class inside a module that we call Main like this and inside the class we create a Constructor that is named in it with two underscores before and after and within this Constructor we can initialize the storage with an attribute that we decide to call value and the attributes are stored in self. data Dot and the name of the attribute so here the contract doesn't execute anything on blockchain WE simply Define its initial value of the storage that will be stored forever once it's deployed it won't be doing anything else if we want to test the smart contract in the smart P IDE we will need to add tests and you always want to add test to any contract you write and in smart P you can add them in the same file as the contract itself here we create a test by adding this test function with the ad test decorator and within this test we create a scenario that basically will contain the sequence of tests calls to Smart contract Etc we give it a name by calling the function test scenario and we declare what module it uses so here it will be using the main module then we create an instance of our store value contract like this we store it in a variable and then we add it to the scenario when we run the test it will simulate deploying the smart contract and show us the output one thing you should keep in mind especially if you're not a python developer is that every time in your code that you create a block the content of this block should be indented compared to the parent so for example here we have a class and inside the class we create a block that's the content of the class all the content of this block should be indented here it's indented by four spaces it could be more it could be tabulations but it has to be the same number for the whole block and then here we can see that inside the Constructor we create another block with a content of the Constructor and again it is indented by four spaces as soon as we reduce the number of indentation so for example here when we have this decorator it indicates that we Clos the previous opened block so here we close this block we also close this one and close this one let's test our contract inside the smart P IDE in this online IDE you can write your contract and an editor and then on the side panel you will be able to test it and see the output so here I put our original smart contract we see that if I just run it nothing happens because I needed a test for anything to happen so I'll add our test now I can run it and I can see that on the side panel I have this origination that is simulated and I Can See For example the address of my contract and I can see the storage value so here we can see that originated a contract that has this value and will store it in the blockchain we can check a few things for example we can see what the code of the smart contract in melon looks like it doesn't really do anything we can also check the content of the storage or the size of the storage Etc we could even deploy the contract directly from the smart by ID now it's your turn write your first smart contract you can name it store value it should store the value 42 and of course you need to add a test scenario and run it to simulate the deployment of this contract once you're done validate it on open Tel let's pause the video and give it a try before we continue so far our smart contract wasn't really doing anything except storing a value if we want the smart contract to do something we need to add entry points they are like methods or functions that we can add to our smart contract when you call an entry point they cannot do much they can only read the parameters that you pass to the function the current value of the storage of the smart contract a few special values like the balance of the contract or the amount that the color sent to the contract or the address of that color and a few more it will also have access to a global table of constants that all smart contracts have access to it also cannot do much it can only have two effects the first one is to modify the content of its own storage and the second one is to generate new transactions such as transfer t or CS to other smart contracts that will be executed at the end of the execution of the entry point itself and that's it now let's see how we can add an entry point to a Smart contract so we here created a contract called flipcoin that will store the curent ins side of a coin and then we will have a flip entry point that can be used to switch this side from 0o to one and then from 1 to zero Etc we can see here how we created an enter point we created a function with a s sp. entry point decorator and then inside that function well we change the value of the side attribute of our storage to one minus this value so if you start with zero you get 1 0 equal 1 and then if you call it again it goes back to 1 1 = 0 Etc every time you call it it will flip the value of the coin to add test to our entry point we can simply add calls to this entry point in our test function so after we added the contract to the scenario we can call contract. Flip so that's the name of our Tre Point as many time as we like let's give it a try in the smartp IDE so here we have our contract and N test let's run it we can see again the origination with the initial value of side set to zero and then we have here our first call to our flip entry point and if we click on show details we can see that the new value of the storage is now one then we have the second call and here we can see that the value is zero and then one again Etc now the issue with this is that if we make a change to this contract we don't want to have to check again and click on show details Etc to see that all the value of the storage are still correct we would like to automate this and have Smart P tell us immediately if what we get is what we expected we can do that by automating those tests so to check the outcome automatically all we have to do is add this to our scenario after or before a call to an entry point scenario. verify and then some conditions so here for example we can check that the value of this field from the storage of our contract is equal to a specific value let's give it a try here after flip we can write scenario dot verify construct. data. side equals so after the first flip it should be equal to one then I can add it here should be equals to zero again and then to one again let's give it a try all good we get the same output if we had here written one then smart P would tell us hey this comparision is incorrect as an error so of course here that's just because the test is invalid but we put zero and then we run it and then we can make some changes and make sure that we never break this condition now it's your turn write your own smart contract call it count the calls and the goal of the smart contract is to count how many times we will call it so we will have a attribute NB calls in the storage that you initialize with zero and then every time we call the contract it should increment by one so to do so you will create an entry point make call and then increment by one the value of NB calls and then of course add a test scenario and run it let's give it a try and when you're done you can validate it on open tizel so please pause the video and give it a try let's take a look at the solution we created a class come the calls that inates from sp. contract we have a Constructor that initializes the value NB calls to zero then we create an entry point make call and every time we call it NB calls will be incremented by one you could also write NB call equals and equals + one but this is a shorthand operator that makes it easier to increment in our test we instant shed the cond the calls contract in the contract variable we can verify immediately that the value is zero we can use H2 to display a title that says what we're going to do next we call the entry point make call verify that the value is one then call it again verify that the value is two let's check if it works and it's all good we start with zero then we make the first call it's now one second call is not two everything is good and again I had change it to three it would let me know that this condition is invalid testing a smart contract is really important smart contracts manipulate tokens and other digital assets that can have very large economic values we can talk about millions of dollars in some cases or tens of millions of dollars in a single smart contract and the environment where you execute the code is what we call adversarial that means other people can attack it anyone in the world could look at your contract try to find a bug and if there's a bug someone will try to attack it and try to either steal some funds in it or make them stuck in the contract and people have very strong incentive to exploit bugs that you may leave in the contract and since once you deploy the contract it cannot be changed anymore it's immutable then bugs cannot be fixed as soon as you see them so that makes it even more dangerous there are unfortunately many examples of cases where people lost millions of dollars collectively as a consequence of small bugs in smart contract so it's very important when you write a smart contract to spend a lot of time testing it proofreading it Etc in general it's actually relatively simple to write a smart contract smart contracts are small projects compared to to other types of software projects but it's actually quite hard to make sure there are no bugs in those smart contracts so testing them and avoiding bugs is the hardest part in later modules we will study different flaws and best practice on how to avoid typical kinds of bugs in this module you will learn how to add entry points to your smart contracts so that you can create contracts that do something so far our smart contract wasn't really doing anything except storing a value if we want the smart contract to do something we need to add entry points they are like methods or functions that we can add to our smart contract when you call an entry point they cannot do much they can only read the parameters that you pass to the function the current value of the storage of the smart contract a few special values like the balance of the contract or the amount that the caller sent to the contract or the address of that color and a few more it will also have access to a global table of constants that all smart contracts have access to it also cannot do much it can only have two effects the first one is to modify the content of its own storage and the second one is to generate new transactions such as transfer t or calls to other smart contracts that will be executed at the end of the execution of the entry point itself and that's it now let's see how we can add an entry point to a Smart contract so we here created a contract called flipcoin that will store the current side of a coin and then we will have a flip entry point that can be used to switch this side from 0er to one and then from one to zero Etc we can see here how we created an entry point we created a function with a sp. entrypoint decorator and then inside that function well we change the value of the side attribute of our our storage to one minus this value so if you start with zero you get 1 0 = 1 and then if you call it again it goes back to 1 1al 0 Etc every time you call it it will flip the value of the coin to add test to our entry point we can simply add calls to this entry point in our test function so after we added the contract to the scenario we can call contract. Flip so that's the name of our Treo as many time as we like let's give it a try in the smart P IDE so here we have our contract and N test let's run it we can see again the origination with the initial value of side set to zero and then we have here our first call to our flip entry point and if we click on show details we can see that the new value of the storage is now one then we have the second call and here we can see that the value is zero and then one again Etc now the issue with this is that if we make a change to this contract we don't want to have to check again and click on show details Etc to see that all the value of the storage are still correct we would like to automate this and have Smart P tell us immediately if what we get is what we expected we can do that by automating those tests so to check the outcome automatically all we have to do is add this to our scenario after or before a call to an entry point scenario. verify and then some conditions so here for example we can check that the value of this field from the storage of our contract is equal to a specific value let's give it a try here after flip we can write scenario dot verify construct. dat. side equals so after the first flip it should be equal to one then I can add it here it should be equals to zero again and then to one again let's give it a try all good we get the same output if we had here written one then smart P would tell us hey this uh comparison is incorrect as an error so of course here that's just because the test is invalid but we put zero and then we run it and then we can make some changes and make sure that we never break these conditions now it's your turn write your own smart contract call it count the calls and the goal of the smart contract is to count how many times we will call it so we will have a attribute NB calls in the storage that you initialize with zero and then every time we call the contract it should increment by one so to do so you will create an entry point make call and then increment by one the value of n calls and then of course add a test scenario and run it let's give it a try and when you're done you can validate it on open tsos so please pause the video and give it a try let's take a look at the solution we created a class come the calls and inates from sp. contract we have a Constructor that initializes the value NB calls to zero then we create an entry point make call and every time we call it and me call call will be incremented by one you could also write NB call equals n + one but this is a shorthand operator that makes it easier to increment in our test we instantiate the cond the Call's contract in the contract variable we can verify immediately that the value is zero we can use H2 to display a title that says what we're going to do next we call the entry point make call verify that the value is one then call it again verify that the value is two let's check if it works and it's all good we start with zero then we make the first call is now one second call is now two everything is good and again I had change it to three it would let me know that this condition is invalid testing a smart contract is really important smart contracts manipulate tokens and other digital assets that can have very large economic values we can talk about millions of dollars in some cases but tens of millions of dollars in a single smart contract and the environment where you execute the code is what we call adversarial that means other people can attack it anyone in the world could look at your contract try to find a bug and if there's a bug someone will try to attack it and try to either steal some funds in it or make them stuck in the contract and people have very strong incentive to exploit bugs that you may leave in the contract and since once you deploy the contract it cannot be changed anymore it's immutable then bugs cannot be fixed as soon as you see them so that makes it even more dangerous there are unfortunately many examples of cases where people lost millions of dollars collectively as a consequence of small bugs in smart contracts so it's very important when you write a smart contract to spend a lot of time testing it proof reading it Etc in general it's actually relatively simple to write a smart contract smart contracts are small projects compared to other types of software projects but it's actually quite hard to make sure there are no bugs in those smart contracts so testing them and avoiding bugs is the hardest part in later modules we will study different flaws and best practice on how to avoid typical kinds of bugs in this module you will learn how to deploy your contracts so that they are available on the chain for everyone to use well will deploy our contracts on a test Network so that you don't need to spend any test to do the deployment but the same approach will work on the main Network so the test network is called ghost net and it is very similar to the main Network so to originate or we can say deploy your contract you need to do two steps the first step is to produce the makerson contract so compile your smart pie contract into melon melson is the lowlevel language of every tesos smart contract and smart py is a highlevel language that makes contract easier to write but when you run smart py you compile the smart P code into mikelson so you generate the mikelson contract so that's the first step before you can deploy your contract and the Second Step will be to create and sign a transaction to deploy that contract the smart py IDE will help you prepare the transaction and we will be able to use our wallet to sign this transaction and then we'll send to ghost net this operation is what we call the origination of the contract so we start from the IDE with our contract and to deploy it we first need to run the code and on the right side in the top part we have the origination and here we can view the mikon version of the contract and then you can see at the bottom right deploy contract button so let's click on that and here it will prepare everything everything you need to originate your contract so here we'll select what network we use we can use ghost net or main net here you can provide the address of the node that you will be using to deploy the contract so for example by default it's the smartp node but I could use a node from another infrastructure then I can select my account and here I have a choice of a number of wallets if I wanted to use my Kai wallet I could select Bon and then Kai but smartp also offers its own system to manage accounts so here you can create accounts and here have created a couple so let's just use this one so we can see that this account has almost 100 t in it and it's revealed already on ghost net so I simply validate that account here I can provide any origination parameters I can say how many Tes I put in the contract as I deploy it and I can also set a delegate to indicate if I have test in the contract which Baker should I be delegated to then I have the estimates of the deployment cost that I obtain from RPC so that's contacting the node doing our RPC remote procedure call to the node I can check and it tells me okay this is how much the node expects that it will cost to deploy it so it's very cheap to deploy this tiny contract this is how much gas I will spend how much storage I will spend Etc and then I can simply click deploy contract it shows me all the information about the contract I'm going to deploy so it shows me the hash of the transaction the parameter so what account I use to originate it what's the counter what's the fee I'm going to be paying the gas limit the storage limit Etc and the balance initial balance for my contract in the full version I also have the full code of the contract in meason plus the initial value of the storage and then I can see the by encoded version of that so once I'm sure that this is the transaction I want to run I can accept it and then it contacts node originates the account and I have the address here if I copy this address and go to for example better call Dev I can search that contract and I can see here that better called Dev sees my contract on ghostnet and we can see that the operation was done just now here it says a few seconds ago so my contract is deployed I can check the contract on ghost net see the current value of the storage see the melson code and I can even interact with it directly from ghostnet so now that we have deployed it our contract and the associated data are now public so as we could see through better called Dev anyone can read the code and the storage without asking for permission the contract is immutable it can never be changed and it's Eternal so as long as a few nodes are running the tesos blockchain my contract will be available for anyone to use this is because tesos is run by hundreds of independent nodes that each maintain a copy of my contract and its data and changes to the contract may only be made if a super majority of participants with agreed to make changes which is something that doesn't actually happen people don't really change contracts when they have been deployed we will see later that we can integrate features in a contract to enable upgradability features of our contract and so due to this decentralized structure of the blockchain no single entity can cause my contract to fail and the network as a whole to fail so my contract is pretty much available for anyone to use forever and we'll keep counting how many times people call it I could try directly from baral Dev execute and directly using my wallet here it's sending to my Kai wallet so here it says I'm waiting for confirmation my Kai wallet is here so I just need to accept the transaction and I go back CA successfully submitted the operation transaction has been successful and now I if I see the storage I can see well this contract has been called once I can try it again execute confirm successfully executed I see this storage not updated yet and that's it now it's two so my contract is available forever and you could call it to using this address in this module you will learn that every value variable or parent parameter in smart Pi has a type but most of the time you won't need to tell smart Pi what the type of your variables are thanks to a very powerful tool called type inference but first let's talk about parameters we have already presented entry points since an entry point is a kind of method of your smart contract they can take parameters if you want to write an entry point with one parameter here is how you do it so when you define your entry point next to self you add a comma and the name of your parameter and then within the code of your entry point you can simply use the name of your parameter wherever you want to use this value in your test when you want to call an entry point with a parameter if it's a single parameter all you have to do is put the value of this parameter between the parenthesis when you call the entry point of your contract let's take a look at an example here we modified our store value contract by adding two entry points one entry point with a parameter called added value that we can call to add this value pass as a parameter to the stored value and then we can compare it to another entry point that doesn't have any parameter reset that simply resets the value to zero and then in our test scenario here here we call contract. add with a parameter five saying that we want to add five to the initial value 42 and then after the call we can verify that the new value of stored value is 47 and then to really make sure that the entry point works well if we call it several times we have a second test where we this time add two and then we verify that the result is 49 let's give it a try so we can see that it was successful we start with the origination with the value 42 then we call our entry point we see that the argument so the value passed for the parameter added value was five and then if you look at the detail we can see that the new stored value is changed to 47 and then we have another call with the argument two and the new stored value is 49 in smart Pi everything has a type whether it's a value or for a variable that always has the same type and can only contain values of the same type and the same with the parameter all of them have to have a type so far we have manipulated whole numbers but just for whole numbers we actually have two different types available the first one is int for integer and a value of type hint can hold a whole number that can be either positive or negative but there is a second type for whole number called nut for natural natural numbers that can also hold a whole number but this time only non negative values so values starting at 0 1 2 3 Etc but not negative values when we want to use the whole numbers if we want to specify which one of those two we want we can either write sp. in of five for the integer five or sp. not of five for the natural five so those are two values of different types whenever we want to express the type itself in smart pile we will simply use sp. in and sp. notot in short when I talk about it I will just say int and net in smart Pi you cannot directly combine nut and int so for example if you have a variable of type int you can add assign a nut to it and vice versa so if we take this example of a contract that has a value where we assign a type int and then has an increment variable to which we assigned three then we cannot have an entry point that adds those two together because they are of different types but we can convert a nut into an INT for example using sp. 2 in of the value so if this value is an N we can con convert it to an integer with this function most of the time if you feel like you need to convert a value from one type to another it may be because you chose the wrong type to begin with so most of the time if you feel the need to convert try to think first if there's a way you can change the initial type of the variable rather than converting it to another type if every variable has a type you may wonder why we never had to to provide the type so far and the idea is that smartp uses a very powerful tool called type inference to automatically determine the types of many variables and parameters if you don't specify it it can deduce it from other Clues and there's a number of information that you can use for that the main one is the initial value you assign to the storage so for example if you have a variable in your storage and you say I sign it to sp. int of five then smart P can deduce that the variable is of type int if you combine operation in an operation for example if you add two values and one of them is of type nut then that means the other one and the results both have to be of type net and sometimes you can provide explicit information about the type of a value so for example if we have a parameter factor and we want to say we know and we want this parameter to be up type int then we can use sp. cast of factor and the type that we want to assign to this parameter not that this is not converting the type of this variable whatever value it contains to an NT it is simply saying that the type of this parameter or variable is an INT and should always be an INT it uses those information that it finds here and there in your contract and it propagates it to the rest of the contract whenever it can one thing that you should know is that sometimes smart P cannot determine if a value is of type int or of type not so it temporarily propagates a value that has an intermediate type int or not and then only at the end it will determine which one of the two it is and sometimes you may see error messages that tell you that it's expecting into not it's because so far it doesn't know yet if a variable containing a number will be of type int or of Type n so it is propagating this intermediate type but eventually it will have to pick between it and N if we look at our smart contract as an example here we saw that we didn't provide any type information and that means when I look at the type of the storage here we can see that the stored value is of type int or not because it doesn't know if this 42 is an INT or or not same thing with this parameter or this value it could be both but eventually since it has to pick when we look at the melson code we see that it picked an INT so if there's choice between in and nut at the end it will pick an INT but we could force it to be a nut by here initializing the value with sp. nut of 42 so type inference will be used to deduce that the type of this variable is net here since we add the value of this parameter to the stored value this means this parameter is also an out and here since we assign another value to store value then it knows that zero should be actually sp. nut of zero so here if we run it we can see that store value is now S as a n and then melon contract we see that we have nut everywhere as well the type inference could be used starting from any point so for example could use the reset entry point to say hey this zero is a nut and the result would be the same because it will deduce from this that stored value is a nut therefore 42 is a nut therefore the parameter added value is a nut so from this single information that this value is a nut it will propagate it to stored value then to added value then to other places like for example the value 42 it knows that it is n this is what we call type inference using a set of Clues to determine for sure what the type of each value is let's look at a different version of this contract that I prepared for an exercise here we have this add entry point and we say that we don't want to allow negative numbers to be added to the value and the reason is that we also have a sub entry point that substract a given value from the stored value and so since we have this entry point let's say we don't want add to be able to be used to add negative value which would be the same as subtracting so it's just a rule that we set for the purpose of this exercise so for this reason as a way to say I don't want negative value I say that this parameter should be of type net so I use sp. cast to say added value is of type net let's see what happens when I run so here we have a type issue on line 18 it's telling us that it's trying to combine an INT and a nut and as we said we cannot combine those two types in the same operation for most operations so here we have an issue because it deduced that stored value is a n from adding an N to it here but it also deduces that stored value is an integer because well we subtracted a value to it therefore it could become negative therefore it can hold negative values and should be of type int so your goal for this exercise is to try to find a way to fix this mod contract and make it compile while keeping this constraint of having added value B of Type n you will find the content of this smart contract either in the git Repository associated with this course or in the type inference section on open tzel please pause the video and give it a try Okay so let's see how we can fix this here the issue is that when we add a nut to this value it will deduce that this value should be a nut but we want this value to be an INT because we want to be able to subtract values to it and we want it to be potentially negative so this has to be an INT but this has to be a nut but we cannot combine the two together so what we do is we convert this value to an INT by writing SP do 2 int of this value let's give it a try so I still have an error but a different one line 30 and again it says entry point expect parameter of type SP sp. unknown but it got int and it tells us that there is an int sln mismatch so the error message is not very clear on where the problem is but let's look at what we have on line 30 and we can see the content of this line here here we see that inest we called add but we passed an INT as a parameter so of course if we pass an INT as a parameter and then it tells us no this parameter should be of type nut then there's the discrepancy we cannot pass an in when it expects a n so all we have to do here is change this to nut let's give it a try and it works so now the type inference doesn't have any conflict it doesn't end up with a place where from one set of deductions it deduces that a value should be of a type in and then from another set of deductions it deduces that it should be a nut everything is coherent so it all works when particularity of tesos is that it cannot have bugs related to overflows so if you not familiar with overflows the idea is that in most languages values of different types have a minimum and a maximum value they can hold so for example in C++ if you use the type short you can only store values between those two numbers included if you use an operation that adds one for example to the maximum value that it can have it will loop back to the minimum negative value that you can have so from this number if you add one you go all the way back to the negative value 32,768 and this can cause very dangerous bugs right if you add a number to a value you expect it to increase you don't expect it to become a very negative value on tesos we cannot have this kind of bugs contrary to many blockchains and the reason is that on tesos most types don't have any limit there is no upper limit to the value that an in can hold hold and there is no negative limit to the value that an in can hold basically that means the value of an INT can be between minus infinity and plus infinity there's only one type the TZ that has a limit but in this case if there's an overflow if you try to add one to the maximum value for the type Tes you will trigger an error instead of getting an invalid result so you avoid very dangerous situations so you may wonder is there really no limit to values does it make any sense to talk about in being able to hold infinite values well of course not in practice the types of value you can hold in an INT are limited by the storage needed to hold these values so you may wonder how much storage is used by a value and we can say that it's roughly proportional to the number of digits so if you have a number with 100 digits it will use about 50 bytes of memory so it's about one bite for every two digits approximately so the next question will be to wonder if uh the limit is the amount of storage and there's no limit to how much you can put in a value how do we prevent abuse how do we prevent people from storing numbers with billions of digits for example and the idea is that users have to pay whenever they increase the size of the storage of a smart contract so when you uh deploy a smart contract or when you call a smart contract in some cases the result of that is that you will change the value in the storage of the contract and therefore you may increase the amount of storage needed to store these values so whenever that happens you have to pay for that storage so now we may wonder who gets paid if we pay who do we pay to and the answer is no one we actually burn those tests and that's because there's really no easy way to determine who should deserve that amount and in a way by burning the test we pay everyone in the community because if you burn test you destroy them you make them unavailable you reduce the total amount of test available for everyone so by doing that indirectly you increase the value of the Tes so it's basically value that is shared with a community when do you pay well when you call a smart contract you're doing through a transaction that you will need to sign with your wallet and your wallet will simulate the transaction compute how much extra storage will be needed due to your transaction calling smart contracts and increasing their storage and so compute how many bytes you may increase the storage and then uh lets you know basically how by how much how many Tes you may burn and you can specify the maximum amount of Tes that you are willing to burn for this transaction to happen and when the transaction happen the exact amount will be burned okay now let's work on an exercise so you will take the smart contract store value that we have used so far and add a multiply entry point to the contract this multiply entry point should take a parameter called factor that should have type int and the multiply entry point should multiply the value of the storage by this parameter and of course we ask for you to add the Cor corresonding test to your scenario so please pause the video and give it a try and you can validate your Solution on open Tel let's take a look at the solution here we added this entry point multiply that takes a factor parameter and we multiply stored value by this factor and then of course we call it in our scenario to verify let's give it a try and we can see see here that when we call multiply by 10 we started with the storage that was five multiply by 10 and we can see the result is indeed 50 in this module you will learn to manipulate text on tesos using the type string tesos supports a string type that you can use to manipulate text but it is limited to non accented characters so what you can use is the set of characters from the nonextended S key standard composed of 128 different possible characters when you want to express a string literal you write it between double quotes like this example so double quote your text and then double quote again and just like for INT and nut there is no limit to how long this text can be you can write a string as long as you like the only limitation is the storage and how much it costs to store this string on the blockchain the most common operation we can do on strings is to concate Different Strings so you can concate different elements like this using the plus operator so here we Show an example where we create a URL by conting this bit with this parameter with this text with this parameter let's directly try it on an exercise so you will create a contract that will illustrate the concept of Eternity and immutability of the blockchain so for that you create a smart contract called edness wall and the idea is that it will store a string that we will call Wall text and anyone will be able to call an entry point called write message that will take a message as a parameter and will add it to this text basically it's a very long string of text that anyone will be able to add to so people like to leave their name U maybe carve their name on a rock for tunity or on a tree for a long time Etc there often a need for people to leave a trace so this is a contract that will let people leave a trace forever without destroying the environment in any way so the right message entry point should add a comma to the text to worldex then a space and a message then the string forever so for example if you call write message of tesos it will add a comma space and then tesos forever to wall texts and so if we start with hello and then we call WR message then we end up with hello tesos forever and of course once you're done writing the contract you should create the corresponding test scenario and you can validate your contract on open tizel let's pause the video and give it a try okay let's look at this solution so we created this endless wall contract we initialize the storage with a wall text variable that takes the parameter initial text that sets the initial value we will initialize this value with hello in our test then we have this entry point write message it takes the message as a parameter and it adds to World text a comma and the space then the message then forever and we use the plus operator to concatenate them and then plus equal to add them to W text in our test again we initialize the contract with the initial text hello then we create our scenario we add the contract to the scenario we call write message a first time with Anna and Jack we then verify that everything went well and W text contains hello comma and I inject forever then we call it again with tesos as the message and we verify that what text contains hello and inject forever then Tes us forever let's give it a try so it works we see that at the origination the content is hello then after the first call with the argument and un Jack and the result is hello and unj forever and then with another call with the argument tsos the new storage is hello un inject forever comma tsos forever all good in this very short module we will talk a little bit about the history of smart contracts the concept itself of smart contract was first proposed in 1996 by Nick Zabo in the first blockchains you only have a few types of transactions but some of them could run very basic scripts but those scripts are very limited on purpose you couldn't do any Loops for example for security reasons ethereum was the first blockchain with support for smart contracts and it was launched in 2015 tesos was launched in 200 18 as a new smart contract blockchain that was built from scratch it focuses on the security of smart contracts along with unchain governance in a way the whole point of a smart contract is to say if you do that this will happen no matter what no one can stop it in this module you will learn how to write smart contract that do that through performing verifications the code of an entry point of have the same structure and should have the same structure first it checks that the call is allowed that you should be able to call at this time with this address with these parameters Etc then after checking that everything is good do stuff computations changing the content of the storage sending tests to people do all kinds of transactions and maybe check all the things to do the first part checking that things should be allowed we use the assert command and we give it the condition that should be checked so basically write assert then the condition so for example we could write assert this parameter should be lower than some Maximum value we can also provide an error message so that when the contract fails we know why it failed so we just write assert the condition comma and the string containing the error message if the assert fail so if the condition is not met everything that was done since the beginning of the transaction is cancelled it's just as if nothing had happened so if we take this example we assign the value for it to to some attribute of the storage and then we check assert that this value is lower than 10 so of course this assert will fail so that means if you put this in a smart contract the whole smart contract will fail and the value will never be set to 42 and this is no matter what the cause of the failure is so if you cause a failure of the contract because of a false condition of an asset or if you for example try to send more test from the contract then the contract has in its balance or if you call another contract and this other contract ends up failing for similar reasons whatever the reason why the contract fails or one of the transactions it's try to do fails then everything this contract was doing is cancelled and it's as if nothing at all had happened so basically it's all or nothing either everything works or nothing happens when you do verifications you can use the regular python comparison operators so for example if we have a variable C that contains an integer four we can check if it's greater than three lower than three greater or equal than four equal to four are different from five let's look at this example where we take our store value contract and we have simply an add entry point that takes a parameter and adds it to the store value we don't specify any constraint it could be a positive negative value anything you like we can try it and we see that we start with zero if we add one we end up with one and then at nine we end up with 10 as we verify here now let's say we want to make sure whoever it calls it doesn't add more than 10 for example so we could have an assertion assert added value is lower than 10 say and otherwise we display message too much okay now if we run it again it just works because we only try to add one nine but now let's try to add 10 here we see that it fails and it displays the unexpected error too much we could also add an aerion that is a positive for example and again we can add minus 5 and then check and we will have the error needs to be positive we can also use Smart Pi's Boolean conditions so we introduce a type boan where value can be true or false and then we can create an Expression A and B that is true if and only if both A and B are true and then we can have the or operator that is true if either a or b or both are true and we can even use the exclusive or using the binary python operator um this side that means exclusive or that will be true if a is true or B is true but not both so exactly one of them has to be true for the whole expression to be true otherwise it's false and of course we have the not operator that text the opposite of the value of a so in our example instead of having two values we could just write here let's put this here the value is greater than zero and added value below 10 and let's say uh had a message not between Zer and let's say nine included so now if we write it we still have the error with the value minus 5 that is not between 0 and 9 and if we come in this ver this line and try with 10 then we have the same value for OD 10 then this message appears so the issue here is that we do want to check that this fails when we add 10 but if we do that then it just stops our test right if I want to check that both Min 5 and 10 return an error well when I run it it stops at minus5 so I don't know for sure that um adding 10 also causes an error so to help with that we can add code in the scenario that will check when something should be failed so we actually test that the failures work so basically when we test a smart contract we need to both check that the contract doesn't fail when it should succeed so by testing with valid parameters making sure that it works but we should also check that if we pass the wrong parameters or call it the wrong time Etc the smart contract actually fails it's very important to test it so to test that without having the whole scenario completely stop we can make a call to a Smart contract entry point by passing invalid parameters but then we say we know that this is invalid and that's what we want to check so to do that you add an extra parameter with underscore valid equals false to say I know that this is false and this should fail and I expect it to fail so when you run it if it actually succeeds you will get an error message if it fails then all good it's going to continue to the rest of your scenario and of course if you put true here it will be the other way around true will means I expect this to be valid so it should work but true it's a default value so you don't need to put it when you expect it to work and you can also check what message is output by the error so you can add underscore exception equals and then the exact string that should be produced when this entry point fails with this parameters so let's give it a try here my fire should fail so we can write valid equals false so now it will run minus F will work and we only have the add 10 that doesn't do what is expected so we change the expectation by adding valid equals false then everything works so now you can see here this transfer failed but this is expected so it doesn't cause an error so it's displayed in the output of smart Pi you even have the value of the expression here not between zero and five so you can still check everything but it is tested automatically in your scenario if we want to check the error message we can add exception equals not between 0 and 9 so let's say I do the wrong exception and it's going to tell me no that's not the exception I expected I expect 09 and you sent 08 and of course I can put the same right here for this call and everything works I don't have to use strings when I generate exceptions exceptions can actually be of any type so for example if I want to send two values I cannot easily build a string using Python's F strings F strings if you no pythons are not supported so I cannot concatenate a piece of string with a number that was a smart contract there's no easy way to convert a number into a strings for example so you can create a mixed message that has text and numbers but what you can do is generate an error that is not a string but for example that is a pair I can use this syntax I put two values between parentheses and with a comma between them that is a pair we'll talk about it later and so instead of returning just this string I return a pair that contains this string and then this value let's give it a try so here instead of putting not between zero and five I can create a pair and add added value comma not between Z and nine and then here if I run it of course it will tell me I was expecting the string but I got a pair conents minus 5 and not between 0 and 9 so here I just change it to 5 and then same here 10 okay so I can check here what the exact error was and including a value not it's your turn to give it a try I'm asking you to change the endless to contract to add verifications to it so the idea is to add verification so that people only add strings that have a length between three and three characters included this seems like a reasonable size for a message that will stay on the Chain forever and once you do that in your scenario please add test that make sure your contract does this very well you will need to get the length of a string so for that you can use this syntax sp. Len and then your string between parentheses and then you can validate the whole thing on open tiesos please pause the video and give it a try let's look at the solution so we still have our endless wall contract with the wall text that we initialize to this parameter and then in the right message entry point we add this line where we assert that the length of the message is lower or equal to 30 and the length of the message is greater or equal to three if not we simply produce the error in valid length if everything is good then we add the message and forever to the text in or test here we have to test both sides of each limit so here we have it limited 30 so 30 should be allowed but 31 should be rejected same here three should be allowed but two should be rejected so we test here with a message that contains 31 letters and we make sure it is failing then we test with two characters and we test that it is failing then we check that when the message is right above the limit so three characters should be the smallest text that works so we check that it works and same thing with this 30 character text we check that it works as well here would be good to check that the message is invalid length so let's add this exception equals invalid length and same here let's give it a try all good you can see here those two errors but it's just as expected Lo explorers like Bal Dev provide a user interface to explore contracts and accounts so we can find data about accounts their balance Etc find information about contracts what operations there have been on this contract was the current storage and you can even interact with the contract there's other kinds of explorers like TZ KT and TZ stats that have different types of features the contract that we just saw has already been deployed on ghostnet with this address so we can paste this address here and we will find this contract and we can explore so we can see that has been originated a long time ago and it's been used just a few times to call the right message entry point we can see the melon code we can see the current value of the storage so we can see a few messages and we can even interact with it so here I can interact with the default entry point so there's only one entry point called write message in this contract so the name is not kept it's just the default the only entry point and here I can put the value let's say smart pi and then I don't need any options I can simply execute it and I can use my wallet on ghostnet let's take Kai so it's asking me to confirm the transaction where I send zero TZ to this contract to call the default entry point so I confirm so the call was made it's confirmed I can go back to Bar Dev and I can check that a few seconds ago this right message was called I can check to see the details I can view the raw message you can see that the value of the parameter was smart pi and and I can see that it changes in added smart pie forever if I go back here and go to storage I can see smart P forever can see that each oper operation has a hash that I can use if I want to track this operation check that it's been added to the block and check that it's final before I do anything else so you can play around with baral Dev call this contract and see what happens now let's say we try to call it with an invalid value for example two characters let's give it a try I'll use my wallet then we can see here parameters invalid some of the parameters you provided are invalid and the request could not be completed please check your inputs and try again so we can see that I cannot call it with go and the same thing if I try to put let's say 31 characters can do it like that 10 20 31 execute using my wallet again it tells me parameters are invalid so if I go back to the operation I can see that this operation has never been run I don't have this new operation the last two that failed are not appearing I didn't pay for them the wallet just didn't let me run it because it simulated it realized this is not going to work don't even try don't even send it to the blockchain and so it was stopped before it was propagated and added to a block so to recap so far we have learned how to create our first smart contract we have learned how to create and deploy a smart contract to store a value in the contract using the types net int and string and we have learned to create one or more entry points each with a single parameter that checked the value of the parameter and then changed the value of the storage of the smart contract and finally we have learned to do test scenario that could check that everything was as EXP expected so far our smart contracts only stored one value and we only had entry points with one parameter it's pretty straightforward to add multiple parameters but there's a few important things to pay attention to if we want to put multiple values in the storage it's pretty basic we just need to have one line to assign a value to each value in the storage and we give them different names and we just have multiple parameters to the constructure so Min value will be stored in the minan value variable the storage and same thing with max value if we want to have multiple parameters for an entry point it's the same we just add another parameter with a comma behind the first parameter and we just give it another name and then we can use them for example to replace the values in the storage the part where you should be really careful is that when you call a smart contract entry point from your test scenario if the entry point has multiple parameters you need to name them so instead of just putting the two values separated by a comma I give the name of the first value equals the value I want to pass comma the name of the second parameter equals the value I want to the syntax doesn't work if I only have one parameter so if I only have one parameter I simply put the value if I add the name it it will not work the reason is that entry points actually only have one one parameter behind the scenes in the melon language so when we do this what we send is a single parameter in the form of a record so we create a record that contains those two values those two attributes and we send that record as the single parameter of the smart contract but we have a simplified syntax when we declare the entry point instead of saying we use a record that has multiple values Etc we just simply give the list of the attributes of the record and we will talk later about exactly how we use record but here records are used implicitly anyway all you have to remember is that when you call an entry point from a test scenario use the names if there's more than one parameter and don't put the name if there's only one parameter we can use an example we will change our store value contract to store a range of value with two numbers minan value and max value then we will have an true Point set that will change these values and we will also have an entry point add number that would add the same value to both the num minm and the maximum value of our wrench and of course we'll create a test scenario to check everything and again remember in a test scenario when we pass multiple parameters we have to name them let's look at our example so here we have our constructure and as parameters we have the two initial values that we want to set in the storage Min value and max value we want to set that those are integers using sp. cast of minan value s sp. in then we just assign them to the storage then we have an entry point set that takes again two parameters actually it's just one in the form of a record but we see them as two parameters new Min value and new max value we assign them to the two variables in the storage then we have ADD number where we have one value that we will add to both minan value and max value and we have a test where we create an instance with minan value equals zero max value equal to five then we call set again naming the parameters new minan value and new max value we verify that they have been set and here I can show that if instead of calling this I simply call this directly with the value then I get an error because it says entry point expects paramet of type of Nots but it got in or not and it says expected a record with two attributes new max value and new my value Etc but instead we got one number so that's because it's just checking the first parameter it sees that it's not a record it's just a number and it's checking that against the rec cord that contains both parameters and it doesn't like it because it doesn't look the same so if you see this kind of error message that talks about records then remember that it may be because you forgot to give names to your parameters in your scenario okay so then we add a number check the result add a number again everything so here you may wonder why uh explicitly said that Min value was an integer and the reason is that if I don't do that smart P tells me that there is an unresolved constraint so basically it says here those cannot be added and basically that's because it doesn't really know the type of minan value so when I add something to minan Value it doesn't really know what to type we had no hint other than this to tell us if Min value is a nut an INT a string or something else so we have to give some information about what type it is but if we only give the type of Min value the type inference system can infer that since Min value is of type int the parameter Min value is of type in therefore the storage is of type int therefore a has to be of type int therefore max value also has to be of type int therefore this max value has to be of type int this one has to be of type int this one has to be of type int so just by adding this single information that says Min values and int everything else can be determined by the type inference so we're starting to write contracts are a little bit more complex and that means sooner or later we will have bugs so it's important to learn how you can debug smart contracts one way to debug smart contracts is to cut them into pieces for example if I have an error that I don't understand I could try to see well let's see in which entry point causes the error so I could easily delete this entry point delete the calls to this entry point and check do I still have my error if I'm completely lost I can just use binary search basically by deleting half of the contract to see if that helps but another tool to help me debug is to get some information about what's going on inside of an entry point and for that I can use the trace function to print any value that I use in my entry point if I'm using the smart Pi IDE the output will be in the browser console and if I run it on the common line it will be simply sent to the uh standard output so for example I have this entry point make call after I increment and because Trace so output on the console or on the stand output the value that number call has now let's give it a try here if right after and because plus equals one I use Trace to put a string and then Trace to Output this value I run it I don't see anything special here but if I open the browser console so on Google Chrome it's control shift J I can see here the output and we call 1 and equals 2 so I can clear it with contrl L to make sure I only see what's the output of the execution I run it I see okay n equals one n equals 2 I could also use pairs so for example I put parenthesis here comma here I'll do contrl L and if I run it I can see n equals 1 n equals 2 it's a bit easier to read that can help me understand what's going on in my contract and fix bugs let's practice on an exercise I will ask you to modify the endless wall contract so that it now counts the number of times it's been called so the number of times that messages have been added to the text in a new variable in the storage and then please change the right message entry point so that it takes two parameters both a name and a message it should check that the length of the name is between three and 10 letters you should still check the length of the message itself is between three and 30 letters but you just add this new check on the name and then with these parameters it will add a comma then the name a column a space then the message and finally forever to the text so we'll have the name and then the message and then forever and of course please check everything in your test scenario and use this as an opportunity to practice using trays and print internal values and see how it works so please pause the video and give it a try let's take a look at a solution so in the storage we added this variable NB calls that we initialize at zero then we modified the right message entry point to add a name parameter we still have our assertions on the length of the message we change the error message to clarify that it's an invalid message length then we added a second assertion this time on the length of the name with a message that says invalid name length and then we change W text to add comma the name column message and forever then finally we increment the value of NB calls at every call in our test scenario whenever we call write message we need to give the name of the first parameter message equals the value we want to send and same thing with the second parameter the name equals and the value we want to send so we make a couple calls that are valid we verify that the output is what we expect we verify that the number of calls is what we expect and finally we try a few calls that would fail we try to send message that is 31 letters long and so this is false and should generate an invalid message length error same thing with a message that is too short a name that is too short a name that is too long and then finally we write some messages that are exactly the minimum we need so three letters in the message three letters in the name and then the maximum so 30 letters in the message and then 10 letters in the name this is exactly 10 letters and we check again that the number of calls is correct we can give it a try and we see that it worked we start with hello then we call it with a message an Jack and the name Anna we can see that we now have Hello Anna Colin Anna and Ja forever and after another call from Joe we have Joe Tes us forever and then two calls we have those four test that didn't work and then finally another two that worked all good in this module you will learn how to manipulate addresses in a smart contract which will make your smart contracts a lot more powerful as tesos is a public blockchain it is permissionless that means anyone can participate in the network anyone can emit transactions anyone can create accounts Etc however when they do so they are authenticated based on their address so their address is attached to their balance and their transactions are attached to their balance and whenever we execute a transaction we can know for sure that this transaction has been emitted by whoever owns the private key of this address so they are directly attached to a specific address and when you use addresses in smart contract that makes it very powerful you can authenticate users that call the smart contract so you can basically Implement fine grain access control and you can also use these addresses to assign ownership to any digital asset you have already manipulated addresses you know that TZ addresses correspond to user accounts and KT addresses correspond to the address of smart contracts you deploy and each of these addresses uniquely identify either a user or a contract and the TZ addresses are based on the hash of the public key of the users also include a check sum so you cannot just write a random sequence of numbers after TZ the checkm has to be valid from a smart contract you can manipulate addresses for example you can obtain the address of the direct Coler of the contract it could be a user or it could be another smart contract you can also compare two addresses so you can check if the address of the color is equal to some expected address so that enables Access Control you can also send TZ to a given address or you could call another smart contract based on its address on the other hand there's a few things you cannot do you cannot check the test balance of some address whether it's a user or of a contract from a smart contract you only have access to your own balance and you cannot read the storage of another contract either you can only read the storage of the cont cont ract that you're executing let's look at some syntax to manipulate addresses so if you want to create an address value you simply write sp. address and then between parenthesis and between double quotes you just give the actual value of the address so a tz1 address or a kt1 address if you want to express the type of an address you simply write sp. address you have access to the address of the direct color of the smart contract through sp. sender and if you want to know the address of the contract itself that you are currently running you can use sp. self address So that's its own address in your test scenario you can create test accounts for fake accounts just for the purpose of the test using sp. test account and then a name that you can give so you can store it in in a variable then when you call Smart contract and need to send the address of one of these accounts as a parameter of your smart contract you can simply use the name of the variable where you store the account do address so this will send tz1 address of that user and finally if you want to call a smart contract and say this call has been made by this user so the sender of this transaction is this specific user you can add a parameter when you call a smart contract entry point underscore cender equals then the variable that contains the account so here you're saying I'm calling the increment entry point with the parameter five as Alice using Alice as the center of this entry point so from the smart contract sp. Center will be the address of Alice let's work on an example we will change the store value cont contract so that only the owner of the contract is able to call the reset entry point and then of course we will add test to this new version of the store value contract here is our modified store value contract so on top of storing the value 42 initially the Constructor takes a parameter owner that we assigned to another variable in the storage then in the reset entry point we add an assertion we checked the sender so whoever is calling that entry point we check that is actually the owner that we stored here so we check that this address is equal to this address so that only the owner can reset in our test scenario we create a couple of account Alice and Bob and then when we instantiate our contract we say that the owner is Alis and finally when we call reset we first try with a sender being Bob so we call it with an address that's different from the owner that we defined here so of course we say valid equals false because we expect this to fail and then we try a call that should work by calling reset as alist so this is not sending in a parameter this is just saying that we simulate this call to reset with no parameter but where the transaction is emitted by Alice finally we verify that reset was correct and we check that is equal to zero let's give it a try here we can see that when we insten the contract the value of the owner is tz1 WXR so this is Alice's address then we call the add entry point we see that here the sender is not defined because we didn't specify any sender here when we try to reset as Bob we can see that the sender here is a different address so not Alice Alice was tz1 WX Etc here we call it as tz1 RP Etc so it doesn't work only owner can reset then we do another transfer this time as alist tz1 WX Etc and this one works and of course we reset the value to zero now it's your turn modify the endless wall contract so that the same user can't add text twice in a row basically we want to do a very basic spam prevention so we don't want the same user to send two messages in a row which means between two calls from a given user at least one other user should have added text otherwise we reject the call please pause the video and give it a try let's take a look at a solution here in the constructure we take two parameters the initial value of the text and the address of the owner so we initialize well text to this initial value we initialize the number of calls to zero and then we initialize the last sender as the owner so this address this is an address where we will store who is the last person who called right message but we have to initialize it with some address so we decided that we would use some address that is the owner of the smart contract so we say the owner deploys their contract they shouldn't be the one sending the first mess message and if they want to be the one sending the first message they can just send a different address here then in the right message entry point so we have this version where we only send a message we add an assertion that the value of the sender so whoever is calling this entry point should be different from whoever we have stored in last sender then we add the message to the wall we increment the number of calls and then we update last sender to whoever is calling this entry point so this means that once we have a first call the next call cannot be by the same person because the next call shouldn't have sp. sender equal to last sender we can have our test scenario where we again create a few accounts and then we first write a message using Eve as the sender then we write a second message where we use Bob as sender this should be fine but then we add another message where it's Bob again try to send some messages so this should fail and then the next one we send it at Alice again so it works and in between we tried with Alice but with a wrong length of the message so this entry point was never executed and it's cancelled so now Alice can send a message again because the previous person to send a message successfully was Bob let's give it a try okay we can see here that initially we have last sender that's the address of Alice tz1 WX Etc then we have write message sent by Eve tz1 NW then we have write message sent by Bob so a different address tz1 RP and every time we can see that the last sender has been updated to whoever is calling this message so I'm here now send her update to Eve so now again we have Bob train to call but L sender is set to this value so this is rejected we can try again then we send a message that's too long then we have another person try to send it Etc all good in this module you will learn how to create your own nft smart contract and you will find out that the few features we have presented in the previous modules already make smart contracts very powerful and useful the few Concepts we have presented so far integers Naturals strings addresses entry points storage and verifications already give smart contracts a lot of power you can use them to store data forever you can attach users to data through their address which can enable ownership and with verifications access control and smart contracts are unique thanks to their address on a unique blockchain finally they can execute code that will change this data and perform transactions based on pretty fine and most importantly unalterable rules all this makes it possible to create any type of digital asset with two properties scarcity and ownership anyone can create their own unique digital assets on tizel you probably already have heard about nft so nft stands for nonfungible tokens and an nft is a digital asset that is unique uniquely identifiable it contains some information it's metadata that could be anything an image for example or some text it has an owner and it can be transferred and that's it that's what defines an nft non Venable token so a token that cannot be split that is unique and that can be transferred because they clearly identify the ownership of an item nfts can identify the ownership of any digital or physical art or collectible such as paintings music or ingame assets they can also represent real estate or any other physical assets or they could be used to represent more temporary assets such as tickets for a concert or any event passes and if you also provide a number of benefits like everything on a blockchain when used well they don't depend on a third party so for example you could transfer an nft without having a third party authorize or be the intermediate for this transfer they also provide a temper proof record of the ownership of the Em which makes it easier to track if you're really buying the right thing if basically it prevents counterfeiting you know that what you're buying is the original nft and you can see who sold it first Etc they make it possible to trade on new marketplaces that are available worldwide without restrictions so this increases accessibility as well as liquidity and can increase the value of these assets and finally they offer the possibility to add a number of features such as automatically paying royalties to artists when you transfer the nfts there's actually nothing new to learn for you to be able to create your own nft contract so based on what we just described you can already write your first nft contract so the idea is to create a contract that will represent a single nft to do that you have to keep in mind that the nft needs to be uniquely identifiable that it will contain some information that we call metadata that it has an owner and that it can be transferred so give it a try pause the video and try to create your own NFD contract if you're stuck come back and we'll give you some hints okay let's talk about some hints on how to create an nft smart contract when you create your smart contracts the most important thing is to determine what you will store in your smart contract and what the different entry points will be then it gets easier to write the code of each entry point so if we think about what the contract would store we need to think about its different properties we said that the nft contract has to be unique but every contract is already unique as it is identified by its address so it makes it unique on a given blockchain so we actually don't need to do anything about that we just rely on the uniqueness of our smart contract the nft has to have an owner we can simply store it as an address in our contract same thing for metadata we can have metadata in the storage of our contract for example as a string it could simply be your names first nft finally it has to be transferable so for that we need to be able to change the owner so that means we need an entry point that will update the address of owner but of course only the current owner should be able to initiate this transfer with those hints in mind pause the video give it a try make sure everything's good in your smart contract and don't forget to test it well let's look at a solution so we can see here this single basic nft smart contract and we can see that it's very lightweight in the storage as we described in the hints we have the owner that we initialize with the first owner so whoever is deploying this contract can set this value to their own address then we have the metadata here we uh simply hardcode it in the Constructor we could also pass it as a parameter but the same thing is when you deploy your contract you define what the value of the storage is initial as we already described the uniqueness of the enf is already given by the unique address of the smart contract so there's nothing you need to do about that and finally we create this transfer entry point where we pass the address of the new owner then the entry point checks that the current owner is indeed the one who's trying to do the transfer so we check that the sender is equal to the owner otherwise we have this exception and if that's the case we assign the new owner to the storage that's it and of course we need to test it well so we create a few accounts we instantiate our nft we say Alice is the original owner we keep this metadata as the original metadata then we can create our test scenario and we try a few transfers here we transfer to Bob we check that indeed it was transferred to Bob we check the metad data is what we think then Bob can transfer to Eve so we check that the new owner is inde the eve then Bob can transfer the nft to Eve and we check that Eve is indeed a new owner and finally Eve can transfer to Alis and we check that this is good so here we missed something right our test is not complete it's important to keep in mind that you should always test the case where everything goes well but also test cases where people try to do things that are not allowed so of course here we have this assertion that checks that whoever is trying to do the transfer is the current owner we need to make sure we check this assersion in our test so we need to add this verification of trying to transfer for example to Bob but as someone who's not the current owner so Alice is the current owner so let's try transfer to Bob as Eve and and we expect this to be failing so we write valid equals false and the exception equals not your property let's give it a try all good so we start with this owner this is Alis tz1 H4 Etc metadata first nft we have this unique address that identifies contract therefore nft so Alice transfers to this person that's Bob and so we can show that the owner has changed then we transfer to Eve we can see that the owner has changed Etc and finally we tried transfer to Bob by Eve but we have the exception as expected not your property so everything is good and now we have our first nft smart contract if we deploy this smart contract we are creating an nft that will be on the blockchain forever that we can transfer and that has its own metadata of course you want to create nfts with maybe more interesting metadata than this but this is actually really an nft of course it's still a very lightweight nft and it's missing some features that we really expect to make nfts convenient the main one is that doesn't make it easy to securely trade it against currency or other nfts in particular you can transfer it but there's no secure way to sell it without taking a risk that's really the main issue with this smart contract the next one is having one contract for each nft is not very convenient it makes it expensive because you have to pay for each deployment T us the fees are reasonable enough but still you have to pay for the storage of each contract that's not ideal and finally it doesn't follow any standards there are nft standards that make it easy for nfts to interact with different tools with wallets with uh marketplaces Etc so if you use this very simple nftd contract you really won't be able to trade it much and benefit from all the possibilities of nfts but in the next modules you will learn how to address these issues and add these possibilities and more to your nft control on blockchains everything is about trust on one side it's about not having to rely and trust a third party for things to happen as expected and on the other side it's about trusting that things will happen exactly as they are supposed to exactly as a smart contract announced things would happen and blockchain is also about the underlying cryptocurrency in the case of tesos it's all about TZ in this module we will see that both complement each other that TZ can increase the trust you have and its trust that gives the value to the cryptocurrency a public blockchain is a system that anyone can use without necessarily revealing their identity and it's also a system that has a lot of value at stake so if anyone can use it without revealing who they are and if there's a lot of value at sck what could possibly go wrong all this can only work if most participants behave well so the question is how can we make sure they do pause the video and think about it for a moment before you continue if we take our previous example of a contract that allows people to post text on a wall forever how can we prevent someone from flooding or wall with all kinds of messages we tried preventing the same user from calling twice in a row as an example on how to use addresses but this doesn't really protect from anything it's very easy for a user to create many different addresses and in our case we only needed to create two addresses and switch back and forth between the two addresses to post as many messages as we wanted another approach could be to restrict access to a set of trusted people but that would really defeat the purpose of the contract and the whole idea of blockchains where anyone can can join so it would be too limiting and complicated to use it's possible but it's not really the goal of this contract it also wouldn't be 100% safe just because you think you trust someone doesn't mean they're going to behave well still focusing on this endless wall contract can you think of an approach that could work to prevent people from spamming the wall with tons of messages give it a moment and pause the video before you continue one way to prevent excess iive use of a smart contract is to rely on a financial incentive all you have to do is charge one Tes every time someone wants to add a message to the wall if you really want to post a message and keep it forever one test is not much but if all you're trying to do is to spam the wall with all kinds of junk then one test for every message is starting to be expensive so by charging one t for each message you make sure that people don't abuse it at the same time you can use this test as a way to fund the development of our nice app that showcases this wall contract and makes it easier for users to post their messages on it as we're starting to see cryptocurrency is useful for much more than speculation or simply storing value you can use it as part of the blockchain security you can use it as a punishment for bad behavior that's what we do to prevent double baking through the slashing of the baker deposits you can use it as a reward for behaving well so for Bakers it's about a reward for baking or denting bad behavior and you can also use it as a way to prevent excessive use that's what we do when we have this system of gas to prevent people from using excessive computation from the network or storage fees to prevent people from using excessive data on the network so we can see that cryptocurrency is is used to increase the trust that we have in the blockchain and the fact that it behaves well and reliaable the same can be said about smart contract and you can use cryptocurrency as a way to increase the security of smart contracts you can use it as punishment by asking people to deposit some Tes that may not be returned if they don't behave correctly you can use it as rewards that users can obtain for providing a service or maybe dening bad behavior and you can use it in your smart contract to prevent excessive abuse by charging fees as we discussed instead of setting strict limits and rules that may limit legitimate use of your smart contract how do we do that when you call a smart contract the caller may send some Tes to this contract these ts are added to the balance of the contract and they also may be sent to to another address by the contract so that's how we can have a contract that charges a fee for example let's look at the syntax we have Type M TZ that can be used to express amounts of Tes that we manipulate in the contract we can create values for example if we want to have a variable that stores 12 TZ we can write sp. TZ of 12 or we can write it in the actual unit that's underneath that is the mutes a millions of Tes and so we can write sp. mes of 12 million this is the same as this so sp. T of 12 is a shortcut when you want to manipulate a whole number of Tes but the actual type is the mess of Tes the mutas within a smart contract you can check how much the color of the smart contract transferred to this contract by using sp. amount you can also check how much is currently in the balance of the contract with sp. balance that includes the amount that has just been sent by the caller but finally you can send some Tes to an address by using sp. send the address and then the amount that you want to send not that this is generating a transaction that is not immediately executed it's added to a list of transactions that will happen after the end of your entry point in your test you can test the transfers of Tes so for example when you call an entry point you can specify who is calling it and how much they're sending to the entry point by adding underscore amount equals and the amount you want to send from this user to the contract within your test you can also check the balance of the contract just simply by writing contract. balance on the other hand it's not currently possible and smart P to check the current balance of a test account so after here Alice sends some test to the entry point you cannot check that the amount Alice has on her balance has indeed decreased by five you could do it by using a smart contract instead of a regular account we'll see later how we can do that so it's really important to understand that on tesos at least on the L1 that we're working on with smart py when a contract charges a fee for a ser Serv the contract doesn't take the test from the account it's the caller of the contract who is the one who sends the right amount of test to the contract all the contract does is to check if it's happy with the amount that the caller sent and if it's not happy with it it can fail and basically reject the call but by default any Tes that are sent during a call are automatically added to the contract's balance so the contract does doesn't have anything to do to accept the Tes all it can do is potentially reject it if the amount is not what it wants so this is important in particular because this is not the case for all blockchain but that's how it works on tesos let's look at a version for Endless W contract where we charge one Tes every time someone calls right message all we had to change was to add this line where we check that the amount of Tes sent by the sender is one test if not we generate an error incorrect amount and everything is cancelled that's all we need to make sure people pay one test whenever they want to write a message in our test scenario we can check that if we indeed do send one test everything works but to check that it's really exactly one t we can check a little bit less and this should fail and cause the exception incorrect amount and same thing if we send a little bit more it will cause the same error and it's always good to have a second call to check that we can indeed call twice by paying the right amount let's give it a try everything worked so we can check towards the end this is the first call where we send one t with we can see that it added the text testing the right amount and then here we tried with a tiny bit less and generate the error same here with a tiny bit more and then if we send one test again everything works this contract actually has a very terrible flaw and things would end sadly for the author of the contract and it's a real flaw that people have made in the past and have lost large amounts of fund so it's very important to have this flaw in mind and avoid having it in your own contract so the question is can you figure out what that flaw is and then can you fix it take a good look at the contract pause the video and try to find the flaw as we stated earlier the test sent to a contract or added to its balance and by default that means these T are stuck forever in the contract there is no notion of owner or author of a contract on tesos unless you specifically assign a value to an oral variable in the smart contract so that means by default no one can get these Tes out of the contract that means the Tes in the balance of the contract are wasted if we want to avoid wasting them we need to specify an owner of the smart contract that will receive this T and make it possible for this owner to collect the tests to do that one way is every time someone writes a message to send the corresponding Tes to the owner so we can send the amount received and that's it and we see here that after a call where the caller sends one test to the contract then the contract generates a transaction that sends one test to the owner unfortunately this is not enough there's another big flaw can you figure out why pause the video and think about it for a moment I'll give you a hint the idea is that this version of the contract doesn't really enjoy all of the benefits of the centralization so I'll recap Main benefits the centralization provides relability it gets rids of the dependence on the third party and it prevents censorship so one of these aspects has been lost in this version of our smart contract can you figure out which one and why and how to fix it take a look at our contract and think about what could go wrong pause the video and think about it for a moment to find out what the flaw is you have to remember that a smart contract is a kind of account and like any account its address can be the destination of some transfer so instead of using a user account address as the owner you could use a contract address as the own and so when you send some test you can send them to a contract address if the address isn't that of a contract in practice sending test to a contract address will call the default entry point of that contract it's simply an entry point called default that takes no parameter and if you want to create a default entry point that accepts TZ as TZ or by default accepted all you need to do is to do nothing and as a way to show that we write pass as the only instruction in the contract to indicate that yes we know we don't want to do anything in this entry point so we write pass to say do nothing this will be an entry point that accepts simple transfers of TZ to the contract now the issue is that if the owner of a contract is a smart contract this smart contract could change change the behavior of its default entry point and reject the Tes if as the owner of the contract you can reject the test you can reject calls to write messages that means users have to trust you they have to trust the owner of the contract that this owner will not disable the smart contract or prevent someone from posting their messages the whole idea of decentralization and not relying on the third party is that you don't want to have to trust that the owner of the contract will not stop the service for any reason so here if whoever deployed the contract made the owner another smart contract and that smart contract can prevent transfer of test then they have full control on whether Our Endless World contract works or not and that's a problem we don't want that to better understand this let's look at an example so we have our endless World contract here that whenever we call right message checks that the user sent one test and then sends that one test to the owner so let's see how we can make this owner a smart contract that will then have full control on whether it's possible to call right message or not the idea is that we can create this owner contract that will store the owner of this contract and we'll have a Boolean called blocked that says where whether it's accepting or blocking transactions so we set it as false initially everything works then we have an entry point set block where the owner can change the value of blocked to true or false finally we have our default entry point if blocked is false then this condition will be true and then the contract will not only receive the test but send the balance back to the owner owner of this contract but if blocked is set to true then it will reject any transfer to it so if this contract is the owner of this contract then whoever owns this contract can decide to block any call to write message we can write the corresponding test scenario here we create a scenario we create an instance of our owner contract and Alice is the owner of that owner contract we added to the scenario then we create an instance of Our Endless World contract and we say that the owner is actually this contract's address we add that to the scenario as well then we can check that if we simply write a message and send one t everything works but if we then call set block of that contract as Alice who's in charge of this contract then the next call the same call is going to fail with the exception wall is blocked returned by this contract when we call the default entry point let's give it a try so it worked and we can see that indeed when we did the second right message call it's call the the default entry point of our owner contract and raise the exception wall is blocked so the transfer didn't happen and Eve was not able to write on the wall this is not something we want we don't want some unique person some third party to have full control on the contract and prevent other people from using this service so how do we prevent that well the issue here and that you should always be careful about is that this entry point called by any regular person is sending T to another address and this is the dangerous part because this could fail and prevent any call from right bling so the solution is to avoid calling send to another address as part of the entry point that the first person is calling to do that we just split it into a separate entry point that this owner will have to call to get their money back so we create a separate entry point that we call claim that can be used by the owner to request the balance to be sent to them here we checked that it was actually the owner calling this but we don't really need to if someone else calls it then it's going to send test to the owner and that's fine that's what we want in the end we just didn't want it to happen as we write message because this call could be blocked so we don't actually need this assertion so now we don't have an exception anymore so expected exception but not occurred so we can change that and say yes now this works but for Alice to get her money she would have to call the claim entry point so now that we know a little bit about transferring TZ to and from a smart contract let's see how we can use it as a way to add a feature to our nft smart contract so that the current owner of an nft can sell it with the transfer entry point that we already had in our basic nft smart contract we could imagine a sell that would take two steps two transactions the first transaction would be for the buyer to send a certain amount of t to the owner of the nft to pay for that nft and then in a second transaction the owner could say okay you paid me now I will call transfer on that nft with the address of the buyer so that's a typical transaction right if you go to the bakery and you want to buy some bread you give 1 to the Baker and then the baker gives you your bread so the question is what could go wrong with such a system and how could we change our basic nft smart contract to fix this issue here was the contract so pause the video and think about it for a moment so the issue when you use two transactions is that it relies on the two parties to trust each other that's the case no matter in which order the two steps are performed if it's the buyer who sends the money first then they have to trust that the seller will indeed transfer the item to them on the other hand if it's the seller who transfers the item first then the seller needs to trust that the buyer will then send the money without the blockchain so for example in our Bakery the same thing can happen you could pay 1 EUR for your bread and the baker could take your the Euro and not give you your bread or if the baker gives the bread first you could take it run away without paying the one Euro in this sitation we can rely on the police we can Ry on the justice system Etc as a way to handle conflicts or more generally we can involve a third party for example an online shop as an intermediate between the buyer and the seller but again you need to trust that the police will care about your bread or your one Euro that you lost that the justice system will be effective Etc it's really a hassle and can be actually very expensive and time consuming and you have to trust that the police police or the justice system will do their job well but thanks to decentralization blockchains can provide this kind of trust without a third party within a smart contract you can perform what we call an atomic exchange where either the two steps of a transaction succeed or neither of them will happen so either you both transfer the item and get the money or nothing happens simply by having the two steps within the same entry point since any step that fails cancels the whole entry point let's put this in practice with an exercise where your goal is to change the basic nft contract so that users can buy or sell their nfts so your goal is to add a buy feature such that the following can happen the owner of the contract should be able to set a selling price price for their nft the buyer should then send the corresponding amount of Tes the seller should be able to get these T and finally the ownership of the nft should be transferred to the buyer when everything goes well the contract should make sure that the buyer only gets the nft if they sent the right amount and the seller should only receive the paid amount if the nft ownership was transferred so how can we we do that pause the video and try to work on it so to help you we can think of what entry points we will need we will need two different entry points one for the current owner of the nft to be able to set the price at which they want to sell that nft and the second entry point will be the buy entry point that the buyer can call to purchase the nft will have to check that the buyer transfer the correct amount using sp. amount it will need to send that amount to the seller's address from the balance of the contract and then it will have to transfer the ownership of the nft to the buyer so please implement this you can then validate it on Open tizel let's take a look at the solution in our Constructor we added this new value the price that we need to store then we have an entry point set price that takes the new price as parameter we make sure only the owner of the nft can call this entry point and once we've done that we simply replace the current value of price with the value of the parameter finally we can have a buy entry point that doesn't need to take any parameter the buyer don't need to say how much they send they simply send it as they call the buy entry point and it's the contract that checks that the amount sent is equal to the price cuz if if it was a parameter the buyer could just claim whatever amount without actually sending the test so the amount to send is available from sp. amount and that's the value you want to check so once you check that the buyer sent the right amount you can send that amount to the owner so here as we have seen this could fail but if that fails that means the owner doesn't really want to sell it so that's fine we don't need to separate that into a claim entry point here finally once we have created the transfer of price to the owner we can change the owner to the address of the caller who's the buyer and that's it then we can test this here we call set price with a price of seven from Alice who's the original owner of the nft we check that if someone else like Bob tries to change the price this will cause an exception you cannot update the price and finally we try to buy the nft as Bob paying the right price 710 and we check that if we try to buy it at the wrong price this will cause an exception saying wrong price let's give it a try all good we Chang the price here we can see that the price has changed we can see that this failed then we actually purchase and we can see that the amount was sent back to Alis then we can try to purchase with the wrong amount and we get an exception all good so just by doing this we made our nftd contract a lot more convenient so now you can buy and sell nfts in this module we'll give you the answer to a question you may already have asked yourself what if I don't want to put any value for example what if I don't want to set a price for my nft it's not for sale for that we can use options but we also see that in many cases you probably shouldn't use them so far our variables always had a value but sometimes you simply want to say that there is no value for example when you initialize the endless wall and we keep track of who called the right message entry point for the last time initially you want to set this last caller value to nothing right nobody has called it yet so how could we support this possibility pause the video and think about how you would support this possibility if it was up to you so how can we allow variables of some type to have no value at all one possibility could be to use a special null value but this could be quite risky if an INT variable is new then any arithmetic operation you apply to it would fail if you want to avoid bugs you want to make sure that if there's Theos possibility of a Nal case your code always handles it but you don't want to have to handle the newal case even for variables that actually always have a value how can we solve this dilemma again pause the video and think about it for a minute if we want to both Force the code to always handle the possibility that a variable has no value but at the same time avoid having to write such code for variables that will always have a value then we would need to use a different type for both situations right so for any type int not TZ address Etc we would have a version that always has a value and then another variation of that type that sometimes may not have a value how can we avoid having to support two versions of every type a steel handle both cases so instead of having two versions of every type the int that always has a value and then it that may have no value we use a special type that wraps around all the types and we call it options an option is like a box that may or may not contain a value of a given type so for example an option on an INT may contain either nothing or an INT all you can do with an option is create the option with or without a value check if an option has value compare two options unwrap the options that basically means is getting the value that it contains out of the option and any other operation can't be done without first unwrapping the option so for example if you want to add two values of two options so two options on the NIT you need to unwrap both options and then add the actual values so here is how you create an option you simply write SP do sum and then between parentheses the value that you want to put inside an option but of course you also want to be able to create an option with no value for that we simply write none two options are equal if they contain the same value so we can compare sp. sum 42 to sp. sum of 42 and those would be equal or if they both contain nothing so none equals none any other case they are different so for example you could do assert my option equals sp. sum of 42 or S my option equals n you could also use the other type of comparison operators lower than greater than Etc if the two options contain a value it will compare these values if at least one of the options is none it will return false so for example sp. sum of 33 is lower than sp. sum of 42 but none is not not lower than sp. sum of 42 and it's not greater either or equal to sp. sum of 42 so those two will return false if you want to extract the value out of an option you can write your option do unrap sum and this will trigger an error if the value of the option is none because there is no value to get out of it the Box doesn't contain anything if you want to check if an option has a value you can see simply write assert my option different from none it's usually a bad idea to use unwrap sum to compare an option to a value for example if you do if my option do unrap sum equals my value then this will fail if the option doesn't contain any value which is probably not what you want you just want to do something if it's exactly this value and not fail if it's not so what you would rather do is compare to an option so if my option equals sp. sum of the value you want to compare it to so instead of unwrapping your option you wrap the value that you want to compare it to this will never fail whenever you need to describe the type of an option you can write SP do option and between square brackets you put the type of the value inside the option so for example for a n the type would be sp. option and square brackets sp. n for for none type inference is used to determine the correct type let's check an example in Our Endless wall contract when we wanted to check that the same address was not used to call right message twice in a row we used last sender and before we initialize it to the address of the owner but instead we could say the initial value of SL sender is none right we haven't made any call yet then when we want to update it instead of assigning it to sp. Sender we assign it to sp. sum of sp. sender when we want to check if it's the same color as last time we compare last sender to sp. sum of sp. Senter again you ripe the value you want to compare it to rather than unwrap your option does this would fail if the value was none so if we make that change and run it everything works and we can see that the initial value of L sender is none and then sum and the address Etc my recommendation is actually to avoid options when there is an alternative the reason is that when you use an option you need to add code every time you manipulate its value you need to add code to verify if it's none you need to add code to extract the value you need to add code code to compare it to a special value Etc every time there's something extra you need to do to handle the fact that it's an option this overall makes the code longer harder to read slower and more expensive so if there's an alternative that works we recommend using that alternative what would an alternative be well as we have done before we introduce option we can simply use a default value if there is one that can do the job so for an address we can initialize the value with an invalid address and give it a name so for example this is a contract address that is correct the check some works but it doesn't correspond to any actual contract and so you could use this address but most of the time using the address of the owner also works so that's what we had done for Our Endless World contract and the last sender value here if instead of using option we simply initialize with owner then we remove code right we don't need to do this we just directly compare to the sender and here we remove code again we directly compare to the sender so it makes the code easier to write and to read the only issue with this is that owner cannot be the one who makes the first call but if we want owner to be able to make the force go to write message we can just initialize with a different value that that we know for sure will not be the one writing the first message such as an invalid value of course sometimes it's necessary to use options because there is no better choice so for example if you need to call another contract that has an entry point that takes an option as a parameter of course you need to use an option but sometimes you need to create your own entry point that has an optional parameter maybe because you want to be compatible with a standard that uses options if no matter what you need to have some specific code to handle the case where there is no value then you definitely want to use an option it's a lot nicer to compare to none than to compare to some arbitrary value that you use instead of N and finally if there's no default value that would work nicely then you should use an option for example for the nft contract if you want to make sure that nobody can buy your nft putting a very huge price on an nft would Weir would be a weird way to handle it it would mean like you're pretending that your nft is extremely expensive so it's a lot better to say my nft is not for sale the current price is none finally there's a number of cases where you need to access return values from Instructions that may cause errors and such instructions often return an option here are a few examples if you use the function is n to check if a value is a nut this will return none if the the value is negative and it will return an option on the value if it is zero or positive another example is sp. slice that extracts a substring of a given string but it will return none if for example the offset or the length are invalid there is no such extract and it's beyond the bounds of the string for example but if it is valid then it returns an option on the result another case is when you want to interact with another contract you use sp. contract and provide the type of the contract the address and the entry point and it will return none if there is no such tree point for the contract at this address otherwise it will return an option on the contract let's put it in practice with an exercise change your nft orell contract so that it uses an option to indicate that the nft is not for sale so if you want to say it's not for sale you will use the set price entry point but pass none as a parameter to say I don't want it to be on sale and similarly right after somebody buys it you want to set the price back to none so that it cannot be bought again immediately by someone at the same price here is a smart contract that we asking you to change pause the video and give it a try so here when we initialize the contract we don't need to put any initial value value so we can remove the price and initialize It To None when we set the price well we need to pass an option anyway so we just save it as is it's already an option and when we buy then we need to compare the amount sent to the price so we don't unwrap the price we wrap the amount using sp. sum and finally we need to set the price back to none you know test here we need to wrap this into an option same here and line 21 we need to unwrap this because we need to send the value but since we already compareed the amount to the price instead of unwrapping this we can simply send the amount received and so when we initialize the contract we decided not to put any price so all good but now if we want to say it is not on sale all we have to do is C1 do set price none and so we can see that end we put the price Back To None So options are pretty easy to use but remember that when you can it's better to avoid using them to simplify your code in this module we will talk about blockchains and time blockchains have a deep relationship with time you could say that a blockchain has a pulse it's like a heartbeat ticking very regularly from the Genesis block towards eternity every few seconds we have a new block another connection between blockchain and time is that a blockchain can be used by anyone to safely store information forever to send information far in the future it also has a relationship with the past as a blockchain can be used to certifiably timestamp information and prove interiority basically prove that at some time in the past you already had this information and you can prove it finally it is possible to use a blockchain to lock assets until a specific time in the future in a way use it as a Time cap capsule the only issue is that a smart contract actually can't tell time when you execute the smart contract you cannot read the current time from the computer that executes it the reason is that a smart contract should always produce the exact same result no matter which node execut it no matter when it executes it so if you run the same program on different nodes and at different times the current time will be different right so the code cannot depend on the actual current time of the computer that runs it however you really often need to manipulate time within a smart contract you want a smart contract to be able to check if it's been called before or after a deadline you want to be able to check how much time has passed between two given events and you also want to be able to store and saveguard the date of specific events so the question is how can we solve this dilemma we cannot access to a time of the computer the contract is running on but you do need to know the time pause the video and take a minute to think about it so the solution is that every block includes its own timestamp and a smart contract can access this timestamp using sp. now and every smart contract call within the same block will read the exact same Tim stamp and it doesn't matter which node executed or when we execute it the time stamp of a block is always the same so whenever you execute a contract from a block the value of the time stamp is always the same and then of course for the next block it will be a different value corresponding to when this block was created but the time stamp of a block is actually predictable the value of sp. now is predetermined by a time stamp stored in the previous Block in practice there's two time stamps in the block the one that can be read through sp. now and the actual creation time of the block that will only be used by the next block to compute value of sp. now in the next block so the time stamp of a block is predictable based on the content on the previous block but more than that in practice blocks are created very regularly at the time of recording there is a block being created every 15 seconds and if you look at the ual time the difference between two block creation is really precisely 15 seconds most of the time there's very little variation that's something important to keep in mind in smart Pi we have a type dedicated to time stamps s. timestamp and it represents a number of seconds relative to January 1st 1970 at midnight internally it's like an integer it can be infinitely positive so it can correspond to any date as far as you like in the future but it can also be infinitely negative so represent any time as far as you like in the past if you want to create a time stamp you can use sp. timestamp and provide the number of seconds since January 1st 1970 again it could be a negative number if you want to access the time stamp of the current block you can use sp. now if you want to add some time to a time stamp you can use SP do add seconds your time stamp and number of seconds or if you want to add a number of days you can use sp. add days your time stamp and the number of days finally if you want to compute the difference between two time stamps you can subtract them and the result will be a number of seconds so that's very convenient to measure how much time has elapsed since a given event finally there's a way to create a time stamp using a list of parameters where you provide the year the month the day the hours minutes and second this is using sp. timestamp from UTC so it's a time in the UTC time zone when you test a smart contract time doesn't pass between your different calls doesn't matter how long the computation takes you can make as many calls to your smart contracts in your test the time is not going to pass automatically SP do now will always be Zero by default but you can specify what value of sp. now you want to use by adding a parameter to your entry point calls underscore now equals and then the value of your time stamp this way you can simulate time passing without actually having to wait if you have a contract that has to wait 10 days for some event to happen you don't have to test it by waiting 10 days you can just simulate time passing by changing the value of now let's work on an example we'll take or unless we count contract and add a deadline the idea is that we will change a contract so that people only have until the end of 2025 to write a message on it from then on the wall won't change ever again so how do we do that well for one we we need to change our storage and add a deadline that we can initialize in the Constructor then in the right message entry point we will add a check is this before the deadline so we check if sp. now is lower or equal to our deadline otherwise we have an exception after dead line and that's it that's all we need to have this feature that the endless wall expires after a given deadline in or test to check that it does work right before the deadline but stops working after that line we call write message with a date that is just before the end of 2025 December 31st at 1159 and 58 seconds this one should pass but then a couple seconds later on January 1st 2026 after 1 second this should fail so we add valid equals F we use underscore now to specify the time we can initialize using time stamp from UTC let's give it a try it works we can see here that this call was met at this time so something that ends with 598 and it worked but a little bit later 3 seconds later 601 this one failed because it's after the deadline now it's your turn to practice on an exercise this time you will change your nft contract to add some notion of time in it and the idea is to make it so that you cannot sell on nft less than 5 days after the last time it was bought pause the video and give it a try let's look at our solution in the storage we will need to add a date that is the last time that somebody bought this nft so we initialize it in the constructure and then in the buy entry point we will store the new value so assign it to sp. now but before we allow the user to buy this nft we check that the current time is more than 5 days after the last date so here we have the last date that it was bought and we use sp. add days to add five days to it if this fails then we have an exception that says you need at least 5 days so here you may want Wonder should we use options so that initially The Bu date should be set to none and the answer is no as I said earlier when you have a way to avoid using options I recommend avoiding it here there's a very simple date that we can use as a default value and that could be sp. timestamp of zero so January 1st 1970 so there's no need to use an option any call we could make of course will be more than 5 days after that date so there's really no need for an option in this situation now let's look at our test so here we have the test that check the deadline when we initialize a smart contract we initialize with sp. time stamp of zero and then when we try to buy it the first time at the right price we set a value for the current date that is four days so so that's four times the number of seconds in a day after the time stem zero so that's of course way in the past but what matters is the difference and so this one should fail because it's less than 5 days after the initial value of BU date but then if we do a second call this time six days after the time St zero then it should work let's give it a try and it's all good we can see that this attempt was done at this time and in and a bit later this attempt was done and it passed well good so this is a good time for a recap of all the benefits of a smart contract that we have seen so far we have seen that smart contracts add trust in a sense that they allow us to eliminate the need for trusted third parties when we perform transactions by eliminating these intermediaries they also allow us to reduce cost they also have the benefit of transparency the code of a smart contract is public on a public blockchain so it's possible to check everything that will happen before you call a smart contract and use its service there is no surprise you should take the time to check the code we also saw that smart contracts are immutable and even the owner may not change the code at least by default so you are guaranteed that those rules will not change after you decide decided to use the service finally one of the benefits of decentralization is that there can be no censorship so nobody in particular can be stopped from calling a smart contract finally there is no single point of failure thanks to decentralization you can be certain that the service will always be available in this module you will learn to manipulate arithmetic operators and we will take as an example our first decentralized Finance contract a yield forming contract you have already manipulated some arithmetic operators but let's take a look at all of the ones that are available we already manipulated the addition using the plus operator subtraction and multiplication using the usual python operators as you would expect and we also have the negation to take the opposite of a value the integer Division and that's the only division we have and the single slash actually does an integer division on tesos because we don't have any floating Point operations those would be dangerous as they can lead to approximation issues maybe a different result depending on the architecture you're running it on Etc so to keep it safe we only manipulate whole numbers on tesos you can do modulo using the sp. mod function that takes two values and Returns the remainder of the division of the first one by the second one and you already manipulated some shorthand operators so we can use plus equals to add a value to this so Value Plus equals x adds X to Value same with minus equals or multiply it equal instead of having to write self data. Val equals self data. Val plus X Etc so this can keep things short for all these arithmetic operators both operants have to be of the same type this is because smartp is using Python and overloads the python operators and you can only overload operators if the two operant have the same type if you need to do arithmetic operations that combine two different types for example if you want to mix int and N operant you have two choices you can convert the nut value into an INT using SP do two int of the N value or you could convert the int value to a nut using SP do as int if you know for sure that the value is positive or zero or you could use dedicated functions for multiplication addition or division sp. add sp. Mo and sp. ediv that work even if the two types are different now the type of the result it's usually what you would guess based on what the result result can be so for the addition multiplication and division if both operants are Naturals the result will be a natural as well right you can never end up with a negative result if you add multiply or divide positive numbers but if at least one operant is int therefore could be negative then the result could be negative therefore it has to be of type int so if you multiply an INT with a n the result will be an INT same with addition and division for subtraction and negation the result can always be negative if you subtract two positive numbers if the second number is bigger than the first one and the result will be negative so the result will always be of type int whether the operant are Nots or inss for the module it's always a nut so the remainder of a division is always the positive remainder for the EDF function it returns an option on a pair of values q and R where Q is the quo so the result of the division and R is the remainder the reason why it's an option is because you divide by zero it could fail and in this case instead of raising an exception it returns none and if it doesn't fail then it returns an option on this pair we already discussed pairs a bit before let's look at it in more detail so to create a pair of values you put them between parenthesis and with a comma in between so A1 comma A2 between parenthesis and they can be of different types so for example you could have a pair where the first element is 42 an INT and the second element is a string and there the type would be sp. pair and between square brackets sp. in comma sp. string if you want to extract values from the pair you can extract the first element by using sp. FST for first the this would get you 42 here and for the second element you use sp. snd D this would give you ABC it's also possible to extract both components at once into two variables so here if on the right hand side of the equal operator you have some pair on the left hand side you can put the name of two variables between parentheses this will extract the first value of the pair in a and the second value of the pair in B and of course here it could simply be a variable that contains a pair or anything else it doesn't have to be the actual values so that's a good way to obtain a Content a pair into two variables in one single instruction this actually works for topples so so values that have more than two elements you could write a tole with three elements like this and you could extract all these three elements into three variables a b and c like this if you want to do arithmetic operations on mutes for the addition addition and subtraction if you add or subtract mutes the result will be a mutes if you subtract and the result is negative you will get an exception if you want to multiply mes you have to multiply them with a n if you have five T you can have twice that so five T times the natural two or you could do 2 * 5 T and the result will be a number of t 10 t for that you use sp. null since the two operant are of different types and so you multiply X by your natural value where X is of type mutes if you want to divide mutes by on that we have a special instruction for that to do computations we will see in a little bit that we call sp. split tokens that can do divisions and more on mutes if you want to do any other type of operations with mutes you will need to convert the values into other kinds of types when manipulating mutes you you need to be careful about overflows for inut we already saw that there is no upper limit or negative limit on how big or small a value can be except for the storage and the cost of storing these values but for mutes it's different mutes are currently stored using 64 bits integers and as mutes is a very small unit it's a million of AES that means you pretty quickly end up with big value so for example if we take 5,000 T that's 5,000 time a million mes so the actual value you store is 5 billion so if you need to square 5,000 test for example if you want to do some Financial computation that involves the square of the price Etc you may end up squaring a number of tests but you only need to square 5,000 T to get a result that won't fit in 64 bits because you're squaring 5 billion new TZ and 5 billion squared doesn't fit in 64 bits of course you cannot multiply 5,000 TZ by 5,000 Tes so you would have to use a type conversion to multiply a number of Tes with a number of nut and that get this result but it's really important to keep in mind because if you end up with a value that causes an overflow then the call to the smart contract will fail so you won't get the wrong result but the call Will Fail therefore you could be stuck and the funs would be stuck in your contract so be really careful when multiplying Tes with big values talking about type conversions we already said that if you can avoid it it's better to avoid any kind of type conversions usually it's a bad sign if you need to convert a type into another but sometimes you really do need to convert type so when you do need to convert types here is how you do it first for some of them you will need a special module the sp. utils module to make it available in your contract you need to declare it in your test scenario so in the test scenario after the name of the test we before had just made the only module that contain your smart contract but now we need a list of modules to have sp. UTS and then still main so between square brackets you put the list of the modules separated by a comma so now that you have the utils module available in your contract you can do some conversions you can convert a mutes value to a natural so for example if you convert one mutes you will get the number one as a nut and in the other direction you can convert any nut to a number of mutes or to a number of Tes so if you use not two mes and then you pass one you will get one mes but if you want to avoid having to put big numbers you can directly convert to T so if you call not toes with the value one you will get one TZ which is a million mutes if you want to convert a nut to an INT you simply write SP do2 int of the natural you don't need the SP doils module and then of course you will get an in to convert an in to a nut if you know for sure that the int is positive you can use SP do as n of your int value if the number is negative this will fail and make your contract fail let's play with an example in the storage we will store an integer value that we initialize with the int one and a n value that we initialize with a n zero the values don't really matter and I created one entry point per basic operation so one for add subtraction multiplication negation Division and the module and some with a shorthand operators that you can play with and then we have some test where we just call each of them if I simply run it it doesn't work it tells me I cannot subtract unknown and unknown for the subtraction operator so here that's because when we do the subtraction the result is an INT but the result of our subtraction is always an NT so we don't know what those are they could be Naturals they could be integers there's no way to know for sure what the type of X and the type of Y are just by knowing that the result is an integer so we have to help the type inference system so we simply say that X let's say is a nut and Y we could say it's um in maybe but now if we do that it will say no there's a problem the subtraction operators must have two arguments of the same type and I put an INT and a n so of course I could simply put a nut here and it would work now I have an issue with division so similarly it doesn't know what I'm dividing by so I need to say what the types are so I'll just say I'm dividing two Naturals so not works so here since the result is an end it deduces that X and Y are ends let's say X is a nut now if I run this it's telling me nope you cannot mismatch int and nut because the result is an INT if one is a nut maybe the other one may be an INT but we cannot add n an INT and if it's if the other one isn't n then the result wouldn't be an INT so here what I could do is either use SP do add X and Y but then it tells me I don't know what Y is so let's say Y is a NT and it would work or we could say well we first convert X to an in so let's say SP do 2 N of x plus Y and this would work as well so what I recommend you do is take this ample and play with it change the types of different values and see what happens and find ways to fix it and look at what the error messages look like Etc so for example one thing we could do is try to put the result of the subtraction as a n so this up course would fail because the result is an in I try to store it in the nut but I could try to do sp do as nut of the result which would work but that's only because I'm subtracting three from five so if I subtract seven here then it would tell me nope it doesn't work the result fails but here the message is not very clear because it's internally it's using options to manipulate the result because the underlying op operation returns an option and is none if the result is invalid so if before I use asut I need to make sure I know for sure that X is greater than y so play around with it now we can have a similar example where we play around with mutes here we have this financial value that's of type Tes and then we have operators to add subtract multiply and divide if I simp run it like that it's going to tell me it doesn't like multiplying two mutas and that's because my example multiply I did T time T so this doesn't work I can only multiply a mutes with a nut so let's say I want to do five T * three but it still doesn't work because again The Operators expect the two values to be of the same type and that's not the case here so before I even tries to run my test is just inferring from the type of financial value that those two values should be of the same type and type T so here I need to use sp. M then again for the subtraction it tells me I don't know what those are so I need to cast them and if I cast the first one it's going to deduct that the second one is the same type and now it's telling me that the multiplication it doesn't know what I'm trying to multiply because with sp. Mo can mully all kinds of things and obtain all kinds of types so I should say that X is of type mutas and Y is of type not for division same thing I need to provide the types let's say x is a mutas why let's try with not doesn't like it I need to use ediv of X comma y so this will return an option on a pair so I can do do unwrap sum and if I want to get the result I can do sp. FS of that pair and here it's telling me it's expected a nut but got mes so that's because when I call it I want to divide by but I simply put it as here and now it works so again play around with it and see what happens one operation we really often want to do when manipulating money is compute percentages but because there is no floating Point type on tesos um to avoid bugs related to approximations Etc we cannot compute 20% of a value by simply multiplying by 0.2 so we have to multiply by 20 then divide by 100 to make that easier especially when it comes to the types we have a special operation that we can use to compute any kind of percentages it's called split tokens and split tokens will take three parameters an amount a quantity and a total quantity and they will do the computation amount times quantity divided by the total quantity Where amount is a number of T and quantity and total quantity are of Type n and so this can be used to compute percentages so if we want to compute 20% of some amount we can call sp. split tokens of that amount comma 20 comma 100 of course we could also do the same with one and five as long as the ratio between this number and this number is what we want 20% it's not always 100 because we can consider having other kinds of percentages that are maybe smaller than 1% for example 0.1% so here all we would have to do is do one per thousand so we use quantity one total quantity 1,000 and this will compute 0.1% of 5,000 T okay let's use all this in an example and for an example we'll create our first decentralized Finance contract I'm definitely not an expert in finance and this is not a contract that we audited Etc it's really for educational purposes but we can show you how you can create a contract that people can lend money to for the purpose of gaining some interest over time we already presented the idea of baking and the fact that while baking ERS put some Tes at stake to get the rewards people who don't want to be Bakers by themselves can delegate their own TZ to the baker of their choice to get a share of the rewards when you pick a baker you can pick them based on multiple criteria you can check how much of the rewards they will share with you different bakers will share different percentages you can also check if they do their job well so if they ever miss the opportunity to create a blog because that's when they do create a blog that they get their reward and then share them with you so check how often this happens and of course you also want to check how they vote when there's a call for a vote for a new Amendment usually the reward you get when delegating your TZ is around 5% a year but there is no guarantee of that there's always a risk that after you delegate your test to a baker this Baker doesn't do their job well and misses a lot of blocks or doesn't pay you your Rewards or simply disappears and stop being a baker or changes address for example so when you delegate your Tes if you want to make sure that you get your share of the rewards you need to regularly check what your Baker is doing so you cannot just sit down wait a year and then get your profit there's a risk you wouldn't get anything your test themselves are not at risk because even if the baker behaves badly and gets slashed your own test that you delegate don't get slashed but the risk is that you won't get your rewards so the example we work on is a smart contract that offers the service for anyone who doesn't want to worry about that still want to delegate their test to some Baker They Don't Really necessarily want to worry about which Baker they just want to be assured to have some yearly interest without any risk at all so pause the video and think how you would create such a contract that guarantees to whoever is putting their money that they will get their rewards so what we will do is our first decentralized Finance contract that will enable the externalization of the baker selection and monitoring Etc making sure your Baker does a good job in exchange it will take a small share of your rewards so it will guarantee you that you will get get a fixed reward of 4% a year to make sure that whatever happens you will get this 4% this amount for a whole year will be deposited in advance in the contract and stuck there for you to get your guaranteed interest but the owner if they do their job well delegate the balance of the contract to the right Baker monitor it Etc and make sure they get 5% and they will be able to keep anything that's beyond the 4% that they owe you in exchange for taking the risks and we will do that in a contract that handles only one lender at a time so only one person will be using this contract at a time pause the video and think a bit about how you would do that okay so we will have two people interacting with this contract the lender so that's the one that has money to invest in the contract and want to get 4% back so the lender will be able to deposit their funds using a deposit entry point and put some test on the contract and at some point in the future when they want to get their deposit back plus their earnings they will call a withdraw entry point on the other side the owner will be able to control what beger to delegate the balance of the contract to and they will have a set delegate and true point to say I want to delegate to this Baker and they can change it at any time is their responsibility to make sure they pick the right Baker because it will impact how much they earn of course at some point they may want to withdraw their own funds so we need to have an owner withdraw entry point for the owner to collect any amount that they are allowed to withdraw they always need to make sure there's enough Reserve in the contract to pay whatever the lender has deposited plus one year of yields finally since the need is reserved in the contract need to have a default entry point to deposit this Reserve at the beginning before the lender deposits their own funds but this is also the entry point that Bakers use to send money to the contract when a baker send their rewards to an address that delegated to them they simply send test to this address so we need to make sure that our smart contract has a default entry point that accepts the rewards quick reminder the default entry point of a smart contract is the entry point that is called whenever you simply send some test to the contract if there is no such entry point the transfer will fail and if this entry point fails then the transfer will fail and you won't get the test so if all you want to do is accept direct transfers from anyone you can create this entry point called default that doesn't take any parameter and doesn't do anything so with the instruction pass but remember that any entry point can accept TZ as long as the call is valid okay so in our yield fing contract we will do a number of computations so first we need to add a ramp of period so it's a period of time where you don't get any yield and the reason is that when you delegate your Tes to a baker you don't immediately start earning you need to wait for the baker to get the opportunity to bake a block so to keep it simple we simply wait let's say 3 weeks before we start paying interest to the lender after that ramp period the yield becomes proportional to the time between the deposit after that rer period and the withdrawal so if you live your money for one year you would get exactly the annual yield rate if you wait for 6 month you will get half of that as interest as we said earlier we always want the owner to leave a reserve so that they can always pay one year of Interest so we will have a computation to do that where we multiply the deposited amount so deposited amount is whatever the lender has deposited multiply that by one because they at least should have that amount kept in the balance of the contract plus the annual yid rate so let's say 4% of that amount when the lender withdraws from the contract the amount they should get is their deposit times one plus their deposit multiply by the annual yield rate and multiply by what percentage of the Year passed since the deposited so the duration since the deposit after the rampant period divided by one year and here is how we compute this direction so we take the current date minus the deposit date and we substract the rampup duration now if we look at the contract in more detail we can focus on what we need to store so we need to store the address of the owner the address of the lender how much money was deposited on the contract when it was deposited we can store the annual yield rate that we promise that we will give to the lender and then how much time we need to wait before the yield starts so the ramp up duration then we have our different entry points we already talked about the default entry point we need the owner withdraw entry point for the owner to be able to withdraw some amount from the contract and then we will check that it's indeed the owner calling we check that the amount they leave in a contract is sufficient and then we send the amount request to them if everything is good we'll have the set delegate entry point that takt an address it's technically an option on an address as a parameter it will simply check that the caller is the owner only the owner may decide which Baker to delegate to to and then they will simply change the delegate to this address we need the deposit entry point for the lender to deposit funds and when we do that we check that there's not already some amount been deposited so we cannot increase how much we have in the contract we can simply deposit once then withdraw and if we want to start again we can deposit a bigger amount or a smaller amount so when we deposit keep things simple we check that the current deposit is zero and then we update this value and we keep track of when it was deposited finally when the lender tries to withdraw some funds we check that the caller is indeed the lender then we compute how long it has been since the lender deposited the amount and we subtract the ramp up duration from that and finally we compute how much they should get back so that the amount that deposited plus this amount times the yield so they are guaranteed annual yield rate times the proportion of the year that they got the money for then finally to say that the money has been reimbursed so we can say deposited amount is back to zero so that the owner can now withdraw everything because they don't need to leave any reserve anymore since there's no nothing deposited so now we can check the actual code so we see the constructure that initializes everything the owner the lender deposited demount deposit date here we set the deposit data at zero we could say well nothing has been deposited yet so why not use an option but again an option will make things more complicated here it's easier to just set the data at zero we see that we have our default entry point that doesn't do anything just pass uh we have our set delegate entry point that simply takes the address of the new delegate technically an option we check that it's the owner wanting to change a delegate and then we call sp. set delegate so this sets the Delegate for the whatever test are in the balance of the contract to this address we have a deposit entry point for the lender to deposit their money so we check that it's the lender we check that there's not already some money being deposited which would cause a mess in all the computations we then store the amount in deposit amount and we store the current date in deposit date now when the user wants to withdraw their funds again we check that it's indeed the lender we compute the duration since they put the money in so for that we take the deposit date we add the ramp up duration that's a number of seconds we subtract that from the current time and then we convert it to that there's an easy way easier way to convert to n here we can simply do as nut so that's the duration and then we take the duration of a year so that's approximate um but it's good enough we say year is 365 days and then we compute the yield for one year so we multiply the deposited amount times the annual yield rate that's at percentage let's say 4% this would be four so that's one year yield multipli by 100 then using the duration we compute the duration yield so how much for if this is how much for one year multiply by 100 this would be how much for this direction so we use split tokens to take one year yield and we for this duration divided one one year times 100 so that g us how much yield we should get for this duration then we simply send that amount plus the deposit itself back to the lender and then we reset everything deposited amount to zero and deposit de to zero finally the owner May withdraw at any time but always needs to keep a reserve that's enough to pay for one year of Interest so here we check that the owner calling owner withdraw we compute one year of yield again using split tokens so we take the deposit amount and we take the annual yeld rate out of that so 4% of that amount and the reserve should be whatever the user has deposited plus that interest if the amount that the owner is requesting to withdraw leaves enough so the balance minus whatever we take is more than this Reserve that we have to leave then we can send them that amount and that's it if we run it we can see that we initialize it with an annual y rate of 4% initially everything is zero then we set up this random duration ramp up duration I think that's 3 weeks the owner transfers five TZ to allow for some amount of deposit then the user deposits 100 T then we check that if we try to deposit again this doesn't work we can only have one deposit at a time on the contract if we try to withdraw with the wrong owner we cannot do that if we try to withdraw too much it doesn't work either but we can here withdraw one TZ and we still have enough to pay for one year of yields here we use set delegate to change the delegate of the contract so which Baker We delegate to and then here the owner withdrawals after some anount of time that we set here that corresponds to a year plus the ramp period and we see that they received 104 Tes so they deposited 100 Tes and now they get 104 back so that could be a very nice way to provide a service but again this contract has not been audited um this is just for educational purposes so don't trust it as is now it's your turn to work on an exercise where you do some computations and we'll take this opportunity to play a little bit with interesting nfts so the idea is that with smart contract we could show that you can create digital objects that has an owner that can be bought Etc but you can add interesting properties that can be very unique either Collectibles or you can even run interesting social experiments so let's try to do one we will create an nft that has a price that automatically increases by 10% after every sale so the owner of the nft doesn't set the price at which they sell it the price is automatically 10% more than whatever they paid for so pause the video think of how you would do that and give it a try so if we want to create an nft that has a price that increases by 10% after every sale we will need to remove the set price entry point point from our nft contract and then we will need to change the buy entry point so that it automatically sets the new price at 10% more than the previous price after the sale so if we do that and you start with an nft that's worth one TZ after the first sale it would be 1.10 TZ after 10 sales it will be 2.59 TZ and after 100 sales only this is exponential it will be 13,780 t pause the video and think about how you would change your contract and implement this let's look at the solution the contract we get is actually pretty basic we have three values in the storage the owner the Met data and our price that we set with an initial price and we only have one entry point left the buy entry point that simply checks that whoever is trying to buy is sending the right price then sends that amount to the owner and changes the owner of the nft and then computes the new price using sp. split tokens so we take the old price and we take 10% of that price and we add it to the old price and we can give it a try and calling a couple times the buy entry points and we see okay we initialize with five Tes so the first purchase is the actual price five T so we transfer five T back to the owner then the next time someone wants to buy then it became 5.5 T So 10% more and so we transfer 5.5 t to the new owner and finally if we try to purchase with the wrong amount so six t it's incorrect because now the price is 6.05 as we ver ify here so all good so the sad thing about this is that if you deploy this contract all you will get is those initial five tests if the price keep increasing and many people buy it and sell it it would end up being worth tens of thousands but as the initial creator of this great idea you will only get 5% wouldn't it be nice if you could get a percentage of every sale and therefore if your experiment Bec very successful then you would get a nice reward so what we want to do is create an nft that gives royalties to its author the idea is that every time the nft is sold we want the author of The nft to get 5% of the price of the sale and of course the 95% remaining should go to the owner of the nft so try to add this feature to your nft contract of course you will need to add an author in in the storage that is separate from the owner and when you will compute the shares that the owner and the author have you can use sp. spit tokens so pause the video and give it a try let's take a look at the solution here we added two fields in the storage the author and the percentage of each cell that the author should get then we modified or buy entry point to compute the share that the author should get so for that we use split tokens and we take the price and we compute the author rate so 5% and for the owner share we take whatever is left so the price that was just paid minus the share of the author it's important to do that rather than do another speed token maybe with 95% because there's always a risk that with some approximations and running Etc the total wouldn't be 100% in which case the sale couldn't happen because you try to send even a tiny bit more than 100% everything would fail so it's safe for the last person you send test to to send whatever is left after everything else has been added we'll talk about that a bit more in a minute then we send the owner share to the owner and the author share to the author finally we still have our formula to increase the price and then we update the owner you could wonder why we didn't send simply the balance to the last person for example to the owner after sending their share to the author but it's important to have in mind that when you send Tes using sp. send it's not actually directly sending the Tes to the owner it's adding a transaction to the list of transactions that will be executed after the end of our entry point so it's not executed immediately and it definitely doesn't change the balance the balance that you read in this entry point stays the same for the whole direction of the entry point but later on the transfer will be done to the owner and then the transfer will be done to the author or at least will be attempted again you need to be careful when splitting the balance if we did it this way it's a bit unusual but if we did it by subtracting to the price the share that the other person would get so here we do split tokens we take the price uh whatever is sent to the author as a percentage then 100 minus other R so we subtract 95% of the price from the price for to get what is sent to the author and here we do the same with the owner if we did it in this bit unusual way but when you look at the computation everything seems to be good you send the price minus 95% to the author and then you send the price minus 5% to the owner this should give 100% right but if you do that with some value of the price you would end up with running issues where this value is a tiny bit less than 95% therefore the Alor share is a tiny bit more than 4 or five% so it would be if the um rate is 4% I would be 4.1 and then the owner share would be 96 6.1 so the total would be 100.2 and therefore this would fail because there's not enough money in the balance of the contract you cannot send 100 point something per of the amount this would fail so again the best practice is for the last amount that you sent compute it as the total that you have so the balance of the contract for example the price minus whatever you send to the others this would avoid failures due to running issu that would get your contract completely stuck unfortunately there's still a flaw in our contract so if you look at this piece of code can you identify the flaw please pause the video and think about it so this is a flaw we already talked about the author could block any sale and the reason is that the author here could be the address of a smart contract that has a default entry point that they can switch to reject any payment so this transaction could be blocked by the author so the author would say nope the nft I created years ago I don't want it to be sold anymore or maybe they could try to use it to extort money from the current owner that really wants to sell it and needs the money so this could be dangerous so again the best practice is to let the author claim their share using a separate claim entry point that they can call you could say the owner can do this same and reject the the transfer but in this case it doesn't really matter here the whole point is that the owner wants to sell so if they refuse to sell well they just don't get their money this is not a big deal but for the author it's really important they shouldn't be able to block the sell so the way to do it is to remove this line so that we don't directly send the money to the author but we add an entry point claim author rate that the author can use to get whatever is left in the balance of the contract so we check that it's indeed the author and we send them the current balance of the contract so you may wonder if there could be a flaw if the author called this at the wrong time so for example when we buy we send the test to the balance of the contract then we check okay is the amount right we compute the share of the author Etc and then we send the owner but you could think in the meantime the balance contains all the money that is owed to the owner so couldn't the author call this right at the right time in the middle of this to steal the balance of the contract and the answer is no thankfully because the execution of an entry point is atomic nothing else can happen while this is running there is no race condition there's no parallel execution everything is serialized so this code and any transaction generated by the entry point will be completely finished before anyone can call any other entry point everything is serialized and done in sequence so you'll safe from that kind of issues in this module you will learn how to use records in smart p and will'll apply this to an example your first Dynamic nft a record is a data structure that allows you to group several values within a single object single value each of these values has its own name within the record and the different values may have different types for example you could create a record to store data about a person so you would have their first name that is a string their last name also a string and for example their age that would be a n we already manipulated records implicitly when we call called a smart contract with multiple parameters so when you call an entry point and you have to give the name of every parameter that was creating a record since in reality an entry point only takes one parameter so if you want to pass multiple ones you have to use uh record but now we'll work on explicit records to create a record you use the syntax sp. record and between parentheses the list of fields with the name equals the value and all separated with commas so here we have a record with a integer or natural named field one and then the string named field two once you have a variable that contains a record you can access any field simply by using the name of the record Dot and the name of the attribute so here if you create a record with two values X and Y we can extract the value of x by doing record. X when you need to describe the type of a record this is how you do it so you may notice that anytime we Define a type for example when we created a pair or an option we used square brackets after the name of the type uh the record is basically the exception to that for technical reasons related to how python works so in this case we use regular parenthesis so creating a record type looks very similar to creating a record value so we do sp. record and then between parenthesis the list of fields and this time the only difference is that instead of providing the value of each field we provide the type of each field so here field one equals sp. not and field 2 equals sp. string you may sometimes end up having to provide the type of a record multiple times within your code and it can become quite large if you have many fields in a record so to save your time you can name the type by creating what we call a type abbreviation that you would put outside of any contract within the main module so for that you would create a tie by giving the name you want to associate to it so here I wrote T record as the name for some example then colum and the keyword type equals and then the description of the type and then within your contract every time you needed to describe the type of your recard you can put this name instead let's work on an example and we will create a dynamic nft so usually an nft is associated with some static image or maybe some video or some music that you may actually want to store offchain and then you only store the hush in the metadata but for things like games you may want to have nfts that have different properties that evolve over time and with a set of rules on how they can evolve so we'll create this kind of nft and we will make our nft contract an nft of some creature that we would use in a game so we will give this creature two attributes a name and a size and we want to store both of them in the metadata field of our nft then we'll be able to add a feed entry point where we can pay one TZ and that will increase the size of the creature by one so we will increase this at distribute by one every time we call feed so let's look at the contract here in the Constructor we don't actually change anything because we still store whatever metadata is sent and we don't need to specify the type it will be specified directly in the taste case or inferred from other aspects of the contract for set price nothing changed buy nothing changed but now we add this new entry point feed where we check that the color paid one t and we simply change the size attribute of metadata and increase it by one so that's all we had to change in the contract itself and in the test that's where we initialized the storage with a metadata that is composed of a record so we create sp. record with an attribute name say let's call it beast and a size that we initialize at 10 so here here we used to just have a single value a string and now we provide a record and that's about it in our test we add this call to feed where we pay one TZ using Alice's account you may notice that anyone is allowed to feed the beast it doesn't have to be the owner so let's run it and we can see that now in the metadata we have this record presented using two columns one for the name one for the size and so we have the name Beast size 10 and we set the price and we fit it and when we check the details you can see that now the med contains a name that's Ste beast but then we crease the size to 11 records are actually not supported by the underlying mikon language there is no such thing as a record in mikon so what you do to create a record is to use nested pairs so as you remember pairs enable you to group two values with different types and so if you create a record with just two values then it's just simply a pair but if you create a record with three values then we need to use two pairs and the idea is that the first element of the pair would simply be the first of the three element but the second element of the pair would be another pair with the next two elements so like this so we have a pair that contains an regular element an integer and then another pair pair with two values in mikon we write it like this or a first pair with 42 and then the second element is a pair with 12 and three this way of organizing it is what we call the right C presentation so if we were to add another element we would again replace the last element of the inside pair and then replace it with another pair that contains three and then the next value we would like to add so if we keep adding it looks like that it just looks like a com with a handle and a different teeth it would be possible to represent a record in using a different approach and instead of always using the second element and replacing it with a new pair we could do the same but on the left side so take the first element of the pair and then replace it with its own pair we would still put the value in this order so if you Traverse the tree from left to right you would obtain all the different values so this would be what we call the left com representation both are perfectly valid and both are possible with mikin and it's really a matter of convention whether we use right comb or left com different languages actually may use different representations but if you want to be able to make two contracts compatible and make sure they understand each other you can specify what layout you want to use so if you want to use the righton approach after the creation of your record you can add dot layout out and then between parenthesis you describe the structure so here we have the first element of the pair and then another pair with the two elements the names of the two elements between double quotes on the other hand if you want to use the left C layout we would have to do dot layout and then the first pair with A and B comma name of the last element so sometimes you your contract has to interact with another contract that uses a specific layout that may be different for the default layout your language is producing so that's why you need that now it's your turn to work on an exercise let's change this uh Dynamic nft contract to add an extra attribute to the metadata we will call it strength and then we will add a train entry point that somebody can call but only once within a window of 24 hours you may never call it more than once within a given 24 hours window so with a strain and two point if the size is more than 10 it will reduce the size by one and then in exchange increase the strength by one so you train you lose a bit of weight but you gain some strength pause the video and give it a try let's look at a solution so in the constructure we still don't change anything to the metadata but we need to add an extra field in the storage to keep track of one is the last last time we trained our creature so we add this last training parameter we set it at a time St zero of course this is way in the past so we don't need to worry about how soon we're going to be able to train it again we don't need to use an option we don't change set price or buy or the feed entry point but we add this train entry point we check that the size is not too small for it to be trained so it should be at least 10 we check that it's been more than one day since the last time we trained it so we add one day to last training and we compare that to the current time and if we're not yet passed this then we output too soon then we Mark the last training at the current time and then we apply the changes we reduce the size by one and we increase the strength by one in our test we initialize the strength at zero and then we try different tests so we start by feeding the Beast to increase the size by one then we train it to increase the strength by one and reduce the size by 10 we fit it again to train it a different time and see if everything works it would be good here to add scenario at C1 do data do strength equals 2 then we try to train it it again but the size is still 10 let's verify that too so we're too small to train it so we need to feed it again then train it again and then we can verify that the strength is three and the size is back to 10 and we fit it one more time but we're trying to train it right away so it's 3 days plus 1 second and this should fail because it's too soon but if we wait a bit more then this should work and we can check that we had the strength at four and the size is back to 10 let's give it a try and here of course I forgot to put strength within the method record so I need to change that and add this here here here and there and it's all good so now we can check that we start with the name Beast size 10 strength zero and after we feed it the size increased after we train it the strength increased the size decreased we feed it again Etc then we try right too small too soon and at the end as we already check in the code the size is at 10 and the strength is back to four all good in this video you will learn how to use maps and big maps in the storage of your smart contracts and this will enable you to go from small smart contracts that only store a few informations uh single nft uh long single string to large scale smart contracts that can store whole databases of data many ffts and potentially the assets of millions of users a map is a data structure that store key value Pairs and the keys and values in a map can be of almost any type all the keys have to be of the same type and all the values have to be of the same type so for example we could store data about different countries we could create a map that stores the population of each country where the key would be the name of the country a string and the value would be the population of a country and that so for France you would have the population of France for the key Italy you would have the population of Italy Etc similarly you could create a map that stores multiple informations about each country where each entry would be a record so the key would still be a string but the value would be a record with not only the population but the size of the country and other information to create a map all you have to do is write a pair of curly brackets that that would create an empty map but you can also create a map that already has a few elements so you put the key column the value and then comma the next element you can put as many element as you want in the initial map separated with commas and every time the key column the value if you need to specify the type of your map you simply write sp. map and between square brackets two values separated by comma first type of the key comma the type of the value when you want to manipulate entries you use the name of your map and the value of the key between square brackets so to add or update an entry you write the name of your map and then between square brackets the key that you want to change and then you can assign a value to it if you want to delete an entry you simply write Dell and then the name of your map and between square brackets the value of the key that you want to delete from your map and more generally anytime you want to access any entry and value corresponding to a key you write the name of the map and between square brackets the value of the key if you want to check if a map contains a certain entry based on its key you can write my map dot contains then between parentheses the value of the key this will return true if the map contains an entry with this key and false otherwise with the map you you can also get information such as its size you can write sp. Len of your map and this will return the size of the map the number of entries in the map so for example if I have a map with two entries then if I call sp. Len of that map it would return to I can also request the list of items within my map and we'll talk about list later but basically if you call for given map do items it will turn a list where each element will be a record that contains two field a field key with the value of the key of that element and a field value with the value of the corresponding entry so this way we'll see that you can access all the elements of the map and look through them by numerating elements of the list if you only want a list of keys you can use dot keys and so for example if you do this map. Keys it will return a list of keys so one and two in the list similarly if you only want the values you use dot values and then will return a list that contains all the values before you start manipulating map there is something really important you have to have in mind and it concerns the costs and limitation associated with storing a lot of data between uses of a smart contract the storage of this contract is serialized so it is stored as a sequence of btes in a compact way and whenever you call the conract the sequence of bytes needs to be distalized to make it in the form that is convenient uh to manipulate so distalizing is taking this packed bite sequence and then converting it into a format that's really easy to use and manipulate that is typed Etc where we can efficiently access the data but once the entry point is over the new content of the storage has to to be serialized again until the next Call of the smart contract so convert it again to a simple squence of bites and this is done to save memory and make it possible to store this data on disk in an efficient manner but distalizing the storage at the beginning of every smart contract call and resizing it consumes CPU there's quite a few competition that you need to do to deserialize and resize so as the size of your storage gets bigger you increase the amount of CPU that you're using to call this smart contract and we cannot use an infinite amount of CPU for calling a smart contract uh we need every node to be able to run it so it has to be fast enough and there's only so much computation we can reasonably do to execute all of the transactions in a given block So to avoid abuse and transactions that take huge amount of CPU to be executed we have a system called Gaz that is an estimation of the amount of CPU needed to execute a given transaction like even smart contract calls for example we cannot know exactly how much CPU will be used because it really depends on what kind of computer you're running what kind of microprocessor Etc so this is why we need not the exact amount of CPU but some estimation that would be the amount of CPU that an average computer would spend to execute this uh transaction so for every operation every addition every cryptographic operation that we can run in a smart contract we have an estimation of how much CPU it will consume and so we have a corresponding gas cost of this operation so to limit the amount of computation that is done for a transaction and more generally for a block we use a financial incentive by having the color of this transaction pay for this spend Gap so as part of the fee they pay to the baker they pay for the amount of gas needed to execute the transaction and therefore they pay for the CPU they will be using on all the nodes and for each transaction there's an upper limit of how much gas we can spend and similarly for each block there's a limit on how much gas all of the transactions of the block can spend so these limitations mean that if the storage of your smart contract gets too big simply the fact that you need to deserialize and res serialize content before and after the execution of your smart contract means that you could reach this limit and the contract would fail so if you do a smart contract call and dis realizing all of the storage and resizing it costs more in terms of gas than the maximum amount of gas you can spend in one transaction then your call will fail and not be executed at all we already discussed the fact that most types have no limits in terms of how much you can store so we can store nuts and ins that are can be as large as you like time stamps can be as far in the future as you want strings don't have a specific length limits and similarly there is no hardcoded limit to how many entries you can store in a map but in practice there are two limits the first one is that every time you increase the storage so every time you add an entry to your map you have to pay for that extra storage and the second limit again is that if the storage gets too big the realizing and resizing it may exceed the gas limit so for these two reasons there's a limit to how many entries you can add in your map this limit will depend on how big the keys and values are and again if this happens to you your contract will be stuck any call will fail and any funds you have in the contract may be stuck forever to avoid the issue of exceeding the gas limits of a transaction due to having too much in your storage we can use a data structure that is similar to map and is called Big Maps big maaps are pretty much the same as Maps but with a few differences when your storage contains a big map instead of deserializing all of the content of the big map and resizing it at the end of your call we only deserialize and serialize individual entries in the big map that the contract call uses so instead of having to distalize the whole content of the big map you only distalize and resize the entries that you access to during your smart contract call so this removes the limitation of how much you can put in a big map as long as you only access a few entries within a single call of a smart contract there is no limit on how many entries you can have in your big map the syntax to use a big map is pretty much the same as the map except that you will use sp. big map instead of sp. map but many of the operations like getting the length of the big map getting the list of all the entries the keys the values are not available for big Maps so that means if you want to get any information about the content of a big map you have to know the key to the entries you cannot list all the keys you cannot enumerate them all you can say is is this key a available in my big map and what is the value for this key this limitation only applies on chain as everything is public on a blockchain outside of a smart contract you can request information about a map from a node and you can find out all of the entries in the a big map but on chain from within a smart contract you cannot list all the entries you can only request the entries that you already know the key so if we recap the syntax of a big map to create a big map instead of Simply a pair of curly brackets we have to use sp. big map so this will create an empty big map and if we want to have values then the syntax is the same for map curly brackets the different entries separated with comma and for each entry the key column and the value if we want to express the type of a big map we write sp. big map and between square brackets the type of the key comma the type of the value so very similar to map except we add big map here accessing deleting entries Etc is done exactly the same as for maps no difference but getting the size of the big map getting the list of entries the keys and values is simply not available because that would require dis realizing the whole big map which defeats the purpose of using big Maps let's take an example so far Our Endless wall was using a string to store all of the content so it was not really endless if the string got too long eventually it would be too big to be deserialized within a single call it would use too much G just to deserialize the content of our string so with a big map we can fix this instead of storing a long string we can store a big map of Records so in our big map the key would be for example the address of the sender so who is writing on on the wall and the value would be a record that contains the message a string and the date a time stamp so let's take a look at the contract we have this truly endless World contract and in storage we have a messages attribute that we initialize with an empty big map we then indicate what the type of this big map is by using sp. cast the attribute and then the type so SP big map and it between square brackets the type of the key an address so that would be the address of the user who sends the message and then the value a record that contains the content of the message a text or a string but also the date of the last message a time stamp in the right message entry point we have a text parameter so that's a message that the user wants to write we create a data that contains the record we would add if this is a new entry so with the content of the text and the current date but then we check if our big map already contains an entry for this sender then instead of using this new record we fetch the current data we have for the sender then we add the new text after a comma and we update the time stamp to the current time finally we write the data in the big map at the address of the sender so this will create a new entry if there is none and it will update the existing entry if there was already one now that this is necessary in both cases so even if we got the existing entry and modified it this wouldn't be sufficient to actually write the new entry to memory we always have to have this instruction to write back the data in the big map so we're not manipulating a reference to some data in the big map we have to explicitly write again and overwrite the content of this entry so we have this small test where we simply write a couple messages using Bob's address and so we can see that initially we have this empty big map then after the first call we have an entry for this key that's Bob's address and then we have this first message and sometime St zero and then after another call then we see that we updated the text with an extra message so here we have used a new syntax that we need to introduce the if and if lse syntax that's the typical python if and IFL syntax so you can write if this condition colon and then you have a block of code that you will execute only if this condition is true and if if you want to have an alternative piece of code you can write if the condition column and then the block indented block where you put a code to execute if the condition is true and then at the same indentation level as the if we can do else column and then we put here the code that we execute if the condition is not true we don't use a lot of conditional instructions in smart contracts so you won't see a lot of if and L's but once in a while it's necessary okay so now it's your turn to work on an exercise you will create a smart contract that is able to handle multiple nfps the approach we use so far to have one contract for each nft is really not ideal it can be unnecessarily costly to deploy one contract for each nft you want to Min and also makes it pretty hard to keep track of all the nfts so it's a lot better to have a smart contract that can store many nfts and for example a whole collection of nfts so pause the video and think about how you would do that and don't hesitate to start writing the code so if we want to handle multiple nfts we can store all of their content in a big map now that we know that we have to think okay what should be the key and what should be the value for this big map and so we have to think again about what an nft is it needs a unique identifier and it's an owner some metadata and a way to transfer or sell it and in this situation we will need to be able to create new nfts within our contract so we will need a mint entry point to create new nfts so if that helps you pause the video and try to continue working on your contract if we think more precisely about what we need to have in our storage we have to think about what we will use as a unique identifier for each nft this time the contract address won't be sufficient anymore it is still necessary so that you cannot simply write a separate contract with nfts that have the same ideas of all contract so the address of the contract will be part of the uniqueness of each nft but we will need something extra to differentiate between nfts that are stored in the same contract to do that we can simply assign each nft in our contract with a number so we can just start with one for the first nft two for the second Etc it's really that simple as long as these numbers are unique so we can store a nut that starts at one and every time we mint a new nft we increment it by one so this gives a number for each of our nft and we can use it as a key for the big map that will store all the information about our nfts again if that helps you please pause the video and continue to work on the code if not we can continue with some help so let's look at the code structure of this new smart contract in the storage we want to keep this counter this next idea that will will use as the value for the key for the next nft we want to make and everything else can be stored in a big map that stores all the information about the nfts we meant the key would be this token ID so the value of the cter that's with one for the first nft then two Etc and then in the value we have all of the data associated with this nft so we will have a record that contains the owner of this nft the current owner the original author of The nft as this is the type of nft where we still want to pay royalties and increase the price by 10% every time we sell it then we have the metadata and the current price then we need two entry points one entry point to Mint a new nft where we pass the Mt data so this will create a new entry in the tokens big map with as key the current value of next idea we can set the owner and the author to the address of the caller we can set metadata to the value of the parameters and to Mint and then we can initialize price to one test finally we need to increment next ID so that we have a new idea for the next token that will be minted then we need to buy entry point for someone to buy a given token and so this time we pass a parameter that is the number of the nft we want to purchase so it's token idea first we can check that is token exists in our big map then we can check that the amount sent by the buyer is equal to the token's price then we can send 5% of the price to the author then send the rest to the current owner finally we can replace owner with a new owner and then we can increase the price by 10% let's take a look at the contract in the storage we have this counter next idea that we initialized to one and then we have the tokens big map that we initialize with an empty big map you will notice that we don't add a cast instruction to specify what the type of the big map with the type of the key and the type of value we will use type inference and let it determine those types in the mint entry point we use cast to indicate what the type of the Met data is because all we do is stor it so there's no way in the contract to determine what its type is so we say this is going to be a string then we use the current value of next ID as a key to the new entry we put in our tokens big map and we store a record that will contain the metata a price initialized at one TZ the owner and the author that are the address of the sender finally we increment next ID to have it ready for the next nft in the buy entry point we need to take as parameter the token idea that we want to buy we check that there is such a token we fetch the data from the big map then we check that the amount sent was inde the current price we compute the fee that we have to send to the author we send everything but that fee to the current owner and then we send that feed to the author finally we update the address of the owner to this address and we compute the new price and that's it here we have a very basic test that only runs a call to each entry point and we can see the content of the storage so next idea is set to one we have this empty big map initially after the first mint we can see that in the tokens big map we have this entry with a key one the address of the author the metadata the owner and the price and then when we buy it we can see that the owner hasn't changed and the reason why the owner hasn't changed is that we have forgotten to rewrite the content of the token into the big map so it's very important here to add self. data. tokens of token idea equals token otherwise all these changes are simply ignored so if we run it again this time we can see that the owner goes from tz1 H4 to tz1 HJ so it hasn't been been bought by Bob and we can see that the price has changed of course it would be good to do a lot more tests to make sure that the contract is good but keep in mind that passing all the tests and as carefully as you can write your test doesn't mean that there's no bug in your contract and here in this contract we have a big flaw that you should be able to recognize that probably wouldn't have been noticed even by extensive tests pause the video take a look at the code and see if you can find the flaw and here the flaw is one that we have already mentioned before when when we have those two lines the author could be a contract that has a default entry point that fails and this would prevent the sale so the author of the contract could use this as a way to extort funds from the current owner now how can we fix this flaw pause the video and try to change the contract so that it doesn't have this flaw anymore one idea that you could have is that since the cause of the flaw is that all can be smart contracts we could try preventing people from minting their nfts through a contract so basically in the Min entry point you could say okay let's check if the sender is a regular user or a smart contract and there's multiple ways to do it like comparing the address of the user to the smallest possible address of a smart contract for example and other ways so it is possible in practice but I really don't recommend it and the reason is that you don't want to write smart contracts that can only be used by regular users and couldn't be used by other contracts you really want to be able to benefit from all the potential users of your contract and as a user it's really convenient to be able to call your contracts through some other contract could be a joint account like we presented earlier could be a multisig that multiple people can control collectively and the idea is that contracts should be bricks that can interact each other so if you limit the author of your nfts to regular users you will prevent many useful use cases so I really don't recommend differentiating between regular users and smart contracts even though it's possible and it would indeed prevent this issue there's a much better way to prevent the issue but this will required an extra big map pause the video think about it and try to implement this fix so the solution is to avoid sending test directly to the author in the buy entry point and instead as we have done before we let the author claim their own test through a claim entry point the difference here is that we need to keep track of many different authors and store how much each author is being owed by the contract so for that we will create a new big map in the contract that we will call Ledger and it will have a key the address of a user and the value will be the amount that the contract owes to that user and so whenever the user calls claim entry point we check this Ledger if there's an entry for them we just send them that amount and then we delete the entry let's take a look at the modified contract so here in the Constructor we add this new big map The Ledger the mint entry point doesn't need to be changed at all so it's only in the bu entry point instead of directly sending the author fee to the author we check if there's already an entry in The Ledger if not we create one with zero Tes so we don't owe anything yet to them then we add the fee to their entry in The Ledger and that's it that's all we need to change instead of sending test directly to the author we add an entry in The Ledger and then we add the claim entry point where we check if there's an entry for the color of this entry point in The Ledger big map not we just cause an error saying we don't owe any test to that user then we send the amount stored in ledger to the user and to say that we don't own anything anymore we simply delete the entry in The Ledger so if we run a simple test we M an nft somebody buys an nft and then the author can claim the test and they are being transfer their 5% of the cell all good so with this big Maps we can start creating really powerful contract that store data for all kinds of users in this module you will learn the basics of mikelson the lowlevel language that all high level languages on tesos layer one compiled to and and this will give you a deeper understanding of what happens behind the scenes when you execute a smart contract all of the tesos Slayer one smart contract languages generate mikon they make it easier for you to write smart contracts but the actual smart contracts that you execute are in the michelon language it's a lowlevel smart contract language that was designed specifically for tesos you can think of it as the Assembly Language for the tesos layer one blockchain as a lowlevel language it doesn't have any variables everything is based on the use of a stack but even though it's lowlevel it offers quite a few features in particular it has a static type system with a number of basic types such as int not TZ string Etc it has builtin data structures such as pairs lists Maps sets or big maps and it has an API for you to access to the tesos protocol such as cryptographic curves transactions Etc it benefits from a number of design choices that reduce the risk of bugs so as we said mikon is a stack language at any time it has access to a number of values organized like a stack of plates where each plate contains a value most of the melson instructions affect a number of values at the top of this stack there are some instructions that can reach beyond the top of the stack but they always express the location of the elements they read relative to the top of the stack so to give you a quick idea of how this stack works if you want to compute three plus 4 * 5 we write this piece of michelon code first we push elements on the stack so we push three at the top of the stack then four becomes the new top of the stack with three below it then we put five at the top so in the stack we have three then four then five then we execute the multiplication operation mu it will consume the top two elements four and five compute their product 20 and then put it at the top of the stock so after a mo we end up with three at the bottom of the stack and then 20 at the top of the stack then we can use the add instruction that will add those two values remove them from the stock and instead put the results so we get rid of 20 and three and we add 23 instead in the stack we'll see more examples of that the hardest is expect when you write mikelson code is to keep track of the content of the stack after in instruction and we will use commments and tools to help us with that let's take a look at a few instructions from the melon language we won't see them all in this module we will focus on the ones that manipulate the stack or allow you to do some arithmetic operations so that we can practice a little bit manipulating the stock the first instruction is an instruction to put something on the stack so we use the word push then the type for example int not t string Etc then the value so if you want to put the integer five at the top of the stack you write push in five next instruction is an instruction to duplicate whatever is at the top of the stack for example if you have three at the bottom of the stack and then five at the top of the stack and you call dub then you end up with three five and another five at the top of the stack the drop instruction simply gets rid of the top element of the stack so if we had three five5 we end up with three and five in the stack we say that it consumes the top element of the stack the Dig instruction is an instruction to move things around within the stack so you indicate a position related to the top of the stack and it will move that element to the top of the stack so if you have 553 and we do Dig Two it will take the third element from the top and bring it to the top so we end up with five at the bottom five in middle and then three at the top we took the three from the bottom we brought it back to the top the arithmetic operations consume elements from the top of the stack they remove them and then put the results back at the top so the add instruction takes the top two element in the stack consumes them so remove them from the stack and put the result back at the top of the stacks if we have let's say three five three then we take the three and five from the top add them to get eight and then we end up with three at the bottom and eight at the top for the product we use mole that takes the two elements consumes them puts a result of the mation at the top of the stack in mikas we have pairs so a pair is a value that contains two other values of any type and we use pairs a lot in meason so if you have a pair in your stock and you want to unpair them so that you get the two values as separate elements at different level of the stack then you can use unpair if you want to do the opposite take two elements and then pair them to replace them with a single element that contains them both as a pair you simply use the pair instruction finally you will see that even basic contracts will need to push an empty list of elements of a given type in the stack and for that we use the instruction nil and then we indicate the type that we want to put on the stack when you think about what a Merson contract does you really have to think about its input and its output because it's really all it does take some input and compute some output a melson contract starts with a stack that contains only a single value and this value is a pair that contains two elements the parameter of the contract that you pass when you call the contract and the current value of the storage so it can read those value and it also has access to some special values like the balance of the contract the address of the sender so whoever called the contract the timestamp of the blog that contains the current transaction this smart contract call belongs to and the amount that was sent by the caller to the contract Etc it can also access a table of Conant that all smart contracts have access to and finally it can obtain values from other smart contracts using onchain views but that's all it can read in particular cannot read the storage of other smart contract or any outside information can only read its own storage special values and then call onchain views from other contracts to obtain information from them and as the output the contract will produce a single element in the resulting stack and this single value will be a pair of two elements the first one will be a list of operations to execute after the execution of your smart contract your smart contract itself doesn't directly execute operations if your contract needs to transfer a few tests to an address what it will do is generate an operation and added to this list of operations that will be executed once its own execution is over the second value of the pair is the new value of the storage so you rewrite the whole new value of the storage that will replace the one you obtained at the beginning with an exception for the way we handle big Maps where you can write values individually so it's important to keep in mind that a smart contract doesn't have any effects other than Computing this pair and updating values in big Maps so let's take a look at an example this is a very basic smart contract in M that takes as a parameter a pair of integers A and B and all it will do is compute the expression 2 b + a and then put this value in the storage so here we can see the description of the type of the parameter so the parameter is a pair with two integers the first one we add anotation to say the it's named a and the second one is named B the storage only contains an integer we will put the result of the last computation in it and then we can see the code is put with the keyword code and then a pair of curly brackets and then we have the sequence of instructions one per line separated with semicolons so we start by unpairing the value that we have on the stack at the beginning so the storage and the parameter so then we have the parameter at the top of the stack and the storage at the bottom then we unpair the top of the stack so the parameter and we get a and b we use dig two to go get the storage back from the two levels below the top back to the top then we drop it we get rid of that element because we don't need the pr value of the storage we'll replace it with the result of the computation anyway then we call dig one that will get the B bring it to the top so we basically swap the top two El elements of the stack then we push the integer two at the top of the stack we'll multiply it with the second element so we do 2 * B and we get 2 B at the top of the stack we consume those two elements then we call add to add these two elements and replace them with a result so we get a single integer that's worth 2 b + a then since we need to end up with a list of reparation and the new value of the storage we need to create an empty list of operations so nail operation is an instruction that will generate this empty list of operations and then we pair them so that we end up with a pair that has this empty list of operations then the new value of the storage you will notice that we made a good use of the comments to keep track of what was in the stack at any time remember that the hardest part when you write code in mikon is to keep track of what's in the stack so in each comment we write what do we have on the stack after we execute this instruction so it's a good practice to put a commment for every line to describe what's in the stack after the execution of this instruction and then I recommend putting the bottom of the stack on the left and the top of the stack on the right this way when the bottom doesn't change we can see that it's exactly the same and the changes are always on the right so it's easy to just align the left so that the bottom of the stack doesn't move and only the top of the stack is changed for example between this instruction and this instruction we can clearly that the only change is to add two at the top of the stack if we use vs code with the melson extensions we can have a syntax highlighting but much better than that we can see that anytime we select an instruction on the right side the first extension will show us what is the current content of the stack and what it is before we execute this instruction and what what it is after we execute this instruction so we see can see that before we execute the first instruction we only have one element in the stack and it's a pair that contains the parameter itself a pair of two values A and B and the storage and we can see that after we execute and pair we have two values in the stack so at the bottom we have the storage and H and then at the top of the stack we have the parameter or pair a and if I click here here then again see that um before I have the two integers and the storage and after I execute drop I only have the two elements and that's it so it's very inconvenient to check that the type of what we have in stack at any moment is what we expect the second extension allows us to debug mikon code so I can click here to execute this code run and debug it will ask me the value of the contract parameter so here here this is a pair so I write it between curly brackets and for example I will write 1 for a and 10 for B so that's my input parameter then it asks me for the value of the storage of type in so I don't need the storage I'm not using it in this contract so I'll just keep it at zero then I can debug line by line and on the left side I will see the content of the stock so I can use this to run my code step by step so I can see that I will unpair this value that compet my parameter and the storage so I can see that at the bottom of the stack I have my storage zero and at the top I have my pair one and 10 we can see that the pair here is represented differently from the syntax I Ed for input for the input I used curly brackets with the sual in the between here it is represented using a pair of parentheses and then a comma in between so be careful not to mix up the two but they both represent the same pair if I unpair this top element in the stock 110 then I will get one at the top and then 10 and then zero at the bottom of the stock now I execute dig two so I get the second element from the top of the stack and then bring it back to the top so we see Zero is not at the top then I drop the top element of the stack then I do dig one so I get the the element at one position from the top bring it back to the top then I push the value two and I multiply the top two elements so I consume two and 10 multiply them to get 20 and then push 20 at the top of the stack then I add those two 20 + 1 I put 21 back on the stack then I generate this empty list of operations that we have here here it just chose it as a pair of square brackets but here we can see that it's indeed a list of operations and then finally I can pair them to get the end result so a pair containing a list of operations to execute after the smart contract and the new value to put in the storage of the smart contract and that's it so there's a couple things you need to be careful about when you write your smart contract um the first one is when you debug your smart contract if at one point you realize you want to make a change to your contract for example here you actually wanted to push three instead of two you should be careful because when you get to this instruction we will see that it actually pushed two on the stack because it's still running the previous version of the code the changes you make while you debug don't affect your current debugging session so that means anytime you want to make a change to your contract you need to make sure you stop debugging and then start debugging again otherwise it can be really confusing because what you see doesn't correspond to what code you have there and you can spend a lot of time trying to understand what's going on why why do I have this result it doesn't really correspond to what I wanted to do Etc and that's because you're not actually running the code you see so always make sure you stop it run it again and of course then when you execute it you can see that we indeed push three of course here we really wanted to push two another situation you can run into is when you for example add an extra instruction here you can see that everything is in red and it tells us that we have a type check error it doesn't really help us with anything it just says what we have at the end is not right it just not helping us that's because since I added an instruction what I end up at the end on my stack is of the wrong type I get two elements instead of one and that really confuses the type checking and it doesn't help us understand what's going on it just says type check error and if you don't remember that you just added this instruction it can be pretty hard to figure out what is wrong so there's a trick that you can use to do that which is to add a fail instruction at the end and this way the type checking always works because a contract that fails doesn't have to return anything in the stack it just fails and it's always of the right type this way you can check every instruction and see okay what do I have in my stack is that what I wanted Etc and then when you get here you can see oh actually have a one too many elements this doesn't correspond to what I have Etc so you can fix the bug and then once you're good you can remove this extra fail instruction so that's a good trick when you're confused and everything is red and you don't know what to do you'll notice that we put annotations here for each element that we have in the parameter and that's something you can do to help you better understand what's in the stack so here we can see that we have this information that this integer is actually a so basically this annotation was propagated all the way to this position but as soon as you do the computations what you end up doesn't have any annotation it doesn't tell you that this is actually 2B it just tells you it's it's an N so this can be helpful but very quickly you don't really benefit from it anymore so it's much better to use comments that really describe what we have on the stock one thing you may wonder is why do I need to learn meason I write just fine in my higher level language um and I can write smart contracts without knowing meason so why do I need to learn mikin we teach you a little bit of mikin because it can be quite useful in a few situations so for once deployed contracts that you can check with your block explorers are in meason so if you want to read a contract that has already been deployed and that you want to use you have to read the mikon code that's the only thing that's always available sometimes authors U make the original smart contract in the high level language available to you but not always so it's good to be able to read the contract another thing is that while you write your smart contract sometimes you want to make sure you understand what's really going on behind the scenes is it generating a lot of computation or is it something very simple even in a lowlevel language so it can be a good idea to once in a while look at the mikon code generated by your highle language compiler and understand what really happens behind the scenes another time where you will need to understand some mikon is that sometimes you can have compiler errors that are actually expressed in meason it's often type errors so it's important to have some basic idea of uh what mikon is to help you understand these errors more generally it's good to have a deep understanding of what's going on behind the scenes you don't need to be an expert in mikon but it's good to know the basics I advise you to take the habit of reading the mikelson version of contracts you write little by little you will get used to at least reading mikon code and understanding it's not too hard to understand again the hardest part is to keep track on what's in the stack after each instruction as an exercise you will write your own melon smart contract that does some arithmetics so write a contract that takes a pair of integers A and B as a parameter just like we did in our example but then this time computes a * 2 b + 3 a and again puts the result back in the storage pause the video and give it a try let's take a look at the solution so here we have our contract that takes a and b as a parameter with the storage of type int so we start by unpairing our storage and parameter and pairing our two values A and B then we get rid of the storage because we won't need it then this time we will need to duplicate a because in our final expression a * 2 b + 3 a we need a twice so we duplicate a so that we can make use of it twice that's something we often need to do in a stack based language so now we want to compute two B so we dig twos to obtain B at the top of the stack then we push the value two and we multiply them to obtain 2 B now we want to compute 3 a so we dig one to get a a back to the top we push three we multiply them to get 3 a at the top of the stack then we want to compute this expression 2 b + 3 a so we add those two values to get 2 b + 3 a at the top of the stack then all we have left to compute the final expression is to multiply a with this value 2 + 3 a so we have our result here but now we need to add an empty list of operations on the stack so we call nil operation at this empty list of operation we see here that we have indeed a list of operations in the stack and then the new valuable storage we pair them and we get the results in the stack we can give it a try we can use one for a 10 for B zero for the storage and so we compute let's compute a few things so let's see here after doing the addition we still have a = 1 at the bottom then we have 2 B so that's 20 plus 3 a that's three so we get 23 at the top of the stack then we multiply that by a so by one and we get 23 and we compute we have the empty list and 23 if I run it again but this time with two and 10 then I can execute it so I should get 3 * 2 so that's 6 + 20 * 2 so that's 26 * 2 52 which is correct all good in this module you will learn how to install Smart py in your own environment which is what we recommend when you start creating contracts for your real projects the installation procedure of smartp is very straightforward forward all you need is Python 3 and pip which is the tool to install modules for Python 3 there's one exception if you use a Mac and have an Intel processor you will also need to install Docker we'll refer you to the corresponding documentation of these tools to install them if you want to find the latest installation procedure you can go to smart py. I and in the manual in the installation section you will find the commands the version we will use for this demo is a version that's not officially released yet but that you can find here so if you go to the coresponding website you can go in the manual installation and here you find the installation procedure where you have one command that you should run and that's all you need to install Smart Pie as long as you have the prerequisite python pip and maybe Docker for our demo we will do this in the gpen environment prepared and you can try it yourself in the same environment if you don't want to install it on your own computer so we'll create a new workspace with this environment where we don't have anything specific to smartp installed yet so you may need to create a gitp pod. iio account using your gitlab or GitHub authentication if you don't already have a gitpod account then it asks you to create a new workspace which we will do it may take a couple minutes make sure you have the tab open in your your browser with the focus so that it doesn't take too long so once your git pod environment is running I'll Zoom a little bit but all you do is go copy the common line provided in the smart P manual so we copy this line you paste it here it may ask you if you authorize pasting content on git pod so of course you need to authorize and then you simply execute this command it downloads everything needed and everything is ready now you create a folder so will test or endless wall contract so I'll create a endless W folder and I'll open the uh vs code editor where I will put my contract file but you can use any editor you like your contract file should have the py extension and I will paste the count of our contract once you've done that all you need to do is run python contract. py I forgot to save contrl s run it again well good and we see here that created is a test folder with a lot of files so we'll go through them to understand what just happened so all you need to do to run a contract and it's scenarios is simply to run Python and then your contract and this will produce a folder for each of the test scenarios you have in your contract and in each folder you will have a number of files you would have the main file which is log.txt that will contain all of the steps of the execution and you will have files for each contract or Reg ation with the content of the contract in mson the content of the initial storage and you will also have files for each call to an entry point we can see here with the names those are files for the contract for the initial storage the type of the storage and parameter Etc and then for each step we have the files for the parameters of the entry point calls so if we look more precisely at the content of the log.txt file it will contain sections for every step of the execution of your scenario you will have the contract origination with the initial storage of your contract and you will have an entry for each call to an entry point with the parameter and the resulting new value of the storage you will also find the comments produced by calls to the scenario. H1 Etc and you will also see lines for calls to scenario. verify where it will show what conditioning checked and what the result is the output of calls to sp. trace that you use for debugging are not visible in log.txt but they are directly displayed in your terminal as the error output so here we can see the content of some sp. Trace that we added here so we can see that it's displayed directly in the terminal and then if we open the log.txt file we can see the origination of the contract so our contract simply contains a big map so here we can see the initial content of the big map it's empty then it will list all the different files with the storage the types and the contract so for the storage we can see the content either expressed in smart Pi or in mikon or the Michelin version so the Jon version of mikon here we can see the types of the storage the parameter private and Views directly smart p and you can see the contract itself either in the Michelin Json representation or directly in melon as a TZ file so you can see what the melon code that you generate looks like and you can see that after every instruction it shows the content of the stack after the execution of this instruction with the top element of the stack on the left so for example here after impairing the content we have the parameter in the storage and after running now we have now at the top of the stack for each section you can see the corresponding smart pie code so you can follow what part of the code corresponds to what part of your smart pie code that can be quite useful if you want to understand what your code really generates on chain so to recap for each contractor origination you will have the files with the initial storage in different formats the file containing the different types in the smart P format and files with a compile me contract both in the TZ and Json format then for each smart contract that you call some files will be produced they will contain the content of the parameter both in the TZ Jon and smart P formats so we can take a look here for a call we can see that the call had one parameter that was a string with Bob's message here we simply have the string and same here in the meason format so we can see here in the log. XT we originate the contract we see the corresponding initial value of the storage here we can see the output of a call to scenario. H1 here we can see that we call WR message with the parameter and we can see here the new value of the storage so the content of the big map with the key here which is Bob's address and then the corresponding entry then we make another call so we can see that the content of the storage change for the key that is Bob's address and then finally when we make a call to send a message as Alice we see that we have another key in the big map with Alice message and finally you can see here when we verify so if we check our contract here we have a verification that the Tim stamp for Bob's message is zero because we didn't specify any other Tim stamp in log. TT file we can see this verification with the corresponding condition and the result so this is everything you need there to check that everything goes well and to look in detail what happened during the execution of your scenario and remember that for each scenario you will have a similar folder so you can organize your test very nicely okay now it's your turn to give it a try and run smart P locally so what you should do is simply reproduce the demo but you with your own smart contract so you install Smart py in your own environment you execute your own smart contract uh you can take the one from the previous excise make sure you include contract calls verifications comments and calls to trace to see what happens in each case and if you have trouble for some reason to install Smart p in your own environment on your own machine you can test all this using or gitpod environment at this address so pause the video and give it a try in this module we will talk about DS decentralized applications and what it means to develop your own DS adap is an application that is built on top of one or more smart contracts it stands for decentralized application but it is a regular application with or without a user interface that may interact with smart contracts but also a wallet one or more nodes indexers decentralized file systems like ipfs and sometimes a regular back end but you have to be careful in spite of their name decentralized applications only the smart contract part of adap is always decentralized the interaction with different tools are made available through libraries and depending on the type of front end or back end you use you may use different libraries on tesos we usually use takito for web based daps we may also use py tesos for python based daps or we can use the unity SDK for tesos for DS that can work on the web desktop and mobile using the same code base and that is particularly useful for games that you develop using the unity SDK and there are more such libraries for other languages and pl platforms there are also tools like Factory or cleum that can help you by analyzing contracts and generating bindings and make it easier to develop and debug your DS the main capabilities of these libraries are the same but they run on different platforms and with different ease of use a key aspect of DS is their interaction with wallets the role of the wallet is to allow DBS to interact with smart contracts while providing security for the end user it keeps the private keys of the end user safe and it gives them the opportunity to check the transactions before those transactions are sent by the DAP to the node so the D interacts with the wallet at different steps first it uses the wallet for the user to authenticate on the DB then it uses the wallet to simulate transactions and check how much the felds will be the fees to pay to the Baker and the amounts to burn for the storage then the wallet is used to sign and emit the transactions send them to the blockchain but it can also be used to sign other types of messages or to verify signatures from other users we use a standard protocol Bon to interact between deps and wallets so that you don't have to write code specific to each wallet in your DBS and connection between the DBS and wallet can be done either through a QR code or through dip link DBS can also communicate with nodes either through the wallet or or directly they do so to obtain information about a given blog for example its level its timestamp the transactions it contains Etc they can read the balance of an account or a smart contract directly from a node or they can read the storage of a smart contract and they can also execute views and obtain other kinds of data these interactions are done through RPC calls directly to the nodes all of the data is available through the nodes but only block by block and it's not very convenient to access the data this way so to make it easier we use what we call indexers the role of indexers is to fetch data from the node blog by block as the blocks arrive and then make it easily available to the deps so you have apis to find accounts contracts and operations based on many different types of criteria and you can also obtain aggregated or sorted data and more generally you can access data in more digestible format in particular for standardized tokens and the access to data is much faster than you if you try to access directly through a node a good way to get an idea of what is available through an indexer is to look at block explorers because behind each block Explorer such as Bal Dev TZ KT or TZ stats there is a corresponding indexer that stores all that data and makes it easily available so typically the work of an indexer is to keep track of new blocks fetch all of the data store that data in a relational database with indexes to allow for good access performance and then reply to simple or complex queries through a rest API there are a number of public indexers that are available for tesos such as TZ KT or TZ stats but you can also install your own local copy of these indexers but keep in mind they use significant resources because they have to index all of the data from the blockchain a more lightweight approach consists in using selective or custom indexers that only inexs the data you really need for utap there are tools like DP dap or dzer that make it easy for you to create your own selective or custom indexer blockchains and in particular layer ones are not good for storing data in large quantities because every single node on the blockchain stores everything so the St storage on the layer one is expensive in practice when possible we only store a hash of the data in the smart contract we only store the data itself in the smart contract if the smart contract needs to directly interact with the data but even though you don't store all of the data in the contract itself it's important to make sure that the data is available in a decentralized manner so decentralized file systems play this role of storing this data and make it available to everyone everyone ipfs is currently the most used such decentralized file system it stands for interplanetary file system it consists of a protocol for organizing and transferring data through a peertopeer Network an ipfs also represents a number of implementations of this protocol and a decentralized network based on this protocol on ipfs or any similar tool any file is identified by its hash that has multiple advantages because it guarantees that the content has not been tempered with you can check that it matches the hash and even if at some point the content is lost by your system if some content is not available on ipfs anymore anyone can add it back and it's identified by the sash as long as the content matches is hush then you can add it back and you have to be careful because nodes of ipfs are free to decide what data they store just because you put some data on ipfs at some point doesn't mean it stays there for dri so it doesn't guarantee that availability if you want to make sure some content stays available you can use spinning services that take care of that for a to recap adap is an application that is built on top of one or more smart contracts and you have to see it as a regular application that may or may not have a user interface and that may interact with smart contracts with a wallet with a node with indexers with decentralized file systems like lpfs and maybe with a regular back end so again be very careful in spite of the name only the smart contract part of a DB is always decentralized the front end of a Dap is often hosted on a centralized server and the deps often interact with a centralized indexer they also interact with a specific node or a specific set of nodes and they often have a centralized backend so when that's the case only the smart contract part gets the benefits of decentralization furthermore many smart contracts depend on the third bodyy to make some calls so you have to keep in mind that the technology makes decentralization possible but it doesn't require it so it's possible to write AAP and smart contracts that are not fully decentralized so many of the benefits of blockchains can be lost if you don't apply them correctly you can take the example of what happened with f PX for example and see what could go wrong but you also have to keep in mind that to attract users you need to make it easy for them so the hard part is to benefit from all of the aspect of decentralization while still making it easy for users to use one of the barriers of Entry op ups for your final users is that to call any smart contract they need to pay fees and in order to pay fee that means you have to buy TZ which implies doing a K1 YC know your customer prove your identity Etc even if it's a very small fee so this is a barrier for many users when starting to use your product your D so to make it easier one possibil is for you to pay for your users fees users can set up a wallet but don't go through the kyc or obtain TZ and that means instead of signing and paying the fees for a transaction they can use their wallet to sign a message that will allow a transaction but then they send this message to your server and your server receives this message and calls a contract that will then receive the message and do the corresponding transaction so this way the users give their authorization by using their wallet to sign the message but you're the one paying the fee on your server so that's a method that you can use to make it easier for your users to start using your D and there's a standard on tesos on how to do that called tzip 17 one issue that can come up when you do D and in particular when you use Fess transactions comes from the fact that each transaction has to include a counter to avoid replace but that means from a given address you can only emit one transaction with one value of the counter per block but some services including in the case of Fess transactions require sending many transactions per block so to solve this issue we have a system of batches of transaction actions a batch of transaction can contain one or more transactions from the same account and either all of the transactions in the batch are included and are successful or they all fail and issue is that the bigger your batch is the higher the risk that the batch and all of its transactions will be rejected so to manage your chances you will have to split your transactions into several batches that you emit from multiple addresses for a given block so that's one of the things things that you may need to take into consideration When developing Advanced apps and in particular if you use Fess transactions so that give you an overview of the kind of issues you have to deal with When developing daps in this module you will learn how to make inter contract calls and this will open many interesting possibilities the possibility for a contract to call another contract really expands the potential of smart contracts you can create Market Place contracts that interact with nftd contracts or Dow decentralized autonomous organization contracts that allow people to collectively own and trade assets through the interaction of the Dow contract with other contracts you can also build the centralized Finance contract that build on top of one another with Landing contracts that allow you to invest in yield forming contracts Etc or you could create game contracts that interact with dynamic nfts there's really a lot you can build thanks to the possibility of contracts interacting with each other but all this potential also opens up many potential flaws and risk associated with interc contract calls for example if you're not careful it would be possible to trigger a contract on behalf of a user without them realizing that that contract is called in their name and interc contract calls can in some cases give attackers access to potentially Unlimited funds for their attx so when dealing with interc contract calls it's important to be very careful about what you're doing and we'll show some of examples of that the syntax of inter contract calls is pretty straightforward if you have the address of a contract you can use these two instructions to call an entry point of this contract so first you get a contract object by doing sp. contract and then you have to pass three values you pass the parameter type of the entry point you want to call then the address of the contract that has this entry point and finally the name of the entry point and this returns an option on the contract because there may not be an entry point for the contract this address with this parameter type so since it's an option if you know for sure that you press the right argument you can unwrap the option using unwrap sum and store the result in this contract variable once you have this contract variable you can do the contract call by using sp. transfer because calling contract is also transferring some test to a contract then you pass the value of the parameter for the entry point it should have the type that you provided here you indicate how many Tes you want to send as you call this entry point and you pass the object that you just obtained with the previous instruction and this will create a transaction to call the entry point with this name from the contract at this address and with this value as a parameter setting along this amount of Tes this transaction is cued in the list of transactions that you execute at the end of the execution of your current entry point it is never called immediately to test several contracts that interact each other in your test you start by creating instances of your contract in the usual Way by calling the constructure of each contract then you simply have to pass the address of one of the contracts to the other contract for example in an entry point call or it could also be in one of the Constructor parameters so this make the contract address available for the entry point to run these commands let's take an example with contracts that can interact with other contracts we could create a contract that serves as an intermediate between the user and another contract and this adds a lot of new possibilities on how existing contracts can be used so for example if a contract has an owner you could use an intermediate contract to change it to two owners so if we take the case of an nft we can create an nft joint account contract so that two people can jointly own the same nft so let's see how this would work so we have this nft for sell contract that represents a single nft that can be bought and sold in its storage we have the current owner we have its metadata and we have its current price then we have our two entry points one to buy this nft at the current price and one for the owner to set a new price for the nft and so the idea is that we can create this nft joint account that will become the owner of one or more such nfts and then we will have two owners for this contract that will be jointly the owner of this contract and therefore both control the associated nfts and here since it's a joint account each owner has full power on the contract so either one of them can either buy nfts set the prices Etc so for this contract to be able to buy and sell nfts through this um nft for sell contract we need the following entry points the first one will be to buy an nft and so for that we say which nft we want what's the address of the contract corresponding to the nft we want to buy and this entry point will call the buy entry point of the corresponding n Fe and then the contract will become the new owner for that nft once it owns that nft either of the owner could call set nft price again indicating which nft contract this will be and then passing the new price and this entry point will in turn call the set price entry point of that NFD contract finally once someone buys the nft the funds will be sent back to the owner of the nft for sale so it will be sent to the default entry point of our nft joint account contract so we need to make sure we have a default entry point that accepts TZ otherwise we would never be able to sell those nfts so if we look at our contract in more detail so we have those two owners that are both addresses in our buy nft entry point we first check that the caller is either owner one or owner two then we simply call nft address. bu with the amount that was sent to by nft so sp. amount next he set nft price entry point checks again that the color is either owner one or owner two and then simply calls the set price entry point of the nft contract with the new price finally if the default entry point is called we do nothing we simply accept the test let's take a look at the contract so here in the same file we can have our nft for sale contract and our new nft join account contract so the nft for sale contract is one of the versions we used in the past that has a basic set price entry point that checks if the caller is the owner and then updates the price and then the buy entry point check that the amount sent is the right amount sends it to the owner and then changes the owner so now we have this nft join account contract that simply stores the two owners and in the buy nft entry point we get the address of the nft contract that we want to interact with so keep in mind that this joint account could own many different contracts using many different addresses so every time we want to interact with one of these nft contracts we just pass the address but first we check that the caller is either owner one or owner two and then we execute those two instructions I was showing before so we get the buy entry point of this address since the bu entry point doesn't take any parameter we have to say that the type of the parameter is nothing and nothing can be pressed by the type unit so we use sp. unit as the type when we have no parameter at all and since it's an option we need to unwrap it we store it in this variable then we can call transfer we pass the value of the parameter so when we have no value to pass the value for nothing for the type unit is expressed as a pair of parentheses with nothing in it so that means sending no parameter in a when but we need to put something here so we have to put this pair of parenthesis that represents the unit value which means sending nothing then we pass the amount so since we just buy the nft we just forward whatever amount was sent by the caller so one of the two owners to this entry point and we just pass it along to the buy entry point of our nft contract and then we pass the contract object that we got from the previous line and that's it this simply calls the buy entry point of the contract at this address very similarly for the set nft price entry point we check if if it's the owner one or owner two then we obtain the corresponding contract using the same thing the main difference is that this time the name of the entry point is set price and this time we have a parameter the new price that is of type newest so we indicate this new price here and again we unra the option then we call sp. transfer we pass the value of the parameter so the new price that we got from this parameter this time we don't pay so we send zero Tes to the set price entry point and the contract is what we obtained from the previous instruction when we test this contract here we instantiate the two contracts so one for the nft one for the joint account we add them both to the scenario so that they can be both originated within the scenario then we call the set price entry point to set an initial price for this nft so that we can buy it at that price then with the second contract with our joint account we call by nft and we give the address of the nft contract we say okay Bob who is one of the two owners of that join account is calling the buy nft entry point and sending seven TZ to buy this nft the nft with this address that we just created then we can try to change the price from the nft directly so this won't work only the contract is allowed to change the price and here we see that we try to use this join account again called by Eve so Eve is one of the two owners of the joint account and we try to buy it at 7 T but this doesn't work and the reason why this doesn't work is because we didn't add our default entry point yet so if we want this to work and turn this to a true we need to add the default entry point so that when somebody even us buy the nft again then we can receive the money so we can add the default entry point that doesn't do anything but pass and now if we run it then this time it works so we basically bought the nfg from ourselves not very exciting but this can only work if we have the default entry point then we call the set nft price to change the price to 50 TZ so we can see here and the new price has been set to 50 test here if we show the contract we see here the new price and here we verify that the need the new price has been set to 50 St and and that the address is in the address of the contract so not a lot of test but this illustrates the different calls we can make and how we can have a joint account contract that can interact with an nft contract unfortunately this join account contract has a big flaw can you find it and fix it take a good look at the contract and see if you can identify the flaw and find a way to fix it pause the video and give it a try so the issue here is a situation that can be pretty sad once you realize what the flaw is these two users who are the owners of that joint account could jointly buy and sell many nfts for many years accumulate funds by selling nfts selling them later for a higher price and accumulating money on their joint account but there's one small issue the day they decide to retire and get the test out of the contract is the day they realize that they forgot to add a way to get the funds out so it's very important to always remember to add an entry point to claim any profits if the contract is meant to accumulate funds make sure you have this way to get the funds out otherwise all the funds you may accumulate all the time by the service your contract is providing uh will be lost and will be stuck in the contract for forever so the solution of course would simply be to add this claim entry point that either owner one and orer two can call the idea here is that you have two addresses that you can use to the same thing it could be two people that trust each other or the same person that has two different keys and one that's a safe key in case they lose the first one for example and after checking who is calling all the entry point we have to do is send the balance of the contract to the caller so it's very easy to fix the problem is to make sure you don't forget to have this entry point in your smart contract there's been real situations where people accumulated significant money and had no way to get them out but now let's imagine you actually did this and you deployed this contract without the claim entry point so you cannot change the contract itself once it's deployed right it is immutable so the question is can you find a way that you could still get your funds out of this contract I mean imagine that you have millions of TZ stuck in this contract so you really have to try hard and see if there's any way that you can get those funds out pause the video and think about it so again assuming that you have millions of Tes stuck in this contract how can you get them out there's actually one way to change the contract once it's deployed at least in theory can you tell what that way it would be pause the video and take a minute to think about it so this theoretical solution is that on tesos anything is possible thanks to unchain governance all you have to do to get your funds out is to propose a new Amendment to the tesos protocol and you can make any changes you like in amendments so you could propose an amendment that changes your contract so that you can get the test out but the next step would be much harder The Next Step would be to convince the community to vote for your new Amendment and Save You by letting you change your contract so in theory it is possible in practice unfortunately for you this is extremely unlikely to succeed that's because the whole point of a blockchain and of our smart contracts is that you should be able to trust that it won't be changed that it's what is written in the contract is what will happen so it would be really hard to convince the community to go against this principle just so that you can get your Tes out that got stuck there because of your own negligence but really you have millions of STS tuxed in your contract isn't there a way to get them out so you can't change the contract you can't convince the community to let you change the contract and add a claim entry point but you still have access to those existing entry points the buy nft entry point the set nft price entry point and the default entry point and that's all you have to work with calling those entry points is the only way you can interact with your smart contracts so using just this can you figure out a way to get your TZ out of your contract pause the video and think about it for a while imagine that there is millions of stake okay so all we can do with our contract is buy and sell nfts but we could use that to our advantage we could use the TZ in our balance to buy one or more nfts at their market price using our jointed account so those should be nfts that are easy to buy and sell and that have a clearly identifyed market value so that you know that if you buy them at the marketplace you will be able to sell them at a similar price then you change their price to a very low price close to zero and then right after that you buy them with another account let's say a regular account at this very low price and now that you own it and control it you can sell them with your regular account to a buyer at the market price or maybe a bit less than what you paid for and by doing that you got your money out or most of them this sounds good right there's only one small problem if you do this you could actually lose everything can you figure out how pause the video and think about it for a minute so the problem is that if you can do do it someone else can too after you bought the nft with the joint account and changed their price to a very low price so that you can buy it at this very low price with another account someone else could buy it too and could buy it before you do anyone can buy it at this very low price so if anyone or even a bot notices that there is this nft that has a very high value but somehow got a price set to a very low price then there is a good chance that somebody will notice that and immediately buy it then sell it to a buyer at the market price and profit instead of you so there's a risk that you will lose everything and someone else will make the profit thankfully there's a way that we can prevent this the idea here is that between the time that you change the price to a very low price and the time that you buy it with another account you would like to make sure that no one else can do anything and buy it before you do and you can do this using batches of transactions the idea is that on tsos a given user can submit a batch of transactions so it's a sequence of transactions from the same user and that will be executed automically that means right after another without anything being able to happen in between and either nothing happens of the whole sequence of transaction happens with nothing in between so by creating a batch of transaction from the same user so that has to be one of the two people who own the joint account will call the joint account to change the price of the nft then with the same account they will buy that nft at that very low price and now we know for sure that no one can buy it before we do and we manage to get our Millions out of the nft contract we were pretty lucky because this approach worked in this specific case but in many cases they would be no such approach so we get lucky but it may not be the same next time let's look at some other interesting situation that can happen with interc contract calls suppose you are the owner of an nft that has an automatically increasing price and royalties that you worked on before and let's assume that you got smart and bought this nft through a contract that can contemporarily prevent Sal so it has a default entry point with a switch that you can turn on or off to allow prevent sales and you pause the sale so you own the nft at some price the price has increased by 10% since then and then you pause the sales by making sure no one can buy it because the account that owns it will reject the money and prevent the sale now let's say that enough time has passed and for some reason you know that somebody is ready to pay a very high price to acquire this nft somehow it got really famous and someone is really eager to acquire it unfortunately for you the price is already set so if you unlock the sale well that then person is likely to buy it at that price so the question is how could you bypass the increasing price rule so that you can sell this nft that someone really really wants to buy and is ready to pay a high price for it so how can you bypass this increasing price Rule and sell your nft for more and take advantage of the fact that somebody is willing to pay a very high price for it pause the video and think about it for a minute one easy way for you to do that is to increase the price by selling it to yourself and and increasing the price by 10% and you keep doing that until you reach the Target price that you really think you're able to sell it for so every time you sell it to yourself whatever you pay is sent back to you the only issue is that the 5% of royalties fees will go to the author for every sale it's still a good way to increase the price so that you can get the most out of your nft you can use a batch of transaction to make sure that nobody else buys it between the time that you unlock the sale and the time that you buy it now knowing that this is possible and you're the auor author of this automatically increasing price contract you would like to make sure people don't do that and cheat and go around your rule of the price automatically increasing by exactly 10% so if you're the author of the smart contract how can you change the smart contract before you deploy it and prevent users from bypassing this rule pause the video and think about it one idea that wouldn't really work would be to add a rule in your buy entry point to make sure that the current owner of an nft cannot buy the nft from themselves so basically in the buy contract you could check that the caller sp. sender is not the owner otherwise you reject the sale and this wouldn't work because it's very easy for the owner to use a second address to buy the nft so they could go back and forth between two addresses increase the price until that value and since there's no way to know if two addresses are the same person there's really no way to fully enforce this increasing price Rule and preventing the same person from buying a contract again and again to increase the price and you really have to keep in mind when you see nfts that seem to be bought and sold at very high price this may make it look like those nft are really worth a lot but it could be that it's actually the same person buying it and selling it it's just money changing from one address to another but owned by the same person so it doesn't cost anything to sell and buy an N at a very high price if you're selling and buying it from yourself so that's a good way to inflate the apparent price of an nftd so you should be very careful about that so now let's think about a more interesting question what if you want to sell it for Less how could you bypass the increasing price rule so that you can sell your nft for Less let's say it went to a ridiculous price nobody wants to buy it anymore you really want to get rid of it and sell it for less than its automated price and the value of the price in the storage of your contract is really computed by the ENT Point bu and there's no way to change it in any other way all it can do it be increased by 10% when you buy the nft so how could you bypass this buy entry point and sell the nft at a lower price pause the video and think about it one solution could be to not sell the nft itself but sell the address that owns the nft so for example you could sell the private key of the account that owns the nft to someone else and then they would be in control of that nft this is a very dangerous idea especially for the person buying your private key the reason is that there is really no trustless way to automatically verify that a private key has been transferred so we have this issue of who goes first do I send you the private key first or do you send me the Tes first who pay for it so you cannot use the blockchain to do this kind of things safely but most of all there's no way to prevent the original owner of the private key to sell their private key multiple times when you sell a private key then two people I'll have this private key and basically it's like a joint account that both people control so it's not safe at all to buy someone's private key it just doesn't work but this could give you an idea for another approach that relies on inter contract calls can you figure out how pause the video and think about it so the idea is that although you cannot sell the address of a regular account so the private key of the regular account you can sell a smart contract and a contract can own an nft so instead of buying the nft with a regular account and then trying to sell that account you can simply buy it with a new smart contract and then sell that smart contract so we can custom build a smart contract so that it can purchase or sell nfts and also be purchased and sold itself and the rules for selling and purchasing this contract that will own the nft are completely independent of the rules that set the price of the nft itself so in a way we are wrapping the nft into another new contract that we can buy and sell and since this contract owns the nft it's really like selling the nft itself except that it's wrapped into this other contract so we can call this contract nft wrapper and the idea is that whoever owns the nft rapper contract that owns or nft effectively owns the nft through this contract but owning our nft through this nft raer contract will really allow us to go go around any restrictions not only on the price but also on the royalties when you sell that new rapper contract you don't have to pay royalties to the original author because you're not even using the buy entry point of the nft you simply using the buy entry point of the wrapper to change the owner of the wrapper let's look at how this contract would work in the storage we would have three values one we need to be able to say if we allow or disallow sales of the nft it owns so those will simply be a Boolean that we set to True when we allow sales on nft and false otherwise then we need to store the price of the wer and the current owner of the wrapper now we have a number of entry points so we can use this rer to buy nfts and this will simply call the buy entry point of the nft contract with that address so this is just about okay let's have this wrapper buy an nft then we can set the price for our wrapper so when we call it we check that the caller is the actual owner of the wrapper and then we replace price with a new price in the storage we can have this buy entry point for anyone to buy or wrapper we check that the amount it transferred is equal to the price of a rapper we send that price to the current owner and then we replace the owner with a caller so we simply sell this rapper like we sold an nft before now we have this entry point to set the value of this allow sales Boolean all it does is check that the caller is the owner of the rapper and then replace allw sales with a new value and the point of that is that we find have this default entry point that can control whether the owned nfts so the nft that this rapper owns can be sold or not and if allow sales is true then the default entry point will accept any test that is sent to them and not doing anything but if we set aw sales to fals then the default entry point will fail whenever someone tries to buy one of the nfts its owned because that's part of that buy entry point it's sending says to its owner so to the rapper and if the default entry point says Nope sales are not allowed then it will fail and the nft cannot be sold so we can control whether the nft we own can be sold or not we can buy nfts and then we have the entry points for people to buy and sell the rapper itself so your exercise is to implement this nft wrapper so you will have two contracts one is the nft for sale cont contract you have used previously and the second contract will be this nft wrapper contract with this structure so pause the video and give it a try so let's look at the solution here we have a old NFD for sale contract that has an owner metadata and a price or basic nft we have the set price entry point that checks that it's the owner that is calling and then updates the price and finally the buy entry point where we check that whoever is trying to buy sends the right price then we send that amount to the current owner and we change the owner now let's look at the wrapper contract so we have this allo sales Boolean that we initialize when calling the Constructor we have a price and we have the owner of this repper contract we can call the buy and nft entry point to have this rapper buy one or more nfts so we give it the address of the contract that we want to buy we check that the caller is indeed the owner of the rapper contract then we fet a contract for the buy entry point associated with that address again there's no parameter so we put sp. unit as a type and then we call the entry point with no parameter so two parentheses for the unit value and we send the amount that we got so that we can purchase the corresponding nft now we can have the entry points to buy and sell the wrapper itself so the owner can call set price to set a price for the rapper we check that it is indeed the owner that called this and then we update the price for the NF wrapper then we have the buy entry point so we check that whatever amount was sent is the price of the wrapper we send that price back to the owner of the wrapper and then we change the owner very similar to what we do in the nft itself it's just the two entry points we need to buy and cell or contract then we have the set allow cell entry point that simply let the owner of the rapper contract change the value of allo sales and finally we have this default entry point that will fail if our sales is false we don't really need to write that here but if all sales is false then it will fail and then prevent anyone from buying any of the nfts that this contract owns so here we have a test so we create instances of the two contracts initially we said that the sales are allowed we add both contracts to our scenario we set the initial price of the nft to 7 TZ then we have the rapper contract by this uh C1 nft and Bob is the owner of that nft rapper contract so Bob can say buy this C1 nft cont contract through my rapper contract and pay 7 T now we can verify that indeed the owner of this contract is the second contract the rapper contract Bob canot say I don't want to allow anyone to buy the NT I just bought through my wrapper Bob can then set the price of the wrapper itself to 50 TZ and then even though the current price of the nft itself s is at seven we cannot buy it for seven T because buying it would try to send the seven Tes to the reper contract the reper contract has allow sales at false so its default entry point will reject the TZ sent to it and therefore reject the sale but on the other hand someone like Dan can buy or rapper contract at 50 TZ and then take control not only of the repper contract but also of the nfts that this repper contract owns So with this idea of a repper you can see that although it is possible to have all kinds of rules such as paying royalties to the order or having rules on how the price can involve smart contracts are also very powerful and through inter contract calls we can go around certain Rules by wrapping contracts into other contracts and this IDE IDE of wrapping nfts and tokens in general is also one of the ways that we can transfer nfts across blockchain in this module you will learn how to use lists and enumerate elements of lists using Loops you may be surprised that it comes so late as in general programming Loops is one of the first things you learn but in smart contracts we actually try to avoid using loops and lists and we'll talk about why a list is an ordered collection of values of the same type or we could say sequence of values of the same type if you want to create an empty list just like in Python you put two square brackets and if you want to create a list with already some elements you put the elements between the two square brackets separated by commas to describe the type of a list we write sp. list and between square brackets the type of the elements in the list so contrary to python list for example we cannot access any particular element in the list using an index or insert element in the middle or at the end all we can do is add an element at the beginning and for that we can use sp. conson the new element we want to add at the beginning and then a list and this returns a new list that contains all the elements that we already had plus the new element at the beginning of the list and finally you can obtain the length of a list using the Len function the main thing we typically do in a smart contract with lists is Loop over the elements of this list do something with each element so for example if we want to add up all the values in our list of numbers we can initialize a variable total to zero and then we write a loop similarly to how we would write it in Python so four the name we want to give to the variable that will contain each element during each iteration of the loop in and then the list so for the variable in and the list column and then indented the operations we want to do using this variable to access the current value so here we Loop through all the elements and then we add each one to the total to compute the sum if you want to repeat something three times or have a variable that goes from 3 to six for example you can create a list using the range function and if you give it one parameter it will simply create a list with elements that go from zero to that value minus one so with range of three you get zero one and two if you give two values you get all the values between this element and then this element minus one so range of 3 to 7 gives 3 4 5 6 and you can add a step to say that you jump 2 by two so this would be three then five and then It Stop So this way you can create a loop with a variable that takes every value between two values and potentially with a step let's work on an example we want to change our nft joint account contract so that we can purchase multiple nfts at once this can be a good idea because instead of having to call one transaction every time we want to purchase one nft if we have many nfts to purchase it can reduce gas fees to purchase multiple nfts in a single transaction because each transaction involves signature verification Etc so it involves extra gas costs and the calization and serialization of the storage of the contract you Call Etc so if you can do several in one call then you can save some gas fees and therefore some money so let's take a look at the code here we have our usual nft for sale contract where we store one nft with an owner the metadata and the price and we have a set price and a buy entry point but in our nft join account here instead of having code to buy a single nft we pass a list of nfts to buy and then with this list we can do a loop to Loop through every nft in this list so nft will contain the current element in the list and then we call as we did before the Buy entry point of our nft contract by passing the amount stored in nft so here the idea is that we pass a list of Records where each record contains an address so the address of the nft contract that contains it and the price the amount that we are willing to pay for when you call byy nfts you have to send the total amount that you will spend buying all these nfts and then in the list you indicate the address of each nft you want to buy and then how much you're willing to pay for it and that's it in the test we call here joint account buy nfts and we passed a list of records with here two records one with the first nft we minted here and then amount of seven T and then another one with the second nft with the amount of five T which are the current prices of those nfts after we initialize them at five T and then change the price of the second one to 7 T so let's give it a try we can see that we originate the two nfts then we originate the joint account we set the price to seven t for one of the nfts and then we called buy nfts and here you can see that the argument is a list where each element is a record with the address and the amount so we buy the nft at this address for seven T and the nft at this address for five T and we can see that there were two calls to the buy entry point so one to buy the first nft at 7 T and then we can see that the transfer of the 7 t to the original owner has been done and here the second purchase now it's your turn to practice on an exercise so the goal here will be to change this nft joint account contract so that this time both owners have to agree before they buy nfts in a way this becomes a multi where multiple people have to sign on an operation to happen but this one will be a very specialized one that can only be used to buy nfts and your goal will be to change the buy nfts entry point so that the process works as follows so first one of the two owners of the jointed account can propose a list of nfts to buy by calling buy nfts the first time with a list of nfts to buy and the corresponding price and so during the first call we don't purchase anything we simply store that list for the nfts to actually be purchased the other owner of the joint account contract then has to call by nfts again this time with their own list and then what happens is that the nfts that are listed in both lists the one we stored during the first call by the first owner and the one just provided by the new owner we take the nfts that are in both lists and if they are listed with the same number of tests the same amount then the contract buys them and any nft listed by the second owner that had not been bought should be left in the stored list list so that the first owner can then in turn send another list and maybe confirm some of those proposed nfts to buy if the same owner calls buy nfts twice in a row we consider that this overrides any previous list they have sent so at any time we only store the list proposed by the last caller and whenever one of the owner calls byy nfts and the stored list is from the other owner then we check the intersection between the list is sent and the list that is stored check if the prices are the same and when they are we buy the corresponding nfts so pause the video and give it a try let's look at the solution so we don't change the nft for sale contract but we will change the nft joint account and add in the storage two values the list proposed by the last caller in initialized to an empty list and the address of the owner who proposed this list so whoever called byy n FTS last then we Chang the buy nfts entry point we still check that it's only one of the owners calling it if the caller is the same person who called it last so if the owner is the last proposer or if we start with an empty list then we simply store the list that this caller is proposing and that's it if it's the other owner who's calling it then this time we will compute intersection with the currently stored list so there's different ways to do that but we don't have a lot to work with if we simply use lists I mean at the moment pretty much anything you can do with a list is Loop through all the elements so if we simply use that we would have to Loop through all the elements of the new list and for each of them try to search for the same nft in the stored list so we have to look through all the elements in the stored list and see okay if the current element in the stored list is the same address as the current element in the new list with the same amount then we buy this contract otherwise we add it to a new list that we create that will be replacing the old list in the storage of the contract and then we remember that the last color is the sender so this would work but this is a very slow if we have let's say 10 nfts in each list then for each of those 10 nfts in the first list we would have to Loop through 10 nfts in the new list so we basically have N squared iteration of this element so this can get pretty expensive pretty quickly because of all the computation we have to do to compare the two lists so we can do a lot faster than that but to do that we have to use another data structure that you already have learned about oh here we have a bug you forgot to store the proposer so this should be stored whatever happens so the indentation here was incorrect pause the video and think about it for a minute so to take advantage of a map we will take the proposed list and put all of its element in a map where the key is the address of the nft and the value is the amount so this is assuming that uh the same nft address is not listed twice in our list that's a rule we can set for the users of the contract we just say you're not allowed to try to buy the same nft at two different prices in the same list so assuming that will will have one entry for each nft in this map and then when we Loop through the new list of nfts all we have to do is check if it's in the map using the contains instruction with the address as a key then check if the amount for that nft is the one we have in the new list if yes we buy it if not we add it to our new list of remaining nfts so this makes it a lot faster faster to find intersection between the two lists but it's still not the approach I would recommend cuz although this code is less than 20 lines it's still a bit more complicated than necessary so the idea is that we want to avoid doing any unnecessary computation within a smart contract if it can be done off chain and here there's really no need for the smart contract to handle the negotiation between the two owners to find a way to determine which nfts they both agreed to buy they could have this negotiation completely offchain through a d when it's just two people there's really no need for anything in between them for them to agree on which nfts they want to buy the role of the smart contract here is simply to make sure that they do agree before the purchase actually happens and so the way we do that is that we have a first owner could be either one of the two call byy nfts with a list that they allegedly came up with as a list that they both want to buy and so we store that list and we store the address of the owner who proposed that list and then all we have to do is have the other owner called and approve nfts to say yes I agree with the current list that's fine with me so we check that they're indeed one of the owner they're not the proposer it's not the same person agreeing with themselves and then we Loop through all the nfts in the list and simply buy them so that simplifies our contract by quite a bit and so there less risk of bugs but actually in this specific implementation there's a potential flaw that would make it possible for one of the owners to cheat can you figure out how pause the video and think about it for a minute so the way that one owner here could cheat would be to detect when the other owner is calling the approve nft entry point and right before that moment in the same blog potentially but making sure their transaction is accepted first they would call buy nfts again with a new list so basically they would switch the list of nfts right before the person approves it and after they send the transaction so it's too late for them to notice that the list has changed and they're not approving the list they thought they would buy so we need some way when the user calls approve nfts we need a way to make sure that they are approving the list that is currently stored and not a previous list that they have checked before so how would you do that pause the video and think about it for a minute so there's several ways that we could do it one way would be be to ask the caller to send the whole list again and then we compare the two lists and and compare every element and check if they're all the same but that would be a bit more code we could think about Computing the hash of that list and storing it and then we would have the other users send the hash of the list they approve of and a hash is guaranteed in practice to correspond to the same data it's impossible to create another list at the last moment that would have the same hash so this would be safe enough but Computing a hash is a little bit expensive so it's maybe not the cheapest way to do it all we need to do is to have a unique value associated with that list and it doesn't have to be the hash it could be a counter so we could have some counter that uh we increment every time someone makes a new proposal and then when we approve you send the value of that counter so that would be one way to do it so we could do here set to one and then here we increment it and here we check we pass counter and we check the approved counter is is equal to the stored counter so this way we know that by nfts hasn't been called at the last minute before we call approved nfts and if it has been called then the approved counter wouldn't match the current counter so that's a good way to protect against the other user trying to switch the list at the very last moment so making the codes simple is a good way to avoid bugs but it doesn't guarantee that there's no Buon you should always think about ways that someone could cheat it's just easier to think about it if the code is simpler so as I said in introduction we actually try to avoid using lists and Loops in smart contracts when we can that's because using lists in a contract can be dangerous can you figure out why pause the video and think about it for a minute so there's two reasons why lists can be dangerous as we discussed before serializing and deserializing the storage cost gas and so if you have a list in your contract this can increase the cost of calling your contract in some cases it could increase it so much that your contract could get stuck it wouldn't be possible anymore to distalize and resize the current content of the list so you should be very careful about having a list in your storage that people can fill arbitrarily up to the point where it's not possible to dis realize it anymore the second related reason why list can be dangerous is that simply looping through their elements cause gas and as the number of iteration increases the cost increase and similarly your contract can get stuck just because you have to Loop through a very long list and perform some computation on every item so it's important to remember only to use lists if you know that their size is bounded if it's simply a list that you pass as a parameter it's up to the caller to decide the length of the list that passes a parameter there's not much risk of course you're going to pay more if your list is longer but it's really up to you when you do the call to reduce the number of elements of your list if you want to pay less or if you want to make sure that the gas cost doesn't exceed the limit of how much you can spend in a single transaction but if it's a list that you store in your storage then that's when it becomes dangerous and you should be really careful and make sure that the length of the list cannot increase indefinitely so now the question is if we shouldn't use list and we can't use list in the storage with a length that could increase indefinitely what would be the alternative if you feel that you need a list that type of data structure so an ordered sequence of elements of the same type what could you use instead of a list pause the video and think about it for a minute the alternative when you want to store for a lot of data with no limits on how much data you can have is always the big map because that's the only data structure that is not limited by the gas costs and if you pick the right key you can use a big map to emulate all kinds of data structures so for a list the idea is to use a counter to indicate the position in the list so you could store two fields in your storage let's say field elements that's your big map and then a value that counts the number of elements in your big map that starts at zero and if you want to add an element all you have to do is write your value with a key being the current value of NB elements and then you increment NB Elements by one then you can create a loop that just Loops from zero to NB elements minus one so that you can iterate through all the elements in the big map but if you Loop through all the elements in the big map This Way well again if the size of the big map gets too much and you could get stuck again let's say you want to compute the sum of all the elements but there's too many elements to Loop through in a single transaction without exceeding the gas limit then you have the same problem so how would you solve that pause the view and think about it for a minute one way to avoid the very long loops and avoid Loops that cannot go through in a single contract call is to Simply use multiple contract calls you could split the loop into multiple calls that maybe do only 100 iterations in one call so you could keep in your storage where you're at in this big loop so you could have a loop counter in the storage and then you have this continue sum entry point where you pass how many iterations you want to go through at the most and then you Loop through them you increase your counter for every iteration you do and if you didn't exceed the number of elements in your big map then you add the corresponding value to your sum so this could be one way that you can make sure that no matter what you will be able to Loop through all the elements in your big map and compute the sum this could end up being expensive this if there's millions of elements but you will be able to do that if you're ready to pay the price but for this specific example of computing the sum we can do much better can you find out how pause the video and think about it so the idea is that instead of looping to compute the sum when we need this sum it's a lot better to maintain the sum as we add elements all we did to the list is ADD elements to it and maybe we could have a way to remove element from them but as long as we don't do anything more complicated we can maintain the sum as we modify this data structure so we add this sum elements variable in our storage and then every time we add an element we simply add the value to some elements this way when we need the sum we just have to read it in the storage so this is pretty basic and pretty easy to do but it's something to really keep in mind because that's something we use a lot and this works if you want to compute the sum if you want to compute the smallest element in a list or the maximum element in a list or even the average value in your list but a lot of times just like we did a bit earlier this other approaches to reduce the gas consumption that really mostly consist in doing work off chain that's really the best way to avoid paying too much gas is to do as much as the computation as possible off chain in this video you will learn a new way that contract can interact with each other and that will make it even easier to build projects composed of multiple contracts that interact with each other and this new way is what we call views more precisely onchain views but we'll just say views to keep it short and it's a mechanism that allow contract calls that are really meant for one contract to obtain information about another contract and Views are readon so when you call a view of another contract that view cannot modify the storage of that contract and cannot emit its own operations so that means it doesn't have any side effect so by calling that view you not have any effect on this contract all you can do is obtain some information from that contract there can be some computation to obtain that information but there won't be any side effect other than returning the data from that smart contract when you call a view you can pass arguments as input that will be used by the view in addition to the content of the contract storage of that view and uh the view may call other views from other contracts again with no side effects no modification of their storage or no emitted operations calling a view in itself is not an operation all it does is return a result as an output and unlike contract calls or transfers of Tes they are executed immediately they are synchronous so as soon as you call it the view is called in the other contract the C of that view in the contract is immediately executed and the result is immediately available to the caller contract that's very different from inter contract calls that we have seen before where an inter contract call is really a new transaction that you add to a queue but here with views there's no new transactions you immediately execute the code and obtain the result so let's take a look at how we create and call an onchain view creating an onchain view is very similar to creating an entry point we use a different decorator sp. onchain view to indicate that that this is a view then it's like a method that takes one or more parameters just like entry points we can have any kind of computation within the entry point except for modifying the storage and creating new transactions and then the other difference with an entry point is that it returns a value with a keyword return to call a view within an entry point you write sp. View and then between parenthesis and number of values the name of the view so that's the name you gave to the method in your contract then you provide the contract address so the address of the contract that contains this view then you provide the value of the parameter so it could be a single value like here it could be a record it could be anything and then you provide the address of the return type so here we are returning the address of the owner of a token so we pass the token and we say the return type is an address what you will get is then an option on a value from this type so you have to unwrap it to obtain the actual address let's work on an example there was an issue with our nft join account contract which was that if when you pass a list of items you want to buy and a corresponding price a corresponding amount for each nft if one of the nfts in your list list has a price that has changed since you built your list then the purchase of that nft will fail but not only that since one call Will Fail then your whole contract will fail and none of the nfts will be bought so that can be a bit frustrating So to avoid that we will use views by simply checking the price of an nft the current price of an nft right before we try to buy it if it's the wrong price then we'll just skip it and avoid having the whole transaction being cancelled so in our basic nft for sale contract we will add an onchain view get price that only does one thing which is to return the current price of the nft so we just return that value and this way in our join account contract here when we are trying to buy a given n we use the get price view we pass the address of the contract our parameter here is of type unit there's no parameter so we put a pair of parenthesis and what we get is a price so the return type will be mutes and we unwrap the option that we get into a variable price then we can check if the price is the amount we expected to pay then we do the transaction and here we know for sure that this trans transaction will succeed because the price cannot change between the time that we call this contract and the time that the buy code is run so that makes it really convenient and it's easy enough to use so that before we actually do a transaction with another contract we can check information about that contract to make sure we do something that will not fail if we combine interc contract calls and views we can split complicated contracts into simpler contracts which is something really recommend it has several advantages but most of all it makes contract simple for example if we keep the topic of nfts we can split two key roles between two contracts we would have one contract that only takes care of storing the nfts with their IDE their metadata their owner we would call that a ledger contract that just keeps track of Who Wants What nft and we could have a separate contract that will handle all the trading of nfts we would call that a Marketplace contract if the Ledger contract can allow the marketplace contract to change the owner of nfts then we can use this pair of contracts to have people trade nfts and we will keep each of the contracts pretty simple and it will also make it possible to reuse contracts and com combine them with new contracts for example a new type of marketplace or a new type of nft let's look at the structure of The Ledger contract so we would need to store and admin that's who is allowed to change the owner of the contracts that will be our Marketplace contract then we have our usual next token idea to keep track of the idea for the next token we will mint then we have our token speak map that will store all information so we use the token ID as a key and then for each token we store the address of the owner and the metad dator then we have three pretty basic entry points first the mint entry point where we pass metadata and we will simply create a new entry in the tokens big map with the next token ID as a key the caller as the owner and the past metadata as the metadata then we increment the next token ID then we have an entry point to change the owner of a given token so we pass the ID of the token and the new owner we check that the caller is the admin so the admin is allowed to do anything we trust this admin we trust the marketplace because we have read the code before we do that and then we simply change the owner within the tokens to the new owner and for the marketplace to be able to interact with the Ledger it will need to be able to find out who's the current owner of a given token so we have an unchain view get owner that Tex this parameter a token ID and then will simply return who is the owner of that token now let's look at the nft marketplace contract the goal is simply for owners of nfts to be able to put them for sale at a a given price and then buyers will be able to buy them so here we will store all the offers in a big map for the key we will use a composed key a pair of two values the address of the nft contract so in which contract is our nft we can have a Marketplace that can handle multiple collections of nfts in multiple contracts within the collection we need to know the token ID so a given offer has a key that is the description of which nft it is through the address of the contract and the token ID within this contract and then for the value we simply have the price at which the seller is willing to sell this nft then we need three entry points one entry point for the owner of nft to create an offer so again we say what's the contract that stores this nft what's the token idea within this contract and at what price we want to sell it using the get owner view of the nft contract we will check that the caller is indeed the owner of this nft and if it is then we'll add an entry to the offer is big map we give a chance for the owner to cancel their offer so they indicate what what's the nft address and what's the token idea we check that the caller is the owner of the nft again using the view and we simply remove that entry from offers and finally when a buyer wants to buy rft they indicate which contract which token idea so basically they indicate which one they provide the key to the entry in the offers big map so using that we check that the amount they send as they call the buy entry point matches the price stored in the big map we transfer that amount to the current owner that we obtain again using the get owner view of the nft contract and finally we change the owner by calling the change owner entry point of that contract and so we pass them the address of the new owner that is the call and when we're done we remove the entry from the offers big map so your job now using this description is to implement these two contracts so you implement The Ledger then the marketplace and you create the corresponding test to make sure everything works pause the video and give it a try so let's take a look at the solution we will start with the ledger so for The Ledger we store the admin that will be the address of the marketplace contract we create a tokens big map that will store the content of The Ledger all of our tokens their price and owners then we have this counter next to token idea that we initialize at one in the mint entry point we obtain the metadata as a parameter we indicate that this Matera is a string there's no other way to find out by just checking the contract so type inference won't work so we say this is a string then we add an entry to the tokens big map using as a key the next token idea and the value is a record that contains the owner so whoever is calling this entry point and the materal data and of course we increment next token idea so that next person Ms with a different idea then we have this onchain view get owner that takes as parameter the token ID and that simply Returns the owner of that token finally the change owner entry point takes the token ID as parameter and the address of the new owner we check that the caller is the admin of this nft contract so that would be the marketplace and then we assign the new owner to this to toen so that makes it a pretty basic contract pretty easy to proof read and check now let's see how we can create the marketplace contract that interacts with it it's very simple as well we have a storage that only contains this big map with the offers we have an entry point new offer where we indicate which contract and which token idea we are selling at what price then we call our view get owner from from the nft contract we pass the token ID and the return value is the address of the owner so we provide that type and then we unwrap the option to obtain the owner so here of course the idea was to check that it's the owner calling so we have to add assert owner is sp sender and once we've checked that then we create the entry in the offers big map with a key that is a pair containing the address of the nft contract and the token idea and the value is simply the price that we are willing to sell this nftg for then we simply have a buy entry point for any buyer to try to buy this nft tesas parameter again the description of which nft it is through the contract and the token ID within this contract so we first check what's the price of the corresponding offer and if there is no such offer this will fail so the contract will fail so there's no need to check that the offer exists we simply try to read from it and it will fall if it doesn't exist then we check that the amount sent was indeed the price so if this is the case we will change the owner of the nft by calling the change owner entry point of the contract so we use those usual two instructions obtaining the contract object we pass has the type of the parameter the address of the contract and the name of the entry point for the type of the parameter here we have used uh type definition here where we say okay this is a record that contains a token ID an integer and the new owner an address this is a good habit when you do inter contract calls it's a good idea to have the type defined as a type abbreviation at the beginning of your code so now that we have the contract we prepare the parameter so a record with the token ID and the new owner so caller sp. cender and then we call the contract so here it's not going to do a call right away we are simply adding a transaction to the queue that will call this contract with this parameter and sending zero test but we know for sure that if this fail everything will be cancelled so here one thing we didn't do is send the amount to the previous owner so for that we'll need to obtain the address of the previous owner so we can just copy that code and then we can send to the owner the amount also creating a transaction that will send this amount to the owner and at the end and we need to make sure we delete the offer to make sure someone doesn't buy it again right away and immediately take it from this buyer so here we have a very basic test that doesn't check much but shows the two calls we have here created two different ledgers to show that we can have the same Marketplace interact with multiple nfts and when we create each of these Ledger we pass as the admin of The nft Ledger the address of the marketplace that we have created here then we Mint one nft in each then we create an offer in the first Ledger for the token ID one so this NFD that we have minted here we say we want to sell it for Tes and it's Alice selling it so she's the owner of that nft then someone else can buy the nft by NE getting okay I want to buy a token from this contract with this token idea and it's Bob buying it and he's paying those 10 so we can run it and we can see the origination of the marketplace then the two ledgers then we have the minting of those two nfts then offer is being made and stored in a big map of offers and then we have this uh purchase it sends the test to the previous owner and then calls change owner so we see that here the calls to the Views are not shown they're not individual transactions so they're not visible but they have definitely worked to check who to send the test to for example one thing to know about onchain views is that although they are called onchain views they can also be used offchain so this means from adap for example or from any offchain software you can execute this view to obtain some information about a given smart contract so if you want to know the current owner of an nft for a given nft contract you can do an RPC call so remote procedure call to the node to say hey I want to execute this view to obtain information about this smart contract and then you will get the result at different libraries like takito make it easier to do that and this can be very useful if you want to standardize option read access to contract so if you want to know who is the owner of an nft of course you could directly access to the Mig map you have access to everything from of chain but if you want a standard way to find out and work with all kinds of nft contracts that maybe store their owners in different ways if they follow the contract they should all have this um onchain view that Returns the owner of a given token idea and so the same code will be able able to interact with all different contracts through this standardized view so this means we can write a standard on how to obtain the owner of a contract without having to specify how the owner of an nft is stored and very often those views are usedful both onchain and offchain one of the reasons they are called onchain views is that there are other types of views that we have been using in the past and are still using in some cases on tesos there is the term offchain views or that we call metadata views so those used to be melon code that you could call from offchain to obtain information about a smart contract but with nothing executed on chain so it's basically the old way to do the offchain use of the views that we just described and there's a standard that describes it called tzip 16 it is still part of some wellused standards like aa2 that we'll talk about later there was another type of views that we were using before onchain views were created and this was called Lambda views it was also a standard um defined as called tzip 4 and it was not a feature but more of a pattern on how to implement your own views using a system of call backs so it was using inter contract calls but passing a call back to the contract you were calling to say hey compute this information and then when you're done send it to this call back so it served the same purpose onchain as our onchain views but was a lot less convenient to use and so this new onchain view concept is basically replacing both those old ways to do views but again they are still in use for legacy reasons in existing standards but for your new contracts onchain views are really the way to go and make it really convenient in this module we will talk about custom types a piece of syntax that will save you a lot of time when you use interc contract calls or onchain views you often have to specify the type of the parameter and the type of the return value and those types can be a bit long here we present a short example of a typical type that we may pass as a parameter where we specify a destination address a token ID an amount and to match the specifications of Standards we have have to specify the corresponding layout putting this whole piece of code every time you have to specify the type or calling a smart contract that uses this kind of parameter is very inconvenient and if you make changes to the type then you have to make sure you change it everywhere but more generally it makes the code hard to read and hard to maintain So to avoid this and make it things easier we can give a name to a type directly in the main module here for this type Ty we declare the name transaction type we say it's a custom type by putting a column then the keyword type then equals and then the description of the type from then on we can use this name everywhere we need to provide this type so be very careful this only works if you put it in the module itself you cannot Define a custom type within a smart contract for example so typically you would have all your custom types at the beginning of your module as an exercise create a joint account contract with a deadline so you take the existing joint account contract and change it so that they can purchase nfts where prices have a deadline that means to buy the nft at that price you have until that date and after that date the price is not valid anymore while you work on this exercise the whole point is for you to use a custom type to avoid having to put the full type every time you call the smart contract for this exercise there probably will be only one call but the point is to practice grading custom types pause the video and give it a try let's take a look at the solution so here we will need a type record that takes the new price and the deadline so that we call the entry point to update the price we give both the price and the deadline so we create a custom type for this that we Define at the beginning of our main module then when we we call the contract here instead of doing sp. contract and then describing the whole record type in detail we simply put entry pointcore type the name of our custom type and we can give it a try and it works all good in this video we will talk about the set data structure and we will work on the membership contract that can be used to define which users are allowed to access specific features of a smart contract a set is an unordered collection of values of the same type it's a bit similar to a list except in a list the same value can be present multiple times and we worry about the order of values but in a set all we care about is whether a value is or is not in the set you can do three main operations in the set very efficiently you can add an element to the set you can remove an element from a set and you can check if a given element is or is not in the set and those three can be done pretty efficiently because internally the values are stored in a balance tree sorted by value the syntax to use sets is pretty straightforward you can create a set in two ways using sp. set for empty set or you can provide the list of values in the set between curly brackets if you want to specify the type of a set you write sp. set and between square brackets the type of the values then you can do the three operations adding an element with add a your value you can remove an element with remove and the value and you can check if the set contains an element by calling your set do contains of the value and will return true or false depending on whether your set contains it you can obtain the number of elements in the set using Len and then you can obtain the list of elements sorted by values by calling your set. elements so let's work on an exercise where we will create a membership contract it can be quite useful to have a contract dedicated to storing a set of members we can use it to restrict access to features of a smart contract based on some conditions that's what we call allow listing so the list of users that allowed to do something and we can use it to create artificial scarcity for example if an nft can only be bought by members of a club then that makes this nft a bit more exclusive which can increase its value we can also use a membership contract to create a community for example da a decentralized autonomous organization where we store the members in a membership contract and it's often a good idea to separate this data into a dedicated contract that focuses on membership and then this list of members can be reused in other contracts not just this initial contract contct that we meant it for okay so your job for this exercise is to think about how you would Implement such a membership contract and we want to make it exclusive so the idea is that we only want rich people to be able to join this contract or this elite club we don't want them to pay a fee to join but we want them to prove that they do have access let's say to 10,000 T so if you don't have access to 10,000 T you you are not allowed to join this exclusive club we also want to restrict the size of this club to 100 people and of course we want members to be able to leave this community if they want to your contract will need to have an onchain view so that any contract can check if a user is a member of this club or not pause the video and think about what you would store in this contract and what the entry points would be and would do so it's a pretty simple contract in a storage we can store the threshold how much you need to show that you have to be able to join the club we will of course store members the set of addresses that are members of this club and we can store the maximum size that we want the club to have of course those two values could also be hardcoded but here we decided to make them values in the storage then you have three entry point or two entry points and one on chain view the main entry point is the join entry point for someone to join the club so first you have to check that the club is not full so the members doesn't already contain Max size entries then we check that whoever wants to join is actually sending the amount required to join the club to the contract we won't keep that value we will send back here back to the sender but this is a way to prove that they do have access to this money because they are able to send it to the contract before they get it back so if they do have this amount and send it to the contract we can add their address to the members set our onchain view will simply return whether user so the address passed as a parameter is in the members set and then we have a leave entry point where we simply remove whoever is calling this entry point from the set of members pause the video and implement this smart contract let's take a look at the solution we can see here that we have a Constructor that takes the membership thr so and Max size as parameters and stores them and then it creates this members empty set in the join entry point we check that the caller did send the required amount we check that we still have fewer than Max siiz members in the set we check that we still have fewer than Max siiz members in our club then we add this uh color in the set of members and we send them back the amount since we don't want to keep it in the contract we have our is member onchain view that takes a user as a parameter and we simply returns whether it is in the member set or not finally you can call the leave entry point and then we simply remove this address from the members we have a basic test where we create a rich Community by calling this contract with a threshold of 10,000 TZ and a maximum number of members of 100 we then have Alice join by sending the right amount Bob first tried to join with the wrong amount so it shouldn't work then he tries again with the right amount from the scenario we can call the onchain view to check that Alice is indeed a member and that Carl who never joined is not a member then we can test that we can leave so Bob is leaving the community and here we check that indeed he's not a member anymore if we can give it a try we see that we first create an empty set Alice join Bob tries to join and fails Bob then succeeds in joining we can see that we have Alice and Bob here and then we send the 10,000 back to Bob and then Bob leaves and only Alice is a member all good it's important to know when not to use sets and there are situations where you really shouldn't use them pause the video and think about why for a minute the issue as often is with the amount of storage that you have to serialize or deserialize when you call the contract if you have a set and this set gets too big then this amount could be so big that the amount of gas you spend in a transaction exceeds the maximum amount that you allowed so your contract could get stuck if your set keeps growing arbitrarily in our exercise we don't have this issue because we had a limit of 100 members in the set so we were safe it could never grow to more than 100 members but what if you didn't want to have this size limit how could you make sure that your contract never gets stuck pause the video and think about it for a minute so as often when you want to use a data structure doesn't have any size limit you can use a big map and big map can associate a value with a key here we don't have a value but we still can use keys so we could use the values of the set as keys to our big map and then for every key we simply store unit which is nothing so when we want to add a member to our big map we simply say members of this address equals sp. unit so it creates the entry even though the entry doesn't contain anything we can remove it using Dell and we can check membership simply by checking if there's an entry for that address then we can have membership contract that has as many people as we like without having to worry about the costs so big Maps is always what you have to think about when you want to store a lot of data but you should be careful it doesn't always solve all of your gas issues in particular you have to keep in mind that whenever you access a given entry in your big map you still have to deserialize and resize this entry so if you store for example a full set within a single entry then it could be risky because that single entry could get really big and then you would end up with the same problem again so big maps are part of the solution when you want to store a lot of data but it's not always sufficient so you should still be careful in this module we will talk about variance a piece of syntax that allows you to create your own types let's start with simple variants a variant is a type that we use to represent one of several predefined values for example you could Define a type called day of week for values that represent a weekday so a variable of this type could hold any of these values Monday Tuesday Wednesday Thursday Friday Saturday and Sunday simple variant are similar to inms in some other languages that you may be familiar with the syntax to create a variant type is to write sp. variant and then between parentheses the list of possible values and a type unit we'll see later how we can have variance with parameters where the type is different but for now you simply put a list where each element is a name then equals sp. unit meaning nothing to avoid repeating this every time we use a type we usually create a named type a custom type in the main module so in our main module we would write day of week column type equs and then sp. variant with all the different values then within your smart contract you can use values of this type for example in assignments or comparisons here we create an attribute in the storage called day and with initial value of Tuesday so when you use the value you put the name and then a pair of parentheses then you can compare this value to different possible value of this variant here we compared to Sunday or Saturday to determine if this is the weekend and the price for some work is more expensive during the weekend when you use variance you need to keep type inference in mind because if you don't specify the type it can be determined automatically using type inference but it will only be determined based on the actual values that you use so if you have a variant for all the days of the week but you only use some of the days in your code then the type inferred by the type inference algorithm will only contain the values that you have used but you may need the other values in some other cases so that could be a problem so in this example the type inference only creates this variant it only has Tuesday Sunday and Saturday type inference can't guess that there are other weekday than the ones you use in your code if you want to execute different code depending on the value of a Varian you can use sp. match as an alternative to using ifs and elves and comparisons sp. match works like this you write with sp. match and then between parentheses the value then you put one section for each value where each section start with with and then sp. case do the name of the variant colum and then the corresponding code in the test scenario with the current version of smart Pi the way you use variance within your test is a different syntax from the syntax you use within the smart contract itself this may change in the future but that is the case at the moment of recording to describe a given value of the variant instead of writing sp. variant Dot and the name of the value like you do in your smart contract in the scenario you will write sp. variant and then between parentheses the name of the variant between double quotes comma the value unit as a pair of parentheses and then if you want to check if a value is a given variant instead of writing your value do is variant Dot and then name of your variant and parenthesis you write is variant and then between parentheses the name of the variant between double quotes again most likely in the future version of smart py they should be Unified to the same version we use in smart contracts let's take a look at a full example that uses variant here we Define our custom type for the days of the week from Monday to Sunday then in our smart contract we initialize the storage attribute day with the value Tuesday we use sp. cast to make sure that we don't let the type infer determine the type of day but we say this is day of week to make sure that all the days are possible then in our work entry point we compare the value to Sunday or Saturday and determine the price based on that and finally in our test scenario we can call set day with a different syntax to create a value Sunday and then we can verify that the value has been set to Sunday using this test specific syntax we can give it a try and everything works as an exercise to practice variance write a contract that has an order drink entry point and that entry point should take the identifier of a drink as a parameter in the form of a variant it should charge the user the corresponding prices so if you order water you pay nothing if you order a CocaCola you pay one TZ or if you order Fanta you pay two TZ and the smart contract should store the items you order in a list named items POS video and give it a try let's take a look at the solution here we Define the custom type drink type as a variant that can have the values cooka Fanta water and we added seven up in our smart contract we simply Define a list we don't need to specify the types here but in the order drink entry point here we cast drink as the type drink type to make sure we have all the different types including seven up as possible values of our variant we set the default price at zero then we use sp. match to check the different possibilities so one test for Coca two test for Fanta and zero test for water Etc we could add more then we check that the person who ordered the drink paid the right price and then we add the drink to the list of items in our test we use the other syntax to create variants to order drinks can give it a try and everything works all good so you may wonder when you should use Simple variants simple variant are quite convenient when you already know the final full list of possible values so in the case of days of the week we know that they are not expected to change we're not going to add an eighth day of the week anytime soon so you're pretty safe with that variant or if you create a game of chess the list of chess pieces is also very unlikely to change in your game so varant in those situations are a very good way to make sure you never attempt to assign an invalid value and they make it convenient to use names in your code the alternative could be using Naturals from 0 to six four days of the week and same for chess pieces but it's very convenient to name each chess piece but variance could be problematic if you ever want to allow a new value in your list for example for a menu item in our examples where we use drinks we could easily want to extend the list of drinks for example we could add root beer or Sprite so in this situation using variance is actually not a great idea and for anything that could change where new possible values are likely to be added using numerical values or even string values are preferable to variant for example here we have prepared a smart cont contract split in two so this restaurant smart contract is pretty much the one we just worked on where you can order different drinks but then we added an entry point quick drink that uses another contract that stores the favorite drink of each user this favorite drink smart contract has a big map and for each user it will store the favorite drink that this user has recorded and then there's a view favorite that can can request the favorite drink of a user and then the restaurant can have an entry point quick drink that checks what the favorite drink of the color is and then orders that drink here it happens to be a free drink if you order your favorite drink now let's say we want to have a new version of the restaurant where we allow a new type of drink so for example we add stri so we create this drink type new where we have the same list of values but we add this Pride value that we might want to use in the new restaurant then we PR drink contract so that we don't lose all of the data and can keep honoring this quick drink offer but if we do that then when we create an instance of the new restaurant it won't work we can check it we can see here that we're missing the variant Sprite in the type variant that we use in line 71 so that's really the type inference that is not happy when here we try to push a drink in our list because the type of drink is not the same type that we have used in our favorite drinks contract and there's no way to make them compatible because from the point of view of the type inference those two types are really different so this shows that if you ever want to add add a possible value to a variant you could be stuck and unable to use existing smart contracts that you are used to interact with you would have to rewrite the favorite drink and then lose all of its data so that it can be compatible with a new restaurant so that's clearly one case where it might not be a good idea to use variant and instead you could just use strings or numbers so we presented simple variance where you simply have a list of possible values but you can do a lot lot more on tesos with variant you can have variance with parameters for example let's say you want to store a value that represents the current status of a worker the worker could be available could be absent could be away could be in a call or could be in a meeting if you know for sure that this list will never change and this could be a good use for variants but in some cases we may want to add extra information specific to one of the status so for example if the status is away we might want to store the expected date of the next availability of the user so we would want to add an time stamp to this away status or if the person is in a call you may want to add the URL of the online call so that somebody can join that call so here the parameter would be a string and of course we could also want to store multiple information in this case you would use a record for a meeting you may want to store the floor and the room of the meeting associated with the meeting value of the variant you may want to store a record with a string and an INT if you want to create a variant with one or more parameters you can create values directly like this so for no parameters we do as we have done before but then you can create a variant with a parameter where between the parentheses you simply put the value of the parameter and here for a record you simply put the value of the record of course we recommend using a type declaration as we have suggested before so that you can have a precise definition of the variant so here we would say that for the status away the type is sp. time St this is where you understand why we put sp. unit before this was to say that there's no information no parameter associated with this status so for simple variant you put sp. unit but for variance with parameter you put the type of the parameter so sp. time 10 for away sp. string for call and sp. record and the different attributes for meeting now how do you check the value of a variant that has a parameter so let's say we have a status variable in the storage that has one of the following value it can be either absent or away and with this time stamp to test if the status is absent we can use a simple comparison as we have done before you can check assert self. dat. status equals sp. variant. absent but this one won't work if we want to check if the status is away whatever the time stamp value is you cannot just compare to away because it could be a way and a value so if you want to check if a value is of a specific variant independently of the value of the parameter you can use this syntax you can do assert self. dat. status. isore variant. away this will make sure that the status is away with some value if you want to extract the value of the parameter from a variant you can use unwrap so you take your variable status and then dot unwrap Dot and the name of your variant so for example if you want to extract the time associated with the status away that we have defined like this s p. variant. away of this time stamp then you can extract the value of this time temp like this you can say deadline equals self dat. status. unwrap do away this should return the value sp. time stem of 1 2 3 4 5 that is contained in the variant as we defined here if the current value of the status is not of the away variant then it will raise an error as before in the current version of smart pi as we record this video the test scenario is still using an old syntax to unwrap the value of a variant you will write contract. dat. status. opencore variant of double quote away so this is different from what you use in the smart contract itself where you use status. and r. we can expect that in the future you will be using this syntax in the test scenarios as well so earlier when we were working with simple variant we used the match and with construct to handle the possible values of a variant we can use that for variants with parameters as well at the end of the width line for a given variant we can use as and the name of a variable and when the variant matches this case this variable name will contain the value of the parameter here's an example where deadline will contain the value of the parameter when the status is away so we write with sp. case. as deadline then we can use the value deadline that is basically unwrapped from the value of status and compare to some value if the parameter is a record the variable will simply contain the value of the entire record nothing special there let's try this on an example we'll create a contract that manages the status of an employee and so the employee can be available absent away until a certain date in the call but we store the URL where the call can be joined or in a meeting in a given room of a given name and on a given floor where the floor is a natural number the employee should be able to set their status with a set status entry point and their boss should be able to invite them to a meeting unless they are currently unavailable let's take a look at the code the beginning of our module we will Define two custom types the main custom type is for the status where we have a variant that can be available with no parameter absent with no parameter away with a Tim stamp call with a string that is the URL to join the call and then meeting with the floor and the room we'll talk about the other type in a little bit we have a contract employee status that will store the status of a given employee we initialize it with available and we also store the owner of the contract and the boss of that employee we have an ento set status where where the owner of the contract can change the testes so the owner here would be the employee themselves we have a set status entry point where the employee is allowed to change the status to a new value so here this is where we indicate that status is of this type to make sure the type inference doesn't forget any possible value for the variant then we have our invite entry point that allows the bus of that employee to invite them to a call or to a meeting and here we indicate what type of event they want to invite the employee to so this is why we need to describe this event type that can be a subset of the different values of the status type so in this other type we can have two possible values either a call with a URL or a meeting with a floor and a room we make sure the caller is the bus and then we'll have this first section where we determine if the employee can be interrupted and is available for this call so by default they can be interrupted if they're available that's fine if they're absent well they cannot be interrupted they're not here if they're already in a call or already in a meeting then they cannot be interrupted but if they Mark that they were away until a certain date then they can be interrupted if that deadline is passed so if we are after the time that they were supposed to be away then we check that indeed they can be interrup erupted and then depending on the type of event we set the status to a call or to a meeting here you can see that we cannot set the status to the value of the event itself because they're not of the same type those are two different variants so we recreate the call and recreate the meeting here with the meeting information that we extract from the event and we have a simple corresponding test and we can check that everything works well good let's do a recap of the the syntax you use when you manipulate variants if you want to define a variant type you write sp. variant and in between parentheses the list of potential values where each value consists in a name then equals and then the type of parameter Associated to that name if there's no type you can write SP sp. unit then when you want to create a value you write sp. variant Dot and the name of your variant if there is no parameter then you just put a pair of parentheses with nothing in between but you can also put a value of a parameter if it's a variant with a parameter if you want to check if it's a given variant when it's a simple variant you could simply compare it to the exact same value to sp. variant and then variant name one but if it has a parameter you cannot do that so you do assert your variable do is variant dot the name of the variant so that ignores the parameter and checks if you're that variant if you want to extract the value of a variant with a parameter you use unwrap so you take your variable do unwrap Dot and the name of the variant and then this will return the value of the parameter to execute different code depending on the value of a variant we saw that you can use the sp. match syntax so you write with sp. match then between parentheses your value and then you have different cases starting with withth sp. case the name of a variant column then the code you execute if that value is of that Vari if the variant has a parameter you use the same syntax but you add as value this is the name of a variable that you give and where the value of the parameter will be put then you can use it during this code at the moment in a test scenario you use a syntax that's a bit different if you want to create a value you use sp. variant and then between parentheses a string that contains the name of the variant then the value and if the value is nothing you put a pair of parentheses to represent the value unit nothing if you want to check if it's a given variant you can write s scenario. verify of your variable do is variant and then between parentheses the string that represents the name of the variant if you want to extract the value from a variant in a test scenario then you write your variable. open variant then the name of your variant between double quotes we discussed earlier when to use Simple variance we can ask the same question about when to use variance with a parameter or when to use parameters with a variant as we stated before a variance can be convenient if the list of possible values never changes the same applies in the case of variance with parameters both for the list of cases for the variant and for each case for the type of the parameter but you don't need to know all the values of the parameter in advance for this to work you just need to know their type the main use of variance with parameters on tesos is actually an internal use because in meason entry points are really variants each entry point you call has a parameter that corresponds to a different value of a variant where the name of your entry point is the name of the variant so the parameter of a smart contract is a variant type which with the different entry points and their parameters internally variant types are represented as a binary tree if we look at the melson code for a status example where it can be either absent available away on a call or on a meeting internally we have this structure of nested ores and we can represent it as a tree with the main ore here with two children each of them being an or between two values this one is between absent and EV available and the other one is between a way with a parameter Tim stamp and either call or meeting and when you want to describe a value of a variant what you describe is a path in that tree where you go left or right at each step so for example if you want to describe the value available you go left and right so in mikon you write Left Right unit for the value available if you wanted to have the value call you would write right right left and then a string to represent the variant call so this is good to know if you ever see errors related to variant or even entry points that talk about variants okay so under then exercise to work with variance and parameters let's create a new version of our fast food contract where we add more choices and here we listed all the different choices you can either buy a hamburger an ice cream a drink or a brownie the hamburger will be h t by default it has a parameter for the type of sauce that is a string a parameter for the quantity of sauce that is natural and the price will be increased by 0. two Tes for each sauce beyond the first two so the first two units of sauce will be free but then after that you need to pay 0.2 t for each then you can have a side dish with your hamburger that itself is a variant it can be either fries or potatoes and the price will be zero test for fries and one test for potatoes so you have a variant within a variant for the hamburger for the ice cream we have two parameters the flavor a simple string and the extra topping that is a Boolean do you want extra topping on your ice cream or not the price by default will be four Tes and if you add an extra topping you would pay an extra two test and we have no choice in what topping it will be for the drink we simply have a parameter that is the flavor and here instead of using a variant because we know we want to add more types of drinks later we decided to use a string and to keep it simple we said that every drink is three T finally you can order a brownie so this will be a variant without a parameter and which charge fight test so write a version of our fast food cont that can handle all these different choices pause the video and give it a try let's look at a solution here are the main part is to define the variant type so we Define a custom type food type that is the variant where the different possible values are hamburger ice cream drink and brownie brownie is a simple variant with parameter type sp. unit so no parameter drink has a string p parameter for ice cream we have as parameter a record with a flavor a string and an extra topping a Boolean for hamburger it's a bit more complicated so hamburger is a recur that has a type of sauce that is a string a quantity of sauce that is a natural and a side dish that is itself a variant that we hear Define directly in line we don't create its own custom type so we create a variant that is either fries with no parameter or potatoes with no parameter then in our place food order entry point we make sure we cast the parameter as food type using our custom type then we initialize the price at zero and then we will add to it depending on the type of food so we use sp. match on the parameter food if it's a hamburger we extract the parameter in the variable composition we set the initial price at eight TZ we extract the hamburger side the sauce quantity we check if the quantity of sauce is more than two then we add 0.2 T So 200,000 mes for each amount of SCE Beyond two so here we need to write minus two and do sp do ASN because we know this will be a natural then we match the side dish to either Varian fries in which case we add zero or the Varian potatoes in which case we add one if it's an ice cream we extract the parameter in composition and we check if there is extra tupping in which case we add two tees and if it's a drink or bronie the price doesn't depend on the value then we check the price is good we have a test where we buy a hamburger with fries an ice cream with extra topping and a Coca and finally a br we can give it a try and it works well good in this module you will learn about the fa2 standard and this will allow you to create tokens contract that can interact with all kinds of existing tools in the tesos ecosystem so when we talk about tokens we talk about any digital representation of an asset or utility fa2 stands for financial asset number two and it's a token stand standard that we use for tokens on tesos this token standard enables smart contracts to interact with each other and to interact with tools such as wallets and it does so by using a set of rules conditions and functions that any F2 contract need to apply the fa2 standard supports both fible and nonfungible tokens there's also the fa 1.2 standard that is an earlier standard that is simpler but only supports fungible tokens there's also a new version of A2 called a2.1 that is in preparation and it is retro competible with fa2 so anything you learn about fa2 will also apply to fa 2.1 so the standard defines three mandatory entry points that your contract needs to have to be compatible with the fa2 standard the balance off entry point is meant to return how many tokens of a given token ideas one or more users then the transfer entry point will be used to change the ownership of a number of tokens owned by a user and then we have a update operators entry point that will update the list of addresses that are allowed to perform transfers for a given token the standard also defines some value that you should have in the storage of your contract called metadata and it should contain information about the contract following another standard called tzip 16 we won't go into the details of that standard there's also a number of optional mikas Sun storage views get balance total supply all tokens is operator and token meta data we provide pieces of code that you can execute offchain to obtain information stored in the contract but obtain them in a standard way so if we try to implement a very basic A2 contract in the storage we will need to store two things we will need to store the Ledger that keeps track of who owns Which tokens and what information there are about each token so we will store a big map the key will be the idea of the token and the value will be both the owner and the metadata if we don't have any quantity value then we will only be able to handle nft types of token then we need to store operators so that's who is allowed to interact with a given token we'll stall them in a big map and the key will be composed of the address of the owner who set this operator the address of the operator who is allowed to perform actions on that token and the idea of that token and that's it there's no value so the value will be unit so as long there's an entry in the operator's big map for a given owner operator and token idea that means this owner allows this operator to perform actions in its name for this token the balance of entry point takes as parameter two values a call back that will need to be called to provide the result and a list of requests where each request is a record with the owner and the token and it's basically asking for each of these records please give me how many of the token this user owns and then the balance off entry point is supposed to call the call back function passed as parameter and send it a corresponding list of results and it will do that by sending a list of Records where each record contains the content of the request again with the owner and the token ID and the balance for that particular token so it basically says this user owns this much of this token the transfer entry point is used to transfer tokens from one address to another its parameter is a list of batches of transfer and each batch represents the transfer of one or more tokens from a given owner so it will contain a field from that will represent the owner and a list of transfers where each transfer contains a token ID and a destination so basically each patch will say we transfer tokens from this owner this token ID we transfer this amount to that other person and we'll say that for this token idea we transfer this amount to this destination so when we execute it for each transfer we will check if the Coler is either the owner of that token ID or an operator for this owner and token ID here as we only want to transfer nfts we'll simply check if the amount is one so is this nft owned by this owner so we will check that the owner really owns this token ID then when we're done checking all this we can transfer the ownership of the token to the destination given in the parameter finally we have the update operator where we want to say okay either say that we allow this address to transfer tokens in our name or on the other hand we want to remove this operator from the list of operators for a given token so the parameter of this entry point is a list of updates where each update will say if it's an addition of operator for a token or if we're removing an operator for this token then we say uh who is the owner of the token what operator we want to add and what's the token idea that we are updating this operator for so for each update if it's of type ad operator we will add an entry in the operator's big map we talked about earlier and the entry will contain the owner of the token the operator we're adding and what token this is about and if it's soft type remove operator we simply remove the corresponding entry the errors that those entry point May emit are also standardized so there's a list of different errors but here are a few you can have the fa2 token undefined that's when we make a request about a token IDE that doesn't exist at all or we could have A2 insufficient balance if you try to transfer more tokens than the owner has let's take a look at a simplified fa2 contract so that you have some idea of how it works so here we Define a few types we Define a transaction type so a record that authenticates a destination address for a token ID and a given amount then we have the operator type to Define who is allowed to transfer tokens for a given owner so we specify the owner the address of the operator and what token idea we talking about you will notice that we'll specify a layout because this is a standard melon representation has to be a very specific way for this to fit the standard and the representation is that it should be organized as a right com so a pair where the owner is the first element and the second element is a pair containing the address of the operator and the token idea so we use do layout to specify that it should have exactly this structure then to manage operators we have a variant that can be either adding an operator in which case the value is are recorded with the OWN owner the operator and the token idea and then remove operator where the value is also of the same type then we have our contract we see that we store a big map of tokens and next token ID it's started at once so every time we mint we will increment this value and add a new token in the Mig map in the mint entry point we simply take a metata that is a string and then we will create an empty set of operators that are allowed to transfer this token so it's a set of values where each value is operator type that we just Define with the owner operator and token ID then we create the nft itself that is a record with the owner the metadata and the set of operators and now we can increment next token idea so that the next token will have a different idea so we have the balance of entry point so that people can check how many tokens of a given ID I user has so the request is a list where each element is a record with the owner and the token idea so we basically asking how many of this token idea this owner has and we prepare a list for the results where we add for each request the corresponding answer we check that this token ID exist otherwise we have the standard error fa2 token undefined we fetch it from the big map we assume by default that the balance is zero but then if the token owner is the request owner then their balance is one so we add this information to the results so it's a list so we use sp.com to add to the result list a record where we specify the request again and the balance that this owner owns for this token idea so one if he owns it zero if he doesn't finally we send the result back by using this call back and doing an interc contract call where we send this result and zero test to that call back we then have our update operator entry point with a list of actions and each action is either variant add operator or remove operator if it is ADD operator we unwrap the information from the variant to get the data we cast it as operator type to make sure we are compatible with the standard we fetch the token corresponding to the Token ID that's in the operator data we check the that the owner of the token is the user who's trying to update the operators for that token we also check that we are setting the operator for this owner so the sender is the owner in the operator data and if that's all good then we add this operator data to that token so we say yes the operator address that's defin in operator data is allowed to make transfers for the token idea in the name of this owner if the type of the variant is remove operator then we do something similar except this time we remove it from the set of operators finally we have the transfer entry point where we take transfers a list of transfer as parameters and each transfer contains a list of transactions of type transaction type we check that we trying to transfer one of this nft because it's an nft you can only have one we check that the owner of the nft is indeed who we're trying to transfer from so that the transfer is valid we fetch that token and then we create the operator that indicates that we are looking for an operator for this owner the operator is a sender and we manipulate this token idea so we want to check if this user is an operator in the name of the owner to do transfers for this token ID here so if it is if there is such an operator in our set of operators for this token then we transfer the ownership of that token idea to this address and that's about all we have to do for a simplified A2 contract then we have a Marketplace contract that will interact with this fa2 contract it needs to store the address of the corresponding token contract and it will have a big map of offers every time we make an offer we increment this offer ID so when somebody makes a new offer we say I want to make an offer for this token at this price in the sense that I'm willing to sell this token at this price here we don't check that the seller actually owns that token we will check it when we do the transfer in the buy entry point and in the buy entry point so someone a buyer will call this buy entry point and say I accept this offer so we fetch the offer we check that the buyer pays the amount specified in the offer then we obtain the token contract based on this address we provide the type of the transfer entry point to obtain the address of the transfer entry point then we prepare the parameter so we create a transaction that is a record with the sender so that's the destination so the color to whom we will transfer the nft here is the token idea of the nft and here is the amount of the that nftd that they want to transfer we make sure it's of the right type transaction type and then we call the transfer entry point passing a list of transfers where each transfer is from the seller from the address of the seller and we have a list of transactions with only one transaction which is what we just created here so the marketplace says I want to transfer this token that is supposed to be owned by the seller and I want transfer it to the caller the buyer and the amount is one token so when I ask the transfer the token will verify that I'm allowed to the marketplace is an operator for this owner and this token idea we will of course check that the seller is the owner of the nft and if it is we will change the ownership and then I send the price to the seller and here we have a test where where we create a few accounts we create The Ledger itself we create the marketplace we main nft the owner of that NF Alice creates an offer to sell her token for tentes then we add an operator to say that the marketplace should be an operator for Alis for the token id1 so we add an operator and then we tested by having Bob try to purchase the token for 10 is so if we give it a try it all works so this should give you an idea of what an fa2 contract is and what a contract that interacts with it is so here we use the standard for the marketplace to interact with the token and it should be able to interact with other tokens that are also compatible with the fa2 standard in this module you will learn how to develop oracles a special type of smart contract that allows all the contract to obtain information from the offchain world and we will see that this makes many type of applications possible many smart contracts need to access offchain data for example if you want to create an insurance contract that can insure an event against some heavy rain then the insurance contract will need to access to weather data to decide if there was Indeed heavy rain during your event so you should be reimbursed for the Cor Corr responding loss or you could have decentralized Finance contract that need to access exchange rates for example some contract may need to determine what the exchange rate between the US dollar and the euro is to take some other decisions or you could create supply chain contracts that track shipments and may need to access to the current location of a ship in order to assess the current situation of the stock for example or you could imagine that some contracts may require some heavy computations that cannot reasonably be done on chain and so those could be done offchain with the help of an oracle now if we want to access offchain data could we simply call the API of some oft service for a smart contract when we need the data what issues do you think this could cause pause the video and think about it for a minute so if you tried to call a rest API directly from a contract assuming this was possible it really wouldn't work at all you would have three types of issues you would have consistency issues when you execute a smart contract the result has to be the same on every single node but if you use a rest Epi you have no guarantee that this rest API will always give the exact same answer every time you call it so when each of the the nodes of the network would call this rest API then some of the nodes may get a different answer from other nodes and that would create a mess then you have performance issues if the smart contract has to wait for the response from AR rest API that means pausing the execution of all the transactions in the current block and you need everything to be done in a specific order specified by the sequence of transactions in Block so while you wait you don't do anything SO waiting for AR rest API within a contract will slow down the execution of each block considerably finally there are reliability issues the execution of a smart contract needs to always work no matter what this includes running the contract weeks or years later when you want to reexecute all the transactions from Genesis for example so the execution of a smart contract and the result can't depend on the availability of some external service at the moment of the execution of the contract now can you think of a way to obtain this data without being confronted with those three issues pause the video and think about it so one solution is to pay for an offchain service to fetch the data from the original source of data and then call your contract with this data as a parameter so instead of pulling the data from the smart contract you push it from an offchain Source doing that solves all three issues it solves the consistency issue because once you created the transaction with the data as a parameter and injected into a block every node will get the same transaction therefore we'll get the same data it also solves the performance issue because when you execute the contract the data is immediately available to the node they are just part the parameters of the transaction so it doesn't need to wait for anything to execute the contract once it's in the block everything is available finally it solves the reliability issues because we can rely on the resilient architecture of a decentralized blockchain once data is in the Block it's available to all the nodes very quickly but we're not really solving the problem here we are just moving the problem somewhere else can you think of what could go wrong with this approach pause the video and think about it so the issue is that if you rely on an off service to send the data to the contract you lose the benefits of the centralization you lose the reliability aspect of the centralization because the offchain servers that you rely on could simply stop sending the data to your contract and your contract would just stop working you also lose the trust aspect because you have to trust that the offchain service will send correct data to you your contract whoever is in control of it could cheat and make it send invalid data and and make it take all kinds of wrong decisions finally it wouldn't solve the censorship issue because the offchain service could decide to refuse to send some of the data based on all kinds of different criteria including refusing to send some data that wouldn't be beneficial to whoever is in charge of that service so you could say okay if I cannot trust some off server to send me the data what about if I run my own service to fetch data from the original source and then send it to my contract would it solve all these issues I wouldn't need to trust some offchain service I would just run it by myself so pause the video and think about what issues this could create so the idea is that if you run your own offchain servers to provide data to your contract then yes you can trust yourself but you move the problem again cuz the whole point of a smart contract and of a blockchain is that users of the smart contract don't need to trust a third party so here instead of trusting this offchain service that some other party runs they will need to trust you the author of the contract to keep running your own service and so the problem is they cannot be certain that you will always keep your service running they also cannot be certain that you want change the data yourself before before sending it they really have to trust you and that's what we want to avoid to need when we use a blockchain so even the owners of a contract shouldn't need to be trusted once the contract is deployed so this approach may still be used if you are the original source of the data anyway and so you need to be trusted no matter what then you should directly inject the data in smart contracts sometimes the application makes it so that we have to trust you anyway at least for that part another idea if you're not the original source of the data itself is to have this original Source send the data instead of you going to fetch it and then provide it to the contract you could try to convince the original source of the data to directly call your contract then your contract could simply verify that the caller who's sending the data is indeed this official Source you could check the address the issue is that convincing official source process of data to call many contracts on many blockchains is unrealistic so for example if you imagine that we are interested in the weather data and we want to convince the weather agency to call your smart contract and send today's weather to your contract it's going to be quite hard to convince them to do so they probably don't worry much about blockchains at the moment so instead of having those sources try to call every contract that is interested in weather we could simplify things for them and have a single contract on the blockchain that is dedicated to receiving data from this source and this type of contract that centralizes all the data from a given type and makes it available to other contracts is what we call an oracle that's a contract that collects offchain data one way or another and makes it available for all the contracts but still even convincing this uh Weather Service to send its data to a single Oracle contract is not easy at all most potential sources of data are not involved in blockchains at all at least not yet so we can't really expect them to call oracles themselves before we continue I really want to bring your attention to the fact that incentives for people to inject false data into an oracle can be very strong because when you get incorrect data from an oracle your contract can make really bad decisions so for example if you have a contract that relies on knowing the exchange rate between two currencies but obtains the wrong exchange rate then it can make a terrible decision that could lose millions of dollars so it can be very profitable for an attacker to cause an oracle to return an invalid value if you check the news about blockchains and about attacks and millions that are being lost many times those millions are lost because of exploits related to oracles where the value provided by the Oracle is manipulated and as a result Millions were lost or stolen here I listed a few example just within a window of a few months where several millions of dollars were lost due to Oracle manipulations so it's really important to have ways to obtain accurate data from the offchain world so if we can't come convince official sources to send their data to many different blockchains and their oracles something that's a bit easier to convince them to do is to have these original data sources published signed versions of their data so instead of Simply publishing on an API here is the weather today in this city we would just ask them to add a signature to that message then we could run a service that would fetch this data an offchain service and I would send it to the Oracle contract and the Oracle contract could then verify the signature and therefore check the data indeed comes from the original data source doing this has multiple advantages whoever takes the data from the original Source API and then sends it to the arle by calling a entry point of the Oracle we will call them an intermediate they can't temper with the data because if they change the data the signature will be invalid and they can't sign themselves because the signature has to be done with the private key of the original source so we don't actually need to trust whoever is taking care of transferring the data from the official source to the Oracle because they have no way to change that data it's also quite reliable because you don't have to trust that some intermediate will do their job you can rely on multiple people to do it anyone can run their version of that service to increase reliability and go themselves call this API fetch design data and call the Oracle to make it available on chain of course this still assumes that the original Source will keep publishing correct signed data they stop doing it then your Oracle will stop working this kind of approach that relies on sources publishing signed data is used on tesos by what we call Harbinger oracles and the typical source of such data is coinbase where we can find exchange rates between different currency pairs okay let's work on an exercise where we have a contract that will use an oracle so we created a contract called binary bets that lets user bet on the outcome of sport matches and to keep Simple we will assume the following we'll assume that every game is identified by a unique value that we will call game ID again to keep it simple we will assume that the game only has two possible odomes true or false true may be that the first player won and false means the first player lost and therefore the second player one and we also assume that there is an official Sports Federation that publishes the signed result of every game and that we can trust so for the exercise we prepared most of the code of this simple binary bets contract and your job is to write the code of an Oracle and change the binary bets contract so that it calls this Oracle to obtain the outcomes of the sport matches and then reward the winner of the bets let's take a look at the code so here we have this binary bets contract that will store a big map of Bets with the usual next bet ID that we increment every time someone bets then we have the Oracle address and we have the fee that we need to pay the Oracle to obtain the result oracles are servers that want to make money so they may Char a fee when you request some information then users can call the create bet entry point to make a bet and propose a bet to someone on a given unique game ID and they say I bet that the result will be this so again to simplify we say the result will either be true or false so I bet that the result would be this and we set a deadline we say okay the result should be determined before this deadline if it's not then that means we couldn't get the data so we cancel the bet so we simply create an entry in the bets big map we say whoever called this entry point is player one we don't know player two yet so we just store the smart contract address in player two as a way to indicate there is no player to it's easier to do than using options and setting none but using options would be another possibility we store the game Ida we say how much we want to bet so we send that money to say I bet 10 T this team will win and we store of course the expected result the deadline and we say this has not been cancelled then another player could say I accept this bet so they provide the idea of that bet and then we fetch bet we check that the amount they provide is the amount that the other person bet plus the fee for the Oracle so here whoever accept bet is in charge of paying the fee to the Oracle person who creates the BET has a small Advantage we check that nobody else already accepted bet so player two is still the address of the contract itself and we check that the BET has not been cancelled we store the address of player 2 and we store the bed and here since we just accepted the BET here we create a request on the orle to say please send me the result of the game that we bet on and do so before the deadline that the user set so this part of the code is for you to write then we have uh withdrawal entry point that's when something wants to get our money back because the BET was cancelled so here we get the BET which check what amount we should be paid back if we are the player one then we can withdraw the funds either because the BET has been cancelled or because nobody else has accepted the BET yet so in this case we replace player one with self address to make sure that player one cannot call this a second time and be reimbursed twice then we make sure it's set as cancelled and then we send the amount to whoever was calling if the caller is not player one then we make sure it's player two otherwise they have no reason to call this entry point we check that it has been cancelled and then we delete Player Two by saying okay the address is now the address of the contract so it's not a real user and we add to the amount the Oracle fee that player two has paid and then we do the same so the way it could be cancelled is if somebody calls cancel after a deadline for a given bit and here basically the idea is to say if the Oracle didn't provide the result before the deadline that we set then the beted can be cancelled so here your work is to call the erle and get information about whether the result was provided or not to the Oracle and if not then that means people can be reimbursed so the bet is cancelled finally when someone has won the bet they can call claim prize to get their funds so here we check that the BET hasn't been cancelled then we get the result from the Oracle this should only be called once the Oracle has the result we can check that off chain before we make the call if the caller is player one then we check okay did they win is the result what they expected the result would be and if it's not player one then we make sure it's player two and if it is we make sure that the result is not what the first player expected it to be so if we don't fail that means the caller has one so we send them the amount of the BET times two and then we delete the bet so that they cannot claim the price a second time and we need the default entry point because in case everything is cancelled we need here the Oracle to reimburses and the way they reimburses is by simply sending the fee back to this contract through the default entry point so we should have a default entry point to be able to receive the test and here we have started trading the Oracle contract and it's going to be for you to implement it but all you know is that the Constructor takes an admin and then the public key of the source from which you will get the data and so the idea is that when you get data from The Source you will verify that it contains a signature that matches this public key we can now take a look at the test so here we have created three usual accounts and a special account that we call data source that will be the account that won't be an account that directly interacts with the blockchain but that will be the account whose key is used to sign the data so we first create our Oracle so you provide the address of the admin Alice and then the public key of the data source so that we can use it to verify signatures then we create the Ping contract and we say the fee for the Oracle is two TZ then we have a first test where everything goes as planned so we have Alice create a bet on game with ID one she expects the result to be true and she says okay the result should come before this deadline and she bets five T then Bob first tries to accept the bet but by paying only five Tes so this should not be good because Bob needs to pay for the Oracle fee which he does in the next attempt paying seven test then Alice tries to claim the prize before the Oracle even got the result so this should not work so here you will add the part where you send the assigned result to the Oracle that the Oracle will verify after the Oracle got the result Bob will try to claim the price but Bob actually lost because you sent true and Alice bet that the result was true so Bob lost but then Alice one so she can claim the price and this should work then we have a second test case where this time we cancel after the deadline so in this case the orod never obtains data so as soon as the deadline passed test at 1,1 we cancel and everybody should be able to get their money back and finally we have another one where this time Bob wins so your job is to complete this contract by writing the code for the eracle writing all the different calls and completing the test to send sign data to the Oracle and check that everything works pause the video and give it a try let's look at a solution so we will first start by looking at the Oracle contract in the Constructor we store the admin and the public key but we also create a big map of requests that the Oracle will receive and we also store the fee there will be two test when a user requests the result for a given game they need to pass a bet idea so that we can identify their request using their bet idea for a given color we'll see that in a minute and then of course they need to say for which game ID they request the result and what's the deadline for the Oracle to provide this result we indicate that bet ID and game ID are Naturals and deadline is a Tim stamp we check that they paid the fee and we will create an entry with the key being the BET ID and the address of the caller because multiple contracts may call this Oracle and each contract uses its own system of ideas for their bet but for this contract we have a unique bet ID that identifies this request we check that this is not already an entry for this bedge from that contract otherwise they may overwrite a previous request and M things up and then we create the entry where we store that for this bet ID and this sender this is the game idea that they request information for this is the deadline and we set a result that is an option that we initially set at none to indicate that we didn't receive the result yet when we do receive the result some servers will be constantly looking from offchain at what request the Oracle has received and when it sees a new request it will go fetch the data from the original Source the sign data and then send the result of that request to this entry point so when they do that they know all the information about the bet so they can provide the BET idea they can say which contract was doing this request so that we can rebuild the key for that request and they send the message that will contain the result plus the signature associated with that message the message itself will contain the game ID and the result if you only sent the signed result but without saying which game this is then the same result could be used for many games and so people could cheat it's really important to have all the information in the message so that the message is the proof that the source that signed this message claims that the result for this game is this result so after getting the key we fetch the request from our requests big map we check that the game for this request is indeed the game indicated in the message and then we check that the signature that we've received corresponds to this public key signing this message that we pack when we check a signature it has to be a sequence of bytes that we check so we need to pack the message before we sign it and before we verify its signature then we can store the result and we have to store it as an option so we store the result as an option on the result that was in the message finally since we did our job we received the result before the deadline then we can send the fee to the admin actually here we need to check that we didn't already get the results so we need to assert but it was none otherwise we could send the result multiple times and get the fee multiple times the Oracle will have an unchain view so that the contract can immediately fetch the result it will simply pass the key and it will return the result for this key and finally if the contract didn't get the result before the deadline they can call cancer after deadline to get their fee back because the Oracle didn't perform their service so they shouldn't get paid so we say for which bet ID we didn't get the result we fetched the corresponding request we checked yes indeed the deadline is passed we check that the result is still none so the actual result of the game has not been provided then we send the feedback and to make sure somebody cannot cancel twice we Del delete this request so another we have an oracle where we can make requests receive the results signed by the source obtain the result from the contract and cancel the request and get the feedback if nobody sent the results so in our betting contract when we accept the BET then we call the request game entry point from the error call we pass the best idea the game idea the deadline and we make the call when we want to cancel after the deadline similarly here we call the cancel of the deadline entry point here but we do that after verifying through the get game result view that the result has not been provided for the the result is none finally when we claim the prize we call the get game result view to obtain the result we unwrap it and then we award the player if this player has one based on the result in the test here we send the result to the eror call so we prepare a message that contains a game ID and the result we sign that message with the private key of the data source so of course this in practice would happen in some service of chain that sees the request and then calls the smart contract and here we call the receive result entry point we say for which P it is we say for which contract we send the message and the corresponding signature and we do the same here with the version that shouldn't work let's give it try try everything works and we can let you play with the code and check that everything works as expected the Oracle was presented was a very simple Harbinger type of Oracle but it relied on a single source which means we have to trust that source and a lot of cases we really don't want to trust a single Source because a source of data could simply avoid publishing data that doesn't benefit them and similarly if we rely on a single transmitter this single transmitter could avoid transmitting data that doesn't benefit them in some cases when it's about data that changes on a very freaking basis maybe the source of the data or the transmitter could decide to only publish or transmit the values that benefit them and skip the ones that don't benefit them when the value of a token for example goes up and down with time and preventing this behavior from a single Source or a single transmitter is really hard finally if you rely on a single source of or on a single transmitter this causes reliability issues if this source of this transmitter stop doing their job so what we want to do in practice to avoid especially relying on a single source is to combine multiple sources of data so we can fetch data for multiple sources one available if there are multiple sources for example for the weather there may be different agencies that publish information about the weather or for the exchange rate between the US dollar and the Euro you can expect a lot of places to be able to provide that information independently and you could also rely on multiple transmits to take care of sending this data to the Oracle so you should never rely on single transmitter and check the address anyone should be able to send this data the data is signed anyway so we don't need to trust the transmitters so we could have multiple transmitters running at any time and then the oracles that would get information for multiple sources would have to check that enough sources agree with the result and enough sources provided the result and if the set of different values we could take the median of the value as the actual value that the Oracle would return and if this is about a value that changes over time at high frequency such as an exchange rate we also want to average it over a short period of time so that we can avoid flukes like between two different calls it goes up down up so you want to average it over a period of time to to have a better estimate of what's the current value we won't go into detail of different ways to do that but some of the ways to do that include doing some of this work of chain so this idea of using messages that are signed by official sources is great but in practice unfortunately very few sources of data publish such sign data for blockchains for the moment but even if they didn't plan to publish signed data they actually do so for other reasons in particular when you access the website of a service or you access a rest API you usually do so through the https protocol but using https means that the data is encrypted using the private key of the domain's certificate so this means you can verify the authenticity of the data when you decrypt the data that the API returns through the public key of the certificate using SSL so this cannot really be done in a smart contract you cannot send the full https response to an Oracle and expect the Oracle to decrypt it so what we need is a service that we can trust and that will take care of doing this https request to the web page or the API of the original source that publishes the data then decrypt the https response extract the data you need from that response and then sign it and send it to an oracle so if we do trust the service that does that then everything is good of course the issue is how can we run a service off chain that does all that and that we can trust to have such a service we will need to set it up on an architecture that really guarantees that it Run unified code so you write the piece of code that does all that and you have to run it on Art architecture it will tell you yes this is the code what was actually executed and this service will fetch the data directly from a source using https request and then we'll call the Oracle contract with that data along with the proof that all the codee was executed and modified IED and all the Oracle would have to do is check that proof to verify that the service has not been tempered with and indeed the script that you wanted to execute is the one that was executed this is actually possible using what we call trusted execution environment or tees for short tees are architectures that guarantee that the software that is run by the service has not been modified and corresponds to a specific hash so you provide the code you compute its hash and the service will be able to provide a proof that the code that was run was the code that matches this hash and it can also guarantee that the SSL connection it used to fetch the data was secured and the data hasn't been tempered with there are a number of providers of trusted execution environments and this really means running some specific Hardware in a special mode that guarantees that nobody has tempered with the machine even the people who have physical access to the machine there are different solutions to do that but one of it is to use some Android phones that have the right Hardware to be able to provide this kind of security on tesos we can use the acurus service that specializes in using tees using Android and provides a service where we can set up this type of oracles BAS based on the safety net architecture you run your mobile phone in a special mode where you cannot do anything else all they can do is execute scripts in such a way that you cannot interfere with them if you want to learn more about oracles we invite you to check the indepth oracles article on open.com in this module and the next few ones you will learn how to detect flaws in smart contract and learn about best practices to avoid these flaws in your own smart contract the first flaw is related to the use of the sp. source command there are two ways in a smart contract to check who called the contract so far we have used sp. sender that gives you the address of the direct color of your contract but you can also use sp. source which gives the address of the user who is at the origin of the chain of calls of smart contracts so for example if a user a calls a contract B and that contract B then calls a contract C from within the contract c sp. cender will correspond to the address of B so the direct color of contract C but sp. Source will correspond to the address of a the user who is at the beginning of the chain of call so user a called contract B that called contract C but since a is the initial caller that's what you get when you use sp. Source but it's never a good idea to use sp. source and it may Ed for attack so I recommend for you never to use sp. source so for example if you look at this small smart contract can you find the flaw and how someone could take advantage of it so this is a contract for charity where people can deposit some funds using a deposit entri Point here and then the admin can decide to donate some of the funds that have been given to a specific charity so you say how much you send and to which charity so think about how someone could take advantage of a flaw in this contract related to the use of sp. sour pause the video and think about it for a minute so the issue is that an attacker could convince the admin of Charity fund to donate to a fake charity and could be a very small charity and could be just for a few test but when the charity fund donates to the fake charity transfer of TZ to this other contract would call the default entry point of that fake charity contract and that entry point could then call Charity fund. donate and by doing that impersonate the nmin so from the point of view of donate if we look at the code here we check that the original Coler is the nmin but if we call the fake charity from here then the fake charity calls donate again but with a different amount for the donation and with a different charity then they could trick the admin into donating all of the balance of the contract to some destination address the different steps would be that the admin calls charity fund. donate of one test to the fake charity then charity fund. donate would transfer some test to fake charity therefore calling the default entry point of fake charity and then this default entry point will would call Charity fund. donate let's say with a thousand T and with the destination being the attacker address and so charity fund. donate would check that SP source is indeed the admin and assume okay the source is the admin therefore it's the intention of the admin to do that transfer and then we transfer a thousand test to the attacker address so basically the admin thinks they're just donating one test to some contract but in practice a th000 as well be spent so this is very dangerous there is a very easy way to fix that flaw it's simply to avoid using sp. source and instead use sp. sender so to require the admin to make a direct call to char fund. donate and this way they cannot be tricked into doing something else more generally if a contract uses sp. source to identify who is calling the contract all he have to do is Trick the admin to call a small small smart contract you created that only requires a small amount to be transferred but then your smallart contract could do anything in the name of the admin with that contract that uses sp. source so make sure you simply avoid using sp. Source there's never any good reason to use it as far as I know here is the code of the fake Char ready contract it stores the address of the contract to attack so the charity fund stores the address of the attacker and then when it's default entry point is called here when the charity fund sends some test to it then it calls the Donate entry point of the charity font but with the donation of thousand t to the address of the attacker and that's it all you need to do then is convince the admin to donate one t from the contract to your fake charity you can give it a try and you see that indeed thousand T our trans to the attacker's address a second type of flaw that is extremely common so you should always be very careful is when using sp. send especially if it's a destination that is not the caller of the contract and even in some case when it is the color of the smart contract so you should be very careful when using esp. sent here is an example of a part of a contract that is likely to have this kind of flaw where we send 10 Tes to some address and then 10,000 Tes to you to the caller here some address could actually be the address of a smart contract that means when we call send to transfer 10 test to this address it calls the default entry point of that contract and that default entry point could fail and this would make the whole smart contract fail therefore it would prevent the transfer of 10,000 test to your address so you should always be careful whenever you send some test to some address you should think about what if this address is actually a smart contract that has a default entry point that rejects the funds so for example let's say the destination of this ver call is this contract we see that it has a default entry point that checks if the Boolean open is set to true so we initially set it to true but we have this set State entry point where the admin can set the state of the open value to true or false so this way you can control when you're allow to receive the funds and therefore control when this contract is going to fail or work so by using this contract you could block some user from getting their the money that is owed to them and then extort some extra money from them as a condition for you to enable the transfer of test your contract with changing the state of open so you can tell okay I know you have 10,000 test stuck in this contract I have the power to unlock it so give me a th T and I will unlock it for you so that's a way to extort funds so the best practice to avoid this kind of flaw is to always let users claim their own Tes through a separate claim entry point we have already seen that in the nft with royalties contract where we had this exact issue and allowing this claim entry point may require you to add a ledger to your contract if there are multiple users that may have Tes in the balance of the contract that need to claim so if you add a ledger a big map that for each user address keeps track of how much is owned to them by the contract then anytime you want to send some test to someone instead of doing the sp. send you simply add that value to their entry in The Ledger that's something we already did with a multiple nft with fixed contract that we all in another module another common flaw is related to unlimited computations and we talked about this already on tesos we have this notion of gas that is an estimate of the amount of CPU used by a transaction and when you emit this transaction you have to pay a fee that covers this gas but there is a limit to how much G you can spend in a single transaction there's also a limit to how much G you can spend spend in a given block but if a contract call exceeds that limit of how much gas you can spend in a transaction the call will fail and this may mean funds will get stuck in the contract so it is very important to make sure that the gas consumption of a contract can't grow indefinitely and exceed that amount to avoid this kind of flaw you have to avoid storing data that can grow indifferently because you have to remember that the store of a smart contract has to be deserialized at the beginning of every call to an entry point and has to be res serialized at the end of the entry point and this cost gas so you need to make sure that you check this whenever you use lists sets and maps and even basic types that can grow IND definently for example strings can be as long as you want or in nuts and Tim stamp in general the idea is to use big Maps whenever you want to store unlimited amount of data because you can have as many entries as you like in a big map you only pay for the distalization and calization whenever you access a specific entry of the big map but of course if that entry is too big then you still could spend too much to diser realize it so it doesn't guarantee that you won't have any issue so make sure you don't store too much in a single entry of a big map another option in some cases is to consider storing data off chain if you don't actually need the data on chain you don't need the smart contracts to have access to it you may store them off chain so for example you could store it on ipfs so the second part to avoid unlimited competions is to avoid Loops where the number of iterations of the loop can grow indefinitely and to avoid that you can usually do the computations off chain and let the contract focus on verifying that everything you computed is correct and when you cannot do the computation of chain another possibility is to split the computations into multiple contract calls so that in the first call you do part of the computation and then in the second call you can continue the computation that might be necessary the best option is to try to do the competitions of chain whenever you can for example let's take a look at this contract this contract called time save can store deposits that will be stored in the balance of the contract and can only be withdrawn by the owner after a certain deadline so whenever you deposit some money fall the owner you set a deadline and you say okay they will only be able to withdraw that amount after this deadline and here we add all the deposits in the list and whenever the user wants to withdraw we Loop through the list find out all the deposits that I have deadline that is expired and then count the corresponding amount and then transfer that amount to the owner so here we clearly have a data structure in the storage that can grow indefinitely someone could make very small donations and deposit many many different amounts but very tiny amounts like one MCR at a time so much so that the size of the list would be so big that diser realizing the data would take too long and exceed the maximum of guys you can spend in a transaction so here are the ideas that this list can grow indifferently nobody can control how much it can grow there are some ways to limit it you could just set a hard limit on how many deposits there can be at a given time and then delete the deposit when you withdraw the corresponding money or you could make it that deposit has to be at least 100 Tes so it would be extremely costly for someone to add so much to make so many deposits that the contract could get stuck but a better approach is to use a different data structure and use a big map here is a version of the contract that use a big map for the deposits we count how many deposits are been so that we can use this as a key for the big map with all the deposits and whenever somebody calls deposit we create an entry with the key being the current value of the counter and in this entry we record the center the deadline and the amount and this way each entry with all the entries in a big map the data structure can never be so big that just calling an entry point would distalize the whole thing and then exceed the maximum amount of gas you can spend in a transaction however we still have a loop here that goes through all the different elements of the big map by trying every possible counter and so in practice we still have to deserialize everything when we try to withdraw so we can of solve the problem for the deposit entry point that can never fail because it's not going to deize the whole content of the big map but then in withdraw we have a loop so the loop itself may have too many iterations and exceed the total amount of gas you can spend in a transaction but more so you will have to deserialize all of the content of the big map so that doesn't solve the problem to solve this problem instead of a loop that goes through all of the elements we can do the computation of chain of which entries have expired deadlines so instead of looping through every single entry in the big map and then checking if the deadline is expired we do that computation of chain and then when we call withdraw we send a list of keys where the deadlines have expired and so the loop here only enumerates all the entries that have been listed in the parameter it could still be possible that the list is so long that we cannot execute the whole Loop but then we can split the call into multiple calls and then maybe do only half of the list so that we only need to Loop through half of them and distalize half of the entry the caller has control over how many items they put in the list so in this case we are safe we avoided using the type of data structure that can go indefinitely by instead using a big map and we avoided doing a loop that can grow indefinitely and instead did the competition of chain and let the user send a list of items they get money from and that solves our problem in this module you will learn how you can reduce the amount of fees you need to pay when using a micro payments contract where you have to perform a lot of transactions to buy lowcost items so the challenge is to create a micro payments contract let's say a person a very often wants to buy cheap items from a seller B and wants to pay using TZ so we will have transactions where user a gives some amount of M to be a small amount compared to transaction fees and then B will give some item to a so a buys an item from B but at a very small price so the question is how can we do that in the cheapest possible way we don't want to have to pay a transaction fee for every purchase if the item is very cheap we might end up paying more inunction fees than what we actually need to pay for the item but we want to do that by still enjoying the security of the block blockchain we don't want B to have to trust a or a to have to trust B but we can allow for a little bit of risk so for example B could accept that maybe they will lose the amount for one sale but no more than one so B might accept that they will lose the price of one item purchased by a but no more than that so with this constraint try to think about a way you can reduce the transaction fees to the the minimum pause the video and think about it for a minute if we really want to avoid paying too many transaction fees the best way is to avoid doing transactions at least onchain every time you do an onchain transaction you need to pay a fee but we could handle most of these transactions of chain using signed messages the idea is that we would create a micro payment contract where user a will put some amount of test a deposit on the micro payment contract that it is reserved for A's future purchases from B so that amount is really strictly reserved for B and we set a deadline the idea is that a May withdraw those funds but only after that deadline so the idea is that b knows that there is some amount for them that will be available in the contract until that deadline once we have that deposit in the micro payment contract every time a wants to purchase an item from b instead of doing a transaction on the chain and calling the contract and paying the fee a will send a signed message to b so a message would say I hereby declare that I owe you this amount of money more precisely I can say the amount I owe you is now X mutes signed a and of course the signature will be a cryptographic signature that a smart contract could verify so this message is directly sent to be off chain without going through any smart contracts any way they could be by email could be any means and then once B receives that message they have a proof that a owes them money and so they can send the corresponding item to a whenever B wants to get paid whether it's because the deadline is getting closed so they want to make sure a doesn't withdraw the deposit from the contract or whether there's quite a bit of money or that they want to to have and they are ready to pay a transaction fee to get that money then B could call the macro payment contract and sendeth the last sign message signed by a that says I owe this mat to be the smart contract could then verify the signature and if the signature is valid then the contract could send whatever amount a owes to B so to do that we need to be able to sign and verify signatures on tesos you can sign any piece of data as long as it is in the form of a sequence of bytes that's the only type of data you can sign but thankfully we can convert pretty much any data to a sequence of bytes and back we can use the pack instruction to convert type data into a sequence of bytes and later we can unpack this content to extract the typed content so it could be a record for example we pack the record we just get a simple sequence of bytes then later on we can unpack it and get the record back once we have a sequence of bytes we can use a function called make signature to generate a signature for a given sequence of bite and of course we use a given private key to generate this signature on the other side the destination of the message can use check signature to verify the validity of a signature verify that it corresponds to the public key of whoever is sending it so let's look at the syntax to pack and unpack data it's pretty straightforward you can call sp. pack of your type data could be almost anything could be a number could be a record could be a list anything you liked and then you get a pack data that is of type B then you can unpack this data by calling sp. unpack you pass the data and then you pass the description of the type of this data this returns an option it could be done if it's impossible to unpack this data into this type it could be a different type so we use unwrap sum to get the original data back once we have packed data we can use make signature to create a corresponding signature and we pass the secret key of the user and the pack data and we obtain a signature when we want to check the signature we call sp. check signature we pass this time the public key of the user who is supposed to have signed this message we pass the signature and we pass the pack data so this verifies if the signature corresponds to this pack data signed by the person who has this public key we don't need the secret key to verify the signature and this returns true if this is indeed a signature that corresponds to this message and this public key with that your job is to write the corresponding contract with its tests the storage will simply need to contain a big map with all the deposits what is the key and the value for each entry is up to you and we will have three entry points one entry point for someone to deposit some funds for a given seller so we say who are these funds for we set a deadline after which we will be able to withdraw the money back and we send our public key so that we can sign messages and have the contract verified that they come from us so whatever amount is sent to deposit sp. amount will be stored as a deposit from the center to this destination so we create an entry in this big map or update it if there's already one when seller wants to get paid they can call claim payments they say I want to get some funds from this user and here is the message they last sent me and here is the corresponding signature so the contract will check that the signature is valid for this message so the signature is indeed a signature for this message using the public key we stored for this source so the public key we passed here once it checked that the to valid it can transfer the amount that the source owes to the caller and then it will update the corresponding deposit entry finally when a user wants to close their account and withdraw their Deposit they say I want to close my account that I have with this seller so we fetch the corresponding entry in the big map we check that the line has passed and we transfer any funds that haven't been withdrawn yet here we purposely left some details for you to work on so your goal is to implement this contract and try to make sure that there is no flaws that somebody could use to steal some funds or get funds stuck pause the video and give it a try let's look at a potential solution here in the deposit big map we will create entries where the key is composed of the source and the destination so a deposit is really some funds we store for our source and a destination so it makes sense to have an entry for each pair source of destination here we use the record we could also use a pair as a key then we check if there's already an entry and if not we create one we store the deadline the amount that was sent the public key and we also store how much has been spent so far out of this amount and if there is already an entry we verify that the new deadline is after the previous deadline we can only extend the deadline we cannot bring it closer to the present otherwise it would be too easy for a to get their money back even though be trusted that that money would be available in the contract so we can only extend the deadline and here we update the deadline and we add the newly deposited amount to the amount stored in the deposit once there is a deposit for some user reserved for Destination then this user and this destination this seller can freely exchange messages where a sends messages that says I now owe you this much and then B says okay then I can send you this item Etc and the amount a owes to be increases increases and when the deadline gets near or when the amount is quite a bit and B wants to get it out of the contract B can call claim payments they I want to claim the payments from this source and here's the last message that sent me this last IO you and here is the signature that proves that it comes from them so we get the key for the corresponding deposit then we check the signature so we check that this signature corresponds to this pack message with this public key so it has indeed been signed by the public key we stored for this user then we unpack the message and in the message we store the destination and how much the author of this message owes to this destination so the total they owe so far since the beginning which check that the destination is the person who's claiming the payment then we compute how much they need to pay to them now and that amount is the amount indicated in the message so how much I owe you so far minus how much we already sent them before so how much they already spent in the previous message so the idea is that a always increases the amount they o to B since the very beginning because if a sent I ow you 10 more tests than last time we would need a complicated system to track okay when was this message sent how much did we owe last time Etc it would be hard to really know how much we need to send to B but if we simply accumulate how much a has pened in the beginning and then how much we already took from the deposit and send to B then it makes the computation simple so the amount we need to pay is the amount AO so far minus what we already got from them we make sure they have enough in their deposit to pay for that amount if not that means B accepted payments for which there was no corresponding deposit so B made a mistake and they could maybe send a previous message where a didn't owe as much then we update the amount in the deposit we subtract the amount we are paying to B we increase the total amount that we are paying to be so far we add amount to pay and then we send that amount to the sender so send that amount to the seller to B finally when a wants to close their account we fetch the key we check that this is after the deadline and then we send whatever is left in the deposit and and we delete the deposit in the test we create different accounts and here in the test we create a deposit from Alice that deposits 100 t for the seller Bob with a deadline a th000 then when Alice wants to spend a little bit of money and purchase something from Bob she can create a message that says I know all five T to Bob she has to pack the message and then sign it with her secret key so this is done offline she could send more and more of these messages increasing the amount every time by the price of the item she wants to purchase and then eventually when Bob feels okay now it's time for me to get paid Bob will call claim payment saying I want to be paid using the deposit from Alice here's the last message I received here is the Corr opening signature I'll is sent me and Bel gets paid we can give it a try and we can see that indeed Bob gets paid unfortunately there is a big flaw in this contract pause the video and take a minute to try to find it there's a couple similar flaws in this version of the contract the first one is that if Alice closes her account we delete everything and later on she decides to do some business again with Bob then she would deposit some money again saying okay I'm depositing some money I want to make new purchases Bob could steal her money can you figure out how pause the video and think about it for a minute so the issue is that if Bob saved this message and the corresponding signature Bob could send the message again to claim payments and get the same amount again Alice didn't make any new purchase but Bob still has a copy of this IOU 5 test from Alice and the signature is still valid the message is still valid so claim payments would simply send the five test to Bob now how can we avoid this pause the video and think about it for a minute so what we really want is to make sure that the same message cannot be used Again by Bob there's a couple ways to do that one way would be to never a close deposit here instead of sending everything and deleting the deposit and resetting everything and then forgetting that there was already a history between Alice and Bob we could simply reduce the amount deposited to Z but keep the record in our big map this way we remember that the amount spent so far is already five TZ so if BB sends a message that says Alice owes me five TZ then we check well you already received five test from Alice so there's nothing Alice owes you and if Alice wants to make a new purchase she would have to say okay I now owe you five plus xas then Bob could claim the extra xas so that's one way to do it never to close the account another more typical way to do it is to make each deposit entry a bit more unique by adding some information adding a counter similarly to what we do to transactions if you remember a description of how transactions are verified transactions have a signature but to avoid transaction being replayed we add a counter to each transaction that says how many transactions has this user signed so far so we could do exactly the same here when we deposit we could add some counter that we store and that the author of the deposit should increment every time they deposit some money if we are simply adding to the existing funds we shouldn't count the counter this is a counter of how many times we recreated the deposit and then when we claim payments in the pack message we should have the value of the counter and here we could check that the counter for the message equals the counter for the deposit of course when we sign messages we need to add a counter as well so if we close the contract created a new one then we would use accounter two so that messages for a given deposit cannot be reused next time we recreate a deposit and here when we deposit we have to send the counter so counter all good but we still have a flaw and the flaw comes from the same idea of the same signed message being replayed being reused in a different context so now that we have this Contra in the message that says okay this is the third time that we create a deposit and so everything should be reset and every message from previous deposits are not valid anymore but still it would be possible in some cases for Bob to steal money from Alice pause the video and think about it for a minute so the issue here is that we could have multiple instances of this micro preman contract and there is nothing in the messages that says that those messages are about this contract so we could even imagine that a very different contract just happens to have a structure of messages that contains a record with a destination with an amount and with a counter that would have nothing to do with micro payments it's just used for something else and then Alice and Bob happened to be using that other contract so using a message with the same structure for a different contract Bob could call claim payments and extracts funds from this contract that has nothing to do with this message and the way to solve that is to add to the message the address of the contract that we are talking about so here we would need to add contract equals micro payments address to make sure this is about this contract and then here we would get Contract sp. address and then we check message. contract equals sp. self address this time a message dist to a different contract couldn't be reused in our contract this makes everything a lot safer so this idea of always having some kind of Contra in the messages and identifying for which contract the message is and really making sure that the information is complete that says everything we need to verify then you can avoid this flaw of being able to replace signed messages in this video we'll look at a smart contract that enables people to play a geocaching game and will will discuss a number of potential flaws in this smart contract geocaching is a game where one person hides one or more Little Treasures somewhere in the world it could be anywhere and then they publish hints about the location of these treasures and the players use this hints to try to find those items so here the goal is to create a smart contract that makes it easy to play this game for each treasure we assign a unique identifier and a password so if you find the capsule containing a treasure you can call a contract to prove that you indeed found the treasure and the password and ID that it contains and so we could make it into a game where the person who finds the most Treasures gets a reward so the interesting part in this contract is that we will need to be able to verify that a player found a given password but we can't simply store the passwords directly in the contract as we discussed before the storage of the smart contract is public so if we simply store the passwords in the contract anyone can simply see the password and then send them to the contract and pretend that they found the treasure so the question is how can we verify passwords without storing them pause the video and think about it for a minute so a typical way to verify passwords without saving them is to store the hash of the passwords that's what most authentication systems use they store hashes of passwords typically with added salt so that they can authenticate users without keeping the actual password in the database so here we will use a cryptographic hash function that we apply to passwords and those have a few key prop properties for the same input they always produce the same output that we call the hash of that input and if you're given a hash it is virtually impossible to find an input that produces this hash unless you actually know the original input or unless you try every single possible value which typically would take way too long for anyone to ever find the correct input value so the input value here the actual password that we will hash needs to be large enough that it's impossible to simply try every single password and check if it gives a given hash so instead of comparing the password to a store password a contract can verify a password by Computing its hash and then comparing it to the stored hash so let's take a look at the first version of this mod contract in the storage we will keep a big map with all the treasures and we will see that for each treasure the key is an identifier a simple number that we increment every time we add the treasure and the Valu is a record that will contain the hash of the password and a flag that says if somebody found this treasure then we will keep the scores of the different players so for each player we will keep their current score we will maintain the address of the current winner we initialize it with the owner's address and then we also need to initialize the score of the owner to zero so that as soon as somebody finds a treasure they can become the current winner and we can compare their score to the score of the owner we separately store the address of the owner we store a deadline after which we will give the award to the winner and then uh we count the number of treasures the owner is able to create a number of treasures and all he needs to send to the smart contract is the hash of the password we check that he does that before the deadline and that only the owner can call this contract we increment the number of treasure and then we store the information and say this treasure has not been found yet then when somebody discovers a treasure they need to send the ID of the treasure and corresponding password so we check that they do so before the deadline we obtain information about the treasure we check that it hasn't been found yet then we compute the hash of the password was send Using sp. blake2b and we compare it to the hash of the treasure if it's correct then that means the treasure has been found and we just have to increment the score of the player so if there's no entry for that player in the big map we create one with score zero and then we increment their score by one and if their score is more than the score of the current winner then they become the new current winner finally after the deadline the owner can call this award prize entry point we check that he does so after the deadline and then we simply send the whole balance of the contract to the winner so whatever the owner decided to send as a reward when they called for example pre treasure and then we have a test where we check that everything goes well now unfortunately there are a couple of flaws with this contract pause the video and try to see if you can figure them out already to help you remember that flaws in smart contracts can typically have two types of consequences either someone can steal some value from the contract and other users or some value can get stuck in the contract pause the video and try to see if this helps you find the bugs in cashing contract so the first flaw is that you can have funds stuck in the contract and this is due with the way that the award prize entry point has been implemented how could this piece of code make it so that the funds are stuck in the contract what could possibly go wrong and think about it from the point of view of the winner how could your funds get stuck after you won the game pause the video and think about it for a minute well the issue is is that here for the winner to get their prize we need the owner to call the entry point but you could imagine that the owner doesn't call the entry point for a number of reasons for example they could simply forget to call that entry point or they may be unable to call it for example what if they lost their private key and they could also do that on purpose they could say okay I'll give you your prize but you have to do this for me and they could try to extort money from the winner before they give them their price here they would be able to weird but that could be one of the reasons why the owner doesn't call the entry point that Awards money to the winner and you could say well that's the organizer of the price I mean yes if the organizer of a game um is not available anymore and decides not to play well yeah it's okay to imagine and in this kind of situation the winner wouldn't get their prize but the whole point of a blockchain the whole point of using smart contracts is to avoid having to trust that some specific person will do what they are supposed to do we don't want to have to trust a third party and here we don't want to have to trust that the organizer will do what they're supposed to do so the question for you is how can we solve this how can we make sure that we don't have to trust the owner pause the video and think about it for a minute the solution is simply to let the winner or actually anyone call the entry point themselves there's really no need for it to be the owner we simply verify that the deadline has passed and then if it has and somebody calls that entry point then we send the funds to the winner so the best practice in your smart contract is to avoid unnecessarily requiring that a specific third party performs an action if there's really no need for that to be the owner of the contract or someone else then just don't verify it and let anyone call the entry point so here we can simply delete that line and everything still works just fine even if the owner forgets to call that entry point so that fixes the first flaw now the second flaw is that somebody can actually steal money that should go to someone and by that I mean somebody who didn't find a treasure could still become the winner so posi video and think about how you would do that how could you claim the prize without actually having found any real treasure so the second flaw is due to the fact that all transactions are public so as soon soon as you send a transaction to a node you can assume that everyone can see it it will be known by whoever owns that node then this node will send the transaction to all its neighbors and then to other the neighbors Etc so all the nodes will receive the transactions before it's even considered for being added in the block and if you send the password and the ID in your transaction then everybody sees your password so anyone can create their own transaction with the same password and pretend that they found that treasure and to make sure that they get the point and not you they can add a fee for their transaction that is a bit higher than yours so that the baker is more likely to take their transactions first before they take yours and they will get the point and you won't this kind of attack is what we call bpev flaws block producer extractable values and sometimes also calls me maximum extractable value so the idea is you can have Bots that always analyze all the transactions that travel through the peer top Network and they analyze those transactions to see if there's any valuable information in in there and especially they simulate what would happen if they perform this transaction from their own address and if the outcome of that transaction benefits them if they see that after the transaction is over their balance has been increased then will emit the transaction but with a higher fee than the original one so there's whole bunch of bots on all blockchains that look for this kind of transactions and then copy them and send them again but with their own address and a slightly higher fee and so since you have many different Bots that do that eventually the fee goes up and up and up right up to the Limit where it's not profitable anymore to keep increasing the fee so in the end it's likely to be the baker who will make the most profit because they benefit from that higher fee so that's why we call it block producer extractable value because whoever creates the block gets all the benefits of these increased fees and the baker the block producer can even make sure that they are the ones whose transaction is taken because they get to pick which transaction are added to the next block so they could just decide okay I'm going to get the treasure I'm going to be the one creating a copy of this transaction and getting the benefits so one way or another the block producer is able to take advantage of this flaw so here someone who didn't find the treasure could just look for the password in one of transactions and then claim to have fun the Treasure by sending the same password but with a higher fee so the question is how can you protect your contract so that this kind of attack wouldn't work pause the video and think about it for a couple of minutes so to protect against block pess or extractable values there are a number of approaches and none of them is ideal but we can try to find one that would work well for this construct a good way to think about this is to try to imagine that you're in a real room with a number of people and there's a transparent box in that room and your goal is to go around and find treasures and when you find them you need to put a piece of paper in the transparent box and and so you can write the password on a piece of paper and you add the ID of the treasure and your name so that you can claim to be the first one who found that treasure and of course you destroy the password so that another person cannot claim it and then there are will be 10 minutes until the game master opens the box then this game master will look at all the messages and check the passwords and count who found the most Treasures so if you imagine this situation how would you make sure that other people don't copy your password that they can see through the transparent box so that they can lie and claim that they found that treasure and if you can think of a way to do that in this room with this transparent box think about a way that you could apply this idea to a Smart contract pause the video and think about it for a minute so the solution would be that as you write the treasure idea the password and your name to a piece of paper to prevent other people from copying it you would just simply fold the piece of paper this way the game master would have to unfold each piece of paper before counting who found the most treasures and you would make sure that once the game master starts unfolding the pieces of paper making them visible for everyone you wouldn't let anyone else at their own piece of paper to the box so this way as the pieces of paper are folded nobody can read them until it's too late to add a piece of paper in the box now how could you do something similar in your smart contract on the blockchain pause the video and think about it for a minute so one way we could do this would be to encrypt that information so instead of sending the treasure ID password and your address as a clear message in a transaction you would first encrypt it of course the contract wouldn't be able to know the decryption key because anything that the contract knows is public so you cannot have a key in the contract that they would use to decrypt that information so instead you wait until the deadline is passed and then you send the description key so that the smart contract can extract the value from your encrypted message so this way you have to know all the information so that you can encrypt the message before the deadline and then after the deadline you reveal the message by sending the key that you use to encrypt it so that the smart contract can decrypt it and check if you did indeed find the treasure it's important to include your address in this encrypted message otherwise people could still copy a transaction and send the same message and later send the same decryption key so this approach would work but it's a bit costly because encryption functions are pretty costly so you don't want to run them in the smart contract can you think of another way to do that similar way but that may be a little bit less costly pause the video and think about it for a minute so a second approach to solve this but very similar is what we call the commet and reveal scheme and the idea is instead of encrypting the information we simply send a hash of the information and then in the second phase we send the actual information so we have two phases the first phase is the comet phase where each player can s the hush of their message containing the ID of the treasurer the password and their address and then we have a reveal phase where after the deadline each player can send the message itself then the contract compute the hash of the message compare it to the one that the user has sent before and if it is correct they canward the point to that user and Computing a hash is less costly than using any encryption algorithm but it's actually possible to make it even faster and to help you think that the best way to save gas is to do as much as you can offchain rather than onchain so if there's any competition you can avoid doing in the smart contract itself but instead do an offchain then you can save a lot of CPU therefore guys pause the video and think about it for a minute so the third approach is to still use this commit and reveal scheme so you still commit before the first deadline by sending a hash of the message with the ID the password and your address and then you steal reveal after the first deadline where every player sends the actual message but instead of immediately having the smart contract check if the hash corresponds to their produced message you let other players check themselves and if they see a message from a player that doesn't correspond to the hash that this player sent earlier then they can call an entry point to to say hey this player is trying to cheat they're sending a message that doesn't correspond to the hush to sent earlier and if the player indeed cheated then the smart contract can check verify yes indeed this message doesn't match the hash that they sent so I will eliminate them or maybe even punch them so this way we don't always check and compute the hash to verify that the hash of the message corresponds to the hash that the user previously sent we only do it if somebody complains so we have a second deadline and people have some time to complain before we award the prize in practice you can expect that nobody will try to cheat so the actual computation of the hush will never need to be done so let's take a look at the updated contract so here on top of the treasures and score per users we store for a big map with all the comments that people make once they find the treasure and we also keep a value of a deposit that every player will have to send to the contract as their register this way they can be punished if they do something bad and other people can be rewarded for denting anything bad that they did so we'll see that in a minute and then this time we will have three different deadlines the deadline for people to commit the hash of their message the deadline for revealing the actual message and the deadline for other players to dispute a message if they think somebody tried to cheat we add a register player entry point so that people can register before the deadline to commit and send their deposit and we use this as an opportunity to set their score to zero then we still have our create treasure and point for the owner to create treasures and they still store the hash of the password then once somebody finds a treasure they can send a hash of their message to this commit discover treasure entry point so they send the IDE of the treasure and the corresponding message and this is a hashed message so it will be of types sp. bytes we check that the owner themselves cannot uh play so we don't allow the owner to commit a message we check that this is before the deline to commit we check that we didn't already receive this message this is not really necessary I can remove that then we Mark that we received that comment then we have the entry point that people call once the comment deadline is passed and it's time to reveal their message and this time they send the actual password we check that I do that before the deadline to reveal we get the corresponding treasure we check that the treasure has not been found then we Mark the treasure as found we store the password for this treasure and we also store the player who found it then we increase the score of that user assuming that they are not lying that they actually did send a password that corresponds to their previous comment and we check did they get more points than the the current winner and if they did then we store them as the new current winner but now if somebody says hey this person claimed to have F found this treasure but that's not true that's not the case somebody else found it then we can call this dispute Discovery entry point we check that it's not too late to dispute it we obtain the corresponding treasure we check that indeed somebody claimed that they found it then we check did the password that Des send actually correspond to the password for that treasure so does it match the hash of the treasure we didn't even check that they sent the right password when we called reveal this discovered treasure we assume that the person can be trusted but here somebody disagrees so we check did they send the right password so we generate the message that they should send that includes the password and the address of the user so whoever claimed one we compute the hash and we check that indeed this person didn't commit a message corresponding to this hash so that means this whoever is disputing is correct because the hash of that message was not committed then we simply eliminate that player if that have not already been eliminated by someone else and then we send the deposit from that player to whoever calls this a dispute entry point if that player was the current winner then we reset the current winner to the owner we Mark treasure as not having been found so that if someone else has actually found it they can reveal that they found it so they can call the reveal discover treasure if it's still not too late and to make sure they have time to do so we add some time to the reveal deadline an hour and we also add one hour to the dispute deadline so one issue here is that we don't have the winner anymore and we cannot Loop through all the different scores to see who is the new winner now that we eliminated someone so we have to add an extra entry point update winner where we will check this is before the deadline to dispute anything and then we check that whoever is calling this actually has a higher score than whoever is marked as a current winner and then if they do then we update them as the new current winner so anyone can say hey I'm actually the winner look my score is better than Whoever has claimed to be the winner so far finally when the deadline for the dispute time is over then the current winner can claim their funds so the code here and especially the code of dispute discover is a bit more complicated but in practice since there is a way for anyone to tell if you cheit it and you will be punished if you cheit it this part of the code is very likely never to be executed so you won't pay for the cost of it but you need to make sure that there's no bug in there so as you can see preventing block producer extractable value can be a bit complicated make the code a bit more complicated but this is necessary to make sure nobody steals your funds it's actually still a way to cheat at least in some situations and this way is to prevent people from scoring P TR Treasures that they found but this can be costly so can you think about it for a minute and find a way that somebody could prevent you from getting the points for your treasure if they're really motivated to make sure you don't win pause the video and think about it for a minute so that approach that can be used in some situations is to actually attack the blockchain itself preventing some transactions from going through by sending so many transactions that the these users transaction may not be accepted and for that you have to keep in mind that Bakers typically select the most profitable transactions and most profitable means you add an extra fee on top of the minimum fee that you should send to pay for the gas so this means that if you send enough transactions with relatively High fees you could prevent legitimate transactions from being added to blocks so if you send many transactions with high fees you will feel the blocks until the deadline and none of the regular transactions will be added unless somebody notices and pays a higher fee this would be very costly but if there's just a little bit of time left for other players to submit their Treasures they find at the last minute then it could be worth it depending on what the reward would be so the different ways to avoid this kind of situation uh can be to give enough time between deadlines for this to be really expensive of course you could always prevent people from submitting their commit or reveal at the very last moment but then it's up to them if they don't do that so make sure you give people enough time so that nobody can block transactions during the whole window of time and another way to avoid this is for players to be a baker themselves so that they can make sure they give priority to their own Comet and reveal transactions and so this could be either if you're the owner of the contract and you want to make sure nobody can do that for your contract you can be a baker and then once in a while you make sure the transactions for your contract are accepted so that you can guarantee that your service is always reliable but of course anyone Els players themselves could make sure they are Bakers so that they can do that themselves so when the stakes are high it makes sense for big entities that uh rely on Smart contracts to be Bakers themselves so that they can make sure that their transactions go through in this module we will talk about Randomness picking random numbers in a smart contract is a very interesting but hard problem so let's say you want to organize a raffle where every participant can register and pay 100 Tes and after a deadline one of these participants is picked randomly and they get the whole balance of the contract as a prize so the questions for you are how would you structure this contract what would you store what would be the entry points Etc and most importantly how would you pick the winner among all these participants pause the video and think about it for a minute the structure of the contract itself is relatively easy in the storage you will store all the participants you need to use a big map to avoid any gas issues and the key will be an ID and the value will be the address of the participant for the idea we will simply use a counter and we will count the number of participants so a natural that we initially set at zero and every time a new participant registers we will increment this value then we set a deadline for everybody to register now we have two entry points one for participants to bid where we check that they do indeed send 100 test to the contract we check that they do that before the deadline we assign their address to their ID so the current number of participants and then we increment this value by one so we basically register that they participated in the raffle finally after the deadline they can claim their prize whoever is the winner will be able to claim their prize we check who the winner is by picking a random value between zero and the number of participants minus one and then we send the balance of the contract to the corresponding participant so that's for the structure now the hard question is there is no such random function available on tesos so without such a function how can you pick the winner pause the video and think about it for a couple of minutes in a regular program you run on your computer when you pick a random number it usually consists in calling a function that uses a mathematical function that produces a randomish sequence of numbers so we show here an example of such a basic version of a function where you take the current value you multiply it with a big prime number you add some value Etc and then to make it between zero and some value you take the module of that value and then to make sure that every time you run the program you don't get the same sequence you initialize with some randomish source of entropy and we typically will take the current time step because on the regular computer that can be in micros seconds so that changes all the time and it's hard to predict so the question is can you do that in a smart contract using sp. now for you seed and if you can or cannot try to think about why pause the video and think about it for a minute so using sp. now as a source of Randomness to initialize the seed of your function is a terrible idea first the value of sp. now is expressed in seconds so there's really nothing not much Precision it doesn't change too often and since you have blocks every 15 seconds there's really only a few values that are possible for a given block but more than that the baker of the previous block actually gets to pick the exact value so it's not random all all it's just some person on the computer I mean their computer picks it one way or another but the baker has control over that value so the idea is that in practice the value sp. now is not the actual time stamp of the current Block in the sense of when was this block created it's actually 15 seconds plus the actual creation time of the previous block and the idea is that in each block there's really two time stamps there's the time stamp that's the actual time where the block was created at least according to the Baker and then there is the value of sp. now that is 15 seconds plus the time stamp of the previous block so really the baker of the blog to pick what will be the value of sp. now in the next blog so in practice when you look at the actual value of sp. now it tends to be every 15 seconds so it makes it extremely predictable which makes it a really bad source of Randomness it can be predicted and it can be controlled by a baker okay so now that we get this idea out of the way can you think of any better ideas pause the video and think about it for a minute some ideas people tend to have have is to use hashes as sources of Randomness when you look at a hash it looks pretty random you just change one bit of the input and it changes everything in the output so it looks pretty random but be careful it may look random it's actually very predictable if you know the input of course the output will always be the same but more than that just like the time the baker can manipulate it because the hash of a block is really computed based on the content of the block based on what transactions they are and so if a Baker wres a block with a number of transactions then compute a hash and somehow that hash is not good for them it will not produce the right random number when you run the smart contract then they could just try a different set of transactions to obtain a different hash for their block so they do have some control on the value of the hash simply because it can make multiple attempts at traing a block and it will give different values for the hash therefore different random values for who is using this hash as a source of Randomness another reason why you shouldn't use the hash of a block as a source of Randomness is simply that you cannot access a has of a block from a smart contract so this is clearly not a possibility another idea would be to deploy a contract because when you deploy a contract from a smart contract you can obtain the hash of the operation that is created and this is something you can do from within the smart contract unfortunately the value of this hash depends on different things that the baker can control so the baker again can manipulate it in the same way as the hash of the block so we cannot use that as a source of Randomness finally an idea people sometimes have is to use the address of participants but if you do that for example if you add up all the addresses of the different participants to compute a random number then whoever is the last participant to consider bidding can predict the outcome of their choice they will see okay if I bid here's what the outcome will be by adding my address to the total number so they can decide if they want to bid or not depending on whether it makes them win so the address of participants again is predictable and so the results would be not only predictable but controllable by some participants so that wouldn't work either another idea people tend to have is to increase the Run as by mixing different values some ideas people have is to get the exchange rate between two currencies for example the current exchange rate between the Euro and the US dollar and you would say well if somebody could control that then they could be rich and obviously nobody can control precisely what the exchange rate will be on the Dex but then you cannot predict it within maybe a few tens of percents but of course you can predict the main value so you don't have too much Randomness that come out of that just just a few bits then you say okay I can combine that with other sorts of Randomness for example other pairs of currencies this is something you should be careful about when you try to combine different sources of Randomness you get more bits of Randomness for sure so you increase the range of different values you can pick from but the whole result is actually as weak as the weakest of these sources so if somebody can manipulate one of the exchange rates one way another then they can manipulate the outcome so it's actually dangerous from the point of view of making sure people cannot control the outcome to mix multiple sources of Randomness another issue is that the exchange rate of a decentralize exchange can be manipulated for example you could do a couple of transactions you could first buy or sell one of the two currencies of the Dex that may impact the exchange rate if you buy dollars it makes dollars a bit more expensive and then if right after that you call the contract that will compute the random number then your initial call will impact the results of your random number selection since everything is deterministic you can compute in advance what the impact of any peress of sale of currencies on that de will have as a result so you can just try different values and see which one generates the random value you're looking for so you can control it and know exactly in advance what the outcome will be so that doesn't make it a good source of Randomness either another idea people can have is to use a Randomness Oracle so rely on some offchain source to generate that random number but it's not as easy as it sounds if you use a basic oracles just some guy who's sending random numbers to a Smart contract and whoever that person is controls every single number and if they forget to send the number you are also stuck so this can be dangerous so you could use more advanced oracles such as chain link vrf verif fireable random functions this could work if it was available from tesos but you're basically moving the problem away the kind of problem that chain link has to solve is exactly what we trying to solve here and even in that case you should be very careful about trusting this kind of oracles sometimes there's possibility for collusions between different people that make it not as random as you would like finally as we discussed in oracles you can use a trusted execution environment Oracle like Acuras this may be the best solution based on oracles at the moment but again you need to make sure that the whole solution is safe and it's not always easy to have all the details about a given oracles to really be convinced that the randomness is really secure but this last option might be the best for an Oracle that produces random numbers at the moment on tesos but what we really want is to make sure nobody in particular controls the random value and that you don't need to trust some entity to keep producing those random values so we want to use a decentralized source of Randomness how can we do that it's actually possible so the idea is for multiple users and here it could be the participants in the ruffle to cooperate and produce a random number together and the hard part in that is to make sure that none of the participants can manipulate the outcome and make it be something they like so to try to think about a decentralized way to do that try to imagine that you are in a room in a physical room with 10 people and there 10 people you have no dice no coins Etc you just each have a pen and a piece of paper so the question is in that situation how would you generate a random number that none of you can control pause the video and think about it for a minute so one way that people could pick a winner among themselves would be if each of the 10 people could assign a direct number to each of them so one way to randomly pick a winner among those 10 people is to First assign a direct number to each of them from 0 to 9 then each of them would write a random number on their piece of paper and show it to everyone then each person could write a number on their piece of paper and show it to everyone then anyone can sum all these 10 numbers and obtain a big random number then you could take the last digit of this number of the sum which would be a value between 0 and 9 and that gives you the winner would this work try to think about issues with this approach pause the video and think about it for a minute so the issue is that someone could cheat and control the outcome if they wait for everyone to reveal their number and if they're fast at Computing they just quickly sum up all these numbers the nine other people to obtain the current total and then from that it can decide what number they should give so that when they add this number to the total it gives a result that makes them win so that's pretty easy to cheat how can we avoid this pause the video and think about it so the solution is to use something we presented earlier with the geocaching smart contract we want prevent users from changing their numbers once others start revealing theirs so in our physical room we could have each person write a random number on their piece of paper that do so discretly and then they immediately turn the paper over to hide the number from others or they just fold it in half and then when everybody's done writing the numbers we ask everyone to put their pencil down so that they cannot change their numbers anymore and once it's all done every participant can reveal their number show it to everyone and then everybody can sum up the value and pick the winner if we do that there's still a flaw in this process can you figure out what it is pause the video and think about it for a minute so the issue is that someone could decide not to reveal the number to help a teammate so let's say we have these 10 users numbered from 0 to 9 and they all already committed a random value from 0 to 9 that we have here but then two people Eve and Gwen have not revealed yet but let's say Eve and Gwen are actually friends and teamed up and they already waited for everyone to reveal and they know okay the current total is 33 now they get to decide okay if Gwen reveals her number but Gwen doesn't and we just add all the numbers that we revealed before the deadline then we add 33+ 4 so the total would be 37 that would make Iris win so in the last digit would be seven but if Eve reveals her number but Gwen doesn't then the total would be 35 and Gwen would win so by doing this just deciding who between Eve and Gwen reveals then they can decide the best strategy to increase their chance of winning so basically the two of them can generate three outcomes that gives them a chance at winning either are they both reveal so we get 2 + 4 or only Eve reveals so we get two or only Gwen reveals so we get four that we add to 33 and for each of these three possibilities it generates a different outcome a different winner so they can pick out of these three possibilities which one is the best for them and the question is how can we avoid this issue so the idea here is to force people to reveal to make sure that nobody is going to want to use this strategy the first approach is to use a financial incentive you ask each player to deposit some extra money on top of their bed at the beginning of the game and if they don't reveal they simply lose their deposit so they have a very strong incentive to reveal because otherwise they would just lose some money but then the question is how much would this deposit be and the issue is that for this to work as with just a few people that can control the outcome if you have 10 people in a team out of 100 people who bid 10 people can generate 1,023 different outcomes so they're very likely to have one strategy that makes one of them win so you pretty much want the deposit to be as large as the reward so if it's a big ruffle where you can win one million test nobody will want to deposit 1 million test but this could work for a small ruffle there's another approach that is using Brute Force then we will see in a moment if it's in the the physical room we have someone steal Gwen's paper and reveal it for everyone I would call that brute force and we can actually give people an incentive to that if Gwen doesn't reveal we can reward that person with Gwen's deposit so if we can do that when one dare to cheat so then the question is how can we do this on the blockchain we've already seen it in the geocaching smart contract if we use incentives but no BR Force we can use a set of phases and deadlines so we have a registration phase where participants bid and deposit T each participant is assigned a number then we have a comment phase where each user gets to pick a random value and they send a hash of that value to the contract we have the revealed phase where each user sends their chosen value this value must match their hash finally after the reveal phase ends and everybody revealed the winner can collect all the bits and then everybody who revealed gets their deposit back so your job is to write a smart contract that uses this approach to organize a raffle pause the video and give it a try let's take a look at the solution in this raffle contract we store the bid amount so how much people need to bid to take part in the raffle then we store how much they need to deposit for the financial incentive then we store two deadlines the deadline for them to commit the hash of their random number and then the deadline for them to reveal the random number they picked that corresponds to the hash in the big map we store all the information about the players we will store the address we will store the hash of the random number and we will store whether they're already revealed or not then we store the number of players and this will serve as a key for the player big map then we'll store how much has been deposited how much has been bid so that we can know what the total price will be and then we have a total that will be the sum of all the random values finally we need to keep track of how many people have revealed then the bid entry point this is the entry point that people call during the commit phase where they need to send the hash of the random value that they picked they need to send their bid and their deposit so we check that the amount is equal to the sum of both they need to do so before the deine to commit so we check that then we store all the information about the player address the hash of their value and they haven't revealed yet we can then increment the number of players and update the total amount of the deposits and the total amount of bids in the next phase the reveal phase each player has to reveal their actual random value since we use an ID as the key for players we ask people to send their ID instead of sending their address for and they can easily find it out of chain we check that they call this entry point before the end of the reveal phase we check that they have not revealed yet otherwise they would be able to reveal multiple times and then manipulate the outcome we check that the hash of the random value they sent is the same as the hash that they sent during the commit phase then we Mark that they now have revealed we update the total of the random numbers by adding their random value then we increment the number of people who revealed after the deadline to reveal the winner can claim their price so we check that they do so after the deadline then we determine who is the winner to do that we divide the total of the random values by the number of players and we take the remainder using sp. mod and this gives us the ID of the wi of the raffle we fetch their address we make sure they're revealed if they did reveal they cannot win so they cannot claim the price then we compute how much we need to send to them so we send them the price the total amount of bids plus their share of the deposits so the idea is that if somebody didn't reveal they don't get their deposit back and we share it among the other players so to send their share to the winner we divide the total amount deposited by the number of people who revealed using split tokens so they get a fraction of the total deposit one over the number of people who revealed we send them that amount and then we delete them from the players so that they cannot try to claim the prize again then we have an entry point to send their deposits back to players who did reveal but didn't win we don't need to check who is calling it it doesn't matter I mean most most likely they will be calling it but there's no need to check it they need again to send their ID we check that they try to get their deposit after the deadline we make sure they're revealed we get their address and then we need to compute the amount that needs to be shared between the players who revealed to do that we take the total amount of deposits but then we need to find out if to that total we need to add the price if there is no winner if the winner didn't reveal then we need to share the prize between all the players who did reveal so we compute again similarly as here the ID of the winner we check if they are still a player if not that means they already claimed their price so we don't need to worry about uh sharing the price and if they didn't reveal then we add the total price the total of bids to the amount to share then we divided the amount by the number of people who View field we send it to the user and we delete that user from the players to make sure they cannot claim again then we have a test where we have a few people play commit their hash of their numbers then reveal them and some don't reveal and then the winner can climb their price Etc it's a small test in a real test you need to do a lot more than this to check all the different possibilities we can give it a try and we see that everything works all good now the issue with this approach of using Financial incentives to force people to reveal is that the amount they need to deposit should be similar to the total amount that they may win but in a ruffle if you imagine a big ruffle where there's thousand players and a million T to win very few people would have the means to put a million Tes as a deposit and if they did probably wouldn't want to risk it just for a small raffle where they have a small chance of winning so Financial intensive work if it's a small raffle if it's a deposit can be small enough but in some cases the deposit itself makes it unlikely that people will take part so we need a better solution and for that we will use cryptography so the solution is to force people to reveal or at least make sure that their number is re reveal by using cryptography and A cryptographic Primitive called time lock in a sense it's using Brute Force to reveal number for them for people who didn't reveal themselves and time lock is a cryptographic primitive that we will use instead of a hash so instead of hashing and sending the hash of the number we picked we send a time lock of that value and the time lock has the properties that it's like an encryption mechanism but where if you are given enough time anyone can actually decrypt it but it has the property that if you only have a certain number of minute let's say x minutes we could say 10 minutes then nobody will be able to crack it and and decrypt it without the private key even if you have the most powerful computer in the world even if you have a specialized ASC so A specialized Hardware dedicated to decrypting time locks or even you have fpga that you program to decrypt time locks really fast you still won't have time to decrypt it in this number of minutes on the other hand if you have enough time let's say 100 times that amount then anyone can decrypt it even with a regular computer without the private key and so the idea is that the encryption algorithm takes a number of iterations on a single processor you cannot paraliz the computation so you cannot use hundreds of computers in the data center you have to use a single processor and so given enough time whatever computer you have you will be able to decrypt it so this duration of how long it takes at the minimum with the fastest possible computer you may find has to be more than the amount of time people have in the commit phase so that between the time the first person commits their number and the time that the last person can commit theirs this amount of time should be shorter than the smallest amount that anyone with a fastest computer will need to cck the time lock cck the chest and find out what your number was then has to be still small enough that during the reveal phase if somebody didn't reveal somebody with a regular computer can correct the value in a reasonable amount of time let's say 10 hours and reveal for that person and the idea is that if somebody doesn't reveal then someone else can reveal for them and be rewarded so there's really no point for someone to not reveal because they will lose their deposit and someone will reveal their number for them anyway and be rewarded for doing that computation so you gain no benefit in not revealing your number so with this approach we can have a commit and reveal system where we make sure that everybody's value is revealed and we find the right in this module we will talk about reentrancy flaws it's a type type of flaw that is particularly hard to detect but easy to prevent reentrancy bugs happen when the contract calls another contract and then that other contract calls the original contract again in such a way that it breaks the assumptions you make in this original contract there was a very famous reentrancy attack that caused the da hack on ethereum in June 2016 and that attack was so serious that it eventually led to the fork of ethereum into the current ethereum and ethereum classic as the community split between deciding to rewrite history to avoid the attack or simply accept it with ethereum Classic on tesos the languages are designed in such a way that reentrancy bugs are less likely but we will see that rency bugs are still possible on tesos we will also see a way that we can prevent them we'll take an example where we have two contracts that manage unique tokens identified by the ideas the first contract is a ledger contract that simply keeps track of who owns each token so it has an admin contract that can collect and make changes and it simply stores a big map of tokens with the token ID as a key and the address of the owner as a value then we have an unchain view to obtain in the current owner for a given token idea and then an entry point to change the owner of a given token idea to a new owner and only the admin contract is able to change this owner then we have a purchaser contract that is the admin of The Ledger contract and this purchaser contract is simply in charge of purchasing tokens are predefined prices so we store the address of The Ledger contract and in a big map a list of prices so for each token idea we store the corresponding price and that's the price at which the purchaser is willing to buy a given token then the owner of a token is allowed to call the apply offer entry point for a given token idea say okay I'm willing to sell you that token at the price you listed so we check that the caller is indeed the owner of the token by calling this view get token owner of The Ledger then the contract sends the corresponding price to the caller and one thing to keep in mind is that the transfer of test is not immediate but we create a transfer that will be executed after this entry point is over then we call the change owner entry point of The Ledger to say okay I'm the new owner so the purchaser contract becomes the new owner of token ID and again we add this to the list of operations to execute after the end of this entry point with that in mind can you figure out how this contract could be attacked and by attacked we mean how could funds or assets be stolen from this contract or get stuck in this contract pause the video and think about it for a minute so the key idea of the attack is to call this apply offer entry point twice and get paid twice before the ownership change actually happens so while apply offer is taking place and all its consequence is taking place but before the actual change to the owner is made we call apply offer a second time note that on a blockchain you cannot run two transactions in parallel if a user simply creates two transactions to call apply offer twice the first goal will be completely over before the second one can be executed we don't have concurrent execution of different transactions so you never need to worry about that but it's still possible to have a call to apply offer before the owner is changed can you figure out how this can be done pause the video and think about it for a minute so let's look at the code of an attacker contract so we will assume that the contract below is the owner of the token with ID 42 and we also assume that the purchaser contract list this token for a price of 100 T so it's ready to purchase it for 100 T and then we will call attack attack of the purchaser with token idea 42 in the storage we will store a number of calls and the token idea for the token that we are trying to attack during the attack we set the number of calls to two we'll talk about why in a minute and we store the token idea and then all we do is accept the offer by calling purchaser do apply offer saying yes I'm willing to sell you my token 42 for the price listed which is 100 T so far nothing special you simply have a contract that accepts the offer from the purchaser contract but the trick is to also have a default entry point in this attacker contract and to have this default entry point also call apply offers and the idea is that we accept the offer a second time before before the ownership of our token is transferred to the purchaser and to avoid doing that indifferently since when we accept the offer a second time the purchase contract will again send us 100 Tes and call the default entry point again and So to avoid an infinite recursion we have this NB call variable in the storage that we set initially at two and every time the default entry point is called we decrement it by one and when it reaches zero we stop calling apply offer so in practice we only call it twice we call it here the first time and then the first time we receive 100 T then we'll call it again but the second time we receive 100 T we don't call it anymore so this contract uses reentrancy to steal 100 test from the purchaser contract again the idea is that when the attacker calls apply offer for the token ID 42 so the attacker is indeed the owner of token 42 we send TZ to this attacker but you have to keep in mind that we don't directly transfer TZ we add a transaction to the list of transactions that will be executed after we execute apply offer then we add another transaction to this list which is to call The Ledger to change the owner of that token to ourself to the purchaser contract those two transactions are added to a stack of transactions to execute after the apply offer and point is completed so once it's completed we take the top of the stack which is this transaction we transfer 100 test to the caller but we also call the default entry point of the attacker which then create another call that will be added at the top of the stack and that calls apply offer a second time and when apply offer is called a second time we check that the owner is the caller and it's still the case because we haven't changed the ownership yet then we will add two transactions to the stack at the top of the stack we will add a transaction to transfer 100 test to the attacker again and then right below it another call to change the ownership of the token to the attacker then we execute the transaction at the top of the stack which is to transfer 100 test to the caller call the default entry point but this time NB calls gets to zero so nothing happens and then finally we have have this call to change the ownership of the token to the purchaser that was added to the top of the stack by the second apply offer call and then finally we have the same one but this one that was created by the first call to apply offer so let's look at the succession of steps that happen in detail we first have the call to our attacker contract to say okay let's attack this purchaser contract and try to steal funds through through the token we owned so token ID 42 this creates a call to the apply token entry point of the purchaser saying yeah I accept the offer to sell token ID 42 to you then this applyer offer entry point is executed at first time it checks that the call is the owner it creates a transfer of handes to the attacker and a call to the change owner entry point of The Ledger then for the first call the default entry point is executed decrements the NB calls from 2 to one creates a call to purchaser apply offer of 122 and while it does that hand has a transfer from the purchaser contract to the attacker contract then the second call to apply offer is executed it checks that the caller is still the owner so the attack contract and creates a second transfer of 100 test to the attacker then a second call to change owner so this one against is executed first which calls the default entry point that thec end to zero so nothing else happens but 100 Tes are transferred from the purchaser to the attacker again and finally we execute the change owner call that was created here in the second call to apply offer so we set the ownership of the token to purchaser and then we have finally the initial call to change owner that is executed that sets the ownership to the token again to purchase her a second time in the end the attacker contract received 200 Tes from a token that was priced at 100 T so it stole 100 T from the purchaser contract if we had initially set n be calls to 10 it would have stolen 900 T from the purchaser contract by accepting the offer 10 times before before transferring the ownership of the token to the purchaser contract so the question is how can we avoid this type of flaw so you have to keep in mind that what makes this flaw possible and hard to detect is that a new call to the purchase contract can be initiated in the middle of the execution of its different steps and Our intention in the purchas contract was to Simply send usest to the seller and then take ownership of the token but what really happened is that we sent test to the seller but then the seller did all kinds of things including trying to sell its token a second time and only after that did we take ownership of the token so with that in mind how can we avoid this type of flaw pause the video and think about it for a minute so the first approach is to Simply order the steps of your contract in a safe way and the idea is to start with the steps that will prevent future similar calls so in our example we could have avoided the flaw by swapping these two instructions so the instruction to send the 100 test to the caller and instruction to change the ownership to the purchase contract if we simply changeed the ownership first and then transferred hand test to the caller then during that transfer any call to accept the offer again would have been rejected because the attacker contract wouldn't be the owner anymore so this approach can work if you're really careful you make all the changes that will prevent future calls first and then the consequences and in particular transfers of TZ afterwards it's possible to avoid them but as contracts become more complex it can become really hard to be 100% sure that you cover all cases and that no reentrance attack can happen so there's a second approach that is a bit more radical and that simply prevent any reentrancy at all and therefore any reentrancy attack the idea is to use a Boolean flag for example we can call it is running that we put in the storage of the contract and that will be said to True while the contractor is being used so that it cannot be called a second time and so the entry point will have this structure we first check that is running is false then we set is running to true then we do all the logic including creating calls to other contracts transfer of test Etc and then we call an entry point that set is running to false it's important to do it through a call to an entry point that simply set is running to fals because all of these calls created here all this transfers will happen after the end of the execution of our entry point so we cannot just simply set it to false again we have to call an entry point that will set it to false after all the consequences of this section will be done if we look at the fixed contract it will look like that in apply offer we first check that is running in false then we set it to true then we check that the caller is the owner of the token that we are trying to purchase then we change the ownership of the token to ourselves so the purchase or contract then then we transfer her test to the color and then finally we call stop running that will check that the color itself so that no one else can change the value of is running and then we set is running to false so this way apply offer can't be called during the transfer of test to the attacker and the attack would fail here we can look at a more complete version of this attack and test it we have this Ledger that's stes tokens and has anmin we can Min tokens then check the ownership of a current token or change the owner or token then we have our purchaser contract that has a list of offers here we have a system of escrow so you put funds in a processor contract in case somebody wants to sell the token to you the buyer has the funds available in an escroll big map in the purchase contract then when someone accepts an offer we send the price to the current owner of the token and then we call change owner to change the ownership and we can see here the attacker contract that does exactly what we said we initialize and calls at zero we call the accept offer entry point of the purchaser contract and in the default entry point we decrement and be calls and if it's greater than zero then we call accept offer again and if we run a test that has an attack for token ID one then we can look at the details and see that we get 100es transferred twice once here and once here so the attack worked in this module we will look at an auction contract that has multiple flaws and your goal will be to find the flaws in this contract let's take a look at this auction contract in the storage we will store a map of tokens each token will store the metadata of the nft and the current owner and the key will be a token ID that will start at one and that we increment every time someone meets a new nft then we have a map with all the options where the key is the IDE of the token that is put for auction people can mint nfts using the mint entry point that pass the data of the NFD they want to Mint we check that they pay a fee of one TZ to Mint that will be used to fund the website and the advertisement everything to bring users to this project and then we simply add an entry to the tokens map that will contain the metadata and the initial owner of the nft then we increment the token ID once somebody wants to open that auction for a given token they provide the token ID and a deadline for the auction that means people will have anth this deadline to bid and the highest bidder will become the new owner of that token so in this entry point we store that the caller is the seller we store the deadline we store the current top bid and here instead of using an option to set that there isal top bid we simply set it at zero and we say that the top bidder is the cender so whoever is putting the item on auction bids zero but then anyone can bid so that if nobody bids anything then they can get the ownership of the token back then once somebody bids for this token they indicate what token ID they bid for we get the data of the corresponding option we check that they're bidding more than the current top bid for this nft and we check that they bid before for the deadline so since they bid more than the current top bidder we send the amount that the previous top bidder have bid back to them and then we set the new top bid to be the amount sent by this sender and then they become the new top bidder and we save it back into the map finally after the deline the seller can claim the top bid and get the funds while transferring the ownership of the token to the top bid so we fetch the auction object we check that this is after the deadline we check that the caller is the seller of the token we send them the value of the top bid and we change the owner of the nft to the top bidder now your job is to find all the bugs from this contract and there are at least seven bugs in this small contract pause the video and give it a try so for the first bug I will give you a hint remember that if the storage of a smart contract gets too big the time it takes to derealize all of the data in the storage before any contract call and then res serialize it after the end of the entry point May exceed the amount of gas that you can spend in a transaction so it's always important to think about how large the storage can be and make sure there is no risk of exceeding that maximum amount of gas to spend in a transaction so with that in mind can you figure out what the issue is pause the video and think about it for a minute so the issue here is that we used maps to store the nfts themselves and to store the information about the auctions but maps are stored directly in the storage which means the serializing them takes an amount of gas that is proportional to the number of entries so as people mint more and more tokens and put them into more and more auctions the size of the storage that you need to distalize will get bigger and the gas could exceed the maximum amount you can spend in the transaction so this is bug number one and to fix it all we need to do is change these into big Maps like this and this as big map are serialized and deserialized On Demand there always the data structure you need to use for any data I can keep growing indefinitely a second bug is in the open auction entry point there's actually two bugs in this entry point because we don't need nearly enough verifications so pause the video and focus on that entry point for a minute the first bug in this entry point is that we never check that the sender who is trying to sell this token in an auction is actually the owner of the corresponding entry point and we don't even check that this token exists so we need to start by checking is the color the actual owner of this so we can write assert of. data so we check that the owner of this token is the cender so they're allowed to sell it this automatically checks that this token exists otherwise this would fail anyway so we don't have to add an extra verification to check that this token ID exists for the next issue you can use a method that I always recommend to apply when proofreading a smart contract which is to think about what would happen if somebody calls a given entry point twice with the same information so let's imagine that we call open aution a first time with a given token ID for example 20 and the deadline so we first check that the caller is the owner of the token 20 and then we create a record and save it in the big map for the key token it here then if we call open auction again with the same parameters we will again check that the sender is the owner but then we will overwrite the previous auction with a new record so in this case it's fine we just redo the same thing but if in the mid time somebody has bid for this auction then we lose all the information about the top bidder and the top Bid And so basically any funds that any bidder has sent to the contract would be lost because they're not recorded as the top bidder anymore and they won't be reimbursed if someone else bids Etc so here we have a clear bug that the owner of a token can basically cancel everything that has happened with an auction by creating in a new auction so to fix this we need to verify that there is no auction going on for this token so we assert that self data auctions does not contain the token ID the next bug that is reasonably easy to find is on the claim top bit entry point so focus on this and try to use the techniques that we presented thinking about what happens if we call an entry point twice but also what happens if we don't call an entry point if the person supposed to call it doesn't call it pause the video and think about it for a minute so here the issue is if somebody doesn't call the entry point we can see that here we expect the seller so the owner of the token to call claim tub bid but the seller may not call it for a number of reasons it could be because they're not available because they forgot or it could be for nefarious reasons for example they could say well I'm not happy with the auction I feel I want to get more than the current top bid so since I have their money stuck in the contract anyway I will try to pressure them to to give me more money if they don't well too bad their money is stuck they don't get the nft and that's their problem I don't lose anything so somebody could pressure the top bidder to try to distort a bit more money for example and it's always the case when somebody needs to do something we have to trust that they will do it and if we depend on them to do it then they have some leverage over us so it's not good to require that the seller call this entry point the whole point of a blockchain is that we don't want to have to trust someone to do something so here we could say well maybe the top bidder themselves could also run this entry point and so if the seller doesn't do it then the top bidder will do it so we can add here or SP sp. sender equals top bidder but we actually don't really care who calls this entry point so we can simply delete this line and as long as somebody calls it then everything is good the next bug is actually a bug that we now have in in two places we have it both in this entry point and in this entry point the version in this entry point is the most dangerous one because somebody could really steal all of the tokens that are P for sale through this auction contract so try to focus on this entry point and think about a way that somebody could steal all of the tokens are put for auction pause the video and think about it for a minute so here I may give you another hint when you send funds to an address if it's a regular cheesy address of a basic account you simply send the TZ to that user address but if the address is that of a smart contract then what happens is that this calls the default entry point of the contract while sending the test to that smart contract if the smart contract doesn't have a default entry point the transaction fail if it has a default entry point but the default entry point fails then the transaction fails so for a contract to be able to receive direct transfers using sp. send and without explicitly calling a smart contract it needs to have a default entry point like this that for example doesn't do anything so when you try to turn transfer some test to this contract with sp. send it will call default it shouldn't have any parameters otherwise it's not the right entry point and it will fail and it shouldn't fail so here we put pass so it doesn't do anything and doesn't fail but if the destination of this transaction either doesn't have a default entry point or has a default entry point that maybe checks for Boolean something like that and maybe has another entry point point that allows them to change the value of accept test then they would be able to control at any time if they allowed transfers of test to them or not so here if the top bidder is the address of a contract with this kind of default entry point that has a Boolean to accept or reject transfers of Tes they could bid for the nft with a very small amount as soon as the nftd is put for auction then they could set this to false to to reject any future transfers of test if somebody else bits a higher amount for the same token idea we will check yes they bit more yes it before the deadline but then when we try to reimburse the previous St bidder that previous St bidder would reject the transfer and therefore this new bid would fail and then this initial bidder who's trying to steal the token just has to wait until the deadline and then claim the top bit and get the nft so with this we have a system for anyone to bid a very small amount and then prevent anyone from bidding above them until finally they get the item so it's really important to be very careful every time you have an entry point that calls sp. send especially if you're not sending Tes to the colar of the entry point itself we have the same issue here here we sending Tes to the seller but the seller could be the address of a smart contract that has a default entry point that may or may not accept TZ and they could use that as a way to prevent anyone from calling the claim to bid entry point and finalizing the transaction so we have the same issue here and here and this issue is an issue we can have quite often in smart contract you should be really careful anytime you call sp. S now what do you think the solution would be to fix this issue pause the video and think about it for a minute so one solution people often think about is to prevent contracts from bidding or prevent contracts from trying to sell Etc so if we know that this is not the address of a smart contract then we know that it's impossible to block the transfer but preventing smart contracts from using your smart contract is really cutting yourself from a lot of potential use cases for example no entity that is using a multiseed contract to collectively take decisions on how to use their assets would not be able to use your contract there's many occasions where we don't want to directly interact with a contract with a TZ address but instead through a smart contract so I really don't recommend testing if the caller is a smart contract or a regular user account an implicit account instead what we want is to let the top beider here and let the seller here get their friends back themselves through a separate entry point but for that we need to use a ledger that keeps track of how much the contract owes to each user so here we will add a big map Ledger where the key will be the user and the value will be the amount that the contract owes to them so here instead of sending test we check if there's already an entry for that user so if it doesn't exist we create the entry with zero T and then we add the amount that we wanted to send them like this and we also need to add a claim entry point where we send to the color the amount that is in The Ledger for them and then we delete the entry and here in claim to bid we can do the same thing I'll just copy this but here it's going to be action auction seller and that's it so that's fixing the next bud so it's really it's a good habit to to have a ledger in your smart contract so that instead of directly sending test to different addresses you just keep it in The Ledger and you let people withdraw the funds through a claim entry point the next bug is in claim Tob bid and again think about what happens if you call the same entry point twice pause the video and think about it for a minute if we call claim Tob Bild the first time let's say for 2 id20 we check that the deadline to be is passed we send the amount of the top bed to the seller Through The Ledger and then we change the ownership of the token to the top bidder now if we do it again we call claim top bid a second time with the same parameter 20 then we do everything again we check it still past the deadline but then we transfer the amount of the top bit again to the seller the seller didn't change then we assign the ownership of the nft again to the top bid so this doesn't change anything but here we add the top bid a second time to the seller so the seller could keep calling this entry point many times and get the amount from the top bit again until the balance of the contract is lower than the top bit by doing that basically the seller would steal funds from top biders of other auctions that are currently ongoing to avoid this we can delete the entry so that the entry point cannot be called again and maybe another auction can be set later the last bug that I know of is related to The Mint entry point and to the fact that we charge one test for someone to Mint and through this contract pause the video and think about what the issue could be with that here are the issues that we have accumulated TZ in the balance of the contract but the owner of the smart contract whoever is managing the website that goes with the smart contract has absolutely no way to get this money so they may look at the contract see yes many people are minting nfts and accumulating money Etc until one day when they say Okay I want to use this money for something else to pay for some developer some marketing Etc then they realize that they have absolutely no way to get the Tes out of the contract this may sound silly but this kind of issues forgetting to create an entry point to get the money out of the contract is something that has happened to multiple companies with their smart contract so when you test your smart contract make sure you test the whole life cycle of the contract including the time where you want to get the money out so here there's an very easy way to fix that which is to Simply add these T to The Ledger but for that we need to specify who the owner of the smart contract is so we have to specify an owner and store it as there is no default owner of a smart contract just because you deploy the smart contract doesn't make you the owner so we have to store it in the storage there is really no default notion of owner that we can access to so here as soon as we get the one so here we can use this piece of code again and we add one test to the The Ledger you may notice that I have copied the same piece of code multiple times and there is a way to put it in the function but we will see it later in the module about Lambda so for now we simply copy this piece of code in each of the smart contract that uses it and that's it to recap we found seven flaws in our simple auction smart contracts we forgot to check that the seller of an nft was actually the owner of that nft there was a way for a bidder to bid a very small amount and then prevent anyone else from out bitting them and therefore making sure they could win the auction with a very small price and therefore stealing all the tokens we noticed that the seller could never call claim top bid and maybe use this as a way to extort money from the top bidder so if we fix that we also notice that the seller or anyone could call claim top bid multiple times and steal t from other auctions and we noticed that the admin the owner of the contract could never claim their earnings so we added a way for them to do that through the Ledger we also noticed that the usage cost of the contract was increasing little by little as people created new tokens Etc in the map in the storage until the contract would be completely stuck once the amount exceeded the total amount of gas we can spend in a transaction and we simply fix that by using big maps and finally we noticed that it was possible for a seller to delete an auction and everything that was already bid by overwriting the auction with a new one so you can see that in a very small smart contract it's quite easy to have many different bugs and so it's very important not only to test very carefully have people other than developer proof fre the contract and also go through checklists and making sure you don't have any of the typical bugs we just presented on open.com we have a page about all the typical flaws we can have in smart contracts and you can use that page as a checklist when you review your own contract in this video we will talk about the type of contract used in decentralized finance called flash loan and we will see that with a flash loan you can become temporarily very rich so we'll start with an exercise in a previous module about sets we presented a membership contract that only rich people could join and the way we did that was that the join entry point that people had to call in order to join this club required you to transfer a large amount of TZ to the contract that the contract will then reimburse you so in order to join the club you needed to have access to a large amount of money so the question for this exercise is let's say you don't have access to a large amount of funds is there a way you could still join this club pause the video and take a minute to think about how you could create a smart contract that would make this possible so the solution is that you have to borrow some Tes and so the idea is to create a contract that can lend TZ to users and of course users would have to pay back later with some interest so the question is how can you have a contract that lends you money but then makes sure that the user will pay back pause the video and think about it for a minute so the usual way that even Banks use to reduce the risk when they lend you money is that you have to have some kind of collateral it could be a house it could be anything on the blockchain is typically money but in a different currency so let's say you want to borrow some amount of T let's call it X from a contract we could deposit some amount of token a so a different cryptocurrency that is worth more than x Tes for example it could be 130% of X then in exchange we receive this amount X of Tes then for some amount of time we can use those T but at some point in the future we pay back that amount plus the interest once we do that we can get our deposit back in the token a so the amount we deposited in the token a was never used was never invested or anything it was just kept by the contract so that we could get it back once we returned the amount of Tes one thing to keep in mind when you do that is that the value of token a may change over time it's a different cryptocurrency so the exchange rate between a and the T could vary over time so if the value of your deposit in the form of tokens a becomes so low that it's starting to get close or even lower than the amount that you got the contract can liquidate the loan to make sure it doesn't lose money for example let's say the value of token a gets close to 110% only of xegs then it will use an exchange to exchange your deposit for some T so that's what we call liquidating the loan so this is the way the contract makes sure and no matter what it will get the test back plus some interest either you pay it back or if you don't pay it back or if your deposit is starting to lose value then it will get back the money by liquidating your deposit so this is a type of loan but not the one that would work for us because in our membership contract the whole point was that we want to join but we are not rich we don't have any funds whether it's in form of Tes or another token so we cannot pay in any way and we cannot provide a collateral basically this kind of loan doesn't work if we just poor so if a user doesn't have any funds how could someone lend to them without taking a risk so I can give you a hint in our situation we only need the money very briefly so how could we do that pause the video and think about it for a minute so the idea is to do everything in a single transaction in the same transaction we could borrow money from a contract then use that money to join the membership contract and then immediately get it back then we could pay the money back to the contract plus some very small interest if all this is in the same transaction then if we fail to pay the money back then everything will be cancelled right because when it's a single transaction a single contract call if one of the part fails then everything fails and is cancelled so basically the contract never lends you money if you don't actually pay it back so there is no risk for the lending contract so this type of contract where you borrow some funds without any collateral use it immediately and then pay back plus some interest that's what we call a flash loan contract so in a Flash loan the key idea is that funds have to be borrowed bored and repaid within the same transaction so you borrow some amount from The Flash loan contract you use it for any kind of financial operation that generates a profit or at least where you don't lose any money then you repay the funds plus the interest to the flash loan contract and you can keep any profit you made so in the case of our membership contract your profit is simply that you manage to become a member of this membership contract so there's really no risk if anything goes wrong the transaction fails entirely so it's as if nothing has happened which means anybody can be temporarily as rich as needed in particular to profit from an opportunity okay so let's work on the implementation of such a contract think about how you would Implement a simple flash loan contract you have to have an owner who will deposit t on the contract and eventually claim them back when he needs to to those Tes will be used to lend Tes to other people then anyone can borrow these Tes with no limits other than the total balance of the contract so the amount deposited by the owner and then the lender needs to repay the loan with interest in the same transaction so again there is no risk if the lender can't repay the loan the entire transaction is cancelled let's look at the structure of such a smart contract in the storage we would need to have the owner so the person who puts the funds in the smart contract to lend to other people we provide the interest rate so what percentage of the funds you borrow you have to pay on top of reimbursing the loan itself we only need to make one loan at a time since we're going to pay it back right away so there's only one Loan in the flash loan contract so we can store the amount that is being loaned we need to keep track of whether there is actually a loan in progress we'll see why a little bit later we need to know who who borrowed this amount and then we'll need to know if the amount has been repaid then we have five entry points we have a deposit entry point where the owner will deposit the initial funds and a claim entry point where the owner will claim their bance back at the End plus their interest and people can call the borrow entry point and specify how much they want to borrow and they willing to provide a call back that says what is the next step right after a the money this entry point will transfer the amount to the sender and then we'll call this call back and within this call back the funds will be used profit may be made and then the call back will repay the loan so after we call the call back we need to call a function that will check if the loan has indeed been repaid while the call back is running at some point it has to call repay and send the funds back to the flash loan contract then finally check repail will be called and we will check that the loan was repaid otherwise we fail and everything is cancelled so the idea is that the contract that borrows the money will call borrow and pass its profit entry point as a call back so let's say we want to borrow 10,000 TZ and as soon as we have those funds The Profit entry point should be called so we call borrow borrow transfers 10,000 Tes to the sender then it calls this function call back then it calls check repaid to make sure that indeed call back has repaid the loan the next step is that profit is being called so the tests that have been transferred to it can be used to buy something for example then we can sell it for more somewhere else that's one way to make a profit and finally we need to call Flash loan. repay with the amount borrowed plus some interest so when we call repay the repay entry point of course checks that the amount sent is the amount of the loan plus the interest and it sets the repaid flag to True finally the check repaid entry point is called and here we check that repaid is true otherwise we fail so we make sure that indeed the amount sent was repaid So based on this try to implement this fles loan contract and call it from the borrower contract and note that you will need a total of three contracts The Flash loan contract the membership contract and the attacker contract the contract that will borrow the funds so that it can be then become a member of the membership contract we'll pause the video and Implement those contracts let's take a look at the solution so here is our flash loan contract we instantiate it with an owner and some interest rate we store those two we Mark that the flash loan is not in progress we have no loan so we set the loan amount currently to zero we have to set a borrow to avoid uh using an option so we set it to owner and then we say the flash loan hasn't been repaid so we set repaid to Falls we then have the deposit entry point that the owner can call to deposit some funds that will be used to lend funds to anyone only the owner should call it but we don't have to check it if somebody else wants to send money to the flash laan contract that's fine the owner will be able to claim it so nobody else is likely to send some Tes then we have our borrow entry point that takes an amount someone wants to borrow and the call back to be called after the money has been sent we check that there is not already a loan in progress because if we can borrow while there's a loan progress that will complicate things we would have to keep track of the list of people who borrowed Etc so we only want to have one loan at a time so we say it's in progress the money is being used so we set it to true and we won't be able to borrow again until the loan is paid back we record who is borrowing we record how much is being loaned then we send that amount to the caller and then we call the call back it has to be an entry point that doesn't take any parameter so we send unit to it then after the call back is acculate we will call the check repaid function so the call back is supposed to use the money make some profit and then call the repay entry point so here we call the check repaid entry point here to check that indeed repay was called by the Callback so when the call back calls repay we check that indeed there's a loan in progress and we check that the amount paid back is equal to the loan amount plus the loan amount times the interest rate so for example if the interest rate in one and we need to pay back 101% of the loan amount then we can Mark repaid to true so the loan has been paid back so later when we call check repaid we check that it's in progress we check that the loan has been repaid and we say okay the loan is over it's not in progress anymore everything goes well and the whole transaction happens if check repaid is called but the call back didn't call repay then this will fail and everything will be cancelled and the money will be safe finally the owner can call claim at any time unless there's a loan in progress so we check that is indeed the owner calling we check that the loan is not in progress and then we send the balance of the contract to the owner who's calling claim we have our membership contract that checks when we joined that the caller sent a certain amount and then we send it by to them then we have the attack contract that will borrow some funds then join the membership contract then pay the funds back to the flesh Loan in the constructure we take the address of the membership contract the address of the flesh loan contract and then the amount that we will need to pay to join this club therefore that we will need to loan we store all three then we have the impersonate rich person entry point point we will call the borrow entry point of The Flash loan contract and we will pass it the amount we want to borrow plus the address of the call back entry point so here we get the attack call back entry point so that we can pass its address when we call the loan contract so we say we want to borrow this amount when you're done please call this call back which is this entry point so in the call back we call the membership entry point and we send it that amount of money so that we can join the club and then we repay the contract so we compute the amount to repay which is the amount we borrow plus 1% here we hardcoded that it's 100 T then we call the repay entry point of The Flash loan contract and send that amount of T to it so that we can repay the contract and of course we need a default entry point so that we can receive the funds that the flash loan contract sends to us and that's it so then we can see the test we create a membership contract we say the amount to have in order to join this club is 10,000 TZ then we create the flash loan contract we say Alice is the owner the interest rate is 1% and note that this is not 1% per year or per any unit of time it's just that any time you borrow you have to pay back with 1% of Interest immediately Alis sends 100,000 Tes to the flash loan contract so that people can use it to borrow some funds then we create the attacker contract we pass the address of our membership contract the address of our flashl contract and then the 10,000 test or the amount that we will need to pay to join the club and we simply call impersonate rich person we have to send some extra test to be able to pay the interest let's give it a try so here we can see that we originate the membership contract we originate the flash laan contract Alice deposits 100,000 t to the flash loan contract then we originate or attack a contract with the address of those two flash loan and M ship contract then the attack starts we call imperson at reach person we pass 500 T so here we borrow some funds 10,000 T and we say here is the call back the flash loan transfers 10,000 test to the default entry point of our attacker then it calls the call back so this function where we join Jo the membership contract by sending 10,000 TZ we get the 10,000 TZ back into the balance of our attacker contract then we can repay 10,000 plus 100 T back to the flash loan and so when the flash loan calls check repaid everything was good so everything works but if anything went wrong and for example we didn't pay the full amount back or we paid without interest let's say we pay only 10 T of Interest interest and if we run it we can see that this didn't work so everything was cancelled all good in this video you will learn how to create your own fible tokens in particular you will be able to create your own currency on chain fible tokens can be used in many different ways they can represent an existing fible resource for example we can create a stable coin or we can create an ingame C currency represented by a token we can also use fible tokens to fractionalize the ownership of a tangible asset for example we can have a token that represents a piece of real estate or a piece of art and the tokens make it a lot easier for the owners of this real estate to split their ownership and then Trade It Etc fible tokens can also be used to raise capital for a project similarly to stock the fible aspect ECT of tokens means that different units of the same token are interchangeable and if you own an amount of token you can split it into sub amounts this is very different from nonf B tokens nft where each nft is unique and cannot be split into sub nfts with all that in mind try to think about the structure of a basic contract that would represent a fible token I'll give you a hint think about the test token it is a fible token and what we want to be able to do with our fible token is very similar to what we are able to do with the native test so with that in mind think about how you would structure a contract to handle this pause the video and think about it for a minute so with the native TZ we have accounts and we have a balance for each account and we can transfer Tes from one account to another so we need to be able to do that with our token contract so we need to store the balance of each user in that token and we need to be able to transfer tokens to other people for that all we need is to have in the storage of our contract or Ledger a big map that contains the balances of all the users the key would be the address of the user and the value would be the amount of this token that the user owns and we need a transfer entry point where a user can say I want to send this amount of token to this destination and the ENT triport will check that we have enough tokens in our balance to transfer that amount if the destination does already have an account we create it by setting the balance for this address to zero then we can do the transfer we add that amount to the balance of the destination and then we subtract the amount from the balance of the sender so that's great but with the test we can do more than that so try to think about what else we can do with the TZ that this doesn't support and I'll give you a hint think about what you can do with Tes within smart contracts or when you use Smart contracts pause the video and think about it for a minute I'll give you another hint think about how you would write a version of the Endless wall contract where it would charge one token instead of charging one TZ to add a message to the wall what would you need in The Ledger contract to be able to support this here is the code of the Endless W contract that uses TZ so what would you need to do to be able to write a similar code but by charging using your own token instead of one TZ pause the video and think about it for a minute so with the native TZ token you can transfer test to a contract when you call an entry point then within the entry point you can use speeded amount to check how much was sent to the contract to pay for some service or to deposit some amount Etc so we need to be able to do something similar with our token one way would be to call the transfer entry point to send tokens to the address of the contract just before making a call to an entry point so that we can send some amount of token to the contract we are just about to call but if we do that we there would be no way for the contract to check how much we just sent to it so we need a way for the contract to be able to check who transferred how much to it and we need to make sure that the same transfer of tokens cannot be used for two calls by the same user to the same smart contract one way to do that would be to store information about every transfer to a given contract call and we could store that in a big map where we store all the transfers the key would be the source so who is calling this entry point and sending tokens to it and then we will store the destination address so the address of the smart contract and how much we are transferring so we would add an entry to this big map when we make a transfer to a Smart contract and the destination contract will then be able to call some entry point of the token contract of The Ledger to check that there is indeed a transfer that has been made with the right amount and they will then delete that transfer so that it cannot be reused so that could work but in practice the standards we use to write such fible tokens contract do it a bit differently so that we can mble more your cases instead of keeping track of how much we just sent to the contract we calling we will allow the contract to take some money from the caller so we allow a given contract address to spend some amount of tokens in the name of a given user or contract so users can say okay this contract is allowed to spend this amount of tokens from my balance and then the contract can directly transfer that amount to itself or to some other destination so instead of sending some token to the contract and having a way for the contract to check it we allow the contract to use some of our tokens and then the contract can do it itself so instead of storing transfers we store allowances in the storage of our Ledger where for a given account and a given operator that's the address of the contract we allow to use some of our tokens and we say how many tokens it can spend we create an allowance by calling an allow entry point that takes the address of the operator that is allowed to spend some of our funds and the amount that we allow this operator to spend if there's no entry we create one and then we add this amount to the entry so with the account and the operator then when we call transfer we specify the source because the source may not be the sender so we say I want to transfer this amount from this source to this destination and within the entry point we check if the source is not us then we check if there's an allowance that allows us to spend at least that amount then we subtract that amount from the Alan so that you cannot spend it a second time so now it's your turn to implement this contract so your job is to write a ledger contract such that a user can create a new token and set an initial amount of tokens that he owns then anyone May transfer their tokens to other users so this first user can distribute their token the way they wish then The Ledger will keep track of how many tokens each user owns in their balance with a system of accounts and balances and finally users can allow contracts to spend some amount of tokens in their name once you've done that use this Ledger in a version of the Endless wall contract such that anyone can add text to the wall as long as they pay one of your tokens and the tokens that are paid can be directly transferred to the owner of the Endless W contract to help you we provide you an incomplete code that you can find either in the G repository or on open tesos and your goal is to complete the contracts and the tests let's take a look at the solution so in our Ledger we store the balances so a big map initialized with the owner of The Ledger who owns the total Supply that we provide then we'll have another big map that will store all the allowances when we transfer some amount from a source to a destination we check if the source is not whoever is calling the transfer point then we check that they're allowed to transfer that amount so we check if there's an entry in the allowances for this source and this callar we check that the allowed amount is more than what we want to transfer and then we subtract the amount from the allowed amount this could be negative except that we check that it's not so we can convert it to a natural and then update the allenes we also check that the balance of the source is sufficient to transfer that amount then we update that amount by subtracting the amount we transfer from the balance of the source finally if the destination doesn't already have a balance we create one with the value zero and then we add the amount we transfer to their balance we will use a get balance onchain view so that any contract can figure out what's the current balance of a user for this token and then we have our allow entry point where a user can allow a given operator so the address of a smart contract to spend some amount in their name it could be a regular user but in practice it's almost always a smart contract if there's no entry in the big map for that key composed of the sender and the operator then we create one and we say the allowance is zero and then we add the amount we want to allow to this allowance and that's it for The Ledger now let's look at the modified version of the Endless wall contract all we have to do here in the contract is to do the transfer so we get the entry point transfer from that ledger contract the type of the parameter will be a source a destination and the amount and then we do the call to the transfer entry point we say the color of WR message is the source the destination is the owner of the unless will contract and we transfer one token we don't need to transfer any Tes and so this is just a way to say transfer one token from whoever is calling right message to the owner of the UN listable contract of course for this to work the user who is calling right message has to have allowed us to do so then we change the text in our test we create the ledger so Alice creates a ledger with a million tokens then we create an endless wall where Bob is the owner of that endless wall but the endless wall needs to know the address of the ledger so we pass the address of The Ledger here to Our Endless W Constructor that we store here and then finally Alice will need to allow the endless wall contract to spend one token in her name and once she's done that then she can call right message and this one token will be taken from her balance and transferred to Bob we can give it a try so here we originate The Ledger where only Alice has an entry with 1 million tokens then we originate the endless wall with the initial text hello then we allow the endless World contract to spend one token in the name of Alis then Alice can call the right message entry point and this will trigger a transfer of one token to Bob's address all good when we create fible tokens on tesos we need to make them compatible with tools and contracts and wallets so that generic tools can be used for you to view your balance and spend your tokens Etc so we have a set of standards that are used to create fible tokens the first standard was the a 1.2 standard that is dedicated to contract that manage fible tokens only then we have the A2 standard that also supports nonfungible tokens we talk about it in another module and at the time of recording we're about to release the AA 2.1 standard so an updated version of the fa2 standard these standards all include support for some system of operators and or allowances that can be done in different ways depending on the standard but the idea is always the same that we allow some address to do some operations in our name they also include A View to access the balance of a given user from another contract and they have additional metadata about the tokens in this video we will talk about how you can trade tokens for example if you create your own token you can trade it against TZ or against tokens from other people and we'll talk about how the value of a token can be calculated so in the module and fungible tokens we saw how we could transfer tokens from one address to another and how we could spend tokens in smart contracts using a system of operators and allowances but we also want to be able to trade our tokens with t or to trade them with other tokens so for example we can take the simple case of trading between a pair of tokens we create our token a and we want to be able to trade tokens a versus TZ so if someone has an amount of token a they want to able to sell it for some mon of t or vice versa so the question for you is think about how you would create a contract that would allow anyone to either quickly purchase tokens a using TZ as a way of payment or quickly sell tokens a in exchange for TZ and the important part is to do so at a fair price how can you make sure the exchange is on the right price pause the video and think about it for a minute so we can think about a multiple ways to determine the price a basic idea would be to set a fixed exchange rate once and for all so you could say well I create this token for my game currency and I will say that one token is worth exactly 0.3 T for example but if you do that no trading would probably happen because if some people think the currency in your game should be worth more than 0.3 TZ for each token then they will never sell it at that price or vice versa if people who may want to buy your token think well it's worth a bit less then they won't be willing to buy it at that price the whole point of creating your own currency is for the token to be able to have its value changed based on demand so if your game becomes very popular and lots of people want to earn some currency in your game then the price should go up and vice versa if the game is not too popular then the price should be able to go down so that people still can buy and sell those tokens so a fixed exchange rate wouldn't work another way would be to try to have a group of people decide together what the current exchange rate they could have meetings every day say okay we think it should be lower it should be higher let's change it a bit that would be a bit complicated and it wouldn't really help because it wouldn't adjust fast enough to the demand and this group of people wouldn't have a good way to know what's the right exchange rate it would say okay yesterday people bought it but didn't sell it so it's probably too cheap or vice versa and it's probably too expensive we need a way to instantly adjust to the demand we could think about using auctions like we do for nfts but auctions are slow you need to set a deadline in the future you need to make sure there's people who know this your auction Etc and they're hard to use because you would put an as an auction a certain amount and this amount may not match what the buyer wants to purchase and if you make an offer while setting up the offer at the right price is not easy either so we want something that really determines the right price automatically and instantly if you want the trading of tokens to be effective we need liquidity it should always be possible to buy and sell at any moment you shouldn't have to wait for someone to be available and agree to sell to you or buy from and the prices should be adjusted automatically and instantaneously based on the offer and demand for your token and the token you want to trade it for so to support that we could use a contract that will store some amount of the two tokens that you want to trade so we will store some amount of token a and some amount of TZ so that if people want to buy or sell there is some amount that is available immediately for trading and this contract will have to automatically adjust the price based on the offer or on the demand for your token so think about how you would design a contract that will store some amount of tokens a and of TZ and then will automatically adjust the price based on offer and demand and will let anyone trade at that price pause the video and think about it for a minute this type of contract is what we call a liquidity pool and a liquidity pool enables users to easily trade between Pairs of tokens let's imagine that we have token a and TZ in our liquidity pool some investors could deposit initial amounts of token a and a corresponding amount of TZ these tokens would form a reserve of liquidity for each of the two tokens then users would be able to trade amounts of one token for the corresponding amount of the other token at the current price and this current price the exchange rate would be based on the available amounts of both tokens in the pool we will see that when we do that any deviation from the real exchange rate based on the offer and demand the price that people are willing to buy it for or sell it for can't last very long because as soon as the price is cheap then somebody will quickly buy and it will increase the price or if the price is too much people will sell and this will reduce the price and there will be a system of Arbitrage opportunities that makes sure that the exchange rate is the right rate the investors who deposited the liquidity on this liquidity pool will be rewarded using Exchange fees so percentage of every trade that they will receive in exchange for providing this liquidity so the main question is how can we determine the exchange rate that we will use typically liquidity Pools use what we call an automated Market maker or am mm mechanism it's a mechanism that determines the token prices based on the amount of token a and of TZ in the pool for example of be a TZ there can be a number of different formulas you can use but the most common formula that is used is called the constant product formula and with this formula the prices are such that the product of the balance of both tokens remain constant so the balance of token a multiply by the balance of TZ that is in the reserve of the liquidity pool should always be equal to some constant K that we set when we create the liquidity pool and the idea is that with this formula the more of a given token you have out of the two the cheaper that token gets and of course the less of a token you have the more expensive it get because it's rare so it's more expensive than if it's really abundant so the the idea is that whenever we buy or sell a given token we compute the price to make sure that after the transfer this product is still constant so with that in mind let's Implement a very basic liquidity pool contract at the beginning we will have a single user who will provide liquidity to this pool a single time then other users should be able to trade tokens for tez or vice versa there should be a way for contracts to be able to check the current exchange rate and again the idea is that the balance of the two token in the pool should always verify this formula token a balance time token B balance equals K so first think about what you would store in this smart contract and what would the entry points be pause the video and think about it for a minute so in the storage of the contract we will need the address of The Ledger because we will interact with the Ledger that stores the token we also need the address of the owner who is the single user who put liquidity at the creation of the liquidity pool and they will be able to get it out when they want to close the liquidity pool we need to store the constant K so since we multiply a natural number with a number of TZ then K has unit TZ and finally on top of the balance in t that we will have access to using sp. balance we also need to store how many tokens the liquidity pool owns and we could of course check in The Ledger but it might be more convenient to store it directly in the storage then we will have five entry points the first entry point is for the creator of the liquidity pool to transfer some liquidity and so they send some amount of Tes to the entry point along with a number of tokens they want to deposit in the balance of the liquidity pool so you add to the balance in TZ and to the balance in this token some amount based on this you can compute the value K that's the product between this amount and the amount of test transferred and so we can store these two values and then we of course need to transfer this number of deposit tokens to the address of the smart contract through the ledger so this assumes that the caller has allowed the liquidity tool to transfer these tokens to itself at the very end owner should be able to withdraw their liquidity so when they call it withdraw liquidity we simply send all the tokens in the balance of the contract and all the Tes in the balance of the contract to the owner and this closes the liquidity pool then we have the two main entry points for for users to sell or buy tokens so our sell tokens entry point we will say how many tokens we want to sell but as a safety measure to make sure we don't sell them for cheaper than what we expect we indicate how many Tes we expect to get at the minimum when we sell our token so it's a safety measure to make sure that if the price goes temporarily very low then maybe we just don't want to sell so we can set some minimum value of how much we will get for those tokens and so in this entry point we will compute using the formula how many Tes the tokens that we want to sell are worth and if this is more than the Tes we requested then we simply transfer the tokens and T accordingly so we transfer the tokens to the liquidity pool contract and then we take test from the balance of the liquidity pool to send them to the seller the buy tokens entry point Works similarly we send some amount of TZ to the contract and we say with that amount of Tes I expect to buy at least this number of tokens if the price price of the token goes too high then maybe I just don't want to buy them and here again we start by Computing how many tokens I can get for that amount and if this is more than the minimum that I want to buy then we transfer the tokens and the test accordingly we keep the test sent by the user in the balance and then we transfer tokens to the color finally we will have a view get token price that will compute and return how much it would cost to buy one token right now so your job is to implement this contract and keep in mind that this formula should always be maintained the product between the balance of one token and the balance of the other token should always be equal to K before and after each call to an entry point again you can start with the incomplete code that we provide in the G repository or on open tzel pause the video and give it a track let's look at a solution here we have our Ledger that we didn't change and here we have this liquidity pool contract where we store the address of The Ledger contract the address of the owner the constant K that we initialize at zero before we know the value it will have and then we keep track of how many tokens the liquidity pool has on its balance and then this will be used to simplify the calls to The Ledger contract so basically this is a variable where we will store the address of the transfer entry point for that contract so that we don't have to compute it every time we have the provide liquidity entry point where the owner will deposit some amount of tokens and some amount of Tes initially to the liquidity pool we check that whoever is calling is the owner we check that we have never sent anything so the liquidity pull is not open yet so the value of K was Zero then we compute the value of K as the product of the balance of the contract after the transfer of TZ from the user and the number of deposited tokens so here K is set once and for all and finally we keep track of how many tokens the liquidity pool owns finally we do the transfer to obtain those tokens from the user through the ledger so this is where we initialize this Ledger contract up variable with the address of the transfer entry point of The Ledger you may notice that to avoid having to repeat the type everywhere we created this perm type that we Define here as the record that contains a source a destination and some amount so that we don't have to repeat it every time once the owner has provided some liquidity in the form of TZ and some amount of tokens we have the withdrawal liquidity that will be called at the End by the owner to withdraw all of these tokens so we check that this is indeed the owner calling and then we simply send the balance of the contract to the owner and then transfer the tokens themselves to the owner finally we just say now the tokens own are zero and then we set K back to zero so that maybe the contract can be used again later by the owner but this effectively closes the liquidity pool for now let's look at the get token price on chain view so that we can figure out how we compute the current price of the token and here the idea is to compare what the current balance in T is to what it would be if we had one less token and this difference is how much the balance needs to change so that the product between the two balances stays the same so here we divide K by the number of tokens we currently own this should tell us what the current balance is and then we do the same but with the current amount of tokens owned minus one and so this tells us what the balance should be after we sell one token so if we have the balance before we sell one token and the balance after we sell one token then the difference between the two should be how many Tes we get for that token and so this is how we compute the current price of a token now in the sell tokens entry point we do something similar we compute what the balance would be if we had this number of tokens on top of the token we have and so we compute how many Tes we are supposed to send by Computing the difference between the current balance and what we should have once we obtain those extra tokens so this is not the same as Computing the current price of one token and then multiplying this by the number of tokens sold because the more you sell token to the liquidity pool the cheaper they become because the more tokens the liquidity pool has then the cheaper each token becomes so we cannot simply use the price of the first token and then multiply that by the number of tokens so this is why we use this formula as a way to check what is the current balance and what should be the balance after we obtain those tokens and the difference between the two tells that the price that we should pay for those tokens so here we check that this price is more than what the seller is requesting and once we have that it's very easy we transfer the tokens we transfer the TZ and we keep track of how many tokens we still own the buy tokens Works in a similar way we compute the number of tokens we should get for the price that the user sends so sp. amount by Computing the difference between how many Tok tokens we currently own and how many tokens we should own based on the new balance that we have so we divide K by the New Balance to determine was the number of token we should own after we got this uh new amount and again we check that this number of tokens is more than what the buyer is expected to receive and if it is then we send tokens to them and we update the number number of tokens we own now in the test we create The Ledger we create the liquidity pool Alice provides 2,000 tokens and 2,000 Tes and C provide liquidity to the pool this means K will be 2,000 * 2,000 so 4 million then we have Bob bu at least 90 tokens for 100 TZ then Carl buys a th000 T worth of tokens and expect to get at least 500 of them then finally we have Bob sell his tokens so it allows the liquidity pool to withdraw 96 tokens that's the number that he will actually be able to buy here and then calls sell tokens to sell those 96 tokens and he expect to get at least 200 TZ so if this works so Bob spent 100 TZ to buy 96 tokens then Carl spent a th000 TZ to buy a lot of tokens so this increased the price of a token so that Bob can sell his 96 tokens at at least 200 and make a big profit of at least 100 T so let's give it a try so we can see here that we created The Ledger with 1 million tokens then we created the liquidity p cool with K set to zero no tokens own we provide some liquidity after allowing 2,000 tokens to be provided we provide 2,000 tokens and 2,000 Tes the transfer is made for these tokens to be transferred then we have Bob by 100 T worth of token and he wants at least 90 tokens for that price with see that the amount computed for 100 T is 96 tokens then Carl buys for a th000 TZ worth of token expect to get at least 500 and we see that he indeed gets 614 tokens for 1,000 Tes we can see that the price of the token went up for 100 TZ Bob got 96 token but for a th000 TZ Carl only got six 114 and the price keeps increasing as the supply of tokens in the liquidity pool gets lower we can see here that the number of tokens owned is down to 12290 whereas the balance is up to 3,100 so tokens are getting rare which means they're getting more expensive then Bob allows for his 96 Tok tokens to be transferred back to the liquidity pool and then sells them and says I should get at least 200 T and we can see that his 96 tokens are taken from him but then he gets 23997 T so he indeed made a profit of almost 114 TZ for his initial 100 T purchase so here there's high demand for these tokens so people who bought tokens early can make a profit all good in this video we will talk about the concept of Arbitrage and we will see that if there are two liquidity pulls or in other word two exchanges for the same pair of tokens but the price is not the same for both then there's an opportunity for Arbitrage where we can make some profit so the idea is that you could have two contracts two liquidity pools to exchanges where the exchange rate between the two tokens A and B or a in TZ are different when this happens this creates an opportunity for anyone who owns some token to purchase some tokens a in the contract with the cheaper price paying with the other token and then to sell these tokens in the contract with a higher price and you get a higher amount of token B that what you initially paid so you make a profit this happens all the time on block chains but also other markets and we presented a very simple opportunity where it's just a direct exchange rate between tokens but it could be path where you go through intermediate tokens but then find a way to make a profit with a succession of exchanges so there's always many many users and in practice Bots that constantly look for search Arbitrage opportunities and as soon as they see W they purchase some tokens in one exch change and then sell them for more in the other exchange by doing that they make a profit but they also help to make sure that the exchange rate for a given pair of tokens stays approximately the same across all the different liquidity pool contracts all the different markets and you can do this even if you don't have money by using flash loans so that you can take advantage of any such Arbitrage situation if you notice two liquidity pull contracts that have different exchange rates for the tokens A and B you could borrow tokens of type B from a flash loan contract then you can purchase tokens a at the cheaper price using your tokens B that you just borrowed immediately sell your tokens a at the higher price in the other liquidity pool getting more tokens B than you spent and with these tokens you could reimburse a flash loan and the interest but still make a profit so you don't actually need to own any tokens b or a to take advantage of an Arbitrage situation thanks to flash loans because Flash loans can make you temporary rich in any of the tokens and of course if you make a mistake and cannot reimburse The Flash loan everything is cancelled so there is no risk for anyone let's work on an exercise where you will take advantage of an Arbitrage situation you will use the Ledger and liquidity pool contract and create a test that does the following with a user Alice you will create a token with a supply of 10 million tokens then Alice will create two instances of the liquidity pool contract and each of those instances she will provide liquidity with 1 million tokens and 1,000 TS once this is ready we will have Bob purchase 100 TZ worth of tokens from the first liquidity pool and this will create an arbitr situation because it will change the price of the tokens that was initially the same in both pools but not at Bob bought from one pool it will change the price of the token in this pool so Carl will take advantage of this Arbitrage opportunity and earn some TS so using the example contracts that we provide on a g repo and on open tesel pause the video and write a test where Carl makes as much of a profit as possible in this situation let's take a look at the solution so here we have our Ledger contract and the liquidity pool contract that we didn't change and so in or test we here create a ledger in the name of Alice with a total supply of 10 million tokens then we create two identical liquidity pools lp1 one and LP2 each liquidity pool is created in the name of Alis attached to this Ledger and Alis provide 1 million tokens and a thousand T of liquidity initially the price is the same for both tokens then we have Bob buy 100 T worth of tokens from the first liquidity pool and he expects to get at least 80,000 token so this creates an arbitr opportunity because the tokens on the first liquidity pool will be worth more than the tokens on the second liquidity pool because there are now fewer tokens in the first liquidity pool so Carl can buy some tokens from the second liquidity pool and then sell them for more in the first liquidity pool and the question is how many should he buy and at what price and the idea here is that since Bob only bought a small amount of tokens compared to the the whole pool then the price won't change by much so we could use some math to compute what's the right amount but by triy and error we can see that the best amount is to spend 48 TZ and this will buy 4,82 tokens and with this numberous call we'll make a profit of 4.76 T and if he bought for 49 T then the profit would be a bit less and same for 47 T profit would be a bit less so maybe the ideal value is not precisely 48 T but this will be close enough so Carl will buy this amount of TZ worth of tokens and he expects to get exactly this amount but that's the minimum he says he wants to get then he will sell those tokens back on the first liquidity pool so allows this number of tokens to be transferred by the first liquidity pool and then sells them so so let's give it a try so we can see the creation of The Ledger creation of the first liquidity pool then we allow transfer of liquidity to this first liquidity pool we do the same for the second liquidity pool and then we have Bob who buys 100 T worth of token we see that with this amount he actually got 9,910 token then Carl buys for 48 T worth of tokens with see that indeed the number of tokens he bought is 45,8 two and that by looking at this value that we actually set this exact value here then the tokens are transferred and then Carl allows for these tokens to be transferred when he sells it and he to sell this amount of token and he expects well he doesn't expect anything he'll just see what he can get but we can see here that the tokens are transferred and then we have 52.76 TZ transferred so he bought them for 48 T and he sells them on the other liquidity pool for 52.76 making a profit of 4.76 T if we want to better understand what happens we could check the prices at different moments of the different liquidity Pools by calling scenario. verify and then I get the token price and check that for example it's at least 90 mutes some rary value and the get token price can be instrumented with some Trace instructions to find out what the different values are what the ratio are what the current price should be and so we can run it then open the console to see here the price of the token return is 1,000 so when we call it here right after we created the liquidity pool then one token equals 1,000 mutes but after Bob buys some token then we can run it again and we see that this time the price increased to 1210 mutas Etc so you can use this instruction at different places with the two liquidity pools to check exactly what's happening very convenient to help you understand you can play around and see what happens in this video we will show that in some situations it's possible to manipulate prices of tokens and cheat if contracts are not protected against this manipulation contracts that want to attract wide audience may offer users to pay in a choice of multiple tokens so you could accept payment in TZ but also accept payment in number of other tokens that people own so that they don't have to First Trade their tokens before they can use your contract so for example we could change our membership contract to sell the access to a club we could set the entry price at A th000 T but people could also pay the equip equivalent price using token a for the contract to be able to do that and use the right price it will need to obtain the exchange rate between those two tokens but this can be done through the liquidity pool you could use the view get token price from the liquidity pool to find out what's the current exchange rate let's take a look at this version of the membership contract it will use a ledger it will use our liquidity pool that we don't change and here is the membership contract when we created we initialize the membership price in TZ we said the owner we give the address of The Ledger and the address of the liquidity pool and we have our set of members here then users have two ways to join the club they could join by simply paying the membership price in TZ so we check that they pay the right amount we add them to the list of members and we send the amount to the owner this is a extra usess line here but users could also join this club by paying with tokens and when they call they say how many tokens they pay we will then check the current token price by using the get token price onchain view from the liquidity pool and then we check that if you multiply the number of tokens that the user is willing to pay with this current price it should be at least the membership price in TZ and if that's the case then we transfer the tokens from The Ledger to the owner and then we add this user to the club then we have our test where we create a ledger liquidity pool we provide liquidity to the liquidity pool then we create the membership contract with a entry price of a th000 TZ we have Bob simply join the club by paying a th000 TZ then we have Carl joined by paying 1,000 tokens let's give it a try it worked so we see that we created The Ledger the liquidity pool we provide liquidity to the liquidity pool then create the membership contract and then we transfer a thousand TZ from Bob's account so that Bob can join we can see here that Bob is a member then Alice transfers 2,000 tokens to Carl so that Carl can join using tokens and Carl allows for 1,000 T to be spent by the membership contract and then calls joins with tokens with a thousand token and the tokens are transferred and so the current price paying 1,000 token works now the issue is that unfortunately this contract has a very serious flaw and the question is can you figure out a way to obtain membership at a very low price and as a hint I can tell you that the idea is that the exchange rate can be manipulated look at this membership contract and think about how we can manipulate the price so that people can join the club without paying much pause the video think about it for a minute so the way you can manipulate the price to join the membership contract is that you can manipulate the exchange rate of token a versus T to do that you would first buy a lot of tokens a from the liquidity pool this will automatically increase the price of token a by a lot in this liquidity pool then you can purchase membership in the club using just a few tokens a because those tokens are worth a lot now and then you can sell your tokens a back to the liquidity pool at the same price you bought them so you temporarily increase the price of token a by a lot by purchasing most of the tokens a from the liquidity pool to make them be worth a lot then you use them to purchase membership and it will check the price using this liquidity pool and then you can sell all your tokens back but for this to work you need to have enough funds to buy tons of tokens a from the liquidity pool and you also need to make sure that nobody jumps on the abrage opportunities because if you bought a lot of tokens then people can sell tokens to the liquidity pool because the price is very high before you get to purchase membership in your contract and remember that there's always Bots looking for these opportunities so as soon as you buy a lot of tokens a some bot will purchase tokens a from a different pool and then sell them to the liquidity pool to make a profit and your attack won't work so for this attack to work we need to make sure we have enough funds and we need to make sure nobody can jump on the Arbitrage opportunity that you create by buying so many tokens because if this happen when you sell them back you won't be able to sell them at the right price and you will lose money so if you assume that you only have 200 Tes how could you still join this club without spending much pause the video and think about it for a minute so the solution to both issues with our attack is to use a flash loan you could borrow enough TZ through a flash loan to purchase lots of token a and therefore impact the price and then you could pay back the loan within the same transaction and if you do everything within a single transaction nobody will be able to use Arbitrage because nobody can run any smart contract call or any transaction at all within your transaction as an exercise you will try to simulate this using The Ledger the liquidity pool The Flash loan and the membership contracts you will create an attack manually in your test that will make it possible to purchase a membership from an account that only spends 200 test to create this attack you need to be careful with the execution or of a transaction remember that when from an entry point you call a smart contract you're not actually executing that smart contract right away you're adding it to a stock of transactions that will be executed after the execution of your entry point and the Order of execution of the different transactions is important for you to be able to create this attack and to help you we prepared a file that you can find on open tesos or on git with all the contracts you need and you just have to write a test pause the video and give it a try let's look at the solution so we have our Ledger we have a liquidity pull we have a fles loan contract then our membership contract and then we will create an attor contract that it will temporarily use a flash loan to increase the value of our token then use just a few token to pay for the membership and then pay pay the loan back so this attacker will need the address of all the different constructs it will interact with we will need to calculate how many tokens we buy so this is a value you can calculate and we initialize how many Tes we will borrow from The Flash loan and we have the price of membership and so the attack needs to be in three parts that's because the first part will borrow some test from The Flash loan but since we don't get the funds immediately we cannot do the second part immediately so what we do is we then call the second part to make sure the second part is executed After we receive the funds from the flash Loan in the second part we will buy tokens from the liquidity pool and then call the next part because the next part needs to happen after we receive the tokens from the liquidity pool so that we can then benefit of the new of the token in the liquidity pool to purchase the membership so here we borrow funds from the flash loan here we buy a lot of tokens from the liquidity pool and here we buy the membership at a low price we sell our tokens back to the liquidity pool and then we replace the flash loan we can check the details and here we can see see that we use the view from the liquidity pool to compute how many tokens we need to pay to the membership contract and send here so we compute here pricing tokens by getting the current price of our token and then we see how many do we need to pay for the membership price we add one to take into account running issues and that's the amount we will transfer when paying for the membership ship then in the test we can see that we create the liquidity pull The Ledger the membership flash loan we deposit some funds on the fles loan and then we simply call or attack your contract after allowing the liquidity pool in the membership address to withdraw some tokens from the funds of the attacker contract so the question you may now ask is how do we prevent such a tax and for that you need to really understand what's the cause of the flaw and the cause of the flaw is that the liquidity pool may not always reflect the real exchange rate it only reflects the real exchange rate if you get enough time for Arbitrage opportunities to be taken advantage of by Bots or other users so knowing that how can we avoid this issue this type of attack pause the video and think about it for a minute so if you want to prevent a tax based on price manipulations one way is to keep track of prices within some time frame so for example within some number of blocks like five blocks then across those five blocks you could use the medium price within that time frame as given by the liquidity pool this gives enough time for Bots to take care of Arbitrage opportunities and you avoid flukes in the price of the liquidity pool and most of all you make sure you don't take the instant price returned by the liquidity pull based on the current balances you take a price that has computed before your current transaction there's another approach that consists in combining multiple sources multiple liquidity pools and again taking the median of their prices but you should make sure you don't take instant prices because multiple liquidity pools could be manipulated at the same time in this module you will learn how to generate events from a smart contract a feature that makes it a bit easier to create that that react to Smart contracts so smart contracts May emit events that you can observe from an offchain app and so the goal of events is to standardize how external apps can keep track of some aspects of a contract instead of having to go look at its storage analyze transactions in the block Etc they will simply be able to listen to events some examples where events could be used to inform for apps and their users an event that corresponds to the sale of an nft within a collection or an update to some value provided by an oracle or the operation of a new proposal for a multi or a dow contract where the user is expected to participate and vote after checking what the proposal is in all of those cases it's convenient for the contract to emit events and for apps to observe those events so that they can react to it or warn the user about it to emit an event from an entry point you can add this instruction sp. Emit and then you have up to three parameters the first one is the only one that's mandatory the other two are optional the first one is a value attached to the event it can have the type of your choice here we put a string but it could be an integer it could be a record almost anything you like then you have an optional tag so it's a word with no spaces that is attached to the event and that deps can use in filters so you could listen to all of the events that have a specific tag for example so finally there's a wi type attribute and when you set it to True some extra content will be added to the event that describes the type of the value in a way that is fully annotated so events have absolutely no effect on chain it's not going to change anything about the behavior of your smart contract it's only only for offchain apps to observe they are emitted by a transaction and are listed in its result in the order that they are emitted and an app can obtain the list of events emitted by a transaction with their values their types and their tags they can do so through RPC calls directly to the node or they can use the dedicated API of indexers that support events for example TZ KT let's take a look at an example we'll take the basic C the calls contract that simply counts the number of times we call make call but now when we call make call it will emit three events one just with a string hello one that will have both a string and a tag my tag then finally one a bit more advanced where we include a full record with two attributes a tag and we include the annotated type of this record so whenever somebody calls my call all these three events will be generated in this order in the smart P IDE when we run it we can see that we have this meel entry point being called and then the hello event the second event and then this event with a record that's about it if you go to a block Explorer on the contract that emits event here we can see in the melon code emission of some event with a pair of ins then you can see that you have an event events tab that is only present for contracts that emit events and if you go to the events tab then you can see the different events from different transactions here we can see one in this block one in this block Etc in this module we will talk about how we can upgrade contracts whether it is to fix a bug or add new features so by Design and thanks to decentralization a Smart contract can't be mod ified by the author this is so that users can trust that the contract will always do what it says but the author of a smart contract sometimes really want to be able to make some changes it could be because they need to fix a bug that was found in the contract or it could be to add a new feature or make it compatible with a new standard or to finetune the business Logic for example how rewards are distributed or votes are counted Etc so the question is how can we solve this Dilemma on one side you want to make it possible to change a contract but on the other side you want to allow users to trust that the contract won't be changed to their disadvantage so how can you solve this dilemma pause the video and think about it for a minute a common solution is the simplest one you can simply replace the contract with a new one and sometimes it's just that simple you simply Point your dab to the new contra contract but this approach has limitations first you have to warn everyone that the new contract is being used and that the address that the DAP points to has changed and if users have Assets in the old contract they have to move these assets to the new contract and then stop using the old contract but these assets may be locked in the old contract for example into the deadline that is quite far in the future let's start with an exercise where you will take the endless World contract we use a version that has an unchain view that gives access to messages from each user and then your goal is to create a new version of this contract where we now require new messages to be at most 30 characters where we charge one test per message and we allow users of the old contract to transfer their messages to the new one for free without paying the one test per message so we have our existing endless World contract here that stores all the messages in the big map and that stores the owner with the right message entry point and then we have this onchain view read messages that simply returns all the messages for a given user so start from this contract and write a new version of the contract that can transfer all the messages using this view into the new contract you will have to have both contracts in your files so that you can create a test that makes them interact with each other pause the video and give it a try let's take a look at a solution so here we have the old contract and here this is the new version of the contract so we still have a big map to store all the content we still store the owner but we also store the address of the old contract so that we can interact with it in the right message entry point we simply make the changes to the logic where we charge one TZ and we check that the messages are shorter than 30 characters everything else is the same as the previous right message but now we add this new transfer old messages entry point where we call the view read messages from the old contract to obtain the data associated with that user the user who's calling this transfer old messages entry point and we simply store this old data in the new contract without charging anything we ass assume that the user never called right message so we simply create or replace uh the entry with the sender as the address finally we keep the same onchain view in case we want to upgrade the contract again and then in the test we first create the first contract with some message and we need and then we test the new contract where we write messages and of course longer messages are not allowed we need need to make sure we pay one t but we can also transfer messages from the old contract here by calling transfer old messages as Bob and then Bob can finally add new messages an issue with this approach is that it requires the initial contract to have views so that the new contract can access the old data so the question for you is how would you manage the transfer of data without having an onchain view in the old contract positive and think about it for a minute so if the old contract doesn't have any views we have to count on the owner to validate every transfer of data we can think of three approaches to do that the owner could simply initialize the contract with all of the data from the old one the issue with this approach is that this could exceed the gas limit for the deployment the origination transaction would be too large to fit in a single block and it would also be quite expensive the next option would be for the owner to have an entry point to transfer Bunches of data from the old contract and split the transfer between many different calls and the main issue with that is that the owner themselves will have to pay for all the storage costs and all the transaction costs required for all these calls and that could be quite expensive if the contract is very successful a better option would be for the owner to publish signed messages that allow users to repost each of their old messages so the idea here is that users should be able to post old messages for free but for any new message they would have to pay one TZ so the owner can send them signed messages of chain as a proof that the owner of the contract allows them to post this messages for free with this approach each user will pay for the transaction fees and the storage fees for the transfer of their own data they just don't have to pay the one Tes to the owner again so let's do this as an exercise you will start with the same initial endless walk contract as in the previous exercise but this time without the onchain view and then you can create a new version of the contract or modify your new version of the contract so that users can repost their old messages for free so you can assume that offchain the owner will publish a signature for every existing message and the signatures will guarantee that the old messages sent by users were present in the old contract so you will have to write a tests and in the test generate all the signatures and then call the new contract in the name of different users with the content of the messages and the corresponding signatures pause the video and give it a try let's take a look at the solution here we have the old contract that we didn't change except we remove the onchain view and here is the new version of the contract here we don't store the address of the other contract we don't interact with the other contract instead we store the public key of the owner that we will be able to use to verify signatures sent to the contract the right message entry point didn't change so we only change the transfer all messages entry point and we take as parameters the all data packed as a sequence of bytes and the corresponding signature then in the entr point we check that the signature is valid so we check that it corresponds to the public key of the owner for the signature and this packed data then we unpack the data the data contains the text of the messages from the user and the corresponding timestamp and the user address so we unwrap the data and then add it to the big map and in the test here after creating the new contract we fetch all data from the old contract off chain anybody has access to this data so we can simply fetch that data we create a record where we add the user address we pack it into a sequence of bite and then we call make signature using the secret key of Alice to generate a signature for this data and then we call transfer all messages let's give it a try and we can see that everything worked well in the version we just presented an issue is that all the messages were duplicated into the new cont contract and we had to have each user pay for the storage and transaction fees again this can be a bit costly but another issue is that if the data represents assets duplicating them could be problematic for example imagine that the assets are nfts if you duplicate nfts this would mean both the original nft and the copy could be sold separately and exist at separate nfts so the question for you is can you think of a solution in the case of an nft cont contct that avoids duplicating the nfts one solution in the case of an nft contract is to wrap the nfts we already use this approach as a way to go around paying royalties and the idea is that the new contract can buy an nft from the old contract and then Min its own version of the nft and this copy would become the new official version and could have a different set of rules for trading the nft compared to the old version but this can be considered as upgrading a contract this approach only works when the ownership of assets can be immediately transferred to a new owner that will be the contract if you can plan things in advance there are better approaches available so you can make upgradability a feature of your contracts we already saw that if you planned an onchain view in your contract this can allow you to duplicate the data but what we really want is to avoid duplicating the data but instead move the data or the assets into a new contract without duplicating them so the question is how can we make sure that data can be moved into a new version of the contract pause the video and think about it for a minute really transferring the data to another contract can be costly or complicated you have to repay for all of the storage costs in the new contract and you also have to split the transfer into many transactions so what we really want is to keep the the data in the same contract but since we want to upgrade the contract and have a new contract a good way to keep the data in the same contract is to separate the logic into a separate contract that interacts with the data contract so you have one contract that takes care of storing the data and then one contract that takes care of the logic and the contract in charge of the logic could easily be replaced so only the ownership of the data contract would then need to be transferred instead of the ownership of every asset in the old contract let's do it as an exercise so your goal is to create a version of the Endless World contract that is upgradeable and you do that by splitting it in two you will have one contract that will be in charge of storing the data and then a second contract that will contain the logic and access the data through the first contract then you will show how it can be upgraded by using a new contract that accesses to the data contract and again it should only allow messages to be of length less than 30 characters and it should charge one test for each new message let's take a look at the structure of such a contract so first we look at the data contract in the storage we will have all the content in the big map W content and then we store the owner of the contract but this time the owner is the address of the other contract the logic contract then we have two entry points that will be be called by the logic contract the first one is the right message entry point that takes the message and the user as parameter the caller will be the logic contract so we check that indeed only the logic contract can call this entry point and then we simply store this data into W content with the user as the key then as the goal is to be able to upgrade the logic contract we need another entry point update owner where the previous logic contract can say okay okay I need to be upgraded here is the address of the new contract that will take over the logic and so we pass the address of the new contract as parameter and we check that the caller is indeed the current owner before updating to the new owner then let's look at the structure of the logic contract that we call upgradable endless wall in the storage here we don't store much we simply store the address of the data contract and the address of the owner of this contract in the entry points we simply have the usual WR message entry point that takes a message as a parameter and all it will do is call the right message entry point of the data contract with the message and the address of the caller then when we want to upgrade this contract we call an entry point upgrade with the address of the new contract we check that it's the owner of this contract that calls and then we call the data contract to say update the owner to the address of the new contract so your goal is to implement these two contracts and demonstrate the upgrade procedure to a new contract in your test and of course again the new version of the contract should only allow messages of length below 30 and charge one test for each new message pause the video and give it a try let's take a look at a solution so we start with the data contract we see here that we have our big map and the address of the owner contract here in write message we check that the caller is the owner so the logic contract and then we simply add the content as usual in the big map and then the update owner entry point simply checks that the caller is the Old owner and replace it with a new address of the logic contract then in logic contract we store the owner and the address of the data contract in the right message all we do is call the right message entry point of the data contract contract and then in the upgrade contract we call the update owner entry point of the data contract to change the owner after checking that this is the owner of the logic contract doing the transfer in the new version of the logic smart contract we keep exactly the same structure and the same content the only thing we need to change is to add the assertions that about the length of the message and at about the one test price to call right message and in the test we first create the first version we pass we first create the data contract we pass it to the first version of the logic contract then we upgrade to the new version and continue adding messages we can give it a try and we can see that we can keep adding messages and then we have all the messages sent through the old logic contract and the messages sent with the new log contract so one issue with this new solution is that sometimes we really don't want the address of our contract to change because then we need to send everybody to the new address so to deal with that we can use a proxy contract a proxy contract is a contract that forwards all of the calls to the real contract so it's an inter intermediate between the user and the real contract and the address of this real contract can be changed while your proxy contract never changes as long as the API the entry points and the parameter of the entry points stay the same so let's give it a try as an exercise try to make the endless wall contract upgradable using this proxy pattern then show how it can be upgraded to add the rules about the length of the message without changing the address that people use to interact with the contract so here we would have again two contracts the inner andless W contract would have the usual storage with the big map and the address of the owner that will be the proxy contract and we'll simply have one entry point write message the TT this parameter the message and the user check that the caller is the owner and update the data and in the proxy contract we will store the owner and the address of the inner contract in the right message contract we simply call the inner contract write data entry point with a message and the user that is the caller and and then we have an entry point to upgrade to a new contract we check that the caller is the owner and then we replace inner contract with the address of the new contract so your goal is to implement these two contracts and demonstrate the upgrade to a new inner contract pause the video and give it a try let's take a look at the solution so here we have our inner contract with the wall content and the owner the right message entry point is the usual nothing special about it then we have here our main proxy contract where we store the owner and the address of the inner contract and whenever we call write message we simply forward that call to the inner contract and when we want to upgrade we simply store the new address of the inner contract and if we want to upgrade this contract we only upgrade the inner contract and so we can update the address of this inner contract and keep using the same address for the main contract so here we have a new version of the inner contract this is pretty much the same as the initial one but with this extra assertion and here again we have the test that first creates the proxy then initializes the inner contract and then we upgrade to the new inner contract can give it a try and see that it works so once more there is an issue with this approach is that which is that when we upgrade the inner contract all the data is lost and again deploying the new inner contract with a copy of all of the data would be too costly but we could combine the two approaches that we just saw the proxy W contract on one side and splitting the contract between the logic and the data on the other side so we would have three contracts it starting to be a bit complicated but it can work in the next module we will see another approach that is based on a feature called Lambda in this module we will see another approach that can be used to upgrade contract and that is using a feature of the language called landas on tesos it is possible to store pieces of code in a variable or in the storage of a smart contract using lambdas a Lambda is a piece of code that can be stored then executed in particular it's a piece of code that can take some parameters and that returns a value this value could contain operations to execute but by default they have no side effect so executing Lambda itself won't change the storage or emit operations but with smart P there's a syntax that makes it transparent to include feature that allows to do either of these so let's see how to create a Lambda to create a Lambda we declare a function within the main module that takes one parameter error and return a value we can keep this Lambda in the storage by simply using the name of the function as the value as we do here we store a default rule that is defined here in the data. rule attribute of the storage then we can call it from an entry point so here when we call execute rule we can call self. data. Rule and pass the current value as a parameter and then we get the result and store it again in the contract so here this is a rule that simply increments the value that we passed as a parameter then we can have another entry point that updates the rule to a new function so here we can call we can simply change self. data. value equals new rule where we use a different Rule and store it so our Lambda really only takes one parameter so if we want multiple parameters we have to use a record in the definition of your function you actually declare multiple parameters separated with commas but these parameters will correspond to different attributes of the record that you will send when you make a call so here we have two parameters A and B and the rule simply adds A and B and Returns the result but when we call this Lambda we need to create a record with the attribute a with the first value and the attribute B with the second value so here it looks like separate parameters but when you make the call it's a single parameter that is a record containing two attributes although internally lambdas do nothing except doing some computation and returning a value and cannot modify the storage or create transactions in smart Pi we have added syntax that you can use in Lambda to allow you to modify the storage and create transactions so in practice what really happens is that the internal lamb does simply return the changes to apply to the storage and also return a list of transactions to be added to the list of transactions of the entry point let's work on an exercise where you will create an upgradeable contract using a Lambda so you will start again with the endless wall contract and then make it upgradeable by the author using a Lambda so that you can support rules about the amount to pay when writing a message and rules about the content of the messages that are allowed for example the length of those messages so everything about that should be handled by a Lambda and then you add an entry point to allow the author of the contract to change this rule so the initial rule should be that any message is allowed and it's free and the new rule should be that the messages length should be less than 30 characters and the amount to pay should be one test pause the video and give it a try let's take a look at a solution here in the main module we create two versions of the internal rule the first version doesn't do anything we don't check anything we allow every message and it's free the second rule simply checks that the length of the message is less than 30 characters it should be strictly less and you will notice that we don't check anything about the price yet we'll talk about it in a minute so in the endless World contract we as usual store the content in the big map the owner but then we store this extra value that will be a Lambda verify that takes care of very verifying if we allowed to send a given message so we initialize it with default verify message in the right entry point we do the usual but at the beginning we simply call at s. data. verify with the message and then we have an entry point to change the rule set verify that TT the new Ru as parameter and we verify that it's the owner calling it and we simply store this new rule so one issue here is that we did didn't plan in our right message entry point that we would be able to change the price of calling message so since we didn't plan it and didn't pass the amus parameter we will be stuck here and cannot verify the price so when you use a Lambda you have to think ahead of time everything that you want to be able to change on one side it's good because people who read this contract know that all you can do is check if this is allowed based on the content of the message and if they read this they see okay you won't be able to charge ever in the future so I'm free to use this it's always going to be free I don't need to worry about so in a way that's a good thing so you have to think about everything you may want to change in the future so if we want to make sure we can decide later on to add a price we need to send the amount to the Lambda but again we cannot simply send two parameters we have to create a record so we create parm equals sp. record message like this and then we send that parameter and now we need to change each of these lambdas to add the price here and here and then we can assert price equals one t so if we give it a try we can see that here we didn't send one TZ because I just changed the rule but here we can pay one t and then it works all good so when using lambdas as we just saw you can only change aspects that were already planned to be changed another example is that in the code we just presented we couldn't add a rule about the total length of a text G a given user may have we can only make a rule about the new messages that we add but not the total amount of text that they store in the contract but as we said this is a good thing the Min users can read the contract and know the limitations of what changes you may make in the future so that they can trust that everything else won't change which is a really important part of using smart contracts in a decentralized blockchain in this short module we will list all the different ways we presented on how to upgrade contracts we presented four different ways the first one was to Simply Point The Depths to a new contract which implied supporting transfers of data or assets to the new contract but we saw that the transfer may be inconvenient or costly and that for nfts we could use wrapping as a way to transfer the assets the second approach was to store the data in a separate contract that could be used by the New Logic contract but of course this means we cannot change the structure of the storage between versions since we keep this data contract between upgrades the third version was to use a proxy contract so that we could keep the same address for the contract but the limitation is that this means the API has to be the same between versions and finally we just saw how we can use lambdas to place some of the logic in the storage of the contract so this means there are limitations to what the owner can change in the contract which can add trust for the users but that also means that all the aspects that the owner may want to change need to be thought about in advance so here we talked about how to upgrade the contract but in each case the owner could unilaterally make changes to the contract at any moment so we could limit what the owner could change but still they could change quite a bit whenever they wanted but we really want users to be able to trust that the contract won't be changed so easily as this really defeats the whole point of using a disiz blockchain so there are two ways to help reduce the risk of a better surprise for the user when a contract is being upgraded the first one is to have a delay between the time the change is made public and the time this change is effective so for example you could have a two weeks delay that allows users of the contract to exit the contract and get their assets out before the changes applied if they dis like that change but this may not always be possible the assets could be stuck in the contract for a very long time another approach is to use contract governance basically letting users vote and only apply changes that users approve this can be done through a multi or a da a decentralized autonomous organization contract which will we present in the next module in this mod module we will talk about multisig and DOW contracts contracts that allow people to work together as one for example to collectively manage some assets so first we'll talk about decentralized autonomous organization or Dao a Dao is a smart contract that enables communities to collectively manage resources the participants in a DA can contribute funds or resources that are stored in the contract then in exchange they receive tokens or shares representing their ownership and influence within the Dow then they can propose ideas projects or changes then vote to determine which of these ideas are accepted or rejected and people may receive Rewards or incentives based on their contribution work or voting participation so the good thing with Dows is that the decision process to manage the shared assets is decentralized fair and transparent dials can be used in many different situations for example you can have collective decision making on a project development where you allocate resource manage the budget and distribute rewards those can also be used in various Industries such as Finance art governance social impact and decentralized applications in finance daos can facilitate decentralized investment funds lending platforms or decentralized exchanges finally Dows can Empower communities to collectively manage digital assets develop opensource software curate content platforms or govern decentralized protocols as an example let's look at the C Finance protocol col is a defi protocol that allows users to borrow stable coins against T it uses smart contracts and each smart contract is referred to as an oven to collateralize TZ versus the stable coin kusd each oven has multiple functions you can deposit some Tes into the oven you can withdraw TZ from the oven you can borrow kusd against the oven using TZ as collateral then you can repay K USD that was borrowed against the oven finally you can liquidate and your OV is liquidated automatically if your borrowed stable coin exceeds your test deposit so let's look at how a DA is used to manage the governance of the C Finance protocol Kow is the governance token used for the cber finance protocol and you need to own Kow to participate in the governance of the protocol you can vote or submit proposals to submit a proposal you need 1,000k D and you submit it it on the c. Finance protocol by pushing a piece of code a Lambda as an example we can take a look at proposal 41 it was proposed after a white hat hacker had found two critical vulnerabilities in the C protocol that could have led to a drain of all of the funds of the protocol this white hat hacker disclosed those vulnerabilities and the developers took actions to patch the bugs but as a reward the community decided to make an unchain proposal via the Dao implementation in order to transfer 50,000 USD to the white hat hacker we can go to the Cur governance website to check all the different proposals and we see here proposal 41 pay security researcher for bug disclosure and we can see that people voted yes by a wide majority and some people abstained and we can click here to see the detail of The Proposal with a short description a link to some details and here we can see the melson code of the Lambda that was sent and that included a transfer of tokens to the researcher another example of Da is the tesos ecosystem da it was designed to curate and vote on the distribution of TZ for various tesos ecosystem initiatives it's governed by a small number of key holders that include the tesos comments TR TCH tesos domain Foundation the tesos foundation itself and the tesos India Foundation anyone can submit any initiative to the DA via the tesos Agora Forum then the initiatives will be curated by tesos comments and proposed to the DA on chain and the objective is to facilitate Community engagement in funding decisions and to promote the growth and development of the tesos ecosystem basically it's a way for people to be rewarded to contribute to the tesos ecosystem now let's take a look at what the smallest Dow could be we can have a variety of different types of dows with different features including governance tokens rewards Etc but they all include a voting system with various rules on how votes are counted for example with quorums Etc so a minimal Dow would include a list of participants a system to propose decisions and a voting process where decisions are executed when approved by a given number of participants this kind of minimal Dow is already very useful it even has its own name we can call it a multisig so what is a multisig it's a contract that requires multiple signatures in order to execute a given transaction this is a way to enhance security by ensuring that no single party has complete control over a transaction for example if you have a company you don't want to have one single person in charge of the private keys and instead you can use a multi where multiple people have to agree before a transaction is confirmed multi contracts operate on the principle of consensus where a predetermined number of signatures are required to authorize a transaction each signature is associated with a specific participant or key holder and the contract verifies that the required number of signatures is provided multis contracts are commonly used to secure funds or assets especially in cases where multiple parties are involved or an added layer of trust and oversight is desired multi6 can be used in a number of use cases for example for escr services multis contracts can be used when funds are held in a contract until specific conditions are met and multiple parties must provide their approval for the release of the funds it can be used in decentralized organizations where they facilitate this centralized decision making within organizations by requiring multiple keyh holders to approve proposals or fund location finally they can be used to secure wallets multi contracts can be used to create secure wallets where multiple signatures are required to authorize outgoing transactions which provides enhanced protections against unauthorized access or theft as an exercise your job will be to create a multi contract where in the storage you have a a predefined set of participants and a number of required votes to approve a proposal and you will have an entry point to make a proposal in the form of a Lambda to execute with a deadline and another one to vote for that proposal and have it executed when the number of votes is reached pause the video and give it a try let's take a look at our solution so here we have a Lambda that we will use as an example of proposal that simply sends some Tes to a given address in the contract itself we will have a set of participants a big map with all the proposals a number of required votes for a proposal to be accepted and then the ID that we use as a key for the proposals bigma in the proposed entry point people can call the proposed entry point to send a piece of code a Lambda with with a deadline for people to vote we check that the caller is one of the participants in the multi then we store the proposal with the next ID and we store the code the deadline number of approvals at zero and then a set of people who have already voted to make sure people cannot vote twice on the same proposal then we increment the ID when somebody votes they indicate for what proposal they vote and then we check that they vote before the deadline we check that there are indeed a participants in the multi seek and we check that they have not already voted then we Mark they have voted we increment the number of approvals and then we check if the number of approvals is equal to the required number of votes then we execute the proposal we don't need to delete the proposal because we have to be exactly at the number of approved so if one more person votes then we will exceed the number of proposals and so this will not be executed and in the test we simply instantiate the multi seek with a set of participants and a required number of votes at two so both Alice and Bob have to approve a proposal for it to be executed then we propose a Lambda and have both people vote for it for
