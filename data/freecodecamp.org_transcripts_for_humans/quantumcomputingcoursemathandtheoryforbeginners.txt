With timestamps:

00:00 - Quantum Computing leverages the
00:02 - principles of quantum mechanics to
00:05 - process information at incredible speeds
00:08 - this course provides a solid foundation
00:09 - in Quantum Computing from the ground up
00:12 - taking you from the basics to a thorough
00:15 - understanding of how popular Quantum
00:17 - algorithms work the first section covers
00:20 - all the essential mathematics and the
00:22 - second section is a deeper exploration
00:25 - into the mechanics of quantum computers
00:27 - you'll learn why quantum computers are
00:29 - so powerful and how they're poised to
00:31 - transform technology Michael from
00:34 - Quantum sore created this course if you
00:37 - were to search up on Google M quantum
00:39 - computers you would get answers in the
00:41 - form of analogies like quantum computers
00:44 - use Q bits that are both zero and one at
00:47 - the same time when I first started
00:49 - learning about quantum computers these
00:51 - analogies and explanations never made
00:54 - sense this course was created in order
00:56 - to provide a solid foundation on Quantum
00:59 - computation
01:00 - without using analogies but teaching how
01:03 - quantum computers actually
01:06 - work let's quickly look at the structure
01:09 - of this course the first section of this
01:12 - course goes through the basic
01:14 - mathematics needed to understand the
01:16 - rest of the course including an
01:18 - introduction to complex numbers and
01:20 - basic linear algebra in the next section
01:24 - we'll explore what a cupid is and how we
01:26 - can represent them mathematically we
01:29 - also explore some single qbit operations
01:31 - and discuss some of their properties the
01:34 - third section introduces how we can
01:36 - represent multiple cuq bits
01:38 - mathematically and explor some
01:40 - operations we can perform on multiple
01:42 - cuq bits this section ends on exploring
01:45 - the strange Quantum phenomena of quantum
01:47 - entanglement and phase Kickback in the
01:50 - final section of this course we use
01:52 - everything we have studied up until this
01:54 - point to analyze Quantum algorithms this
01:57 - section showcases why quantum computers
02:00 - as such revolutionary
02:03 - technology let's start with
02:05 - understanding imaginary and complex
02:06 - numbers but before that we need to
02:09 - consider the square roots of numbers
02:11 - let's say we have the equation x^2 is
02:13 - equal to 4 which means X is equal to
02:16 - Plus or - 2 easy but what if x^2 is
02:19 - equal to -4 since a number squared is
02:22 - always greater than zero how can X2 ever
02:25 - be a negative number this is where
02:27 - imaginary numbers come in if we let I be
02:30 - the < TK of1 we can then write the < TK
02:33 - of-4 as plus orus 2
02:41 - I this is an imaginary number any number
02:44 - that contains a factor of theare < TK
02:46 - of1 or
02:49 - I now we move one level up to complex
02:52 - numbers all a complex number is is a
02:54 - number that contains a real number plus
02:56 - an imaginary number a standard complex
02:59 - number looks like this a plus I B where
03:02 - both A and B are real numbers a being
03:05 - the real part of the number and B being
03:07 - the imaginary part of the
03:13 - number complex numbers may not seem very
03:16 - useful but in the next lesson we will
03:18 - see how we can represent complex numbers
03:20 - in another form which is used to model
03:22 - Quantum Computing
03:25 - States we can add and subtract complex
03:27 - numbers pretty easily all we do is add
03:30 - or subtract the real parts and the
03:32 - imaginary
03:33 - Parts pause the video and try adding up
03:36 - these complex
03:45 - numbers multiplication is pretty simple
03:47 - as
03:57 - well but we must remember the before we
04:00 - get i s that becomes -1 since I is the
04:03 - square root
04:09 - of1 the complex conjugate of a complex
04:12 - number is when you take the complex
04:13 - number and flip the sign or negate the
04:15 - imaginary part this is denoted by an
04:18 - asteris here are some
04:22 - examples one cool property of complex
04:25 - numbers is if we multiply any complex
04:27 - number by its complex conjugate the
04:29 - result is always a real number try
04:32 - multiplying 2 + 3 I with 2 - 3 I and
04:35 - confirming this is the
04:42 - case we can think of a complex number as
04:45 - a vector where we have the real axis on
04:47 - the horizontal and the imaginary axis on
04:49 - the vertical this allows us to graph our
04:52 - complex numbers for example the complex
04:55 - number -2 + 3 I would be a vector that
04:58 - would end at the point -2
05:01 - 3 when we represent a complex number on
05:04 - the number plane like this we also
05:06 - uncover another property its magnitude
05:09 - which is its distance from the origin
05:12 - this is denoted with vertical lines and
05:14 - is calculated by using Pythagoras's
05:22 - Theorem so we get that the magnitude of
05:25 - some arbitrary complex number A plus I
05:28 - is equal to the square root of a^ 2 + b^
05:31 - 2 pause the video and see if you can
05:34 - find the magnitude of 4 - 3
05:40 - I this is not the only way of
05:43 - representing complex numbers instead of
05:45 - using real and imaginary Parts as
05:47 - coordinates we can represent them
05:49 - through their magnitude and the angle
05:51 - they make with the Positive xais using
05:54 - trigonometry we find that we can also
05:56 - represent complex numbers in the form r
05:59 - cos theta plus I sin Theta where I is
06:02 - the magnitude of the complex number and
06:05 - Theta is the angle it makes with the
06:06 - Positive X AIS we can find Theta by
06:10 - using the tan function as tan of theta
06:12 - is equal to b a so Theta is arctan of B
06:16 - of A this is called Polar form there is
06:20 - also one other form which is r e to the
06:23 - power of I Theta this form is
06:26 - exponential
06:27 - form pause the video now and try to
06:29 - convert the complex number 1 + I into
06:33 - Polar form then into exponential
06:39 - form in Quantum Computing we almost
06:42 - exclusively use complex numbers in
06:44 - exponential form this is because of the
06:46 - property that when we change Theta we
06:48 - rotate around a
06:56 - circle so multiplying two complex
06:59 - numbers in exponential form whose
07:01 - magnitude is one graphically we are
07:03 - rotating around a unit circle as the
07:06 - angles of the two complex numbers add
07:08 - together you will see once we start
07:10 - studying Quantum Computing that this
07:13 - property is very useful in representing
07:15 - Quantum
07:19 - States a matrix is a 2d arrangement of
07:22 - numbers in the next lesson we will get
07:25 - to the applications of matrices and how
07:27 - they relate to Quantum Computing but in
07:29 - this this lesson we will quickly Define
07:30 - some properties and operations we can do
07:33 - on them we say we have an M byn Matrix
07:36 - if the number of rows is M and the
07:38 - number of columns is n so this Matrix
07:40 - here would be a 2x3
07:44 - Matrix pause the video and see if you
07:47 - can find out the dimensions of these
07:52 - matrices if we want to add two matrices
07:55 - together all we need to do is add each
07:57 - element of the matrices
08:04 - this is the same for subtraction note
08:07 - that we can only add and subtract
08:08 - matrices if the number of rows and
08:10 - columns is the same for both so we
08:13 - wouldn't be able to add these two
08:14 - matrices pause the video and see if you
08:17 - can add these
08:21 - matrices we can also multiply matrices
08:24 - by a scalar if we do each element in the
08:27 - Matrix gets multiplied by the scaler
08:29 - giving us another
08:36 - Matrix when multiplying matrices we have
08:39 - to do this weird operation where to get
08:41 - the element in the First Column and
08:43 - first row we take a sort of dot product
08:45 - with the first row of the left Matrix
08:48 - and the First Column of the right
08:55 - Matrix then to get the second column
08:58 - first row we take the dotproduct of the
09:01 - first row of the left Matrix and the
09:03 - second column of the right
09:10 - Matrix we continue this process until we
09:13 - have all the elements in the new
09:21 - Matrix pause the video and try to
09:23 - complete this matrix multiplication
09:44 - it's important to note that we can only
09:46 - multiply two matrices together if the
09:48 - number of columns of the first Matrix is
09:51 - the same as the number of rows in the
09:52 - second Matrix for example we can't
09:55 - multiply these two mates here since the
09:58 - first one has two columns but the second
09:59 - one has three
10:05 - rows if we have a n by one Matrix we
10:08 - call it a column
10:12 - Vector we can graph these like any other
10:15 - Vector these are useful as one of the
10:18 - ways we can represent a state of a
10:20 - Quantum computation is through a column
10:23 - Vector it turns out that when we
10:25 - multiply a matrix with a column Vector
10:27 - we get another column vector
10:30 - intuitively what is happening is the
10:32 - column Vector is getting transformed by
10:34 - The Matrix so we can use matrices as
10:37 - Transformations on a vector here are
10:40 - some examples
10:50 - graphically as you will see in the
10:52 - quantum Computing sections we do the
10:54 - same process of applying matrices to our
10:56 - Quantum state to apply operations on qu
11:00 - computers we also have a special Matrix
11:03 - called an identity Matrix this Matrix is
11:06 - all zeros except for the main diagonal
11:08 - that has all ones if we multiply the
11:11 - identity matrix by any Matrix we get
11:14 - back the original
11:16 - Matrix verify this is true by
11:18 - multiplying the two-dimensional identity
11:20 - Matrix with this Matrix and check to
11:23 - make sure you get back the original
11:27 - Matrix matrices also have what's called
11:30 - an inverse that when multiplied with the
11:32 - original Matrix gives us the identity
11:34 - Matrix we denote this with a ne1
11:38 - graphically this means that if we have a
11:40 - matrix a and we apply it to a column
11:42 - Vector 1 one if we then apply the
11:45 - inverse of a we lend back on the point 1
11:49 - one therefore applying a than a inverse
11:53 - is the same as applying the identity
11:55 - Matrix which means the column Vector
11:57 - stays in the same spot
12:05 - as we saw previously with complex
12:06 - numbers we can also take the complex
12:09 - conjugate of a matrix this is denoted by
12:12 - the asteris on the top right of the
12:14 - Matrix just like with complex numbers
12:17 - when we apply this we flip the sign of
12:19 - all the imaginary components of all the
12:21 - elements in The Matrix pause the video
12:24 - and find the complex conjugate of this
12:26 - Matrix
12:37 - we can also do what we call the
12:38 - transpose of a matrix this is denoted by
12:41 - the T and involves exchanging its rows
12:43 - with its
12:53 - columns if we combine these two and find
12:55 - the complex conjugate and transpose of a
12:58 - matrix a we get something called a
13:00 - dagger denoted by the dagger symbol what
13:03 - was the point of all this in Quantum
13:05 - Computing we use two types of matrices
13:07 - to apply our operations one of them is
13:10 - unitary matrices these have the property
13:13 - that given a unitary Matrix u u * U
13:17 - dagger is equal to the identity Matrix
13:20 - so U dagger is its
13:22 - inverse geometrically when a unitary
13:25 - Matrix acts on a vector the length of
13:27 - the vector stays the same but it is
13:29 - rotated or flipped this property may not
13:32 - seem very useful but once we start
13:34 - talking about probabilities in quantum
13:36 - computers it will all start to make
13:39 - sense the other type of Matrix we use to
13:42 - apply operations in Quantum Computing is
13:44 - the Homan Matrix these matricies have
13:47 - the property that given a Homan Matrix H
13:50 - H is equal to H dagger as you go through
13:53 - the quantum Computing sections of this
13:55 - course you will start to understand why
13:57 - we use these types of matricies to
13:59 - perform operations on quantum
14:07 - computers sometimes when we apply a
14:09 - transformation to a vector the vector
14:12 - stays in the same direction but just
14:14 - gets stretched or compressed meaning
14:16 - that we can factor out a scalar and get
14:18 - back that same
14:20 - Vector when this happens we call the
14:22 - vector an igen Vector of the
14:24 - transformation matrix that we applied
14:26 - and the Scala we factored out an igen
14:30 - value let's go through an example if we
14:33 - have the Matrix
14:35 - 20112 with the vector 03 applying the
14:39 - Matrix on the vector gives us the vector
14:42 - 06 with this we can Factor at a two
14:45 - leaving us with two times the vector
14:48 - 03 this gives us an igen value of two
14:51 - with the igen vector 03 for that Matrix
15:00 - classical computers use binary zeros and
15:03 - ones to store and process their data
15:06 - quantum computers on the other hand use
15:08 - Q bits or Quantum bits which can be zero
15:10 - and one at the same time we have all
15:13 - heard this explanation of quantum
15:14 - computers but what does that actually
15:16 - mean in order to understand what a
15:19 - quantum computer is actually doing we
15:21 - must look at how we represent them
15:24 - mathematically instead of using binary
15:26 - like classical computers quantum
15:28 - computers use cubits physically a cubit
15:32 - can be any Quantum particle that exists
15:34 - in two distinct states such as a photon
15:37 - of light being polarized either
15:38 - horizontally or vertically just like
15:41 - classical computers we still use zeros
15:43 - and ones but in Quantum computation we
15:46 - Define them instead as the column
15:48 - vectors 1 0 and 01 respectively the
15:52 - weird brackets around 0 and one is
15:55 - direct notation we will look more into
15:57 - it later you may have heard of the term
16:00 - superposition what it means in quantum
16:02 - mechanics is that a Quantum particle is
16:05 - in two states at the same time so back
16:08 - to our Photon polarization example this
16:11 - means that the photon is both
16:12 - horizontally and vertically polarized at
16:15 - the same
16:16 - time in terms of quantum Computing we
16:19 - say a cuit is in superp position if it
16:21 - is both zero and one at the same time
16:24 - let's look at how we represent cubits
16:26 - mathematically
16:29 - mathematically we can represent a qit as
16:32 - a column Vector with two elements the
16:35 - top element indicates how much the qbit
16:37 - is in the zero State and the bottom
16:39 - element indicates how much the cuit is
16:41 - in the one state the convention for a
16:43 - Quantum state is to set it equal to the
16:45 - Greek letter s we'll talk more about
16:47 - this in the next video so if we have a
16:50 - cubit in the state 1 Z it now makes
16:52 - sense why this is zero since it is all
16:55 - in the zero State and none in the one we
16:57 - can say the same for Q bit in the state
17:00 - 01 being one if a qbit is in both the
17:04 - zero and one state so it has nonzero
17:06 - numbers in The Matrix then we say it is
17:09 - in a superposition of 0 and one since it
17:11 - is both of the states at the same time
17:14 - so now we know how to represent a cubit
17:16 - mathematically but how do we measure the
17:18 - cubits for that we must look at another
17:21 - rule of quantum mechanics when we
17:23 - measure a Quantum system it changes the
17:25 - state of the system to the measurement
17:28 - what does that mean
17:29 - if we go back to our Photon polarization
17:32 - example if the photon is in a
17:34 - superposition of both horizontally and
17:36 - vertically polarized then when we
17:38 - measure it we will only measure it as
17:40 - one or the other but not both and once
17:42 - it has been measured it collapses into
17:45 - the state we measured so if it was in a
17:48 - super position and we measure it to be
17:50 - horizontally polarized it would collapse
17:52 - and become horizontally polarized
17:54 - meaning it is not in a super position
17:57 - anymore the same thing happens when we
17:59 - measure Q bits we can only measure a
18:02 - zero or one we do not measure how much
18:05 - the QQ bit is in the zero state or how
18:07 - much the cuq bit is in the one
18:09 - state immediately after measuring a cuq
18:12 - bit its state changes to either zero or
18:15 - one depending on the
18:16 - measurement so what is the point in
18:19 - those numbers telling us how much the
18:20 - cuq bit is in the zero State or the one
18:24 - state what those numbers tell us is the
18:27 - probability of measuring a 0 or
18:30 - 1 the probability of measuring zero is
18:33 - the magnitude squar of the amplitude of
18:36 - the zero State and the probability of
18:39 - measuring one is the magnitude squ of
18:41 - the amplitude of the one
18:44 - state so for this example Cubit when we
18:48 - measure it we have a 75% chance of
18:50 - measuring a zero and a 25% chance of
18:53 - measuring a
18:55 - one if we now think about how we defined
18:58 - the Z and one state at the start of the
19:00 - lesson they should now start to make
19:03 - sense we stated that Zer was the column
19:06 - Vector 1 0 and now we can see why the
19:09 - probability of measuring Z is 1 so will
19:12 - always be measured as zero this is the
19:15 - same for the one state since there are
19:18 - only two possible outcomes when
19:20 - measuring a q bit the probability of
19:22 - measuring a zero plus the probability of
19:24 - measuring a one must equal one giving us
19:28 - this equation
19:29 - so this would be a valid Cubit State
19:31 - since the probabilities add up to one
19:34 - but this would not be since the
19:35 - probabilities add up to more than one
19:39 - when we do measure a qbit that is in
19:41 - superp position it collapses into the
19:43 - measured state so if we measure this
19:45 - state to be zero it collapses into the
19:48 - zero state so every measurement after
19:51 - will be zero this is because of the laws
19:54 - of quantum mechanics when we measure
19:56 - something it permanently changes the
19:58 - state of the system to that
20:09 - measurement normally when we are
20:11 - mathematically representing a Quantum
20:13 - state of a quantum computer instead of
20:16 - using matrices we use a specific
20:18 - notation called direct notation to see
20:21 - how this works let's convert an
20:23 - arbitrary Cubit State Alpha Beta into
20:26 - direct notation all we need to to do is
20:29 - turn the Matrix into the sum of two
20:31 - matrices and then factor out the Alpha
20:34 - and the
20:35 - beta now if you look at the column
20:38 - vectors they are the zero and one States
20:40 - as we saw in the previous lesson this
20:43 - gives us a linear combination of the
20:45 - zero and one
20:47 - States those brackets around the 01 and
20:50 - S are called KS all they tell us is that
20:54 - 0 1 and S are quantum States
20:59 - pause the video and convert this Cubit
21:02 - state from Matrix to direct
21:09 - notation this notation might seem weird
21:11 - at first but it is the conventional way
21:14 - of writing a Quantum Computing State
21:17 - since when we start adding more Q bits
21:19 - using matrices to represent them becomes
21:21 - unmanageable as we start to get very
21:23 - large matrices
21:31 - we can represent a cuit graphically on
21:34 - what is called a block sphere on the top
21:37 - we have the zero State and on the bottom
21:40 - we have the one state on the horizontal
21:43 - we have the plus State minus State I
21:46 - State and negative I State we will
21:49 - discuss these in later lessons the
21:51 - closer up the cuit is to the zero State
21:54 - the higher probability of measuring a
21:56 - zero and the same goes for the one
22:00 - state that means that if we have the
22:03 - state 1 on < tk2 1 on < tk2 it will lie
22:07 - halfway between the North and South
22:09 - Poles since it has an even chance of
22:11 - being measured as Zer or
22:14 - one you may notice that since it is a
22:17 - sphere the cubic can spin around the
22:19 - sphere this is called phase we will talk
22:23 - about this in later
22:24 - lessons right now it is important to
22:27 - understand the basic idea that the
22:29 - higher up the qbit is the more likely we
22:32 - are to measure a zero and the lower the
22:34 - qbit the more likely we are to measure a
22:37 - one pause the video and think about
22:40 - where the state 1 on 2 < tk3 on2 will be
22:44 - on the Block
22:48 - sphere the cuit 1 on2 < tk3 on2 would be
22:53 - halfway between the Equator and the one
22:55 - state since it has a one on4 chance of
22:58 - being measured as a zero and a 3 on four
23:01 - chance of being measured as a
23:09 - one with classical computers we use
23:12 - logic gates to process data with quantum
23:16 - computers we still use gates to change
23:19 - the states of our cubits but they are a
23:21 - little bit different to your usual logic
23:24 - gates the most common single Cubit gates
23:27 - are the X Y and Zed Gates let's first
23:31 - look at the X gate if we have a Q bit in
23:34 - the zero State and apply the X gate to
23:37 - it it flips to the one state let's try a
23:40 - q bit that is halfway between 0 and
23:43 - one try and see if you can figure out
23:46 - what the xgate is doing let's try a q
23:50 - bit in this
23:51 - state as you can see the xgate flips the
23:55 - Cubit 180° or Pi radians around around
23:58 - the
23:59 - x-axis now let's have a look at the Y
24:01 - gate here are some examples of the Y
24:04 - gate
24:08 - transformation as you can see it does
24:10 - the same thing as the xgate but instead
24:13 - it rotates the Cubit State 180° or Pi
24:17 - radians around the Y
24:20 - AIS lastly we have the Z gate which
24:23 - rotates the cubeit
24:25 - 180° or Pi radians around the Z
24:30 - axis since these Gates rotate the cuit
24:34 - around the specified axis by pi radians
24:37 - if we apply the same gate twice one
24:39 - after the other then the Cubit returns
24:42 - to its original position this means that
24:45 - these three gates are their own
24:48 - inverses we can represent these Gates as
24:51 - matrices here are the matrices for these
24:53 - gates for the moment ignore the complex
24:56 - numbers in the Y gate mat mat we will
24:59 - explain this later in the next lesson
25:01 - when we talk about phase mathematically
25:04 - to apply a gate to a cubit we can
25:07 - multiply The Matrix that represents the
25:09 - gate with the column Vector of the
25:13 - Cubit pause the video and prove that
25:16 - applying the X gate to the zero State
25:19 - gives us the one
25:25 - state in direct notation if we we want
25:28 - to apply a Quantum gate we still use the
25:31 - matrices but instead of using matrix
25:34 - multiplication we look at The Columns of
25:36 - the
25:38 - Matrix the First Column of the Matrix
25:41 - indicates the column Vector the zero
25:43 - state becomes after applying the gate
25:45 - and the second column indicates the
25:47 - column Vector the one state becomes then
25:50 - we can factor out both our zero and one
25:53 - States again to get back into direct
25:56 - notation also since Quantum gates are
25:59 - linear if we apply an arbitrary gate U
26:03 - that gate acts on each of the
26:05 - superposition States
26:08 - individually let's look at an example of
26:11 - applying a gate in direct
26:13 - notation if we want to apply a y gate to
26:16 - this state in direct notation the Y gets
26:19 - distributed into the
26:21 - state then the Y changes the zero state
26:24 - to the First Column of the Matrix and
26:26 - the one state to the second column of
26:28 - the
26:31 - Matrix then we can factor out the I and
26:34 - the negative I the column vectors once
26:36 - again become the zero and one States
26:39 - leaving us with this
26:42 - state with this pause the video and
26:45 - prove that applying a zed gate to a cuit
26:48 - in the state Alpha 0 plus beta 1 gives
26:51 - us the state Alpha 0 minus beta 1
27:04 - looking at this you may be thinking what
27:07 - is the point of the Zed gate this Q bit
27:10 - still has an alpha squar chance of being
27:12 - zero and a beta Square chance of being
27:14 - one it didn't affect their
27:17 - probabilities in the next lesson we will
27:20 - finally bring complex numbers into
27:22 - Quantum Computing with an introduction
27:24 - to phase
27:32 - on the Block sphere we saw in the
27:34 - previous lessons that we could also
27:36 - rotate around the Zed AIS this is called
27:40 - phase it may not seem very useful as the
27:43 - probability of measuring a zero or a one
27:46 - is still the same no matter how much we
27:48 - rotate around but phase is what makes
27:51 - quantum computers as powerful as they
27:53 - are we will get into the uses of phase
27:56 - in the next lesson in this lesson we
27:58 - will see how we can represent phase
28:01 - mathematically to represent phase we
28:03 - have to bring back our old friend
28:05 - complex numbers in Quantum Computing we
28:08 - mostly use complex numbers in
28:10 - exponential form you will now see why
28:14 - but first let's consider some states in
28:16 - the block sphere let's first consider
28:19 - the states 1 or < tk2 0 plus 1 or < tk2
28:22 - 1 if we apply a zgate we get it to the
28:26 - state 1 or < tk2 0 0 - 1 < tk2
28:30 - 1 as you can see the one state was
28:33 - multiplied by a factor of -1 and the
28:37 - Cubit rotated Pi radians around the Z
28:40 - AIS if we represent the -1 as a complex
28:43 - number in exponential form we get e to
28:47 - the I Pi notice how the angle of the
28:50 - complex number is pi
28:54 - radians let's try another example let's
28:57 - plot the state 1 on < tk2 0 + 1 < tk2 1
29:01 - and 1 on < tk2 0 + I on < tk2 1 if we
29:06 - represent I as a complex number in
29:08 - exponential form we get e to the I Pi /
29:12 - 2 and if you look at the Block sphere to
29:14 - get that state we rotate Pi / 2 radians
29:17 - around the Z
29:19 - AIS we use complex numbers in
29:21 - exponential form in Quantum Computing
29:24 - since it gives us a nice mathematical
29:25 - way of rotating around a circle by
29:28 - changing the value of f by multiplying
29:31 - the one state of the Cubit with the
29:33 - complex number e to the I we rotate the
29:36 - Cubit around the Z AIS by five radians
29:40 - but why is it the one state and not the
29:42 - zero State being multiplied by the
29:44 - complex number there are two types of
29:46 - phase Global phase and relative phase
29:49 - Global phase is when the entire cuit is
29:52 - multiplied by a complex number and
29:54 - relative phase is when just the one
29:57 - state is multip IED by a complex number
29:59 - it turns out the global phase is
30:01 - physically
30:02 - irrelevant so the state e to the I * 1 <
30:06 - tk20 + 1 < tk2 1 is logically equivalent
30:10 - to the state 1 < tk2 0 + 1 < tk2 1
30:14 - relative phase on the other hand is
30:16 - extremely important and matters in our
30:18 - calculations relative phase is when the
30:21 - amplitude of the one state has a factor
30:23 - of a complex number as we saw earlier
30:26 - having relative phase rotates the Cubit
30:29 - on the Block sphere around the Z AIS but
30:32 - what if we have a complex number in both
30:34 - the amplitudes of the zero State and the
30:36 - one state what we do is we factor out
30:39 - the complex number of the zero state
30:41 - from the entire qbit creating a global
30:43 - phase and relative
30:45 - phase then we can discard the global
30:48 - phase leaving us with a qbit with a
30:50 - relative phase we saw previously on the
30:54 - Block sphere that phase does not affect
30:56 - the probability of measuring a zero or a
30:59 - one as the cupit stays the same distance
31:01 - from the zero State and the one state no
31:04 - matter how far we rotate around the
31:06 - block sphere if we look at an arbitrary
31:09 - Cubit State Alpha 0 plus e to the I5
31:12 - beta 1 the probability of measuring a
31:15 - one is the magnitude of e the5 beta
31:18 - squar we can split the absolute values
31:21 - up like this the magnitude of e to the
31:24 - II is 1 since the coefficient of the
31:27 - complex number in exponential form
31:29 - states its magnitude so the probability
31:32 - of measuring one is still the magnitude
31:34 - of beta squ in the next lesson we will
31:38 - see why relative phase
31:46 - matters before we discuss perhaps the
31:49 - most important gate in Quantum Computing
31:51 - we will quickly revisit the block sphere
31:54 - in earlier lessons we saw that on the
31:56 - equator we have four states
31:58 - the plus State minus State I State and
32:01 - negative I State now that we know about
32:04 - phase we can Define these states all
32:07 - they are a shorthand for commonly used
32:10 - States since they all lie on the equator
32:12 - of the block sphere they all have an
32:14 - even chance of being measured as zero or
32:17 - one but each one contains a different
32:20 - relative phase the plus state is the
32:23 - state 1 < tk2 0 + 1 < tk2 1 the next
32:28 - state is the minus State this is the
32:30 - same as the plus state but with a
32:32 - relative phase of
32:35 - -1 the I state has a relative phase of I
32:39 - and the negative I state has a relative
32:42 - phase of negative
32:45 - I now let's look at the hadam mod gate
32:49 - here is the Matrix for the gate if we
32:51 - look at how the gate acts on a qit on
32:54 - the Block sphere we see that the zero
32:57 - state gets trans transformed into the
32:58 - plus State and the one state gets
33:02 - transformed into the minus
33:04 - State applying a hadam mod to the plus
33:07 - State gives us the zero State and
33:10 - applying a hadam mod to the minus State
33:12 - gives us a one state this means that the
33:15 - hadam mod is its own
33:17 - inverse if we wanted to apply a hadam
33:20 - mod gate to an arbitrary Cubit state in
33:22 - direct notation we can replace the zero
33:25 - with the plus State and the one with the
33:28 - minor State and
33:33 - expand the hadamar gate shows that phase
33:36 - matters if we apply the gate to the plus
33:39 - State we get zero and to the minus State
33:42 - we get one these states only differ by a
33:45 - relative phase but after applying the
33:47 - gate they are different even though
33:50 - initially they both had a 0.5 chance of
33:53 - being measured as zero and a 0.5 chance
33:56 - of being measured as one in the fourth
33:58 - section of this course we will start to
34:00 - look at some Quantum Computing
34:03 - algorithms and you will start to see why
34:05 - the hadide gate and phase is so
34:13 - powerful now that we understand relative
34:16 - phase let's introduce two new gates the
34:20 - s and t Gates the S gate adds a relative
34:24 - phase of Pi on 2
34:26 - radians the T eate adds a relative phase
34:29 - of Pi on 4
34:31 - radians if we take the conjugate
34:33 - transpose of the two matrices of the two
34:36 - gates we get their inverses for the S
34:39 - gate we can see that applying s dagger
34:42 - adds a relative phase of negative pi on
34:45 - 2 which is the inverse of the S gate
34:49 - this means that if we apply a s gate
34:52 - then an S dagger gate we are back in the
34:54 - same spot meaning the S dagger gate is
34:57 - the inverse of the S gate we also have
35:01 - the T dagger gate which is the same
35:03 - thing as the S dagger but adds a
35:05 - relative phase of piun on 4 radians
35:08 - instead meaning it is the inverse of the
35:12 - T
35:17 - gate if we have multiple cuq bits we
35:20 - represent them through the tensor
35:22 - product for example if we had two cuq
35:26 - bits in the zero state then we would
35:28 - represent the state like this this is
35:31 - usually shortened to this where we have
35:33 - the two zeros in the one get
35:36 - Vector if we wanted to represent two
35:38 - cubits in superp position we can expand
35:41 - it out like any other operation by
35:44 - multiplying the amplitudes of the states
35:46 - and using the tensor product on the zero
35:49 - and one
35:50 - States as you can see now we have four
35:53 - states the 0 0 01 1 0 and one one States
35:59 - this makes sense since those are the
36:01 - possible combinations of zeros and ones
36:04 - we can have with two
36:05 - cubits measurement works the exact same
36:08 - as before the probability of measuring 0
36:11 - 0 is the magnitude squared of the
36:14 - coefficient of the 0 State and so
36:18 - on here is an example of combining these
36:21 - two
36:26 - cubits if we want to add another q bit
36:29 - to the system all we need to do is
36:31 - tensor it onto the end of the
36:35 - state we also have some Shand notation
36:38 - you will sometimes see if we have n Zer
36:42 - we can write it like this which means 0
36:45 - tensed with itself n times so this state
36:48 - would be shorthand for 5
36:55 - ones this represents ation of cuits is
36:59 - great but what if we wanted to apply a
37:01 - gate to a certain cuit how would we
37:04 - indicate that we wanted to let's say
37:07 - apply an xgate to the second cubit in
37:09 - this state for this we use a diagram
37:13 - called the quantum circuit here is an
37:15 - example of one on the vertical we have
37:18 - the cubits each line representing a
37:21 - singular Cubit the states on the left
37:24 - are the initial states of the cuits the
37:27 - bo boxes are the quantum Gates and the
37:29 - letters on the boxes are the type of
37:32 - gate we are applying for example this is
37:35 - an X gate these boxes are measurements
37:39 - and represent us measuring the Cubit the
37:43 - horizontal is the order in which we
37:45 - apply the gates we start from the left
37:48 - and go to the right sometimes you will
37:51 - also see size States pointing to
37:53 - different points in the circuit these
37:56 - are used to represent the state of the
37:58 - system at different points during the
38:01 - algorithm let's go through this circuit
38:04 - at S Sub 0 we have the state 0 01 then
38:09 - at SI sub one we apply an X gate to the
38:12 - second
38:14 - Cubit at SI sub 2 we apply a hadam mod
38:18 - gate to the second Q bit giving us this
38:23 - state then at S Sub 3 we apply an xgate
38:27 - to both the first Cubit and the third
38:29 - Cubit giving us this
38:31 - state then at size sub 4 we measure the
38:35 - cubits so we will get one of these
38:37 - states with these
38:45 - probabilities now let's introduce some
38:48 - gates that act on multiple cuy bits the
38:50 - most common multibit gate is the c not
38:54 - or controlled X gate here is the gate on
38:57 - a Quantum circuit the gate acts on two Q
39:00 - bits one of the Q bits is called the
39:03 - control Q bit and the other is called
39:05 - the target QQ bit the C not gate applies
39:09 - an X gate to the Target QQ bit if the
39:12 - control QQ bit is a one and does nothing
39:15 - if the control is a
39:17 - zero let's look at the C not gate acting
39:20 - on some states if we apply a c not to
39:23 - this state with the first Q bit as the
39:25 - control and the second Q bit as the
39:28 - target then we apply that c not gate to
39:31 - each of the superposition States giving
39:34 - us this
39:35 - state here is another
39:43 - example we also have the tooli gate this
39:47 - gate is very similar to the C not but
39:49 - instead it has two control cubits here
39:52 - it is on a Quantum circuit
39:58 - if we apply a tooli gate to this Cubit
40:01 - state with the second and third cuq bits
40:04 - as control and the fourth Cubit as the
40:07 - target we get this
40:10 - state it turns out that we can use senal
40:13 - gates to create controlled versions of
40:16 - single qbit Gates so we also have
40:19 - controlled y z s t and hadamard Gates
40:24 - they act the same as the C not flying
40:27 - the gate if the control is one and does
40:30 - nothing if the control is
40:32 - zero we represent these on a Quantum
40:35 - circuit like this with the regular gate
40:38 - box but with a line going out to the
40:40 - control CU bit for example here is the
40:44 - controlled es gate on a Quantum circuit
40:47 - where the second qbit is the control and
40:49 - the first is the target
40:57 - now that we have multiple cuq bits how
40:59 - do we measure a single cuq bit let's say
41:03 - we have two cuq bits in this state and
41:05 - we wanted to find the probability of
41:07 - measuring the second Cubit as a one we
41:11 - do this by looking at all the
41:13 - superposition states where the second CU
41:16 - bit is one then summing up the
41:18 - probabilities of measuring those
41:25 - States Let's do an example
41:27 - if we wanted to find the probability of
41:30 - measuring a zero in the first CU bit
41:33 - then we sum the probabilities of
41:34 - measuring each of the states where the
41:37 - first Q bit is a
41:39 - zero but how do we know what the state
41:42 - collapses to once we measure a qbit
41:46 - remember once we measure a qbit it
41:48 - collapses its superp position and
41:50 - becomes the measurement let's look at an
41:54 - example say we have this state and we
41:56 - measured me the first cuit to be a one
42:00 - then the state collapses and since the
42:02 - first cuit becomes a one we get rid of
42:05 - all the superposition states where the
42:07 - first Cubit is not a
42:10 - one remember the probabilities must add
42:13 - up to one but we have just removed some
42:17 - states so the probabilities will be less
42:20 - than one we fix this by multiplying the
42:23 - state by what we call a normalization
42:25 - constant let's call it a now we can
42:28 - normalize the state by using the
42:30 - identity that the probabilities must add
42:33 - up to one this gives us values for a so
42:37 - if we measure the first CU bit to be one
42:40 - the state collapses to this state we can
42:43 - use these techniques with any number of
42:46 - cubits let's go through an example with
42:49 - three cubits let's say we have this
42:52 - state and we measure the middle Cubit to
42:54 - be zero the state collapses like this
42:58 - collapsing into this
43:08 - state let's consider this Quantum
43:11 - circuit at SI Sub 0 we have the state 0
43:15 - 0 then at S Sub 1 we have the state 1 on
43:19 - < TK to 0 plus 1 0 Let's distribute the
43:24 - zero State into the equation giving us
43:26 - the state 1 < tk2 0 0 + 1
43:31 - 0 now at size sub 2 we apply a cot with
43:35 - the first qbit being the control and the
43:38 - second being the target this means that
43:41 - the 0 0 state stays the same since the
43:44 - control is zero but for the one zero
43:47 - State the control is one so the second Q
43:50 - bit flips to a
43:52 - one this leaves us with the state 1 on <
43:56 - tk2 0 0 + 1 1 can you notice anything
44:00 - weird about this state if we were to
44:04 - measure one of the cubits as a zero the
44:07 - other would collapse into a zero and if
44:10 - we were to measure a one the other would
44:12 - collapse to a
44:15 - one so without even looking at both the
44:18 - cubits by measuring one of them we
44:21 - immediately know the state of the other
44:23 - Cubit this is called entanglement
44:27 - there are many different entangled
44:29 - States we say a state is entangled if it
44:32 - cannot be factored into the tensor of
44:35 - single Cubit
44:37 - States for example this state is not
44:40 - entangled since we can Factor it like
44:42 - this but this state is entangled since
44:45 - we cannot Factor it into singular Cubit
44:48 - States what this means is that when the
44:51 - cuits are entangled they depend on each
44:54 - other to determine their state
44:57 - there are two types of entangled States
45:00 - maximally entangled States and partially
45:03 - entangled States we say CU bits are
45:06 - maximally entangled if measuring one of
45:09 - the CU bits tells us the state that the
45:11 - other Q bits are in so the example
45:14 - entangled state from the beginning 1 on
45:18 - < tk2 0 0 + 1 1 is maximally
45:23 - entangled here are the common maximally
45:25 - entangled States with two
45:28 - cubits we call these states the Bell
45:30 - States and we denote them with capital
45:33 - fi and
45:36 - S we say cubits are partially entangled
45:40 - if the measurement of a cubit affects
45:42 - the probabilities or phase of the other
45:46 - cubits for example with this state if we
45:50 - measure the first cuq bit as zero the
45:52 - state collapses to this but if we
45:55 - measure the first Q bit as a one then it
45:58 - collapses to this state as you can see
46:01 - the two states have different
46:03 - probabilities of measuring Zer or one so
46:06 - this state is partially entangled since
46:09 - measuring one cubit affects the
46:11 - probabilities of the
46:20 - other another quantum property we can
46:23 - use is something called phase Kickback
46:26 - to understand and how this works let's
46:28 - consider this circuit as you can see we
46:31 - have a Q bit in the plus State and
46:33 - another q bit in the state V we also
46:36 - have an arbitrary controlled U
46:39 - operation let's say that V is an igen
46:42 - state of u so if we apply the U gate to
46:45 - the state V we get e to the I Theta V
46:49 - since all I values of quantum computers
46:52 - can be represented as e to the I
46:55 - Theta now at sub one we have the state
46:59 - plus V Let's expand the plus State and
47:02 - distribute the V State into the plus
47:04 - State at S Sub 2 we apply the controlled
47:08 - uate nothing happens to the first
47:10 - superposition State since the control is
47:13 - a zero but the second superposition
47:15 - state has the gate applied to the V
47:17 - State since the control is a
47:20 - one we can now Factor back out the V
47:23 - state from the equation can you see what
47:26 - has happened
47:27 - V is unchanged even though it was the
47:30 - Target qit and a factor of e the I Theta
47:33 - has been applied as a relative phase to
47:36 - the control
47:37 - Cubit this occurs if V is an igen state
47:41 - of the gate you are applying we call
47:44 - this phenomenon phase Kickback and it is
47:46 - used in some Quantum algorithms
47:58 - let's have a look at superdense coding
48:01 - this Quantum protocol allows us to send
48:03 - two bits of classical information with
48:06 - only one cubit to do this we need
48:09 - entanglement we'll say that the person
48:11 - sending the Cubit is Alice and the
48:13 - person receiving this Cubit is
48:16 - Bob to start off with Alice and Bob
48:19 - maximally entangle two cubits so they
48:22 - are in this state Alice takes one and
48:25 - Bob takes the other we will say that
48:27 - Alice takes the left QQ bit and Bob
48:29 - takes the right cuq bit then Alice and
48:31 - Bob take those cubits with them now when
48:35 - Alice wants to send two bits of
48:36 - classical information to Bob depending
48:39 - on which two bits of information Alice
48:41 - wants to send she performs some
48:43 - operations on her Q bit if Alice wants
48:47 - to send the two classical bits 0 0 she
48:50 - does nothing and sends her Q bit to Bob
48:54 - if Alice wants to send 01 she an X gate
48:57 - to her qbit transforming the CU bits to
49:00 - this state then she sends her Cubit to
49:03 - Bob if Alice wants to send one Z she
49:07 - applies a zgate to her Q bit
49:09 - transforming the Q bits to this state
49:11 - then she sends it to Bob lastly if she
49:14 - wants to send one one she applies both
49:17 - an x and z gate to her cuit giving us
49:21 - this state she then sends her qbit to
49:24 - Bob now Bob has both the cubits in one
49:27 - of these four states he now applies a c
49:30 - not with the first Cubit as a control
49:33 - and the second as the target giving us
49:35 - these
49:36 - states then he applies a hadam mod gate
49:39 - to the left key bit this gives us this
49:41 - state that Alice wanted to send all Bob
49:44 - now has to do is measure the Q bits and
49:47 - he will get the two bits Alice intended
49:49 - to send as you can see with quantum
49:52 - computers we can send two bits of
49:54 - classical information by sending one Q
49:57 - bit this works since there are two
49:59 - entangled Q bits in the entire
50:08 - system before we look at how we can
50:10 - apply functions on quantum computers we
50:13 - will quickly look at how classical
50:15 - computers perform operations on bits and
50:18 - how we make classical operations
50:20 - reversible there are four main
50:22 - operations we can perform on classical
50:24 - bits the and or not and exclusive or
50:28 - operations let's go through each one of
50:30 - them quickly the simplest is the not
50:33 - gate which flips 0 to 1 and 1 to zero
50:37 - here is the truth table for the gate
50:39 - where X is the input and F ofx is the
50:42 - output as you can see this gate acts on
50:45 - one bit now let's look at the end gate
50:49 - here is the truth table for the gate the
50:51 - operation acts on two bits and returns
50:54 - one if the two bits are one and zero
50:58 - otherwise the orgate acts on two bits as
51:01 - well if either of the bits is a one or
51:04 - both or one then it returns one
51:07 - otherwise it returns
51:09 - zero lastly we have the exclusive or
51:12 - gate here is the truth table for the
51:15 - operation as you can see it returns one
51:18 - if either of the inputs is one and
51:20 - returns zero if both the bits are zero
51:23 - or one we use the exclusive or operation
51:26 - to reversible classical Gates we say a
51:29 - function f is reversible if given F ofx
51:33 - we can determine the value of x so if we
51:36 - are given the output we can determine
51:39 - the input so this function here where we
51:42 - negate the second bit is reversible
51:45 - since each row of the truth table for
51:47 - this function is unique so we can map
51:50 - each output to a unique input but the or
51:54 - operation on the other hand is not
51:56 - reversible
51:57 - since if we get an output of one we
51:59 - cannot say what the input was it could
52:02 - have been any of these three
52:05 - inputs to make any classical gate
52:07 - reversible we must input another bit
52:10 - let's call it C and instead of only
52:12 - returning F ofx we return the input X as
52:16 - well as C exclusive or with F ofx this
52:19 - makes the operation reversible let's
52:22 - look at converting the orgate to a
52:24 - reversible operation
52:26 - here is a normal orgate and here is a
52:29 - reversible orgate as you can see we
52:32 - input another bit C and return it
52:35 - exclusive or with the
52:37 - output now looking at the truth table
52:40 - each row of the outputs is unique so the
52:42 - gate is reversible since we can
52:45 - determine the input from the
52:48 - output what is the point in all this
52:51 - well with quantum computers all
52:53 - operations besides measuring the qits
52:55 - must be reversible this is because every
52:58 - operation must be unitary if you
53:01 - remember from the first section of this
53:03 - course unitary matrices rotate and flip
53:06 - a vector so they must be reversible in
53:09 - the next lesson we will discuss how we
53:11 - can apply functions on quantum computers
53:14 - using the same techniques that we used
53:16 - to make reversible classical
53:22 - Gates we discussed in the previous
53:25 - lesson how we can make classical Gates
53:27 - reversible now let's use this same
53:29 - technique to make Quantum functions
53:32 - since the operations we perform on
53:34 - quantum computers must be reversible if
53:37 - we wanted to apply a function on a
53:39 - quantum computer the function must be
53:41 - reversible to do this we use the same
53:43 - techniques for making classical Gates
53:45 - reversible a standard Quantum function
53:48 - looks like this where we input X and Y
53:51 - and get back X and Y exclusive or with f
53:55 - ofx
53:57 - now you might be thinking how are we
53:59 - going to get the output if it is
54:01 - exclusive or with Y but if we set y to
54:04 - zero then we get zero exclusive or with
54:07 - f ofx zero exclusive or with any bit
54:11 - gives us back that bit this means that
54:14 - zero exclusive or with f ofx is just F
54:18 - ofx this allows us to query the function
54:21 - and get its output on a quantum computer
54:24 - we can encode functions within a unitary
54:26 - Matrix and so it is a valid Quantum gate
54:30 - we usually denote a function f as U subf
54:34 - so overall if we apply a function f to
54:37 - the state x0 we get the state x f ofx
54:43 - then to get the function output we can
54:45 - measure the second register of
54:47 - cuits let's see what happens if we apply
54:50 - a function f to this state with the
54:52 - output register being the minor State
54:55 - first let's rewrite the minor State like
54:58 - this and distribute the X State into the
55:01 - superposition since the function is a
55:03 - unitary operation it gets distributed
55:05 - into the superposition like any other
55:08 - gate then it acts on each of the
55:10 - superposition States individually
55:12 - applying U subf we get this state the
55:16 - zero exclusive W with f ofx becomes F
55:18 - ofx and the One exclusive W with f ofx
55:21 - becomes not F ofx now let's consider two
55:25 - scenarios if f ofx is equal to 0 then
55:29 - the state becomes 1 < tk2 x0 - X1 which
55:34 - we can rewrite as x minus on the other
55:38 - hand if f ofx is equal to 1 then the
55:40 - state becomes 1 on < tk2 X1 - x0 we can
55:46 - factor out the -1 leaving us with the
55:49 - state-1 on2 x0 - X1 this can be further
55:53 - factored intox
55:56 - minus now looking at these two states we
56:00 - can see that the only difference is the
56:02 - phase at the front we can combine these
56:04 - two equations into -1 to^ FX
56:09 - xus so if we apply a function to the
56:13 - state xus we get back -1 to the^ of f
56:17 - ofx xus when we query a function in this
56:21 - way where the output bit is in the minor
56:24 - State we call it a phase Oracle in the
56:27 - next lesson we will finally see how
56:29 - quantum computers can outperform
56:31 - classical computers with Deutsch's
56:33 - algorithm which uses this technique of
56:36 - the phase
56:37 - Oracle one more thing we will discuss
56:40 - when it comes to quantum computers is a
56:42 - theorem called the no cloning theorem
56:45 - when we want to copy bits on a classical
56:48 - computer all we need to do is read the
56:51 - values of the bits and write the values
56:53 - to other bits but with quantum computers
56:56 - if if we have a CU bit in an unknown
56:58 - State say we have S is equal to Alpha 0
57:01 - + beta 1 we cannot copy this state if we
57:04 - don't know Alpha and beta if we were to
57:06 - measure s we would get Z or 1 but to
57:10 - copy the state we need to know the
57:12 - amplitudes so we would need to know
57:14 - Alpha and beta we could easily copy qbit
57:17 - states where we know the amplitudes by
57:19 - applying the needed Gates but if we do
57:21 - not know the state we cannot copy a cuit
57:31 - now let's finally look at a Quantum
57:33 - algorithm deutch's algorithm but first
57:36 - let's look at the problem it solves and
57:38 - how we would solve that problem with a
57:40 - classical computer say we have a
57:43 - function f that takes in a bit and
57:46 - returns a bit we don't know what the
57:48 - function does all we can do is send in a
57:51 - bit and read the output bit it is like a
57:54 - black box our t ask is to find out
57:57 - whether the function f is constant or
58:01 - balanced if a function is constant then
58:04 - it Returns the same bit no matter the
58:06 - input here are the two constant
58:08 - functions that can act on one bit
58:11 - constant one which always returns one
58:14 - and constant zero which always returns
58:17 - zero balanced functions on the other
58:20 - hand return zero for half the inputs and
58:23 - one for the other half of the inputs
58:25 - here are the are the two balanced
58:27 - functions that can act on one bit
58:30 - identity which Returns the input and the
58:32 - not gate which we saw before which flips
58:35 - the bit as you can see both these
58:38 - operations return zero for one input and
58:41 - one for the other
58:42 - input for this problem we don't care if
58:46 - the function is a not gate or a constant
58:48 - zero we only care if it is constant or
58:51 - balanced if we wanted to find out if f
58:54 - is constant or balanced on a classical
58:57 - computer we would first need to input
58:59 - zero and then input one to see if we get
59:02 - the same or different values if f of0
59:06 - equals F of 1 then we know that the
59:08 - function is constant and if F of 0 does
59:11 - not equal F of one then the function is
59:13 - balanced so we need to query the
59:15 - function twice once with zero as the
59:18 - input and once with one as the input
59:20 - with quantum computers and Deutsch's
59:22 - algorithm however we only need one query
59:25 - of the function to find out if the
59:27 - function is constant or balanced here is
59:30 - the circuit for the algorithm the U of
59:33 - represents the function f at S Sub 0 the
59:37 - Q bits are in the state 0
59:39 - 0 then at SI sub 1 the cubits are in the
59:43 - state
59:44 - 01 at SI sub 2 we apply a hadam mod to
59:48 - each of the cubits leaving us with the
59:50 - state plus minus let's expand the plus
59:54 - State and distribute the minus state
59:56 - into the
59:57 - equation now at SI sub 3 we apply the
60:00 - unitary Matrix UF acting as the function
60:03 - to the state since all Quantum
60:06 - operations are linear UF gets
60:08 - distributed into the state and acts on
60:11 - each of the superposition States
60:13 - individually if we look at each of the
60:15 - superposition States they are in the
60:17 - phase Oracle form so applying U of f to
60:20 - the first state becomes -1 to the^ of f
60:23 - of 0 0 minus and the second state
60:26 - becomes -1 to ^ f of1 1
60:30 - minus the minus qbit is not needed for
60:33 - the rest of the algorithm so we will
60:35 - emit it to clean up the equation now
60:38 - let's consider two different scenarios
60:41 - if F of 0 equals F of 1 then the state
60:44 - becomes 1 / < tk2 0 + 1 if F of 0 and F
60:48 - of 1 equal 0 or 1 / < tk2 0 - 1 if F of
60:55 - 0 and F of 1 = 1 with this we can factor
60:59 - out a global phase of -1 leaving us with
61:03 - 1 < tk2 0 + 1 therefore if F of 0 equal
61:09 - F of 1 the state becomes 1 / < tk2 0 + 1
61:13 - or the plus State now let's look at if F
61:17 - of 0 does not equal F of 1 so if F0 = 0
61:21 - and fub1 = 1 the state becomes 1 / < tk2
61:26 - 0 - 1 if F of 0 = 1 and F of 1 = 0 then
61:31 - the state becomes 1 / < tk2 - 0 + 1 with
61:36 - this we can factor out a global phase of
61:39 - -1 leaving us with the minus
61:46 - state so overall if F of 0 equals F of
61:50 - one the state becomes the plus State and
61:52 - if F of0 does not equal F of 1 the state
61:55 - becomes the minor State see if you can
61:58 - finish the rest of the algorithm off
62:02 - yourself now at SI sub 4 we apply a
62:05 - hadam mod to the Q bit in the case where
62:08 - F of 0 equals F of 1 this transforms the
62:11 - state into zero and in the case where F
62:14 - of 0 does not equal F of one the state
62:17 - becomes one now all that's left to do is
62:20 - measure the Cubit looking at our
62:22 - equations if we measure a zero then the
62:25 - function is constant since f of0 equals
62:28 - F of 1 and if we measure one then the
62:31 - function is balanced since F of 0 does
62:33 - not equal F of one as you can see what
62:36 - took a classical computer two queries of
62:39 - the function was done with one query of
62:41 - the function on a quantum
62:43 - computer in the next lesson we will look
62:46 - at the DEA algorithm which considers
62:49 - itself with the same problem of deutch's
62:51 - algorithm of finding out if a function
62:53 - is constant or balanced but in instead
62:56 - of having a function that only inputs
62:58 - one bit the algorithm is a general case
63:01 - that accepts any number of bits as
63:08 - input the deuts josa algorithm considers
63:11 - itself with the same problem of
63:13 - deutsche's algorithm of finding out if a
63:16 - function is constant or balanced but
63:18 - instead this algorithm is a general case
63:21 - that can accept any number of bits as
63:24 - input let's quickly revise constant and
63:27 - balanced functions constant functions
63:30 - always return the same value no matter
63:32 - the input here are the two constant
63:35 - functions constant Z and constant
63:38 - one balanced functions return zero for
63:41 - half the inputs and one for the other
63:43 - half of the inputs here is an example of
63:46 - a balanced function that takes in a bit
63:48 - string of length three as you can see
63:51 - the function returns zero for four of
63:53 - the inputs and one for the other four of
63:56 - the
63:57 - inputs for a classical computer to solve
63:59 - this problem it would need to query the
64:02 - function in the worst case 2 ^ n -1 + 1
64:06 - * where n is the length of the bit
64:09 - string the function takes as
64:11 - input this is because in the worst case
64:14 - we check half of the inputs and get the
64:16 - same output for all of them when this
64:19 - happens we need to check one more input
64:21 - to determine whether the function is
64:23 - constant or balanced the there are two
64:26 - to the N possible bit strings of length
64:28 - n so 2 the nus1 is half of the possible
64:32 - inputs therefore we need to check half +
64:36 - 1 so 2 n-1 + 1 inputs in the worst case
64:41 - to be certain the function is constant
64:43 - or balanced with a quantum computer we
64:46 - only need one query of the function just
64:49 - like deutch's algorithm to determine
64:52 - whether the function is constant or
64:54 - balanced
64:55 - here is a circuit for the algorithm this
64:58 - line here going through the circuit
65:00 - represents n qits and the hamod gates
65:04 - tensor n represent n hadam mod Gates
65:07 - each one being applied to one of the N
65:10 - cubits let's go through the algorithm at
65:13 - S Sub 0 we have n z minus then at S Sub
65:18 - one we apply a hadam mod gate to each of
65:21 - the N zeros giving us this state let's
65:24 - quickly derive anide identity that we
65:26 - frequently use when applying hatam mods
65:28 - to a register of zeros this gives us n
65:32 - plus States if we expand them out we get
65:35 - 1 / < tk2 0 + 1 tens with 1/ < tk2 0 + 1
65:40 - and so on N times let's try different
65:43 - values of n to figure out how we can
65:45 - represent this mathematically if we have
65:48 - Nal 2 we have the plus state tensored
65:51 - with itself Distributing the states
65:53 - gives us a state one of a < tk2 2 0 0 +
65:58 - 0 1 + 1 0 + 1
66:01 - 1 we can represent the superposition
66:03 - States like this with a sum over all bit
66:06 - strings of length 2
66:09 - x let's try n = 3 with this we have the
66:13 - plus state tensored with itself three
66:15 - times Distributing gives us this state
66:18 - we can once again represent the
66:20 - superposition States as a sum of all
66:23 - possible bit strings of length three and
66:25 - X resulting in this state we can
66:28 - generalize this and say that if we apply
66:31 - a hadam mod to each of the N zeros we
66:34 - get 1 / < tk2 to the^ of n time the sum
66:37 - of all bit strings of length n x this is
66:41 - a very important identity in Quantum
66:44 - algorithms and is used in many
66:46 - algorithms if you think about it this
66:48 - makes sense since each Cubit is in the
66:51 - plus state it has an even chance of
66:53 - being zero and one so every possible
66:56 - combination of zeros and ones will occur
66:58 - in the state and with equal
67:01 - probabilities going back to size sub 1
67:04 - we can now change this to our
67:07 - identity now at size sub 2 we apply the
67:10 - Oracle function since the function acts
67:13 - on each of the superposition States we
67:16 - distribute it into the sum now if you
67:19 - look at each of the superposition states
67:21 - in the sum they are in the phase Oracle
67:24 - form applying the function function
67:26 - gives us the equation 1 / < tk2 the^ of
67:29 - n * the sum of all bit strings of length
67:32 - n -1 to the^ of f ofx
67:36 - xus let's emit the minus Q bit from the
67:39 - equation as it is not needed in the
67:41 - algorithm anymore at size sub 3 we once
67:45 - again apply a hatam mod to each of the
67:47 - CU bits what this means is that for
67:50 - every bit in the bit string X we apply a
67:53 - hadam mod gate you may be looking at
67:55 - this and thinking that we can use the
67:57 - formula we used before but that one can
68:00 - only be used when the state is all zeros
68:03 - the X State can be any combinations of
68:06 - zeros and ones let's quickly figure out
68:09 - how we can represent this mathematically
68:12 - for this we can rewrite the hadam mod
68:14 - transform on an arbitrary bit XI as 1 /
68:18 - < tk2 0 + -1 to the^ of x i 1 since if
68:24 - XI is0 it becomes the plus State and if
68:27 - x i is one it becomes the minus State
68:30 - let's try X being a bit string of length
68:33 - three this gives us this state if we
68:36 - tend to the states together we get this
68:38 - state let's quickly add the exponents of
68:41 - the negative 1es as you can see whenever
68:44 - there is a one in the superposition
68:46 - state that state is being multiplied by
68:48 - a negative one to the power of x i where
68:52 - x i is the position of the one we can
68:55 - reite write this as the dotproduct of X
68:57 - with the superposition
69:02 - State now we can combine this state as
69:04 - the sum of all Zs that are bit strings
69:07 - of length three -1 to the^ of X do z
69:12 - z generalizing we get this identity
69:16 - where applying a hatam mod to an
69:17 - arbitrary bit string of length n x gives
69:20 - us 1 / < tk2 to the^ of n * the sum of
69:24 - all bits Str of length n -1 to the^ of X
69:28 - do z
69:30 - z this is also a very important identity
69:34 - that is used in many Quantum algorithms
69:37 - with this the qits are now in this
69:47 - state let's now consider the amplitude
69:50 - of the all zero State we find that it is
69:53 - 1/ 2 ^ n time the sum of all bit strings
69:57 - of length n -1 to the^ of f ofx + x
70:02 - dotted with all zeros the X doted with
70:04 - the all zeros become zero so the state
70:07 - becomes this
70:10 - state now if the function f is constant
70:14 - then the value of f ofx will be the same
70:16 - no matter the input this means that if f
70:19 - ofx is equal to Z the amplitude of the
70:22 - state becomes 1/ 2 to the^ of n time a
70:25 - sum over all X's 1 evaluating the sum
70:30 - there are two to the end possible
70:31 - combinations of Zer and ones of length n
70:35 - so the sum is 1 + 1 + 1 and so on 2 the^
70:39 - of n * this gives us 1 / 2^ n * 2^ of n
70:45 - which equals 1 on the other hand if F
70:48 - ofx isal to one we do the same thing
70:51 - giving us netive - 1 so if the function
70:54 - is constant the amplitude of the all
70:56 - zero state is plus or minus 1 if the
71:00 - function is balanced then half the
71:02 - inputs will result in zero and the other
71:04 - half will result in one if we look at
71:07 - the sum this means that there will be
71:09 - the same number of ones being added to
71:11 - the same number of negative ones this
71:14 - means the sum will be evaluated to zero
71:18 - so if the function is balanced then the
71:20 - amplitude of the all zero state is
71:23 - zero now we measure the cubits before we
71:27 - saw that if the function is constant
71:29 - then the amplitude of the all zero state
71:32 - is plus or minus 1 that means the
71:34 - probability of measuring the all zero
71:36 - state is one if the function is balanced
71:39 - on the other hand then the probability
71:41 - of measuring all zeros is zero what this
71:44 - means is that if we measure all zeros
71:46 - the function is constant but if we
71:48 - measure anything else the function is
71:51 - balanced and we done we have determined
71:54 - if the function X f is constant or
71:56 - balanced in a single query of the
71:58 - function the key takeaway from this
72:01 - algorithm are these two identities they
72:03 - will keep popping up again and
72:10 - again let's now look at the Bernstein
72:13 - vasani algorithm here is the problem it
72:16 - solves imagine we have a function f that
72:20 - takes in a bit string of length n and
72:22 - returns a single bit which is a DOT
72:24 - product of the input with some secret
72:27 - string S modulo 2 our task is to find
72:31 - out what the secret string s is on a
72:35 - classical computer the approach is to
72:37 - input a bit string of all zeros except
72:40 - for one in one position this allows us
72:43 - to get the value of one position of the
72:45 - bit string S as all the zeros in the
72:48 - input will cancel out in the dot product
72:51 - this means that we must query the
72:53 - function n * when n is the length of s
72:57 - since each query we get one value of
73:00 - s with quantum computers on the other
73:03 - hand we only need to query the function
73:05 - once to find out what s is if we look at
73:09 - the circuit it may look familiar it's
73:12 - the same circuit as a DOA algorithm just
73:15 - with a different function being applied
73:17 - to the cubits initially the cubits are
73:20 - in the state n z minus then at S Sub 1
73:25 - the state is 1/ < tk2 the^ n * the sum
73:29 - over all X where X is a bit string of
73:32 - length n x minus at S Sub 2 we apply the
73:37 - Oracle since the target Q bit is in the
73:40 - minus State we use the phase Oracle
73:42 - property so the state becomes 1 / < tk2
73:45 - to^ n * the sum over all x -1 to the^ of
73:50 - f ofx
73:52 - xus let's rewrite f ofx as a dotproduct
73:55 - of X and S since that is the definition
73:58 - of our function let's also emit the
74:01 - minus qbit since it is not needed
74:03 - anymore now we apply a hadam mod to each
74:06 - of our Q
74:15 - bits let's distribute the -1 to the
74:18 - power of X do s into the sum we can now
74:22 - add the exponents giving us the dot
74:24 - product of s s and X plus the dot
74:26 - product of x and z we can factor out the
74:30 - X giving us s + z dotted with x the plus
74:34 - indicates bit wise exclusive or so for
74:37 - each bit in s we exclusive or it with
74:40 - the bit in Zed that is in the same
74:42 - position so the I position of S Plus Z
74:46 - is S Sub I exclusive or with Z sub I
74:51 - this gives us another bit string of
74:53 - length n now we measure the Q bits let's
74:57 - look at the probability of measuring s
75:00 - expanding out we find the amplitude of
75:02 - the S state is 1 / 2 to^ n * the sum
75:06 - over all X's where X is a bit string of
75:09 - length n -1 to the power of s + S dotted
75:13 - with X since plus indicates bit yse
75:17 - exclusive or S + S equals to all
75:22 - zeros now in the X exponent we have all
75:26 - zeros dotted with X this will equal Z
75:29 - since all the zeros will cancel out all
75:31 - the X's at each position applying the
75:34 - power means the state becomes 1 on 2
75:38 - the^ n * the sum over all X's 1 since
75:42 - there are two to the power of n bit
75:44 - strings of length n there are two to the
75:47 - N possible values of X so evaluating the
75:50 - sum we get 2 the^ of n this leaves the
75:54 - amplitude of the s State as one this
75:57 - means that the probability of measuring
75:59 - s after applying the algorithm is one
76:03 - and that is it after one query of the
76:05 - function we can find S by measuring the
76:08 - cubits you may start to see the
76:10 - similarities between this algorithm and
76:13 - the others applying a hadam mod to each
76:15 - of the cubits so that the state is in a
76:17 - uniform superp position then applying
76:19 - the function and once again applying
76:21 - hadam mods is used in many algorithms
76:29 - in the next two lessons we will look at
76:31 - the quantum forier transform as well as
76:33 - Quantum phase estimation these are both
76:36 - used within many Quantum algorithms
76:38 - including Shaw's algorithm let's start
76:40 - with the quantum fora transform or qft
76:44 - before we look at the maths and circuit
76:46 - behind it let's look at how it
76:48 - transforms states on the Block sphere so
76:50 - we can gain some intuition on the top we
76:53 - have how we would normally represent a
76:55 - number in binary as you can see each of
76:58 - the Q bits is either zero or one and if
77:01 - we take those bits we get the number
77:04 - then underneath we have the same cubits
77:06 - after the quantum 4A transform has been
77:09 - applied as you can see instead of
77:11 - encoding the numbers like we normally do
77:14 - in a classical computer with zeros and
77:16 - ones the numbers are now encoded by the
77:18 - phase of the Q bits that are in a
77:20 - uniform superp position as you can see
77:23 - the left Q bit has two possible phase
77:26 - options either Zer or -1 relative phase
77:30 - then the next qbit has four possible
77:32 - phase options and so on up until the
77:35 - last CIT which has two to the N possible
77:38 - phase positions where n is the number of
77:40 - qits in this case the right CU bit has 2
77:44 - to the 3 or eight possible phase
77:47 - options depending on the number the
77:50 - phase of the CU bits is different let's
77:53 - see how the number five is encoded Ed
77:55 - once the quantum 4A transform has been
77:57 - applied as you can see the right Q bit
78:00 - has been rotated around the Z AIS 5 8 *
78:04 - 2 piun radians which is 5 piun on 4
78:09 - radians to get the amount rotated around
78:12 - the Z AIS of the next q bit we multiply
78:15 - the previous one by two so the next q
78:18 - bit has been rotated 2 * 58 * 2 piun
78:22 - radians so rotating the cub > / 2
78:25 - radians around the Z
78:27 - AIS the last one is 2 * that which is 2
78:31 - * > / 2
78:35 - radians this means that if we have this
78:38 - state which is five in binary and we
78:40 - apply the quantum forier transform we
78:43 - get this state in the next lesson we
78:45 - will see a use of the quantum forier
78:48 - transform but for now let's look at the
78:50 - circuit here is the Quantum forier
78:52 - transform circuit for any number of bits
78:56 - as you can see there are two gates that
78:58 - we have not seen before this gate here
79:01 - is a controlled R gate we will Define
79:03 - this gate with this Matrix as you can
79:06 - see this gate has a variable K which we
79:09 - can set and affects the phase applied
79:12 - this gate transformed the Bas of State 0
79:14 - into 0 and 1 into e 2 Pi / 2 to the K 1
79:21 - giving us a relative phase if applied to
79:23 - a q bit in in superp position the
79:26 - controlled version like we have in this
79:28 - circuit is the same as all the other
79:30 - controlled versions of other Gates only
79:32 - applying the gate if the control is a
79:35 - one this other weird looking gate is
79:38 - called a swap gate and it swaps the
79:40 - states of the two Q bits for this lesson
79:44 - we will go through an example with three
79:46 - bits for this example we'll use the
79:49 - state J as an input to the algorithm we
79:52 - will label each one of J's bits like
79:54 - this where each ji is either Z or 1 to
79:59 - keep our equations tidy we will look at
80:01 - each one of the cubits individually then
80:04 - combine them at the end of the algorithm
80:07 - let's start with finding out what j0
80:10 - becomes after the hadm mod gate the
80:12 - state becomes 1 < tk2 0 + -1 to the^ of
80:18 - J
80:20 - 01 we can represent this like this
80:25 - you will see why we keep the j0 ided 2
80:29 - and don't simplify the fraction at the
80:31 - end then we apply the controlled R2 gate
80:35 - with J1 as the
80:46 - control we apply the R3 gate in the same
80:49 - way
80:55 - now let's find out what J1 becomes after
80:58 - the hadam mod gate the state becomes
81:00 - this state then after the controlled R2
81:03 - gate and simplifying like we did
81:05 - previously we get this
81:08 - state lastly we apply a hatod gate to
81:12 - the J2 Cubit leaving it in this
81:15 - state so after this part of the
81:18 - algorithm our state J is in this state
81:21 - now once we swap the cuits the state
81:24 - changes to this and we're done with the
81:27 - algorithm it may not seem like we did
81:30 - much but we have in fact encoded the
81:32 - value of J into the phase of the cubits
81:36 - just like we saw with the animation
81:38 - previously let's quickly check this by
81:41 - making J the value of five so 101 in
81:45 - binary if we now input the values into
81:48 - the equations for the state then we can
81:50 - see that the phases do match up to what
81:53 - we had previously discovered at the
81:55 - beginning of the lesson if we were to
81:58 - apply the quantum fora transform to an
82:00 - arbitrary basis State J we get 1 / < tk2
82:04 - to^ of n * the sum from K = 0 to 2 n- 1
82:10 - E to the^ 2 pi i j k/ 2 the n k where n
82:16 - is the number of bits in
82:19 - J we also have the inverse Quantum fora
82:22 - transform and that undoes the quantum
82:25 - forier transform so if we add this state
82:28 - which is the state where we encoded five
82:30 - using the quantum forier transform if we
82:33 - now apply the inverse Quantum forer
82:35 - transform we get back to our state
82:43 - 101 the quantum phase estimation
82:46 - algorithm allows us to find the igen
82:48 - value of an igen Vector given the Matrix
82:52 - so if we have a matrix U and apply to
82:54 - its vector v since V is an Vector we get
82:58 - e to the I Theta V where e to the I
83:01 - Theta is the igen value we can represent
83:05 - all igen values in Quantum Computing in
83:07 - this form the qpe or Quantum phase
83:11 - estimation algorithm finds e to the I
83:13 - Theta to a certain accuracy this
83:16 - algorithm is a key part in many Quantum
83:18 - algorithms including shaes algorithm
83:21 - which we will discuss in the next lesson
83:23 - which allows us to find prime factors of
83:25 - large numbers here is the Quantum phase
83:28 - estimation circuit as you can see we
83:31 - have two registers the first one
83:33 - contains M zeros and is used to store
83:36 - the estimated phase and the second one V
83:39 - is n cubits and is the IG Vector of the
83:42 - gate we're trying to measure the IG
83:45 - value of looking at the circuit you can
83:48 - see that the gate U which we're trying
83:51 - to find the I value of is to the power
83:54 - of some numbers U to the power of n is
83:57 - the same as applying U to a qit n * also
84:02 - you can see we have the inverse Quantum
84:03 - fora transform at the end of the
84:06 - algorithm let's start going through the
84:08 - circuit at S Sub 0 we have the state M
84:12 - Z's V then at SI sub 1 we apply the
84:16 - hadam mod gates to all the Q bits in the
84:18 - first
84:21 - register at SI sub 2 we apply the uate
84:25 - to the igen vector v with the rightmost
84:28 - qbit in the first register as a control
84:31 - since V is the IG Vector of you phase
84:33 - Kickback occurs which adds a relative
84:36 - phase of e to the a Theta to the Cubit
84:39 - then at SI sub 3 we apply two U Gates or
84:42 - the U squared gate with the qbit in the
84:45 - first register as a control and v as the
84:48 - target once again phase Kickback occurs
84:51 - applying a phase of e to the I Theta * a
84:54 - to the I Theta or e 2 I Theta we
84:58 - continue this process for each of the
85:00 - cuits in the first register which leaves
85:02 - us with this
85:04 - state now we let Theta equal 2 pi J
85:09 - where J is a number between 0 and 1
85:12 - since Theta is an angle between 0 and 2
85:15 - pi with this if we find J we can find
85:19 - Theta substituting this in we get this
85:22 - equation now since since J is a bit
85:25 - string less than one we can represent it
85:27 - like this which converts it from a
85:29 - decimal in binary to a decimal in base
85:32 - 10 if we now sub that into our equation
85:36 - it becomes this now if we look at the
85:38 - first Cubit we have a factor of 2 to
85:41 - the^ of nus1 if we distribute that into
85:44 - J we get
85:48 - this since all these terms are integers
85:51 - when we expand them out they will be a
85:53 - factor of 2 Pi so they are not needed
85:56 - since they are redundant this leaves us
85:59 - with J m-1 / 2 if we do the same process
86:04 - to the rest of the cubits we are left
86:06 - with this state can you notice anything
86:08 - about this state this is the same state
86:11 - as if we were to apply the quantum for8
86:13 - transform to the state J so when we
86:17 - apply the inverse Quantum forier
86:19 - transform we end up with the state J all
86:23 - we need to do is measure the state and
86:25 - we've approximated J to M bits now with
86:29 - J we can multiply it by 2 pi to get
86:33 - Theta and then we can find the I value
86:36 - as e to the I
86:44 - Theta now we will tackle probably the
86:47 - most important and popular Quantum
86:49 - algorithm shaes algorithm this algorithm
86:52 - allows us to find the prime factors of a
86:55 - large number so if we have a number n
86:57 - equal PQ where PQ are both Prime Shaw's
87:01 - algorithm allows us to find p and
87:05 - Q this may not seem very useful but this
87:08 - is the backbone of RSA which is a widely
87:11 - used type of encryption so using shaes
87:14 - algorithm will allow us to crack RSA
87:16 - encryption but that won't happen for a
87:18 - while to run sh's algorithm we will need
87:21 - a fault tolerant quantum computer with
87:23 - Mill ions of logical Q bits which won't
87:26 - happen for some time this algorithm uses
87:29 - both classical and quantum computers for
87:32 - different steps first we choose an a
87:36 - that is between 1 and n and the gcd of A
87:39 - and N is one so A and N share no common
87:44 - factors next we do the quantum step but
87:48 - before that we will look at some number
87:51 - theory in modular arithmetic we say say
87:54 - that a is congruent to B mod n if the
87:58 - remainder of a / n is B for example 3 is
88:03 - congruent to 1 mod 2 since dividing 3
88:07 - with two gives a remainder of
88:09 - one we can reduce the factoring problem
88:13 - down into the problem of finding the
88:15 - period of modular exponentiation modular
88:18 - exponentiation is when you take the
88:20 - powers of a number modul a number here
88:23 - is an example
88:25 - example as you can see if we have a
88:27 - number in this case two and put it to
88:30 - increasing Powers we get a repeating
88:32 - pattern when we take the modulo the
88:35 - period of this pattern is the length of
88:37 - the sequence and that is what we are
88:39 - looking for in this case the period R is
88:43 - equal to 6 all of the sequences start
88:46 - with a ^ of 0 is congruent to one mod n
88:50 - so we need to keep increasing the power
88:52 - until we get back to one
88:55 - if we are able to find the period we can
88:57 - use some number Theory to find the prime
89:00 - factors if we have a number n which is
89:03 - equal to the product of two prime
89:05 - numbers p and Q if we pick a number a
89:08 - where the gcd of A and N is equal to 1
89:12 - so they share no common factors and we
89:15 - find the period of a to the X Mod n then
89:19 - if we get a good approximation for R the
89:21 - gcd of a to the^ of r / 2 - 1 and n and
89:27 - the gcd of a ^ n / 2 + 1 and N has a
89:32 - good chance of containing the factors of
89:35 - n let's go through the steps in finding
89:38 - the period of modular exponentiation for
89:41 - this we need to use this gate let's call
89:43 - it U which transforms the state x to the
89:47 - state x a mod n if we apply this gate to
89:51 - the one state multiple times we can get
89:54 - powers of a in mod n how we construct
89:58 - this gate is outside the scope of this
90:00 - course see the problem set for resources
90:03 - on how we can construct this gate let's
90:06 - consider this state
90:10 - us if we apply a uate to the state it
90:14 - gives us this
90:19 - state looking at the a to the r mod n we
90:23 - can change the to a to 0 mod n since
90:26 - they are both 1 if we multiply the right
90:29 - hand side by 1 or e to the 2i i s / R *
90:34 - e - 2i i s / R we get this state we can
90:40 - change the E to -2 Pi I Sr / R to e to
90:46 - -2 Pi i 0/ r since they are both equal
90:49 - to one now as you can see this whole
90:53 - state becomes the US state this means
90:57 - that the US state is an igen Vector of
91:00 - the uate with an igen value of e to ^ 2
91:04 - pi i s /
91:06 - R this means that if we can construct
91:09 - the US state we can use the quantum
91:11 - phase estimation algorithm to get the
91:14 - value of s/ R it turns out that it is
91:17 - far easier to construct the equal
91:20 - superposition of all of the US states
91:23 - what what this becomes is 1 mod n in the
91:27 - problem set for this lesson we will
91:29 - prove this result we can construct the
91:32 - one mod n by applying a KN to the
91:35 - rightmost Q bit in a register of all
91:37 - zeros which gives us the value one which
91:40 - is equal to one in mod n so by creating
91:44 - the state 1 mod n we are actually
91:47 - creating the state 1 /un R * the sum
91:50 - from s = 0 to R -1 of us here is the
91:55 - circuit for the algorithm looking at it
91:58 - this is just the quantum phase
92:00 - estimation circuit as you can see we now
92:03 - know that one is an igen Vector of the
92:06 - uate so we are using this to estimate
92:08 - the igen value e to^ 2 pi i s / R where
92:13 - s is an integer from 0 to R -1 this is
92:17 - because our igen Vector 1 mod n is equal
92:21 - to 1 /un R * the sum from S = 0 to R
92:26 - -1 of U so we will get the I value e to
92:31 - ^ of 2 pi i s / R for one value of s so
92:36 - when we measure the qits we will get the
92:39 - I value of one of the US's which means
92:43 - that we will get S / R for 1 s from 0 to
92:47 - Rus one if we happen to get zero as our
92:50 - igen value so s = 0 then then we repeat
92:54 - the circuit so we can get an igen value
92:57 - that is non
92:58 - zero now we have a decimal number J
93:01 - which is equal to S / r that is the
93:04 - Quantum part of the algorithm done now
93:07 - we estimate the values of S and R by
93:10 - using a technique called continued
93:12 - fractions here is an example with the
93:15 - decimal
93:17 - 0.312 we start by writing it as a
93:19 - fraction then we flip the fraction
93:25 - we continue this process until we have
93:27 - the number one in the numerator by
93:30 - representing a decimal in this way we
93:33 - can approximate its value with a
93:35 - fraction by rounding off the continued
93:37 - fraction here are the first three
93:40 - approximations for the decimal
93:43 - 0.312 to approximate s / R we find an
93:46 - approximation where the denominator is
93:49 - less than n since the period R must be
93:52 - less than n if R is odd then we repeat
93:56 - the algorithm and get a new value of R
93:59 - now that we have a value for R we can
94:01 - use this to find the factors of n we
94:04 - know that a to the r is congruent to 1
94:07 - mod n so a to the r -1 is congruent to Z
94:12 - mod n this means that a ^ of R -1 has a
94:17 - factor of n since when we divide it by n
94:21 - we get zero remainder if we Factor a^ R
94:26 - -1 with the difference of 2 squares then
94:29 - we get this from this we can see that if
94:32 - we calculate the gcd of a^ R / 2 -1 n
94:38 - and the gcd of a^ R / 2 + 1 and N with
94:43 - our approximation of R we have a good
94:45 - chance of them being one of the factors
94:48 - this allows us to find p and
94:51 - Q let's go through a quick example with
94:54 - n = to 15 so p is 3 and Q is 5 in step
95:00 - one we choose an a which is relatively
95:02 - prime to 15 let's choose AAL
95:06 - 7 now in step two we use the quantum
95:09 - part of Shaw's algorithm to find the
95:12 - period or R so we need to find R such
95:15 - that 7 to the power of R is congruent to
95:18 - 1 mod 15 by using the algorithm we find
95:22 - that R is equal to 4
95:24 - now we calculate the gcd of 7^ 4 /2 - 1
95:30 - and 15 and the gcd of 7^ 4/ 2 + 1 and 15
95:36 - the first one becomes the gcd of 48 and
95:40 - 15 and the second becomes the gcd of 50
95:44 - and 15 the gcd of 48 and 15 is three and
95:49 - the gcd of 50 and 15 is five
95:54 - as you can see we have found the factors
95:56 - of 15 3 and 5 using shaes algorithm

Cleaned transcript:

Quantum Computing leverages the principles of quantum mechanics to process information at incredible speeds this course provides a solid foundation in Quantum Computing from the ground up taking you from the basics to a thorough understanding of how popular Quantum algorithms work the first section covers all the essential mathematics and the second section is a deeper exploration into the mechanics of quantum computers you'll learn why quantum computers are so powerful and how they're poised to transform technology Michael from Quantum sore created this course if you were to search up on Google M quantum computers you would get answers in the form of analogies like quantum computers use Q bits that are both zero and one at the same time when I first started learning about quantum computers these analogies and explanations never made sense this course was created in order to provide a solid foundation on Quantum computation without using analogies but teaching how quantum computers actually work let's quickly look at the structure of this course the first section of this course goes through the basic mathematics needed to understand the rest of the course including an introduction to complex numbers and basic linear algebra in the next section we'll explore what a cupid is and how we can represent them mathematically we also explore some single qbit operations and discuss some of their properties the third section introduces how we can represent multiple cuq bits mathematically and explor some operations we can perform on multiple cuq bits this section ends on exploring the strange Quantum phenomena of quantum entanglement and phase Kickback in the final section of this course we use everything we have studied up until this point to analyze Quantum algorithms this section showcases why quantum computers as such revolutionary technology let's start with understanding imaginary and complex numbers but before that we need to consider the square roots of numbers let's say we have the equation x^2 is equal to 4 which means X is equal to Plus or 2 easy but what if x^2 is equal to 4 since a number squared is always greater than zero how can X2 ever be a negative number this is where imaginary numbers come in if we let I be the < TK of1 we can then write the < TK of4 as plus orus 2 I this is an imaginary number any number that contains a factor of theare < TK of1 or I now we move one level up to complex numbers all a complex number is is a number that contains a real number plus an imaginary number a standard complex number looks like this a plus I B where both A and B are real numbers a being the real part of the number and B being the imaginary part of the number complex numbers may not seem very useful but in the next lesson we will see how we can represent complex numbers in another form which is used to model Quantum Computing States we can add and subtract complex numbers pretty easily all we do is add or subtract the real parts and the imaginary Parts pause the video and try adding up these complex numbers multiplication is pretty simple as well but we must remember the before we get i s that becomes 1 since I is the square root of1 the complex conjugate of a complex number is when you take the complex number and flip the sign or negate the imaginary part this is denoted by an asteris here are some examples one cool property of complex numbers is if we multiply any complex number by its complex conjugate the result is always a real number try multiplying 2 + 3 I with 2 3 I and confirming this is the case we can think of a complex number as a vector where we have the real axis on the horizontal and the imaginary axis on the vertical this allows us to graph our complex numbers for example the complex number 2 + 3 I would be a vector that would end at the point 2 3 when we represent a complex number on the number plane like this we also uncover another property its magnitude which is its distance from the origin this is denoted with vertical lines and is calculated by using Pythagoras's Theorem so we get that the magnitude of some arbitrary complex number A plus I is equal to the square root of a^ 2 + b^ 2 pause the video and see if you can find the magnitude of 4 3 I this is not the only way of representing complex numbers instead of using real and imaginary Parts as coordinates we can represent them through their magnitude and the angle they make with the Positive xais using trigonometry we find that we can also represent complex numbers in the form r cos theta plus I sin Theta where I is the magnitude of the complex number and Theta is the angle it makes with the Positive X AIS we can find Theta by using the tan function as tan of theta is equal to b a so Theta is arctan of B of A this is called Polar form there is also one other form which is r e to the power of I Theta this form is exponential form pause the video now and try to convert the complex number 1 + I into Polar form then into exponential form in Quantum Computing we almost exclusively use complex numbers in exponential form this is because of the property that when we change Theta we rotate around a circle so multiplying two complex numbers in exponential form whose magnitude is one graphically we are rotating around a unit circle as the angles of the two complex numbers add together you will see once we start studying Quantum Computing that this property is very useful in representing Quantum States a matrix is a 2d arrangement of numbers in the next lesson we will get to the applications of matrices and how they relate to Quantum Computing but in this this lesson we will quickly Define some properties and operations we can do on them we say we have an M byn Matrix if the number of rows is M and the number of columns is n so this Matrix here would be a 2x3 Matrix pause the video and see if you can find out the dimensions of these matrices if we want to add two matrices together all we need to do is add each element of the matrices this is the same for subtraction note that we can only add and subtract matrices if the number of rows and columns is the same for both so we wouldn't be able to add these two matrices pause the video and see if you can add these matrices we can also multiply matrices by a scalar if we do each element in the Matrix gets multiplied by the scaler giving us another Matrix when multiplying matrices we have to do this weird operation where to get the element in the First Column and first row we take a sort of dot product with the first row of the left Matrix and the First Column of the right Matrix then to get the second column first row we take the dotproduct of the first row of the left Matrix and the second column of the right Matrix we continue this process until we have all the elements in the new Matrix pause the video and try to complete this matrix multiplication it's important to note that we can only multiply two matrices together if the number of columns of the first Matrix is the same as the number of rows in the second Matrix for example we can't multiply these two mates here since the first one has two columns but the second one has three rows if we have a n by one Matrix we call it a column Vector we can graph these like any other Vector these are useful as one of the ways we can represent a state of a Quantum computation is through a column Vector it turns out that when we multiply a matrix with a column Vector we get another column vector intuitively what is happening is the column Vector is getting transformed by The Matrix so we can use matrices as Transformations on a vector here are some examples graphically as you will see in the quantum Computing sections we do the same process of applying matrices to our Quantum state to apply operations on qu computers we also have a special Matrix called an identity Matrix this Matrix is all zeros except for the main diagonal that has all ones if we multiply the identity matrix by any Matrix we get back the original Matrix verify this is true by multiplying the twodimensional identity Matrix with this Matrix and check to make sure you get back the original Matrix matrices also have what's called an inverse that when multiplied with the original Matrix gives us the identity Matrix we denote this with a ne1 graphically this means that if we have a matrix a and we apply it to a column Vector 1 one if we then apply the inverse of a we lend back on the point 1 one therefore applying a than a inverse is the same as applying the identity Matrix which means the column Vector stays in the same spot as we saw previously with complex numbers we can also take the complex conjugate of a matrix this is denoted by the asteris on the top right of the Matrix just like with complex numbers when we apply this we flip the sign of all the imaginary components of all the elements in The Matrix pause the video and find the complex conjugate of this Matrix we can also do what we call the transpose of a matrix this is denoted by the T and involves exchanging its rows with its columns if we combine these two and find the complex conjugate and transpose of a matrix a we get something called a dagger denoted by the dagger symbol what was the point of all this in Quantum Computing we use two types of matrices to apply our operations one of them is unitary matrices these have the property that given a unitary Matrix u u * U dagger is equal to the identity Matrix so U dagger is its inverse geometrically when a unitary Matrix acts on a vector the length of the vector stays the same but it is rotated or flipped this property may not seem very useful but once we start talking about probabilities in quantum computers it will all start to make sense the other type of Matrix we use to apply operations in Quantum Computing is the Homan Matrix these matricies have the property that given a Homan Matrix H H is equal to H dagger as you go through the quantum Computing sections of this course you will start to understand why we use these types of matricies to perform operations on quantum computers sometimes when we apply a transformation to a vector the vector stays in the same direction but just gets stretched or compressed meaning that we can factor out a scalar and get back that same Vector when this happens we call the vector an igen Vector of the transformation matrix that we applied and the Scala we factored out an igen value let's go through an example if we have the Matrix 20112 with the vector 03 applying the Matrix on the vector gives us the vector 06 with this we can Factor at a two leaving us with two times the vector 03 this gives us an igen value of two with the igen vector 03 for that Matrix classical computers use binary zeros and ones to store and process their data quantum computers on the other hand use Q bits or Quantum bits which can be zero and one at the same time we have all heard this explanation of quantum computers but what does that actually mean in order to understand what a quantum computer is actually doing we must look at how we represent them mathematically instead of using binary like classical computers quantum computers use cubits physically a cubit can be any Quantum particle that exists in two distinct states such as a photon of light being polarized either horizontally or vertically just like classical computers we still use zeros and ones but in Quantum computation we Define them instead as the column vectors 1 0 and 01 respectively the weird brackets around 0 and one is direct notation we will look more into it later you may have heard of the term superposition what it means in quantum mechanics is that a Quantum particle is in two states at the same time so back to our Photon polarization example this means that the photon is both horizontally and vertically polarized at the same time in terms of quantum Computing we say a cuit is in superp position if it is both zero and one at the same time let's look at how we represent cubits mathematically mathematically we can represent a qit as a column Vector with two elements the top element indicates how much the qbit is in the zero State and the bottom element indicates how much the cuit is in the one state the convention for a Quantum state is to set it equal to the Greek letter s we'll talk more about this in the next video so if we have a cubit in the state 1 Z it now makes sense why this is zero since it is all in the zero State and none in the one we can say the same for Q bit in the state 01 being one if a qbit is in both the zero and one state so it has nonzero numbers in The Matrix then we say it is in a superposition of 0 and one since it is both of the states at the same time so now we know how to represent a cubit mathematically but how do we measure the cubits for that we must look at another rule of quantum mechanics when we measure a Quantum system it changes the state of the system to the measurement what does that mean if we go back to our Photon polarization example if the photon is in a superposition of both horizontally and vertically polarized then when we measure it we will only measure it as one or the other but not both and once it has been measured it collapses into the state we measured so if it was in a super position and we measure it to be horizontally polarized it would collapse and become horizontally polarized meaning it is not in a super position anymore the same thing happens when we measure Q bits we can only measure a zero or one we do not measure how much the QQ bit is in the zero state or how much the cuq bit is in the one state immediately after measuring a cuq bit its state changes to either zero or one depending on the measurement so what is the point in those numbers telling us how much the cuq bit is in the zero State or the one state what those numbers tell us is the probability of measuring a 0 or 1 the probability of measuring zero is the magnitude squar of the amplitude of the zero State and the probability of measuring one is the magnitude squ of the amplitude of the one state so for this example Cubit when we measure it we have a 75% chance of measuring a zero and a 25% chance of measuring a one if we now think about how we defined the Z and one state at the start of the lesson they should now start to make sense we stated that Zer was the column Vector 1 0 and now we can see why the probability of measuring Z is 1 so will always be measured as zero this is the same for the one state since there are only two possible outcomes when measuring a q bit the probability of measuring a zero plus the probability of measuring a one must equal one giving us this equation so this would be a valid Cubit State since the probabilities add up to one but this would not be since the probabilities add up to more than one when we do measure a qbit that is in superp position it collapses into the measured state so if we measure this state to be zero it collapses into the zero state so every measurement after will be zero this is because of the laws of quantum mechanics when we measure something it permanently changes the state of the system to that measurement normally when we are mathematically representing a Quantum state of a quantum computer instead of using matrices we use a specific notation called direct notation to see how this works let's convert an arbitrary Cubit State Alpha Beta into direct notation all we need to to do is turn the Matrix into the sum of two matrices and then factor out the Alpha and the beta now if you look at the column vectors they are the zero and one States as we saw in the previous lesson this gives us a linear combination of the zero and one States those brackets around the 01 and S are called KS all they tell us is that 0 1 and S are quantum States pause the video and convert this Cubit state from Matrix to direct notation this notation might seem weird at first but it is the conventional way of writing a Quantum Computing State since when we start adding more Q bits using matrices to represent them becomes unmanageable as we start to get very large matrices we can represent a cuit graphically on what is called a block sphere on the top we have the zero State and on the bottom we have the one state on the horizontal we have the plus State minus State I State and negative I State we will discuss these in later lessons the closer up the cuit is to the zero State the higher probability of measuring a zero and the same goes for the one state that means that if we have the state 1 on < tk2 1 on < tk2 it will lie halfway between the North and South Poles since it has an even chance of being measured as Zer or one you may notice that since it is a sphere the cubic can spin around the sphere this is called phase we will talk about this in later lessons right now it is important to understand the basic idea that the higher up the qbit is the more likely we are to measure a zero and the lower the qbit the more likely we are to measure a one pause the video and think about where the state 1 on 2 < tk3 on2 will be on the Block sphere the cuit 1 on2 < tk3 on2 would be halfway between the Equator and the one state since it has a one on4 chance of being measured as a zero and a 3 on four chance of being measured as a one with classical computers we use logic gates to process data with quantum computers we still use gates to change the states of our cubits but they are a little bit different to your usual logic gates the most common single Cubit gates are the X Y and Zed Gates let's first look at the X gate if we have a Q bit in the zero State and apply the X gate to it it flips to the one state let's try a q bit that is halfway between 0 and one try and see if you can figure out what the xgate is doing let's try a q bit in this state as you can see the xgate flips the Cubit 180° or Pi radians around around the xaxis now let's have a look at the Y gate here are some examples of the Y gate transformation as you can see it does the same thing as the xgate but instead it rotates the Cubit State 180° or Pi radians around the Y AIS lastly we have the Z gate which rotates the cubeit 180° or Pi radians around the Z axis since these Gates rotate the cuit around the specified axis by pi radians if we apply the same gate twice one after the other then the Cubit returns to its original position this means that these three gates are their own inverses we can represent these Gates as matrices here are the matrices for these gates for the moment ignore the complex numbers in the Y gate mat mat we will explain this later in the next lesson when we talk about phase mathematically to apply a gate to a cubit we can multiply The Matrix that represents the gate with the column Vector of the Cubit pause the video and prove that applying the X gate to the zero State gives us the one state in direct notation if we we want to apply a Quantum gate we still use the matrices but instead of using matrix multiplication we look at The Columns of the Matrix the First Column of the Matrix indicates the column Vector the zero state becomes after applying the gate and the second column indicates the column Vector the one state becomes then we can factor out both our zero and one States again to get back into direct notation also since Quantum gates are linear if we apply an arbitrary gate U that gate acts on each of the superposition States individually let's look at an example of applying a gate in direct notation if we want to apply a y gate to this state in direct notation the Y gets distributed into the state then the Y changes the zero state to the First Column of the Matrix and the one state to the second column of the Matrix then we can factor out the I and the negative I the column vectors once again become the zero and one States leaving us with this state with this pause the video and prove that applying a zed gate to a cuit in the state Alpha 0 plus beta 1 gives us the state Alpha 0 minus beta 1 looking at this you may be thinking what is the point of the Zed gate this Q bit still has an alpha squar chance of being zero and a beta Square chance of being one it didn't affect their probabilities in the next lesson we will finally bring complex numbers into Quantum Computing with an introduction to phase on the Block sphere we saw in the previous lessons that we could also rotate around the Zed AIS this is called phase it may not seem very useful as the probability of measuring a zero or a one is still the same no matter how much we rotate around but phase is what makes quantum computers as powerful as they are we will get into the uses of phase in the next lesson in this lesson we will see how we can represent phase mathematically to represent phase we have to bring back our old friend complex numbers in Quantum Computing we mostly use complex numbers in exponential form you will now see why but first let's consider some states in the block sphere let's first consider the states 1 or < tk2 0 plus 1 or < tk2 1 if we apply a zgate we get it to the state 1 or < tk2 0 0 1 < tk2 1 as you can see the one state was multiplied by a factor of 1 and the Cubit rotated Pi radians around the Z AIS if we represent the 1 as a complex number in exponential form we get e to the I Pi notice how the angle of the complex number is pi radians let's try another example let's plot the state 1 on < tk2 0 + 1 < tk2 1 and 1 on < tk2 0 + I on < tk2 1 if we represent I as a complex number in exponential form we get e to the I Pi / 2 and if you look at the Block sphere to get that state we rotate Pi / 2 radians around the Z AIS we use complex numbers in exponential form in Quantum Computing since it gives us a nice mathematical way of rotating around a circle by changing the value of f by multiplying the one state of the Cubit with the complex number e to the I we rotate the Cubit around the Z AIS by five radians but why is it the one state and not the zero State being multiplied by the complex number there are two types of phase Global phase and relative phase Global phase is when the entire cuit is multiplied by a complex number and relative phase is when just the one state is multip IED by a complex number it turns out the global phase is physically irrelevant so the state e to the I * 1 < tk20 + 1 < tk2 1 is logically equivalent to the state 1 < tk2 0 + 1 < tk2 1 relative phase on the other hand is extremely important and matters in our calculations relative phase is when the amplitude of the one state has a factor of a complex number as we saw earlier having relative phase rotates the Cubit on the Block sphere around the Z AIS but what if we have a complex number in both the amplitudes of the zero State and the one state what we do is we factor out the complex number of the zero state from the entire qbit creating a global phase and relative phase then we can discard the global phase leaving us with a qbit with a relative phase we saw previously on the Block sphere that phase does not affect the probability of measuring a zero or a one as the cupit stays the same distance from the zero State and the one state no matter how far we rotate around the block sphere if we look at an arbitrary Cubit State Alpha 0 plus e to the I5 beta 1 the probability of measuring a one is the magnitude of e the5 beta squar we can split the absolute values up like this the magnitude of e to the II is 1 since the coefficient of the complex number in exponential form states its magnitude so the probability of measuring one is still the magnitude of beta squ in the next lesson we will see why relative phase matters before we discuss perhaps the most important gate in Quantum Computing we will quickly revisit the block sphere in earlier lessons we saw that on the equator we have four states the plus State minus State I State and negative I State now that we know about phase we can Define these states all they are a shorthand for commonly used States since they all lie on the equator of the block sphere they all have an even chance of being measured as zero or one but each one contains a different relative phase the plus state is the state 1 < tk2 0 + 1 < tk2 1 the next state is the minus State this is the same as the plus state but with a relative phase of 1 the I state has a relative phase of I and the negative I state has a relative phase of negative I now let's look at the hadam mod gate here is the Matrix for the gate if we look at how the gate acts on a qit on the Block sphere we see that the zero state gets trans transformed into the plus State and the one state gets transformed into the minus State applying a hadam mod to the plus State gives us the zero State and applying a hadam mod to the minus State gives us a one state this means that the hadam mod is its own inverse if we wanted to apply a hadam mod gate to an arbitrary Cubit state in direct notation we can replace the zero with the plus State and the one with the minor State and expand the hadamar gate shows that phase matters if we apply the gate to the plus State we get zero and to the minus State we get one these states only differ by a relative phase but after applying the gate they are different even though initially they both had a 0.5 chance of being measured as zero and a 0.5 chance of being measured as one in the fourth section of this course we will start to look at some Quantum Computing algorithms and you will start to see why the hadide gate and phase is so powerful now that we understand relative phase let's introduce two new gates the s and t Gates the S gate adds a relative phase of Pi on 2 radians the T eate adds a relative phase of Pi on 4 radians if we take the conjugate transpose of the two matrices of the two gates we get their inverses for the S gate we can see that applying s dagger adds a relative phase of negative pi on 2 which is the inverse of the S gate this means that if we apply a s gate then an S dagger gate we are back in the same spot meaning the S dagger gate is the inverse of the S gate we also have the T dagger gate which is the same thing as the S dagger but adds a relative phase of piun on 4 radians instead meaning it is the inverse of the T gate if we have multiple cuq bits we represent them through the tensor product for example if we had two cuq bits in the zero state then we would represent the state like this this is usually shortened to this where we have the two zeros in the one get Vector if we wanted to represent two cubits in superp position we can expand it out like any other operation by multiplying the amplitudes of the states and using the tensor product on the zero and one States as you can see now we have four states the 0 0 01 1 0 and one one States this makes sense since those are the possible combinations of zeros and ones we can have with two cubits measurement works the exact same as before the probability of measuring 0 0 is the magnitude squared of the coefficient of the 0 State and so on here is an example of combining these two cubits if we want to add another q bit to the system all we need to do is tensor it onto the end of the state we also have some Shand notation you will sometimes see if we have n Zer we can write it like this which means 0 tensed with itself n times so this state would be shorthand for 5 ones this represents ation of cuits is great but what if we wanted to apply a gate to a certain cuit how would we indicate that we wanted to let's say apply an xgate to the second cubit in this state for this we use a diagram called the quantum circuit here is an example of one on the vertical we have the cubits each line representing a singular Cubit the states on the left are the initial states of the cuits the bo boxes are the quantum Gates and the letters on the boxes are the type of gate we are applying for example this is an X gate these boxes are measurements and represent us measuring the Cubit the horizontal is the order in which we apply the gates we start from the left and go to the right sometimes you will also see size States pointing to different points in the circuit these are used to represent the state of the system at different points during the algorithm let's go through this circuit at S Sub 0 we have the state 0 01 then at SI sub one we apply an X gate to the second Cubit at SI sub 2 we apply a hadam mod gate to the second Q bit giving us this state then at S Sub 3 we apply an xgate to both the first Cubit and the third Cubit giving us this state then at size sub 4 we measure the cubits so we will get one of these states with these probabilities now let's introduce some gates that act on multiple cuy bits the most common multibit gate is the c not or controlled X gate here is the gate on a Quantum circuit the gate acts on two Q bits one of the Q bits is called the control Q bit and the other is called the target QQ bit the C not gate applies an X gate to the Target QQ bit if the control QQ bit is a one and does nothing if the control is a zero let's look at the C not gate acting on some states if we apply a c not to this state with the first Q bit as the control and the second Q bit as the target then we apply that c not gate to each of the superposition States giving us this state here is another example we also have the tooli gate this gate is very similar to the C not but instead it has two control cubits here it is on a Quantum circuit if we apply a tooli gate to this Cubit state with the second and third cuq bits as control and the fourth Cubit as the target we get this state it turns out that we can use senal gates to create controlled versions of single qbit Gates so we also have controlled y z s t and hadamard Gates they act the same as the C not flying the gate if the control is one and does nothing if the control is zero we represent these on a Quantum circuit like this with the regular gate box but with a line going out to the control CU bit for example here is the controlled es gate on a Quantum circuit where the second qbit is the control and the first is the target now that we have multiple cuq bits how do we measure a single cuq bit let's say we have two cuq bits in this state and we wanted to find the probability of measuring the second Cubit as a one we do this by looking at all the superposition states where the second CU bit is one then summing up the probabilities of measuring those States Let's do an example if we wanted to find the probability of measuring a zero in the first CU bit then we sum the probabilities of measuring each of the states where the first Q bit is a zero but how do we know what the state collapses to once we measure a qbit remember once we measure a qbit it collapses its superp position and becomes the measurement let's look at an example say we have this state and we measured me the first cuit to be a one then the state collapses and since the first cuit becomes a one we get rid of all the superposition states where the first Cubit is not a one remember the probabilities must add up to one but we have just removed some states so the probabilities will be less than one we fix this by multiplying the state by what we call a normalization constant let's call it a now we can normalize the state by using the identity that the probabilities must add up to one this gives us values for a so if we measure the first CU bit to be one the state collapses to this state we can use these techniques with any number of cubits let's go through an example with three cubits let's say we have this state and we measure the middle Cubit to be zero the state collapses like this collapsing into this state let's consider this Quantum circuit at SI Sub 0 we have the state 0 0 then at S Sub 1 we have the state 1 on < TK to 0 plus 1 0 Let's distribute the zero State into the equation giving us the state 1 < tk2 0 0 + 1 0 now at size sub 2 we apply a cot with the first qbit being the control and the second being the target this means that the 0 0 state stays the same since the control is zero but for the one zero State the control is one so the second Q bit flips to a one this leaves us with the state 1 on < tk2 0 0 + 1 1 can you notice anything weird about this state if we were to measure one of the cubits as a zero the other would collapse into a zero and if we were to measure a one the other would collapse to a one so without even looking at both the cubits by measuring one of them we immediately know the state of the other Cubit this is called entanglement there are many different entangled States we say a state is entangled if it cannot be factored into the tensor of single Cubit States for example this state is not entangled since we can Factor it like this but this state is entangled since we cannot Factor it into singular Cubit States what this means is that when the cuits are entangled they depend on each other to determine their state there are two types of entangled States maximally entangled States and partially entangled States we say CU bits are maximally entangled if measuring one of the CU bits tells us the state that the other Q bits are in so the example entangled state from the beginning 1 on < tk2 0 0 + 1 1 is maximally entangled here are the common maximally entangled States with two cubits we call these states the Bell States and we denote them with capital fi and S we say cubits are partially entangled if the measurement of a cubit affects the probabilities or phase of the other cubits for example with this state if we measure the first cuq bit as zero the state collapses to this but if we measure the first Q bit as a one then it collapses to this state as you can see the two states have different probabilities of measuring Zer or one so this state is partially entangled since measuring one cubit affects the probabilities of the other another quantum property we can use is something called phase Kickback to understand and how this works let's consider this circuit as you can see we have a Q bit in the plus State and another q bit in the state V we also have an arbitrary controlled U operation let's say that V is an igen state of u so if we apply the U gate to the state V we get e to the I Theta V since all I values of quantum computers can be represented as e to the I Theta now at sub one we have the state plus V Let's expand the plus State and distribute the V State into the plus State at S Sub 2 we apply the controlled uate nothing happens to the first superposition State since the control is a zero but the second superposition state has the gate applied to the V State since the control is a one we can now Factor back out the V state from the equation can you see what has happened V is unchanged even though it was the Target qit and a factor of e the I Theta has been applied as a relative phase to the control Cubit this occurs if V is an igen state of the gate you are applying we call this phenomenon phase Kickback and it is used in some Quantum algorithms let's have a look at superdense coding this Quantum protocol allows us to send two bits of classical information with only one cubit to do this we need entanglement we'll say that the person sending the Cubit is Alice and the person receiving this Cubit is Bob to start off with Alice and Bob maximally entangle two cubits so they are in this state Alice takes one and Bob takes the other we will say that Alice takes the left QQ bit and Bob takes the right cuq bit then Alice and Bob take those cubits with them now when Alice wants to send two bits of classical information to Bob depending on which two bits of information Alice wants to send she performs some operations on her Q bit if Alice wants to send the two classical bits 0 0 she does nothing and sends her Q bit to Bob if Alice wants to send 01 she an X gate to her qbit transforming the CU bits to this state then she sends her Cubit to Bob if Alice wants to send one Z she applies a zgate to her Q bit transforming the Q bits to this state then she sends it to Bob lastly if she wants to send one one she applies both an x and z gate to her cuit giving us this state she then sends her qbit to Bob now Bob has both the cubits in one of these four states he now applies a c not with the first Cubit as a control and the second as the target giving us these states then he applies a hadam mod gate to the left key bit this gives us this state that Alice wanted to send all Bob now has to do is measure the Q bits and he will get the two bits Alice intended to send as you can see with quantum computers we can send two bits of classical information by sending one Q bit this works since there are two entangled Q bits in the entire system before we look at how we can apply functions on quantum computers we will quickly look at how classical computers perform operations on bits and how we make classical operations reversible there are four main operations we can perform on classical bits the and or not and exclusive or operations let's go through each one of them quickly the simplest is the not gate which flips 0 to 1 and 1 to zero here is the truth table for the gate where X is the input and F ofx is the output as you can see this gate acts on one bit now let's look at the end gate here is the truth table for the gate the operation acts on two bits and returns one if the two bits are one and zero otherwise the orgate acts on two bits as well if either of the bits is a one or both or one then it returns one otherwise it returns zero lastly we have the exclusive or gate here is the truth table for the operation as you can see it returns one if either of the inputs is one and returns zero if both the bits are zero or one we use the exclusive or operation to reversible classical Gates we say a function f is reversible if given F ofx we can determine the value of x so if we are given the output we can determine the input so this function here where we negate the second bit is reversible since each row of the truth table for this function is unique so we can map each output to a unique input but the or operation on the other hand is not reversible since if we get an output of one we cannot say what the input was it could have been any of these three inputs to make any classical gate reversible we must input another bit let's call it C and instead of only returning F ofx we return the input X as well as C exclusive or with F ofx this makes the operation reversible let's look at converting the orgate to a reversible operation here is a normal orgate and here is a reversible orgate as you can see we input another bit C and return it exclusive or with the output now looking at the truth table each row of the outputs is unique so the gate is reversible since we can determine the input from the output what is the point in all this well with quantum computers all operations besides measuring the qits must be reversible this is because every operation must be unitary if you remember from the first section of this course unitary matrices rotate and flip a vector so they must be reversible in the next lesson we will discuss how we can apply functions on quantum computers using the same techniques that we used to make reversible classical Gates we discussed in the previous lesson how we can make classical Gates reversible now let's use this same technique to make Quantum functions since the operations we perform on quantum computers must be reversible if we wanted to apply a function on a quantum computer the function must be reversible to do this we use the same techniques for making classical Gates reversible a standard Quantum function looks like this where we input X and Y and get back X and Y exclusive or with f ofx now you might be thinking how are we going to get the output if it is exclusive or with Y but if we set y to zero then we get zero exclusive or with f ofx zero exclusive or with any bit gives us back that bit this means that zero exclusive or with f ofx is just F ofx this allows us to query the function and get its output on a quantum computer we can encode functions within a unitary Matrix and so it is a valid Quantum gate we usually denote a function f as U subf so overall if we apply a function f to the state x0 we get the state x f ofx then to get the function output we can measure the second register of cuits let's see what happens if we apply a function f to this state with the output register being the minor State first let's rewrite the minor State like this and distribute the X State into the superposition since the function is a unitary operation it gets distributed into the superposition like any other gate then it acts on each of the superposition States individually applying U subf we get this state the zero exclusive W with f ofx becomes F ofx and the One exclusive W with f ofx becomes not F ofx now let's consider two scenarios if f ofx is equal to 0 then the state becomes 1 < tk2 x0 X1 which we can rewrite as x minus on the other hand if f ofx is equal to 1 then the state becomes 1 on < tk2 X1 x0 we can factor out the 1 leaving us with the state1 on2 x0 X1 this can be further factored intox minus now looking at these two states we can see that the only difference is the phase at the front we can combine these two equations into 1 to^ FX xus so if we apply a function to the state xus we get back 1 to the^ of f ofx xus when we query a function in this way where the output bit is in the minor State we call it a phase Oracle in the next lesson we will finally see how quantum computers can outperform classical computers with Deutsch's algorithm which uses this technique of the phase Oracle one more thing we will discuss when it comes to quantum computers is a theorem called the no cloning theorem when we want to copy bits on a classical computer all we need to do is read the values of the bits and write the values to other bits but with quantum computers if if we have a CU bit in an unknown State say we have S is equal to Alpha 0 + beta 1 we cannot copy this state if we don't know Alpha and beta if we were to measure s we would get Z or 1 but to copy the state we need to know the amplitudes so we would need to know Alpha and beta we could easily copy qbit states where we know the amplitudes by applying the needed Gates but if we do not know the state we cannot copy a cuit now let's finally look at a Quantum algorithm deutch's algorithm but first let's look at the problem it solves and how we would solve that problem with a classical computer say we have a function f that takes in a bit and returns a bit we don't know what the function does all we can do is send in a bit and read the output bit it is like a black box our t ask is to find out whether the function f is constant or balanced if a function is constant then it Returns the same bit no matter the input here are the two constant functions that can act on one bit constant one which always returns one and constant zero which always returns zero balanced functions on the other hand return zero for half the inputs and one for the other half of the inputs here are the are the two balanced functions that can act on one bit identity which Returns the input and the not gate which we saw before which flips the bit as you can see both these operations return zero for one input and one for the other input for this problem we don't care if the function is a not gate or a constant zero we only care if it is constant or balanced if we wanted to find out if f is constant or balanced on a classical computer we would first need to input zero and then input one to see if we get the same or different values if f of0 equals F of 1 then we know that the function is constant and if F of 0 does not equal F of one then the function is balanced so we need to query the function twice once with zero as the input and once with one as the input with quantum computers and Deutsch's algorithm however we only need one query of the function to find out if the function is constant or balanced here is the circuit for the algorithm the U of represents the function f at S Sub 0 the Q bits are in the state 0 0 then at SI sub 1 the cubits are in the state 01 at SI sub 2 we apply a hadam mod to each of the cubits leaving us with the state plus minus let's expand the plus State and distribute the minus state into the equation now at SI sub 3 we apply the unitary Matrix UF acting as the function to the state since all Quantum operations are linear UF gets distributed into the state and acts on each of the superposition States individually if we look at each of the superposition States they are in the phase Oracle form so applying U of f to the first state becomes 1 to the^ of f of 0 0 minus and the second state becomes 1 to ^ f of1 1 minus the minus qbit is not needed for the rest of the algorithm so we will emit it to clean up the equation now let's consider two different scenarios if F of 0 equals F of 1 then the state becomes 1 / < tk2 0 + 1 if F of 0 and F of 1 equal 0 or 1 / < tk2 0 1 if F of 0 and F of 1 = 1 with this we can factor out a global phase of 1 leaving us with 1 < tk2 0 + 1 therefore if F of 0 equal F of 1 the state becomes 1 / < tk2 0 + 1 or the plus State now let's look at if F of 0 does not equal F of 1 so if F0 = 0 and fub1 = 1 the state becomes 1 / < tk2 0 1 if F of 0 = 1 and F of 1 = 0 then the state becomes 1 / < tk2 0 + 1 with this we can factor out a global phase of 1 leaving us with the minus state so overall if F of 0 equals F of one the state becomes the plus State and if F of0 does not equal F of 1 the state becomes the minor State see if you can finish the rest of the algorithm off yourself now at SI sub 4 we apply a hadam mod to the Q bit in the case where F of 0 equals F of 1 this transforms the state into zero and in the case where F of 0 does not equal F of one the state becomes one now all that's left to do is measure the Cubit looking at our equations if we measure a zero then the function is constant since f of0 equals F of 1 and if we measure one then the function is balanced since F of 0 does not equal F of one as you can see what took a classical computer two queries of the function was done with one query of the function on a quantum computer in the next lesson we will look at the DEA algorithm which considers itself with the same problem of deutch's algorithm of finding out if a function is constant or balanced but in instead of having a function that only inputs one bit the algorithm is a general case that accepts any number of bits as input the deuts josa algorithm considers itself with the same problem of deutsche's algorithm of finding out if a function is constant or balanced but instead this algorithm is a general case that can accept any number of bits as input let's quickly revise constant and balanced functions constant functions always return the same value no matter the input here are the two constant functions constant Z and constant one balanced functions return zero for half the inputs and one for the other half of the inputs here is an example of a balanced function that takes in a bit string of length three as you can see the function returns zero for four of the inputs and one for the other four of the inputs for a classical computer to solve this problem it would need to query the function in the worst case 2 ^ n 1 + 1 * where n is the length of the bit string the function takes as input this is because in the worst case we check half of the inputs and get the same output for all of them when this happens we need to check one more input to determine whether the function is constant or balanced the there are two to the N possible bit strings of length n so 2 the nus1 is half of the possible inputs therefore we need to check half + 1 so 2 n1 + 1 inputs in the worst case to be certain the function is constant or balanced with a quantum computer we only need one query of the function just like deutch's algorithm to determine whether the function is constant or balanced here is a circuit for the algorithm this line here going through the circuit represents n qits and the hamod gates tensor n represent n hadam mod Gates each one being applied to one of the N cubits let's go through the algorithm at S Sub 0 we have n z minus then at S Sub one we apply a hadam mod gate to each of the N zeros giving us this state let's quickly derive anide identity that we frequently use when applying hatam mods to a register of zeros this gives us n plus States if we expand them out we get 1 / < tk2 0 + 1 tens with 1/ < tk2 0 + 1 and so on N times let's try different values of n to figure out how we can represent this mathematically if we have Nal 2 we have the plus state tensored with itself Distributing the states gives us a state one of a < tk2 2 0 0 + 0 1 + 1 0 + 1 1 we can represent the superposition States like this with a sum over all bit strings of length 2 x let's try n = 3 with this we have the plus state tensored with itself three times Distributing gives us this state we can once again represent the superposition States as a sum of all possible bit strings of length three and X resulting in this state we can generalize this and say that if we apply a hadam mod to each of the N zeros we get 1 / < tk2 to the^ of n time the sum of all bit strings of length n x this is a very important identity in Quantum algorithms and is used in many algorithms if you think about it this makes sense since each Cubit is in the plus state it has an even chance of being zero and one so every possible combination of zeros and ones will occur in the state and with equal probabilities going back to size sub 1 we can now change this to our identity now at size sub 2 we apply the Oracle function since the function acts on each of the superposition States we distribute it into the sum now if you look at each of the superposition states in the sum they are in the phase Oracle form applying the function function gives us the equation 1 / < tk2 the^ of n * the sum of all bit strings of length n 1 to the^ of f ofx xus let's emit the minus Q bit from the equation as it is not needed in the algorithm anymore at size sub 3 we once again apply a hatam mod to each of the CU bits what this means is that for every bit in the bit string X we apply a hadam mod gate you may be looking at this and thinking that we can use the formula we used before but that one can only be used when the state is all zeros the X State can be any combinations of zeros and ones let's quickly figure out how we can represent this mathematically for this we can rewrite the hadam mod transform on an arbitrary bit XI as 1 / < tk2 0 + 1 to the^ of x i 1 since if XI is0 it becomes the plus State and if x i is one it becomes the minus State let's try X being a bit string of length three this gives us this state if we tend to the states together we get this state let's quickly add the exponents of the negative 1es as you can see whenever there is a one in the superposition state that state is being multiplied by a negative one to the power of x i where x i is the position of the one we can reite write this as the dotproduct of X with the superposition State now we can combine this state as the sum of all Zs that are bit strings of length three 1 to the^ of X do z z generalizing we get this identity where applying a hatam mod to an arbitrary bit string of length n x gives us 1 / < tk2 to the^ of n * the sum of all bits Str of length n 1 to the^ of X do z z this is also a very important identity that is used in many Quantum algorithms with this the qits are now in this state let's now consider the amplitude of the all zero State we find that it is 1/ 2 ^ n time the sum of all bit strings of length n 1 to the^ of f ofx + x dotted with all zeros the X doted with the all zeros become zero so the state becomes this state now if the function f is constant then the value of f ofx will be the same no matter the input this means that if f ofx is equal to Z the amplitude of the state becomes 1/ 2 to the^ of n time a sum over all X's 1 evaluating the sum there are two to the end possible combinations of Zer and ones of length n so the sum is 1 + 1 + 1 and so on 2 the^ of n * this gives us 1 / 2^ n * 2^ of n which equals 1 on the other hand if F ofx isal to one we do the same thing giving us netive 1 so if the function is constant the amplitude of the all zero state is plus or minus 1 if the function is balanced then half the inputs will result in zero and the other half will result in one if we look at the sum this means that there will be the same number of ones being added to the same number of negative ones this means the sum will be evaluated to zero so if the function is balanced then the amplitude of the all zero state is zero now we measure the cubits before we saw that if the function is constant then the amplitude of the all zero state is plus or minus 1 that means the probability of measuring the all zero state is one if the function is balanced on the other hand then the probability of measuring all zeros is zero what this means is that if we measure all zeros the function is constant but if we measure anything else the function is balanced and we done we have determined if the function X f is constant or balanced in a single query of the function the key takeaway from this algorithm are these two identities they will keep popping up again and again let's now look at the Bernstein vasani algorithm here is the problem it solves imagine we have a function f that takes in a bit string of length n and returns a single bit which is a DOT product of the input with some secret string S modulo 2 our task is to find out what the secret string s is on a classical computer the approach is to input a bit string of all zeros except for one in one position this allows us to get the value of one position of the bit string S as all the zeros in the input will cancel out in the dot product this means that we must query the function n * when n is the length of s since each query we get one value of s with quantum computers on the other hand we only need to query the function once to find out what s is if we look at the circuit it may look familiar it's the same circuit as a DOA algorithm just with a different function being applied to the cubits initially the cubits are in the state n z minus then at S Sub 1 the state is 1/ < tk2 the^ n * the sum over all X where X is a bit string of length n x minus at S Sub 2 we apply the Oracle since the target Q bit is in the minus State we use the phase Oracle property so the state becomes 1 / < tk2 to^ n * the sum over all x 1 to the^ of f ofx xus let's rewrite f ofx as a dotproduct of X and S since that is the definition of our function let's also emit the minus qbit since it is not needed anymore now we apply a hadam mod to each of our Q bits let's distribute the 1 to the power of X do s into the sum we can now add the exponents giving us the dot product of s s and X plus the dot product of x and z we can factor out the X giving us s + z dotted with x the plus indicates bit wise exclusive or so for each bit in s we exclusive or it with the bit in Zed that is in the same position so the I position of S Plus Z is S Sub I exclusive or with Z sub I this gives us another bit string of length n now we measure the Q bits let's look at the probability of measuring s expanding out we find the amplitude of the S state is 1 / 2 to^ n * the sum over all X's where X is a bit string of length n 1 to the power of s + S dotted with X since plus indicates bit yse exclusive or S + S equals to all zeros now in the X exponent we have all zeros dotted with X this will equal Z since all the zeros will cancel out all the X's at each position applying the power means the state becomes 1 on 2 the^ n * the sum over all X's 1 since there are two to the power of n bit strings of length n there are two to the N possible values of X so evaluating the sum we get 2 the^ of n this leaves the amplitude of the s State as one this means that the probability of measuring s after applying the algorithm is one and that is it after one query of the function we can find S by measuring the cubits you may start to see the similarities between this algorithm and the others applying a hadam mod to each of the cubits so that the state is in a uniform superp position then applying the function and once again applying hadam mods is used in many algorithms in the next two lessons we will look at the quantum forier transform as well as Quantum phase estimation these are both used within many Quantum algorithms including Shaw's algorithm let's start with the quantum fora transform or qft before we look at the maths and circuit behind it let's look at how it transforms states on the Block sphere so we can gain some intuition on the top we have how we would normally represent a number in binary as you can see each of the Q bits is either zero or one and if we take those bits we get the number then underneath we have the same cubits after the quantum 4A transform has been applied as you can see instead of encoding the numbers like we normally do in a classical computer with zeros and ones the numbers are now encoded by the phase of the Q bits that are in a uniform superp position as you can see the left Q bit has two possible phase options either Zer or 1 relative phase then the next qbit has four possible phase options and so on up until the last CIT which has two to the N possible phase positions where n is the number of qits in this case the right CU bit has 2 to the 3 or eight possible phase options depending on the number the phase of the CU bits is different let's see how the number five is encoded Ed once the quantum 4A transform has been applied as you can see the right Q bit has been rotated around the Z AIS 5 8 * 2 piun radians which is 5 piun on 4 radians to get the amount rotated around the Z AIS of the next q bit we multiply the previous one by two so the next q bit has been rotated 2 * 58 * 2 piun radians so rotating the cub > / 2 radians around the Z AIS the last one is 2 * that which is 2 * > / 2 radians this means that if we have this state which is five in binary and we apply the quantum forier transform we get this state in the next lesson we will see a use of the quantum forier transform but for now let's look at the circuit here is the Quantum forier transform circuit for any number of bits as you can see there are two gates that we have not seen before this gate here is a controlled R gate we will Define this gate with this Matrix as you can see this gate has a variable K which we can set and affects the phase applied this gate transformed the Bas of State 0 into 0 and 1 into e 2 Pi / 2 to the K 1 giving us a relative phase if applied to a q bit in in superp position the controlled version like we have in this circuit is the same as all the other controlled versions of other Gates only applying the gate if the control is a one this other weird looking gate is called a swap gate and it swaps the states of the two Q bits for this lesson we will go through an example with three bits for this example we'll use the state J as an input to the algorithm we will label each one of J's bits like this where each ji is either Z or 1 to keep our equations tidy we will look at each one of the cubits individually then combine them at the end of the algorithm let's start with finding out what j0 becomes after the hadm mod gate the state becomes 1 < tk2 0 + 1 to the^ of J 01 we can represent this like this you will see why we keep the j0 ided 2 and don't simplify the fraction at the end then we apply the controlled R2 gate with J1 as the control we apply the R3 gate in the same way now let's find out what J1 becomes after the hadam mod gate the state becomes this state then after the controlled R2 gate and simplifying like we did previously we get this state lastly we apply a hatod gate to the J2 Cubit leaving it in this state so after this part of the algorithm our state J is in this state now once we swap the cuits the state changes to this and we're done with the algorithm it may not seem like we did much but we have in fact encoded the value of J into the phase of the cubits just like we saw with the animation previously let's quickly check this by making J the value of five so 101 in binary if we now input the values into the equations for the state then we can see that the phases do match up to what we had previously discovered at the beginning of the lesson if we were to apply the quantum fora transform to an arbitrary basis State J we get 1 / < tk2 to^ of n * the sum from K = 0 to 2 n 1 E to the^ 2 pi i j k/ 2 the n k where n is the number of bits in J we also have the inverse Quantum fora transform and that undoes the quantum forier transform so if we add this state which is the state where we encoded five using the quantum forier transform if we now apply the inverse Quantum forer transform we get back to our state 101 the quantum phase estimation algorithm allows us to find the igen value of an igen Vector given the Matrix so if we have a matrix U and apply to its vector v since V is an Vector we get e to the I Theta V where e to the I Theta is the igen value we can represent all igen values in Quantum Computing in this form the qpe or Quantum phase estimation algorithm finds e to the I Theta to a certain accuracy this algorithm is a key part in many Quantum algorithms including shaes algorithm which we will discuss in the next lesson which allows us to find prime factors of large numbers here is the Quantum phase estimation circuit as you can see we have two registers the first one contains M zeros and is used to store the estimated phase and the second one V is n cubits and is the IG Vector of the gate we're trying to measure the IG value of looking at the circuit you can see that the gate U which we're trying to find the I value of is to the power of some numbers U to the power of n is the same as applying U to a qit n * also you can see we have the inverse Quantum fora transform at the end of the algorithm let's start going through the circuit at S Sub 0 we have the state M Z's V then at SI sub 1 we apply the hadam mod gates to all the Q bits in the first register at SI sub 2 we apply the uate to the igen vector v with the rightmost qbit in the first register as a control since V is the IG Vector of you phase Kickback occurs which adds a relative phase of e to the a Theta to the Cubit then at SI sub 3 we apply two U Gates or the U squared gate with the qbit in the first register as a control and v as the target once again phase Kickback occurs applying a phase of e to the I Theta * a to the I Theta or e 2 I Theta we continue this process for each of the cuits in the first register which leaves us with this state now we let Theta equal 2 pi J where J is a number between 0 and 1 since Theta is an angle between 0 and 2 pi with this if we find J we can find Theta substituting this in we get this equation now since since J is a bit string less than one we can represent it like this which converts it from a decimal in binary to a decimal in base 10 if we now sub that into our equation it becomes this now if we look at the first Cubit we have a factor of 2 to the^ of nus1 if we distribute that into J we get this since all these terms are integers when we expand them out they will be a factor of 2 Pi so they are not needed since they are redundant this leaves us with J m1 / 2 if we do the same process to the rest of the cubits we are left with this state can you notice anything about this state this is the same state as if we were to apply the quantum for8 transform to the state J so when we apply the inverse Quantum forier transform we end up with the state J all we need to do is measure the state and we've approximated J to M bits now with J we can multiply it by 2 pi to get Theta and then we can find the I value as e to the I Theta now we will tackle probably the most important and popular Quantum algorithm shaes algorithm this algorithm allows us to find the prime factors of a large number so if we have a number n equal PQ where PQ are both Prime Shaw's algorithm allows us to find p and Q this may not seem very useful but this is the backbone of RSA which is a widely used type of encryption so using shaes algorithm will allow us to crack RSA encryption but that won't happen for a while to run sh's algorithm we will need a fault tolerant quantum computer with Mill ions of logical Q bits which won't happen for some time this algorithm uses both classical and quantum computers for different steps first we choose an a that is between 1 and n and the gcd of A and N is one so A and N share no common factors next we do the quantum step but before that we will look at some number theory in modular arithmetic we say say that a is congruent to B mod n if the remainder of a / n is B for example 3 is congruent to 1 mod 2 since dividing 3 with two gives a remainder of one we can reduce the factoring problem down into the problem of finding the period of modular exponentiation modular exponentiation is when you take the powers of a number modul a number here is an example example as you can see if we have a number in this case two and put it to increasing Powers we get a repeating pattern when we take the modulo the period of this pattern is the length of the sequence and that is what we are looking for in this case the period R is equal to 6 all of the sequences start with a ^ of 0 is congruent to one mod n so we need to keep increasing the power until we get back to one if we are able to find the period we can use some number Theory to find the prime factors if we have a number n which is equal to the product of two prime numbers p and Q if we pick a number a where the gcd of A and N is equal to 1 so they share no common factors and we find the period of a to the X Mod n then if we get a good approximation for R the gcd of a to the^ of r / 2 1 and n and the gcd of a ^ n / 2 + 1 and N has a good chance of containing the factors of n let's go through the steps in finding the period of modular exponentiation for this we need to use this gate let's call it U which transforms the state x to the state x a mod n if we apply this gate to the one state multiple times we can get powers of a in mod n how we construct this gate is outside the scope of this course see the problem set for resources on how we can construct this gate let's consider this state us if we apply a uate to the state it gives us this state looking at the a to the r mod n we can change the to a to 0 mod n since they are both 1 if we multiply the right hand side by 1 or e to the 2i i s / R * e 2i i s / R we get this state we can change the E to 2 Pi I Sr / R to e to 2 Pi i 0/ r since they are both equal to one now as you can see this whole state becomes the US state this means that the US state is an igen Vector of the uate with an igen value of e to ^ 2 pi i s / R this means that if we can construct the US state we can use the quantum phase estimation algorithm to get the value of s/ R it turns out that it is far easier to construct the equal superposition of all of the US states what what this becomes is 1 mod n in the problem set for this lesson we will prove this result we can construct the one mod n by applying a KN to the rightmost Q bit in a register of all zeros which gives us the value one which is equal to one in mod n so by creating the state 1 mod n we are actually creating the state 1 /un R * the sum from s = 0 to R 1 of us here is the circuit for the algorithm looking at it this is just the quantum phase estimation circuit as you can see we now know that one is an igen Vector of the uate so we are using this to estimate the igen value e to^ 2 pi i s / R where s is an integer from 0 to R 1 this is because our igen Vector 1 mod n is equal to 1 /un R * the sum from S = 0 to R 1 of U so we will get the I value e to ^ of 2 pi i s / R for one value of s so when we measure the qits we will get the I value of one of the US's which means that we will get S / R for 1 s from 0 to Rus one if we happen to get zero as our igen value so s = 0 then then we repeat the circuit so we can get an igen value that is non zero now we have a decimal number J which is equal to S / r that is the Quantum part of the algorithm done now we estimate the values of S and R by using a technique called continued fractions here is an example with the decimal 0.312 we start by writing it as a fraction then we flip the fraction we continue this process until we have the number one in the numerator by representing a decimal in this way we can approximate its value with a fraction by rounding off the continued fraction here are the first three approximations for the decimal 0.312 to approximate s / R we find an approximation where the denominator is less than n since the period R must be less than n if R is odd then we repeat the algorithm and get a new value of R now that we have a value for R we can use this to find the factors of n we know that a to the r is congruent to 1 mod n so a to the r 1 is congruent to Z mod n this means that a ^ of R 1 has a factor of n since when we divide it by n we get zero remainder if we Factor a^ R 1 with the difference of 2 squares then we get this from this we can see that if we calculate the gcd of a^ R / 2 1 n and the gcd of a^ R / 2 + 1 and N with our approximation of R we have a good chance of them being one of the factors this allows us to find p and Q let's go through a quick example with n = to 15 so p is 3 and Q is 5 in step one we choose an a which is relatively prime to 15 let's choose AAL 7 now in step two we use the quantum part of Shaw's algorithm to find the period or R so we need to find R such that 7 to the power of R is congruent to 1 mod 15 by using the algorithm we find that R is equal to 4 now we calculate the gcd of 7^ 4 /2 1 and 15 and the gcd of 7^ 4/ 2 + 1 and 15 the first one becomes the gcd of 48 and 15 and the second becomes the gcd of 50 and 15 the gcd of 48 and 15 is three and the gcd of 50 and 15 is five as you can see we have found the factors of 15 3 and 5 using shaes algorithm
