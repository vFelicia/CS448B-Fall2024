With timestamps:

00:02 - while Luke John was a developer at seven
00:05 - West media he led the adoption of CSS in
00:07 - jeaious at the West Australian and at
00:09 - Perth now and he's also a leading
00:11 - contributor to the CSS in J's framework
00:13 - glamorous he's going to tell us all
00:15 - about using CSS nsj we have type systems
00:18 - like typescript or flow with typesafe
00:20 - CSS and J yes please welcome look okay
00:29 - so as you just heard I'm here today to
00:32 - talk about type safety and CSS and Jas
00:34 - both of which are very shiny quite new
00:38 - and a really fun to work with so just a
00:43 - bit of background around how we got to
00:45 - type safety and CSS and Jas we've had
00:49 - this massive rise of Jas everywhere
00:53 - we've got frameworks like react and
00:56 - angular and as those frameworks got
00:59 - bigger and more mature we've started to
01:02 - see type systems from the likes of
01:05 - Facebook and Microsoft where you'll have
01:08 - some level of type safety with your
01:10 - JavaScript and that language will just
01:12 - compile to JavaScript and it helps make
01:15 - those large code bases a bit more marine
01:19 - table and flexible for a future usage so
01:24 - on the CSS nsj side of things we should
01:26 - probably start with what CSS outside JSS
01:30 - with these modern frameworks where
01:33 - you're doing component based development
01:34 - your markup is a function of state it's
01:38 - quite easy to understand based on this
01:41 - URL and flowing through your JSX if
01:45 - you're using react exactly what markup
01:47 - you're going to be getting when it comes
01:49 - to styling side of things it's a bit
01:53 - more of an unknown a lot of frameworks
01:55 - we'll be having will be important
01:57 - perhaps for different CSS external files
02:01 - then they might be using webpack loaders
02:04 - for sass to have some level of component
02:06 - based styling but the CSS is not
02:11 - necessarily determinable
02:13 - based on just state CSS in jeaious both
02:18 - your markup and your styling is a
02:20 - function of your state and so based on a
02:22 - URL or a user being logged in you can
02:25 - work out exactly what styles and only
02:28 - those styles are actually created for
02:30 - the page so it enables pattern things
02:33 - like critical CSS and really helps out
02:37 - if you're doing server-side rendering to
02:39 - only shoot down the CSS which is needed
02:43 - for any particular page so it's really
02:46 - awesome so as we started there before a
02:51 - lot of this talk is going to be using
02:53 - react however CSS in jeaious exists with
02:57 - a bunch of the other frameworks now but
03:00 - when you add type safety to something
03:03 - like react and CSS nsj you start to live
03:06 - in the happily ever after where things
03:08 - are really shiny and you won't enjoy
03:11 - coding all the things and so we'll just
03:13 - start with where CSS nsj started the
03:18 - term was first popularized by inline
03:22 - styles in react where as you're doing
03:25 - your templating inside your JSX there
03:28 - there's a style property available which
03:32 - you can just add some inline Styles
03:33 - those will get added in line in your
03:37 - resulting HTML markup but then later on
03:40 - other frameworks saw that pattern
03:42 - thought this is really awesome and they
03:44 - created some other handy helpers that
03:47 - would extract all of that and put it
03:49 - into your head or do other things but
03:51 - the basic pattern was very similar and
03:55 - this example here is actually got it
03:57 - turned on with typescript we'll just
04:00 - have a look at the Taipings for where we
04:02 - started with type safety in CSS and
04:04 - jeaious they just typed a subset of CSS
04:09 - properties for some of them they had
04:13 - pretty strong type safeties so this
04:15 - aligned content property here you'll get
04:18 - autocomplete on the key and the value
04:22 - and if you do a misspelling which
04:25 - is quite common in CSS you'll get
04:29 - immediate feedback about that
04:33 - unfortunately there's a lot of CSS
04:36 - properties that allow quite flexible
04:42 - values border 10px solid red
04:45 - you can't give types a key for that sort
04:47 - of thing just using this pattern so
04:49 - they're just type two strings so this
04:52 - was the inline Styles popularized by
04:56 - react what was happening in Jay s about
04:59 - the same time is the language was
05:01 - getting new features one particular new
05:04 - features were template literals of which
05:06 - the more advanced version was the tagged
05:10 - template literals and these would allow
05:12 - you to pass template literals with
05:13 - function that's at bottom one that's
05:16 - just grad from MD n n MD end the
05:18 - examples and so people who were doing a
05:23 - lot of react development who had
05:25 - traditionally been putting a lot of work
05:27 - into other solutions for CSS at scale
05:30 - saw this and thought wow we could do
05:34 - some really awesome stuff with this that
05:37 - slide is far too small to see on
05:39 - apologize but essentially you've got a
05:43 - function up the top there that you've
05:44 - set up which would allow users to use a
05:50 - string as an API for writing their CSS
05:53 - within JavaScript and then have
05:58 - expressions within that of course this
06:02 - is a bit of a back step when it comes to
06:04 - type safety for CSS and jeaious because
06:06 - we've gone back to a string interface
06:09 - and you're not going to get a lot of
06:11 - safety there however really popularized
06:14 - the props based styling pattern where
06:18 - you could have functions which you could
06:22 - pass props to so when you're doing
06:23 - component based development pass props
06:26 - in to what was ever creating your CSS
06:28 - and rather than having three different
06:30 - class names that you're going to select
06:31 - form based on those props you could just
06:34 - write the exact CSS in
06:36 - case which was really handy and here's
06:40 - just an example using styled components
06:45 - you get auto complete on the Dom tags of
06:50 - the interface but then once you're
06:52 - inside that tag template you have no
06:57 - real safety but then down below there
06:59 - what you can see is using so that then
07:03 - returns a react component which you can
07:07 - just use inside your JSX see inside your
07:10 - templating and it has the props flowing
07:12 - through quite nicely so then we had
07:16 - glamorous came out earliest last year I
07:22 - think about April and it followed on
07:26 - from some of the api's that had been
07:28 - pioneered by the starred components
07:30 - people but they quite liked the CSS
07:33 - object interface for writing your CSS so
07:37 - they mixed that pattern of having
07:38 - component factories with CSS objects and
07:43 - this was really exciting for where I was
07:46 - working at the time we had been using
07:49 - processes peer-review conventions such
07:52 - as been to protect our code base from
07:54 - bad things happening and this was
07:56 - working for most of the time for our
07:58 - front-end devs with strong CSS knowledge
08:00 - however that wasn't all of us we had
08:03 - people with a range of experience across
08:04 - domains and so bad things were still
08:08 - happening CSS nsj with something quite
08:11 - glamorous which we would be able to type
08:14 - look like it offered some technical
08:15 - solutions to the problems we were having
08:18 - so the initial typings somebody was
08:22 - obviously using it on a project they'd
08:25 - ridden some type-ins internally and they
08:27 - went to contribute that back to the
08:29 - community
08:30 - what had been happening a lot at that
08:32 - time was people would put the tie pins
08:34 - on definitely typed and just sort of
08:35 - which is a it's a repo set up by
08:40 - Microsoft which makes all the types of
08:42 - ailable to install but about this time
08:46 - people were starting to bundle
08:47 - definitions with the frame
08:49 - so somebody thought oh yeah I'll try and
08:50 - get those landed there the person who
08:55 - led the development of it wasn't quite
08:56 - sure about it but the feedback he got
08:59 - and it's quite surely is that it's a lot
09:02 - better for consumers when you have
09:03 - bundle typed it implies that the project
09:06 - is type friendly B those bundle types
09:08 - flow or type script and when you change
09:11 - or add something you can expect a PR
09:14 - shortly to add type support for that and
09:17 - a bunch of other things it does however
09:19 - lead to a bit of extra contributor
09:22 - overhead because you've got more
09:24 - activity going on
09:26 - so those initial definitions they just
09:29 - covered a small subset about the of the
09:32 - API of glamorous and there was also a
09:36 - clear expectation set around how those
09:39 - types would be maintained it would be up
09:41 - to typescript users to maintain those
09:45 - which was everybody accepted and was
09:48 - great what was also very helpful was the
09:51 - project had very clear contribution
09:54 - guidelines this provided clear guidance
09:56 - for the initial PR to add them but also
09:58 - for anybody who wanted to extend the
10:01 - Taipings or add additional features it
10:03 - was very clear how they could add those
10:05 - features and get them landed so if
10:07 - you're adding types to a framework
10:09 - highly recommend having contribution
10:11 - guidelines well laid out so initially it
10:15 - was set up with the types separated out
10:17 - into a toppings folder which is a fairly
10:19 - standard thing with in typescript
10:22 - definitions and also flow ones and then
10:25 - there's just a field you put in your
10:27 - package jason with a the location of
10:30 - where the toppings are for when
10:31 - typescript does type acquisition on
10:33 - usage and it also just had a simple test
10:38 - file the way testing works for a lot of
10:41 - typescript definitions is that they just
10:44 - have a single file that just goes to all
10:47 - the uses that the types provide and make
10:50 - sure that the compiler doesn't generate
10:52 - any error output and as you can imagine
10:54 - there's some problems with that but
10:56 - we'll touch on that in a bit
10:56 - and so sorry
11:00 - so showing up there fantastic
11:03 - so this is just some of the api's that
11:08 - glamorous had to give an idea as we jump
11:11 - into the Tri Keynes that it has what
11:13 - sort of support it needed and the range
11:15 - of types so we just start with some
11:18 - glamorous dom and built-in component
11:21 - factories the second signature their
11:23 - glamorous talk gives just a short cut to
11:24 - the first one it also had built-in
11:28 - components so you could just import a
11:30 - div from glamorous name name sized
11:37 - exports and also glamorous octave would
11:39 - work as well
11:40 - this actually presented a bit of
11:41 - challenge for typescript because there's
11:43 - no easy way to share named exports with
11:47 - interfaces for typing so there was a
11:49 - fair bit of type ii plication also with
11:52 - the glamorous stock dev for the other
11:54 - built in component factories then
11:58 - glamorous could also take components
12:00 - when you set up a component factory so
12:04 - that needed to be typed and it also had
12:07 - options which would then change the
12:09 - behavior of the resulting component so
12:12 - if you set that props are CSS overrides
12:15 - this equal to true when you finally use
12:17 - that component you then have available
12:21 - all of the CSS properties as props on
12:23 - that component which will get added up
12:26 - into the CSS and then there's also with
12:30 - component api which you can change what
12:32 - component the eventuated clamorous
12:36 - component factory returns so a huge api
12:41 - service with things at the top level
12:43 - impacting things a few levels down which
12:47 - was quite interesting so in terms of
12:49 - type coverage we'll just touch on
12:50 - initially the CSS and SVG properties so
12:56 - we'll start with the these were very
12:58 - similar to the react typings
13:00 - initially we just used to react to CSS
13:03 - property typings then we had a great PR
13:05 - from a contributor who vendored those
13:08 - but then went through property by
13:10 - property and checking the MDM doc
13:13 - tation and tightening up the types so
13:16 - for some things such as display or float
13:18 - I think where the reactor eye pins for
13:23 - would just accept any string it was
13:25 - tightened up a bit so for the
13:26 - autocomplete it was really helpful and
13:28 - for misspellings it would avoid that
13:31 - then we just also need to support the
13:34 - pseudo properties so that's how you
13:37 - would use that and then when you're
13:38 - using that anywhere where it's being
13:40 - typed you're going to get type safety
13:42 - which is really handy you also get
13:43 - autocomplete it's quite wonderful then
13:47 - we had a lossy version of the CSS
13:50 - properties the way that a lot of the CSS
13:53 - and J's frameworks work with their CSS
13:55 - objects is they support something
13:57 - similar to sass and other things where
14:01 - you can have contextual selectors but
14:04 - also just for media queries where you
14:06 - have another object underneath it
14:08 - because of this particular type index
14:12 - that would be getting added onto it it
14:14 - meant that for the previous CSS objects
14:16 - you actually lose type safety so whilst
14:19 - if you've typed float correctly get type
14:21 - safety on the properties in order to
14:22 - complete if you accidentally type flat
14:24 - it's going to pass which is a bit sad
14:28 - there are some other alternative CSS and
14:31 - J's frameworks that have alternative
14:34 - syntax for this sort of stuff they're
14:36 - not quite as widely adopted or and but
14:39 - should be interesting in the future and
14:43 - so then just using it all together it's
14:45 - kind of like CSS it's just using an
14:48 - object J object syntax it all fits
14:51 - together quite well so those are just
14:55 - some examples so style arguments these
14:58 - are the things that when we saw earlier
15:01 - on the glamorous API you would set up a
15:04 - component Factory with either a Dom tag
15:07 - or a component these are the arguments
15:10 - that you then pass to that to create
15:12 - your CSS it can take a function which
15:15 - would return some properties or a string
15:19 - or also an array of properties and
15:22 - strings it would also accept a style
15:25 - array so
15:26 - ray of all of those things and then a
15:31 - style argument sort of a combination of
15:32 - those plus a couple of other signatures
15:34 - that I've just taken out of that for
15:37 - brevity's sake but then for the style
15:40 - arguments that's for dynamic styles and
15:42 - you can see their props are getting
15:43 - passed to us and generic so that they're
15:45 - available in the style functions a lot
15:48 - of the time when you do in CSS in j/s
15:50 - you won't actually use props flowing
15:52 - through and so there's also a simpler
15:56 - static style argument which also helps
15:58 - out with the compiler output if
16:01 - something goes wrong it's a bit simpler
16:03 - in those cases it's been easier to read
16:06 - and so here's an example of how those
16:12 - types are then checked on a component so
16:16 - here that will pass because it's a CSS
16:18 - properties object and the values are
16:20 - correct here this would pass because
16:22 - it's a function having actually typed
16:24 - this but it the props if I had a typed
16:26 - on the example component would be type
16:29 - two something and then you can use that
16:32 - in determining the output of the display
16:35 - here it would pass because it's going to
16:37 - return a string here would pass because
16:39 - it's going to return an array of all
16:41 - those things so quite a lot of different
16:46 - things you could do with star arguments
16:47 - Oh with support and so we'll next look
16:54 - at just a single one of the glamorous
16:57 - API shapes that we saw earlier where you
16:59 - pass a component factory to the
17:01 - glamorous function which will return you
17:03 - a glamorous component Factory so this is
17:06 - a heavily trimmed down version of the
17:08 - types so we start with the main export
17:11 - from the definitions which is this
17:14 - glamorous interface then the glamorous
17:18 - interface
17:19 - this looks really noisy and messy
17:22 - essentially it's just a object which
17:24 - takes a component with some optional
17:26 - objects and returns a glamorous
17:27 - component factories we've had to use a
17:29 - lot of generics here because of all the
17:34 - different changes that happen downstream
17:38 - in that glamorous can
17:40 - Factory and then the resulting Columbus
17:42 - component that is created from that in
17:44 - order to get type safety there but you
17:46 - don't actually have to pass any of those
17:48 - generics all the time most of the time
17:50 - if you're doing something dynamic with
17:52 - that component you'll just pass the
17:53 - props and the rest will just all match
17:55 - together
17:55 - if you've typed it on that component
17:58 - which is really nice we use overloading
18:03 - with this signature because depending on
18:06 - the options that you pass in again the
18:09 - signature of the so dish the API of the
18:14 - resulting glamorous component is quite
18:16 - different it will accept if you've set
18:18 - the props or CSS overrides options to
18:20 - true a bit down you can just use those
18:24 - props and so they need to be typed as
18:26 - well so that's the initial creation then
18:31 - we get into the actual component factory
18:33 - so that returns the component factory
18:35 - component factories just take those
18:38 - generic crops and initially we start
18:40 - with a overload for the static styles we
18:45 - put that at the top because even though
18:48 - it should match down the bottom as well
18:50 - so the next two we'll see there was a
18:53 - bit of a memory leak issue with
18:55 - typescript and this just has CSS
19:00 - properties as arguments pretty much you
19:03 - can't do any functions or anything in
19:04 - there then we have an overload for a few
19:06 - props have got a theme so there's a
19:08 - concept of a theme provider and
19:09 - glamorous which I won't go into but
19:11 - essentially there's some magical props
19:13 - that can end up on that component and be
19:16 - available for whilst you do in your
19:17 - styling and we also use as part of this
19:20 - so we say that when they set up the
19:23 - props for the component Factory so for
19:27 - those functions that we turn the styles
19:29 - the themes going to be available but
19:31 - then when they we actually return the
19:33 - glamorous component from this all those
19:36 - props that are there they need to be set
19:38 - up
19:39 - but the theme doesn't type script
19:43 - doesn't have subtraction types and it
19:44 - kind of gives something similar but it
19:47 - does actually pollute the intellisense
19:50 - and compiler output so I would recommend
19:52 - avoiding where possible and then finally
19:55 - we just have a overload for the
19:58 - component factory where there's just
20:01 - that props no theme which is quite handy
20:04 - and it just keeps the types of it's
20:06 - simpler and then finally the component
20:11 - factory to returns a glamorous component
20:13 - which is just a react component factory
20:15 - with various external props and extra
20:18 - glamorous props so the external props in
20:20 - some case will just be the props
20:21 - sometimes it will be the CSS properties
20:24 - if we had offset that props or CSS
20:26 - overrides earlier on and then it also
20:29 - has some methods available on it such as
20:32 - with component which we saw earlier
20:33 - which will let you have all the props
20:37 - and all the type in but for a slightly
20:40 - different component which is this one
20:43 - here and there's a couple of other ones
20:45 - there so what was getting typing typed
20:51 - initially it started off with just a
20:53 - very small subset of what was available
20:55 - in glamorous it was quite understandable
20:59 - easy to use but there was a lot of stuff
21:02 - that you couldn't do then we started to
21:05 - add overloads and generics to provide
21:08 - support for both the alternative
21:10 - interfaces but also the generics to get
21:12 - better type safety on some things that
21:15 - initially that were essentially such as
21:17 - pops just a any so you didn't have that
21:20 - much safety then we introduced the omit
21:25 - type to support the theme being excluded
21:30 - it seems like a really good idea at the
21:33 - time there was probably an alternative
21:35 - syntax that we could have used using an
21:37 - additional generic but this less magical
21:40 - type and had we have used that it would
21:44 - have led to much cleaner compiler output
21:46 - and when users are having errors easy to
21:49 - understand what's going on and then
21:52 - eventually we started having to use
21:54 - overloads coupled with generics which
21:58 - would extend the extend from things so
22:01 - that we could limit this particular
22:04 - generic to
22:05 - this shape and then we'll do this thing
22:08 - and it all got very complicated very
22:11 - fast that was a very small subset in
22:15 - some places there were extra overloads
22:18 - for things like CSS properties versus
22:20 - SVG properties unfortunately a
22:23 - limitation of the compiler typescript
22:25 - compiler at this point in time meant
22:27 - that the intellisense at this point in
22:29 - time meant that if you try and union
22:31 - that there you would just lose
22:33 - autocomplete it would still type but the
22:36 - developer experience would get worse and
22:38 - so pretty massive amount of types as you
22:43 - can imagine things go wrong when you've
22:46 - got such large types and the standard
22:49 - definition strategy of just testing what
22:53 - is meant to work and making sure that
22:55 - the compiler succeeds wasn't really
22:59 - sufficient to allow additional
23:01 - contributors to easily add things and
23:04 - not have to worry about accidentally
23:07 - breaking something else so we introduced
23:10 - some additional testing we just set up a
23:12 - should fail file adjacent to the test
23:14 - file and then we just used just
23:17 - snapshotting to run the compiler on that
23:19 - file as well make sure that everything
23:22 - that we'd set up to fail was ending up
23:25 - in that snapshot and that did pick up
23:28 - quite regularly where people would sort
23:30 - of think oh I can just make this change
23:31 - here and not realize that that would
23:33 - actually knock out something else with
23:35 - one of the other glamorous interfaces so
23:38 - really handy pattern there's some other
23:40 - strategies there now that a little less
23:43 - sort of hacky here we're just using
23:45 - spawn to run the compiler and snapshot
23:47 - it but definitely recommend testing both
23:51 - sides and also just on the testing side
23:55 - of things you'll often find that if
23:58 - you're using
24:00 - glamorous as part of something that else
24:04 - which you're generating definitions from
24:06 - it has subtly different behavior with
24:10 - the compiler so recommend testing in
24:13 - definitions declarations bode with your
24:17 - tests another thing that we did
24:19 - with the types in some places was we did
24:22 - things that weren't strictly necessary
24:24 - but they improved the developer
24:28 - experience in one case if we used a
24:32 - union for type the you would get type
24:36 - safety but when you're using vs code or
24:39 - another editor that's using Intel a
24:40 - sense you would lose autocomplete which
24:43 - was really handy feature and people who
24:46 - aren't using typescript are also getting
24:49 - benefits off it so we would do some sort
24:52 - of happy things it's worthwhile
24:54 - commenting when you do that to make sure
24:57 - that in a couple of months time both
25:00 - flow and typescript moving really
25:01 - rapidly a lot of things this one we
25:04 - found after about two months we could
25:06 - actually just move to a spread under
25:08 - Union and it all worked nicely so worth
25:11 - commenting those things sometimes you
25:13 - need to get a bit creative when you're
25:15 - setting up types as well or using it
25:17 - with the type system we had a fun one
25:20 - where the rollout compilation for
25:22 - glamorous was incompatible with how
25:26 - typescript was doing the importing so we
25:29 - actually added this this to the main
25:33 - glamorous source file just to allow
25:35 - usage with typescript but where you do
25:37 - get creative with things like this again
25:40 - it's really worthwhile adding some
25:42 - comments so that the next person knows
25:44 - what's going on and it's a pretty
25:49 - massive amount of typing there a large
25:53 - surface area with the API there were
25:55 - some pretty massive mistakes that were
25:57 - made which were in most cases quite
26:00 - avoidable a couple of those one we had
26:05 - this issue opened up it was quite an
26:08 - interesting one so there was a memory
26:09 - leak with the Taipings
26:10 - which meant that when you were using
26:12 - that with a project with a lot of
26:14 - glamorous components pretty quickly the
26:17 - compiler would bath and you would get
26:20 - out of memory that was it was
26:22 - interesting because the compiler worked
26:23 - fine with tests and depending on project
26:25 - size and also usage of the types it
26:28 - would just never show up and the way
26:31 - that it
26:32 - part of why it happened was there a
26:35 - bunch of changes the types getting added
26:37 - to a V next branch so nobody was testing
26:41 - them in production
26:42 - all of a sudden V next launched there
26:45 - were all these new types that landed and
26:49 - how they interacted led to this man we
26:51 - liked so it took a few days to sort of
26:53 - work out where that was and get an
26:56 - update going another one was the
27:00 - definitions can sometimes get quite
27:03 - overwhelming this was a very politely
27:05 - worded issue from somebody where they
27:08 - had gone to use the glamorous with
27:12 - typescript and the autocomplete was just
27:14 - out of control
27:15 - as you start to type in the arguments
27:18 - you would get this enormous window pop
27:21 - up with all the different options and it
27:22 - would hijack your arrow keys as to go
27:24 - through the different options so this
27:29 - one was quite well in some ways easily
27:32 - solved went back in and we structured
27:36 - some of the Taipings
27:37 - so that the output for things like Intel
27:41 - he sense but also just compiler output
27:42 - if there's an error was more readable
27:44 - and more clear more concise and yeah so
27:52 - definitely recommend limiting type
27:55 - coverage when you're typing the
27:56 - framework like this if the framework
27:58 - doesn't in tender usage
28:00 - don't type it there were a couple of PRS
28:03 - landed early on that were landed purely
28:06 - to supports and some stuff that had
28:10 - started happening by mistake and was
28:11 - never really intended by the framework
28:14 - or the lead contributors and because
28:19 - that got typed early it's hard to remove
28:22 - type coverage for anything that you've
28:24 - added because people will complain when
28:26 - they do a update and things break for a
28:30 - non-major also try to ensure types don't
28:35 - make workflows difficult like you can
28:37 - tell you senses you just saw and should
28:40 - always use comments to help consumers
28:43 - this will win you a lot of love for both
28:45 - typescript
28:46 - and flow in just j/s developers because
28:48 - in things like intellisense for api's
28:52 - that are immediately clear just off the
28:55 - name of that property they get a little
28:58 - bit of actually information about how to
29:00 - use it it's also really important with
29:05 - this sort of thing to enable
29:07 - contributors something really awesome
29:09 - that's happened in the last year is that
29:12 - there's now online play boxes where you
29:16 - can set up a full type script and flow
29:19 - project and import glamorous and have
29:24 - the sort of definitions being used as
29:26 - you're typing online and getting error
29:31 - output in browser so setting up a
29:35 - sandbox for people who are having issues
29:38 - to be able to quickly set up a
29:40 - reproduction along with the issue rather
29:43 - than having us set up a whole repo and
29:45 - it's really handy and also just obvious
29:47 - things like asking for the version of
29:50 - typescript they're using if they are
29:51 - having an issue with the bundle
29:53 - declarations is really handy so we'll
29:59 - now just have a quick look at how you
30:00 - use the CSS MJS which i've script and so
30:05 - here we have a glamorous component
30:09 - factory with styles where we're getting
30:11 - autocomplete on both the property name
30:13 - and then the values that it accepts
30:16 - really handy really useful we'll jump
30:20 - straight from that to this is something
30:23 - we're going to now create with CSS nsj
30:26 - and typescript
30:27 - so it's a reproduction of the LCA
30:30 - schedule where the it starts at a
30:34 - calendar then just collapse down to a
30:36 - talk by talk by talk and gives us some
30:39 - really clean HTML without lots of
30:41 - wrapping divs or reused CSS or anything
30:45 - like that so we'll start with a
30:48 - timetable react component which if we
30:52 - jump into that and have a look at that's
30:55 - just a glamorous emotion component
30:57 - Factory another CSS nsj framework
31:00 - we've got our CSS being returned from
31:03 - this we're going to use the CSS grid
31:06 - we're able to use the props that that's
31:08 - being typed with which has a number of
31:11 - active rooms to set up the amount of
31:12 - columns that we want on that so then if
31:15 - we jump back to the time table inside of
31:18 - that time table we're going to have time
31:20 - starts which is just going to show up on
31:22 - the left hand side as we saw and pass
31:26 - that through the information it needs to
31:27 - do that and it's just another react
31:30 - component which then has the time start
31:35 - h3 and then that's going to use the
31:38 - props to set up the CSS to put it in
31:41 - there collect correct row which is nice
31:44 - and handy there and the correct column
31:46 - as well then we'll jump on to the slot
31:50 - so that's the actual talks as we go
31:53 - through they're going to have a use
31:58 - another component we'll just have a look
32:00 - at the styled slot we won't go through
32:01 - all of it
32:02 - that takes a bunch of props which go
32:05 - into the styling again I've collapsed
32:08 - this so it doesn't include all the
32:09 - stylings required but it's going to grab
32:11 - the using the room index it's going to
32:15 - run another method which gets room
32:17 - colored that just takes a CSS color
32:20 - value and adjusts the hue left and right
32:23 - so that we get the nice colors going
32:25 - along and we can have sort of infinite
32:26 - amount of rooms or just a few and then
32:31 - it's going to select the column and the
32:34 - amount of rows that talk should span
32:36 - based on its twine start and it's time
32:39 - offset so as we've been going through
32:41 - here only the CSS that is absolutely
32:45 - required for each of these slots is
32:47 - being generated in cases where the CSS
32:50 - is in common it will dilute those Styles
32:53 - automatically for that use so there's no
32:55 - need for by handy chipping it will be
32:59 - producing a really nice clean markup
33:02 - there's no need for wrapping divs to
33:04 - sort of enable this kind of nice visual
33:06 - structure and it's
33:10 - really really easy and fast so this
33:14 - whole thing took about 20 minutes to get
33:17 - running which normally with CSS would
33:20 - take an enormous what might take a bit
33:22 - longer to get all of those grids and
33:25 - calls if you weren't doing it inside of
33:26 - j/s and being able to use those patterns
33:32 - so just have a look at the future of CSS
33:36 - MJS and some of the things that type
33:40 - script and flow enabling and the first
33:43 - one this is very limited to typescript
33:45 - in particular there's this really cool
33:47 - thing called typescript server plugins
33:49 - which gives you that string api for CSS
33:53 - that we talked about earlier on when
33:55 - that first came around
33:56 - there's no way to type a string these
33:58 - server plugins actually allow you to
34:00 - create your own sort of type safety for
34:02 - certain things and give autocomplete in
34:05 - editors using intellisense and whatnot
34:09 - so here we're actually getting type safe
34:12 - CSS strings in j/s which is really
34:16 - powerful and I think very exciting for
34:21 - the future there's also some plays
34:26 - around how you generate types at the
34:28 - moment for glamorous as you saw there
34:31 - was the glamorous dev Col glamorous with
34:34 - the div string there was the export so
34:37 - import did from glamorous there was the
34:40 - glamorous dot uppercase div which are
34:43 - all doing fairly similar stuff and using
34:46 - the same sets of types but they have to
34:50 - be typed separately and so we've
34:54 - generated typings
34:55 - you can sort of automate some of that
34:58 - which both makes it a bit easier for
35:02 - contributors when they want to make a
35:04 - change to some of those big files they
35:06 - can just make it in one place but also
35:08 - gives you a bit more confidence in the
35:11 - definitions because as it is there's a
35:14 - fair bit of copy pasting these are just
35:16 - for the different files each of which
35:18 - are a couple of hundred lines long
35:21 - another really exciting thing regex try
35:25 - there's a PR open on the typescript
35:30 - repository at the moment it's probably
35:33 - not going to land for a couple of major
35:34 - couple of versions but it's been
35:37 - actively discussed by the typescript
35:39 - team and looks really exciting
35:43 - not just for CSS in jeaious but a whole
35:45 - range of other applications and so this
35:50 - isn't actually necessary this isn't
35:52 - anything to do with typescript and CSS
35:54 - in jeaious this is just really cool
35:55 - things you can do CSS and j/s because
35:59 - it's so shiny you can do CSS
36:01 - snapshotting alongside your markup for
36:03 - your components so if you have things go
36:06 - wrong it's easier to pick up in peer
36:09 - review and also just whilst you're
36:11 - developing traditionally your Yui
36:14 - snapshots might contain a couple of
36:16 - class names which you may or may not
36:18 - have set and really no information about
36:21 - the style rules but this sort of opens
36:24 - up a lot more confidence it does
36:26 - generate very noisy tests however which
36:30 - brings us to visual snapshots we're on a
36:33 - unit level it's really easy when you're
36:36 - using something like CSS in j/s to test
36:38 - that that component is pixel perfect for
36:42 - changes so what you can see here and
36:47 - isn't working is actually you'd never
36:52 - see that if you were just looking at it
36:54 - in PR by running the code but here on
36:59 - the bottom one something it's just a
37:01 - couple of pixels off and you pick that
37:04 - stuff up immediately it's really really
37:07 - amazing
37:08 - so just summarize some of the points
37:10 - we've touched on type systems really
37:14 - help keep code maintainable and really
37:16 - help enable growth of applications when
37:21 - you think about CSS in G is a really
37:23 - nice way to think about it is it's
37:25 - turning it's adding the styling to be a
37:28 - function of the state in addition to
37:29 - your markup you can do inline Styles you
37:32 - can have styles throw an app into your
37:34 - head you can do both string an object as
37:36 - an API
37:37 - and you've now got type safety with both
37:39 - of them thanks to things like the server
37:41 - plugins the component factories really
37:44 - enable you as a developer with component
37:46 - based dev to have props impact your
37:48 - styling in terms of when you're actually
37:52 - setting up definitions and declarations
37:55 - for frameworks developers love them it's
37:59 - useful if you keep the type simple it
38:02 - both helps the users and also helps
38:07 - people who want to contribute be able to
38:09 - contribute and should test types fail as
38:15 - well as succeed it sounds really obvious
38:17 - but within the typescript and also flow
38:21 - communities the way that testing is
38:23 - happening currently that is not as
38:25 - common as it should be you can type a
38:29 - lot more than you think but you probably
38:30 - shouldn't it'll just make it harder for
38:32 - people to use the types and contribute
38:35 - to them in the future
38:37 - compilers aren't perfect but there's
38:39 - lots of ways to work around them and
38:42 - yeah types should enable users and not
38:45 - overwhel them if you're interested in
38:47 - CSS MJS there's a excellent repo on
38:51 - github CSS in Jas 101 I highly recommend
38:54 - checking it out
38:55 - it has a thorough overview of all the
38:58 - different options that are out there
39:00 - currently how you would use them and the
39:03 - advantages of the various options these
39:08 - are also some great people to follow on
39:10 - Twitter Basara in particular when it
39:13 - comes to typescript he wrote a CSS and
39:17 - J's framework with just typescript and
39:20 - is really excellent and all of the other
39:23 - ones
39:24 - Kent Dodds is the creator of glamorous
39:26 - and the other people out there have
39:29 - created other CSS and J's frameworks
39:31 - really awesome people and thank you very
39:35 - much and that is CSS and J's and type
39:38 - safety
39:42 - and I think we've just got a little bit
39:44 - of time for questions that thing that's
39:52 - yep
40:09 - so which generates I think the question
40:11 - was we've generated tycoons what's the
40:13 - best way to do that currently where
40:15 - you've got various variations but with
40:19 - common things I haven't actually done
40:22 - that yet there's some interesting ones
40:25 - I think ts spoon was one and a few
40:29 - others but there's also things like
40:32 - babel prevail where if you just have
40:35 - some code that you want to use to
40:38 - generate other code on build enable that
40:41 - quite easily but I haven't actually
40:42 - dived into that yet it just looks really
40:45 - exciting

Cleaned transcript:

while Luke John was a developer at seven West media he led the adoption of CSS in jeaious at the West Australian and at Perth now and he's also a leading contributor to the CSS in J's framework glamorous he's going to tell us all about using CSS nsj we have type systems like typescript or flow with typesafe CSS and J yes please welcome look okay so as you just heard I'm here today to talk about type safety and CSS and Jas both of which are very shiny quite new and a really fun to work with so just a bit of background around how we got to type safety and CSS and Jas we've had this massive rise of Jas everywhere we've got frameworks like react and angular and as those frameworks got bigger and more mature we've started to see type systems from the likes of Facebook and Microsoft where you'll have some level of type safety with your JavaScript and that language will just compile to JavaScript and it helps make those large code bases a bit more marine table and flexible for a future usage so on the CSS nsj side of things we should probably start with what CSS outside JSS with these modern frameworks where you're doing component based development your markup is a function of state it's quite easy to understand based on this URL and flowing through your JSX if you're using react exactly what markup you're going to be getting when it comes to styling side of things it's a bit more of an unknown a lot of frameworks we'll be having will be important perhaps for different CSS external files then they might be using webpack loaders for sass to have some level of component based styling but the CSS is not necessarily determinable based on just state CSS in jeaious both your markup and your styling is a function of your state and so based on a URL or a user being logged in you can work out exactly what styles and only those styles are actually created for the page so it enables pattern things like critical CSS and really helps out if you're doing serverside rendering to only shoot down the CSS which is needed for any particular page so it's really awesome so as we started there before a lot of this talk is going to be using react however CSS in jeaious exists with a bunch of the other frameworks now but when you add type safety to something like react and CSS nsj you start to live in the happily ever after where things are really shiny and you won't enjoy coding all the things and so we'll just start with where CSS nsj started the term was first popularized by inline styles in react where as you're doing your templating inside your JSX there there's a style property available which you can just add some inline Styles those will get added in line in your resulting HTML markup but then later on other frameworks saw that pattern thought this is really awesome and they created some other handy helpers that would extract all of that and put it into your head or do other things but the basic pattern was very similar and this example here is actually got it turned on with typescript we'll just have a look at the Taipings for where we started with type safety in CSS and jeaious they just typed a subset of CSS properties for some of them they had pretty strong type safeties so this aligned content property here you'll get autocomplete on the key and the value and if you do a misspelling which is quite common in CSS you'll get immediate feedback about that unfortunately there's a lot of CSS properties that allow quite flexible values border 10px solid red you can't give types a key for that sort of thing just using this pattern so they're just type two strings so this was the inline Styles popularized by react what was happening in Jay s about the same time is the language was getting new features one particular new features were template literals of which the more advanced version was the tagged template literals and these would allow you to pass template literals with function that's at bottom one that's just grad from MD n n MD end the examples and so people who were doing a lot of react development who had traditionally been putting a lot of work into other solutions for CSS at scale saw this and thought wow we could do some really awesome stuff with this that slide is far too small to see on apologize but essentially you've got a function up the top there that you've set up which would allow users to use a string as an API for writing their CSS within JavaScript and then have expressions within that of course this is a bit of a back step when it comes to type safety for CSS and jeaious because we've gone back to a string interface and you're not going to get a lot of safety there however really popularized the props based styling pattern where you could have functions which you could pass props to so when you're doing component based development pass props in to what was ever creating your CSS and rather than having three different class names that you're going to select form based on those props you could just write the exact CSS in case which was really handy and here's just an example using styled components you get auto complete on the Dom tags of the interface but then once you're inside that tag template you have no real safety but then down below there what you can see is using so that then returns a react component which you can just use inside your JSX see inside your templating and it has the props flowing through quite nicely so then we had glamorous came out earliest last year I think about April and it followed on from some of the api's that had been pioneered by the starred components people but they quite liked the CSS object interface for writing your CSS so they mixed that pattern of having component factories with CSS objects and this was really exciting for where I was working at the time we had been using processes peerreview conventions such as been to protect our code base from bad things happening and this was working for most of the time for our frontend devs with strong CSS knowledge however that wasn't all of us we had people with a range of experience across domains and so bad things were still happening CSS nsj with something quite glamorous which we would be able to type look like it offered some technical solutions to the problems we were having so the initial typings somebody was obviously using it on a project they'd ridden some typeins internally and they went to contribute that back to the community what had been happening a lot at that time was people would put the tie pins on definitely typed and just sort of which is a it's a repo set up by Microsoft which makes all the types of ailable to install but about this time people were starting to bundle definitions with the frame so somebody thought oh yeah I'll try and get those landed there the person who led the development of it wasn't quite sure about it but the feedback he got and it's quite surely is that it's a lot better for consumers when you have bundle typed it implies that the project is type friendly B those bundle types flow or type script and when you change or add something you can expect a PR shortly to add type support for that and a bunch of other things it does however lead to a bit of extra contributor overhead because you've got more activity going on so those initial definitions they just covered a small subset about the of the API of glamorous and there was also a clear expectation set around how those types would be maintained it would be up to typescript users to maintain those which was everybody accepted and was great what was also very helpful was the project had very clear contribution guidelines this provided clear guidance for the initial PR to add them but also for anybody who wanted to extend the Taipings or add additional features it was very clear how they could add those features and get them landed so if you're adding types to a framework highly recommend having contribution guidelines well laid out so initially it was set up with the types separated out into a toppings folder which is a fairly standard thing with in typescript definitions and also flow ones and then there's just a field you put in your package jason with a the location of where the toppings are for when typescript does type acquisition on usage and it also just had a simple test file the way testing works for a lot of typescript definitions is that they just have a single file that just goes to all the uses that the types provide and make sure that the compiler doesn't generate any error output and as you can imagine there's some problems with that but we'll touch on that in a bit and so sorry so showing up there fantastic so this is just some of the api's that glamorous had to give an idea as we jump into the Tri Keynes that it has what sort of support it needed and the range of types so we just start with some glamorous dom and builtin component factories the second signature their glamorous talk gives just a short cut to the first one it also had builtin components so you could just import a div from glamorous name name sized exports and also glamorous octave would work as well this actually presented a bit of challenge for typescript because there's no easy way to share named exports with interfaces for typing so there was a fair bit of type ii plication also with the glamorous stock dev for the other built in component factories then glamorous could also take components when you set up a component factory so that needed to be typed and it also had options which would then change the behavior of the resulting component so if you set that props are CSS overrides this equal to true when you finally use that component you then have available all of the CSS properties as props on that component which will get added up into the CSS and then there's also with component api which you can change what component the eventuated clamorous component factory returns so a huge api service with things at the top level impacting things a few levels down which was quite interesting so in terms of type coverage we'll just touch on initially the CSS and SVG properties so we'll start with the these were very similar to the react typings initially we just used to react to CSS property typings then we had a great PR from a contributor who vendored those but then went through property by property and checking the MDM doc tation and tightening up the types so for some things such as display or float I think where the reactor eye pins for would just accept any string it was tightened up a bit so for the autocomplete it was really helpful and for misspellings it would avoid that then we just also need to support the pseudo properties so that's how you would use that and then when you're using that anywhere where it's being typed you're going to get type safety which is really handy you also get autocomplete it's quite wonderful then we had a lossy version of the CSS properties the way that a lot of the CSS and J's frameworks work with their CSS objects is they support something similar to sass and other things where you can have contextual selectors but also just for media queries where you have another object underneath it because of this particular type index that would be getting added onto it it meant that for the previous CSS objects you actually lose type safety so whilst if you've typed float correctly get type safety on the properties in order to complete if you accidentally type flat it's going to pass which is a bit sad there are some other alternative CSS and J's frameworks that have alternative syntax for this sort of stuff they're not quite as widely adopted or and but should be interesting in the future and so then just using it all together it's kind of like CSS it's just using an object J object syntax it all fits together quite well so those are just some examples so style arguments these are the things that when we saw earlier on the glamorous API you would set up a component Factory with either a Dom tag or a component these are the arguments that you then pass to that to create your CSS it can take a function which would return some properties or a string or also an array of properties and strings it would also accept a style array so ray of all of those things and then a style argument sort of a combination of those plus a couple of other signatures that I've just taken out of that for brevity's sake but then for the style arguments that's for dynamic styles and you can see their props are getting passed to us and generic so that they're available in the style functions a lot of the time when you do in CSS in j/s you won't actually use props flowing through and so there's also a simpler static style argument which also helps out with the compiler output if something goes wrong it's a bit simpler in those cases it's been easier to read and so here's an example of how those types are then checked on a component so here that will pass because it's a CSS properties object and the values are correct here this would pass because it's a function having actually typed this but it the props if I had a typed on the example component would be type two something and then you can use that in determining the output of the display here it would pass because it's going to return a string here would pass because it's going to return an array of all those things so quite a lot of different things you could do with star arguments Oh with support and so we'll next look at just a single one of the glamorous API shapes that we saw earlier where you pass a component factory to the glamorous function which will return you a glamorous component Factory so this is a heavily trimmed down version of the types so we start with the main export from the definitions which is this glamorous interface then the glamorous interface this looks really noisy and messy essentially it's just a object which takes a component with some optional objects and returns a glamorous component factories we've had to use a lot of generics here because of all the different changes that happen downstream in that glamorous can Factory and then the resulting Columbus component that is created from that in order to get type safety there but you don't actually have to pass any of those generics all the time most of the time if you're doing something dynamic with that component you'll just pass the props and the rest will just all match together if you've typed it on that component which is really nice we use overloading with this signature because depending on the options that you pass in again the signature of the so dish the API of the resulting glamorous component is quite different it will accept if you've set the props or CSS overrides options to true a bit down you can just use those props and so they need to be typed as well so that's the initial creation then we get into the actual component factory so that returns the component factory component factories just take those generic crops and initially we start with a overload for the static styles we put that at the top because even though it should match down the bottom as well so the next two we'll see there was a bit of a memory leak issue with typescript and this just has CSS properties as arguments pretty much you can't do any functions or anything in there then we have an overload for a few props have got a theme so there's a concept of a theme provider and glamorous which I won't go into but essentially there's some magical props that can end up on that component and be available for whilst you do in your styling and we also use as part of this so we say that when they set up the props for the component Factory so for those functions that we turn the styles the themes going to be available but then when they we actually return the glamorous component from this all those props that are there they need to be set up but the theme doesn't type script doesn't have subtraction types and it kind of gives something similar but it does actually pollute the intellisense and compiler output so I would recommend avoiding where possible and then finally we just have a overload for the component factory where there's just that props no theme which is quite handy and it just keeps the types of it's simpler and then finally the component factory to returns a glamorous component which is just a react component factory with various external props and extra glamorous props so the external props in some case will just be the props sometimes it will be the CSS properties if we had offset that props or CSS overrides earlier on and then it also has some methods available on it such as with component which we saw earlier which will let you have all the props and all the type in but for a slightly different component which is this one here and there's a couple of other ones there so what was getting typing typed initially it started off with just a very small subset of what was available in glamorous it was quite understandable easy to use but there was a lot of stuff that you couldn't do then we started to add overloads and generics to provide support for both the alternative interfaces but also the generics to get better type safety on some things that initially that were essentially such as pops just a any so you didn't have that much safety then we introduced the omit type to support the theme being excluded it seems like a really good idea at the time there was probably an alternative syntax that we could have used using an additional generic but this less magical type and had we have used that it would have led to much cleaner compiler output and when users are having errors easy to understand what's going on and then eventually we started having to use overloads coupled with generics which would extend the extend from things so that we could limit this particular generic to this shape and then we'll do this thing and it all got very complicated very fast that was a very small subset in some places there were extra overloads for things like CSS properties versus SVG properties unfortunately a limitation of the compiler typescript compiler at this point in time meant that the intellisense at this point in time meant that if you try and union that there you would just lose autocomplete it would still type but the developer experience would get worse and so pretty massive amount of types as you can imagine things go wrong when you've got such large types and the standard definition strategy of just testing what is meant to work and making sure that the compiler succeeds wasn't really sufficient to allow additional contributors to easily add things and not have to worry about accidentally breaking something else so we introduced some additional testing we just set up a should fail file adjacent to the test file and then we just used just snapshotting to run the compiler on that file as well make sure that everything that we'd set up to fail was ending up in that snapshot and that did pick up quite regularly where people would sort of think oh I can just make this change here and not realize that that would actually knock out something else with one of the other glamorous interfaces so really handy pattern there's some other strategies there now that a little less sort of hacky here we're just using spawn to run the compiler and snapshot it but definitely recommend testing both sides and also just on the testing side of things you'll often find that if you're using glamorous as part of something that else which you're generating definitions from it has subtly different behavior with the compiler so recommend testing in definitions declarations bode with your tests another thing that we did with the types in some places was we did things that weren't strictly necessary but they improved the developer experience in one case if we used a union for type the you would get type safety but when you're using vs code or another editor that's using Intel a sense you would lose autocomplete which was really handy feature and people who aren't using typescript are also getting benefits off it so we would do some sort of happy things it's worthwhile commenting when you do that to make sure that in a couple of months time both flow and typescript moving really rapidly a lot of things this one we found after about two months we could actually just move to a spread under Union and it all worked nicely so worth commenting those things sometimes you need to get a bit creative when you're setting up types as well or using it with the type system we had a fun one where the rollout compilation for glamorous was incompatible with how typescript was doing the importing so we actually added this this to the main glamorous source file just to allow usage with typescript but where you do get creative with things like this again it's really worthwhile adding some comments so that the next person knows what's going on and it's a pretty massive amount of typing there a large surface area with the API there were some pretty massive mistakes that were made which were in most cases quite avoidable a couple of those one we had this issue opened up it was quite an interesting one so there was a memory leak with the Taipings which meant that when you were using that with a project with a lot of glamorous components pretty quickly the compiler would bath and you would get out of memory that was it was interesting because the compiler worked fine with tests and depending on project size and also usage of the types it would just never show up and the way that it part of why it happened was there a bunch of changes the types getting added to a V next branch so nobody was testing them in production all of a sudden V next launched there were all these new types that landed and how they interacted led to this man we liked so it took a few days to sort of work out where that was and get an update going another one was the definitions can sometimes get quite overwhelming this was a very politely worded issue from somebody where they had gone to use the glamorous with typescript and the autocomplete was just out of control as you start to type in the arguments you would get this enormous window pop up with all the different options and it would hijack your arrow keys as to go through the different options so this one was quite well in some ways easily solved went back in and we structured some of the Taipings so that the output for things like Intel he sense but also just compiler output if there's an error was more readable and more clear more concise and yeah so definitely recommend limiting type coverage when you're typing the framework like this if the framework doesn't in tender usage don't type it there were a couple of PRS landed early on that were landed purely to supports and some stuff that had started happening by mistake and was never really intended by the framework or the lead contributors and because that got typed early it's hard to remove type coverage for anything that you've added because people will complain when they do a update and things break for a nonmajor also try to ensure types don't make workflows difficult like you can tell you senses you just saw and should always use comments to help consumers this will win you a lot of love for both typescript and flow in just j/s developers because in things like intellisense for api's that are immediately clear just off the name of that property they get a little bit of actually information about how to use it it's also really important with this sort of thing to enable contributors something really awesome that's happened in the last year is that there's now online play boxes where you can set up a full type script and flow project and import glamorous and have the sort of definitions being used as you're typing online and getting error output in browser so setting up a sandbox for people who are having issues to be able to quickly set up a reproduction along with the issue rather than having us set up a whole repo and it's really handy and also just obvious things like asking for the version of typescript they're using if they are having an issue with the bundle declarations is really handy so we'll now just have a quick look at how you use the CSS MJS which i've script and so here we have a glamorous component factory with styles where we're getting autocomplete on both the property name and then the values that it accepts really handy really useful we'll jump straight from that to this is something we're going to now create with CSS nsj and typescript so it's a reproduction of the LCA schedule where the it starts at a calendar then just collapse down to a talk by talk by talk and gives us some really clean HTML without lots of wrapping divs or reused CSS or anything like that so we'll start with a timetable react component which if we jump into that and have a look at that's just a glamorous emotion component Factory another CSS nsj framework we've got our CSS being returned from this we're going to use the CSS grid we're able to use the props that that's being typed with which has a number of active rooms to set up the amount of columns that we want on that so then if we jump back to the time table inside of that time table we're going to have time starts which is just going to show up on the left hand side as we saw and pass that through the information it needs to do that and it's just another react component which then has the time start h3 and then that's going to use the props to set up the CSS to put it in there collect correct row which is nice and handy there and the correct column as well then we'll jump on to the slot so that's the actual talks as we go through they're going to have a use another component we'll just have a look at the styled slot we won't go through all of it that takes a bunch of props which go into the styling again I've collapsed this so it doesn't include all the stylings required but it's going to grab the using the room index it's going to run another method which gets room colored that just takes a CSS color value and adjusts the hue left and right so that we get the nice colors going along and we can have sort of infinite amount of rooms or just a few and then it's going to select the column and the amount of rows that talk should span based on its twine start and it's time offset so as we've been going through here only the CSS that is absolutely required for each of these slots is being generated in cases where the CSS is in common it will dilute those Styles automatically for that use so there's no need for by handy chipping it will be producing a really nice clean markup there's no need for wrapping divs to sort of enable this kind of nice visual structure and it's really really easy and fast so this whole thing took about 20 minutes to get running which normally with CSS would take an enormous what might take a bit longer to get all of those grids and calls if you weren't doing it inside of j/s and being able to use those patterns so just have a look at the future of CSS MJS and some of the things that type script and flow enabling and the first one this is very limited to typescript in particular there's this really cool thing called typescript server plugins which gives you that string api for CSS that we talked about earlier on when that first came around there's no way to type a string these server plugins actually allow you to create your own sort of type safety for certain things and give autocomplete in editors using intellisense and whatnot so here we're actually getting type safe CSS strings in j/s which is really powerful and I think very exciting for the future there's also some plays around how you generate types at the moment for glamorous as you saw there was the glamorous dev Col glamorous with the div string there was the export so import did from glamorous there was the glamorous dot uppercase div which are all doing fairly similar stuff and using the same sets of types but they have to be typed separately and so we've generated typings you can sort of automate some of that which both makes it a bit easier for contributors when they want to make a change to some of those big files they can just make it in one place but also gives you a bit more confidence in the definitions because as it is there's a fair bit of copy pasting these are just for the different files each of which are a couple of hundred lines long another really exciting thing regex try there's a PR open on the typescript repository at the moment it's probably not going to land for a couple of major couple of versions but it's been actively discussed by the typescript team and looks really exciting not just for CSS in jeaious but a whole range of other applications and so this isn't actually necessary this isn't anything to do with typescript and CSS in jeaious this is just really cool things you can do CSS and j/s because it's so shiny you can do CSS snapshotting alongside your markup for your components so if you have things go wrong it's easier to pick up in peer review and also just whilst you're developing traditionally your Yui snapshots might contain a couple of class names which you may or may not have set and really no information about the style rules but this sort of opens up a lot more confidence it does generate very noisy tests however which brings us to visual snapshots we're on a unit level it's really easy when you're using something like CSS in j/s to test that that component is pixel perfect for changes so what you can see here and isn't working is actually you'd never see that if you were just looking at it in PR by running the code but here on the bottom one something it's just a couple of pixels off and you pick that stuff up immediately it's really really amazing so just summarize some of the points we've touched on type systems really help keep code maintainable and really help enable growth of applications when you think about CSS in G is a really nice way to think about it is it's turning it's adding the styling to be a function of the state in addition to your markup you can do inline Styles you can have styles throw an app into your head you can do both string an object as an API and you've now got type safety with both of them thanks to things like the server plugins the component factories really enable you as a developer with component based dev to have props impact your styling in terms of when you're actually setting up definitions and declarations for frameworks developers love them it's useful if you keep the type simple it both helps the users and also helps people who want to contribute be able to contribute and should test types fail as well as succeed it sounds really obvious but within the typescript and also flow communities the way that testing is happening currently that is not as common as it should be you can type a lot more than you think but you probably shouldn't it'll just make it harder for people to use the types and contribute to them in the future compilers aren't perfect but there's lots of ways to work around them and yeah types should enable users and not overwhel them if you're interested in CSS MJS there's a excellent repo on github CSS in Jas 101 I highly recommend checking it out it has a thorough overview of all the different options that are out there currently how you would use them and the advantages of the various options these are also some great people to follow on Twitter Basara in particular when it comes to typescript he wrote a CSS and J's framework with just typescript and is really excellent and all of the other ones Kent Dodds is the creator of glamorous and the other people out there have created other CSS and J's frameworks really awesome people and thank you very much and that is CSS and J's and type safety and I think we've just got a little bit of time for questions that thing that's yep so which generates I think the question was we've generated tycoons what's the best way to do that currently where you've got various variations but with common things I haven't actually done that yet there's some interesting ones I think ts spoon was one and a few others but there's also things like babel prevail where if you just have some code that you want to use to generate other code on build enable that quite easily but I haven't actually dived into that yet it just looks really exciting
