With timestamps:

00:00 - In this course, I'm going to be teaching you
everything you need to know to get started
00:03 - writing programs in Ruby. And Ruby is an extremely
popular programming language. And it's also
00:09 - the programming language behind one of the
most popular web development frameworks called
00:13 - Ruby on Rails. So if you're somebody who's
looking to get into Ruby on Rails, or you
00:17 - just want to learn more about Ruby, and come
to the right place, in this course, I'm gonna
00:21 - be showing you everything you need to know
to get started. So we're going to start off
00:24 - with the basics like installing Ruby, getting
Ruby set up with a text editor and executing
00:30 - your first Ruby program. And we're going to
look at, you know, some of the bare basics,
00:33 - things like variables, we're going to look
at dealing with different types of data, storing
00:38 - data, we're gonna learn things like if statements
and loops, and then we're going to get into
00:42 - more advanced stuff. So we're going to talk
about the ins and outs of object oriented
00:47 - programming, we're going to talk about things
like classes and objects. And all throughout
00:51 - this course, we're going to be using real
world examples. So I'm going to be showing
00:54 - you guys different, you know, mini applications
that you can build, we're gonna build a couple
00:58 - different games, we'll build like a calculator,
we can do all sorts of stuff. So not only
01:03 - are we going to be learning Ruby, but I'm
going to be showing you guys how to apply
01:06 - it in a bunch of different situations. So
I'm excited for you guys to come along. In
01:10 - this course, I'm covering just about every
major topic in Ruby. So by the end of the
01:15 - course, you should have a pretty solid understanding
of what this language is about what it can
01:19 - do and what you can do with it. In this tutorial,
I'm going to show you how to install Ruby
01:28 - on Windows, it's actually a pretty easy process.
Essentially, all we have to do is use a Ruby
01:34 - installer that we can download from like Ruby's
official website. And it'll basically walk
01:38 - us through all the installation instructions.
So I'm over here on this website, it's Ruby
01:43 - installer.org, forward slash downloads. And
this has basically a Windows downloader that
01:49 - we can use. So you'll see down here, there's
a bunch of different options, I'm going to
01:53 - be installing the latest version at the current
time, which is Ruby 2.4. Just a quick disclaimer,
02:00 - the instructions in this video aren't going
to work for Ruby versions below 2.4. So below
02:05 - 2.4, there's actually a different way that
you can install it, but after 2.4 and above,
02:11 - then you can follow these instructions. So
I'm just gonna click this and it should start
02:14 - downloading. When the download has finished.
Now all we have to do is run that program.
02:18 - So I'm going to go over to my downloads folder,
and you'll see we have this Ruby installer,
02:23 - let's double click that, and it should open
up a window that we can work with. Alright,
02:27 - so I'm just going to click through all the
options on this window, I'll accept the license.
02:33 - And now Ruby should start installing on our
computer. Alright, when the installer finishes
02:38 - running, all we have to do now is install
one more thing. So you'll see over here, there's
02:42 - a checkbox that says run our idk install,
you want to make sure this is checked. And
02:47 - I'm just going to click Finish. So this should
actually open up another window here, it just
02:51 - says Ruby installer too. And you'll see over
here that there's three options. So the first
02:57 - one says ms y s to base installation. Second
one says system update. And then here it says
03:02 - ms wise to mA n GW development toolchain.
Just for the purposes of being thorough, we're
03:08 - going to go ahead and install MSI as to and
the m i n GW development tool chain. And I
03:14 - found doing this, it's best to just enter
all these options in order. Sometimes when
03:20 - you enter just three, then you get an error
because certain things aren't updated. So
03:24 - I'm going to go ahead and enter in one and
then after that's done two and then three.
03:29 - And if we do that, then everything should
be able to be downloaded correctly. So I'm
03:34 - just going to click one and we'll go ahead
and run this. When that's done running, then
03:38 - we can just click to and we'll run that. And
this is going to go ahead and update everything
03:45 - that we just installed. And finally, I just
want to click this third option. So I'm going
03:50 - to type in three, and we'll run that. Alright,
once you've run all three of those installers,
03:56 - then we're officially done with installing
Ruby on our computer. The last thing I want
04:00 - to do is just check to make sure that everything
got installed correctly. So I'm going to go
04:04 - down here, and inside of my search bar, I'm
just going to type in cmd. So I'm just going
04:09 - to type cmd. And this option for the command
prompt should come up. So you just want to
04:13 - click that. The command prompt is basically
just a way that we can interact with the computer
04:18 - by giving it text commands. And we can go
inside here to check to see what version of
04:23 - Ruby we have installed. So essentially, what
I want to do is just type in Ruby hyphen,
04:28 - V. And when I click enter, this should tell
me the version of Ruby that I currently have
04:33 - on my computer. As long as you're getting
a version with the Ruby hyphen v command,
04:39 - then you have Ruby installed on your computer,
and you're ready to start writing some awesome
04:43 - programs. And this tutorial, I'm going to
talk to you about installing Ruby on OSX.
04:52 - Now one of the great things about OSX is it
actually comes pre installed with Ruby. So
04:58 - basically you don't actually need to install
it, you should just already have it. But I
05:03 - just wanted to talk about in this video, like
how we can check to make sure that we have
05:07 - Ruby. And then I'll also talk a little bit
about updating the version of Ruby that you
05:11 - have on your computer. So, first thing I want
to do is come up here to the search bar. And
05:16 - I'm just going to type in Terminal. And basically,
this will open up the terminal. The terminal
05:21 - is essentially just a program that allows
us to interact with the computer by using
05:26 - text commands. So inside of the terminal,
I just want to check to make sure that everything
05:30 - is installed with Ruby. So I'm just going
to type out Ruby hyphen, V. And this should
05:37 - spit out a version number of Ruby. In my case,
I have Ruby version 2.4. Point two. So as
05:43 - long as you're getting a Ruby version number
that's getting printed out onto the screen,
05:48 - then you're good to go. And for the most part,
if you're running OSX, you should have some
05:52 - version of Ruby installed on your computer.
If you'd like to update this version, though,
05:57 - for example, if you have maybe an outdated
version of Ruby, I would recommend using a
06:02 - program called the Ruby version manager. I'm
not going to get too into using the Ruby version
06:07 - manager here. But I just wanted to bring it
up so that if you are running an outdated
06:11 - version of Ruby, then you'll know kind of
what to look for in order to update it. So
06:16 - something called the Ruby version manager
and it's basically a program that you can
06:19 - use to update the current version of Ruby
that you have on your computer. So if you're
06:25 - trying to update your current version of Ruby,
then use the Ruby version manager. But otherwise,
06:29 - you can basically just use whatever Ruby version
that you have installed on OSX in order to
06:35 - follow along with this course. In this tutorial,
I'm going to talk to you guys about getting
06:43 - a text editor for Ruby. And then we're also
going to look at how we can write our first
06:49 - Ruby program and run our Ruby programs from
the text editor that we download. And one
06:54 - of the cool things about Ruby is you can basically
write Ruby code in any text editor you want.
06:59 - So you can use something simple like Notepad
or TextEdit. Or you could use like a dedicated
07:04 - environment that was built just for writing
Ruby. In our purposes. For this course, I'm
07:09 - going to be using a special text editor called
Adam. And this is basically a text editor.
07:15 - But it's been designed to support Ruby. And
so it's going to be an awesome environment
07:20 - where we can write our Ruby code. So I'm going
to show you guys how to install Adam, we're
07:24 - going to talk about setting it up and getting
it ready to go. But just a quick disclaimer,
07:29 - like you don't have to use Adam, if you don't
want, that's what I'm gonna be using for this
07:32 - course. But like I said, you can basically
use any text editor that you want to write
07:37 - your Ruby programs. So let's go ahead and
install Adam, I'm going to come down here
07:40 - to my web browser. And up here in the URL
bar, I just want to type in atom.io. And this
07:48 - is the official website for the atom text
editor. What this should do is it should bring
07:54 - you to a page for your operating system. So
in my case, I'm on a Mac, so it gives me this
07:58 - download for Mac option. If you're on a Windows
machine, then it'll give you a download for
08:03 - Windows option. I'm just going to click this
and we'll go ahead and download Adam. When
08:07 - Adam has finished downloading, I'm just going
to go into my downloads folder. And I'll just
08:11 - go ahead and double click on this Adam Mac
dot zip file. And if you're on Windows, you
08:15 - might have to go through an installer process.
If you're on Mac though, now you basically
08:20 - have Adam over here. So you just move it into
your Applications folder, and you'll be able
08:25 - to start using it. So I already have Adam
installed on my computer. So I'm going to
08:29 - go ahead and open it up. And once we have
Adam open, there's a bunch of different stuff
08:38 - that we can do. One thing you might want to
do when you first get into atom is go down
08:42 - here into preferences or settings. And over
here, you can configure a bunch of stuff.
08:47 - So you'll see over here on the side, we have
an option for like editor, you can also configure
08:53 - like a theme. So you know you can change like
what the text editor is going to look like.
08:58 - You can do a bunch of stuff over here just
to kind of configure out them to your liking.
09:03 - In order to be running Ruby programs on here,
we're actually going to have to install one
09:07 - thing, which is a package. So over here on
the Settings page, I'm just going to go over
09:12 - here to this install button. And inside of
here, we want to search for a program it's
09:18 - just going to be called Adam hyphen runner.
And essentially what this plugin is going
09:24 - to allow us to do is it's going to allow us
to run our Ruby scripts or our Ruby programs
09:29 - from inside atom, it's going to make it really
easy for us to do this. So you'll see right
09:34 - here, it's just atom runner, and I've actually
already installed it, but over here there
09:38 - should be an install button just like you
see down here. So click the Install button
09:42 - on atom runner. And once that's installed,
then we have everything we need to start programming
09:48 - Ruby from inside here. So now that we have
Adam runner installed, I'm going to show you
09:54 - guys how to set up your first Ruby file. So
the first thing I'm going to do is come over
09:58 - here to file I'm actually going to add a project
folder. So I'm just gonna click Add project
10:03 - folder. And I'm just going to add my Documents
folder because this is a folder that I'm going
10:08 - to be working with throughout the course.
And I'll just click open, you'll see over
10:12 - here, now we have this little like file explorer
window. So that can actually be pretty useful
10:17 - just so we can see like, what the different
files are that we're working with. So inside
10:22 - this Documents folder, I'm actually just going
to click right click, and I'm going to say
10:25 - new file. And I'm going to go ahead and create
a new file. And I'm just going to call this
10:30 - file draft.rb. So whenever we're creating
a Ruby file, we want to use this.rb extension.
10:38 - And that's basically going to tell our computer
that this is going to be a Ruby program. And
10:42 - you can name it whatever you want. I'm just
naming it draft. So I'm gonna click Enter.
10:46 - And now we have our first Ruby file up and
running. So what I want to do now is just
10:51 - write a simple line of Ruby code inside of
here, we'll test it out, we'll make sure everything's
10:56 - working. And that way we know we have our
environment set up to go for the rest of the
11:00 - course. So over here, I'm just going to type
print. And I'm going to type an open and closed
11:06 - quotation marks. And I'm just going to type
hello world. And I'm just going to go ahead
11:11 - and save that. So just print this out. And
basically what this does is it just prints
11:14 - a line of text out onto the screen. So now
what we want to do is use that atom runner
11:20 - plugin. So remember, we installed that atom
runner plugin before. And now I can actually
11:25 - use that to execute this Ruby code. So I'm
just going to click Ctrl N r, so Ctrl R, and
11:33 - you'll see this is going to go ahead and run
our program. So down here at the bottom of
11:37 - the screen, I actually have this little output
window. And you'll see down here that it's
11:41 - printed out hello world. So it's gone ahead
and printed out hello world onto the screen.
11:46 - So as long as that's working as long as the
ctrl r was able to run that atom runner package,
11:52 - and were able to execute the Ruby code, then
everything set up, we're ready to start going
11:56 - in this course and ready to start writing
some awesome Ruby code. In this tutorial,
12:05 - I'm going to talk to you guys about the basics
of Ruby programs. So we're going to write
12:10 - a very simple Ruby program, we're going to
talk about how those programs get executed
12:14 - the order in which the instructions in those
programs get executed. We're also going to
12:19 - talk about different ways that we can print
things out onto the screen, this is going
12:23 - to be a pretty awesome tutorial, I'm really
excited. First thing I want to show you guys
12:27 - is how to print something out onto the screen.
So you'll notice over here I have my little
12:32 - atom runner output window. And in the last
tutorial, we talked about setting up this
12:37 - basic environment. So what I want to do is
show you guys how to print something out onto
12:42 - this little console window over here. So all
we have to do to print something out is just
12:47 - type print a space. And then if you want to
print out like plain text, we can just make
12:53 - an open and close quotation marks. And we
can put any text we want. So I could put like
12:57 - draft Academy here. And now what I run this
program by clicking Ctrl R, you'll see that
13:03 - draft Academy gets printed out onto the screen
over here. There's also another way that we
13:09 - can print something out onto the screen. So
in addition to just saying print, I can also
13:13 - say puts and puts basically works the same
way as print, it's going to take whatever
13:19 - we put inside of these quotation marks, and
it's going to print it out onto the screen.
13:24 - So for example, I can type my name like Mike.
And now this is going to get printed out onto
13:29 - the screen over here. Now you'll notice that
draft Academy and Mike are getting printed
13:33 - out right next to each other. And this actually
brings me to the first thing I want to talk
13:37 - about, which is the difference between print
and puts. So you'll notice here I'm using
13:43 - this print command, I'm printing out draft
Academy. And then right below it, I'm printing
13:47 - out Mike using this puts command. And when
I use this print command, Mike just gets printed
13:53 - out right next to draft Academy, as you can
see over here. But if I was to take this puts
13:58 - command and move it up here right above draft
Academy, so now the program is going to execute
14:04 - puts Mike before it executes draft Academy,
what you'll notice is that draft Academy gets
14:10 - printed out on a new line. That's because
whenever you use this puts command, it's going
14:15 - to print out whatever you put over here. And
it's also going to print out a new line afterwards,
14:21 - which basically means that when you use puts,
you can print things out on different lines.
14:26 - When you use print however, everything gets
printed out on the same line. So if I wanted
14:31 - to print out two things right next to each
other, for example, I could print out something
14:34 - over here like is cool. Now these are going
to get printed out right next to each other.
14:40 - So you can see it says draft Academy is cool.
But if I was to do the same thing with puts,
14:46 - for example, if I did another puts down here
and I said is cool. Because I'm using this
14:53 - puts up here, this is actually going to get
printed out onto a new line. So you'll see
14:57 - down here that's exactly what happened. So
That's the two different ways that we can
15:01 - print something out onto the screen using
prints and using puts, again, puts will print
15:06 - out whatever you specify. And then it'll print
out a new line, print will just print out
15:11 - whatever you specify no new line. So that's
the basic difference between those two. So
15:16 - now what I want to do is just to show you
how we can use these print statements to draw
15:21 - a little shape out onto the screen. So over
here, I'm just going to say puts, and I'm
15:26 - going to make an open and close quotation
mark. And I'm actually going to copy this
15:29 - a couple times. So we'll paste this like a
few times down below here, I want to show
15:34 - you guys how we can just draw a basic like
triangle shape. So I'm going to start with
15:38 - a forward slash down here. And I'll make another
forward slash, another one up here. And another
15:44 - one there. And now I'm just going to make
vertical bars going all the way down. And
15:49 - I'm going to make some underscores down here.
And now we have a basic little triangle right
15:56 - here. So you can see I'm using this put statement.
And individually on each one of these lines,
16:01 - I'm printing out some text. So now if I was
to go over here and run my program, you'll
16:07 - notice that we're printing out this triangle.
And it looks pretty good. So this is sort
16:11 - of the basics of drawing something out onto
the screen, I also want to talk to you guys
16:16 - about how these programs get executed. So
when we run our Ruby program or our Ruby script,
16:25 - basically what happens is Ruby is going to
go through, and it's going to look at each
16:29 - line individually inside of this script, it's
going to start with the first line here. So
16:33 - it's gonna say, Okay, the first instruction
that the user wants me to do is print this
16:38 - line of text out onto the screen. So Ruby
is going to look at this first instruction,
16:43 - it's going to execute it. And then once it's
done with this instruction, it's going to
16:47 - move on to the next instruction that's moving
on to the next line. And it's going to go
16:51 - ahead and execute this instruction. And then
when it's done with this one, it's going to
16:55 - move on to the next line and the next line,
etc. So Ruby is looking through each instruction
17:01 - that we give it inside of our program. And
an instruction in Ruby is just something like
17:05 - this, it's like this puts or that print that
we saw before, there's tons of these different
17:10 - instructions that we can give Ruby. But the
point is, is that Ruby is going to execute
17:14 - them in the order that we write them. So Ruby
is going to start with this line move on to
17:19 - this line, etc. So if I was to take this bottom
line here, and move it up here to the top,
17:25 - now it's going to execute this line of code
first. So you'll see over here, we get this
17:30 - like funky looking shape. So that's sort of
like the bare basics of how Ruby is working,
17:35 - we're giving it sets of instructions, right,
I'm just writing out a bunch of different
17:39 - instructions, and Ruby's going to execute
them in order. And it's going to do essentially
17:44 - whatever we tell it to do. So right now all
we're doing is telling Ruby to print something
17:48 - out onto the screen. But as we learn more
about Ruby, and as we go forward, and we learn
17:53 - more instructions that we can give it, we
can actually make programs to do just about
17:58 - anything. So as long as you can specify specific
enough instructions for the computer, you
18:04 - can do anything inside of a programming language.
And that's kind of like the core concept that
18:08 - I want to give you today, which is how these
programs are structured and how to write essentially
18:13 - a basic program that prints a shape out onto
the screen. In this tutorial, I want to talk
18:21 - to you guys about using variables in Ruby.
Now in Ruby, you're going to be dealing with
18:26 - a lot of different data. And generally anytime
you run a program, there's going to be all
18:31 - sorts of data that you want to maintain and
manage. And a lot of times when you're dealing
18:36 - with large amounts of data, it can be difficult
to manage, it can be difficult to keep track
18:40 - of it. So in Ruby, we have a special container,
where we can store data values called a variable,
18:47 - and a variable those pretty awesome because
we can actually take a piece of data or a
18:52 - piece of information in our Ruby programs,
we can store it inside of a variable. And
18:57 - then whenever we want to use that piece of
data or access it or modify it, we can just
19:02 - refer to its variable container. And you'll
see in this tutorial why variables can be
19:08 - really useful. So let's go ahead and jump
in down here I have a basic Ruby program written
19:14 - out. Essentially all it does is it prints
out a story it says There once was a man named
19:18 - George, he was 70 years old. He really liked
the name George, but didn't like being 70.
19:25 - And you'll see I'm just using this puts instruction
over here. And here. It's just printing out
19:31 - the story onto the screen. So we're essentially
just printing out everything that's over here
19:35 - onto the screen over here. So this is a pretty
awesome program, right? It works. It's completely
19:40 - valid. But let's say that I wanted to go inside
of my little story here and start modifying
19:46 - some of the information right, let's say that
I wanted to change the character's name. So
19:50 - maybe I don't like the name George and I want
to change his name to john. So I'm gonna have
19:55 - to go through and I found that first place
where the character's name was and I'm the
19:59 - keeps her Through and then Okay, here's another
place where we have the characters name. So
20:04 - I'm gonna change it. So now I've officially
changed the character's name in the story.
20:09 - Let's say that I'm reading over the story
again, and I'm thinking to myself, Hmm, I
20:12 - think we can make the character a little bit
younger. So instead of 70, why don't we make
20:16 - him 35? Right. So again, I'm gonna have to
look through this entire program. Alright,
20:22 - found the first 70. So I'll change this to
35, I have to keep looking through. And okay,
20:28 - here's the other 70. So we'll change this
to 35. Alright, so now updated the name and
20:33 - the age. But here's the problem. What I wanted
to change the character's name and the character's
20:38 - age, I had to manually go into my program
into the story, and modify each value. So
20:46 - every place where the character's name was
mentioned, I had to update it to the new name,
20:50 - every place where the character's age was
mentioned, I had to go in and update it. And
20:54 - this is kind of a problem, right? This is
a situation where we have two pieces of data,
20:59 - the character's name and the character's age.
And we're trying to keep track of that information,
21:03 - right. But imagine that instead of just having
a story, that was four lines, I had a story
21:08 - that was hundreds of lines long, right, and
they mentioned the character's name, you know,
21:12 - hundreds of times, if I wanted to then go
through and change my character's name and
21:17 - my story, it would be a real drag, right,
I would have to look through hundreds of lines
21:21 - of code. In order to do that same goes for
the age. And this is actually where variables
21:27 - come in. So this is a perfect example of a
time where we have two pieces of information
21:32 - the name and age, and we want to be able to
keep track of them and maintain them a lot
21:37 - better than we currently are. So what I can
actually do is I can create a container, and
21:43 - I can put the character's name inside of its
own container, I can put the character's age
21:47 - inside of its own container. And then when
I want to access that information and use
21:52 - it, I can just access that container. And
that container is called a variable. So I'm
21:57 - going to show you guys how we can use variables
to seriously increase the usability of this
22:02 - program. So up here, up above these puts lines,
I'm actually going to create a variable. And
22:09 - whenever we create a variable, we need to
give Ruby some information. The first piece
22:14 - of information we need to give Ruby is the
name of the variable that we want to create.
22:19 - So generally, when we create a container to
put information in inside of our programs,
22:23 - we'd like to give it a descriptive name, right?
Generally, you want to give the container,
22:28 - a name that will identify what information
is inside of it. So the first thing I'm going
22:33 - to go do over here is type in the name of
the variable that I want to create. So I'm
22:36 - going to create one called character name.
And generally in Ruby, if you're creating
22:42 - a variable, you want to give it a descriptive
name. And if there's going to be multiple
22:46 - words like character name, you want to separate
them with an underscore. So the next thing
22:51 - I have to do is tell Ruby what I want to store
inside of this variable. So I can just say
22:56 - character name, and I can use this equal sign,
and I can set it equal to a value. So I can
23:01 - say character name equals, and I'm just gonna
say, john, because this is going to be the
23:06 - new characters name. So now I've officially
created a variable called the character name,
23:13 - the next thing we can do is create another
variable to store the character's age. So
23:17 - I'm going to do the same thing, I'm just gonna
say, character age. And I'm going to set this
23:22 - equal to 35. So now we have two variables,
both of which are storing values. So down
23:31 - here in my program, what I can actually do,
instead of just typing out the character's
23:36 - name like this, you know, manually, I can
actually just refer to the variable that is
23:42 - storing the characters name. So over here,
instead of saying There once was a man named
23:46 - john, I can actually just get rid of this.
And outside of these quotation marks, I'm
23:53 - actually going to make a plus sign. And now
I'm going to type out the name of the variable
23:58 - that I want to put in here. So I'm just gonna
say, character underscore name, essentially,
24:04 - what I'm doing is I'm saying I want to type
out all of this text over here, plus, I want
24:10 - to type out the value that's inside of the
characters name. So I want to print out the
24:15 - value that's inside this character name variable.
There's one more thing we have to do anytime
24:20 - you're using a string of text like this, and
you're also using a variable name, you need
24:26 - to surround this whole thing with parentheses.
So I'm going to put a parentheses over there.
24:31 - And I'm going to put a parentheses over here.
So now, we'll actually be able to use this
24:37 - program. So let's go ahead and we're going
to run this program. And now you'll see that
24:41 - over here, it still says There once was a
man named john, he was 35 years old, etc.
24:46 - But you'll notice that we didn't have to manually
print like type out the word john. All we
24:53 - had to do was refer to the actual variable
name, character name. So I just refer to this
24:58 - variable and it was a Able to insert the value
that was stored inside that variable inside
25:04 - of our print statement. So I can basically
do this same thing for this guy down here.
25:09 - So I'm just going to copy this. And I'm going
to paste this in down here. So now I'm adding
25:15 - in the character name where john was in that
other spot. So over here, we're also going
25:20 - to have to put another parentheses. And I'm
going to do the same thing for the characters
25:24 - age. So over here, once again, we'll just
surround this with parentheses. And now I'm
25:30 - just going to close off both of these. So
I have two separate little strings of text
25:36 - inside of quotation marks. And I'm going to
put a plus sign, I'm going to type in the
25:41 - variable name, character age. And then I'm
going to put another plus sign. Essentially,
25:46 - what I'm doing is I'm telling Ruby that I
want to print this out, plus, I want to print
25:50 - out the value inside of the character age
variable. Plus, I want to print this out over
25:56 - here. So that's essentially what this is doing.
And we can do the same thing down here. So
26:01 - and again, we're going to need to surround
this with parentheses. So once we've done
26:05 - this, now we've actually set up our program
to use all of these variables. So every place
26:10 - where we mentioned the characters age, we
replaced it with the character age variable,
26:15 - every place where we mentioned the character's
name, we replaced it with the character name
26:18 - variable. So when I run this program, now,
you'll see over here, we get exactly the same
26:23 - output as we did before, we're printing out
the same exact story, the only differences
26:29 - now that we're using variables, our program
is a lot better. So for example, if I wanted
26:34 - to change the characters name inside of my
story, instead of having to go through and
26:39 - manually change it in every single spot where
we mentioned it, I can actually come up here
26:44 - and just modify it. So I could change the
characters named Mike. And now, without having
26:49 - to modify anything else in my entire program,
the characters name is going to be updated
26:54 - to Mike. So you can see now it's using the
name, Mike. And that's really why variables
26:59 - are powerful, because they allow us to organize
and they allow us to keep track of the information
27:04 - and the data inside of our programs a lot
better, the other thing you can do is you
27:09 - can actually modify the value of variables.
So let's say halfway through my story, I wanted
27:15 - the character's name to change, I can actually
come down here, and I'm just going to put
27:19 - this line of code right after these first
two and right before the second two, I can
27:24 - change the value of a variable. So I can say,
character name, and I can just set it equal
27:31 - to something else. So I can set it equal to
Tom, for example. So now when I go and run
27:36 - my program, you'll see that halfway through
the story, the character's name changes. So
27:42 - over here, it's Mike, and then halfway through,
it changes to Tom. So you can update and modify
27:47 - the values of these variables throughout your
program. And that can be extremely useful.
27:54 - So that's sort of the basics of variables.
And these can be really useful, there's a
27:58 - lot more that we can talk about. So for example,
over here, I'm just storing text information,
28:03 - right, I'm storing like, the text Mike, I'm
storing the text 35. Down here, we're using
28:09 - all this text. But in Ruby, we can actually
represent we can store a bunch of different
28:14 - types of data inside of our variables. And
that's what I'm going to be talking about.
28:18 - In the next tutorial, we're going to be talking
about data types. So there's all different
28:22 - types of data types, we can store like text,
data, numbers, true false values, a bunch
28:27 - of different stuff. So stick around for the
next tutorial, and we'll talk about that.
28:35 - In this tutorial, I want to talk to you about
data types in Ruby. But data type is essentially
28:40 - a type of data that we can represent and use
inside of our Ruby programs. And by default,
28:47 - Ruby is going to support a bunch of different
data types. So these are basically just types
28:52 - of information that we can use in our programs.
And I want to talk to you guys about the different
28:56 - types of data that we can use. And we're going
to look at how we can store those different
29:00 - types of data inside of variables. So down
here, I'm actually going to create a couple
29:05 - of different variables. And we're going to
store some different types of information
29:10 - inside of those variables. And the first and
probably most basic type of data that we can
29:15 - represent in our Ruby programs is called a
string. And a string is basically just plain
29:19 - text. So anytime we want to represent plain
text, in our Ruby programs, we can use a string,
29:25 - so I could just make a string called like
name, and I could set it equal to Mike. So
29:31 - this is a good example of a string. It's basically
a variable, and we're storing a string value
29:38 - inside of it. So the string is just like any
plain text, right? You could also make another
29:43 - one occupation and we can set it equal to
like programmer, whatever you can store any
29:48 - like information that you'd want to store
as plain text inside of your programs as a
29:54 - string. We could also store numbers so for
example, I could store a whole number Like
30:00 - if I wanted to specify someone's age, I could
say age is like 75. Right. So someone might
30:05 - be 75 years old, we can represent numbers
like this inside of our Ruby programs. And
30:11 - you'll notice that with a number, I didn't
need to use these quotation marks, I just
30:15 - had to type out the number that I wanted to
type out. You can also use decimal numbers.
30:20 - So this right here, 75 is what will be referred
to as an integer. And an integer is basically
30:27 - just a counting number like 234567. Basically
a number like a whole number. A decimal number
30:33 - is different because a decimal has decimal
points after it. And a lot of times, especially
30:38 - in Ruby, more referred to these numbers as
floating point numbers, basically just means
30:43 - that their decimal numbers, so if I wanted
to specify a floating point number, I could
30:47 - say like GPA, and we can set it equal to like
3.2. Or you can set it equal to 3.2854, or
30:53 - whatever, like you can set it equal to, you
know, whatever decimal point you want to represent
30:58 - inside of Ruby. So using integers and using
floats, you can represent different types
31:02 - of numbers, you can also make these negative,
so I can make this like a negative 75, or
31:07 - a negative 3.2. And Ruby is going to be just
fine with that. In addition to storing numbers,
31:14 - we can also store something called a Boolean.
And a Boolean is basically a true or false
31:20 - data type. So a lot of times in programs,
we're going to want to represent true or false
31:24 - data. And this might not be something that
you're super used to doing in the real world.
31:29 - But in programming, when we're specifying
types of data, a lot of data is going to fall
31:34 - into like the true or false category. For
example, if I created a variable called is
31:39 - male, this variable can tell us whether or
not someone is a male, in which case it's
31:44 - going to be like a true or false value, right?
They're either a male, or they're not, it
31:48 - only has two possible values. So I can set
this equal to true because I'm a guy, you
31:52 - can also create one, you know, it can be like
is tall, and this Boolean variable would tell
31:57 - us whether or not someone's tall, right, so
if you're not tall that it would be false.
32:02 - So a lot of information in our programs can
be represented with one of two values either
32:06 - true or false, we can also store one more
type of information, which is called nil.
32:13 - And the nil data type basically means that
it doesn't have a value. So for example, if
32:17 - I created a variable called like flaws, and
I set it equal to nil, basically, what this
32:23 - means is this flaws variable doesn't have
a value. So we can go out of our way to say
32:29 - that something is nil, like to say that it
has no value. So these are the basic data
32:34 - types in Ruby. And there's actually like a
couple other like more obscure data types
32:39 - that we can use. But for the most part, these
are the data types that you're going to be
32:43 - using as a beginner to the Ruby programming
language. So we can store and represent information
32:49 - in either a text form with a string number
form with an integer, which is a whole number,
32:54 - or a floating point number, which is like
a decimal number. Or we can use true or false
32:59 - values. And we can also use nil, which would
mean no value. So these are sort of the basics.
33:05 - And as we go forward in this Ruby course,
we're gonna be looking at all sorts of ways
33:09 - that we can work with this type of data. And
this tutorial, I want to talk to you guys
33:18 - about working with strings in Ruby. Now strings
are one of the most common data types in Ruby.
33:24 - And for good reason. A lot of times in our
programs, we're going to want to represent
33:28 - and store and work with plain text data. That's
essentially what a string is. So in this tutorial,
33:34 - I want to walk you guys through the basics
of using strings, we're going to look at some
33:38 - different things we can do as strings, we're
going to also look at different things called
33:42 - methods which we can use on string. So a method
is essentially just a little block of code
33:47 - that we can call and it will either modify
our string or give us information about our
33:53 - string, so can be pretty awesome. First thing
I want to do is just show you guys basically
33:57 - how to print out a string so I could say puts,
and over here, to create my string, I just
34:02 - have to put it inside of open and closed quotation
marks. So anything I put inside these quotation
34:07 - marks is going to be considered a string.
So I could just type out like draft Academy.
34:12 - And now this is going to get printed out over
here onto the screen works pretty well. There's
34:16 - a couple things we can do inside of these
strings. So one thing you might be wondering
34:20 - is how can I print out a quotation mark. So
for example, this string is surrounded by
34:25 - quotation marks, we use the quotation marks
to tell Ruby where the string starts and ends.
34:30 - But what if I wanted to use quotation marks
inside of this string? If I just tried to
34:35 - put one right here, you'll see that it messes
everything up and ends the string. In order
34:39 - to use a quotation mark, I can put a backslash,
and then put the quotation mark and this is
34:44 - basically going to tell Ruby, hey, I want
to literally enter in the character quotation
34:48 - mark. I don't want to use it to end off my
string. So now I should be able to print this
34:53 - out. Over here, you'll see we're printing
out a quotation mark. You can also use something
34:57 - similar to print out a new line. So let's
say that I want To print out and draft, and
35:01 - then on a new line print out Academy, I can
type a backslash n. And I'm actually going
35:06 - to get rid of this space. And now you'll see
that this is going to print out draft Academy
35:11 - on two separate lines. So that can be pretty
useful. Another thing we can do is we can
35:15 - store strings inside of variables. So if I
didn't want to just type this out like this,
35:21 - I could put it inside of a variable inside
of a container. And it'll be a little bit
35:25 - easier for me to work with. So why don't we
create a variable called phrase, and I'm just
35:29 - going to set it equal to draft Academy. Now,
if we wanted to print this out, all I have
35:34 - to do is come down here and just type in the
name of the variable that I want to print
35:38 - out. So now we'll just be printing out phrase.
And you'll see we're still printing out draft
35:43 - Academy. So using these variables can be pretty
useful. And when we're working with strings,
35:48 - we can actually use things called string methods,
or sometimes you'll hear people refer to them
35:53 - as string functions. Essentially, what these
are little blocks of code. And we can call
35:59 - these blocks of code. And they'll go off and
they'll either modify our strings will change
36:04 - it in some way, shape, or form. Or they'll
give us information about our strings, these
36:09 - can be really useful. And there's just a few
that I want to show you. And you'll kind of
36:12 - get the hang of how to use these. Whenever
we are going to use one of these methods,
36:16 - we just want to type out either the name of
the variable that storing the string, or just
36:21 - the string itself. And then I want to type
out dot. And now I want to type in the name
36:26 - of the method or function that we want to
access. So I'm going to show you guys a couple
36:30 - that are pretty useful, I found them in them
to be pretty useful. The first is called up
36:34 - case, you're just going to type up case, and
then an open and closed parentheses. And actually,
36:39 - this open and close parentheses in a lot of
situations is going to be optional. But I'm
36:43 - just going to include it just to be super
correct. So when I type phrase.up case, and
36:48 - we run this program, you'll see now it takes
our string, it takes our phrase, and converts
36:53 - it entirely into uppercase letters, you can
also use another one called down case. So
36:58 - instead of saying upper case, we'll just say
down case, and this is going to convert it
37:01 - down to all lowercase letters. So this can
be a pretty useful little function, there's
37:06 - also another one called strip. So if I had
a string that had a bunch of leading and trailing
37:12 - spaces, right, I wouldn't necessarily want
to just print this out. So if I print this
37:17 - out onto my screen, you'll see that we get
it printed out all weird, right? There's these,
37:22 - you know, spaces in front, there's these spaces
after, you can use a method called strips,
37:27 - I'm just going to type out phrase dot strip.
And now when I run my program, all of that
37:33 - leading and trailing whitespace gets deleted.
So a lot of cases when you're dealing with
37:37 - a variable, you might not know if it has leading
and trailing whitespace. So you can use this
37:41 - strip method to make sure that all that disappears,
we can also use these methods to find out
37:47 - information about our strings. For example,
instead of saying strip, I could say phrase
37:51 - dot length, and this is going to tell me how
many characters are inside of this string.
37:56 - So you see over here, we get 24. And actually,
let me get rid of all this whitespace. So
38:00 - now we should get a smaller number 15. So
draft Academy has 15 characters in it, that's
38:05 - including any of the spaces that we put inside
of it. In addition to figuring out how many
38:10 - characters are in a string, I can also figure
out if certain text shows up in my strings.
38:16 - So for example, I could say phrase dot include.
So I'm gonna say include, and now I'm going
38:21 - to type a question mark. And then I'm going
to type a space. And now I'm going to type
38:26 - a string, I'm going to type another string.
Basically, what we're saying is, we're asking
38:31 - this include method whether or not this phrase
includes the string that we're going to put
38:37 - over here. So for example, if I put Academy
right here, this is going to return a true
38:42 - or a false value, telling us whether or not
the word Academy shows up inside of our phrase.
38:48 - So over here, we should get a true value because
Academy does show up. If I was to type out
38:53 - like academies, though. So for example, this
isn't inside of our phrase, it's gonna give
38:58 - me a false value. So that's a really good
way to figure out if a certain string or a
39:03 - certain phrase, or a certain character shows
up in the string that you're working with,
39:08 - we can also access individual characters inside
of these strings. So for example, let's say
39:13 - that I wanted to just figure out what the
first character in the string was. So maybe
39:17 - I was just given this variable phrase, and
I don't know what's inside of it. And I want
39:21 - to figure out what the first character is,
I can type out the string and then I can make
39:26 - an open and closed square bracket. And inside
of the square brackets, I can put the index
39:32 - of the character that I want to access. So
if I wanted to access this G, I can actually
39:38 - put a zero inside of here. So now you'll see
this is just going to print out that G. If
39:43 - I wanted to access this I, I could put a one
in here. And this is going to print out the
39:48 - I if I wanted to access this a for example
I can it was going to be 0123. So I'm going
39:53 - to put a three in here and now we'll be able
to access that a so if you haven't caught
39:59 - on Already, the way that we assign index positions
to strings in Ruby is starting with zero.
40:06 - So if I was going to give these characters
index positions, I would say that g is an
40:11 - index position zero is an index position one,
r two, a three, f four other f5, e6, etc.
40:21 - So whenever we want to access the first character
in a string, we have to access it using index
40:27 - position zero. And this is kind of like a
staple of using strings in Ruby, the first
40:32 - character is always at index position zero.
So essentially, Ruby starts counting at zero.
40:38 - So anytime we want to use this little method
right here, where we're just passing in a
40:42 - number, you always want to start with zero
as the first character. So let's do a little
40:46 - experiment. Let's say I wanted to access this
capital A, it's going to be 012345678. So
40:50 - I put an eight in here, now we're going to
print out that capital A. So play around with
40:58 - these different string indexes. You know,
this is obviously not super difficult to understand.
41:02 - But you want to get used to starting indexes
at zero as you start programming, you can
41:07 - also print out a range of characters. So let's
say I wanted to figure out what the first
41:12 - three characters inside of this string where
I can say zero, I can type a comma. And I
41:18 - can basically specify a range. So I can say
I want to print out or I want to get access
41:22 - to the characters from position index position
zero up to another index position. So we can
41:28 - say zero, let's say we want the first three,
I can say zero, up to 0123. And this is actually
41:35 - going to give me the first three characters,
so it's going to give me 01. And two, and
41:41 - it's actually not going to give me that third
index position character, so I should just
41:45 - get g IR here, you can see that's exactly
what we get. So when we specify a range down
41:51 - here, we start the range at the first index
position zero, and we end it at three, but
41:57 - we don't include the character at index position
three, so we didn't include this a. So that's
42:01 - basically how we can grab like characters
in a specific range inside of the string,
42:05 - you can also use another method, and I'm just
gonna type phrase dot index. And basically
42:11 - what this is going to do is it's going to
tell us what position a specific character
42:16 - in our string starts at. So for example, I
could say phrase dot index, and I can type
42:22 - in like a capital G. And this should give
me a zero, because zero is where our capital
42:28 - G is at, if I typed in like a capital A here,
this should give me the index position where
42:33 - capital H shows up inside of our string. So
it's going to be an eight, you can also type
42:37 - in just a normal string here. So I could say,
like FFP. And this will tell me where FFP
42:42 - starts inside of my string. And it starts
at index position four, so 01234, this index
42:49 - method is actually pretty useful. So these
string methods can be extremely useful when
42:54 - you're working with strings. And they basically
just allow you to take your strings, and you
42:57 - can either modify them, or you can find out
different information about them. And these
43:03 - are going to be very useful. Also just want
to point out that you can use these little
43:07 - methods on things other than just variables.
So for example, if I came down here, I could
43:12 - print out like a string. And I could say dot,
and now I can say like uppercase, and it's
43:18 - still gonna work exactly like it worked when
we use it on that variable. So now when I
43:23 - run this, it'll do exactly the same thing.
So you don't have to have these inside of
43:26 - variables in order to use these different
methods. So those are just a couple of the
43:30 - different methods that you can use with strings
in Ruby, what I would recommend is going on
43:35 - Google and just typing in like Ruby string
methods. And then there should be like, huge
43:39 - list of all the different methods that you
can use with these strings. But I would say
43:43 - for the most part, those are some of the most
common methods that you're going to be seeing.
43:48 - And really, I just wanted to give you guys
an introduction into how we can work with
43:51 - strings inside of our programs, we're going
to talk about how we can use different methods
43:55 - to do different things. Hopefully, you learned
something, and hopefully now you can go off
43:58 - and start playing around with strings inside
of your programs. In this tutorial, I want
44:07 - to talk to you about working with numbers
in Ruby. So we're going to take a deep dive,
44:11 - we're going to look at all the different things
you can do with numbers. We're talking about
44:15 - the different types of numbers in Ruby, and
we're gonna look at some awesome Ruby methods
44:20 - that we can use on our numbers to do a bunch
of different stuff. So this is gonna be a
44:24 - pretty cool tutorial. But down here, I'm just
going to show you guys the basics of working
44:28 - with numbers, I can just say like puts in
this, we'll just print something onto the
44:32 - screen just so we can kind of see what's going
on. When I want to use a number in Ruby, it's
44:36 - really easy. You just type out the number
so I can type out like five for example. And
44:40 - now this is going to get printed out onto
the screen as five. In addition to just using
44:45 - whole numbers like this, we can also use decimal
numbers so I can see like 5.86543 it's going
44:52 - to do exactly the same thing. So now over
here, it'll be able to print that out. We
44:56 - can also use negative numbers so I can put
a negative in front of here and again, right
44:59 - He's going to have no problem dealing with
negative numbers. And it isn't just using
45:03 - numbers though, we can also use basic arithmetic.
So for example, I can say like five plus nine,
45:10 - and this will actually be able to go through
and print out the answer. So not only is Ruby
45:14 - going to print out five plus nine, it's actually
going to do that calculation for us and print
45:19 - the answer out onto the screen, which is pretty
cool. So we can use addition, we could use
45:23 - subtraction, we could use multiplication,
which is just this Asterix, we could use division.
45:28 - So those are like the four basic types of
resin of arithmetic, but we can also use exponential.
45:33 - So for example, let's say I wanted to take
two rays to like the third power, I can just
45:39 - do something like this, I can say two, multiplication
multiplications, so two Asterix is and then
45:44 - three. And this is basically going to be the
same thing as saying two raised to the third
45:49 - power. So now we should get two cubed, which
is eight. So it's going to be a really handy
45:54 - operation here, we can also use something
else, which is called the modulus operator.
45:58 - So I could say, for example, 10, a percent
sign and then three. And what this is going
46:03 - to do is it's going to take 10, it's going
to divide it by three, and it's going to spit
46:07 - out the remainder. So 10 divided by three
is three, right 369 with a remainder of one.
46:14 - So when I run this, you'll see it prints out
a one. So it's basically printing out the
46:18 - remainder that we get from dividing these
two numbers. And that can be pretty useful.
46:22 - In addition to just having numbers over here
like this, I can also store numbers inside
46:26 - of a variable. So I can come over here and
say like, num, this is the name of a variable,
46:31 - and we can set it equal to like 20. And then
down here, if I wanted to access that number,
46:36 - I can just print out the variable. So now
we're printing out the actual variable. And
46:41 - I want to point out, one cool thing with numbers
is you can actually print out numbers and
46:46 - strings inside of the same print statement.
So for example, I can say like, my fav num,
46:54 - and over here, I can put a plus sign. And
what this is basically going to allow me to
46:59 - do is print out this string alongside this
number. But you'll see over here, when I actually
47:04 - print this out, we're going to get a couple
errors. And the first thing we have to do
47:08 - is we always want to put this inside of parentheses.
So I'm going to surround this whole thing
47:13 - with parentheses, that's because we're referring
to this variable. But also, if I want to print
47:17 - out a number alongside of a string, I actually
have to convert this number into a string.
47:22 - And I can do that by saying num.to underscore
s. And basically, what this is going to do
47:29 - is it's going to take this number, it's going
to convert it into a string. And then we'll
47:33 - be able to print both of these side by sides,
you can see now it just says my fav num 20.
47:38 - That's a really useful way to do something
like that. So in addition to just working
47:42 - with normal numbers, we can actually use special
things called methods. The method is essentially
47:47 - just a block of code that we can call, which
will either modify our number or it'll give
47:53 - us information about a number. Sometimes it'll
also do like mathematical calculations on
47:57 - the number. So now here, I can say like put
num, when I want to access one of these number
48:02 - methods, I can say dot and then I can type
out the name of the method that I want to
48:06 - use. So for example, I can say num dot abs,
and an open and close parentheses. And basically
48:11 - what this is going to do is it's going to
tell me the absolute value of num. So if I
48:16 - put like a negative 20, up here, now this
is just going to return 20. Because it's giving
48:20 - me the absolute value. There's also some methods
that we can use with decimal numbers. So for
48:25 - example, if this was like 20.487, I can use
num dot round. And this will actually round
48:33 - the number for me. So over here, you'll see
we just get 20. So it's basically rounded
48:37 - the number but if I was to make this like
a six, now we should get 21. So it's rounding
48:41 - it up or down, you'd also use a ceiling and
a floor function. So a ceiling will always
48:47 - take the higher number and the floor will
always take the lower number. So for example,
48:51 - if I said 20.18 cetera, let's just say 20.1.
And I said num dot c i L, this is actually
48:59 - just going to return 21. So it's going to
give us the highest number, or it's going
49:04 - to give us the next highest number from 20.
If I was to say like 20.9, and I said num
49:10 - dot floor, this is just going to give me 20.
So it's basically just gonna cut off that
49:14 - decimal point, give me the lower number, in
addition to just using these normal methods,
49:19 - or you also hear these referred to sometimes
as functions. So in addition to using these
49:24 - methods or functions, we can also use other
special methods which are inside of something
49:30 - called the math class. And don't worry too
much about what a class is. But essentially,
49:34 - there's this entity inside of our Ruby programs
called math. And we can use it to perform
49:39 - specific math operations on numbers. So if
I came over here, I could type out math like
49:45 - that with a capital M, I can type a dot, and
now inside of this math class, and again,
49:51 - don't worry too much about what a class is.
But inside of this math entity in Ruby, there's
49:56 - a bunch of these methods that we can use.
So for example, I could say math dot Sq RT
50:01 - and open and close parentheses. Now inside
of this open close parentheses, I can give
50:06 - this a number. So for example, I could put
like 36 inside of here. And what this is going
50:11 - to do is it's going to give us the square
root of this number 36. As you can see, over
50:16 - here, we get six, you could also use something
like the logarithmic function. So I could
50:21 - say math dot log, put like a one in here.
And now we're going to get 0.0 back. So there's
50:27 - a lot of these different like math operations,
you can do a lot of things with like sine,
50:31 - cosine, tangent, like logarithmic stuff. So
this can be really useful if you're just trying
50:36 - to work with math inside of Ruby. So the last
thing I want to talk to you guys about in
50:40 - this tutorial is working with floating point
numbers and working with integer numbers.
50:46 - So there's two basic types of numbers in Ruby,
we have integer numbers, which are like whole
50:51 - numbers. So an integer would be like 20, or
21, or 22. We also have decimal numbers, which
50:56 - would be like 22.1 22.2, etc. integers and
floats can be used inside of Ruby, basically
51:03 - interchangeably, although there are two, like
separate types. So Ruby does distinguish between
51:09 - a whole number and a floating point number,
but I want to show you guys how we can use
51:12 - these together. So for example, like if I
came down here, and I just added two integers,
51:17 - like I added one plus seven, you'll notice
that we're going to get an integer back, so
51:22 - it's going to be eight. But if I added like
1.0, and seven, now you'll see we're getting
51:28 - a floating point number back, so we're getting
a decimal back. So whenever you add two integers,
51:33 - you always get an integer back or multiply
two integers divide, subtract two integers,
51:38 - you're always going to get an integer back.
So for example, if I said like 10, divided
51:42 - by seven, this shouldn't be an integer number.
This should be like some long decimal number.
51:48 - But you'll notice that I'm just getting a
one back. So I'm only getting an integer back.
51:53 - But if I said like 10 divided by 7.0, now
I'm going to get the full number back. So
51:59 - whenever you're using an integer, and a floating
point number together to do some operation,
52:04 - you're always going to get a floating point
back, if you're using two integers, you'll
52:07 - get an integer back. And if you're using two
floats, obviously, you're going to get a floating
52:11 - point number back. So that's kind of the difference
between those two. And Ruby doesn't really
52:16 - give you too much of a hassle. When you're
using numbers, you know, you can basically
52:20 - use integers and floats interchangeably. But
just know that Ruby does distinguish between
52:25 - the two of them. So if you're doing different
types of math, with different types of numbers,
52:29 - like integers or floating point numbers, there's
going to be a difference in the type of answer
52:34 - that you're going to get. So that's really
the basics of working with numbers. I mean,
52:37 - I can spend all day talking about all the
different methods and you know, little caveats
52:42 - here and there that you can use with numbers
in Ruby. But I think that's kind of a good
52:45 - coverage of the basics. And so now your job
is just to go off and play around with all
52:50 - this different stuff. And really just get
comfortable working with numbers 
52:57 - in your Ruby program. In this tutorial, I'm
going to talk to you guys about getting input
53:00 - from users and Ruby, this is going to be awesome,
basically going to allow a user to input information
53:06 - into our programs, we're going to store whatever
they input into a variable. And then we're
53:11 - going to print out that variable along with
a message that basically just says hi to whoever
53:16 - entered the information. So in order to get
information from the user, we're actually
53:21 - going to have to do one thing. And if you've
been following along with this course, we've
53:26 - been using this atom runner program in order
to run our Ruby files. And this is a really
53:31 - awesome convenient way in order to just run
a Ruby file. But here's the problem, if we
53:36 - want to get input from a user, inside of our
Ruby programs, we actually can't use this
53:42 - little atom runner plug in to do it, we're
gonna have to use something called the terminal
53:47 - or the command prompt. And if you're on Windows,
this is a program called the command prompt.
53:52 - If you're on Mac, it's called the terminal.
Basically, it's an environment where we can
53:57 - interact with our computer using text. And
in order to interact with the computer and
54:02 - input information into our Ruby programs,
we're going to have to use the terminal. So
54:07 - the first thing I want to do is show you guys
how to set that up. And then we'll look at
54:11 - getting input from the user. So this is going
to be instructions for doing this inside of
54:15 - atom over here. I'm just going to go over
to the preferences inside of atom or the settings.
54:21 - And down here, I'm just going to click this
install tab. And I want to search for a package
54:26 - and we're looking for a package which is called
platformio hyphen ID e terminal. So search
54:33 - for this. And you'll see it shows up over
here and I actually already have it installed,
54:38 - but you want to install this platformio id
e terminal. Basically what this is going to
54:43 - allow us to do is use a terminal or a command
prompt if you're on Windows straight from
54:49 - inside atom. So install that. And now we're
just going to go back over here. You might
54:54 - need to restart your atom program in order
to use it but eventually what you should get
54:59 - is a little problem. Sign You see, there's
this plus sign down here at the bottom left.
55:03 - And when I hover over it, it says new terminal.
So once you have this installed, you want
55:08 - to go ahead and click that. And a little terminal
window should pop up down here, you'll notice
55:13 - mine is just black with white text. So this
is where we can run our Ruby program in order
55:19 - to get input from a user. And this is also
another way that you can run your Ruby programs.
55:25 - So down here, as long as you have your Ruby
file open inside of atom, so as long as this
55:31 - file is open, when you open up platformio
id terminal into a new terminal, it should
55:36 - automatically open up to the location where
your Ruby file is. Now, you know, I'm not
55:42 - going to get too into like using the terminal
in this tutorial. But essentially, you can
55:46 - navigate through the different folders and
the different files inside of your computer
55:51 - using the terminal or the command prompt.
So as long as you have your Ruby file open,
55:56 - like I have this draft Ruby file open, this
should automatically open to the correct directory,
56:01 - so you won't have to worry about that. So
once we're here, I just want to type in Ruby.
56:06 - And then I want to type in the name of the
file that I want to run. So in my case, it's
56:10 - just draft.rb. And what this is going to do
is it's going to run the file for us now when
56:15 - I click enter, it's going to run the file
and you know, it'll basically stop, we don't
56:20 - have any code up here. So if I was to print
out like, Hello, now when I run this, again,
56:25 - I can just type it in and click Enter, and
you'll see that we get the program running.
56:29 - So that's basically how we can run a Ruby
program from inside of our command line or
56:35 - inside of our terminal. So we're going to
have to do this in order to get input from
56:39 - the user. Just so you guys know. Alright,
so let's talk about how we can get input from
56:44 - the user. Basically, I'm going to allow the
user to input a piece of information, we're
56:49 - going to store that piece of information inside
of a variable, and we're going to print it
56:53 - out onto the screen. So first thing I want
to do is actually just type out a prompt.
56:58 - So I want to tell the user what I want them
to enter. So I can just say puts, and I'm
57:03 - just gonna say enter your name. And now once
we've prompted them to enter some information,
57:10 - I can use a special command in Ruby called
gets. And basically what this is going to
57:15 - do is it's going to allow the user to enter
a piece of information into our program. So
57:21 - it's basically going to stop the execution
of the program and wait for the user to enter
57:25 - something. And what I want to do is I want
to store whatever the user enters inside of
57:29 - a variable. So I'm actually going to create
a variable called name. And I'm going to set
57:34 - it equal to guests. And basically, what this
is going to do is it's going to tell Ruby
57:38 - to take whatever the user inputs into the
program and store it inside of this name variable.
57:44 - So the last thing I want to do is come down
here, I'm just gonna say puts, and I'm going
57:48 - to print out some text, I'm going to say hello,
plus name. So basically, I'm printing out
57:56 - hello to whoever entered in information into
the program. So I'm going to save this. Now
58:01 - I'm going to come down here and I'm just going
to run this program. So you'll notice, if
58:06 - you click the up arrow on your arrow keys
on your keyboard, it will actually just insert
58:11 - the last line that you entered. So I just
click the up arrow here. And now when I click
58:15 - enter, you'll see that it says enter your
name. So I'm going to enter my name is going
58:20 - to be Mike. And now when I click Enter, and
actually we're getting an error here, I should
58:23 - actually need puts down here not put, that's
my bad. So let's do this again. So I'm going
58:29 - to enter my name, Mike. And now when I click
enter, it's going to say, Hello, Mike. So
58:34 - it's basically just saying hi to me. So that's
the basics of getting input from the user,
58:39 - you can use this gets in order to get specific
information. Now, I do want to talk to you
58:44 - guys about one more thing, which is basically
something that happens in Ruby when we enter
58:49 - information. And let me sort of illustrate
this. So down here, I'm saying hello, name.
58:53 - And after this, why don't we print something
else out. So I'll say like, you are cool.
58:59 - Alright, so I'm basically printing out Hello,
name, you are cool. Now I'm going to go ahead
59:03 - and run this program and you guys will see
what happens. So I'm running the program,
59:06 - I'm entering in my name, Mike. Now when I
click enter, you'll notice that it prints
59:11 - out Hello, Mike, but then it prints out a
new line. And it says that other text. basically
59:17 - what's happening here is when I click enter,
Ruby is not only taking that as the text that
59:23 - we entered, but also as a new line. So whenever
you click enter it basically like is going
59:27 - to insert a new line. So Ruby is essentially
printing out Mike, then the newline character
59:32 - and then all the text over here. In order
to mitigate that all I have to do is come
59:37 - over here and say name is equal to get dot
Chomp, and an open and close parentheses.
59:43 - And this is going to get rid of that new line
character that happens when we click enter.
59:48 - So now when I run my program, it's going to
be able to work correctly. So I'll say enter
59:53 - your name Mike. And now it just says hello
Mike. You are cool. So now our program is
59:58 - working perfectly. So you If you want to keep
that new line, when the user clicks enter,
60:03 - you can go ahead and just not put dot chomp
here. But in a lot of cases, you're going
60:07 - to want to go ahead and just put that in there.
So that's the basics of getting input from
60:11 - a user. And if I wanted, I can get multiple
pieces of information. So for example, I could
60:16 - say puts, enter your name. And I'm actually
just going to copy this. And now we'll say
60:21 - like, enter your age. And we'll do the same
thing. I'll store it in a variable called
60:25 - age. So now we can actually come down here
and we can print out like Hello, Mike, you
60:30 - are. And then we could just print out like
the age. So now it'll just be printing out
60:35 - age. So now we can get two pieces of input
from the user. So let's run our program. And
60:43 - it says, enter your name, Mike. And let's
say that I'm like 59. So now it's printing
60:49 - out. Hello, Mike, you are 59. So we're getting
input from the user, we're getting two pieces
60:55 - of input from the user. And we're printing
them out onto the screen. So that's the basics
61:01 - of getting input. And in the next couple lessons,
we're going to talk about other ways that
61:04 - we can do this. And basically ways we can
make this work a little bit better. In this
61:12 - tutorial, I'm going to teach you guys how
to build a very basic calculator in Ruby,
61:17 - we're basically going to build a little program
that will allow the user to enter in two numbers,
61:22 - and then we'll print out the sum of those
two numbers. So we'll get the two numbers
61:26 - from the user, we'll add them together, and
we'll tell them what the answer is, it's gonna
61:30 - be pretty cool. And it'll kind of give you
guys some more information about getting input
61:34 - from users, specifically how we can get numbers
from users. So keep in mind, In this lesson,
61:40 - we're going to be using the terminal or the
command prompt, in order to get information
61:45 - from the user. So you want to make sure that
either if you're using atom, you can use this
61:50 - platformio id terminal plugin that I talked
to you guys about in the last lesson. Or you
61:55 - can just use your normal like terminal or
your normal command prompt. So I'm going to
61:59 - be using this little atom plug in that I have.
So let's talk about how we can get input from
62:04 - the user. Specifically, we need to get to
numbers. So down here, in our program, we
62:09 - can just write out the code to do that. So
I'm going to first write a prompt, I'm just
62:12 - going to say puts, and we're just going to
type out a message for the user. So we'll
62:16 - say enter a number. And then we're basically
going to get that number that they entered
62:22 - and store it inside of a variable. So I'm
going to create a variable called num one.
62:27 - And I'm going to set it equal to gets dot
chomp. And gets is basically going to get
62:35 - whatever information the user enters in, and
chomp is going to get rid of the new line
62:39 - that they accidentally enter when they click
the Enter buttons. So whenever you click enter
62:44 - in Ruby, and you're inputting information
into the program, it's going to add a new
62:47 - line onto the end of whatever you input. So
this is just going to get rid of that for
62:52 - us. The next thing I want to say is another
prompt, so I'm gonna say puts, and I'm going
62:57 - to tell them to enter another number. And
once again, we're going to do the same thing.
63:02 - So I'm just going to say num two is equal
to get stop shop. So essentially, we're asking
63:07 - them to enter in two numbers. Now, all we
want to do is just print out the result of
63:13 - those two numbers. So I'm going to put, and
I'm going to put this inside of parentheses,
63:18 - and I'm going to say num one plus number two,
right? Essentially, what we're doing is we're
63:22 - getting two numbers, and then we're printing
out the sum of those two numbers onto the
63:26 - screen. So let's go ahead and do that. I'm
going to come down here into my terminal window.
63:32 - And I'm just going to run this program. So
I'm just going to type out Ruby draft.rb.
63:40 - And this is going to run the program for me.
So it says down here, enter a number. So why
63:44 - don't we enter five, enter another number.
Let's enter two. And now when I click enter,
63:50 - this should add the two numbers together and
print out the answer. So click Enter. And
63:55 - you'll notice down here, we're actually getting
a little bit weird of an answer, we're getting
63:59 - the answer 52. The last time I checked, five
plus two wasn't 52. Essentially, what we're
64:06 - doing is we're concatenating these two strings
together. So here's the problem. When you
64:13 - enter in information into Ruby, Ruby automatically
just converts whatever you enter in into a
64:19 - string. So byte you can enter in as many numbers
as you want, you can enter in decimal numbers,
64:24 - normal numbers, doesn't matter, Ruby's just
going to convert it into a string. And when
64:29 - we add two strings together like this inside
of a put statement, it just does what's called
64:34 - concatenating the strings, so it takes the
first string and adds the other string onto
64:38 - the end of it, right. So that's why we get
five to in order to actually add these two
64:44 - numbers together, we're going to have to convert
the strings that the user enters into numbers.
64:50 - So over here we're getting a number num one
here we're getting a number num two. But remember,
64:56 - when we actually store those variables, they're
getting stored as strings. So all we have
65:00 - to do is take num one, convert it into a number,
taking them to convert it into a number, and
65:06 - then we'll be able to run this program successfully.
So all I have to do to do that is just say
65:10 - num 1.2 and underscore, and then I, so it's
not 1.2 I and basically what this means is
65:18 - we're converting num one into an integer,
I'm going to do the same thing over here dot
65:22 - two, I. So now we're basically taking these
two strings num one and m two and converting
65:28 - them into integers. So Ruby is going to take
whatever the numbers that were inside of those
65:32 - strings, and convert them into integers. So
let's go ahead and run our program. So I'm
65:39 - gonna come down here, I'm just going to type
in clear. And I'm going to type in Ruby draft.rb.
65:46 - So it says enter a number, we'll enter in
five, enter another number, let's enter in
65:49 - two. Now when I click enter, you'll notice
that we're getting the answer which is seven.
65:55 - So that's pretty awesome, right, we were able
to build our calculator, and it was able to
65:58 - add the numbers together. Here's the problem,
though. Let's say I come down here and I run
66:02 - this program again, and I enter in a five.
But now I enter in a 2.5. So for example,
66:10 - instead of just entering in two, I'm entering
in a decimal number 2.5. When I run this program,
66:15 - Now, you'll notice that we're still getting
seven. So our program wasn't able to add this
66:21 - z, this point five on to the answer. That's
because over here, we're converting these
66:28 - to integers. So we're saying num, one is going
to get converted into an integer, num two
66:32 - is going to get converted into an integer.
And so really, all this is doing is it's adding
66:36 - in the integer five, and it's adding in the
integer value of 2.5, which is just going
66:41 - to be two together. So if I want to be able
to add in decimal numbers in my program, instead
66:46 - of saying two I I'm going to say two F, and
to AP is basically going to convert whatever
66:52 - is inside of those strings into floating point
numbers, so into decimal numbers. So now when
66:57 - I run this program down here, we'll be able
to do that addition. So if I say Ruby, and
67:02 - I'm just gonna enter in a five, and now we'll
enter in that 2.5. And now they should give
67:07 - us the number that we wanted. So we're going
to get 7.5. So two F or two I or two really
67:14 - useful little functions that we can use on
numbers. And in some cases, you're only going
67:19 - to want the user to be able to enter an integer.
So you can just say two I. In other cases,
67:24 - though, you want them to use floating points,
so we can use to f. So that's the basics of
67:29 - building our little calculator. Now, I also
want to point out one way that we can make
67:33 - this program a little bit easier. So instead
of saying num 1.2, f down here, I could actually
67:39 - come up here. And I could say gets.chomp.to,
F. And I can do the same for this one over
67:49 - here.to F. And now this is going to convert
them up here, so we don't have to convert
67:56 - them down here. So this is going to work exactly
the same as it worked before. So I can say
68:01 - like 5.6 and 7.2. And it'll be able to add
them. So that's, there's another way that
68:07 - we can do that. But that's sort of how we
can build a basic calculator inside of our
68:12 - Ruby programs. In this tutorial, I want to
talk to you guys about building a Mad Libs
68:21 - game in Ruby. So we're gonna build a little
mad libs game. And I'll kind of show you some
68:25 - more about how we can get input from a user.
So if you're not familiar with Mad Libs, a
68:30 - Mad Libs is basically just a game where you
would enter in like a bunch of random like
68:34 - words maybe like nouns, verbs, adjectives,
adverbs, and then you'd take all of those
68:38 - words that you'd enter in and like sort of
sprinkle them in inside of a story. And generally
68:43 - like since you're entering in random words,
the story is going to be like kind of funny.
68:47 - So over here I have an example of a Madlib
you can see down here, it's like telling the
68:51 - user to enter in like a noun, a plural noun,
an adjective, and we're actually can build
68:56 - a Mad Libs game inside of our Ruby program.
So down here, you'll notice I have a little
69:01 - basic program set up, it's basically printing
out this poem. Roses are red, violets are
69:06 - blue. I love you. So this is, you know, kind
of a classic poem, but I think we can mix
69:10 - it up a little bit and create a Mad Libs for
this poem. So how would we say instead of
69:17 - Roses are red, well let the user enter in
a color. Instead of saying violets are blue,
69:23 - we'll let them enter in a plural noun. And
instead of saying I love you, why don't we
69:30 - let them enter in like someone else so maybe
like a celebrity, instead of having just Roses
69:35 - are red, violets are blue I love you will
have roses are and whatever the color the
69:38 - user enters in, whatever the plural noun they
enter in, or blue, and then I love a certain
69:44 - celebrity. So this would be kind of funny.
So let's set up our program. The first thing
69:48 - I want to do is get input from the user. So
I want to be able to get three pieces of information
69:54 - from the user, I want to get the color. I
want to get the plural noun and then I want
69:57 - to get the celebrity after we get that input.
Then we'll intersperse those variables inside
70:03 - of this little output. So let's get the input
from the user, I'm just going to come over
70:07 - here and we'll just print out a prompt, it'll
just say, enter a color. So the first thing
70:13 - they'll do is enter the color. And now what
we're going to do is store that in a variable
70:17 - called color. So I'll say color is equal to
get dot chump. And remember, chomp is just
70:24 - getting rid of the new line that gets entered
when you click the enter button. Alright,
70:29 - so we'll enter in a guess. And we're also
going to do two more of these, I'm just going
70:33 - to paste this two more times. And then we're
going to enter in a plural noun. And we'll
70:38 - make a variable called plural noun. And finally,
they're going to enter in a celebrity. So
70:44 - we'll make a variable called celebrity. So
now we have three variables that are storing
70:51 - the three pieces of information that the user
input. last step is to come down here. And
70:58 - instead of just printing out color inside
of curly brackets, I'm actually just going
71:01 - to add in that color variable. So we'll print
out color, same thing for the plural noun.
71:07 - And same thing for the celebrity. And now
our program is essentially set up, we're getting
71:12 - the input, and then we're just printing out
the actual embed libs. So remember, whenever
71:18 - we get input from the user, I have to use
my terminal down here. So instead of just
71:23 - using this little like atom runner plugin
that we've been using throughout the course,
71:27 - I'm going to use my terminal. And down here,
I'm just going to go to the directory where
71:31 - my Ruby file is stored. And I can just run
it so I'm just gonna say Ruby draft.rb. That's
71:36 - the name of the file, and I'm gonna run the
program. So it's going to ask me to enter
71:40 - a color. So why don't we enter in like magenta?
says, enter a plural now and I'm going to
71:46 - enter in microwaves and enter a celebrity.
Why don't we do like Tom Hanks. So now what
71:53 - should happen when I click enter is all of
that information should get put inside of
71:58 - our Mad Libs, and we should get the finished
story. So I'm gonna click Enter. And you'll
72:02 - see down here we get our finished story. So
it just says roses are magenta, microwaves
72:08 - are blue. I love Tom Hanks. So basically,
the user could run this program, they could
72:14 - enter in all the words for the Madlib. And
then we'll basically just be printing out
72:18 - Madeline. So it's actually a pretty simple
program, you can see how easy it is to build
72:23 - a game like a Madlib inside of Ruby, it's
super easy. And also if you want and you can
72:28 - make this a lot more complex. So you get to
have them add in like adverbs, verbs, adjectives,
72:34 - like all sorts of stuff inside of here make
obviously the story a little bit longer. And
72:39 - you could essentially replicate any Madlib
inside of your Ruby program, which is awesome.
72:46 - And this tutorial, I want to talk to you guys
about using arrays in Ruby, and Ruby, we're
72:53 - going to be dealing with lots of information.
And a lot of times when you're writing programs,
72:57 - there's going to be a bunch of different values
that you want to store and keep track of.
73:01 - And one way that we can keep track of the
data inside of our programs is using a simple
73:07 - variable. Here's the problem with the variable,
though it can only really store one single
73:12 - value, as I can create a variable, I can store
a value inside of it. But what happens when
73:16 - I have a lots of data, it's going to be kind
of a pain in the butt to have to create like
73:20 - hundreds of different variables, if I want
to keep track of and maintain hundreds of
73:24 - different pieces of information. And this
is where arrays come in. An array is essentially
73:29 - a structure or a container, a lot like a normal
variable. The only difference being that an
73:35 - array can hold multiple values. So unlike
a normal variable, an array can hold like
73:40 - 10, or 20, or 100, or a million different
items inside of it. And a lot of times when
73:46 - we're programming in Ruby, and we're dealing
with large amounts of information, we're going
73:49 - to want to be able to use arrays. So let's
jump in, I'm going to show you guys how to
73:53 - use arrays and talk about you know, what they
are, how to create them how to put stuff inside
73:57 - of them all that fun stuff. So down here,
if I want to create an array, I created a
74:02 - lot like I would a normal variable, the first
thing we have to do is tell Ruby what we want
74:06 - that array to be called. So in my case, why
don't we make an array that's going to store
74:11 - a bunch of names of my friends. So I can make
an array called friends. And I'm going to
74:17 - set this equal to array with a capital A,
and then we're going to make an open and closed
74:23 - square bracket. inside of this open and close
square bracket, I can start putting in some
74:29 - of the pieces of data that I want to store
in this array. In my case, I'm just going
74:33 - to store a bunch of strings with names of
some of my friends. So I can store on like
74:37 - Kevin, Karen, and Oscar. So here we have an
array that has three elements inside of it.
74:47 - And each one of these pieces of data are referred
to as array elements. Basically what I did
74:53 - is I created a container that can hold multiple
pieces of information. So what I can do Now
75:00 - is I can come down here and I can just say
like, puts friends. And this is actually going
75:05 - to print out all of the information inside
of this array, all the data values on my output
75:11 - over here. So you can see, we're printing
out Kevin, Karen and Oscar. So that's the
75:15 - basics of using an array. And if I didn't
want to just store strings, I can store any
75:20 - type of data inside here. So I can sort of
strings, I can even store like a number, or
75:25 - I can store a boolean value like false, you
can put all different types of information,
75:31 - all different data types, inside of these
arrays. And if you want, you can even put
75:35 - different data types together in the same
array. But for our purposes, let's just stick
75:39 - with strings. So let's say that I wanted to
access one specific element inside of this
75:44 - array. Well, if I want to access just one
element, I can make an open and close square
75:49 - brackets after I'm referring to the variable
name. And I can put an index inside of here.
75:55 - So let's say that I wanted to grab Kevin,
let's say I wanted to grab this first string
75:59 - inside of my array, I can put a zero inside
of here, and zero refers to the index of this
76:06 - Kevin value. So now when I print this out,
you'll see we're just printing out Kevin.
76:10 - And this brings me to a point about arrays,
we start indexing arrays of zero. So I would
76:16 - say that this Kevin attribute of this Kevin
element inside of the array is at index position
76:21 - zero. Karen is at index position one, and
Oscar is at index position two, so the first
76:28 - element is always in index position zero,
and then you just basically count up from
76:31 - there. So if I wanted to access Oscar over
here, I could put a two inside of here. And
76:37 - now this is going to print out Oscar, another
thing I can do is I can access array elements
76:43 - from the back of the array. So for example,
another way I could access Oscar would be
76:48 - by putting a negative one in here. Basically,
what this is going to do is it's going to
76:51 - grab the item in the array, but it'll start
counting from the back. So it'll basically
76:56 - like this would be negative one, Oscar, this
would be negative two, and this would be negative
77:01 - three. So if I said negative two in here,
now we're going to be grabbing Karen and printing
77:06 - that out. So that's two different ways that
we can access elements inside of the array,
77:10 - I can also grab a range of elements. So for
example, let's say I only wanted to grab the
77:15 - first two elements inside this array, and
I didn't want to grab the third one, I could
77:19 - say zero, and then I could say two. And basically,
what this is going to do is it's going to
77:25 - grab index position zero all the way up to
but not including index position two, so it's
77:30 - going to grab zero, and one, and it's going
to stop at two, so we're not going to grab
77:35 - two. So now we're just going to get Kevin
and Karen. And this can be really useful just
77:41 - specifying like a range inside of this square
brackets. There's also a bunch of other stuff
77:46 - that we can do with these arrays. So for example,
let's say I wanted to modify one of the values
77:51 - inside of the array, I can come down here
and I can just say, friends, let's say I wanted
77:55 - to change this first element and exhibitions
here, I could say friends, zero, and I can
78:01 - give it a new value. So I can say like Dwight,
and now instead of having the value of Kevin,
78:06 - this is going to have the value of Dwight.
So when we print it out, we get that new value.
78:10 - And you can access and modify any individual
element inside the array, just by referring
78:16 - to its index. There's also going to be situations
where you're not going to know exactly what
78:21 - elements you want to put inside of the array
right upfront. So for example, over here,
78:26 - I knew exactly what friends I wanted to put
in this array. But in some cases, you're not
78:30 - going to know that right off the bat. So we
can just say array dot new. And now we're
78:36 - basically telling Ruby that we want friends
to be an array, but that we don't want to
78:40 - put any values into it just yet. Then down
in my program, I can just start putting stuff
78:46 - in here. So for example, right now, if I printed
out friend zero, you'll notice that nothing
78:50 - prints out, it's just a nil value. Right?
If I came over down here, though, I could
78:55 - say friends zero, and I can just give this
whatever value I want. So I can give this
78:59 - a value of like Michael. And now friend zero
is going to be Michael. And you can do that
79:05 - as much as you want. So I can even come down
here and say like friends, five, and I can
79:11 - give this a value. So now this is going to
be equal to Holly. And what you'll see over
79:17 - here, when I print out just the entire friends
array, it's going to fill in all of the elements
79:23 - that are between zero and five, just with
blank elements. So those are just going to
79:28 - be nil. So that's kind of how you can create
an array and not give it some initial information
79:32 - yet, and then add in information later. There's
also a bunch of different methods that we
79:37 - can use with these arrays. So let's go back
to that array that we were using before with
79:41 - all the friends. So if I wanted to access
specific information about this array, I can
79:45 - use a little method so I could say like friends
dot and one really useful one is length. So
79:52 - this will tell me how many elements are inside
of this array. So you see over here we have
79:56 - three I can also check to see if certain elements
are inside. The array so I can say friends
80:01 - dot include, and I'm gonna put a question
mark. And over here, I can type in an element
80:08 - that I would want to check to see if it's
in the array. So I could say, like Karen.
80:12 - And now this should give us a true value because
Karen is inside of the array. If I put like
80:18 - Karen's, though, so I changed it. Now this
is going to give a false value, because that's
80:22 - not in the array, you can also modify the
order of the array. So I can say, like friends
80:26 - dot reverse, and this will reverse all the
elements. So now it's going to be Oscar, Karen.
80:32 - And then Kevin. As you can see over here,
you can also sort of different elements in
80:37 - the array. So for example, if I wanted, I
could sort all the elements. So if I were
80:42 - working with strings, we could sort them alphabetically.
So if I put something over here, like Andy,
80:48 - and now Andy is going to end up being in the
front, because it's going to sort the array
80:53 - alphabetically. So I'll say friends, that
sort. And now when we print this out, you'll
80:57 - see Andy care and Kevin Oscar, so moved Andy
to the front, because a comes before K and
81:03 - O. It's important to note though, that if
you're going to have an array that has multiple
81:07 - data types, so for example, if I put a n number
like an integer in here, this is going to
81:11 - throw an error now, because you can't sort
it, there's no, there's no way for us to compare,
81:15 - like numbers and strings inside of Ruby. So
that's the basics of working with arrays and
81:21 - arrays are super useful, there's going to
be tons of situations where we're going to
81:24 - want to store large amounts of information
in a single container. And arrays are great
81:29 - at doing that. In this tutorial, I want to
talk to you guys about using hashes in Ruby.
81:38 - Now, a hash is basically a type of data structure
where we can store a bunch of different pieces
81:44 - of information. If you're familiar with arrays
in Ruby, they're very similar to arrays. So
81:50 - a hash is basically doing the same thing.
It's allowing us to store multiple pieces
81:55 - of information. The difference is that with
hashes, we can actually store something called
82:00 - a key value pair. And a key value pair is
basically where we can store of value. And
82:07 - we can give it a key which is kind of like
a name. Now a lot of times you'll hear hashes,
82:12 - also called dictionaries. And that's because
they act a lot like dictionaries, picture
82:16 - a dictionary, like in a dictionary, you have
two parts to every word, right? You have the
82:21 - actual word itself. But then, in addition
to the word, you actually have the definition,
82:26 - right, so you could say that the word is the
key. And the definition is the value. So that's
82:32 - basically what hash is. And you'll kind of
see what this is, as we kind of go through
82:36 - this tutorial. And this tutorial, I want to
build a little hash, which will store state
82:42 - codes. So for example, I live in the United
States, and we have a bunch of different states.
82:47 - And each state has a specific code. So for
example, Pennsylvania, PA, right, New York
82:53 - is NY, California is CA, Michigan is EMI,
right, so you can map a state like New York
83:01 - to a specific abbreviation like NY, we can
map California to a specific abbreviation
83:08 - ca. And that's basically what I want to represent
inside of my hash. So we're going to build
83:13 - a hash, which can store all of those different
abbreviations. And you'll see why these data
83:19 - structures are useful and how they're different
from arrays. So down here, I want to create
83:24 - my hash. And in order to do that, you basically
just have to give the hash a name. So I'm
83:29 - just going to call this states. And I'm going
to set it equal to an open and closed curly
83:35 - bracket just like that. And a lot of times
when people are making hashes, they'll end
83:39 - up putting a new line here. So inside of here,
we can specify a bunch of different key value
83:45 - pairs. Okay, so what I want, I want the keys
to be the actual state names. And I want the
83:52 - values to be the abbreviations for those states.
So basically, all we have to do is just type
83:58 - out a key and then we can type out a value.
So the first thing I'm going to do is type
84:02 - a key. So why don't we map like Pennsylvania.
And so Pennsylvania is going to be the key.
84:10 - And now I can map this to a value. So I can
just say equals and then a greater than sign.
84:15 - And over here, I can type in a value. So I'm
just gonna type PA. Okay. So essentially,
84:20 - what I'm doing is I'm defining the key, and
I'm defining the value. Now I'm going to type
84:24 - a comma. And I can go and define another key
value pair. So why don't we do New York City,
84:29 - New York. And we're going to map this to and
why. And why don't we do another one, Oregon
84:38 - is another state, and we'll map this to o
r. So in here, I'm basically have three different
84:45 - states and I'm not going to do all 50 states,
but I have a key and then I have a value.
84:51 - Now here's one thing you need to know about
these hashes is you can only have unique keys.
84:56 - So for example, I couldn't create another
key down here. called Pennsylvania, that's
85:01 - gonna be a big No, no, when we're creating
hashes, you always want to have unique keys.
85:06 - Alright, so now that we have these input into
here, we can actually start using this hash.
85:13 - So down here, if I wanted, I could just print
this out. So I can come down here and say
85:17 - put, and it's just called states. So we can
put this and when I print this out, you'll
85:22 - notice that we're printing out this little
structure. It's just like Pennsylvania, that
85:26 - gets mapped to PA, New York gets mapped to
NY, etc. But one of the most powerful things
85:32 - we can do with these hashes is we can actually
give it a key, and it'll tell us the corresponding
85:38 - value. So I can come in here and inside of
these square brackets, I can just input a
85:43 - key. So I get input like Oregon. And now this
is going to print out the value for Oregon.
85:49 - So it's going to print out, or I could put
inside here, New York. And now this is going
85:55 - to print out ny because it maps to New York.
So that's like a super useful way that we
86:01 - can store our data, we could give this structure
a key, and it would spit out the corresponding
86:06 - value. There's also a couple other ways that
we can create these keys. So for example,
86:11 - instead of putting Pennsylvania inside of
quotation marks, I could also just put a colon
86:16 - here. And now this is going to be the same
thing. So down here, I could specify like
86:24 - Pennsylvania, and actually, this should be
capital. And now it'll still give me that
86:32 - same value. So it'll, it'll still give me
pa up here. You can also use in addition to
86:37 - like strings, we could also use numbers. So
down here, I could say one. And if I put one
86:44 - down here, now we're basically going to get
the same thing. So this should still print
86:49 - out pa and you can see that it does over there.
So these hashes are extremely useful. And
86:54 - there's a lot of situations where you're going
to want to map keys to values. So for example,
86:59 - in this situation, we're mapping a key, which
is the state name to a value, which is the
87:04 - state abbreviation. But you could do the same
thing for like days of the week, you could
87:07 - do it for a month abbreviations you could
do it for I mean, really, there's a tons of
87:11 - situations where this type of structure is
going to come in handy. And now I just want
87:16 - to point out how these are different from
arrays. So normally, when I create an array,
87:21 - I'm just creating like a list of individual
values, right. But when I create a hash, I'm
87:26 - creating a list of key value pairs. And I
can give this hash a specific key, and it'll
87:32 - spit out the corresponding value. So this
is a very useful data structure. And this
87:38 - is definitely something you're gonna want
to play around with and get used to using.
87:45 - In this tutorial, I want to talk to you guys
about methods in Ruby. Now, a method is basically
87:51 - just a block of code that we can write, which
will perform a specific task for us. A lot
87:57 - of times in Ruby, you're gonna have different
groups of code, different groupings of code,
88:01 - they're going to perform specific tasks, or
they're going to do certain things. And what
88:06 - we can do in Ruby is we can take all of that
code that's, you know, designed to perform
88:11 - one task, we can put it inside something called
a method. And what's cool about methods is
88:16 - you can actually call them from other places
inside your program. And we can give methods
88:21 - information, and then they can give us information
back. So in this tutorial, I'm just going
88:25 - to talk to you guys about the basics of using
methods, we're going to write a method, and
88:28 - we're going to look at how they can be useful.
So the first thing I'm going to do is create
88:33 - a method. And our method is going to be very
simple. all it's going to do is say hi to
88:39 - the user. So our method is going to perform
one task and has one goal, and it's going
88:44 - to say hi to the user. So down here, I'm going
to create my method. First thing we always
88:48 - want to do when we create a method is type
out d f. And this basically means that we're
88:53 - defining a method. Second thing we want to
do is give our method a name. So generally,
88:58 - you want to give your methods descriptive
names. So it's very obvious what task they're
89:04 - performing. In our case, our method is saying
hi to someone, so we can just call it Say
89:09 - hi, just like that. And now what I want to
do is hit Enter, and I'm going to come down
89:13 - here and I'm just going to type and so essentially,
what I'm doing is I'm defining a method block.
89:20 - And anything that's in between death and end
is going to be inside of our method. A lot
89:26 - of times people will indent here just to show
that the code is like inside the method. So
89:31 - in here again, we have one goal, we want to
say hi, so I'm just going to type puts. And
89:35 - I'll just say hello, user. Cool. So now I'm
going to run my program and we'll see if this
89:41 - method works. So I'm just going to run the
program. But you'll notice over here, when
89:46 - I run the program, nothing's showing up. And
that's because when we define a method, the
89:52 - code inside of the method is only going to
get executed when we call it so in other words,
89:59 - we want to execute the code inside this method,
we have to call the method, that basically
90:03 - just means we have to say like, Hey method,
go do your stuff go perform your task. So
90:08 - I can come down here. And the way I call this
method is just by typing out its name. So
90:11 - I can type out, say, hi. And now Ruby is going
to execute this method up here. So you can
90:17 - see over here, we have Hello users. So everything's
working. And I just want to show you guys
90:23 - one thing. So if I typed out, like, top up
here, and then typed out, bottom over here,
90:29 - I want to show you guys the flow of these
methods inside of our program. So now when
90:33 - I run this program, you'll see we're printing
out top, hello, user. And then bottom, essentially,
90:38 - what's happening is, Ruby is looking at this
line of code, it's executing it, then it sees,
90:44 - say, hi. So it knows, okay, the user wants
me to execute the say, Hi, method. So Ruby
90:50 - is going to jump up, it's going to execute
all of the code inside of this, say, Hi method.
90:55 - And then once it's done executing all of that
code, it's going to jump down, back down here,
91:00 - and it's going to print out bottom. And I
just want to point out, you can put as many
91:03 - lines of code inside of one of these methods
as you want. Obviously, this is like a simple
91:08 - method. So we're just keeping it simple. But
that's the basic execution flow of functions
91:13 - or methods. And actually, this brings me to
a good point, a lot of times, these are called
91:17 - methods. But you'll also hear people calling
these functions. Essentially, in the case
91:22 - of Ruby, these words are basically interchangeable,
basically means the same thing. But for the
91:26 - most part in Ruby, we're referring to them
as methods. Alright, so let me show you guys
91:31 - some more cool stuff we can do. One thing
we can do is we can actually give these methods
91:35 - some information. So I can actually take this
Say hi method. And I could actually allow
91:41 - the user to tell it, who to say hi to. And
the way that I'm going to do that is after
91:46 - I type the name of the method, say hi, I'm
going to make an open and close parentheses.
91:51 - And over here, I just want to specify what's
called a parameter. And a parameter is basically
91:56 - a value that whoever is calling this method
is going to give to it. So this method can
92:03 - actually accept inputs, it can accept parameters
as input. So over here, I can just type out
92:09 - the name of the parameter I want to accept.
So in our case, we'll just call this name
92:13 - because it's going to be the name of who we
want to say hi to. And then down here, instead
92:17 - of saying, hello user, I can say hello, name.
And you'll see in a second, this is going
92:23 - to use whatever variable and whatever piece
of information gets passed into this method.
92:31 - So down here, if I want to give this a name,
I can make an open and close parentheses.
92:35 - And in here, I could type in name. So I could
say, Mike. So now when we run our program,
92:39 - it's going to say, Hello, Mike, essentially,
what's happening is the say, Hi, method is
92:45 - specifying that you can give it a name. And
down here, I can, when I call the method,
92:51 - I can give it that piece of information, you
can also give these things multiple pieces
92:56 - of information. So I can also specify age.
And then down here, we can incorporate that
93:01 - into our print statement. So I can say hello,
name you are, and now we'll print out their
93:08 - age. So I can just say age. And essentially,
this will take in two parameters, and it will
93:14 - print them both out over there. So down here,
I can just specify the first parameter Mike.
93:20 - And then I can specify the age. So we can
say like, you know, 73, or something. And
93:24 - now it's going to say, Hello, Mike, you are
73. And actually, you'll see we're getting
93:28 - an error over here. And this is actually a
good little catch. So age, I'm actually passing
93:34 - in an integer. And whenever we want to print
out an integer inside of a print statement
93:40 - like this with strings, we always have to
say age.to underscore s. So that's why we're
93:46 - getting that error. And that's something that
you always want to watch out for in Ruby.
93:49 - So now when we run our program, it says, Hello,
Mike, you are 73. So that's pretty cool. We
93:56 - can pass this two pieces of information. But
let's say that I didn't want to pass this
94:01 - in age, right? Maybe I didn't know how old
Mike was. So I didn't want to give it an age.
94:05 - Well, now when we're when we run our program,
you'll see that we're getting an error, right?
94:10 - So because I didn't include an age, when I
call this, it's throwing an error. One way
94:15 - we can mitigate this in Ruby is we can actually
give these variables default values, we can
94:21 - give these parameters default value. So I
can come over here and say name is equal to
94:25 - no name. And we can just say age is equal
to negative one. And essentially, what's going
94:32 - to happen now is if I don't include an age
in here, it's just going to print out the
94:37 - default. So it says hello, Mike, you are negative
one, right? If I wasn't including the name
94:42 - in here, it's just going to use both of those
default values. See, let's see. I'm not passing
94:46 - any parameters. And now it basically just
says hello, no name, you are negative one.
94:52 - So sometimes specifying default values can
be a good way to control these methods and
94:58 - really, it depends so In some methods, you're
going to want whoever's calling them to give
95:03 - you certain pieces of information. But if
those pieces of information are like optional,
95:07 - you can just give them default values like
that. So that's the basics of working with
95:12 - methods. And there's actually one more thing
we can talk about, and I'm going to talk about
95:15 - it in the next video. It's something called
return types. Basically, we can give the method
95:20 - information and the method can give us information
back. But for now, this is just the basics
95:25 - and hope you guys learned something about
methods. In this tutorial, I want to talk
95:32 - to you guys about using returns in Ruby methods.
So in the last tutorial, we talked a lot about
95:39 - writing methods, we looked at how we could
give methods, some information through parameters.
95:44 - And this is all real, I want to talk to you
guys about how methods can give us information
95:49 - back. So when I call a method inside of my
program, that method will go off, it'll execute
95:54 - all this code, but then it can actually give
us a piece of information or in some cases,
95:59 - multiple pieces of information back. And that
can be really useful. So for the purposes
96:04 - of this tutorial, I want to show you guys
how we can create a cube function. So in math,
96:09 - when you cube a number, you essentially take
it to the third power. So if I was going to
96:14 - cube two, it'd be like to raise to the third
power. So essentially, it would just be two
96:18 - times two times two, right? So why don't we
write a little method that's going to do that
96:24 - for us. So this method will cube a number,
and it's going to be pretty interesting. So
96:28 - down here, I'm just gonna say def, and we'll
say cube. And we want to pass in one number,
96:34 - so I'm just gonna specify that they need to
pass in a num. And then down here, we're gonna
96:39 - say, and what's cool about these methods,
they can actually give us information back.
96:44 - So if I was gonna cube the number, it would
basically just be num times num, times num,
96:50 - right? So that's essentially like all we would
need to do to cube the number. But what's
96:55 - cool is when I call this cube function, and
I give it a number, so like, I give it a two,
97:00 - if I was to print this out, so if I said puts
cube two, this is actually going to print
97:06 - out num times num times num. So it's actually
going to print out this answer over here.
97:13 - So let's take a look. You'll see here, we're
printing out eight, if I was to pass in like
97:17 - three over here, now we should get 27. So
basically, what's happening is we're calling
97:23 - this cube method. And this cube method is
giving us a value back. So when I call this,
97:29 - this is actually like ends up representing
a value and ends up representing the value
97:33 - that was given back to it. And if you want
to give a value back, all you have to do is
97:38 - basically just specify it right here. So that's
a really cool way that we can use these methods
97:43 - to get information back. But sometimes when
you're working in these programs, that might
97:47 - not be super clear what value you want to
return. So for example, I have num times num
97:52 - times num here. But if I put a four down here,
right below this, or even if I put like a
97:57 - string or whatever, let's put a five, you'll
notice that now instead of returning num times
98:02 - num times num, this is actually going to return
five. And that's because five is the last
98:09 - line inside of this method. It's basically
like the last returnable piece of information
98:15 - that's inside of this method. So in situations
like this, you can actually use what's called
98:19 - the return work keyword. So I can say return
right before here. And even though there's
98:24 - a value after this, you'll see that this is
going to return num times num times num anyway.
98:30 - So we're returning 27. And actually, here's
the interesting part is any code that goes
98:36 - before this return keyword, or that goes after
this return keyword isn't gonna get executed.
98:41 - So if I put a puts down here, and I printed
out Hello, when I run my program, you'll notice
98:47 - that it doesn't print out Hello, like nothing
is getting printed out. Basically, what's
98:52 - happening is when we use this return keyword,
that's going to signal to Ruby that we're
98:57 - done with the method. So when Ruby sees this
return keyword, it's basically going to jump
99:02 - and break out of the method and move on to
the next line of code. So essentially, when
99:06 - you're using the return keyword, nothing after
it is going to get executed. And that's just
99:11 - a little tip. So in addition to returning
just normal numbers like we did over here,
99:17 - we can also return multiple pieces of information
and keep mine You can return any data type,
99:22 - it doesn't have to be like a number. It could
be a string could be Boolean could be anything.
99:27 - If I wanted though, I can return multiple
numbers. So for example, I could return num
99:32 - times num times num. And then if I put a comma
here, I can return another value so I can
99:37 - return like 17. And now when I run my program,
in addition to returning 27 you'll see that
99:44 - it's also returning 70. So I'm getting two
pieces of information. And this is basically
99:50 - just returning like an array so I could access
each individual value that got returned by
99:55 - its index. So if I said q three square brackets
one that's just going to give Give me 70.
100:01 - They want to be careful when you're returning
multiple values just because if you're returning
100:05 - like five or six different values that can
get a little bit confusing, especially for,
100:10 - you know, the code that's actually calling
these functions, but for the most part that
100:14 - can actually be pretty useful. So that's the
basics of using that return keyword and also
100:19 - just returning values. In general, this can
be a super powerful way to to make your methods
100:24 - a lot better. In this tutorial, I want to
talk to you guys about using if statements
100:33 - in Ruby, an if statement is a special structure
that we can use in Ruby in order to help our
100:38 - programs to make decisions. They also have
our programs to respond to the different information
100:45 - in the program. So if certain information
has certain values, we can do certain things.
100:50 - Other information has different values, we
can do different things, basically, if statements
100:54 - make our programs a little bit smarter. So
in this tutorial, I'm just going to give you
100:58 - guys a basic overview of if statements, what
we can do with them, how we can use them,
101:02 - and essentially just get you guys up and running
with if statements. So over here, I just have
101:07 - this little text file. And it actually has
some common if statements that human beings
101:13 - every day will encounter. So believe it or
not, if statements also apply to like human
101:18 - beings. So let me show you guys a couple of
these. The first one up here says I wake up,
101:23 - if I'm hungry, I eat breakfast. So let's break
this down a little bit. You'll see right here
101:28 - we have a condition, right? If I'm hungry,
this condition is either true or false, right?
101:35 - on the condition that they're hungry, then
they're going to go ahead and eat breakfast.
101:40 - If they're not hungry, though, if this condition
is false, then we're just going to move on
101:44 - and they're not going to eat breakfast, right?
That's something that pretty much every morning,
101:47 - everybody is going to have to like ask themself
at some point. Here's another one, it says,
101:52 - I leave my house. If it's cloudy, I bring
an umbrella. Otherwise, I bring sunglasses.
102:00 - So up here you'll notice the same pattern,
we have another condition, right, the condition
102:05 - is if it's cloudy, if that condition is true,
if it is indeed cloudy, then they're going
102:11 - to bring the umbrella. But if the conditions
false, in other words, if it's not cloudy,
102:17 - then we're going to come down here and we'll
bring the sunglasses. So this one's a little
102:21 - bit different from the one up above. Because
if this condition, if it's not cloudy, if
102:25 - this is false, then we're going to do something
else. So I have one more down here at the
102:30 - bottom that says I'm at a restaurant. If I
want meat, I order a steak. Otherwise, if
102:37 - I want pasta, I order spaghetti and meatballs.
Otherwise, I ordered a salad. So this one's
102:42 - even more complex, right we have our condition
says if I want meat, if that's true, we order
102:48 - the steak. Otherwise, if that's false, in
other words, if you don't want meat, then
102:54 - we check another condition. So we're checking
to see if we want pasta. If that's true, we
102:59 - get the spaghetti and meatballs. Finally,
though this is false when we get the salad.
103:03 - So these are the three basic if statements.
And these are three if statements that we
103:08 - can actually use. And these are the types
of things that we can do inside of our program.
103:12 - So we can specify certain conditions. If those
conditions are true, we can do certain things,
103:17 - those conditions are not true, we can do other
things. So I'm going to show you guys basically
103:21 - how this works. Let's go over here to our
Ruby file. So I'm just in my draft.rb file.
103:27 - And I'm going to create a if statement. So
I'm going to show you guys how this works.
103:31 - The first thing we're going to do before we
actually make the if statement is just make
103:34 - a variable, so I'm just going to call it is
male. And this is going to be a boolean variable,
103:40 - it's going to tell us whether or not someone
is male. So let's say this is a piece of information
103:45 - that we were storing inside of our program
like whether or not someone's male. So in
103:49 - my case, I have a male so I'm going to set
it equal to true. So down here we can actually
103:54 - make an if statement. So we can do something
depending on the value of this variable is
104:00 - male. So I can say if and over here I want
to specify a condition. So remember, when
104:07 - we were looking at those text files, it was
like if it's cloudy, or if I'm hungry, or
104:13 - if I want me right we were giving these those
statements, different conditions. In this
104:18 - case, we're going to specify our own condition.
So I'm going to say if is male, and inside
104:23 - of this condition we need to include either
a true or a false value. So bullions are great
104:29 - with this because a Boolean can either have
a value of true or false. So I can say if
104:34 - is male, and then down here I just want to
type out and now whatever goes in between
104:40 - if an end is going to get executed when is
male is true. So over here we can just put
104:46 - you are male, right? So now because is male
is true. When I run my program, you'll see
104:53 - over here it says you are male, so the program
is working. If I was to change is male to
104:59 - false, however, So I'm just gonna put false.
Now you'll see that this code isn't getting
105:05 - executed. So we're not printing anything out.
That's the basics of an if statement, right,
105:09 - I can specify a condition. If the condition
is true, then we'll execute the code down
105:15 - here. If the condition is false, we just skip
over it. So I'm going to show you guys how
105:19 - we can use something called an else. So basically,
what happens if we want to do something when
105:24 - the person's not male, right, so we have it
covered, if the person's male, we're going
105:28 - to tell them they're a male, but what if they're
not a male? Well, I can actually come down
105:32 - here, and I can type out else. So I'm just
gonna say else. And then again, below else,
105:38 - I'm going to put code so I can say puts, you
are not male. So now we basically have an
105:45 - if statement that will handle both of the
possible scenario. So if they're male, it'll
105:51 - tell them they're male. Otherwise, it'll tell
them they're not male, so you'll see is male
105:54 - is false. And over here, we were telling them
that they're not male. If I was to change
105:59 - this back to true, now, it's gonna say you
are male. So it's essentially able to react
106:05 - to the value of that variable. Let's make
this if statement a little bit more complex.
106:11 - So why don't we add in another Boolean variable,
I'm going to say is tall. And we'll set is
106:17 - tall equal to actually let's set it to true
initially, we'll also set this to true. So
106:22 - is tall will tell us whether or not a specific
person or a specific entity you know is tall.
106:29 - So what happens down here, if we want to do
something when they're male, and they're also
106:34 - tall, I can actually use another keyword in
Ruby, which is called and so I could say if
106:40 - is male, and is tall. And basically what this
is going to do is it's going to execute the
106:46 - code inside of here, when they're both male.
And they're also tall. So here, we could say
106:52 - you are a tall male. And so now this code
is only going to execute when is male is true,
106:59 - and is tall is true. So they're both true,
right? Now let's run our program, it says
107:04 - you are a tall male. But if I was to set one
of these equal to false, so for example, if
107:10 - I set in is tall, equal to false, now, it's
not going to tell us that we are a tall male
107:15 - anymore. So it's just gonna say you are not
male, although I guess we would have to change
107:19 - this down here. So we can say you are either
not male or not tall, or both. And so now
107:28 - it's telling us you're either not male, or
not tall, or both, because we know for a fact
107:33 - that they're not male and tall. So that's
how we can we can check to conditions. And
107:38 - in addition to using an and I could also use
another keyword called or, basically this
107:43 - will execute if they're either male, or if
they're tall. So only one of these variables
107:50 - has to be true now, right, this is going to
execute if they're male, or if they're tall.
107:56 - So you'll see over here is male is true and
is tall is false. But this is still gonna
108:02 - execute, you are a tall male. And obviously,
we can change, you know, whatever is getting
108:06 - printed out there. But hopefully, you get
the point, when we say and both of the conditions
108:11 - have to be true. So if I was to say, is male,
and is tall, these would both have to be true.
108:18 - In order for this code to get executed. If
I say or only one of them needs to be true.
108:24 - Now both of them can still be true and will
still execute that code. But only one of them
108:29 - has to be true. And if both of them are false,
then we'll execute the code down here. So
108:34 - I'm going to go back to is male and is tall.
And let's say that I want to check to see
108:39 - the other conditions, right. So we're already
checking one condition, we're checking to
108:43 - see if they're male, and they're tall. But
what if we wanted to do something when they're
108:47 - male, and they're not tall? Well, I can use
something called an else F. And then f is
108:53 - basically another key word in Ruby that will
check another condition. So I could say like,
108:59 - LS if and this just stands for elsif. And
I want to type in another condition after
109:04 - this. So why don't we check to see if they're
male. So I'm going to say elsif is male. And
109:10 - I want to check to see if they're not tall.
And the way that I can check to see if they're
109:15 - not something is I can use a exclamation point.
So if I said, and exclamation point is tall,
109:22 - this is basically saying not is tall. So when
they're not tall, this is going to be true.
109:29 - And we're doing that using this exclamation
point. It's called the negation operator.
109:34 - So down here, we can put some more code. So
I could just say puts you are a short male,
109:41 - right? basically what's happening is it's
going to check this if condition. So Ruby
109:46 - is going to check this if statement up here,
if they're either not male or they're not
109:51 - tall. So in other words, if this whole thing
is false, it's going to come down here, and
109:56 - it's going to check this next condition and
if this is false, it's going to go down to
110:01 - the else. But if this is true, it'll execute
the code inside here, there's actually one
110:05 - more scenario that we could cover, which is
when they're tall, but they're not a male.
110:11 - So I'm going to use another elsif, I'll say
else, if not, is male, so I'm using that exclamation
110:17 - point and is tall. And if this is true, then
we can just print out, you are not male, but
110:28 - are tall. And then also down here, if the
code inside of this else block is getting
110:34 - executed, then we're going to know that they're
not male and not tall. So we can say you are
110:37 - not male and not tall. Alright, so let's go
ahead and run our program. So I'm going to
110:42 - set is male equal to true and is tall equal
to true right off the bat just to start. So
110:48 - I'm running the program and you'll see it's
able to handle that situation says you are
110:52 - a tall male, if I was to set is male equal
to false, though, our program is going to
110:58 - be able to handle that situation. So it's
going to say you are not male, but are tall,
111:03 - right, our program just by using these if
statements was able to give us information
111:08 - based off of these values. If I was to make
is tall, false, and is male true, it's going
111:16 - to be able to handle that. So it will say
you are a short male. If I make both of these
111:21 - false, it's going to be able to handle that
as well. So it's going to say you are not
111:26 - male and not tall. So that's the basics of
using if statements, you can see down here,
111:32 - I'm checking a condition. And in a lot of
cases, you're going to want to check more
111:35 - than one condition. So you can use either
and, or or I'm checking these conditions.
111:42 - If the condition is true, then we'll execute
the code down here. And by the way, you can
111:47 - put as much code down here as you'd want.
I mean, I could put hundreds of lines of code
111:50 - if I wanted to. So I'm using the if statements.
And I'm using these else ifs and I'm using
111:55 - this else in order to catch all of these different
scenarios. And these else ifs are really useful
112:02 - because you can check multiple conditions
when other conditions are false. So that's
112:06 - the basics of working with if statements,
there's actually some more stuff we can learn
112:10 - with these. Instead of just using Boolean
like true and false, we can also use things
112:15 - called comparisons. And I'm going to be talking
about that in the next tutorial. But for now,
112:20 - this is just kind of been a brief introduction
into if statements in Ruby. In this tutorial,
112:28 - I want to talk to you guys some more about
if statements. Specifically, we're going to
112:32 - be talking about using comparisons with if
statements. So in any if statement, you're
112:37 - going to need a condition. And a condition
is basically a true or a false value. One
112:43 - of the cool things about Ruby though, is we
can use a comparison in order to get a true
112:48 - or false value. So inside of our condition,
or if statement, we can actually compare different
112:54 - values. And depending on the result of that
comparison, we'll be able to either execute
112:59 - the code inside of the if statement or move
on. So I'm going to show you guys how we can
113:03 - do this. It's really awesome. And it's a super
powerful feature, what I want to do in this
113:07 - tutorial is actually create a method. So I
want to create a method called max. And this
113:14 - method is going to take three numbers as input.
So it's going to take three parameters. And
113:19 - basically what it's going to do is it's going
to return whichever number is the largest.
113:23 - So whichever number out of the three is the
biggest, it'll basically return that back
113:27 - to the user. And this is a great example of
a situation where you'd want to use comparisons
113:32 - inside of your if statements. So let's get
started. I'm just going to come down here
113:36 - and we'll start making our function or our
method. So I'm just going to say def, and
113:40 - we're going to call it max. And I'm gonna
make an open and close parentheses. inside
113:44 - of this parentheses, I can specify any parameters
that I want this method to take in. So I'm
113:49 - just gonna say num one, number two and num
three. Basically, we're taking in three numbers.
113:56 - Now down here, I'm just gonna say and, and
inside of this method, we have to devise an
114:03 - algorithm to figure out which number is the
biggest right. So inside of this method, we
114:08 - don't know which of these is the biggest right,
we have no idea we have no idea what the user
114:14 - input into here. So we need to use an if statement
in order to figure that out. So I can say
114:19 - if now inside of this condition, I can actually
compare two numbers. So I could say if num
114:26 - one is greater than or equal to num, two,
and num one is greater than or equal to num
114:34 - three. So remember, inside of an if statement,
we need to put a condition here. And in the
114:42 - last tutorial, when we were using conditions
we were putting in true or false Boolean values,
114:47 - what you'll notice is when I compare two values,
when I compare number one and number two,
114:52 - this is actually going to get resolved into
a true or a false value. So this comparison
114:57 - is either true or its false. num one is either
greater than or equal to num two or it's not.
115:04 - This is actually going to end up being a boolean
value, this is going to end up being true
115:09 - or false. Same thing over here, num one is
either greater than or equal to num three,
115:14 - or it's not. It's a boolean value, there's
only two possible situations here, it's either
115:18 - true or its false, we didn't actually have
to put like true or false, here, we were able
115:23 - to use a comparison in order to get a true
or false value. So if num one is greater than
115:30 - num, two, and it's greater than num, three,
then we can just return num one because we
115:35 - know that's the maximum number. Down here,
I'm just going to say elsif. And I want to
115:40 - check another condition. So I'm going to check
to see if num two is greater than num one,
115:44 - we're actually greater than or equal to num
one. And num two is greater than or equal
115:51 - to num three. So if num two is bigger than
num, one and num three. In other words, if
115:57 - the result of both of these comparisons is
true, then we know that num two is the biggest
116:04 - number. So we're just going to return that.
And finally, we can use an else statement.
116:11 - So I can use that else keyword, I can just
say else. And down here we can just return
116:15 - num three. Because if num one isn't the biggest
and num two isn't the biggest, then we can
116:21 - be pretty sure that num three is the biggest.
So this is basically how we can use comparisons
116:27 - inside of our if statements. I also want you
guys to notice that I was able to use this
116:31 - return keyword multiple times, right. So if
this condition is true, we can just return
116:37 - the number. Alright, so let's go ahead and
run this function. So I'm going to come down
116:41 - here, and I'm going to call this function,
I'm gonna say Max, and I'm going to pass it
116:45 - three numbers one, two, and three. So if I
print this out, I print out the value that
116:52 - gets returned, actually, I'm gonna put it
I should get a three back. So let's go ahead
116:58 - and run this. And actually, you'll see I'm
getting an error over here, I forgot to put
117:02 - in the end keyword. So down here, we just
have to put an end. So you'll see we have
117:06 - an end keyword here. And this ends off this
if statement, we have another end keyword
117:12 - here. And this ends off this function declaration.
So that's something to keep in mind, you always
117:16 - want to make sure that you're remembering
to include this end keyword, you can see how
117:20 - easy it is to forget, I just forgot it. So
I'm going to run this program and you'll see
117:25 - we're getting three. So I pass it three numbers,
if I was to make this middle number, the largest,
117:30 - so we'll make it 20. Now it should return
20. If I was to make the first number, the
117:35 - largest, it's going to return that. So we
now have a valid working max function that
117:40 - will always tell us what the maximum number
is. So I just want to point this out one more
117:46 - time what was happening, instead of putting
a true or a false value in there, we actually
117:51 - indirectly put a true or a false value in
there by making a comparison. And the result
117:56 - of that comparison is either going to be true
or false. There's no other situation right?
118:00 - No one's either bigger, greater than or equal
to num two or it's not, I'm also using something
118:05 - called a comparison operator. So this right
here is a comparison operator. It's an operator
118:10 - that we can use to compare different values.
This one is greater than or equal to, but
118:15 - there's also some other ones. So for example,
probably the most basic is a double equals,
118:21 - and this basically means equal to, I can put
a exclamation point in equal sign, this means
118:26 - not equal to so this would be like num one
is not equal to num two, we can do a greater
118:31 - than sign a greater than or equal to sign
a less than sign a less than or equal to sine.
118:37 - And all of those are going to allow us to
compare different values. It's also important
118:42 - to note that, in addition to this using numbers,
you could also use strings here so you can
118:47 - compare different strings. For example, I
can compare two strings for equality, I could
118:53 - check to see if one string was equal to another
string. And that's really a powerful way that
118:59 - we can use these if statements is by checking
comparisons. A lot of times in your programs,
119:04 - you're going to want to compare different
values. And depending on the results of those
119:08 - comparisons do different things. In this tutorial,
I want to talk to you guys about creating
119:17 - a better calculator in Ruby. If you've been
following along with this course, then you'll
119:22 - know that in the beginning of the course,
we created a very simple calculator. Basically,
119:27 - we allow the user to input in two numbers,
we took those numbers, added them together
119:32 - and then printed out the answer onto the screen.
So it's a really simple calculator. But in
119:36 - this tutorial, we're going to be building
an even better calculator. This calculator
119:40 - is not only going to be able to add two numbers,
but it'll be able to add, subtract, multiply
119:44 - and divide numbers and will allow the user
to choose which one they're going to do. So
119:50 - this is going to be pretty cool. And we're
going to use a lot of the stuff that we've
119:53 - learned up to this point in this course in
order to do it. So the first order of business
119:58 - when we're creating our calculator As we need
to get some input from the user, I need to
120:03 - get certain information, right, we need to
get the first number, we need to get the second
120:07 - number, and then we need to get the operation
that they want to perform. So they would need
120:11 - to type in like two, and then a plus sign,
and then a five, you know, something like
120:16 - that, basically. So let's go ahead and do
that down here in my program, the first thing
120:20 - I want to do is, is print out a prompt. So
I'm going to say puts, and we're going to
120:24 - print out enter first number, basically, we're
prompting them to enter in the first number.
120:30 - And then what I want to do is I want to take
whatever number they enter, and I want to
120:34 - store it inside of a variable. So I'm going
to create a variable called num one. And I'm
120:39 - just going to set it equal to get dot chunk.
And this will basically just get the number
120:45 - that they enter in and remove the new line
that gets entered when we click the enter
120:49 - key. So now that we've done this, we can do
something similar for the other two pieces
120:54 - of information we need the next the next thing
I want to get is the operator. So I'm just
120:59 - going to say enter operator. And basically
this is going to be like plus minus division
121:06 - or multiplication, they're going to enter
in whatever they want to do. So over here,
121:10 - instead of saying num, one, we can just say
Opie, and this is going to Stanford operator,
121:14 - and we're just going to get whatever they
input. Finally, I'm going to ask them to enter
121:19 - the second number. So I'll say enter second
number, and we're just going to store this
121:23 - as num, two. So essentially, what we're doing
is we're asking them to enter in the first
121:28 - number. Once they do that, we're asking them
to enter in the operator plus minus division,
121:32 - multiplication, subtraction, whatever, then
we're asking them to enter in the second number,
121:38 - and we're storing all of that information
inside of variables. Now there's one more
121:42 - thing we have to do. Remember, when the user
enters in a number in, when we ask them for
121:48 - input, it automatically gets converted into
a string. So what we want to do is want to
121:54 - convert the number that they enter from a
string into a floating point number. So I'm
121:59 - just going to say gets.chomp.to underscore
F, and this is going to convert it into a
122:06 - floating point number, I'm going to do the
same thing down here.to underscore F. So now
122:11 - number one, and number two are going to be
floating point numbers, assuming the user
122:16 - entered the number in correctly. Alright,
so once we do that, we actually need to do
122:21 - a couple other things. So the first thing
we need to do is we need to figure out if
122:25 - they want us to add the numbers, subtract
the numbers, multiply the numbers or divide
122:28 - the numbers, right? We have no way of doing
that right now. So we need to figure out,
122:34 - how can we figure out if they entered in a
plus sign? How can we figure it out, if they
122:37 - entered in a minus sign, we need some way
of figuring out what they entered. And this
122:42 - is a perfect scenario where we can use an
if statement. Remember, an if statement allows
122:47 - us to respond to the different values in our
programs. So if something has a certain value,
122:52 - we can do something it has another value,
we can do something else. perfect situation
122:57 - right here. For an if statement, we can check
to see if it's a plus sign. If it's a minus
123:02 - sign, if it's a division sign, and depending
on the one it is we can do something down
123:07 - here, I'm going to create an if statement,
I'm just going to say if. And then we always
123:10 - want to make sure that we end off the if statement
down here. And up here we're going to put
123:14 - a condition, I'm going to be checking a couple
different conditions in this if block. The
123:19 - first thing I'm going to do is check to see
if it's equal to a plus sign. So I can check
123:23 - to see if op. And remember, op was the operator
that got entered is equal to I'm going to
123:30 - make those double equals and over here, we'll
just make a plus sign. So this is going to
123:35 - be true if the operator they entered was a
plus sign. So down here, what we can do is
123:40 - we can just say puts, and we'll just print
out the answer. So I'm just going to put num
123:45 - one plus num, two. Awesome. But there's also
some other scenarios, right the scenario where
123:52 - they enter a minus sign. So I can say elsif
elf if, and I'm going to say oh p is equal
123:58 - to minus sign. If that's true, we're just
going to put num one minus num two, we can
124:06 - do the same thing for multiplication and division.
So I'm going to go ahead and copy this, this
124:11 - will just make it go by a little quicker.
And now instead of checking for subtraction
124:16 - was check for division, which is just going
to be a forward slash. Finally, we can check
124:20 - for multiplication. So I'm going to come down
here and we'll just check for an Asterix and
124:26 - then down here we'll multiply them. So we're
able to basically capture the four types of
124:32 - arithmetic right and respond to them appropriately.
There's going to be one more situation though
124:36 - that we want to cover which is that they enter
in an operator that's not valid. So I'm just
124:41 - gonna say else. And remember, the code inside
of this else is only going to get executed
124:46 - when none of the stuff up here is true. So
when none of this stuff is true, in other
124:50 - words, if it's not plus sine minus division
or multiplication, we can just print out an
124:55 - error we can say put invalid operator And
that's basically going to give them a little
125:02 - error message like, Hey, you messed up, you
didn't put in the right operator. So we've
125:06 - essentially written out our program, we get
the three pieces of information, we check
125:10 - to see what operator they put in, and we respond
to it. So let's run our program and see how
125:15 - it works. Now remember, whenever we're running
a program where we need to get input from
125:19 - the user inside of Ruby, we're going to have
to use the command line. So normally, in this
125:24 - course, we've been using this little atom
plugin over here called atom runner. But now
125:29 - we're going to have to use the command line.
So I'm going to come down here and I just
125:32 - have one inside of my atom text editor. And
I'm just going to type Ruby draft.rb. That's
125:39 - the name of my file. And I'm just gonna click
Enter. And let's go ahead and use this little
125:44 - calculator. So it says enter the first number,
we'll enter in a five. And it says, enter
125:49 - the operator. So why don't we enter in a plus
sign, and it says, enter the second number.
125:53 - So let's enter in a six. When I click enter,
we should hopefully get the correct answer.
125:57 - So you can see down here, five plus six is
11. So our program actually work. That's awesome.
126:03 - All right, let's do it again. Let's try another
one. Why don't we try to do some multiplication.
126:09 - So enter the first number, we'll enter in
a five, and then we'll multiply by 8.65. And
126:15 - let's see, oh, wait, sorry, this is the operator.
So multiplication, we'll multiply it by 8.65.
126:22 - And let's see what we get 42.25. So yeah,
that seems about right. So our calculator
126:28 - is functioning correctly. And let's try one
more case where we enter an invalid operator.
126:33 - So I'm gonna run the program one more time,
enter in a four, and then we'll just enter
126:37 - in like a T as the operator and a five. And
okay, so it tells us invalid operator. So
126:44 - we have a four function calculator, we've
actually built an awesome four function calculator.
126:50 - What's cool about this calculator, is it's
able to respond to the operator that the user
126:56 - enters. And we can do that using if statements.
So this is one of those situations where if
127:00 - statements are just going to come in such
handy because they're so useful, right, we
127:04 - can check all these different conditions.
If one of them's true, we can do something
127:08 - if another one's true, we can do something
else. So this is kind of bringing together
127:12 - like getting user input and if statements
into one single program, which ends up being
127:16 - a pretty awesome calculator. In this tutorial,
I want to talk to you guys about case expressions
127:25 - in Ruby, a case expression is actually just
a special type of if statement that we can
127:31 - use to check a bunch of different conditions.
So we could use an if statement to check you
127:36 - know, to see if a bunch of different things
are equal to other things, or to check the
127:40 - values of different variables. But sometimes
when there's a bunch of different things that
127:45 - we need to check, we can use something called
a case expression. And it actually makes it
127:49 - a lot easier. So we're going to be creating
a method in this tutorial, which is going
127:53 - to map day abbreviations to day names. So
for example, each day of the week has an abbreviation
128:00 - like Monday is mo n, and that gets mapped
to Monday, right? Tuesday is t ue, and that
128:08 - gets mapped to Tuesday. Wednesday is W Ed
that gets mapped to Wednesday, etc, right?
128:15 - The abbreviations get mapped to actual full
days of the week. So I want to write a method
128:21 - that can take as a parameter, one input, and
it's going to be an abbreviation, and it's
128:25 - going to take that abbreviation and it's going
to spit out the actual name of the day. So
128:31 - if we pass it in an MLM, it'll spit out Monday,
and we pass in a fri it'll spit out Friday,
128:37 - right. And that's basically going to allow
us to convert these abbreviations into the
128:41 - actual days of the week. So let's go ahead
and do that. I'm just gonna define this method.
128:46 - So I'm just gonna say def. And we need to
also include an end over here and a method
128:52 - name. So why don't we call our method get
day name is going to be called get date name.
128:59 - And inside of here, we're going to pass the
abbreviation. So I'm just going to call this
129:03 - day and day is going to represent the three
letter abbreviation of the specific day, right?
129:11 - Make sense? Alright, so down here, what we
need to do is we need to convert day into
129:17 - the actual day name. So the first thing I'm
going to do is create a variable and we'll
129:21 - just call it day name. And we're going to
store whatever the day name ends up being
129:25 - inside of this variable. So I'm just going
to set this initially equal to the empty string.
129:30 - And then down here, right, before we end off
the method, I'm going to return day name.
129:36 - So our mission inside of this method now is
to give this date name variable, the value
129:41 - of the correct day, right? We need to give
it the name of the day that corresponds to
129:47 - this abbreviation. So one way that we could
do this would be using an if statement, right?
129:52 - So I can come down here and you know, hopefully
at this point you guys are familiar with if
129:55 - statements I could say like, if day is equal
to mo n Right, if Daisy with mo and then we
130:02 - can set the day name equal to Monday. Make
sense. But there's also a bunch of other conditions
130:09 - we have to check. So if that's not true, we
can check to see if the day is equal to Tuesday.
130:14 - And if that's true, then we can set the day
name equal to Tuesday. So for each day of
130:20 - the week, I can make a different Elsa frags,
like elsif, Daisy will do Wednesday, Thursday,
130:25 - Friday, Saturday. But here's the problem,
this is going to get really tedious and really
130:29 - messy really fast, right having to create
seven different if statements and you know,
130:34 - seven different else blocks, checking seven
different conditions, is going to be really
130:38 - difficult and tedious. And that's why Ruby
has something called the case expression.
130:43 - And essentially, what the case expression
does is it allows us to take a scenario like
130:48 - this, where we're comparing the same value
to a bunch of different values, and put it
130:53 - into a structure of its own. so in this situation,
in every single one of these conditions, we're
130:59 - comparing the day variable equal to another
value, right? In this condition, we're comparing
131:04 - it to Monday down here, we're comparing it
to Tuesday, we could also compare to Wednesday,
131:08 - Thursday, Friday, it's the same comparison
with a different value. In a situation like
131:13 - that case expressions are golden, they're
gonna help us out so much. So I'm going to
131:17 - get rid of this if block. And over here, we're
going to set up a case expression. So the
131:22 - way that I do this is just by typing out case.
And now I need to give this something so we're
131:28 - going to give this the value that we want
to compare to a bunch of different values.
131:32 - In our case, it's just day. All right, because
I want to compare day to month I want to compare
131:37 - data to like TV, I want to compare it to W
Ed th view, I want to compare it to all the
131:43 - day abbreviations. So we're gonna need to
end this off. Now inside of here, I can create
131:50 - something called a when statement. And a when
statement will basically do something when
131:55 - day is equal to a certain value. So I can
say when and now I can compare day to something.
132:01 - So I could say when mn and basically what
this means is, when de is equal to m o n,
132:09 - then down here, we're going to do something
so I can just put some code down here. So
132:13 - what I want to do is set day name equal to
Monday, because now we know they're trying
132:19 - to get Monday, I can make another one. So
I could say when T, we could say day name
132:27 - is equal to Tuesday. All right. So basically,
what we're doing is we're checking to see
132:33 - if day is equal to Monday. And if it is, then
we'll do this. If day is equal to Tuesday,
132:39 - then we'll do this, etc. So I can make one
of these for every single day of the week.
132:45 - And that's exactly what I'm gonna do. So I'm
going to go ahead and do that. And then we'll
132:48 - meet back here, and we'll talk about what
happened. Alright, so I went ahead and created
132:53 - one of these for every day of the week. So
we have 1234567 of these here. And each one
132:59 - of these is doing something when a different
condition is met. So when it's w Ed, or setting
133:06 - de named Wednesday, when it's fri we're setting
Danny to Friday, etc. So essentially, we're
133:11 - able to create like a complex if else structure,
but without having to like actually write
133:17 - all of it out, we can just say like when,
and it's automatically going to check this
133:21 - value with the value up here. So this can
be really useful. But there's actually one
133:27 - thing that we want to account for, there's
going to be situations where the user enters
133:32 - in an invalid day abbreviation. So if the
user enters in a valid abbreviations like
133:37 - su n or sa T, we can cover that right. But
what happens if they enter in something invalid.
133:42 - So what happens if they pass a parameter into
this get day name method that isn't an actual
133:49 - valid abbreviation? Well, we can use something
called the else keyword and the else keyword
133:55 - is a lot like the else keyword. And if statements,
I can just say else. And now anything that
133:59 - I put in here is going to execute when none
of these guys up here are true. So I can say
134:05 - down here else day name is equal to invalid
agree abbreviation, right? So I'm basically
134:14 - telling them, hey, you put an invalid abbreviation
in here. So this is going to get executed
134:20 - when there isn't a valid abbreviation. Alright,
so essentially, what I'm doing is, in each
134:25 - of these scenarios, I'm giving a name a different
value, then down here at the bottom of our
134:29 - method, I'm just returning deigning. So this
is a fully functional method. Hopefully everything
134:34 - works. Why don't we come down here and test
it? So I'm going to go ahead and just print
134:39 - out the answer that we get back. So I'm gonna
say puts, and then it's just called get day
134:44 - name. And we want to pass is an abbreviation
so I'm going to pass this mln for Monday,
134:52 - right? And when I pass it this and we run
our program. You'll see over here we print
134:57 - out Monday. So our program is giving us Back
to the correct answer. If I typed in sh t
135:03 - down here, then we should get back Saturday,
just like that. If I typed in th foo, then
135:10 - we're going to get back Thursday. So you can
see, we're getting back the correct value
135:14 - if I typed in something invalid, so if I typed
in like d o g, like dog now shouldn't yell
135:20 - at us. So it's gonna say invalid abbreviation.
And we were able to do this whole thing while
135:25 - keeping it nice and clean and nice and simple.
Like this whole thing only took me you know,
135:30 - less than a minute to write out. And I was
covering all of these different situations.
135:35 - So this can be extremely useful when you want
to check a single value, like de against a
135:42 - bunch of different values and do different
things, depending on the situation. So definitely
135:47 - consider using case expressions, here's the
thing, these aren't going to be appropriate
135:51 - in every situation. These are appropriate
for one specific situation, right, where we're
135:56 - checking the same value against a bunch of
different values. But that situation is very
136:01 - common. So when it does come up, don't be
afraid to use case statements, they'll make
136:05 - your life a lot easier. In this tutorial,
I want to talk to you guys about working with
136:13 - while loops in Ruby. So a while loop is basically
a structure that we can use inside of our
136:19 - Ruby programs, which will allow us to loop
through a particular block of code a specific
136:26 - number of times. So I can basically like write
out my while loop and I could put some code
136:30 - in there. And as long as a certain condition
remains true, I'll keep looping over and executing
136:36 - that same code inside that while loop. There's
a lot of situations in Ruby, where we're going
136:42 - to want to use loops, we're going to want
to do something continuously until we need
136:46 - to stop. And so while he was a great way to
do that, and in this tutorial, I just want
136:50 - to give you guys a broad overview of while
loops, we'll look at like the most basic type
136:55 - of while loop, you can write what it's talking
about the core concepts behind them. So over
137:00 - here, I can actually create a while loop and
the first thing I want to do is actually make
137:04 - a variable. And this isn't, you know, 100%
necessary when working with while loops. But
137:08 - you'll see how this variable comes in in a
second. So I'm just going to call the variable
137:12 - index, and I'm going to set it equal to one.
So we have a variable index, and it has a
137:17 - value of one, and down here, I can actually
create my wild. So the first thing I'm gonna
137:22 - do is just type out while and then what I
need to do is I need to specify a condition.
137:27 - And you always want to make sure that you
end these off. So I'm just going to put an
137:30 - end down here. Now here's basically how while
loops work all the code in between while and
137:36 - n. So all the code inside of here, that we're
going to put inside there is going to get
137:41 - continually executed. So it's going to keep
getting looped over and keep getting executed.
137:46 - As long as this condition is true. As long
as the condition that we specify right there
137:53 - is true, then we're going to keep executing
the code inside of this loop. So over here,
137:58 - I can actually specify a condition. So I'm
going to say while index is less than or equal
138:04 - to five. So essentially, what I'm saying is,
while index is less than or equal to five,
138:09 - I'm gonna keep looping through the code inside
of here. And actually what I can put in here,
138:13 - we can just put, you know, whatever code we
want to keep looping over. So the first thing
138:17 - I'm going to do is, I'm gonna take puts, and
I'm going to print out the value of index.
138:22 - So I'm say puts index, and then down below
here, I'm actually going to increment the
138:27 - value inside of index. So I'm gonna say index
is equal to index, plus one. So basically,
138:34 - every time through this loop, I'm printing
out the index. And then down here, I'm incrementing,
138:39 - the index. And actually, I want to show you
guys something that's cool we can do in Ruby,
138:43 - I have here index is equal to index plus one.
But I can actually instead of saying that,
138:48 - I can just say index plus equals one. And
whenever I say plus equals, you can also use
138:53 - minus equals, as well, this is basically just
going to add the number over here to index.
139:00 - So this is going to add one two index. So
that's kind of a little shorthand we can use
139:03 - in Ruby. But back to the while loop, this
is going to keep looping through the code
139:08 - inside of here, as long as the index is less
than or equal to five. So let's think about
139:15 - what's going to happen here. Actually, let
me just show you guys. So why don't we execute
139:18 - this code, I'm going to run the program. And
you'll see over here, I'm actually printing
139:22 - out values between one and five. So I'm printing
out 1234, and five. So maybe this is what
139:30 - you expect it to happen. Maybe it's not what
you expected to happen. Either way, I'm going
139:33 - to walk you guys through exactly what happened.
So over here, it says while index is less
139:39 - than or equal to five, so remember, we're
going to keep looping through this loop as
139:43 - long as that's true. So here's how the execution
of this program goes. Ruby creates this index
139:49 - variable gives it a value of one. The first
thing Ruby does when it gets to this while
139:53 - loop is it checks this condition. If this
condition is true, then it's going to start
139:58 - looping through. So in our case, this condition
is true, right? So Ruby is going to go ahead,
140:02 - it's going to print out the index, and it's
going to add one to it. Once Ruby has finished
140:07 - executing the code inside the while loop,
the next thing it's going to do is go back
140:12 - up here to the top of the while loop. And
it's going to check this condition again.
140:16 - So every time Ruby goes through this loop,
every time it loops through the code, right,
140:21 - it's going to go back up, and it's going to
check the condition again. So every time through
140:26 - the loop, we're constantly checking the condition.
So in this case, we incremented I, we incremented
140:30 - the index, so the index is now equal to two,
which is less than or equal to five. So we're
140:35 - good to go. Right, that condition is true.
So now we'll execute all of the code inside
140:39 - of here again, and then again, we're going
to come back up and check the condition. So
140:44 - every single time we're going, we're checking
that condition, eventually, index is going
140:49 - to be equal to six, right, we're going to
get to a point where, you know, index was
140:54 - equal to five, so we printed it out, and then
we added one to it. So now index is equal
140:58 - to six, we're going to loop all the way back
up here. And suddenly, this condition is going
141:04 - to be false. And when this condition is false,
we're going to break out of the loop, so we're
141:08 - not going to execute it anymore. And we're
just going to move on to the next line of
141:11 - code. So that's basically how while loops
work, we specify a condition. As long as that
141:17 - condition is true, we move on. And that's
how we can get this output right here. So
141:22 - for example, if I was to change this to like
eight, now we're going to print out one through
141:27 - eight, because the condition is only false
when we get to nine, right, so we're printing
141:32 - out a times essentially. So this is extremely
useful. There's tons of situations where we're
141:37 - going to want to use while loops like this.
Now, I want to point out one potential problem
141:41 - that you're going to have with wild loops,
and it's basically called an infinite loop.
141:46 - And an infinite loop is a situation where
the condition up here never becomes false.
141:52 - So it just loops through infinitely. And this
is something that could actually mess up your
141:56 - programs quite a bit. So you always want to
make sure that when you're writing a while
142:01 - loop, that eventually the condition up here
is going to be false. Now in certain special
142:06 - circumstances, you actually want to use an
infinite loop. But I'd say for most cases,
142:11 - especially as a beginner, you're not going
to want to infinite loop. So it's just something
142:14 - to keep in mind. But this is where the basics
of a while we're specifying a condition, as
142:18 - long as that condition is true, we're going
to keep looping through whatever code is inside
142:23 - of here. So like I said, there's tons of ways
for us to use this. And in the next lesson,
142:28 - we're actually going to build a program where
we're going to use a while loop in order to
142:32 - build a little game. So stick around for that,
that's gonna be pretty fun. In this tutorial,
142:39 - I want to talk to you guys about building
a guessing game and Ruby. So we're actually
142:43 - going to build a little game. And it's basically
a game where the user can try to guess a secret
142:49 - word. So we'll continually prompt the user
to guess a secret word. And if they get it
142:54 - right, then they'll get a success message
like, Hey, you got the word right, and they
142:58 - get it wrong, then we'll let them keep guessing.
So they'll be able to keep guessing what the
143:01 - word is until they get it right. And this,
this would be kind of cool. And this will
143:04 - show us how we can use something like a while
loop in order to build a little game. So down
143:10 - here, first thing I want to do is create a
couple variables, the first variable I want
143:15 - to create is going to be the word that the
user has to guess. So remember, we're creating
143:20 - a guessing game. So we need to store a variable
that has the word in it, right. So I'm going
143:26 - to say, secret underscore word. And this is
just going to store that secret word. And
143:31 - I'm just going to set this equal to draft.
So you know, this could really be anything
143:35 - you want, whatever the secret word is going
to be for our game. And finally, I want to
143:40 - create one more variable, this is going to
be called guests. And we're just going to
143:43 - set guests equal to the empty string for now.
So I have two variables, secret word, and
143:48 - guests. And now that I have these two variables,
I basically want to create a while loop. And
143:53 - I'm gonna create a while loop that's going
to continually loop through and ask the user
143:58 - for input. So I'm just going to say while
and over here, we need to specify a condition.
144:05 - So again, this while loop is going to keep
asking the user to input the secret word.
144:11 - And as long as they don't get the secret word,
right, we're gonna keep asking them. So I'm
144:15 - basically going to say while guess, is not
equal to secret word. So as long as the users
144:24 - guess, isn't equal to the secret word, we're
going to keep looping. So down here, what
144:29 - I want to do is print out a prompt, so I'm
just gonna say puts, and we're just gonna
144:34 - say enter your guess. So this is going to
prompt the user to enter a guess. And what
144:42 - we want to do now is we want to store whatever
the user guesses inside of this guests variable.
144:48 - So I'm just going to say guess, is equal to
get dot shop. And remember, chomp is basically
144:55 - just going to get rid of that new line at
the end of whatever user enters. So essentially,
145:02 - what's happening here is, while they, the
user hasn't guessed correctly, while their
145:07 - guests isn't equal to the secret word, we're
just going to prompt them again for the guests
145:12 - and the guests is just going to get equal
to whatever the user types in. So eventually,
145:17 - what's going to happen is they're going to
guess the word correctly. And when they do
145:21 - guess the word correctly, then this condition
is going to be false. So we're going to come
145:26 - down here, and we'll basically just print
out a success message. So I'll just say, like,
145:31 - puts you one. Alright, so this is a pretty
simple program. But you'll see this actually
145:35 - allows us to build a guessing game inside
of Ruby. So whenever we are getting input
145:41 - from the user in Ruby, we always want to do
it through the terminals or through the command
145:46 - line. So I'm going to go ahead and open up
my command line down here. And I'm going to
145:50 - run our program. So it's just called draft.rb.
So I'm just going to type Ruby draft.rb, and
145:57 - this will start executing our program. So
down here, you can see it's asking us to enter
146:02 - a guest. So I'm going to come down here, and
I'll enter a guest. So why don't we just enter
146:07 - in some nonsense. So you'll notice as long
as I don't guess the word correctly, as long
146:12 - as I'm not entering in the correct guests,
the program keeps prompting me to enter a
146:17 - guest right keeps asking me to do that. But
here's the thing, if I was to come down here
146:22 - and actually enter in the guest correctly,
so if I typed in, like draf, now we should
146:29 - get a success message. So when I click enter,
you'll see it says you won because we entered
146:35 - in the secret word correctly. So obviously,
this is a very simple program, but it actually
146:39 - works pretty well. And it does everything
that we want it to do. This is a very simple
146:45 - game. And one of the problems with this game
is that the user gets unlimited guesses, they
146:49 - can keep guessing the word forever until they
get it. And that's not the makings of a good
146:54 - game, what would be better is if we imposed
some sort of a guess limit on them. So they
146:59 - can only guess the word a certain number of
times, otherwise, they lose the game. So let's
147:05 - go ahead and see if we can add that functionality
into our program. In order to do that, I'm
147:11 - going to have to create a couple more variables,
the first variable I want to create is going
147:16 - to be called guest count. And guest count
is going to basically tell us how many times
147:21 - the user has tried to guess the word. So I'm
gonna create a variable guests underscore
147:25 - count. And I'm just going to set this equal
to zero, because initially, the user won't
147:30 - have guests. So the guest count will just
be zero. Now down here, every time the user
147:36 - guesses, I want to increment the guest count.
Right? So down here, basically, this code
147:42 - means that the user has tried to guess the
word. So every time they do that, I want to
147:46 - increment the guest count, I just want to
say guess, count, plus equals one. And this
147:52 - will add one on to the guest count. So every
time they guess we're going to increment that.
147:58 - And I want to create two more variables. The
first one is going to tell us how many guesses
148:03 - the user can actually take. So it's going
to be called gas limit. And why don't we just
148:08 - say the user has three guesses. So three strikes
and you're out, so they can't guess the word
148:13 - and three tries, then they're going to lose
the game. Alright, finally, I want to create
148:17 - one more variable. And this variable is going
to tell us whether or not the user is out
148:22 - of guesses. So I'm just going to say out of
guesses, is equal to false. Because Initially,
148:32 - the user is going to have three guesses right?
When the user reaches their guests limit,
148:37 - we're going to set this out of guesses variable
equal to false. And then we'll be able to
148:42 - tell the user like hey, you lost the game.
Alright, so now that we've created these variables,
148:46 - I'm just going to come down here. And inside
of this while loop, we want to modify a couple
148:50 - things. The first thing I want to do is every
time we ask the user to guess the word, I
148:56 - want to make sure that they're not out of
guesses. In other words, I want to make sure
148:59 - that they haven't reached the gas limit. So
I'm going to use an if statement. To do that
149:04 - inside this while loop. The first thing we're
going to do before we do anything else is
149:07 - just say if. And we want to check to make
sure that the guest count is less than the
149:12 - guest limit. So I'm going to if guess count
is less than guess limit. In other words,
149:22 - if the guest count is less than the guest
limit, then we know they have guesses left,
149:26 - right, we know that they have a certain number
of guesses left and they should be able to
149:30 - keep guessing the word. So if this is true,
then I want to allow them to guess the word.
149:36 - So I'm just going to take all this code, and
we're going to move it up here. Alright, so
149:40 - if the guest count is less than the guest
limit, if they have more guesses, then we're
149:44 - gonna do all of this. Otherwise, though, in
the situation where the guest count isn't
149:51 - less than the guest limit, then we know for
a fact that the user is out of guesses, right?
149:57 - If they that means they have no more guesses.
So inside of this else statement, what I want
150:01 - to do is I want to set that out of guesses
variable equal to true. And basically, this
150:08 - will tell our program like, hey, the users
don't, they're out of guesses, right? We check
150:13 - to see if they were eligible for another guess.
And if they weren't, then we're going to say
150:18 - out of guesses is equal to true because they
ran out of guesses. All right, there's one
150:23 - more thing we have to do inside of this while
loop. And we have to actually modify the while
150:27 - condition. So over here, you can see we have
our little condition. And we're going to keep
150:32 - looping while the guess is not equal to the
secret word. But now that we've imposed the
150:38 - guessed limit, there's actually one more situation
that's going to cause us to stop looping,
150:43 - which is when the users out of guesses. So
I want to say I want to keep looping as long
150:48 - as the guest is not equal to the secret word.
And as long as the user is not out of guesses,
150:54 - so and not out of guesses. So we're going
to keep looping through this loop, we're going
151:02 - to keep asking the user to input information,
we're going to keep doing all the code down
151:08 - here, as long as the gas is not equal to the
secret word. And as long as the user is not
151:14 - notice I'm using this exclamation point here,
out of guesses, right. So now we have our
151:21 - while loop set up, right, we're able to loop
through here. As long as the user has guesses
151:26 - left, there's one more thing we have to do
down here. So before we just put you one,
151:33 - right before, if the user exited out of that
while loop, that means they guessed the word
151:38 - correctly. So we knew for a fact that they
won. But now that we're imposing the gas limit,
151:44 - there's actually two situations where the
user could exit out of the loop. The first
151:47 - situation is where they got the word right,
in which case they won. The second situation,
151:51 - though, is that they ran out of guesses. And
if they ran out of guesses, we don't want
151:55 - to tell them they won, we want to tell them
they lost. So we can actually check to see
151:59 - which situation caused that loop to end, I
can just say if. And I want to check to see
152:06 - if they're out of guesses. And if they are
out of guesses, and I'm just going to print
152:11 - out, you lose. But otherwise, if they're not
out of guesses, that means that they were
152:19 - able to guess the word correctly within the
certain number of guesses. So they win. So
152:24 - this is our basic program. And let's go ahead
and test it and see if it works. So again,
152:28 - I'm going to open up the terminal. And over
here, I'm just going to run the program. And
152:32 - actually, it looks like I'm getting an error
here. Yeah, so I forgot to put an end statement
152:37 - down here. I always forget to do that. So
always make sure that you put an end statement
152:41 - down here. And now we'll be able to execute
our program correctly. So here we go. Alright,
152:48 - so it says enter a guest. So why don't we
just try to lose the game. So I'm just going
152:52 - to enter in one guest. Two guesses. Now I'm
on my third guest. So this is my last try
152:57 - if I don't get the secret word on this time,
or lose the game, so we're going to not get
153:01 - it and it's going to say you lose. So the
program is smart enough to figure out that
153:05 - not only did we run out of guesses, but also
that we lost. So let's try it now. But we'll
153:10 - try to win the game. So over here, I'm gonna
make a random guess another random guess.
153:17 - So now we're on our last try, it's our last
chance to get the guests I'm going to type
153:21 - in the secret word, which is draft. And now
the program is going to tell us Hey, you won.
153:27 - So we were able to win the game because we
guessed within the guest limit. So that is
153:33 - basically this program. I know this is a lot
of codes, I'm just going to step through with
153:37 - you guys one more time just to kind of do
a broad overview of what we did. That way
153:41 - you can get a better idea of what's going
on. So we have these two variables, secret
153:45 - word and guess. And these two are pretty obvious,
right? The secret word stores the word that
153:49 - the user needs to guess, guess is going to
end up storing what the user guesses each
153:54 - time through that loop. Right. So we're going
to keep looping through this loop as long
153:58 - as the guest is not equal to the secret word.
And down here, we're basically going to store
154:04 - whatever the user guesses inside of this guest
variable that was like the basic game that
154:09 - we built. Then we added these three new variables
and guest count guests limit and out of guesses.
154:15 - Guest count is basically going to tell us
how many times the user has guessed. And so
154:20 - every time the user guesses, we're going to
come down here and we're going to increment
154:23 - it, right? Guess limit is going to tell us
how many times the user can guess in other
154:28 - words, how many guesses they have available
to them. And you'll see down here we're using
154:33 - this if statement. So we're checking to see
if the guest count is less than the guest
154:37 - limit. If that's true, if they still have
some guesses left, then we're going to execute
154:42 - all this code will let them guess. Otherwise,
though, we're going to use this out of guesses
154:47 - variable, and we're going to set it equal
to true. That's going to tell our program
154:51 - that the user is out of guesses. Up here we
also added another condition inside of our
154:56 - while loop so we're saying while the guest
is an equal to the secret word And while the
155:01 - user is not out of guesses, so that's going
to allow us to control what happens in this
155:06 - loop. Then finally down here, we're checking
to see if they're out of guesses. So down
155:11 - here, there was two situations. The first
situation was when the user ran out of guesses,
155:16 - so they lost the game. And if that's the case,
we're just going to print out you lose. Otherwise,
155:20 - we'll print out you one, stop the basics of
building our guessing game. So now your homework
155:25 - is to go off and build a guessing game of
your own. In this tutorial, I want to talk
155:33 - to you guys about four loops in Ruby. Now
a for loop is basically a structure in Ruby
155:38 - that allows us to loop through a specific
collection. So that could be a collection
155:43 - like an array, it could also be a collection
of numbers, basically allows us to loop through
155:48 - a connection, a collection, and for each item
inside the collection, we can do something.
155:53 - And actually, in this tutorial, we're not
just going to be talking about for loops,
155:57 - we're going to be talking about a broad range
of different loops, and looping structures,
156:02 - which we can use to loop through different
things. Essentially, in Ruby, there's a lot
156:06 - of different ways we can do the same thing.
And I'm going to be showing you guys a bunch
156:09 - of different ways to do essentially the same
thing. So the first thing I want to show you
156:13 - guys is I have this array set up up here.
And it's basically just called friends. And
156:17 - it has a bunch of items in it, you know, basically
just a list of someone's friends. And I want
156:22 - to show you guys how we can use a for loop
to actually loop through all of the items
156:26 - inside of this friends array. And remember,
if I wanted to access a specific item, I could
156:31 - just say friends, and then pass an index.
And so if I said friends, one, this is going
156:35 - to print out care and onto the screen, right.
So that's kind of how I can access an individual
156:39 - element. But I can also use something called
a for loop. And I can say for friend, in friends,
156:48 - and then down here, I also want to end this
off. So I'm just going to put end, and inside
156:53 - of this little for loop, I can just say puts
friend, and what this is going to do is it's
156:59 - actually going to print out all of the friends
inside of this friends array. So now when
157:06 - I run this program, you'll see we're printing
out all of the values inside of that array.
157:11 - And essentially, what I'm doing is I'm saying
for and I'm specifying the name of a variable.
157:17 - And on every iteration of this for loop, this
friend variable is going to represent a different
157:22 - friend. So on the first iteration, it'll represent
Kevin, on the second iteration on represented
157:27 - care, etc. And I can actually name this whatever
I want it. So I can just say element. And
157:32 - down here, I could print out element, and
it doesn't actually matter. So it's all going
157:38 - to be the same. So that's a really easy way
that you could loop through all the elements
157:43 - in an array. So for each element inside the
array, you could basically do something and
157:48 - really friends could be this could refer to
any collection inside of Ruby is basically
157:53 - just a general way to loop through a collection
of elements. So this can be really useful
157:57 - when we're dealing with arrays, there's also
another way that we could do essentially this
158:01 - same thing. So instead of having this for
loop, I could just say friends, dot each,
158:07 - and I can say do and then I want to make two
like little vertical bars right here. And
158:12 - I'm just gonna pass in the same thing as we
did before, like a variable. And this variable
158:17 - is going to represent a specific friend on
each iteration of this loop. So then down
158:21 - here, again, we can just say and, and over
here, I can just print out a friend. And so
158:29 - now it's doing the same thing as we did before,
we're printing out each one of the friends
158:33 - that was inside of that array. And again,
I could, this doesn't have to be friend, this
158:36 - could be anything I want. So that's basically
how we can loop through like an array a couple
158:41 - different ways. There's also another thing
we can do, we can loop through a range of
158:44 - numbers. So I could specify that I want to
go through a loop and go through the code
158:49 - a specific number of times. So I can come
down here and I could say like, for index
158:55 - in, let's say zero to five. And I want to
do something, so I could just print out the
159:02 - index, this is basically just going to loop
through this loop five times. So you'll see
159:07 - over here, it prints out actually I guess
it loop through six times. So it prints out
159:13 - 01234 and then five, so it's going to loop
through from zero to five. And a lot of times
159:19 - in a lot of cases, you're going to want to
go through a loop a specific number of times,
159:24 - and you can do it just like that. There's
also another thing we could do, we could say
159:27 - like we could specify a number here, so I
can say like six, and I could say dot times
159:32 - do. And inside of these vertical bars, I can
just say like index. And again, this doesn't
159:39 - have to be called index, this can be called
anything we want. And here it's the same thing.
159:43 - So this is going to loop through something
six times. So over here, we're printing out
159:48 - zero through five. So these are all basically
different ways that we can loop through other
159:53 - collections or we can loop through something
as specific number of times in Ruby and this
159:58 - can come in handy a lot. In this tutorial,
I want to talk to you guys about building
160:06 - an exponent method in Ruby, one of the things
I wanted to show you guys was how we can use
160:11 - something like a for loop in order to write
a little method. And I think one method that
160:16 - could be kind of cool to see how we might
be able to write it would be an exponent method.
160:20 - So an exponent method would basically take
two numbers, it would take a base number,
160:24 - and it would take a power number, and then
it would basically take the base number to
160:28 - the power number. So if we passed in like
a two and a three, then this would basically
160:34 - give us like to raise to the third power has
essentially like what this method is going
160:39 - to do. And let's just go ahead and create
it. So I'm just gonna say def. And why don't
160:45 - we just call this POW for like power, so it'll
take a number to a specific power. And then
160:52 - inside of these parentheses, we actually want
to have this method accept two parameters
160:56 - as input. So we want the base num, and we
also want the pound num. So the base number,
161:04 - and that's going to be taken to the power
number. Okay? All right, let's end off this
161:08 - method. Now, inside of here, we need to figure
out how can we actually do this, you know,
161:14 - how can we take the base number to the power
number, and my solution would be to use a
161:19 - for loop, the first thing I'm going to do
actually is create a variable. So I'm just
161:22 - going to call this result and I'm going to
set this equal to one, and then down here
161:27 - right before the end of the function, we're
just going to return it, so I've just returned
161:32 - result. So ultimately, this variable result
is going to represent the value of the base
161:37 - number taken to the power number. So let's
use a for loop, essentially, what I want to
161:42 - do is I want to multiply the base number by
result, power num times that makes sense.
161:50 - So let's flesh out this for loop. And then
we'll kind of see how it's going to work.
161:53 - So I'm going to save this, I'm going to say
POW num dot times do. And basically what we're
162:01 - going to do now is we can actually just pass
this an index. Now I don't know if we're gonna
162:06 - actually use this index, but it might be good
just to pass it in anyway. And down here,
162:10 - I'm just gonna end this off inside of this
little loop here, we're basically just going
162:14 - to multiply result times the base node, so
I'm just gonna say result is equal to result
162:21 - times base node. So essentially, what's happening
is pow, num dot times do index, this is essentially
162:30 - just going to loop through the code inside
of here power num times. So if power num is
162:35 - three, we're going to loop through this code
three times. If power num is 10, we're going
162:40 - to loop through this code 10 times. And every
single time we go through this code, we're
162:44 - gonna multiply the result times the base num.
So the first time through the loop, it's just
162:49 - going to be resolved, which is one time as
base num, so results gonna end up just being
162:53 - based on second time through, it's gonna end
up being like base num squared. Third time
162:59 - through, it's gonna end up being like based
on q. So this is essentially how we can go
163:04 - ahead and write this method. Now it's important
to note that this is only going to work for
163:08 - positive number exponents. So if power num
is a negative number, then this method is
163:12 - actually not going to work. But just for our
purposes, In this tutorial, let's just assume
163:17 - that we're always going to use a positive
exponent. So once we've multiplied result
163:22 - times, based on as many times as we need to,
then we can just return it. So believe it
163:27 - or not, this is actually all we need for this
method to work. So let's go ahead and call
163:34 - this method and we'll see what we get. So
down here, I'm actually just gonna print this
163:38 - out. So I'll just print out pow, and why don't
we take two to the third power. Okay, so let's
163:45 - run this. And you can see over here, we get
eight. So two cubed is eight. Let's try another
163:50 - one. Why don't we do four cubed. So now we
should get 64. Good. Let's do five squared.
164:00 - So we should get 25. And we do so looks like
this methods working. So again, this is going
164:05 - to work for positive number exponent. Now
you remember exponents, this won't handle
164:11 - it. But for our purposes, this kind of demonstrates
how we can use a little for loop or in this
164:16 - case, we're just saying power num times in
order to loop through something a certain
164:20 - number of times. And this can be extremely
useful when we want to do something like this.
164:25 - And also I just want to point out over here,
I had kind of stored this variable index.
164:29 - But you don't actually have to do that. And
in this case, we don't need it inside of this
164:33 - method, but it's not as good to just have
it there. So that's to kind of give you an
164:37 - idea of like a situation where we might be
able to use one of these looping structures
164:42 - in order to like perform a function. In this
tutorial, I want to talk to you guys about
164:50 - comments in Ruby. A comment is basically a
little line of code that Ruby is actually
164:56 - going to ignore. So a lot of times when we're
writing our Ruby program There's going to
165:00 - be situations where we want to leave like
little notes, or really just little comments
165:04 - inside of our files. And a comment is exactly
that. It's just a little line of code, a little
165:09 - line of text that is meant to be read by humans.
So if you're writing a Ruby file, you can
165:14 - leave a little comment. And then when you
come back later, you can read the comment
165:18 - or another developer who's looking at the
file can read the comment. And you can basically
165:21 - communicate information that's outside of
just the actual code in the file. And there's
165:26 - a lot of situations where comments are going
to be useful. The basics of making a comment
165:30 - is you essentially go to a line of code, and
you can use this hashtag symbol. And anything
165:35 - that you put after this hashtag symbol is
going to be in the comments. So you'll notice
165:39 - that my text editor is actually styling this
a little bit differently. So if I was just
165:43 - to come down here and type out some random
text, you can see that this is actually going
165:47 - to get rendered by the program. But if I put
random text over here, after this hashtag,
165:53 - this is going to be considered a comment.
So I can basically write any plain text over
165:58 - here. And when I run the program, you'll notice
that nothing gets printed out, you know, that's
166:03 - inside of this comment block. So like I said,
comments are really useful for leaving little
166:07 - messages or little reminders inside of your
programs. You can also put comments after
166:12 - lines of code. So for example, here, we have
just a line of code. If I wanted after this
166:17 - line of code, I can put my hashtag. And I
could type a comment after here. And this
166:22 - is something that you'll see a lot in programs
like people will include comments either after
166:26 - lines of code, or directly above lines of
code. And a lot of times people will use comments
166:31 - in order to like describe what a line of code
is doing. So I can say like, this line prints
166:37 - text. So obviously, you know, it's pretty
obvious what this line is doing. But if I
166:41 - wanted, I can put a comment there. Another
thing that comments are used for is commenting
166:46 - out code. So there's going to be certain situations
when you're programming where you might want
166:51 - to run your program, but without a specific
line of code. So if you have like this whole,
166:56 - you know, big method, and you want to see
what your program would be like without a
167:00 - specific line, Well, one thing you could do
would be just to erase the line of code, right,
167:05 - you could get rid of it, and you can go ahead
and you can run the file. And, you know, basically
167:10 - the codes gone. But the problem with that
is you have to physically delete the line
167:13 - of code, a better way would be just to come
over here and right before the line of code,
167:18 - we can put a comment there. And this is what's
called commenting out a line of code. And
167:23 - a lot of times developers we'll use this to
basically temporarily, like disable a line
167:28 - of code. So now when I run the program, we're
not printing out comments or fun anymore,
167:34 - because it's commented out. And the great
thing is when I want this line of code back,
167:37 - I can just get rid of the comment and we're
back in business. So real really a comment
167:42 - is just kind of like open for business, like
whatever you want to do with it, whatever
167:45 - you you know, you think you can accomplish
with a comment, you can go ahead and do that.
167:50 - A lot of times people will also put comments
on multiple lines. So you'll see some people
167:54 - they'll have like, you know, line one of a
comment and then down here, they'll make another
167:59 - hashtag will have line two. This is one way
that you can put comments on multiple lines.
168:05 - And honestly, this would probably be the recommended
way like the most, you know, Ruby asked way
168:09 - to do it. There is another way that we can
do this, though. So yeah, like I said, normally
168:14 - with these hashtags, like it only applies
to the one line, right. But if you wanted,
168:20 - you could create a comment block and all you
have to do is just say equals begin. And then
168:25 - wherever you want the comment block to end
you can just say equals end. And it's important
168:29 - to know that these can't have any whitespace
before them. So you see if I put waste whitespace
168:33 - there, it disables the comment. So down here,
you can just type whatever you want inside
168:38 - of the comment. And it will be rendered as
a comment. But like I said, I think probably
168:43 - a cleaner way to do it is just to put a hashtag
on every line, especially you know, if you're
168:47 - moving to other programming languages, a lot
of other programming languages will do stuff
168:51 - like this. So you know, just something to
keep in mind. One final thought about comments,
168:57 - you want to use comments only when they're
absolutely necessary. You know, comments,
169:01 - if you have too many of them and they're too
active in the document. A lot of times they
169:06 - can be a little bit distracting. Generally,
your goal should be to write code that is
169:11 - as readable and clean as possible, so that
you don't need comments to explain it. But
169:16 - a lot of times a comment can come in handy.
So if there's a situation where you think
169:20 - you need to comment, don't be afraid to put
one in. In this tutorial, I'm going to show
169:27 - you the basics of reading from an external
file in Ruby. And one of the useful things
169:33 - we can do with Ruby is we can actually read
from external files that are on our computer.
169:38 - So if I had like a file that was on my computer
somewhere I could actually read from that
169:42 - file inside of my Ruby program. So I'm gonna
show you guys how to do that I actually created
169:48 - a txt file over here. It's in the same directory
as this draft dot Ruby file. It's called employees
169:54 - dot txt. So I'm going to open that up. And
you can see over here it's just a very simple
169:59 - text file. have employees. So these might
be like employees at an office or you know,
170:03 - whatever we have, you know the name. And then
we have the position. So Jim is in sales Andes
170:08 - and sales creed is in quality assurance, basically
just says their names. And then it says what
170:14 - they do so their jobs. So this is a, you know
an example of maybe a text file that you might
170:19 - want to read from inside of your Ruby files.
So I'm going to show you guys how we can read
170:23 - from this file over here in my program, I
have to use a special command. So I'm just
170:28 - going to say file dot open. And now I'm going
to make an open and closed parentheses. And
170:35 - so inside of this open and close parentheses,
I want to give this a couple of different
170:40 - parameters, the first one is going to be the
name of the file, in my case, I have this
170:45 - file stored in the same directory as this
Ruby file. So I can actually just put in the
170:50 - name of the file, so I can say, employees
dot txt, but if this isn't in the same directory
170:57 - as the Ruby file, you're gonna have to include
either a relative path in here. So for example,
171:02 - if it was in a directory called like files,
I could say, forward slash files, or, you
171:07 - know, files forward slash, or you're gonna
have to include an absolute path that starts
171:13 - at your hard drive. So that would be if you're
on Windows, it could be something like C,
171:17 - you know, users whatever. So basically, it's
some sort of path to the file, or if it's
171:23 - in the same directory, you can just put the
file name. And we also need one more parameter
171:27 - in here, which is going to be the mode that
we want to open the file. And so when you
171:32 - open a file in Ruby, you can actually open
it in a couple different modes. And there's
171:37 - maybe like six or seven different modes that
you can open files in, the one we're going
171:41 - to be using is called read. So I'm just going
to type an R in here. And that's going to
171:45 - tell Ruby that all we want to do is read the
files, we don't want to modify it, we don't
171:50 - want to write to it, we don't want to overwrite
it, we just want to read it. And now what
171:52 - I can do is I can say do, and over here, I
can make two open vertical bars, and I'm just
171:59 - gonna say file. And basically what this is
doing is it's storing this file that we just
172:06 - opened inside of this file variable. So I
now have a variable called file, which will
172:12 - represent the file that we just opened. And
basically, what I want to do is I want to
172:15 - come down here and down below here, I basically
just want to say, and so this is one way that
172:23 - we can open up a file. And I think for a beginner,
this is probably the easiest way to do it.
172:27 - So you just say file dot open the name of
the file, the mode, in our case, our do and
172:32 - then this is now going to store this file
inside of this variable. So whenever we want
172:37 - to do with this file, we can do inside of
here. And the reason that we need this END
172:42 - block is because this n block is going to
signify when we're done working with the file.
172:47 - And when we're done working with the file,
it's just going to go ahead and close the
172:50 - file. So we're not going to be using it anymore,
we're not going to have it open anymore. So
172:55 - this is going to be good just as a beginner
just to kind of, you know play around with
172:59 - working with and reading from files. So inside
of here, we can use this file variable that
173:04 - we created over here, and we can actually
do some stuff. So the first thing I could
173:09 - do would be just to print this out. So I can
just say puts file. And now you'll see over
173:15 - here on the screen, it's printing out like
all this information. This is essentially
173:19 - like some like metadata about our file. It's
basically like how it's stored in Ruby. But
173:25 - if we want, we can read the file, so I can
say puts file dot read. And now we're going
173:30 - to get all the information in the file. So
you see we're printing out all the different
173:33 - names all the different employees from our
file. So read is basically just like you're
173:39 - reading the entire file. And if you want,
you can use any sort of, you know, string
173:43 - methods on this, I mean, this is basically
just giving us a string. So I could say like
173:47 - read dot includes, or include, and, you know,
we could see if like someone in there is named
173:53 - Jim or whatever. And we get true back so that,
you know, essentially, this is just giving
173:57 - us a string with all the information in the
file. There's also another thing which we
174:02 - can do, which is called read line. And read
line will basically read a line from the file.
174:08 - So if I print out file dot read line, it's
going to read the first line of the file.
174:13 - But what this is actually going to do is it's
going to read the first line, and then it's
174:16 - basically going to say like, Okay, now we're
on the second line. So let me show you guys
174:21 - what that means. So if I was to copy this
line, and paste it down here, this is going
174:26 - to print out the first line of the file, and
then this one's going to print out the next
174:29 - line in the file. So you'll see when I run
this, it prints out Jim and then Andy. So
174:35 - every time we read the line, we're basically
telling the file that we want to move on to
174:38 - the next line. So this is a good way if you
want to read like each line individually.
174:42 - You can also do the same thing but with the
characters. So I could say read char and then
174:47 - down here I could also say to recharge and
instead of reading the individual lines, this
174:53 - is just going to read the different characters
inside the file one by one so now we'll be
174:57 - able to print out Jim yeah So recharging and
relying can both be really useful. Like as
175:03 - you go through a file, there's one more I
want to show you, which will allow us to loop
175:07 - through all of the lines in the file. And
then for each line in the file, we can like
175:12 - do a specific thing. So I can do is I can
actually say, for line in file dot read lines,
175:22 - and read lines is a little method, which is
basically just going to return an array of
175:29 - all of the lines. So actually, let me show
you guys what this is going to give us, I'm
175:34 - going to print this out. So I'm going to print
out file dot read lines. And you'll see it's
175:39 - just printing out all the lines in the file.
But this is actually stored as an array, so
175:43 - I get access. Like, if I wanted the third
line in the file, then I'll be able to access
175:49 - it like that. So we can loop through this
array, like you would normally loop through
175:52 - an array. So we could say like for to line
in file dot read lines. And down here, we
175:59 - can just put some code that we want to do
for each line. So I mean, obviously, I could
176:03 - just print them out. So I could say put line.
And this will print out every line. But in
176:08 - here, we can modify the line, we can look
through it, we could do anything we wanted
176:11 - to each individual line in the file. And here's
the thing, you know, these are just sort of
176:17 - the basics. You know, I mean, this is everything
that you need to basically take a file, you
176:21 - know, a text file, loop through every line,
and then you're basically just given a string.
176:26 - So this line over here, I mean, these are
all just strings in our program. So you know,
176:31 - you can use all the different string methods
to parse through those lines to figure out
176:35 - what they're saying, get information from
them. And, you know, really, it's honestly
176:39 - super easy to actually read from a file. So
I would say that's all like the main, you
176:44 - know, those are sort of like the most popular
the most commonly used methods when we're
176:49 - talking about files, I also do want to show
you another way that we can open a file. So
176:53 - you see over here, we said file, dot open
the name of the file, and then we did this
176:58 - whole, like do file thing. There's another
way that we could actually do this. So instead
177:03 - of saying this stuff over here, I could actually
just store this in a variable. So I can say
177:08 - like file is equal to all of this. And we
can do exactly the same stuff we did before.
177:13 - So I could say like, puts file dot read and
will still be able to print out all the contents
177:18 - of the file. The only thing with this though,
is whenever you create a file like this, you
177:23 - always want to make sure that you close the
file when you're done with it. Closing the
177:26 - file basically means you're saying that you're
done with the file. So you don't want to leave
177:30 - a bunch of files like open and in memory.
So if you can just say file dot close, and
177:36 - this will go ahead and close the file. And
you won't have to worry about it like taking
177:40 - up any more space in your program. But that's
really the basics. And you know, you can really
177:44 - just sort of go from here, right? practice
playing around reading different files, practice
177:49 - reading different types of files, these can
be, they don't just have to be text files,
177:52 - they can be any type of file. In this tutorial,
I want to talk to you guys about writing to
178:01 - files in Ruby. One of the cool things about
Ruby is we can read files, but also we can
178:06 - write file, so I can actually write information
out to a file. And I can do that right inside
178:12 - of my program. So in the last tutorial, we
talked a little bit about reading files. So
178:16 - we kind of opened up a file here, we opened
up employees dot txt, which was just this
178:21 - text file that had a bunch of like, I don't
know, employees and a company in it. And we
178:26 - basically stored that file inside this file
variable, we could do all sorts of stuff with
178:31 - it. Now I want to talk to you guys about actually
writing information to files. And the first
178:36 - thing I want to kind of talk to you guys about
are the different file modes. So different
178:40 - ways that we can open up a file, you'll see
over here, I'm passing in two arguments to
178:44 - this open method, I'm passing in the name
of the file, obviously. But then over here,
178:49 - I have this little r. And this is basically
a file mode. So this kind of tells Ruby, like
178:55 - when we're opening the file, it kind of gives
Ruby an idea of like what we want to be able
178:59 - to do with it, right? If I say R, this stands
for read, but there's actually a bunch of
179:03 - other ones. So I'm gonna head over here to
my web browser. And I'm just on a Stack Overflow
179:08 - page. And I think this actually gives a pretty
good explanation of all the different file
179:13 - modes in Ruby. As you can see, here, R is
basically just a read only starts at the beginning
179:18 - of the file, r plus is a read write, W is
write only, it truncates the existing file,
179:26 - w plus is read, right? So there's all these
different, like file modes that we can open
179:31 - up. And this is a pretty cool list, you know,
one thing that's can be fun to do is just
179:35 - play around with a file and opening it and
all these different modes just to kind of
179:38 - see what they do. And this tutorial, I'm going
to be opening the file in a couple of these
179:42 - different modes. And I think it's going to
be pretty fun. So the first thing I want to
179:46 - show you guys is how to append to a file.
So over here I have my little list of employees,
179:51 - right, let's say that I wanted to add an employee
onto this file. So I didn't want to modify
179:55 - any of the existing employees. I basically
just wanted to append one to the bottom of
179:59 - the file. So we want to add In a new employee,
well, I can open up this file in what's called
180:04 - the append mode. So I'm just going to put
an eight here. And that basically means all
180:08 - we can do to this file is just add information
onto the end of it. So we can't read from
180:12 - it, we can't write to it. Well, we can write
to it, but we can only write at the end of
180:16 - the file. So we can just append something.
So down here, what I could do is I could say
180:20 - file dot write. And inside of the parentheses,
we can put whatever we want to write to the
180:27 - file. So why don't we try to add a new employee.
So why don't we say well add Oscar who is
180:34 - in accounting, basically, what's gonna happen
is when I run this program, this line of text
180:39 - is going to get appended onto the end of the
employees dot txt file. So I'm gonna go ahead
180:43 - and run this. And now over here in the employees
dot txt file, you'll see we have this Oscar
180:50 - from accounting line, but it actually just
got appended right onto the end of the fall.
180:55 - So literally right after the last character,
and I want to show you guys what we can do
181:00 - to mitigate that. So I'm just going to get
rid of that. And we're going to run this again.
181:03 - This time, though, I'm going to run it with
a new line in front. And basically, what this
181:07 - will do is it'll go on to the next line, and
then it'll print Oscar from accounting. So
181:11 - now, when I run the program, we should get
what we want, which is this. So Oscar, is
181:16 - just on the next line. Here's the thing, when
you're appending to a file, it really when
181:20 - you're writing to a file, you need to be careful,
because if I was to run this program again,
181:25 - so I'm just going to run it again. And I go
back over to this employees dot txt file,
181:29 - you'll notice that Oscar and got a pendant
to the end of the file again. Alright, so
181:33 - every time you run your program, it's going
to keep modifying the file. So you need to
181:38 - be careful whenever you're writing to files
because you're modifying the actual file.
181:42 - So if you, you know, mess up and you run your
program one too many times, and your files
181:46 - are basically going to be, you know, if not
ruined, they're going to have information
181:50 - in there that you didn't want. So that is
the basics of appending, you can just append
181:53 - something onto the end of the file, it's super
simple, super straightforward. And that can
181:56 - be really useful. In a lot of different scenarios.
Another thing we can do is just write to the
182:02 - file. So instead of a, I'm going to say w
here. And this basically gives us the ability
182:07 - to modify information in a file, overwrite
information in a file and also create new
182:12 - files, which is pretty cool. So over here,
if I was to say file dot write, and I just
182:18 - did Oskar accounting. Now, what this is going
to do is it's going to overwrite this entire
182:23 - employees dot txt file. So let's go ahead
and do that. I'm going to run this. And you'll
182:28 - see over here, this is actually overwritten
the entire file, so we've overwritten everything
182:34 - in this file. And that's basically what happens
when we write to a file. So I'm actually going
182:39 - to undo this. And we'll bring this back to
how it was I want to show you guys another
182:43 - thing we can do, which is when you're writing
to a file, you can actually create new files.
182:49 - So for example, let's say I wanted to create
a new file, I can actually come up here, put
182:53 - the name of the new file that I wanted to
create. So maybe I want to create like an
182:58 - HTML file, I could call it index dot HTML.
Down here, I could actually write out some
183:03 - HTML into this new file. So I could say file
dot write. And we can just put some, I mean,
183:10 - we can put like HTML, you know, whatever.
So HTML is like another sort of programming
183:16 - language. And now what's going to happen is,
when I run this program, a new file called
183:21 - index dot HTML is going to get created. And
this is actually going to get written into
183:25 - that file. So you'll see over here, index
dot HTML has been created. And it has a header
183:31 - one, and it's just saying, hello, that's pretty
cool. You can create all different types of
183:35 - files, you can use all different types of
file extensions over here. And that's, you
183:39 - know, really useful way to create files. Another
thing I want to show you guys is another file
183:44 - mode. So instead of just writing, we're actually
going to read and write, so I'm just gonna
183:48 - say R plus. And basically, what this means
is we can read the file, and we can write
183:53 - the file. And when we're doing stuff like
this, and makes it really useful. So okay,
183:57 - so we have all of our employees here, I can
actually use some of the read methods that
184:03 - we learned in the last tutorial and some of
the right methods in order to write information
184:07 - at specific points in the file. So for example,
we could insert text at a specific point in
184:13 - the file. So I can say like, file dot read
line. And this is basically going to move
184:19 - to the next line in the file. So whenever
you're reading a file, there's like something
184:24 - called a file cursor. Or you'll hear people
call it like the the file buffer, sometimes,
184:30 - basically like it, when we open the file,
we start at a specific place in the file.
184:34 - So if you come back over here, you'll see
like read read only starts at beginning of
184:39 - file, right? Our plus read right starts at
beginning of the file. So in certain times,
184:45 - when we use these certain modes, they'll start
at certain positions in the far right, a little
184:49 - cursor, whatever. When I say file dot read
line that moves that little cursor to the
184:55 - next line in the file, right? And so now,
essentially, where this cursor is, is that
185:00 - the second line of the file. So I can come
over here and I could say file dot write.
185:06 - And I can basically say, like, overridden.
And now when I run this, and I go over to
185:12 - my file, and actually, we got to change this
back to employees dot txt, my bad. So when
185:20 - I go back over to my file, you'll see that
it says overridden down here, right? So I
185:26 - was able to override the text that was on
that second line, I can even do the same just
185:30 - for parts of it. So if I just wrote out like,
high down here, you'll see that high is going
185:37 - to get inserted only in these first two positions,
right? So you're just overriding like the
185:42 - positions right after that little cursor.
And so that can be really, you know, useful.
185:47 - And really, you can use this read line. And
there's also another one called read, char,
185:53 - and recharge will just read like an individual
character. So it'll move that cursor like
185:57 - one character, you can use these different
functions to move that cursor on the file
186:02 - and insert text, you know, in very specific
places. And that, you know, you can just kind
186:06 - of play around with that to be able to do
stuff like that. But I would say those are
186:09 - kind of the basics. You know, we learn how
to create new files, we learn how to override
186:14 - existing files, we learn how to insert text
into specific places and specific files, we
186:20 - learned about the different modes. So again,
you know, go off research some of the different
186:24 - modes where you can open a file, but I would
say really writing to files is extremely useful.
186:29 - And there's a lot lot lot of programs that
do stuff like this and rely on stuff like
186:33 - this. In this tutorial, I want to talk to
you guys about Exception Handling in Ruby.
186:42 - Now, sometimes when you're writing your Ruby
programs, you're going to come across certain
186:45 - errors. So a lot of times when we get an error
in Ruby, it'll crash our program. In fact,
186:51 - every time we get an error in Ruby, it's going
to crash our program. And sometimes when you're
186:56 - writing Ruby code that you want to be able
to execute for, you know, months and months,
187:01 - or even like a couple years at a time, you
want to make sure that you're able to handle
187:05 - any errors or exceptions that pop up in your
program. And I'm going to show you guys how
187:10 - you can do that today using something called
a rescue. So let's go ahead and trigger an
187:15 - error in our program, one of the easiest ways
to do this is to divide something by zero.
187:20 - So if you're familiar with, you know, math,
you can't actually divide something by zero.
187:25 - So if I said like, num is equal to 10, divided
by zero, when I run this program, you'll see
187:32 - over here, we're getting a bunch of red, we're
getting an error, it says divided by 00 Division
187:37 - error. So Ruby's telling us, you had a zero
division error, right? Another area that we
187:44 - could use, and I'm actually just going to
comment, this guy out right here, would be
187:48 - trying to access an invalid index in an array.
So we can try to access an array index using
187:53 - something like a string. So I just have this
array over here of lucky numbers. If I was
187:58 - to say, like lucky nums, like zero, this is
going to be fine, this will give me this four.
188:05 - But if I said lucky, nums dog, I can't actually
pass a string into here. So I'm going to get
188:11 - another error. And over here, it says no imposition,
implicit conversion of string into integer.
188:17 - So I'm getting a type error. And there's a
bunch of these different errors in Ruby, you
188:22 - know, they handle a bunch of different situations
going wrong. But the point is that if a situation
188:27 - like this comes up in my program, a lot of
times, I'm gonna want it to not break the
188:31 - program, like, I'm gonna not want it to explode
the program. And then you know, the program
188:36 - is done running. So we can actually watch
out for some of these common errors. And we
188:40 - can do what's called catching them. And when
we catch an error, or we catch an exception,
188:45 - that means we're basically saying to the program,
like, Hey, we know some of them went wrong,
188:49 - but we're handling it, and it's all good,
don't worry about it, you don't need to crash
188:53 - and burn. So I'm going to show you guys how
you can do that. And really, the most basic
188:56 - way to do it is just to use something called
rescue and begin tags. So over here, I'm just
189:04 - going to say begin. And down below here, I'm
going to say rescue. And then down here, I'm
189:10 - going to say and so this is the basic structure,
any code that I think is going to throw an
189:16 - error or an exception in my program, I want
to put it inside of these, this little BEGIN
189:22 - block. So for example, this division by zero,
let's grab this, and we can put this in here.
189:28 - As long as this code, like the code that we
think might break is inside of that BEGIN
189:33 - block. Then if something does go wrong here,
then it's basically just going to go down
189:38 - to the code inside this rescue block and execute
that. So I can say down here like puts division
189:43 - by zero error. So now when I run my program,
instead of the program just exploding, it's
189:50 - gonna say division by zero error. So the program
actually didn't break the program didn't stop
189:56 - executing our program just handled the error.
And defaulted down here and basically printed
190:02 - out, hey, there's a division by zero error.
Here's the thing, the same thing is going
190:06 - to work for these lucky numbers. So if I was
to grab this lucky numbers, and I put this
190:11 - over here, and I'm actually going to comment
this out. Now when I run this program, you'll
190:15 - see that the lucky numbers is going to do
the same thing. So over here, it says division
190:20 - by zero error. Here's the problem, though.
Let's say I have more than one piece of code
190:26 - inside of this BEGIN block that has the potential
to break the program. Right. So these two
190:32 - blocks of code will break the program, right?
We we know for a fact that they will. But
190:37 - let's say that they'll only break the program
some of the time, right. So maybe we have
190:41 - a program where the user can enter in two
numbers to divide, and sometimes they're going
190:45 - to enter into zero, in which case, we're going
to have to handle this error. And maybe sometimes
190:49 - they won't. The problem is that if I just
put division by zero error down here, this
190:55 - is just going to catch any error that gets
thrown. So it'll catch this error up here,
190:59 - it will also catch this error. And remember,
those are two different types of error. One
191:04 - was a division by zero error, one was a type
error. So there's actually a way that we can
191:10 - specify specific rescue blocks for specific
types of errors. So for example, that division
191:16 - by zero, if I wanted, I can come down here
and I could say rescue, and then I can just
191:20 - type out zero division error. And remember,
this is basically the error that got thrown
191:27 - when we divided by zero. And so here's the
thing, when I run this num 10 divided by zero
191:34 - thing, it's going to get caught by this division
by zero error when I run the program. But
191:40 - if I was to run this lucky numbers, so if
I just uncomment, this, this isn't gonna get
191:46 - caught. So this is still going to break the
program, you'll see over here, we're still
191:50 - getting a type error. So actually, what I
could do is I could create another rescue
191:54 - block for that specific type of error. And
we could just say, type error. And then down
192:02 - here, inside of this rescue block, we could,
you know, print out a message like, wrong
192:09 - type. And so now this lucky numbers with the
dog index is going to get caught. And it's
192:16 - going to say, wrong type. So a lot of times
in Ruby, you're going to want to be specific
192:20 - about what errors you want to catch. And so
basically, what this means is, in the case
192:24 - of a zero division error, I could do something,
I could put a bunch of code inside of here,
192:28 - that's going to do something, in the case
of a type error, I could do something else,
192:33 - another thing we can do is we can actually
take the error that got thrown, and we can
192:37 - store it in a variable. So I could say type,
err, an equal sign and a greater than sign.
192:42 - And then I can just type in the name of a
variable, what I want to store the exception
192:45 - that got thrown, so I'm just going to call
it E. And down here, I could actually print
192:49 - out E. So when this type error gets called,
instead of just typing out, hey, wrong type,
192:56 - it's going to tell us what the actual error
was. So it says no implicit conversion of
193:00 - string into integer. And a lot of times this
can be useful, because different situations
193:05 - will cause this type error to run. In other
words, like different stuff up here might
193:10 - cause the Type error. So by storing the error
inside of a variable called E and printing
193:16 - it out, we can tell the user exactly what
went wrong. So that's pretty useful. And this
193:20 - is optional, you don't have to do this. But
a lot of times, you're going to want to and
193:25 - it's usually a good practice, if you're writing
a script or a piece of code that's going to
193:28 - be running for long periods of time. For example,
if you need a piece of code to be running
193:33 - for like a couple months, or like even a couple
years at a time, like on some server somewhere,
193:37 - using these rescue tags is extremely useful,
because you'll basically prevent your program
193:43 - from terminating or your prey program from
blowing up when stuff goes wrong. And just
193:48 - one more thought on this. And, you know, different
people have different opinions about this.
193:53 - But generally, it's a good idea to specify
the specific errors that you want to catch,
194:00 - it's usually not a good idea just to use rescue.
The problem is because this is just going
194:04 - to catch any error under the sun. So a lot
of times like you're going to want to be able
194:08 - to respond to individual errors differently.
So this is kind of like almost too broad in
194:13 - a sense, because you're just casting a huge
net, and catching every error in your entire
194:18 - program. But if you want to use that, then
it's available to you. So that's the basics
194:22 - of using those begin and rescue tags in order
to stop our programs from blowing up. In this
194:32 - tutorial, I want to talk to you guys about
classes and objects in Ruby, are classes and
194:38 - objects are a extremely important concept
in Ruby. So in this video, I'm going to be
194:42 - giving you a basic overview of what a class
is, what an object is, how we can create classes
194:47 - and how we can create objects. So make sure
you pay attention because this is a very important
194:52 - topic when it comes to Ruby. Now Ruby is an
awesome language because it allows us to use
194:57 - all different types of data inside of our
programs. So if you watch the video that I
195:02 - did on data types in Ruby, we looked at some
of the basic data types that Ruby gives us
195:07 - things like strings, integers, floating point
numbers, things like Booleans. And even like
195:13 - the nil value, right, there's all these different
types of data that we can represent. And we
195:17 - can work with him we can use in our Ruby programs.
But here's the problem is not all things not
195:24 - all information, not all objects, not all
entities in the real world can be represented
195:29 - by just those pieces of information, right?
You can't represent everything with just a
195:34 - string, or with just a number, or with just
a Boolean, right? There's a lot of things
195:38 - in the real world, like a lot of you know,
different things like a person or a phone
195:43 - or a credit card, or a water bottle, or a
computer, a keyboard and mouse, like there's
195:47 - a lot of these real world things that can't
be represented using just a string or just
195:53 - a number. One of the cool things about Ruby
is it allows us to create our own data types.
195:59 - So I could actually create my own data type
that it will allow me to represent like a
196:03 - phone inside of my program, or that would
allow me to represent a computer or a credit
196:08 - card or a book or a lampshade or a dog, really
anything I would want, I could represent inside
196:14 - of my program. And I can essentially just
create my own data type. And essentially what
196:19 - that is, it's called a class. So we can create
a class in Ruby. And a class is basically
196:25 - just a custom data type. So it's a data type
that we can define. So I can basically say,
196:31 - like, I want to represent a book inside of
my program. And I can say, here's what a book
196:35 - looks like, in my program, maybe it has like
a title it has an author has, like, you know,
196:39 - a certain number of pages associated to it.
And then I can take that book data type, and
196:45 - I can create individual books from there.
So I can take this book class that we're going
196:50 - to create, and I can create individual books,
I can represent individual books inside of
196:56 - my program. So I'm gonna show you guys how
we can do that we're going to create a book
197:00 - data type or a book class. And then we're
going to create some book objects, this is
197:05 - going to be pretty cool. In order to create
a class, I can just come over to my Ruby file,
197:10 - and I'm just going to type out class. And
I want to give it a name. And generally, in
197:15 - Ruby, when we create a class, you're gonna
want to give it a name with a capital letter.
197:18 - So I could say, like, be okay with capital
B. And then I'm going to come down here and
197:23 - just type end. So remember, a class is essentially
a custom data type in Ruby. So when we create
197:31 - a class, we're basically modeling a real world
entity or a real world object inside of our
197:37 - program. So inside of this book class, I'm
basically telling Ruby, what a book is, I'm
197:43 - defining like, here's what a book is. And
generally, when we create a class, we're going
197:47 - to give these classes various attributes.
And that's how we can create a data type,
197:52 - I can say, Okay, here's my book class, and
every book is going to have a title, it's
197:58 - going to have an author, and it's gonna have
a number of pages, right? A class is essentially
198:03 - like a blueprint, or a template for a specific
entity or object in the real world, like a
198:10 - book is an actual entity in the real world,
right? A book is an object that we can interact
198:15 - with and work with. And this class is a template
or a blueprint for representing a book inside
198:21 - of our program, we're basically creating our
own data type. So inside of this book class,
198:28 - I can actually define a bunch of attributes,
and attributes is just going to be information
198:33 - that all books are going to have. So we're
essentially telling Ruby, like, hey, all books
198:37 - should have the following information. So
inside of this class, I'm just going to type
198:41 - out a TT r underscore, ACC SSR, attribute
accessor. And now I'm going to make a space.
198:49 - And over here, I'm going to type in the attributes
that a book should have inside of our program.
198:54 - So I'm just going to type a colon, and I'm
going to type the name of the attribute I
198:58 - want to define. So all books should have a
title, I'm going to put a comma book should
199:03 - have an author. And then book should also
have a number of pages. So I'm just going
199:08 - to say pages. So essentially, what I'm doing
here is, again, I'm laying out the blueprint
199:14 - for a book inside of my program. So I'm essentially
saying like, here's the book datatype. And
199:19 - all books are gonna have a title, they're
gonna have an author, and they're gonna have
199:23 - pages. So this is like our overall blueprint,
our overall template. So now that we've created
199:29 - this, now that we've told Ruby, what a book
is, we can actually go and create individual
199:34 - books inside of our programs. And these are
called objects. And an object is essentially
199:40 - just an instance of a book or an instance
of a class. So I can create a book object,
199:46 - and that book object would represent an individual
book in my program. So I'm going to come down
199:52 - here and you can create objects, essentially
the same way that you create variables and
199:56 - actually as we'll learn all variables in Ruby
are actually just objects. So I'm going to
200:03 - give this a name. So we'll just call this
book one. And I'm going to set it equal to
200:10 - book dot new. And we're gonna make an open
and close parentheses. Basically, what this
200:15 - is doing is it's telling Ruby that we want
to create a new book. So we want to create
200:20 - an actual book inside of our program. In other
words, we want to store the book datatype,
200:25 - inside of this book, one variable. Now down
here, what I can do is I can actually give
200:31 - this book attributes. So remember, we defined
a book up here that it's going to have a title,
200:36 - an author, and a number of pages. So down
here, I can basically say book one dot title,
200:43 - is equal to, and we can make this like a Harry
Potter book, right? So I'm basically defining
200:49 - what the title of this book is. And down here,
I could say, Book Two dot author. And we'll
200:58 - make the author, JK Rowling. And we can say,
actually, whoops, this has to be book one,
201:05 - I'm sorry. And then we can say book one dot
pages. And we can set this equal to like,
201:10 - I don't know, maybe has 400 pages or something.
So essentially, what I'm doing is I'm creating
201:15 - this book object. And remember, an object
is an instance of a class. So when a book
201:21 - object is basically just like a given book
inside of our program that's going to have
201:25 - all of these attributes. And I'm giving it
all of these different attributes, I'm assigning
201:30 - it some information. So what I can actually
do now is I can interact with this object.
201:34 - So I can say puts book one dot title. And
this is going to print out the title of book
201:40 - one onto the screen. You see over here, it's
printing out Harry Potter. Over here, I could
201:46 - print out book one dot pages, and it's going
to print out all of the pages in book one.
201:52 - So there's 400. And we could do the same with
the author. So essentially, what I did was
201:57 - I created my own data type up here, I created
a template for what a book is, inside of our
202:03 - program, I said the book is going to have
these certain attributes, I created a new
202:08 - instance of a book. So I created a book object.
And then I gave all of those attributes specific
202:14 - information. So I said, like the title of
book one is going to be Harry Potter, the
202:17 - author of book one's going to be JK Rowling.
And what's cool about objects is we can create
202:21 - as many of them as we want. So down here,
I could actually create another book, I could
202:26 - say, book two is equal to book dot new. And
then I can start giving this some attribute.
202:34 - So I could say like, Book Two dot title is
equal to Lord of the Rings, you'd say Book
202:41 - Two dot author, is equal to token and book
two pages, is equal to, let's say, 500. And
202:53 - so now I'm actually representing another separate
book inside of my program. So I can come down
202:58 - here and say, like, puts book to the author.
And this is going to print out the author
203:05 - of book two over here in the console. So essentially,
what we did again, was we defined the template
203:12 - for what a book is going to be inside of our
program. And this is a class. And then we
203:17 - can create instances of that class, which
are called objects. And an object is just
203:22 - like an actual book. So we have the Harry
Potter book. And we also have the Lord of
203:26 - the Rings book down here. And we can access
all the attributes from inside those books
203:32 - by saying book to author book to pages, we
can just refer to them directly. And that's
203:37 - one of the cool things about classes and objects
is they allow you to create your own custom
203:42 - data types inside of Ruby. And one of the
cool things about Ruby is that everything,
203:48 - all data is actually classes and objects.
So all data is actually an object, a string
203:53 - is an object. An integer, like a number is
an object. a floating point number is not
203:58 - a Boolean is an object. All these different
things are objects, and they all have classes
204:03 - which define them. That's really one of the
cool things about Ruby. And one thing that
204:07 - sets it apart from a lot of other programming
languages is that everything is an object.
204:16 - In this tutorial, I want to talk to you guys
about the initialize method in Ruby classes.
204:21 - So in the last tutorial, we looked at creating
Ruby classes and then creating objects of
204:27 - those classes. And this tutorial, I'm going
to show you a way that we can actually make
204:31 - creating these objects a little bit easier.
So notice down here, when I created my two
204:37 - book objects, I said book one is equal to
book dot new. And then I had to manually set
204:43 - the book's title, the books author and the
books pages. So just to create one book, I
204:48 - had to type out four full lines of code. Right
down here, I do the same thing. So when I
204:53 - created the second book, had to type out four
full lines of code. And this is kind of a
204:58 - problem because if I wanted to create, for
example, like, you know, 10 or 20 different
205:03 - books, it's gonna take up seriously a lot
of space inside of my Ruby files. Also just
205:09 - having to go through and manually say like
book one title is equal to Harry Potter book,
205:14 - one author like, that gets really tedious
after a while, there's actually a way that
205:19 - we can give our objects all this information
right up front when we create them, instead
205:25 - of having to do it manually like this. And
that's by using something called an initialize
205:30 - method. An initialize method is actually a
method that's going to get called whenever
205:35 - we create an object. So remember, up here,
we have this class. And this class is basically
205:41 - just a template. It's a blueprint for what
a book is, in our program, when I create an
205:46 - object, it stops being a template, it stops
being a blueprint, and it becomes an actual
205:51 - book. So this book, one object down here is
representing the Harry Potter book, you know,
205:57 - with the author of JK Rowling 400 pages, this
is like a physical book that we use that template
206:03 - of there to create. So when we end up creating
a book, we can actually give it some default
206:08 - information. And I'm going to show you guys
how to do that. So up here in our class, I
206:12 - want to create a method. And it's going to
be called initialize. So I'm just going to
206:15 - say def, and it's initialized just like that.
And I'm actually going to create this just
206:22 - like I would a normal method. So I'm going
to say, and down here, inside of these parentheses,
206:27 - I can actually pass some information. But
before I do that, I want to show you guys
206:32 - what's going to happen. So for example, I
can put a print statement here, actually,
206:36 - let's do a put statement. And it's going to
say, creating book. Now when I run my program,
206:45 - you'll see that over here, it actually types
out creating book twice. Essentially, what's
206:50 - happening when I say book dot new, this initialize
method up here is getting called. So every
206:58 - time I use this new method down here, and
I call it, this initialize method is actually
207:04 - getting called. So if I was to pass a parameter
into here, so let's have this initialized
207:09 - method, take a parameter, like we'll have
a take name, I could come over here, and I
207:13 - could basically print out like, Hello, name.
So I can pass a name into here, I could say,
207:19 - like Mike. And then down here, I could say
another name, like Bill or whatever. And when
207:26 - I run my program, you'll see it's printing
out Hello, Mike, and Hello, Bill. So this
207:32 - is essentially just a method that we can call
just like any other method in any of our programs.
207:37 - But this method special because it gets called
when we create an object. So what we can do
207:43 - is we can actually pass this initialize method,
some information. And we can use that information
207:49 - to give our object specific information. So
essentially, what I can do over here is I
207:54 - can say, initialize is going to accept three
parameters. So when we call this new method
208:00 - down here, we're going to have to pass it
three things, the first thing we're going
208:03 - to have to pass in is the title of the book
that we want to create. The second thing we're
208:08 - going to have to pass it is the author of
the book we want to create. And the third
208:12 - thing is going to be the number of pages for
the book that we want to create. So now whenever
208:17 - I want to create a book, I have to give it
a title, and author and a number of pages.
208:23 - Once I'm inside this initialize method, I
can do something special. So I can actually
208:27 - take the values that the user passed in. So
I can take the title, the author and the pages.
208:33 - And I can assign them to the attributes of
the object. So I can assign them to the title
208:39 - of the object, the title of the author and
the title of the pages, I can basically do
208:44 - what I did down here. So I can basically say
like book one dot title is equal to whatever
208:50 - the title they passed in was. And this is
going to save us tons of time when we're writing
208:53 - our programs. And the way that I can do that
as I can, I can just say app, and I can say
208:59 - title is equal to title. So let me walk you
guys through this line of code. When I say
209:04 - at title, this is referring to the title attribute
in our objects is referring to the title attribute
209:10 - that we defined up here is rented that title
of their right, this is saying the title of
209:16 - the object that we're creating is going to
be equal to the title that the user passed
209:22 - in. Remember, this title, this is just a parameter
that got passed into this new method down
209:27 - here. This is just a parameter just like I
pass in the name, it's the same thing. We're
209:31 - passing it a parameter. And I could even name
this something else. I can name this like,
209:36 - you know, I couldn't I could name it, you
know, whatever I wanted. And, but I'm just
209:39 - calling it title, because that's what it is.
It's the title. So I'm setting the title of
209:43 - the object equal to the title that got passed
in. I can do that for all of these. So I can
209:47 - say the author of the object is going to be
equal to the author that got passed in. And
209:53 - the number of pages is going to be equal to
the number of pages that got passed in. And
209:59 - so essentially What I can do now is when I
create my new book, instead of having to say
210:04 - like book one title book, one author, I can
just take all this information and put it
210:08 - up here. So I can pass it into this initialize
method. So I can just say, Harry Potter. And
210:16 - this is going to be JK Rowling rolling, and
then the number of pages is just going to
210:22 - be 400. So I can actually get rid of all of
this code over here, because I don't need
210:29 - this anymore. And I can do the same thing
for this other book down here. So we'll pass
210:34 - in Lord of the Rings, token and 500 pages,
and I can actually just get rid of all of
210:41 - this stuff. So now, instead of having all
that other stuff, like where I had to like
210:46 - manually set each of those attributes, I can
reduce the lines of code, I have to write
210:51 - down to two. And this is going to do exactly
the same thing as we were doing before. So
210:56 - I could come down here and I could, you know,
print out like Book Two dot title. And it's
211:03 - still going to be able to print it out to
see it's printing out Lord of the Rings, I
211:06 - could print out book one dot author. And it's
going to be able to print data. So I'm doing
211:14 - exactly what I was doing before, except now
I'm making it a lot easier on myself by using
211:19 - this initialize method. And again, whenever
we say like book dot new, this means we're
211:25 - calling this initialize method, we're passing
it some parameters. And I'm setting the attributes
211:31 - of the current object equal to the attribute
that we pass in when we create that object.
211:36 - So that's how we can use that initialize method
to make our lives way easier. And you're always
211:41 - going to want to use an initialize method
for the most part, just because it makes everything
211:45 - so convenient. In this tutorial, I want to
talk to you guys about instance methods in
211:54 - Ruby. Now, sometimes you'll hear people call
these instance methods, you'll also hear people
211:59 - call them object methods, sometimes they'll
even call them class methods. Essentially,
212:03 - what we're going to do is we're going to come
inside of a class that we create in Ruby,
212:07 - and we're going to give it some methods. And
then when we're using objects of that class,
212:12 - we can access those methods to get information
about our objects. So I want to show you guys
212:17 - my setup over here, I actually have a class
here called student. And this class is basically
212:22 - just modeling or it's acting as a blueprint
or a template for a student in our program.
212:28 - Essentially, we created like a student data
type. So I defined the attributes for a student
212:33 - to be name, Major, and GPA. And down here
we have this initialize method. So we're passing
212:38 - in a name a major and a GPA. And we're setting
the attributes of this student object have
212:44 - an individual student object to be equal to
what gets passed in. So this is like our student
212:50 - class. And down here, I'm creating two student
objects. So we're making one, his name is
212:54 - Jim, he's studying business, he has a GPA
of 2.6, then we have Pam, who's studying art,
213:00 - and her GPA is 3.6. So these are student one
and student two. Now imagine that for each
213:07 - of the students in our program, we wanted
to be able to figure out if they had honors
213:11 - or not. So imagine you're writing a program
for a college or university, and you want
213:16 - it to be able to figure out whether or not
a particular student had honors, let's say
213:20 - that the rules for honors would were constantly
changing, right? So one day, maybe you had
213:25 - honors, if you had a GPA over 3.5. And maybe,
then they you know, would change it to be
213:30 - like 3.3. In other words, like, imagine, if
we wanted to be able to find out which students
213:35 - had honors in which didn't, well, we can actually
write a method inside of our student class.
213:42 - And then that method will be able to tell
us whether or not a specific object has honors.
213:48 - So I'm gonna show you guys how to do that
over here in our class, I'm just going to
213:51 - come down here below this initialize method.
And we can actually create a method of our
213:55 - own. So I'm going to go ahead and define a
method. And I'm just going to call this has
213:59 - honors. And this method is not going to take
in any information. So we're not going to
214:05 - need open and closed parentheses. And down
here, we're just going to end it off. So this
214:10 - has honors method is basically going to return
either true or false. If the current student
214:16 - if the object that's calling this method has
honors and return true, if they don't, it's
214:22 - going to return false. So how can we figure
out if the student has honors? Well, we could
214:27 - use an if statement. So I could say if I want
to check to see if the student's GPA is greater
214:32 - than or equal to a specific number. So what
I can do is I can actually access the GPA
214:38 - attribute inside of our student object and
use it here. So I can say if at GPA is greater
214:45 - than or equal to and let's say that in order
to have honors we we have to have a 3.5 or
214:51 - above. So if their GPA is greater than or
equal to 3.5, then we're going to return true
214:59 - otherwise We're just going to return false.
So this is basically our method if the GPA
215:05 - is greater than 3.5, return true, otherwise,
we return false. So now what I can actually
215:11 - do is I can use this has honors method on
each one of my student objects. So I can come
215:17 - down here, and you'll see I've created these
two students, right, Pam. And, Jim. If I wanted,
215:23 - I could print out whether or not they have
on him. So I could say puts, and let's check
215:27 - to see if student one, which is Jim has honor.
So I could say student one dot has honors.
215:34 - And when I run this, it's going to print out
whether or not he has honors. So in our case,
215:38 - it's going to be false. But if I ran this
method on student two, so if I ran this method
215:44 - on pam, pam actually does have honors because
she has a 3.6. So now this is going to return
215:50 - true. And what I want to point out is this
has honors method is going to be different
215:56 - depend or it's going to be using different
information depending on what object is calling
216:01 - it. Right. So when student one when Jim is
calling this object, Jim has a GPA less than
216:07 - 3.5. So it's going to return false for Jim.
So for the gym objects for the gym instance,
216:14 - it's going to return false. But for the PAM
object, Pam's GPA is higher than 3.5. So it's
216:21 - going to return true, we can basically define
a method that can be used on all of the objects
216:27 - for our specific class. And we can do it using
something like this. So you can define as
216:32 - many of these as you want inside of your class.
And these can be really useful, a lot of good
216:36 - classes out there and Ruby are going to have
a bunch of good methods like this, which are
216:41 - going to allow you to, you know, either find
out information about the specific object,
216:46 - or you know, modify the object or do something
to the object in some way, shape, or form.
216:51 - So that can be really useful. And just consider,
you know, writing some methods inside of your
216:56 - classes when they're appropriate. This is
a good example of, you know, where a method
216:59 - can come in handy, because it can tell us
whether or not the student has honors, they
217:03 - can tell us something about the student, using
the attributes using the information that
217:08 - we've stored about that object. In this tutorial,
I'm going to show you guys how we can create
217:17 - a multiple choice quiz in Ruby. So we're going
to use some of the stuff that we've learned
217:22 - so far in this course, like classes, we're
going to use loops, we're going to use variables.
217:26 - And if statements, in order to create a multiple
choice quiz, basically, we're going to be
217:32 - asking the user a series of questions, the
user is going to input whatever answers they
217:36 - think are correct, we'll grade the test, and
we'll tell the user how they did. So this
217:41 - is going to be pretty fun. First thing I want
to do is talk to you guys about some stuff
217:45 - that I already have set up. First thing I
did was I wrote out a few questions for our
217:50 - multiple choice test. Down here, I have p
one, p two, and P three. And these are all
217:55 - basically prompts. So this is what we're going
to prompt the user with. And we're going to
217:59 - ask them the question. So over here, it says,
what color apples red, purple or orange? What
218:05 - color are bananas? pink, red, or yellow? What
color are pairs? yellow, green, orange. So
218:10 - this is a really easy multiple choice test
just asking you about the colors of different
218:14 - fruits. Over here, I've defined a class called
question. And this is basically modeling a
218:20 - question in our program. So essentially created
like a question data type. And down here,
218:25 - we have these attribute accessors. So we're
defining a question has a prompt and an answer.
218:31 - So the prompt is basically what we're asking
the user. So it would be like, for example,
218:35 - all these questions down here? And then the
answer is the actual answer to the question.
218:40 - So like, we're giving them a prompt that has
a bunch of different options, multiple choices,
218:45 - the answer is going to be like what the actual
answer is. And then we have this initialize
218:49 - method, which will just initialize the object
so we can create like questions inside of
218:55 - our program now. So what I want to do is I
want to create an array of questions. And
219:01 - we're going to have one question for each
of the prompts that we have up here. So I'm
219:05 - actually just going to create a an array,
we're going to call it questions. And I'm
219:09 - just going to set it equal to a bunch of different
questions. So actually, inside of this array,
219:15 - we can create a couple different questions.
So I'm going to say, question dot new. And
219:21 - I'm going to create this first question. So
remember, we need to give this a prompt and
219:25 - we need to give it an answer. So for the first
question, I'm going to pass it p one as the
219:30 - prompt, because this is the prompt for the
first question. And I want to give it the
219:33 - answer. So the answer to what color or apples
is going to be a red, so I'm just going to
219:39 - pass in a now I can create another question.
So you'll notice over here, I can just create
219:44 - a question by saying question dot new, and
then I can pass in the initial information.
219:50 - So I'm going to say question dot new. And
now we'll make one for p two for that second
219:55 - prompt says what color are bananas? And the
answer is going to be C Yellow. So we'll put
220:01 - a C inside of here. And finally, we'll make
another question. And this is going to be
220:08 - P three. And the answer to what color or pears
is going to be be green. So we're going to
220:13 - go ahead and put a B in here. Essentially,
what I've done is I've created three questions
220:18 - in my program. And I've stored them inside
of this array called questions. So we have
220:24 - an array that stores all the questions for
our test. Now the next step is we need to
220:29 - actually be able to run the test. So what
I want to do is I want to be able to go through
220:33 - each of the questions in the test, I want
to be able to ask the user the question, I
220:38 - want to be able to get their answer. And I
want to figure out whether or not they got
220:41 - the answer, right. So what we can do is we
can actually create a method. So why don't
220:47 - we create a method that will run the test.
So this method will accept one parameter,
220:52 - which is going to be an array of questions.
It'll use those questions to run the test.
220:57 - And it'll basically like ask the user all
the questions, figure out what their answers
221:00 - were, and score and grade the test. So let's
do that down here, I'm going to create a method
221:04 - and we're just going to call it run test.
And this method is going to take one parameter,
221:09 - so it's going to be an array of questions.
So we could say, questions. And we're just
221:15 - going to call the parameter that we pass in
questions. And we can go ahead and end off
221:20 - this method. Now, inside of this method, we
want to do a few things, the first thing we
221:25 - want to do is basically just loop through
and ask the user all the questions. So what
221:29 - I want to do is create a variable called answer.
And I'm just gonna set this equal to the empty
221:34 - string initially. And what we're going to
do is we're going to store all of the user's
221:38 - answers inside of that answer variable. So
like, we'll store you know the answer to the
221:43 - first question, the second question, the third
question, etc. Now, what we want to do is
221:47 - want to loop through all of the questions
inside of this questions array. So I'm going
221:52 - to create a loop, I'm just going to say for
question, in questions. So for each question
221:59 - inside of this questions array, I want to
do something and down here, we'll just end
222:03 - this off. Now inside of here, essentially,
what I want to do is ask the user the question,
222:09 - so I'm basically going to say puts, and I'm
going to print out the prompt. So I can say
222:14 - puts question dot prompt. So remember, this
is going to be an array of question objects.
222:22 - And the question class says, two attributes,
it has a prompt, and it has an answer. So
222:28 - essentially, what I'm doing down here, is
I'm printing out the prompt for the current
222:33 - question that we're looping through. Once
I've printed out the prompt, I can get the
222:38 - input from the user. So I can just say answer
is equal to get dot chomp. And this is basically
222:45 - just going to get whatever the user enters
and it's going to store it inside of answer.
222:49 - Now what we need to do is we need to be able
to keep score. So we need to be able to keep
222:53 - track of how many questions that user gets
right, and how many they get wrong. So I'm
222:57 - going to create another variable up here called
score. And I'm going to set this equal to
223:01 - zero initially. And whenever a user gets a
question, right, we're going to increment
223:06 - the score. So every time they answer the question
correctly, score will get incremented. And
223:11 - by the end of the of the test, we'll be able
to tell how many questions they got. Right?
223:15 - So down here, I want to check to see if the
answer that they gave is equal to the correct
223:20 - answer. So I can just say if answer is equal
to and now I want to compare this to the answer
223:27 - to the question. So I can say question dot
answer. And remember, this is just another
223:32 - attribute from inside of that questions class.
So down here, I'll just end this off. And
223:38 - if the answer is equal to question dot answer,
then I can basically just increment the score
223:43 - variable. So I can say score plus equals one,
and that will increment the score. Now, finally,
223:50 - down here, after this for loop, I'm just gonna
print out how they did. So I'll say puts,
223:53 - and we'll basically just say, like, you got,
however, questions out of however, right,
223:58 - so we'll basically be like puts, you got score
out of. And now we're just going to type out
224:07 - the total number of questions. So we can say
questions dot length. And this is just gonna
224:13 - tell us how many questions were inside of
that questions. Right? So this is obviously
224:17 - a lot of code. And you know, this run test
method is obviously a lot of code. But everything
224:22 - looks like it's right. So why don't we try
to run this, and we'll see how we do. So remember,
224:28 - whenever we're going to get input from the
user, we always want to use the command prompt
224:32 - in the terminal to do that. So I'm going to
open up my terminal. And I'm going to go ahead
224:36 - and run this Ruby file. So I'm just gonna
say Ruby draft.rb, because that's the name
224:41 - of the file. And we'll run this. And so actually,
whoops, totally forgot, we have to call this
224:47 - run test methods. So I didn't actually call
this run test method. So I need to do that.
224:53 - So let's come down here, and we're just going
to call it so I'm just going to say run test
224:58 - and we're just going to pass in that Questions
array. So we're passing in the array of questions
225:03 - that we created. Up here, we're passing in
this guy. And actually, you know what, there's
225:08 - one more thing we have to change. So down
here, I'm printing out the score, I have to
225:12 - say.to S. So we're converting the score into
a string. And we're going to have to do the
225:16 - same down here. So I've just saved up to s.
And now that we have this, we can actually
225:23 - run our program from inside of the terminal.
So let's go ahead and do that. So here in
225:27 - the terminal, I'm just going to run this file,
I'm going to say Ruby draft.rb. And you'll
225:33 - see it's asking us the first question. So
it says, What color are apples? So let's just
225:37 - try to get them all right, I'm gonna say apples
are a red, what color bananas, let's say see
225:41 - yellow, what color are pears, let's say be
green. So you can see here, once we entered
225:48 - in all the answers it typed out, you got three
out of three, correct. So it's actually telling
225:53 - us how many of these we got correct. And that's
pretty awesome. So let's try this again. But
225:58 - let's try to get something wrong. So I'm going
to run this same exact file. And let's get
226:02 - the first one wrong, we'll say apples or purple,
we'll get the second one wrong, we'll say
226:06 - bananas or pink. And we'll get the third one,
right, so we'll say pears are green. So now
226:10 - it's going to say you got one out of three,
because we only got one out of three questions
226:15 - correct. So that's basically how we can build
a little multiple choice test. In this tutorial,
226:25 - I want to talk to you guys about inheritance
in Ruby. And inheritance basically allows
226:30 - us to extend the functionality of one class
into other classes. So I can basically define
226:36 - what we would call like a superclass. And
then I can create subclasses, from that superclass,
226:43 - which will inherit all of the methods, all
the functionality, all the attributes from
226:48 - that original superclass. So that doesn't
make sense, don't worry, I'm gonna give you
226:51 - guys a full example of what this is and how
it works. But let me show you guys first what
226:57 - I have over here. So I created a class over
here, which is called chef. And this chef
227:01 - class, I'm going to expand it, it has three
methods inside of it. So the first method
227:07 - over here is called make chicken. And this
method basically just prints out the chef
227:12 - makes chicken. And then it has a make salad
method, same thing prints out the chef make
227:16 - salad. And then finally, we have the make
special dish method, which just prints out,
227:20 - the chef makes barbecue ribs. So essentially,
we're just like creating a chef inside of
227:25 - our program. If I wanted, I could come down
here and create an instance of the chef. So
227:29 - I can say, chef is equal to chef dot new.
And now that I have my chef object, I could
227:36 - say like chef dot make chicken. And now when
I run my program, you'll see it says over
227:43 - here, the chef makes chicken. So we're telling
the chef to make a chicken, we can tell the
227:47 - chef to make a salad or to make the special
dish. Now, let's say that in addition to having
227:52 - this chef class, right, this general overall
chef class, we also wanted to define another
227:58 - type of chef, we also wanted to model another
type of chef in our program. So let's say
228:04 - that in addition to this generic chef, we
wanted to create a more specialized type of
228:09 - chef, so wanting to create an Italian chef.
So I could say, Italian chefs, we're creating
228:14 - an Italian chef class, and down here, we'll
just end this off. But let's say that our
228:20 - Italian chef can do everything that our normal
chef can do. So the Italian chef can also
228:26 - make chicken can also make a salad and can
also make a special dish. So the Italian chef
228:32 - can do everything that the normal chef can
do. In other words, the Italian chef can have
228:37 - all the same methods as the normal chef, well,
I can actually use something called inheritance.
228:42 - And I can pass down all of the functionality
from inside of this chef class into the Italian
228:49 - chef class. In order to do that, all I have
to do is come down here. And after I say the
228:53 - name of the class, I can just make less than
sign. And I can just type out the name of
228:57 - the class that I want to inherit from. So
when I say chef right here, that means that
229:03 - the intent of the Italian chef is going to
inherit all of the functionality from this
229:08 - chef class. So it's essentially going to inherit
all of these methods. So let me demonstrate
229:14 - this. You'll notice there's nothing inside
of this class. I didn't type anything inside
229:17 - of there. But I could come down here and I
can create an Italian chef object. So I could
229:22 - just say, Italian chef, Chef dot new so I'm
creating a new Italian chef. And then down
229:28 - here, I can just say Italian chef dot make
salad. So even though I don't have any code
229:38 - up here, inside of this Italian chef class,
not a single line of code, I can create an
229:43 - Italian chef object and I can still tell this
Italian chef to make salad. Now when I run
229:49 - my program, you see down here in addition
to the normal chef making chicken, we're also
229:54 - able to use the Italian chef to make a salad
so over here it says the chef makes salad
230:00 - So this Italian chef object has access to
all of the functionality from inside of the
230:05 - chef class, because I inherited it. So I'm
using inheritance here. And I'm inheriting
230:11 - all the functionality from the chef class.
But here's a question right? The normal chef
230:16 - over here has a special dish. So the normal
chef makes a special edition that says the
230:21 - chef makes barbecued ribs. But let's say that
the Italian chef is going to have a different
230:26 - special dish from the just generic chef, what
I can do is I can actually do what's called
230:33 - overriding a method. So I can override the
make special dish method inside of this Italian
230:39 - chef class. So I could actually say, make
special dish and ended off and then inside
230:47 - of here, I can put what I want the Italian
chef's special dish to be. So I could just
230:52 - say puts, and we'll say like, the chef makes
eggplant parm. So this is going to be the
230:58 - Italian chef's special dish. So now if I was
to come down here and say chef dot make special
231:04 - dish, and Italian chef dot make special dish.
You'll see when I print these out, or when
231:11 - I run my program, it says the chef makes barbecued
ribs. And the chef makes eggplant parm. So
231:18 - inside of the Italian chef class, I was actually
able to override this make special dish method.
231:25 - And that is a super useful thing to do. Another
thing I can do is add functionality into this.
231:31 - So let's say that the Italian chef, in addition
to doing everything that the normal chef can
231:35 - do, can also make pasta. So I can make a method
here it's make pasta. And down here, it's
231:43 - just going to be the chef makes pasta. So
now inside of my Italian chef object, I can
231:51 - make some pasta. So I could say Italian chef
dot make pasta, and the Italian chef will
231:57 - be able to make pasta. But the normal chef
down here doesn't have a make pasta method.
232:03 - So it's not going to be able to make pasta.
So let's go over what we did. Essentially,
232:08 - I created this class chef, this chef had a
bunch of functionality it can make chicken
232:13 - can make salad can make a special dish, right?
Then I created a nother class, Italian chef.
232:20 - And this Italian chef could do all the same
stuff as the normal chef. So what I did was
232:26 - I inherited all the functionality from the
chef class into here, right. But there was
232:31 - a circumstance where the Italian chef was
actually going to have a different special
232:35 - dish than the normal chef. So I overrode this
method I basically defined redefined the method
232:42 - inside of the Italian chef class. And I was
able to make it do what I wanted it to do.
232:47 - I also extended the functionality. So I was
able to actually make the Italian chef different.
232:52 - So the Italian chef, in addition to doing
everything that the normal chef could do could
232:56 - also make pasta. And that's the basics of
inheritance, we can define what's called a
233:01 - superclass. So this chef up here, this is
the superclass. And then we can also define
233:07 - subclasses. So this Italian chef is a subclass.
And it's considered a subclass, because it
233:13 - inherits from the chef superclass. And this
can be really awesome. So a lot of times in
233:18 - Ruby, you're going to have different hierarchies
of classes. So we'll have like the chef class.
233:25 - And then we'll have a subclass and Italian
chef, I can also create other subclasses,
233:29 - like a Chinese chef or a French chef, or a
Mexican chef, right, I can have different,
233:34 - you know, types of chef different subclasses
of chef's that would all inherit the functionality
233:40 - from the generic chef class. So that is super
useful feature in Ruby, it's really going
233:46 - to come in handy, especially if you start
creating lots and lots of classes. In this
233:53 - tutorial, I'm going to talk to you about using
modules in Ruby. Now module is basically just
233:59 - a container where we can store groups of methods.
So as you start programming more and more
234:05 - in Ruby, and as your programs get more and
more complicated, you're going to want to
234:09 - organize all the different methods that you're
using. So a lot of times in a Ruby script,
234:13 - you're going to be writing out a bunch of
different methods that are going to do different
234:16 - things in the they'll have different tasks.
And one thing we can do is we can take methods
234:22 - that are doing similar things, or that should
be grouped together, we can put them inside
234:27 - something called a module. So over here, I
have this file open. It's called useful tools.rb.
234:33 - And in here, I've defined a module. So I'm
just going to open this up. And you'll see
234:39 - inside of this module, I just said module,
and then tools. So whenever we create a module,
234:44 - you can create it by saying module. And generally
you're going to want to give modules a name
234:49 - with a capital letter, so you need to do that.
And down here, I have two methods. inside
234:55 - of this module, I have a method called Say
hi. And it says hi to a user and I have

Cleaned transcript:

In this course, I'm going to be teaching you everything you need to know to get started writing programs in Ruby. And Ruby is an extremely popular programming language. And it's also the programming language behind one of the most popular web development frameworks called Ruby on Rails. So if you're somebody who's looking to get into Ruby on Rails, or you just want to learn more about Ruby, and come to the right place, in this course, I'm gonna be showing you everything you need to know to get started. So we're going to start off with the basics like installing Ruby, getting Ruby set up with a text editor and executing your first Ruby program. And we're going to look at, you know, some of the bare basics, things like variables, we're going to look at dealing with different types of data, storing data, we're gonna learn things like if statements and loops, and then we're going to get into more advanced stuff. So we're going to talk about the ins and outs of object oriented programming, we're going to talk about things like classes and objects. And all throughout this course, we're going to be using real world examples. So I'm going to be showing you guys different, you know, mini applications that you can build, we're gonna build a couple different games, we'll build like a calculator, we can do all sorts of stuff. So not only are we going to be learning Ruby, but I'm going to be showing you guys how to apply it in a bunch of different situations. So I'm excited for you guys to come along. In this course, I'm covering just about every major topic in Ruby. So by the end of the course, you should have a pretty solid understanding of what this language is about what it can do and what you can do with it. In this tutorial, I'm going to show you how to install Ruby on Windows, it's actually a pretty easy process. Essentially, all we have to do is use a Ruby installer that we can download from like Ruby's official website. And it'll basically walk us through all the installation instructions. So I'm over here on this website, it's Ruby installer.org, forward slash downloads. And this has basically a Windows downloader that we can use. So you'll see down here, there's a bunch of different options, I'm going to be installing the latest version at the current time, which is Ruby 2.4. Just a quick disclaimer, the instructions in this video aren't going to work for Ruby versions below 2.4. So below 2.4, there's actually a different way that you can install it, but after 2.4 and above, then you can follow these instructions. So I'm just gonna click this and it should start downloading. When the download has finished. Now all we have to do is run that program. So I'm going to go over to my downloads folder, and you'll see we have this Ruby installer, let's double click that, and it should open up a window that we can work with. Alright, so I'm just going to click through all the options on this window, I'll accept the license. And now Ruby should start installing on our computer. Alright, when the installer finishes running, all we have to do now is install one more thing. So you'll see over here, there's a checkbox that says run our idk install, you want to make sure this is checked. And I'm just going to click Finish. So this should actually open up another window here, it just says Ruby installer too. And you'll see over here that there's three options. So the first one says ms y s to base installation. Second one says system update. And then here it says ms wise to mA n GW development toolchain. Just for the purposes of being thorough, we're going to go ahead and install MSI as to and the m i n GW development tool chain. And I found doing this, it's best to just enter all these options in order. Sometimes when you enter just three, then you get an error because certain things aren't updated. So I'm going to go ahead and enter in one and then after that's done two and then three. And if we do that, then everything should be able to be downloaded correctly. So I'm just going to click one and we'll go ahead and run this. When that's done running, then we can just click to and we'll run that. And this is going to go ahead and update everything that we just installed. And finally, I just want to click this third option. So I'm going to type in three, and we'll run that. Alright, once you've run all three of those installers, then we're officially done with installing Ruby on our computer. The last thing I want to do is just check to make sure that everything got installed correctly. So I'm going to go down here, and inside of my search bar, I'm just going to type in cmd. So I'm just going to type cmd. And this option for the command prompt should come up. So you just want to click that. The command prompt is basically just a way that we can interact with the computer by giving it text commands. And we can go inside here to check to see what version of Ruby we have installed. So essentially, what I want to do is just type in Ruby hyphen, V. And when I click enter, this should tell me the version of Ruby that I currently have on my computer. As long as you're getting a version with the Ruby hyphen v command, then you have Ruby installed on your computer, and you're ready to start writing some awesome programs. And this tutorial, I'm going to talk to you about installing Ruby on OSX. Now one of the great things about OSX is it actually comes pre installed with Ruby. So basically you don't actually need to install it, you should just already have it. But I just wanted to talk about in this video, like how we can check to make sure that we have Ruby. And then I'll also talk a little bit about updating the version of Ruby that you have on your computer. So, first thing I want to do is come up here to the search bar. And I'm just going to type in Terminal. And basically, this will open up the terminal. The terminal is essentially just a program that allows us to interact with the computer by using text commands. So inside of the terminal, I just want to check to make sure that everything is installed with Ruby. So I'm just going to type out Ruby hyphen, V. And this should spit out a version number of Ruby. In my case, I have Ruby version 2.4. Point two. So as long as you're getting a Ruby version number that's getting printed out onto the screen, then you're good to go. And for the most part, if you're running OSX, you should have some version of Ruby installed on your computer. If you'd like to update this version, though, for example, if you have maybe an outdated version of Ruby, I would recommend using a program called the Ruby version manager. I'm not going to get too into using the Ruby version manager here. But I just wanted to bring it up so that if you are running an outdated version of Ruby, then you'll know kind of what to look for in order to update it. So something called the Ruby version manager and it's basically a program that you can use to update the current version of Ruby that you have on your computer. So if you're trying to update your current version of Ruby, then use the Ruby version manager. But otherwise, you can basically just use whatever Ruby version that you have installed on OSX in order to follow along with this course. In this tutorial, I'm going to talk to you guys about getting a text editor for Ruby. And then we're also going to look at how we can write our first Ruby program and run our Ruby programs from the text editor that we download. And one of the cool things about Ruby is you can basically write Ruby code in any text editor you want. So you can use something simple like Notepad or TextEdit. Or you could use like a dedicated environment that was built just for writing Ruby. In our purposes. For this course, I'm going to be using a special text editor called Adam. And this is basically a text editor. But it's been designed to support Ruby. And so it's going to be an awesome environment where we can write our Ruby code. So I'm going to show you guys how to install Adam, we're going to talk about setting it up and getting it ready to go. But just a quick disclaimer, like you don't have to use Adam, if you don't want, that's what I'm gonna be using for this course. But like I said, you can basically use any text editor that you want to write your Ruby programs. So let's go ahead and install Adam, I'm going to come down here to my web browser. And up here in the URL bar, I just want to type in atom.io. And this is the official website for the atom text editor. What this should do is it should bring you to a page for your operating system. So in my case, I'm on a Mac, so it gives me this download for Mac option. If you're on a Windows machine, then it'll give you a download for Windows option. I'm just going to click this and we'll go ahead and download Adam. When Adam has finished downloading, I'm just going to go into my downloads folder. And I'll just go ahead and double click on this Adam Mac dot zip file. And if you're on Windows, you might have to go through an installer process. If you're on Mac though, now you basically have Adam over here. So you just move it into your Applications folder, and you'll be able to start using it. So I already have Adam installed on my computer. So I'm going to go ahead and open it up. And once we have Adam open, there's a bunch of different stuff that we can do. One thing you might want to do when you first get into atom is go down here into preferences or settings. And over here, you can configure a bunch of stuff. So you'll see over here on the side, we have an option for like editor, you can also configure like a theme. So you know you can change like what the text editor is going to look like. You can do a bunch of stuff over here just to kind of configure out them to your liking. In order to be running Ruby programs on here, we're actually going to have to install one thing, which is a package. So over here on the Settings page, I'm just going to go over here to this install button. And inside of here, we want to search for a program it's just going to be called Adam hyphen runner. And essentially what this plugin is going to allow us to do is it's going to allow us to run our Ruby scripts or our Ruby programs from inside atom, it's going to make it really easy for us to do this. So you'll see right here, it's just atom runner, and I've actually already installed it, but over here there should be an install button just like you see down here. So click the Install button on atom runner. And once that's installed, then we have everything we need to start programming Ruby from inside here. So now that we have Adam runner installed, I'm going to show you guys how to set up your first Ruby file. So the first thing I'm going to do is come over here to file I'm actually going to add a project folder. So I'm just gonna click Add project folder. And I'm just going to add my Documents folder because this is a folder that I'm going to be working with throughout the course. And I'll just click open, you'll see over here, now we have this little like file explorer window. So that can actually be pretty useful just so we can see like, what the different files are that we're working with. So inside this Documents folder, I'm actually just going to click right click, and I'm going to say new file. And I'm going to go ahead and create a new file. And I'm just going to call this file draft.rb. So whenever we're creating a Ruby file, we want to use this.rb extension. And that's basically going to tell our computer that this is going to be a Ruby program. And you can name it whatever you want. I'm just naming it draft. So I'm gonna click Enter. And now we have our first Ruby file up and running. So what I want to do now is just write a simple line of Ruby code inside of here, we'll test it out, we'll make sure everything's working. And that way we know we have our environment set up to go for the rest of the course. So over here, I'm just going to type print. And I'm going to type an open and closed quotation marks. And I'm just going to type hello world. And I'm just going to go ahead and save that. So just print this out. And basically what this does is it just prints a line of text out onto the screen. So now what we want to do is use that atom runner plugin. So remember, we installed that atom runner plugin before. And now I can actually use that to execute this Ruby code. So I'm just going to click Ctrl N r, so Ctrl R, and you'll see this is going to go ahead and run our program. So down here at the bottom of the screen, I actually have this little output window. And you'll see down here that it's printed out hello world. So it's gone ahead and printed out hello world onto the screen. So as long as that's working as long as the ctrl r was able to run that atom runner package, and were able to execute the Ruby code, then everything set up, we're ready to start going in this course and ready to start writing some awesome Ruby code. In this tutorial, I'm going to talk to you guys about the basics of Ruby programs. So we're going to write a very simple Ruby program, we're going to talk about how those programs get executed the order in which the instructions in those programs get executed. We're also going to talk about different ways that we can print things out onto the screen, this is going to be a pretty awesome tutorial, I'm really excited. First thing I want to show you guys is how to print something out onto the screen. So you'll notice over here I have my little atom runner output window. And in the last tutorial, we talked about setting up this basic environment. So what I want to do is show you guys how to print something out onto this little console window over here. So all we have to do to print something out is just type print a space. And then if you want to print out like plain text, we can just make an open and close quotation marks. And we can put any text we want. So I could put like draft Academy here. And now what I run this program by clicking Ctrl R, you'll see that draft Academy gets printed out onto the screen over here. There's also another way that we can print something out onto the screen. So in addition to just saying print, I can also say puts and puts basically works the same way as print, it's going to take whatever we put inside of these quotation marks, and it's going to print it out onto the screen. So for example, I can type my name like Mike. And now this is going to get printed out onto the screen over here. Now you'll notice that draft Academy and Mike are getting printed out right next to each other. And this actually brings me to the first thing I want to talk about, which is the difference between print and puts. So you'll notice here I'm using this print command, I'm printing out draft Academy. And then right below it, I'm printing out Mike using this puts command. And when I use this print command, Mike just gets printed out right next to draft Academy, as you can see over here. But if I was to take this puts command and move it up here right above draft Academy, so now the program is going to execute puts Mike before it executes draft Academy, what you'll notice is that draft Academy gets printed out on a new line. That's because whenever you use this puts command, it's going to print out whatever you put over here. And it's also going to print out a new line afterwards, which basically means that when you use puts, you can print things out on different lines. When you use print however, everything gets printed out on the same line. So if I wanted to print out two things right next to each other, for example, I could print out something over here like is cool. Now these are going to get printed out right next to each other. So you can see it says draft Academy is cool. But if I was to do the same thing with puts, for example, if I did another puts down here and I said is cool. Because I'm using this puts up here, this is actually going to get printed out onto a new line. So you'll see down here that's exactly what happened. So That's the two different ways that we can print something out onto the screen using prints and using puts, again, puts will print out whatever you specify. And then it'll print out a new line, print will just print out whatever you specify no new line. So that's the basic difference between those two. So now what I want to do is just to show you how we can use these print statements to draw a little shape out onto the screen. So over here, I'm just going to say puts, and I'm going to make an open and close quotation mark. And I'm actually going to copy this a couple times. So we'll paste this like a few times down below here, I want to show you guys how we can just draw a basic like triangle shape. So I'm going to start with a forward slash down here. And I'll make another forward slash, another one up here. And another one there. And now I'm just going to make vertical bars going all the way down. And I'm going to make some underscores down here. And now we have a basic little triangle right here. So you can see I'm using this put statement. And individually on each one of these lines, I'm printing out some text. So now if I was to go over here and run my program, you'll notice that we're printing out this triangle. And it looks pretty good. So this is sort of the basics of drawing something out onto the screen, I also want to talk to you guys about how these programs get executed. So when we run our Ruby program or our Ruby script, basically what happens is Ruby is going to go through, and it's going to look at each line individually inside of this script, it's going to start with the first line here. So it's gonna say, Okay, the first instruction that the user wants me to do is print this line of text out onto the screen. So Ruby is going to look at this first instruction, it's going to execute it. And then once it's done with this instruction, it's going to move on to the next instruction that's moving on to the next line. And it's going to go ahead and execute this instruction. And then when it's done with this one, it's going to move on to the next line and the next line, etc. So Ruby is looking through each instruction that we give it inside of our program. And an instruction in Ruby is just something like this, it's like this puts or that print that we saw before, there's tons of these different instructions that we can give Ruby. But the point is, is that Ruby is going to execute them in the order that we write them. So Ruby is going to start with this line move on to this line, etc. So if I was to take this bottom line here, and move it up here to the top, now it's going to execute this line of code first. So you'll see over here, we get this like funky looking shape. So that's sort of like the bare basics of how Ruby is working, we're giving it sets of instructions, right, I'm just writing out a bunch of different instructions, and Ruby's going to execute them in order. And it's going to do essentially whatever we tell it to do. So right now all we're doing is telling Ruby to print something out onto the screen. But as we learn more about Ruby, and as we go forward, and we learn more instructions that we can give it, we can actually make programs to do just about anything. So as long as you can specify specific enough instructions for the computer, you can do anything inside of a programming language. And that's kind of like the core concept that I want to give you today, which is how these programs are structured and how to write essentially a basic program that prints a shape out onto the screen. In this tutorial, I want to talk to you guys about using variables in Ruby. Now in Ruby, you're going to be dealing with a lot of different data. And generally anytime you run a program, there's going to be all sorts of data that you want to maintain and manage. And a lot of times when you're dealing with large amounts of data, it can be difficult to manage, it can be difficult to keep track of it. So in Ruby, we have a special container, where we can store data values called a variable, and a variable those pretty awesome because we can actually take a piece of data or a piece of information in our Ruby programs, we can store it inside of a variable. And then whenever we want to use that piece of data or access it or modify it, we can just refer to its variable container. And you'll see in this tutorial why variables can be really useful. So let's go ahead and jump in down here I have a basic Ruby program written out. Essentially all it does is it prints out a story it says There once was a man named George, he was 70 years old. He really liked the name George, but didn't like being 70. And you'll see I'm just using this puts instruction over here. And here. It's just printing out the story onto the screen. So we're essentially just printing out everything that's over here onto the screen over here. So this is a pretty awesome program, right? It works. It's completely valid. But let's say that I wanted to go inside of my little story here and start modifying some of the information right, let's say that I wanted to change the character's name. So maybe I don't like the name George and I want to change his name to john. So I'm gonna have to go through and I found that first place where the character's name was and I'm the keeps her Through and then Okay, here's another place where we have the characters name. So I'm gonna change it. So now I've officially changed the character's name in the story. Let's say that I'm reading over the story again, and I'm thinking to myself, Hmm, I think we can make the character a little bit younger. So instead of 70, why don't we make him 35? Right. So again, I'm gonna have to look through this entire program. Alright, found the first 70. So I'll change this to 35, I have to keep looking through. And okay, here's the other 70. So we'll change this to 35. Alright, so now updated the name and the age. But here's the problem. What I wanted to change the character's name and the character's age, I had to manually go into my program into the story, and modify each value. So every place where the character's name was mentioned, I had to update it to the new name, every place where the character's age was mentioned, I had to go in and update it. And this is kind of a problem, right? This is a situation where we have two pieces of data, the character's name and the character's age. And we're trying to keep track of that information, right. But imagine that instead of just having a story, that was four lines, I had a story that was hundreds of lines long, right, and they mentioned the character's name, you know, hundreds of times, if I wanted to then go through and change my character's name and my story, it would be a real drag, right, I would have to look through hundreds of lines of code. In order to do that same goes for the age. And this is actually where variables come in. So this is a perfect example of a time where we have two pieces of information the name and age, and we want to be able to keep track of them and maintain them a lot better than we currently are. So what I can actually do is I can create a container, and I can put the character's name inside of its own container, I can put the character's age inside of its own container. And then when I want to access that information and use it, I can just access that container. And that container is called a variable. So I'm going to show you guys how we can use variables to seriously increase the usability of this program. So up here, up above these puts lines, I'm actually going to create a variable. And whenever we create a variable, we need to give Ruby some information. The first piece of information we need to give Ruby is the name of the variable that we want to create. So generally, when we create a container to put information in inside of our programs, we'd like to give it a descriptive name, right? Generally, you want to give the container, a name that will identify what information is inside of it. So the first thing I'm going to go do over here is type in the name of the variable that I want to create. So I'm going to create one called character name. And generally in Ruby, if you're creating a variable, you want to give it a descriptive name. And if there's going to be multiple words like character name, you want to separate them with an underscore. So the next thing I have to do is tell Ruby what I want to store inside of this variable. So I can just say character name, and I can use this equal sign, and I can set it equal to a value. So I can say character name equals, and I'm just gonna say, john, because this is going to be the new characters name. So now I've officially created a variable called the character name, the next thing we can do is create another variable to store the character's age. So I'm going to do the same thing, I'm just gonna say, character age. And I'm going to set this equal to 35. So now we have two variables, both of which are storing values. So down here in my program, what I can actually do, instead of just typing out the character's name like this, you know, manually, I can actually just refer to the variable that is storing the characters name. So over here, instead of saying There once was a man named john, I can actually just get rid of this. And outside of these quotation marks, I'm actually going to make a plus sign. And now I'm going to type out the name of the variable that I want to put in here. So I'm just gonna say, character underscore name, essentially, what I'm doing is I'm saying I want to type out all of this text over here, plus, I want to type out the value that's inside of the characters name. So I want to print out the value that's inside this character name variable. There's one more thing we have to do anytime you're using a string of text like this, and you're also using a variable name, you need to surround this whole thing with parentheses. So I'm going to put a parentheses over there. And I'm going to put a parentheses over here. So now, we'll actually be able to use this program. So let's go ahead and we're going to run this program. And now you'll see that over here, it still says There once was a man named john, he was 35 years old, etc. But you'll notice that we didn't have to manually print like type out the word john. All we had to do was refer to the actual variable name, character name. So I just refer to this variable and it was a Able to insert the value that was stored inside that variable inside of our print statement. So I can basically do this same thing for this guy down here. So I'm just going to copy this. And I'm going to paste this in down here. So now I'm adding in the character name where john was in that other spot. So over here, we're also going to have to put another parentheses. And I'm going to do the same thing for the characters age. So over here, once again, we'll just surround this with parentheses. And now I'm just going to close off both of these. So I have two separate little strings of text inside of quotation marks. And I'm going to put a plus sign, I'm going to type in the variable name, character age. And then I'm going to put another plus sign. Essentially, what I'm doing is I'm telling Ruby that I want to print this out, plus, I want to print out the value inside of the character age variable. Plus, I want to print this out over here. So that's essentially what this is doing. And we can do the same thing down here. So and again, we're going to need to surround this with parentheses. So once we've done this, now we've actually set up our program to use all of these variables. So every place where we mentioned the characters age, we replaced it with the character age variable, every place where we mentioned the character's name, we replaced it with the character name variable. So when I run this program, now, you'll see over here, we get exactly the same output as we did before, we're printing out the same exact story, the only differences now that we're using variables, our program is a lot better. So for example, if I wanted to change the characters name inside of my story, instead of having to go through and manually change it in every single spot where we mentioned it, I can actually come up here and just modify it. So I could change the characters named Mike. And now, without having to modify anything else in my entire program, the characters name is going to be updated to Mike. So you can see now it's using the name, Mike. And that's really why variables are powerful, because they allow us to organize and they allow us to keep track of the information and the data inside of our programs a lot better, the other thing you can do is you can actually modify the value of variables. So let's say halfway through my story, I wanted the character's name to change, I can actually come down here, and I'm just going to put this line of code right after these first two and right before the second two, I can change the value of a variable. So I can say, character name, and I can just set it equal to something else. So I can set it equal to Tom, for example. So now when I go and run my program, you'll see that halfway through the story, the character's name changes. So over here, it's Mike, and then halfway through, it changes to Tom. So you can update and modify the values of these variables throughout your program. And that can be extremely useful. So that's sort of the basics of variables. And these can be really useful, there's a lot more that we can talk about. So for example, over here, I'm just storing text information, right, I'm storing like, the text Mike, I'm storing the text 35. Down here, we're using all this text. But in Ruby, we can actually represent we can store a bunch of different types of data inside of our variables. And that's what I'm going to be talking about. In the next tutorial, we're going to be talking about data types. So there's all different types of data types, we can store like text, data, numbers, true false values, a bunch of different stuff. So stick around for the next tutorial, and we'll talk about that. In this tutorial, I want to talk to you about data types in Ruby. But data type is essentially a type of data that we can represent and use inside of our Ruby programs. And by default, Ruby is going to support a bunch of different data types. So these are basically just types of information that we can use in our programs. And I want to talk to you guys about the different types of data that we can use. And we're going to look at how we can store those different types of data inside of variables. So down here, I'm actually going to create a couple of different variables. And we're going to store some different types of information inside of those variables. And the first and probably most basic type of data that we can represent in our Ruby programs is called a string. And a string is basically just plain text. So anytime we want to represent plain text, in our Ruby programs, we can use a string, so I could just make a string called like name, and I could set it equal to Mike. So this is a good example of a string. It's basically a variable, and we're storing a string value inside of it. So the string is just like any plain text, right? You could also make another one occupation and we can set it equal to like programmer, whatever you can store any like information that you'd want to store as plain text inside of your programs as a string. We could also store numbers so for example, I could store a whole number Like if I wanted to specify someone's age, I could say age is like 75. Right. So someone might be 75 years old, we can represent numbers like this inside of our Ruby programs. And you'll notice that with a number, I didn't need to use these quotation marks, I just had to type out the number that I wanted to type out. You can also use decimal numbers. So this right here, 75 is what will be referred to as an integer. And an integer is basically just a counting number like 234567. Basically a number like a whole number. A decimal number is different because a decimal has decimal points after it. And a lot of times, especially in Ruby, more referred to these numbers as floating point numbers, basically just means that their decimal numbers, so if I wanted to specify a floating point number, I could say like GPA, and we can set it equal to like 3.2. Or you can set it equal to 3.2854, or whatever, like you can set it equal to, you know, whatever decimal point you want to represent inside of Ruby. So using integers and using floats, you can represent different types of numbers, you can also make these negative, so I can make this like a negative 75, or a negative 3.2. And Ruby is going to be just fine with that. In addition to storing numbers, we can also store something called a Boolean. And a Boolean is basically a true or false data type. So a lot of times in programs, we're going to want to represent true or false data. And this might not be something that you're super used to doing in the real world. But in programming, when we're specifying types of data, a lot of data is going to fall into like the true or false category. For example, if I created a variable called is male, this variable can tell us whether or not someone is a male, in which case it's going to be like a true or false value, right? They're either a male, or they're not, it only has two possible values. So I can set this equal to true because I'm a guy, you can also create one, you know, it can be like is tall, and this Boolean variable would tell us whether or not someone's tall, right, so if you're not tall that it would be false. So a lot of information in our programs can be represented with one of two values either true or false, we can also store one more type of information, which is called nil. And the nil data type basically means that it doesn't have a value. So for example, if I created a variable called like flaws, and I set it equal to nil, basically, what this means is this flaws variable doesn't have a value. So we can go out of our way to say that something is nil, like to say that it has no value. So these are the basic data types in Ruby. And there's actually like a couple other like more obscure data types that we can use. But for the most part, these are the data types that you're going to be using as a beginner to the Ruby programming language. So we can store and represent information in either a text form with a string number form with an integer, which is a whole number, or a floating point number, which is like a decimal number. Or we can use true or false values. And we can also use nil, which would mean no value. So these are sort of the basics. And as we go forward in this Ruby course, we're gonna be looking at all sorts of ways that we can work with this type of data. And this tutorial, I want to talk to you guys about working with strings in Ruby. Now strings are one of the most common data types in Ruby. And for good reason. A lot of times in our programs, we're going to want to represent and store and work with plain text data. That's essentially what a string is. So in this tutorial, I want to walk you guys through the basics of using strings, we're going to look at some different things we can do as strings, we're going to also look at different things called methods which we can use on string. So a method is essentially just a little block of code that we can call and it will either modify our string or give us information about our string, so can be pretty awesome. First thing I want to do is just show you guys basically how to print out a string so I could say puts, and over here, to create my string, I just have to put it inside of open and closed quotation marks. So anything I put inside these quotation marks is going to be considered a string. So I could just type out like draft Academy. And now this is going to get printed out over here onto the screen works pretty well. There's a couple things we can do inside of these strings. So one thing you might be wondering is how can I print out a quotation mark. So for example, this string is surrounded by quotation marks, we use the quotation marks to tell Ruby where the string starts and ends. But what if I wanted to use quotation marks inside of this string? If I just tried to put one right here, you'll see that it messes everything up and ends the string. In order to use a quotation mark, I can put a backslash, and then put the quotation mark and this is basically going to tell Ruby, hey, I want to literally enter in the character quotation mark. I don't want to use it to end off my string. So now I should be able to print this out. Over here, you'll see we're printing out a quotation mark. You can also use something similar to print out a new line. So let's say that I want To print out and draft, and then on a new line print out Academy, I can type a backslash n. And I'm actually going to get rid of this space. And now you'll see that this is going to print out draft Academy on two separate lines. So that can be pretty useful. Another thing we can do is we can store strings inside of variables. So if I didn't want to just type this out like this, I could put it inside of a variable inside of a container. And it'll be a little bit easier for me to work with. So why don't we create a variable called phrase, and I'm just going to set it equal to draft Academy. Now, if we wanted to print this out, all I have to do is come down here and just type in the name of the variable that I want to print out. So now we'll just be printing out phrase. And you'll see we're still printing out draft Academy. So using these variables can be pretty useful. And when we're working with strings, we can actually use things called string methods, or sometimes you'll hear people refer to them as string functions. Essentially, what these are little blocks of code. And we can call these blocks of code. And they'll go off and they'll either modify our strings will change it in some way, shape, or form. Or they'll give us information about our strings, these can be really useful. And there's just a few that I want to show you. And you'll kind of get the hang of how to use these. Whenever we are going to use one of these methods, we just want to type out either the name of the variable that storing the string, or just the string itself. And then I want to type out dot. And now I want to type in the name of the method or function that we want to access. So I'm going to show you guys a couple that are pretty useful, I found them in them to be pretty useful. The first is called up case, you're just going to type up case, and then an open and closed parentheses. And actually, this open and close parentheses in a lot of situations is going to be optional. But I'm just going to include it just to be super correct. So when I type phrase.up case, and we run this program, you'll see now it takes our string, it takes our phrase, and converts it entirely into uppercase letters, you can also use another one called down case. So instead of saying upper case, we'll just say down case, and this is going to convert it down to all lowercase letters. So this can be a pretty useful little function, there's also another one called strip. So if I had a string that had a bunch of leading and trailing spaces, right, I wouldn't necessarily want to just print this out. So if I print this out onto my screen, you'll see that we get it printed out all weird, right? There's these, you know, spaces in front, there's these spaces after, you can use a method called strips, I'm just going to type out phrase dot strip. And now when I run my program, all of that leading and trailing whitespace gets deleted. So a lot of cases when you're dealing with a variable, you might not know if it has leading and trailing whitespace. So you can use this strip method to make sure that all that disappears, we can also use these methods to find out information about our strings. For example, instead of saying strip, I could say phrase dot length, and this is going to tell me how many characters are inside of this string. So you see over here, we get 24. And actually, let me get rid of all this whitespace. So now we should get a smaller number 15. So draft Academy has 15 characters in it, that's including any of the spaces that we put inside of it. In addition to figuring out how many characters are in a string, I can also figure out if certain text shows up in my strings. So for example, I could say phrase dot include. So I'm gonna say include, and now I'm going to type a question mark. And then I'm going to type a space. And now I'm going to type a string, I'm going to type another string. Basically, what we're saying is, we're asking this include method whether or not this phrase includes the string that we're going to put over here. So for example, if I put Academy right here, this is going to return a true or a false value, telling us whether or not the word Academy shows up inside of our phrase. So over here, we should get a true value because Academy does show up. If I was to type out like academies, though. So for example, this isn't inside of our phrase, it's gonna give me a false value. So that's a really good way to figure out if a certain string or a certain phrase, or a certain character shows up in the string that you're working with, we can also access individual characters inside of these strings. So for example, let's say that I wanted to just figure out what the first character in the string was. So maybe I was just given this variable phrase, and I don't know what's inside of it. And I want to figure out what the first character is, I can type out the string and then I can make an open and closed square bracket. And inside of the square brackets, I can put the index of the character that I want to access. So if I wanted to access this G, I can actually put a zero inside of here. So now you'll see this is just going to print out that G. If I wanted to access this I, I could put a one in here. And this is going to print out the I if I wanted to access this a for example I can it was going to be 0123. So I'm going to put a three in here and now we'll be able to access that a so if you haven't caught on Already, the way that we assign index positions to strings in Ruby is starting with zero. So if I was going to give these characters index positions, I would say that g is an index position zero is an index position one, r two, a three, f four other f5, e6, etc. So whenever we want to access the first character in a string, we have to access it using index position zero. And this is kind of like a staple of using strings in Ruby, the first character is always at index position zero. So essentially, Ruby starts counting at zero. So anytime we want to use this little method right here, where we're just passing in a number, you always want to start with zero as the first character. So let's do a little experiment. Let's say I wanted to access this capital A, it's going to be 012345678. So I put an eight in here, now we're going to print out that capital A. So play around with these different string indexes. You know, this is obviously not super difficult to understand. But you want to get used to starting indexes at zero as you start programming, you can also print out a range of characters. So let's say I wanted to figure out what the first three characters inside of this string where I can say zero, I can type a comma. And I can basically specify a range. So I can say I want to print out or I want to get access to the characters from position index position zero up to another index position. So we can say zero, let's say we want the first three, I can say zero, up to 0123. And this is actually going to give me the first three characters, so it's going to give me 01. And two, and it's actually not going to give me that third index position character, so I should just get g IR here, you can see that's exactly what we get. So when we specify a range down here, we start the range at the first index position zero, and we end it at three, but we don't include the character at index position three, so we didn't include this a. So that's basically how we can grab like characters in a specific range inside of the string, you can also use another method, and I'm just gonna type phrase dot index. And basically what this is going to do is it's going to tell us what position a specific character in our string starts at. So for example, I could say phrase dot index, and I can type in like a capital G. And this should give me a zero, because zero is where our capital G is at, if I typed in like a capital A here, this should give me the index position where capital H shows up inside of our string. So it's going to be an eight, you can also type in just a normal string here. So I could say, like FFP. And this will tell me where FFP starts inside of my string. And it starts at index position four, so 01234, this index method is actually pretty useful. So these string methods can be extremely useful when you're working with strings. And they basically just allow you to take your strings, and you can either modify them, or you can find out different information about them. And these are going to be very useful. Also just want to point out that you can use these little methods on things other than just variables. So for example, if I came down here, I could print out like a string. And I could say dot, and now I can say like uppercase, and it's still gonna work exactly like it worked when we use it on that variable. So now when I run this, it'll do exactly the same thing. So you don't have to have these inside of variables in order to use these different methods. So those are just a couple of the different methods that you can use with strings in Ruby, what I would recommend is going on Google and just typing in like Ruby string methods. And then there should be like, huge list of all the different methods that you can use with these strings. But I would say for the most part, those are some of the most common methods that you're going to be seeing. And really, I just wanted to give you guys an introduction into how we can work with strings inside of our programs, we're going to talk about how we can use different methods to do different things. Hopefully, you learned something, and hopefully now you can go off and start playing around with strings inside of your programs. In this tutorial, I want to talk to you about working with numbers in Ruby. So we're going to take a deep dive, we're going to look at all the different things you can do with numbers. We're talking about the different types of numbers in Ruby, and we're gonna look at some awesome Ruby methods that we can use on our numbers to do a bunch of different stuff. So this is gonna be a pretty cool tutorial. But down here, I'm just going to show you guys the basics of working with numbers, I can just say like puts in this, we'll just print something onto the screen just so we can kind of see what's going on. When I want to use a number in Ruby, it's really easy. You just type out the number so I can type out like five for example. And now this is going to get printed out onto the screen as five. In addition to just using whole numbers like this, we can also use decimal numbers so I can see like 5.86543 it's going to do exactly the same thing. So now over here, it'll be able to print that out. We can also use negative numbers so I can put a negative in front of here and again, right He's going to have no problem dealing with negative numbers. And it isn't just using numbers though, we can also use basic arithmetic. So for example, I can say like five plus nine, and this will actually be able to go through and print out the answer. So not only is Ruby going to print out five plus nine, it's actually going to do that calculation for us and print the answer out onto the screen, which is pretty cool. So we can use addition, we could use subtraction, we could use multiplication, which is just this Asterix, we could use division. So those are like the four basic types of resin of arithmetic, but we can also use exponential. So for example, let's say I wanted to take two rays to like the third power, I can just do something like this, I can say two, multiplication multiplications, so two Asterix is and then three. And this is basically going to be the same thing as saying two raised to the third power. So now we should get two cubed, which is eight. So it's going to be a really handy operation here, we can also use something else, which is called the modulus operator. So I could say, for example, 10, a percent sign and then three. And what this is going to do is it's going to take 10, it's going to divide it by three, and it's going to spit out the remainder. So 10 divided by three is three, right 369 with a remainder of one. So when I run this, you'll see it prints out a one. So it's basically printing out the remainder that we get from dividing these two numbers. And that can be pretty useful. In addition to just having numbers over here like this, I can also store numbers inside of a variable. So I can come over here and say like, num, this is the name of a variable, and we can set it equal to like 20. And then down here, if I wanted to access that number, I can just print out the variable. So now we're printing out the actual variable. And I want to point out, one cool thing with numbers is you can actually print out numbers and strings inside of the same print statement. So for example, I can say like, my fav num, and over here, I can put a plus sign. And what this is basically going to allow me to do is print out this string alongside this number. But you'll see over here, when I actually print this out, we're going to get a couple errors. And the first thing we have to do is we always want to put this inside of parentheses. So I'm going to surround this whole thing with parentheses, that's because we're referring to this variable. But also, if I want to print out a number alongside of a string, I actually have to convert this number into a string. And I can do that by saying num.to underscore s. And basically, what this is going to do is it's going to take this number, it's going to convert it into a string. And then we'll be able to print both of these side by sides, you can see now it just says my fav num 20. That's a really useful way to do something like that. So in addition to just working with normal numbers, we can actually use special things called methods. The method is essentially just a block of code that we can call, which will either modify our number or it'll give us information about a number. Sometimes it'll also do like mathematical calculations on the number. So now here, I can say like put num, when I want to access one of these number methods, I can say dot and then I can type out the name of the method that I want to use. So for example, I can say num dot abs, and an open and close parentheses. And basically what this is going to do is it's going to tell me the absolute value of num. So if I put like a negative 20, up here, now this is just going to return 20. Because it's giving me the absolute value. There's also some methods that we can use with decimal numbers. So for example, if this was like 20.487, I can use num dot round. And this will actually round the number for me. So over here, you'll see we just get 20. So it's basically rounded the number but if I was to make this like a six, now we should get 21. So it's rounding it up or down, you'd also use a ceiling and a floor function. So a ceiling will always take the higher number and the floor will always take the lower number. So for example, if I said 20.18 cetera, let's just say 20.1. And I said num dot c i L, this is actually just going to return 21. So it's going to give us the highest number, or it's going to give us the next highest number from 20. If I was to say like 20.9, and I said num dot floor, this is just going to give me 20. So it's basically just gonna cut off that decimal point, give me the lower number, in addition to just using these normal methods, or you also hear these referred to sometimes as functions. So in addition to using these methods or functions, we can also use other special methods which are inside of something called the math class. And don't worry too much about what a class is. But essentially, there's this entity inside of our Ruby programs called math. And we can use it to perform specific math operations on numbers. So if I came over here, I could type out math like that with a capital M, I can type a dot, and now inside of this math class, and again, don't worry too much about what a class is. But inside of this math entity in Ruby, there's a bunch of these methods that we can use. So for example, I could say math dot Sq RT and open and close parentheses. Now inside of this open close parentheses, I can give this a number. So for example, I could put like 36 inside of here. And what this is going to do is it's going to give us the square root of this number 36. As you can see, over here, we get six, you could also use something like the logarithmic function. So I could say math dot log, put like a one in here. And now we're going to get 0.0 back. So there's a lot of these different like math operations, you can do a lot of things with like sine, cosine, tangent, like logarithmic stuff. So this can be really useful if you're just trying to work with math inside of Ruby. So the last thing I want to talk to you guys about in this tutorial is working with floating point numbers and working with integer numbers. So there's two basic types of numbers in Ruby, we have integer numbers, which are like whole numbers. So an integer would be like 20, or 21, or 22. We also have decimal numbers, which would be like 22.1 22.2, etc. integers and floats can be used inside of Ruby, basically interchangeably, although there are two, like separate types. So Ruby does distinguish between a whole number and a floating point number, but I want to show you guys how we can use these together. So for example, like if I came down here, and I just added two integers, like I added one plus seven, you'll notice that we're going to get an integer back, so it's going to be eight. But if I added like 1.0, and seven, now you'll see we're getting a floating point number back, so we're getting a decimal back. So whenever you add two integers, you always get an integer back or multiply two integers divide, subtract two integers, you're always going to get an integer back. So for example, if I said like 10, divided by seven, this shouldn't be an integer number. This should be like some long decimal number. But you'll notice that I'm just getting a one back. So I'm only getting an integer back. But if I said like 10 divided by 7.0, now I'm going to get the full number back. So whenever you're using an integer, and a floating point number together to do some operation, you're always going to get a floating point back, if you're using two integers, you'll get an integer back. And if you're using two floats, obviously, you're going to get a floating point number back. So that's kind of the difference between those two. And Ruby doesn't really give you too much of a hassle. When you're using numbers, you know, you can basically use integers and floats interchangeably. But just know that Ruby does distinguish between the two of them. So if you're doing different types of math, with different types of numbers, like integers or floating point numbers, there's going to be a difference in the type of answer that you're going to get. So that's really the basics of working with numbers. I mean, I can spend all day talking about all the different methods and you know, little caveats here and there that you can use with numbers in Ruby. But I think that's kind of a good coverage of the basics. And so now your job is just to go off and play around with all this different stuff. And really just get comfortable working with numbers in your Ruby program. In this tutorial, I'm going to talk to you guys about getting input from users and Ruby, this is going to be awesome, basically going to allow a user to input information into our programs, we're going to store whatever they input into a variable. And then we're going to print out that variable along with a message that basically just says hi to whoever entered the information. So in order to get information from the user, we're actually going to have to do one thing. And if you've been following along with this course, we've been using this atom runner program in order to run our Ruby files. And this is a really awesome convenient way in order to just run a Ruby file. But here's the problem, if we want to get input from a user, inside of our Ruby programs, we actually can't use this little atom runner plug in to do it, we're gonna have to use something called the terminal or the command prompt. And if you're on Windows, this is a program called the command prompt. If you're on Mac, it's called the terminal. Basically, it's an environment where we can interact with our computer using text. And in order to interact with the computer and input information into our Ruby programs, we're going to have to use the terminal. So the first thing I want to do is show you guys how to set that up. And then we'll look at getting input from the user. So this is going to be instructions for doing this inside of atom over here. I'm just going to go over to the preferences inside of atom or the settings. And down here, I'm just going to click this install tab. And I want to search for a package and we're looking for a package which is called platformio hyphen ID e terminal. So search for this. And you'll see it shows up over here and I actually already have it installed, but you want to install this platformio id e terminal. Basically what this is going to allow us to do is use a terminal or a command prompt if you're on Windows straight from inside atom. So install that. And now we're just going to go back over here. You might need to restart your atom program in order to use it but eventually what you should get is a little problem. Sign You see, there's this plus sign down here at the bottom left. And when I hover over it, it says new terminal. So once you have this installed, you want to go ahead and click that. And a little terminal window should pop up down here, you'll notice mine is just black with white text. So this is where we can run our Ruby program in order to get input from a user. And this is also another way that you can run your Ruby programs. So down here, as long as you have your Ruby file open inside of atom, so as long as this file is open, when you open up platformio id terminal into a new terminal, it should automatically open up to the location where your Ruby file is. Now, you know, I'm not going to get too into like using the terminal in this tutorial. But essentially, you can navigate through the different folders and the different files inside of your computer using the terminal or the command prompt. So as long as you have your Ruby file open, like I have this draft Ruby file open, this should automatically open to the correct directory, so you won't have to worry about that. So once we're here, I just want to type in Ruby. And then I want to type in the name of the file that I want to run. So in my case, it's just draft.rb. And what this is going to do is it's going to run the file for us now when I click enter, it's going to run the file and you know, it'll basically stop, we don't have any code up here. So if I was to print out like, Hello, now when I run this, again, I can just type it in and click Enter, and you'll see that we get the program running. So that's basically how we can run a Ruby program from inside of our command line or inside of our terminal. So we're going to have to do this in order to get input from the user. Just so you guys know. Alright, so let's talk about how we can get input from the user. Basically, I'm going to allow the user to input a piece of information, we're going to store that piece of information inside of a variable, and we're going to print it out onto the screen. So first thing I want to do is actually just type out a prompt. So I want to tell the user what I want them to enter. So I can just say puts, and I'm just gonna say enter your name. And now once we've prompted them to enter some information, I can use a special command in Ruby called gets. And basically what this is going to do is it's going to allow the user to enter a piece of information into our program. So it's basically going to stop the execution of the program and wait for the user to enter something. And what I want to do is I want to store whatever the user enters inside of a variable. So I'm actually going to create a variable called name. And I'm going to set it equal to guests. And basically, what this is going to do is it's going to tell Ruby to take whatever the user inputs into the program and store it inside of this name variable. So the last thing I want to do is come down here, I'm just gonna say puts, and I'm going to print out some text, I'm going to say hello, plus name. So basically, I'm printing out hello to whoever entered in information into the program. So I'm going to save this. Now I'm going to come down here and I'm just going to run this program. So you'll notice, if you click the up arrow on your arrow keys on your keyboard, it will actually just insert the last line that you entered. So I just click the up arrow here. And now when I click enter, you'll see that it says enter your name. So I'm going to enter my name is going to be Mike. And now when I click Enter, and actually we're getting an error here, I should actually need puts down here not put, that's my bad. So let's do this again. So I'm going to enter my name, Mike. And now when I click enter, it's going to say, Hello, Mike. So it's basically just saying hi to me. So that's the basics of getting input from the user, you can use this gets in order to get specific information. Now, I do want to talk to you guys about one more thing, which is basically something that happens in Ruby when we enter information. And let me sort of illustrate this. So down here, I'm saying hello, name. And after this, why don't we print something else out. So I'll say like, you are cool. Alright, so I'm basically printing out Hello, name, you are cool. Now I'm going to go ahead and run this program and you guys will see what happens. So I'm running the program, I'm entering in my name, Mike. Now when I click enter, you'll notice that it prints out Hello, Mike, but then it prints out a new line. And it says that other text. basically what's happening here is when I click enter, Ruby is not only taking that as the text that we entered, but also as a new line. So whenever you click enter it basically like is going to insert a new line. So Ruby is essentially printing out Mike, then the newline character and then all the text over here. In order to mitigate that all I have to do is come over here and say name is equal to get dot Chomp, and an open and close parentheses. And this is going to get rid of that new line character that happens when we click enter. So now when I run my program, it's going to be able to work correctly. So I'll say enter your name Mike. And now it just says hello Mike. You are cool. So now our program is working perfectly. So you If you want to keep that new line, when the user clicks enter, you can go ahead and just not put dot chomp here. But in a lot of cases, you're going to want to go ahead and just put that in there. So that's the basics of getting input from a user. And if I wanted, I can get multiple pieces of information. So for example, I could say puts, enter your name. And I'm actually just going to copy this. And now we'll say like, enter your age. And we'll do the same thing. I'll store it in a variable called age. So now we can actually come down here and we can print out like Hello, Mike, you are. And then we could just print out like the age. So now it'll just be printing out age. So now we can get two pieces of input from the user. So let's run our program. And it says, enter your name, Mike. And let's say that I'm like 59. So now it's printing out. Hello, Mike, you are 59. So we're getting input from the user, we're getting two pieces of input from the user. And we're printing them out onto the screen. So that's the basics of getting input. And in the next couple lessons, we're going to talk about other ways that we can do this. And basically ways we can make this work a little bit better. In this tutorial, I'm going to teach you guys how to build a very basic calculator in Ruby, we're basically going to build a little program that will allow the user to enter in two numbers, and then we'll print out the sum of those two numbers. So we'll get the two numbers from the user, we'll add them together, and we'll tell them what the answer is, it's gonna be pretty cool. And it'll kind of give you guys some more information about getting input from users, specifically how we can get numbers from users. So keep in mind, In this lesson, we're going to be using the terminal or the command prompt, in order to get information from the user. So you want to make sure that either if you're using atom, you can use this platformio id terminal plugin that I talked to you guys about in the last lesson. Or you can just use your normal like terminal or your normal command prompt. So I'm going to be using this little atom plug in that I have. So let's talk about how we can get input from the user. Specifically, we need to get to numbers. So down here, in our program, we can just write out the code to do that. So I'm going to first write a prompt, I'm just going to say puts, and we're just going to type out a message for the user. So we'll say enter a number. And then we're basically going to get that number that they entered and store it inside of a variable. So I'm going to create a variable called num one. And I'm going to set it equal to gets dot chomp. And gets is basically going to get whatever information the user enters in, and chomp is going to get rid of the new line that they accidentally enter when they click the Enter buttons. So whenever you click enter in Ruby, and you're inputting information into the program, it's going to add a new line onto the end of whatever you input. So this is just going to get rid of that for us. The next thing I want to say is another prompt, so I'm gonna say puts, and I'm going to tell them to enter another number. And once again, we're going to do the same thing. So I'm just going to say num two is equal to get stop shop. So essentially, we're asking them to enter in two numbers. Now, all we want to do is just print out the result of those two numbers. So I'm going to put, and I'm going to put this inside of parentheses, and I'm going to say num one plus number two, right? Essentially, what we're doing is we're getting two numbers, and then we're printing out the sum of those two numbers onto the screen. So let's go ahead and do that. I'm going to come down here into my terminal window. And I'm just going to run this program. So I'm just going to type out Ruby draft.rb. And this is going to run the program for me. So it says down here, enter a number. So why don't we enter five, enter another number. Let's enter two. And now when I click enter, this should add the two numbers together and print out the answer. So click Enter. And you'll notice down here, we're actually getting a little bit weird of an answer, we're getting the answer 52. The last time I checked, five plus two wasn't 52. Essentially, what we're doing is we're concatenating these two strings together. So here's the problem. When you enter in information into Ruby, Ruby automatically just converts whatever you enter in into a string. So byte you can enter in as many numbers as you want, you can enter in decimal numbers, normal numbers, doesn't matter, Ruby's just going to convert it into a string. And when we add two strings together like this inside of a put statement, it just does what's called concatenating the strings, so it takes the first string and adds the other string onto the end of it, right. So that's why we get five to in order to actually add these two numbers together, we're going to have to convert the strings that the user enters into numbers. So over here we're getting a number num one here we're getting a number num two. But remember, when we actually store those variables, they're getting stored as strings. So all we have to do is take num one, convert it into a number, taking them to convert it into a number, and then we'll be able to run this program successfully. So all I have to do to do that is just say num 1.2 and underscore, and then I, so it's not 1.2 I and basically what this means is we're converting num one into an integer, I'm going to do the same thing over here dot two, I. So now we're basically taking these two strings num one and m two and converting them into integers. So Ruby is going to take whatever the numbers that were inside of those strings, and convert them into integers. So let's go ahead and run our program. So I'm gonna come down here, I'm just going to type in clear. And I'm going to type in Ruby draft.rb. So it says enter a number, we'll enter in five, enter another number, let's enter in two. Now when I click enter, you'll notice that we're getting the answer which is seven. So that's pretty awesome, right, we were able to build our calculator, and it was able to add the numbers together. Here's the problem, though. Let's say I come down here and I run this program again, and I enter in a five. But now I enter in a 2.5. So for example, instead of just entering in two, I'm entering in a decimal number 2.5. When I run this program, Now, you'll notice that we're still getting seven. So our program wasn't able to add this z, this point five on to the answer. That's because over here, we're converting these to integers. So we're saying num, one is going to get converted into an integer, num two is going to get converted into an integer. And so really, all this is doing is it's adding in the integer five, and it's adding in the integer value of 2.5, which is just going to be two together. So if I want to be able to add in decimal numbers in my program, instead of saying two I I'm going to say two F, and to AP is basically going to convert whatever is inside of those strings into floating point numbers, so into decimal numbers. So now when I run this program down here, we'll be able to do that addition. So if I say Ruby, and I'm just gonna enter in a five, and now we'll enter in that 2.5. And now they should give us the number that we wanted. So we're going to get 7.5. So two F or two I or two really useful little functions that we can use on numbers. And in some cases, you're only going to want the user to be able to enter an integer. So you can just say two I. In other cases, though, you want them to use floating points, so we can use to f. So that's the basics of building our little calculator. Now, I also want to point out one way that we can make this program a little bit easier. So instead of saying num 1.2, f down here, I could actually come up here. And I could say gets.chomp.to, F. And I can do the same for this one over here.to F. And now this is going to convert them up here, so we don't have to convert them down here. So this is going to work exactly the same as it worked before. So I can say like 5.6 and 7.2. And it'll be able to add them. So that's, there's another way that we can do that. But that's sort of how we can build a basic calculator inside of our Ruby programs. In this tutorial, I want to talk to you guys about building a Mad Libs game in Ruby. So we're gonna build a little mad libs game. And I'll kind of show you some more about how we can get input from a user. So if you're not familiar with Mad Libs, a Mad Libs is basically just a game where you would enter in like a bunch of random like words maybe like nouns, verbs, adjectives, adverbs, and then you'd take all of those words that you'd enter in and like sort of sprinkle them in inside of a story. And generally like since you're entering in random words, the story is going to be like kind of funny. So over here I have an example of a Madlib you can see down here, it's like telling the user to enter in like a noun, a plural noun, an adjective, and we're actually can build a Mad Libs game inside of our Ruby program. So down here, you'll notice I have a little basic program set up, it's basically printing out this poem. Roses are red, violets are blue. I love you. So this is, you know, kind of a classic poem, but I think we can mix it up a little bit and create a Mad Libs for this poem. So how would we say instead of Roses are red, well let the user enter in a color. Instead of saying violets are blue, we'll let them enter in a plural noun. And instead of saying I love you, why don't we let them enter in like someone else so maybe like a celebrity, instead of having just Roses are red, violets are blue I love you will have roses are and whatever the color the user enters in, whatever the plural noun they enter in, or blue, and then I love a certain celebrity. So this would be kind of funny. So let's set up our program. The first thing I want to do is get input from the user. So I want to be able to get three pieces of information from the user, I want to get the color. I want to get the plural noun and then I want to get the celebrity after we get that input. Then we'll intersperse those variables inside of this little output. So let's get the input from the user, I'm just going to come over here and we'll just print out a prompt, it'll just say, enter a color. So the first thing they'll do is enter the color. And now what we're going to do is store that in a variable called color. So I'll say color is equal to get dot chump. And remember, chomp is just getting rid of the new line that gets entered when you click the enter button. Alright, so we'll enter in a guess. And we're also going to do two more of these, I'm just going to paste this two more times. And then we're going to enter in a plural noun. And we'll make a variable called plural noun. And finally, they're going to enter in a celebrity. So we'll make a variable called celebrity. So now we have three variables that are storing the three pieces of information that the user input. last step is to come down here. And instead of just printing out color inside of curly brackets, I'm actually just going to add in that color variable. So we'll print out color, same thing for the plural noun. And same thing for the celebrity. And now our program is essentially set up, we're getting the input, and then we're just printing out the actual embed libs. So remember, whenever we get input from the user, I have to use my terminal down here. So instead of just using this little like atom runner plugin that we've been using throughout the course, I'm going to use my terminal. And down here, I'm just going to go to the directory where my Ruby file is stored. And I can just run it so I'm just gonna say Ruby draft.rb. That's the name of the file, and I'm gonna run the program. So it's going to ask me to enter a color. So why don't we enter in like magenta? says, enter a plural now and I'm going to enter in microwaves and enter a celebrity. Why don't we do like Tom Hanks. So now what should happen when I click enter is all of that information should get put inside of our Mad Libs, and we should get the finished story. So I'm gonna click Enter. And you'll see down here we get our finished story. So it just says roses are magenta, microwaves are blue. I love Tom Hanks. So basically, the user could run this program, they could enter in all the words for the Madlib. And then we'll basically just be printing out Madeline. So it's actually a pretty simple program, you can see how easy it is to build a game like a Madlib inside of Ruby, it's super easy. And also if you want and you can make this a lot more complex. So you get to have them add in like adverbs, verbs, adjectives, like all sorts of stuff inside of here make obviously the story a little bit longer. And you could essentially replicate any Madlib inside of your Ruby program, which is awesome. And this tutorial, I want to talk to you guys about using arrays in Ruby, and Ruby, we're going to be dealing with lots of information. And a lot of times when you're writing programs, there's going to be a bunch of different values that you want to store and keep track of. And one way that we can keep track of the data inside of our programs is using a simple variable. Here's the problem with the variable, though it can only really store one single value, as I can create a variable, I can store a value inside of it. But what happens when I have a lots of data, it's going to be kind of a pain in the butt to have to create like hundreds of different variables, if I want to keep track of and maintain hundreds of different pieces of information. And this is where arrays come in. An array is essentially a structure or a container, a lot like a normal variable. The only difference being that an array can hold multiple values. So unlike a normal variable, an array can hold like 10, or 20, or 100, or a million different items inside of it. And a lot of times when we're programming in Ruby, and we're dealing with large amounts of information, we're going to want to be able to use arrays. So let's jump in, I'm going to show you guys how to use arrays and talk about you know, what they are, how to create them how to put stuff inside of them all that fun stuff. So down here, if I want to create an array, I created a lot like I would a normal variable, the first thing we have to do is tell Ruby what we want that array to be called. So in my case, why don't we make an array that's going to store a bunch of names of my friends. So I can make an array called friends. And I'm going to set this equal to array with a capital A, and then we're going to make an open and closed square bracket. inside of this open and close square bracket, I can start putting in some of the pieces of data that I want to store in this array. In my case, I'm just going to store a bunch of strings with names of some of my friends. So I can store on like Kevin, Karen, and Oscar. So here we have an array that has three elements inside of it. And each one of these pieces of data are referred to as array elements. Basically what I did is I created a container that can hold multiple pieces of information. So what I can do Now is I can come down here and I can just say like, puts friends. And this is actually going to print out all of the information inside of this array, all the data values on my output over here. So you can see, we're printing out Kevin, Karen and Oscar. So that's the basics of using an array. And if I didn't want to just store strings, I can store any type of data inside here. So I can sort of strings, I can even store like a number, or I can store a boolean value like false, you can put all different types of information, all different data types, inside of these arrays. And if you want, you can even put different data types together in the same array. But for our purposes, let's just stick with strings. So let's say that I wanted to access one specific element inside of this array. Well, if I want to access just one element, I can make an open and close square brackets after I'm referring to the variable name. And I can put an index inside of here. So let's say that I wanted to grab Kevin, let's say I wanted to grab this first string inside of my array, I can put a zero inside of here, and zero refers to the index of this Kevin value. So now when I print this out, you'll see we're just printing out Kevin. And this brings me to a point about arrays, we start indexing arrays of zero. So I would say that this Kevin attribute of this Kevin element inside of the array is at index position zero. Karen is at index position one, and Oscar is at index position two, so the first element is always in index position zero, and then you just basically count up from there. So if I wanted to access Oscar over here, I could put a two inside of here. And now this is going to print out Oscar, another thing I can do is I can access array elements from the back of the array. So for example, another way I could access Oscar would be by putting a negative one in here. Basically, what this is going to do is it's going to grab the item in the array, but it'll start counting from the back. So it'll basically like this would be negative one, Oscar, this would be negative two, and this would be negative three. So if I said negative two in here, now we're going to be grabbing Karen and printing that out. So that's two different ways that we can access elements inside of the array, I can also grab a range of elements. So for example, let's say I only wanted to grab the first two elements inside this array, and I didn't want to grab the third one, I could say zero, and then I could say two. And basically, what this is going to do is it's going to grab index position zero all the way up to but not including index position two, so it's going to grab zero, and one, and it's going to stop at two, so we're not going to grab two. So now we're just going to get Kevin and Karen. And this can be really useful just specifying like a range inside of this square brackets. There's also a bunch of other stuff that we can do with these arrays. So for example, let's say I wanted to modify one of the values inside of the array, I can come down here and I can just say, friends, let's say I wanted to change this first element and exhibitions here, I could say friends, zero, and I can give it a new value. So I can say like Dwight, and now instead of having the value of Kevin, this is going to have the value of Dwight. So when we print it out, we get that new value. And you can access and modify any individual element inside the array, just by referring to its index. There's also going to be situations where you're not going to know exactly what elements you want to put inside of the array right upfront. So for example, over here, I knew exactly what friends I wanted to put in this array. But in some cases, you're not going to know that right off the bat. So we can just say array dot new. And now we're basically telling Ruby that we want friends to be an array, but that we don't want to put any values into it just yet. Then down in my program, I can just start putting stuff in here. So for example, right now, if I printed out friend zero, you'll notice that nothing prints out, it's just a nil value. Right? If I came over down here, though, I could say friends zero, and I can just give this whatever value I want. So I can give this a value of like Michael. And now friend zero is going to be Michael. And you can do that as much as you want. So I can even come down here and say like friends, five, and I can give this a value. So now this is going to be equal to Holly. And what you'll see over here, when I print out just the entire friends array, it's going to fill in all of the elements that are between zero and five, just with blank elements. So those are just going to be nil. So that's kind of how you can create an array and not give it some initial information yet, and then add in information later. There's also a bunch of different methods that we can use with these arrays. So let's go back to that array that we were using before with all the friends. So if I wanted to access specific information about this array, I can use a little method so I could say like friends dot and one really useful one is length. So this will tell me how many elements are inside of this array. So you see over here we have three I can also check to see if certain elements are inside. The array so I can say friends dot include, and I'm gonna put a question mark. And over here, I can type in an element that I would want to check to see if it's in the array. So I could say, like Karen. And now this should give us a true value because Karen is inside of the array. If I put like Karen's, though, so I changed it. Now this is going to give a false value, because that's not in the array, you can also modify the order of the array. So I can say, like friends dot reverse, and this will reverse all the elements. So now it's going to be Oscar, Karen. And then Kevin. As you can see over here, you can also sort of different elements in the array. So for example, if I wanted, I could sort all the elements. So if I were working with strings, we could sort them alphabetically. So if I put something over here, like Andy, and now Andy is going to end up being in the front, because it's going to sort the array alphabetically. So I'll say friends, that sort. And now when we print this out, you'll see Andy care and Kevin Oscar, so moved Andy to the front, because a comes before K and O. It's important to note though, that if you're going to have an array that has multiple data types, so for example, if I put a n number like an integer in here, this is going to throw an error now, because you can't sort it, there's no, there's no way for us to compare, like numbers and strings inside of Ruby. So that's the basics of working with arrays and arrays are super useful, there's going to be tons of situations where we're going to want to store large amounts of information in a single container. And arrays are great at doing that. In this tutorial, I want to talk to you guys about using hashes in Ruby. Now, a hash is basically a type of data structure where we can store a bunch of different pieces of information. If you're familiar with arrays in Ruby, they're very similar to arrays. So a hash is basically doing the same thing. It's allowing us to store multiple pieces of information. The difference is that with hashes, we can actually store something called a key value pair. And a key value pair is basically where we can store of value. And we can give it a key which is kind of like a name. Now a lot of times you'll hear hashes, also called dictionaries. And that's because they act a lot like dictionaries, picture a dictionary, like in a dictionary, you have two parts to every word, right? You have the actual word itself. But then, in addition to the word, you actually have the definition, right, so you could say that the word is the key. And the definition is the value. So that's basically what hash is. And you'll kind of see what this is, as we kind of go through this tutorial. And this tutorial, I want to build a little hash, which will store state codes. So for example, I live in the United States, and we have a bunch of different states. And each state has a specific code. So for example, Pennsylvania, PA, right, New York is NY, California is CA, Michigan is EMI, right, so you can map a state like New York to a specific abbreviation like NY, we can map California to a specific abbreviation ca. And that's basically what I want to represent inside of my hash. So we're going to build a hash, which can store all of those different abbreviations. And you'll see why these data structures are useful and how they're different from arrays. So down here, I want to create my hash. And in order to do that, you basically just have to give the hash a name. So I'm just going to call this states. And I'm going to set it equal to an open and closed curly bracket just like that. And a lot of times when people are making hashes, they'll end up putting a new line here. So inside of here, we can specify a bunch of different key value pairs. Okay, so what I want, I want the keys to be the actual state names. And I want the values to be the abbreviations for those states. So basically, all we have to do is just type out a key and then we can type out a value. So the first thing I'm going to do is type a key. So why don't we map like Pennsylvania. And so Pennsylvania is going to be the key. And now I can map this to a value. So I can just say equals and then a greater than sign. And over here, I can type in a value. So I'm just gonna type PA. Okay. So essentially, what I'm doing is I'm defining the key, and I'm defining the value. Now I'm going to type a comma. And I can go and define another key value pair. So why don't we do New York City, New York. And we're going to map this to and why. And why don't we do another one, Oregon is another state, and we'll map this to o r. So in here, I'm basically have three different states and I'm not going to do all 50 states, but I have a key and then I have a value. Now here's one thing you need to know about these hashes is you can only have unique keys. So for example, I couldn't create another key down here. called Pennsylvania, that's gonna be a big No, no, when we're creating hashes, you always want to have unique keys. Alright, so now that we have these input into here, we can actually start using this hash. So down here, if I wanted, I could just print this out. So I can come down here and say put, and it's just called states. So we can put this and when I print this out, you'll notice that we're printing out this little structure. It's just like Pennsylvania, that gets mapped to PA, New York gets mapped to NY, etc. But one of the most powerful things we can do with these hashes is we can actually give it a key, and it'll tell us the corresponding value. So I can come in here and inside of these square brackets, I can just input a key. So I get input like Oregon. And now this is going to print out the value for Oregon. So it's going to print out, or I could put inside here, New York. And now this is going to print out ny because it maps to New York. So that's like a super useful way that we can store our data, we could give this structure a key, and it would spit out the corresponding value. There's also a couple other ways that we can create these keys. So for example, instead of putting Pennsylvania inside of quotation marks, I could also just put a colon here. And now this is going to be the same thing. So down here, I could specify like Pennsylvania, and actually, this should be capital. And now it'll still give me that same value. So it'll, it'll still give me pa up here. You can also use in addition to like strings, we could also use numbers. So down here, I could say one. And if I put one down here, now we're basically going to get the same thing. So this should still print out pa and you can see that it does over there. So these hashes are extremely useful. And there's a lot of situations where you're going to want to map keys to values. So for example, in this situation, we're mapping a key, which is the state name to a value, which is the state abbreviation. But you could do the same thing for like days of the week, you could do it for a month abbreviations you could do it for I mean, really, there's a tons of situations where this type of structure is going to come in handy. And now I just want to point out how these are different from arrays. So normally, when I create an array, I'm just creating like a list of individual values, right. But when I create a hash, I'm creating a list of key value pairs. And I can give this hash a specific key, and it'll spit out the corresponding value. So this is a very useful data structure. And this is definitely something you're gonna want to play around with and get used to using. In this tutorial, I want to talk to you guys about methods in Ruby. Now, a method is basically just a block of code that we can write, which will perform a specific task for us. A lot of times in Ruby, you're gonna have different groups of code, different groupings of code, they're going to perform specific tasks, or they're going to do certain things. And what we can do in Ruby is we can take all of that code that's, you know, designed to perform one task, we can put it inside something called a method. And what's cool about methods is you can actually call them from other places inside your program. And we can give methods information, and then they can give us information back. So in this tutorial, I'm just going to talk to you guys about the basics of using methods, we're going to write a method, and we're going to look at how they can be useful. So the first thing I'm going to do is create a method. And our method is going to be very simple. all it's going to do is say hi to the user. So our method is going to perform one task and has one goal, and it's going to say hi to the user. So down here, I'm going to create my method. First thing we always want to do when we create a method is type out d f. And this basically means that we're defining a method. Second thing we want to do is give our method a name. So generally, you want to give your methods descriptive names. So it's very obvious what task they're performing. In our case, our method is saying hi to someone, so we can just call it Say hi, just like that. And now what I want to do is hit Enter, and I'm going to come down here and I'm just going to type and so essentially, what I'm doing is I'm defining a method block. And anything that's in between death and end is going to be inside of our method. A lot of times people will indent here just to show that the code is like inside the method. So in here again, we have one goal, we want to say hi, so I'm just going to type puts. And I'll just say hello, user. Cool. So now I'm going to run my program and we'll see if this method works. So I'm just going to run the program. But you'll notice over here, when I run the program, nothing's showing up. And that's because when we define a method, the code inside of the method is only going to get executed when we call it so in other words, we want to execute the code inside this method, we have to call the method, that basically just means we have to say like, Hey method, go do your stuff go perform your task. So I can come down here. And the way I call this method is just by typing out its name. So I can type out, say, hi. And now Ruby is going to execute this method up here. So you can see over here, we have Hello users. So everything's working. And I just want to show you guys one thing. So if I typed out, like, top up here, and then typed out, bottom over here, I want to show you guys the flow of these methods inside of our program. So now when I run this program, you'll see we're printing out top, hello, user. And then bottom, essentially, what's happening is, Ruby is looking at this line of code, it's executing it, then it sees, say, hi. So it knows, okay, the user wants me to execute the say, Hi, method. So Ruby is going to jump up, it's going to execute all of the code inside of this, say, Hi method. And then once it's done executing all of that code, it's going to jump down, back down here, and it's going to print out bottom. And I just want to point out, you can put as many lines of code inside of one of these methods as you want. Obviously, this is like a simple method. So we're just keeping it simple. But that's the basic execution flow of functions or methods. And actually, this brings me to a good point, a lot of times, these are called methods. But you'll also hear people calling these functions. Essentially, in the case of Ruby, these words are basically interchangeable, basically means the same thing. But for the most part in Ruby, we're referring to them as methods. Alright, so let me show you guys some more cool stuff we can do. One thing we can do is we can actually give these methods some information. So I can actually take this Say hi method. And I could actually allow the user to tell it, who to say hi to. And the way that I'm going to do that is after I type the name of the method, say hi, I'm going to make an open and close parentheses. And over here, I just want to specify what's called a parameter. And a parameter is basically a value that whoever is calling this method is going to give to it. So this method can actually accept inputs, it can accept parameters as input. So over here, I can just type out the name of the parameter I want to accept. So in our case, we'll just call this name because it's going to be the name of who we want to say hi to. And then down here, instead of saying, hello user, I can say hello, name. And you'll see in a second, this is going to use whatever variable and whatever piece of information gets passed into this method. So down here, if I want to give this a name, I can make an open and close parentheses. And in here, I could type in name. So I could say, Mike. So now when we run our program, it's going to say, Hello, Mike, essentially, what's happening is the say, Hi, method is specifying that you can give it a name. And down here, I can, when I call the method, I can give it that piece of information, you can also give these things multiple pieces of information. So I can also specify age. And then down here, we can incorporate that into our print statement. So I can say hello, name you are, and now we'll print out their age. So I can just say age. And essentially, this will take in two parameters, and it will print them both out over there. So down here, I can just specify the first parameter Mike. And then I can specify the age. So we can say like, you know, 73, or something. And now it's going to say, Hello, Mike, you are 73. And actually, you'll see we're getting an error over here. And this is actually a good little catch. So age, I'm actually passing in an integer. And whenever we want to print out an integer inside of a print statement like this with strings, we always have to say age.to underscore s. So that's why we're getting that error. And that's something that you always want to watch out for in Ruby. So now when we run our program, it says, Hello, Mike, you are 73. So that's pretty cool. We can pass this two pieces of information. But let's say that I didn't want to pass this in age, right? Maybe I didn't know how old Mike was. So I didn't want to give it an age. Well, now when we're when we run our program, you'll see that we're getting an error, right? So because I didn't include an age, when I call this, it's throwing an error. One way we can mitigate this in Ruby is we can actually give these variables default values, we can give these parameters default value. So I can come over here and say name is equal to no name. And we can just say age is equal to negative one. And essentially, what's going to happen now is if I don't include an age in here, it's just going to print out the default. So it says hello, Mike, you are negative one, right? If I wasn't including the name in here, it's just going to use both of those default values. See, let's see. I'm not passing any parameters. And now it basically just says hello, no name, you are negative one. So sometimes specifying default values can be a good way to control these methods and really, it depends so In some methods, you're going to want whoever's calling them to give you certain pieces of information. But if those pieces of information are like optional, you can just give them default values like that. So that's the basics of working with methods. And there's actually one more thing we can talk about, and I'm going to talk about it in the next video. It's something called return types. Basically, we can give the method information and the method can give us information back. But for now, this is just the basics and hope you guys learned something about methods. In this tutorial, I want to talk to you guys about using returns in Ruby methods. So in the last tutorial, we talked a lot about writing methods, we looked at how we could give methods, some information through parameters. And this is all real, I want to talk to you guys about how methods can give us information back. So when I call a method inside of my program, that method will go off, it'll execute all this code, but then it can actually give us a piece of information or in some cases, multiple pieces of information back. And that can be really useful. So for the purposes of this tutorial, I want to show you guys how we can create a cube function. So in math, when you cube a number, you essentially take it to the third power. So if I was going to cube two, it'd be like to raise to the third power. So essentially, it would just be two times two times two, right? So why don't we write a little method that's going to do that for us. So this method will cube a number, and it's going to be pretty interesting. So down here, I'm just gonna say def, and we'll say cube. And we want to pass in one number, so I'm just gonna specify that they need to pass in a num. And then down here, we're gonna say, and what's cool about these methods, they can actually give us information back. So if I was gonna cube the number, it would basically just be num times num, times num, right? So that's essentially like all we would need to do to cube the number. But what's cool is when I call this cube function, and I give it a number, so like, I give it a two, if I was to print this out, so if I said puts cube two, this is actually going to print out num times num times num. So it's actually going to print out this answer over here. So let's take a look. You'll see here, we're printing out eight, if I was to pass in like three over here, now we should get 27. So basically, what's happening is we're calling this cube method. And this cube method is giving us a value back. So when I call this, this is actually like ends up representing a value and ends up representing the value that was given back to it. And if you want to give a value back, all you have to do is basically just specify it right here. So that's a really cool way that we can use these methods to get information back. But sometimes when you're working in these programs, that might not be super clear what value you want to return. So for example, I have num times num times num here. But if I put a four down here, right below this, or even if I put like a string or whatever, let's put a five, you'll notice that now instead of returning num times num times num, this is actually going to return five. And that's because five is the last line inside of this method. It's basically like the last returnable piece of information that's inside of this method. So in situations like this, you can actually use what's called the return work keyword. So I can say return right before here. And even though there's a value after this, you'll see that this is going to return num times num times num anyway. So we're returning 27. And actually, here's the interesting part is any code that goes before this return keyword, or that goes after this return keyword isn't gonna get executed. So if I put a puts down here, and I printed out Hello, when I run my program, you'll notice that it doesn't print out Hello, like nothing is getting printed out. Basically, what's happening is when we use this return keyword, that's going to signal to Ruby that we're done with the method. So when Ruby sees this return keyword, it's basically going to jump and break out of the method and move on to the next line of code. So essentially, when you're using the return keyword, nothing after it is going to get executed. And that's just a little tip. So in addition to returning just normal numbers like we did over here, we can also return multiple pieces of information and keep mine You can return any data type, it doesn't have to be like a number. It could be a string could be Boolean could be anything. If I wanted though, I can return multiple numbers. So for example, I could return num times num times num. And then if I put a comma here, I can return another value so I can return like 17. And now when I run my program, in addition to returning 27 you'll see that it's also returning 70. So I'm getting two pieces of information. And this is basically just returning like an array so I could access each individual value that got returned by its index. So if I said q three square brackets one that's just going to give Give me 70. They want to be careful when you're returning multiple values just because if you're returning like five or six different values that can get a little bit confusing, especially for, you know, the code that's actually calling these functions, but for the most part that can actually be pretty useful. So that's the basics of using that return keyword and also just returning values. In general, this can be a super powerful way to to make your methods a lot better. In this tutorial, I want to talk to you guys about using if statements in Ruby, an if statement is a special structure that we can use in Ruby in order to help our programs to make decisions. They also have our programs to respond to the different information in the program. So if certain information has certain values, we can do certain things. Other information has different values, we can do different things, basically, if statements make our programs a little bit smarter. So in this tutorial, I'm just going to give you guys a basic overview of if statements, what we can do with them, how we can use them, and essentially just get you guys up and running with if statements. So over here, I just have this little text file. And it actually has some common if statements that human beings every day will encounter. So believe it or not, if statements also apply to like human beings. So let me show you guys a couple of these. The first one up here says I wake up, if I'm hungry, I eat breakfast. So let's break this down a little bit. You'll see right here we have a condition, right? If I'm hungry, this condition is either true or false, right? on the condition that they're hungry, then they're going to go ahead and eat breakfast. If they're not hungry, though, if this condition is false, then we're just going to move on and they're not going to eat breakfast, right? That's something that pretty much every morning, everybody is going to have to like ask themself at some point. Here's another one, it says, I leave my house. If it's cloudy, I bring an umbrella. Otherwise, I bring sunglasses. So up here you'll notice the same pattern, we have another condition, right, the condition is if it's cloudy, if that condition is true, if it is indeed cloudy, then they're going to bring the umbrella. But if the conditions false, in other words, if it's not cloudy, then we're going to come down here and we'll bring the sunglasses. So this one's a little bit different from the one up above. Because if this condition, if it's not cloudy, if this is false, then we're going to do something else. So I have one more down here at the bottom that says I'm at a restaurant. If I want meat, I order a steak. Otherwise, if I want pasta, I order spaghetti and meatballs. Otherwise, I ordered a salad. So this one's even more complex, right we have our condition says if I want meat, if that's true, we order the steak. Otherwise, if that's false, in other words, if you don't want meat, then we check another condition. So we're checking to see if we want pasta. If that's true, we get the spaghetti and meatballs. Finally, though this is false when we get the salad. So these are the three basic if statements. And these are three if statements that we can actually use. And these are the types of things that we can do inside of our program. So we can specify certain conditions. If those conditions are true, we can do certain things, those conditions are not true, we can do other things. So I'm going to show you guys basically how this works. Let's go over here to our Ruby file. So I'm just in my draft.rb file. And I'm going to create a if statement. So I'm going to show you guys how this works. The first thing we're going to do before we actually make the if statement is just make a variable, so I'm just going to call it is male. And this is going to be a boolean variable, it's going to tell us whether or not someone is male. So let's say this is a piece of information that we were storing inside of our program like whether or not someone's male. So in my case, I have a male so I'm going to set it equal to true. So down here we can actually make an if statement. So we can do something depending on the value of this variable is male. So I can say if and over here I want to specify a condition. So remember, when we were looking at those text files, it was like if it's cloudy, or if I'm hungry, or if I want me right we were giving these those statements, different conditions. In this case, we're going to specify our own condition. So I'm going to say if is male, and inside of this condition we need to include either a true or a false value. So bullions are great with this because a Boolean can either have a value of true or false. So I can say if is male, and then down here I just want to type out and now whatever goes in between if an end is going to get executed when is male is true. So over here we can just put you are male, right? So now because is male is true. When I run my program, you'll see over here it says you are male, so the program is working. If I was to change is male to false, however, So I'm just gonna put false. Now you'll see that this code isn't getting executed. So we're not printing anything out. That's the basics of an if statement, right, I can specify a condition. If the condition is true, then we'll execute the code down here. If the condition is false, we just skip over it. So I'm going to show you guys how we can use something called an else. So basically, what happens if we want to do something when the person's not male, right, so we have it covered, if the person's male, we're going to tell them they're a male, but what if they're not a male? Well, I can actually come down here, and I can type out else. So I'm just gonna say else. And then again, below else, I'm going to put code so I can say puts, you are not male. So now we basically have an if statement that will handle both of the possible scenario. So if they're male, it'll tell them they're male. Otherwise, it'll tell them they're not male, so you'll see is male is false. And over here, we were telling them that they're not male. If I was to change this back to true, now, it's gonna say you are male. So it's essentially able to react to the value of that variable. Let's make this if statement a little bit more complex. So why don't we add in another Boolean variable, I'm going to say is tall. And we'll set is tall equal to actually let's set it to true initially, we'll also set this to true. So is tall will tell us whether or not a specific person or a specific entity you know is tall. So what happens down here, if we want to do something when they're male, and they're also tall, I can actually use another keyword in Ruby, which is called and so I could say if is male, and is tall. And basically what this is going to do is it's going to execute the code inside of here, when they're both male. And they're also tall. So here, we could say you are a tall male. And so now this code is only going to execute when is male is true, and is tall is true. So they're both true, right? Now let's run our program, it says you are a tall male. But if I was to set one of these equal to false, so for example, if I set in is tall, equal to false, now, it's not going to tell us that we are a tall male anymore. So it's just gonna say you are not male, although I guess we would have to change this down here. So we can say you are either not male or not tall, or both. And so now it's telling us you're either not male, or not tall, or both, because we know for a fact that they're not male and tall. So that's how we can we can check to conditions. And in addition to using an and I could also use another keyword called or, basically this will execute if they're either male, or if they're tall. So only one of these variables has to be true now, right, this is going to execute if they're male, or if they're tall. So you'll see over here is male is true and is tall is false. But this is still gonna execute, you are a tall male. And obviously, we can change, you know, whatever is getting printed out there. But hopefully, you get the point, when we say and both of the conditions have to be true. So if I was to say, is male, and is tall, these would both have to be true. In order for this code to get executed. If I say or only one of them needs to be true. Now both of them can still be true and will still execute that code. But only one of them has to be true. And if both of them are false, then we'll execute the code down here. So I'm going to go back to is male and is tall. And let's say that I want to check to see the other conditions, right. So we're already checking one condition, we're checking to see if they're male, and they're tall. But what if we wanted to do something when they're male, and they're not tall? Well, I can use something called an else F. And then f is basically another key word in Ruby that will check another condition. So I could say like, LS if and this just stands for elsif. And I want to type in another condition after this. So why don't we check to see if they're male. So I'm going to say elsif is male. And I want to check to see if they're not tall. And the way that I can check to see if they're not something is I can use a exclamation point. So if I said, and exclamation point is tall, this is basically saying not is tall. So when they're not tall, this is going to be true. And we're doing that using this exclamation point. It's called the negation operator. So down here, we can put some more code. So I could just say puts you are a short male, right? basically what's happening is it's going to check this if condition. So Ruby is going to check this if statement up here, if they're either not male or they're not tall. So in other words, if this whole thing is false, it's going to come down here, and it's going to check this next condition and if this is false, it's going to go down to the else. But if this is true, it'll execute the code inside here, there's actually one more scenario that we could cover, which is when they're tall, but they're not a male. So I'm going to use another elsif, I'll say else, if not, is male, so I'm using that exclamation point and is tall. And if this is true, then we can just print out, you are not male, but are tall. And then also down here, if the code inside of this else block is getting executed, then we're going to know that they're not male and not tall. So we can say you are not male and not tall. Alright, so let's go ahead and run our program. So I'm going to set is male equal to true and is tall equal to true right off the bat just to start. So I'm running the program and you'll see it's able to handle that situation says you are a tall male, if I was to set is male equal to false, though, our program is going to be able to handle that situation. So it's going to say you are not male, but are tall, right, our program just by using these if statements was able to give us information based off of these values. If I was to make is tall, false, and is male true, it's going to be able to handle that. So it will say you are a short male. If I make both of these false, it's going to be able to handle that as well. So it's going to say you are not male and not tall. So that's the basics of using if statements, you can see down here, I'm checking a condition. And in a lot of cases, you're going to want to check more than one condition. So you can use either and, or or I'm checking these conditions. If the condition is true, then we'll execute the code down here. And by the way, you can put as much code down here as you'd want. I mean, I could put hundreds of lines of code if I wanted to. So I'm using the if statements. And I'm using these else ifs and I'm using this else in order to catch all of these different scenarios. And these else ifs are really useful because you can check multiple conditions when other conditions are false. So that's the basics of working with if statements, there's actually some more stuff we can learn with these. Instead of just using Boolean like true and false, we can also use things called comparisons. And I'm going to be talking about that in the next tutorial. But for now, this is just kind of been a brief introduction into if statements in Ruby. In this tutorial, I want to talk to you guys some more about if statements. Specifically, we're going to be talking about using comparisons with if statements. So in any if statement, you're going to need a condition. And a condition is basically a true or a false value. One of the cool things about Ruby though, is we can use a comparison in order to get a true or false value. So inside of our condition, or if statement, we can actually compare different values. And depending on the result of that comparison, we'll be able to either execute the code inside of the if statement or move on. So I'm going to show you guys how we can do this. It's really awesome. And it's a super powerful feature, what I want to do in this tutorial is actually create a method. So I want to create a method called max. And this method is going to take three numbers as input. So it's going to take three parameters. And basically what it's going to do is it's going to return whichever number is the largest. So whichever number out of the three is the biggest, it'll basically return that back to the user. And this is a great example of a situation where you'd want to use comparisons inside of your if statements. So let's get started. I'm just going to come down here and we'll start making our function or our method. So I'm just going to say def, and we're going to call it max. And I'm gonna make an open and close parentheses. inside of this parentheses, I can specify any parameters that I want this method to take in. So I'm just gonna say num one, number two and num three. Basically, we're taking in three numbers. Now down here, I'm just gonna say and, and inside of this method, we have to devise an algorithm to figure out which number is the biggest right. So inside of this method, we don't know which of these is the biggest right, we have no idea we have no idea what the user input into here. So we need to use an if statement in order to figure that out. So I can say if now inside of this condition, I can actually compare two numbers. So I could say if num one is greater than or equal to num, two, and num one is greater than or equal to num three. So remember, inside of an if statement, we need to put a condition here. And in the last tutorial, when we were using conditions we were putting in true or false Boolean values, what you'll notice is when I compare two values, when I compare number one and number two, this is actually going to get resolved into a true or a false value. So this comparison is either true or its false. num one is either greater than or equal to num two or it's not. This is actually going to end up being a boolean value, this is going to end up being true or false. Same thing over here, num one is either greater than or equal to num three, or it's not. It's a boolean value, there's only two possible situations here, it's either true or its false, we didn't actually have to put like true or false, here, we were able to use a comparison in order to get a true or false value. So if num one is greater than num, two, and it's greater than num, three, then we can just return num one because we know that's the maximum number. Down here, I'm just going to say elsif. And I want to check another condition. So I'm going to check to see if num two is greater than num one, we're actually greater than or equal to num one. And num two is greater than or equal to num three. So if num two is bigger than num, one and num three. In other words, if the result of both of these comparisons is true, then we know that num two is the biggest number. So we're just going to return that. And finally, we can use an else statement. So I can use that else keyword, I can just say else. And down here we can just return num three. Because if num one isn't the biggest and num two isn't the biggest, then we can be pretty sure that num three is the biggest. So this is basically how we can use comparisons inside of our if statements. I also want you guys to notice that I was able to use this return keyword multiple times, right. So if this condition is true, we can just return the number. Alright, so let's go ahead and run this function. So I'm going to come down here, and I'm going to call this function, I'm gonna say Max, and I'm going to pass it three numbers one, two, and three. So if I print this out, I print out the value that gets returned, actually, I'm gonna put it I should get a three back. So let's go ahead and run this. And actually, you'll see I'm getting an error over here, I forgot to put in the end keyword. So down here, we just have to put an end. So you'll see we have an end keyword here. And this ends off this if statement, we have another end keyword here. And this ends off this function declaration. So that's something to keep in mind, you always want to make sure that you're remembering to include this end keyword, you can see how easy it is to forget, I just forgot it. So I'm going to run this program and you'll see we're getting three. So I pass it three numbers, if I was to make this middle number, the largest, so we'll make it 20. Now it should return 20. If I was to make the first number, the largest, it's going to return that. So we now have a valid working max function that will always tell us what the maximum number is. So I just want to point this out one more time what was happening, instead of putting a true or a false value in there, we actually indirectly put a true or a false value in there by making a comparison. And the result of that comparison is either going to be true or false. There's no other situation right? No one's either bigger, greater than or equal to num two or it's not, I'm also using something called a comparison operator. So this right here is a comparison operator. It's an operator that we can use to compare different values. This one is greater than or equal to, but there's also some other ones. So for example, probably the most basic is a double equals, and this basically means equal to, I can put a exclamation point in equal sign, this means not equal to so this would be like num one is not equal to num two, we can do a greater than sign a greater than or equal to sign a less than sign a less than or equal to sine. And all of those are going to allow us to compare different values. It's also important to note that, in addition to this using numbers, you could also use strings here so you can compare different strings. For example, I can compare two strings for equality, I could check to see if one string was equal to another string. And that's really a powerful way that we can use these if statements is by checking comparisons. A lot of times in your programs, you're going to want to compare different values. And depending on the results of those comparisons do different things. In this tutorial, I want to talk to you guys about creating a better calculator in Ruby. If you've been following along with this course, then you'll know that in the beginning of the course, we created a very simple calculator. Basically, we allow the user to input in two numbers, we took those numbers, added them together and then printed out the answer onto the screen. So it's a really simple calculator. But in this tutorial, we're going to be building an even better calculator. This calculator is not only going to be able to add two numbers, but it'll be able to add, subtract, multiply and divide numbers and will allow the user to choose which one they're going to do. So this is going to be pretty cool. And we're going to use a lot of the stuff that we've learned up to this point in this course in order to do it. So the first order of business when we're creating our calculator As we need to get some input from the user, I need to get certain information, right, we need to get the first number, we need to get the second number, and then we need to get the operation that they want to perform. So they would need to type in like two, and then a plus sign, and then a five, you know, something like that, basically. So let's go ahead and do that down here in my program, the first thing I want to do is, is print out a prompt. So I'm going to say puts, and we're going to print out enter first number, basically, we're prompting them to enter in the first number. And then what I want to do is I want to take whatever number they enter, and I want to store it inside of a variable. So I'm going to create a variable called num one. And I'm just going to set it equal to get dot chunk. And this will basically just get the number that they enter in and remove the new line that gets entered when we click the enter key. So now that we've done this, we can do something similar for the other two pieces of information we need the next the next thing I want to get is the operator. So I'm just going to say enter operator. And basically this is going to be like plus minus division or multiplication, they're going to enter in whatever they want to do. So over here, instead of saying num, one, we can just say Opie, and this is going to Stanford operator, and we're just going to get whatever they input. Finally, I'm going to ask them to enter the second number. So I'll say enter second number, and we're just going to store this as num, two. So essentially, what we're doing is we're asking them to enter in the first number. Once they do that, we're asking them to enter in the operator plus minus division, multiplication, subtraction, whatever, then we're asking them to enter in the second number, and we're storing all of that information inside of variables. Now there's one more thing we have to do. Remember, when the user enters in a number in, when we ask them for input, it automatically gets converted into a string. So what we want to do is want to convert the number that they enter from a string into a floating point number. So I'm just going to say gets.chomp.to underscore F, and this is going to convert it into a floating point number, I'm going to do the same thing down here.to underscore F. So now number one, and number two are going to be floating point numbers, assuming the user entered the number in correctly. Alright, so once we do that, we actually need to do a couple other things. So the first thing we need to do is we need to figure out if they want us to add the numbers, subtract the numbers, multiply the numbers or divide the numbers, right? We have no way of doing that right now. So we need to figure out, how can we figure out if they entered in a plus sign? How can we figure it out, if they entered in a minus sign, we need some way of figuring out what they entered. And this is a perfect scenario where we can use an if statement. Remember, an if statement allows us to respond to the different values in our programs. So if something has a certain value, we can do something it has another value, we can do something else. perfect situation right here. For an if statement, we can check to see if it's a plus sign. If it's a minus sign, if it's a division sign, and depending on the one it is we can do something down here, I'm going to create an if statement, I'm just going to say if. And then we always want to make sure that we end off the if statement down here. And up here we're going to put a condition, I'm going to be checking a couple different conditions in this if block. The first thing I'm going to do is check to see if it's equal to a plus sign. So I can check to see if op. And remember, op was the operator that got entered is equal to I'm going to make those double equals and over here, we'll just make a plus sign. So this is going to be true if the operator they entered was a plus sign. So down here, what we can do is we can just say puts, and we'll just print out the answer. So I'm just going to put num one plus num, two. Awesome. But there's also some other scenarios, right the scenario where they enter a minus sign. So I can say elsif elf if, and I'm going to say oh p is equal to minus sign. If that's true, we're just going to put num one minus num two, we can do the same thing for multiplication and division. So I'm going to go ahead and copy this, this will just make it go by a little quicker. And now instead of checking for subtraction was check for division, which is just going to be a forward slash. Finally, we can check for multiplication. So I'm going to come down here and we'll just check for an Asterix and then down here we'll multiply them. So we're able to basically capture the four types of arithmetic right and respond to them appropriately. There's going to be one more situation though that we want to cover which is that they enter in an operator that's not valid. So I'm just gonna say else. And remember, the code inside of this else is only going to get executed when none of the stuff up here is true. So when none of this stuff is true, in other words, if it's not plus sine minus division or multiplication, we can just print out an error we can say put invalid operator And that's basically going to give them a little error message like, Hey, you messed up, you didn't put in the right operator. So we've essentially written out our program, we get the three pieces of information, we check to see what operator they put in, and we respond to it. So let's run our program and see how it works. Now remember, whenever we're running a program where we need to get input from the user inside of Ruby, we're going to have to use the command line. So normally, in this course, we've been using this little atom plugin over here called atom runner. But now we're going to have to use the command line. So I'm going to come down here and I just have one inside of my atom text editor. And I'm just going to type Ruby draft.rb. That's the name of my file. And I'm just gonna click Enter. And let's go ahead and use this little calculator. So it says enter the first number, we'll enter in a five. And it says, enter the operator. So why don't we enter in a plus sign, and it says, enter the second number. So let's enter in a six. When I click enter, we should hopefully get the correct answer. So you can see down here, five plus six is 11. So our program actually work. That's awesome. All right, let's do it again. Let's try another one. Why don't we try to do some multiplication. So enter the first number, we'll enter in a five, and then we'll multiply by 8.65. And let's see, oh, wait, sorry, this is the operator. So multiplication, we'll multiply it by 8.65. And let's see what we get 42.25. So yeah, that seems about right. So our calculator is functioning correctly. And let's try one more case where we enter an invalid operator. So I'm gonna run the program one more time, enter in a four, and then we'll just enter in like a T as the operator and a five. And okay, so it tells us invalid operator. So we have a four function calculator, we've actually built an awesome four function calculator. What's cool about this calculator, is it's able to respond to the operator that the user enters. And we can do that using if statements. So this is one of those situations where if statements are just going to come in such handy because they're so useful, right, we can check all these different conditions. If one of them's true, we can do something if another one's true, we can do something else. So this is kind of bringing together like getting user input and if statements into one single program, which ends up being a pretty awesome calculator. In this tutorial, I want to talk to you guys about case expressions in Ruby, a case expression is actually just a special type of if statement that we can use to check a bunch of different conditions. So we could use an if statement to check you know, to see if a bunch of different things are equal to other things, or to check the values of different variables. But sometimes when there's a bunch of different things that we need to check, we can use something called a case expression. And it actually makes it a lot easier. So we're going to be creating a method in this tutorial, which is going to map day abbreviations to day names. So for example, each day of the week has an abbreviation like Monday is mo n, and that gets mapped to Monday, right? Tuesday is t ue, and that gets mapped to Tuesday. Wednesday is W Ed that gets mapped to Wednesday, etc, right? The abbreviations get mapped to actual full days of the week. So I want to write a method that can take as a parameter, one input, and it's going to be an abbreviation, and it's going to take that abbreviation and it's going to spit out the actual name of the day. So if we pass it in an MLM, it'll spit out Monday, and we pass in a fri it'll spit out Friday, right. And that's basically going to allow us to convert these abbreviations into the actual days of the week. So let's go ahead and do that. I'm just gonna define this method. So I'm just gonna say def. And we need to also include an end over here and a method name. So why don't we call our method get day name is going to be called get date name. And inside of here, we're going to pass the abbreviation. So I'm just going to call this day and day is going to represent the three letter abbreviation of the specific day, right? Make sense? Alright, so down here, what we need to do is we need to convert day into the actual day name. So the first thing I'm going to do is create a variable and we'll just call it day name. And we're going to store whatever the day name ends up being inside of this variable. So I'm just going to set this initially equal to the empty string. And then down here, right, before we end off the method, I'm going to return day name. So our mission inside of this method now is to give this date name variable, the value of the correct day, right? We need to give it the name of the day that corresponds to this abbreviation. So one way that we could do this would be using an if statement, right? So I can come down here and you know, hopefully at this point you guys are familiar with if statements I could say like, if day is equal to mo n Right, if Daisy with mo and then we can set the day name equal to Monday. Make sense. But there's also a bunch of other conditions we have to check. So if that's not true, we can check to see if the day is equal to Tuesday. And if that's true, then we can set the day name equal to Tuesday. So for each day of the week, I can make a different Elsa frags, like elsif, Daisy will do Wednesday, Thursday, Friday, Saturday. But here's the problem, this is going to get really tedious and really messy really fast, right having to create seven different if statements and you know, seven different else blocks, checking seven different conditions, is going to be really difficult and tedious. And that's why Ruby has something called the case expression. And essentially, what the case expression does is it allows us to take a scenario like this, where we're comparing the same value to a bunch of different values, and put it into a structure of its own. so in this situation, in every single one of these conditions, we're comparing the day variable equal to another value, right? In this condition, we're comparing it to Monday down here, we're comparing it to Tuesday, we could also compare to Wednesday, Thursday, Friday, it's the same comparison with a different value. In a situation like that case expressions are golden, they're gonna help us out so much. So I'm going to get rid of this if block. And over here, we're going to set up a case expression. So the way that I do this is just by typing out case. And now I need to give this something so we're going to give this the value that we want to compare to a bunch of different values. In our case, it's just day. All right, because I want to compare day to month I want to compare data to like TV, I want to compare it to W Ed th view, I want to compare it to all the day abbreviations. So we're gonna need to end this off. Now inside of here, I can create something called a when statement. And a when statement will basically do something when day is equal to a certain value. So I can say when and now I can compare day to something. So I could say when mn and basically what this means is, when de is equal to m o n, then down here, we're going to do something so I can just put some code down here. So what I want to do is set day name equal to Monday, because now we know they're trying to get Monday, I can make another one. So I could say when T, we could say day name is equal to Tuesday. All right. So basically, what we're doing is we're checking to see if day is equal to Monday. And if it is, then we'll do this. If day is equal to Tuesday, then we'll do this, etc. So I can make one of these for every single day of the week. And that's exactly what I'm gonna do. So I'm going to go ahead and do that. And then we'll meet back here, and we'll talk about what happened. Alright, so I went ahead and created one of these for every day of the week. So we have 1234567 of these here. And each one of these is doing something when a different condition is met. So when it's w Ed, or setting de named Wednesday, when it's fri we're setting Danny to Friday, etc. So essentially, we're able to create like a complex if else structure, but without having to like actually write all of it out, we can just say like when, and it's automatically going to check this value with the value up here. So this can be really useful. But there's actually one thing that we want to account for, there's going to be situations where the user enters in an invalid day abbreviation. So if the user enters in a valid abbreviations like su n or sa T, we can cover that right. But what happens if they enter in something invalid. So what happens if they pass a parameter into this get day name method that isn't an actual valid abbreviation? Well, we can use something called the else keyword and the else keyword is a lot like the else keyword. And if statements, I can just say else. And now anything that I put in here is going to execute when none of these guys up here are true. So I can say down here else day name is equal to invalid agree abbreviation, right? So I'm basically telling them, hey, you put an invalid abbreviation in here. So this is going to get executed when there isn't a valid abbreviation. Alright, so essentially, what I'm doing is, in each of these scenarios, I'm giving a name a different value, then down here at the bottom of our method, I'm just returning deigning. So this is a fully functional method. Hopefully everything works. Why don't we come down here and test it? So I'm going to go ahead and just print out the answer that we get back. So I'm gonna say puts, and then it's just called get day name. And we want to pass is an abbreviation so I'm going to pass this mln for Monday, right? And when I pass it this and we run our program. You'll see over here we print out Monday. So our program is giving us Back to the correct answer. If I typed in sh t down here, then we should get back Saturday, just like that. If I typed in th foo, then we're going to get back Thursday. So you can see, we're getting back the correct value if I typed in something invalid, so if I typed in like d o g, like dog now shouldn't yell at us. So it's gonna say invalid abbreviation. And we were able to do this whole thing while keeping it nice and clean and nice and simple. Like this whole thing only took me you know, less than a minute to write out. And I was covering all of these different situations. So this can be extremely useful when you want to check a single value, like de against a bunch of different values and do different things, depending on the situation. So definitely consider using case expressions, here's the thing, these aren't going to be appropriate in every situation. These are appropriate for one specific situation, right, where we're checking the same value against a bunch of different values. But that situation is very common. So when it does come up, don't be afraid to use case statements, they'll make your life a lot easier. In this tutorial, I want to talk to you guys about working with while loops in Ruby. So a while loop is basically a structure that we can use inside of our Ruby programs, which will allow us to loop through a particular block of code a specific number of times. So I can basically like write out my while loop and I could put some code in there. And as long as a certain condition remains true, I'll keep looping over and executing that same code inside that while loop. There's a lot of situations in Ruby, where we're going to want to use loops, we're going to want to do something continuously until we need to stop. And so while he was a great way to do that, and in this tutorial, I just want to give you guys a broad overview of while loops, we'll look at like the most basic type of while loop, you can write what it's talking about the core concepts behind them. So over here, I can actually create a while loop and the first thing I want to do is actually make a variable. And this isn't, you know, 100% necessary when working with while loops. But you'll see how this variable comes in in a second. So I'm just going to call the variable index, and I'm going to set it equal to one. So we have a variable index, and it has a value of one, and down here, I can actually create my wild. So the first thing I'm gonna do is just type out while and then what I need to do is I need to specify a condition. And you always want to make sure that you end these off. So I'm just going to put an end down here. Now here's basically how while loops work all the code in between while and n. So all the code inside of here, that we're going to put inside there is going to get continually executed. So it's going to keep getting looped over and keep getting executed. As long as this condition is true. As long as the condition that we specify right there is true, then we're going to keep executing the code inside of this loop. So over here, I can actually specify a condition. So I'm going to say while index is less than or equal to five. So essentially, what I'm saying is, while index is less than or equal to five, I'm gonna keep looping through the code inside of here. And actually what I can put in here, we can just put, you know, whatever code we want to keep looping over. So the first thing I'm going to do is, I'm gonna take puts, and I'm going to print out the value of index. So I'm say puts index, and then down below here, I'm actually going to increment the value inside of index. So I'm gonna say index is equal to index, plus one. So basically, every time through this loop, I'm printing out the index. And then down here, I'm incrementing, the index. And actually, I want to show you guys something that's cool we can do in Ruby, I have here index is equal to index plus one. But I can actually instead of saying that, I can just say index plus equals one. And whenever I say plus equals, you can also use minus equals, as well, this is basically just going to add the number over here to index. So this is going to add one two index. So that's kind of a little shorthand we can use in Ruby. But back to the while loop, this is going to keep looping through the code inside of here, as long as the index is less than or equal to five. So let's think about what's going to happen here. Actually, let me just show you guys. So why don't we execute this code, I'm going to run the program. And you'll see over here, I'm actually printing out values between one and five. So I'm printing out 1234, and five. So maybe this is what you expect it to happen. Maybe it's not what you expected to happen. Either way, I'm going to walk you guys through exactly what happened. So over here, it says while index is less than or equal to five, so remember, we're going to keep looping through this loop as long as that's true. So here's how the execution of this program goes. Ruby creates this index variable gives it a value of one. The first thing Ruby does when it gets to this while loop is it checks this condition. If this condition is true, then it's going to start looping through. So in our case, this condition is true, right? So Ruby is going to go ahead, it's going to print out the index, and it's going to add one to it. Once Ruby has finished executing the code inside the while loop, the next thing it's going to do is go back up here to the top of the while loop. And it's going to check this condition again. So every time Ruby goes through this loop, every time it loops through the code, right, it's going to go back up, and it's going to check the condition again. So every time through the loop, we're constantly checking the condition. So in this case, we incremented I, we incremented the index, so the index is now equal to two, which is less than or equal to five. So we're good to go. Right, that condition is true. So now we'll execute all of the code inside of here again, and then again, we're going to come back up and check the condition. So every single time we're going, we're checking that condition, eventually, index is going to be equal to six, right, we're going to get to a point where, you know, index was equal to five, so we printed it out, and then we added one to it. So now index is equal to six, we're going to loop all the way back up here. And suddenly, this condition is going to be false. And when this condition is false, we're going to break out of the loop, so we're not going to execute it anymore. And we're just going to move on to the next line of code. So that's basically how while loops work, we specify a condition. As long as that condition is true, we move on. And that's how we can get this output right here. So for example, if I was to change this to like eight, now we're going to print out one through eight, because the condition is only false when we get to nine, right, so we're printing out a times essentially. So this is extremely useful. There's tons of situations where we're going to want to use while loops like this. Now, I want to point out one potential problem that you're going to have with wild loops, and it's basically called an infinite loop. And an infinite loop is a situation where the condition up here never becomes false. So it just loops through infinitely. And this is something that could actually mess up your programs quite a bit. So you always want to make sure that when you're writing a while loop, that eventually the condition up here is going to be false. Now in certain special circumstances, you actually want to use an infinite loop. But I'd say for most cases, especially as a beginner, you're not going to want to infinite loop. So it's just something to keep in mind. But this is where the basics of a while we're specifying a condition, as long as that condition is true, we're going to keep looping through whatever code is inside of here. So like I said, there's tons of ways for us to use this. And in the next lesson, we're actually going to build a program where we're going to use a while loop in order to build a little game. So stick around for that, that's gonna be pretty fun. In this tutorial, I want to talk to you guys about building a guessing game and Ruby. So we're actually going to build a little game. And it's basically a game where the user can try to guess a secret word. So we'll continually prompt the user to guess a secret word. And if they get it right, then they'll get a success message like, Hey, you got the word right, and they get it wrong, then we'll let them keep guessing. So they'll be able to keep guessing what the word is until they get it right. And this, this would be kind of cool. And this will show us how we can use something like a while loop in order to build a little game. So down here, first thing I want to do is create a couple variables, the first variable I want to create is going to be the word that the user has to guess. So remember, we're creating a guessing game. So we need to store a variable that has the word in it, right. So I'm going to say, secret underscore word. And this is just going to store that secret word. And I'm just going to set this equal to draft. So you know, this could really be anything you want, whatever the secret word is going to be for our game. And finally, I want to create one more variable, this is going to be called guests. And we're just going to set guests equal to the empty string for now. So I have two variables, secret word, and guests. And now that I have these two variables, I basically want to create a while loop. And I'm gonna create a while loop that's going to continually loop through and ask the user for input. So I'm just going to say while and over here, we need to specify a condition. So again, this while loop is going to keep asking the user to input the secret word. And as long as they don't get the secret word, right, we're gonna keep asking them. So I'm basically going to say while guess, is not equal to secret word. So as long as the users guess, isn't equal to the secret word, we're going to keep looping. So down here, what I want to do is print out a prompt, so I'm just gonna say puts, and we're just gonna say enter your guess. So this is going to prompt the user to enter a guess. And what we want to do now is we want to store whatever the user guesses inside of this guests variable. So I'm just going to say guess, is equal to get dot shop. And remember, chomp is basically just going to get rid of that new line at the end of whatever user enters. So essentially, what's happening here is, while they, the user hasn't guessed correctly, while their guests isn't equal to the secret word, we're just going to prompt them again for the guests and the guests is just going to get equal to whatever the user types in. So eventually, what's going to happen is they're going to guess the word correctly. And when they do guess the word correctly, then this condition is going to be false. So we're going to come down here, and we'll basically just print out a success message. So I'll just say, like, puts you one. Alright, so this is a pretty simple program. But you'll see this actually allows us to build a guessing game inside of Ruby. So whenever we are getting input from the user in Ruby, we always want to do it through the terminals or through the command line. So I'm going to go ahead and open up my command line down here. And I'm going to run our program. So it's just called draft.rb. So I'm just going to type Ruby draft.rb, and this will start executing our program. So down here, you can see it's asking us to enter a guest. So I'm going to come down here, and I'll enter a guest. So why don't we just enter in some nonsense. So you'll notice as long as I don't guess the word correctly, as long as I'm not entering in the correct guests, the program keeps prompting me to enter a guest right keeps asking me to do that. But here's the thing, if I was to come down here and actually enter in the guest correctly, so if I typed in, like draf, now we should get a success message. So when I click enter, you'll see it says you won because we entered in the secret word correctly. So obviously, this is a very simple program, but it actually works pretty well. And it does everything that we want it to do. This is a very simple game. And one of the problems with this game is that the user gets unlimited guesses, they can keep guessing the word forever until they get it. And that's not the makings of a good game, what would be better is if we imposed some sort of a guess limit on them. So they can only guess the word a certain number of times, otherwise, they lose the game. So let's go ahead and see if we can add that functionality into our program. In order to do that, I'm going to have to create a couple more variables, the first variable I want to create is going to be called guest count. And guest count is going to basically tell us how many times the user has tried to guess the word. So I'm gonna create a variable guests underscore count. And I'm just going to set this equal to zero, because initially, the user won't have guests. So the guest count will just be zero. Now down here, every time the user guesses, I want to increment the guest count. Right? So down here, basically, this code means that the user has tried to guess the word. So every time they do that, I want to increment the guest count, I just want to say guess, count, plus equals one. And this will add one on to the guest count. So every time they guess we're going to increment that. And I want to create two more variables. The first one is going to tell us how many guesses the user can actually take. So it's going to be called gas limit. And why don't we just say the user has three guesses. So three strikes and you're out, so they can't guess the word and three tries, then they're going to lose the game. Alright, finally, I want to create one more variable. And this variable is going to tell us whether or not the user is out of guesses. So I'm just going to say out of guesses, is equal to false. Because Initially, the user is going to have three guesses right? When the user reaches their guests limit, we're going to set this out of guesses variable equal to false. And then we'll be able to tell the user like hey, you lost the game. Alright, so now that we've created these variables, I'm just going to come down here. And inside of this while loop, we want to modify a couple things. The first thing I want to do is every time we ask the user to guess the word, I want to make sure that they're not out of guesses. In other words, I want to make sure that they haven't reached the gas limit. So I'm going to use an if statement. To do that inside this while loop. The first thing we're going to do before we do anything else is just say if. And we want to check to make sure that the guest count is less than the guest limit. So I'm going to if guess count is less than guess limit. In other words, if the guest count is less than the guest limit, then we know they have guesses left, right, we know that they have a certain number of guesses left and they should be able to keep guessing the word. So if this is true, then I want to allow them to guess the word. So I'm just going to take all this code, and we're going to move it up here. Alright, so if the guest count is less than the guest limit, if they have more guesses, then we're gonna do all of this. Otherwise, though, in the situation where the guest count isn't less than the guest limit, then we know for a fact that the user is out of guesses, right? If they that means they have no more guesses. So inside of this else statement, what I want to do is I want to set that out of guesses variable equal to true. And basically, this will tell our program like, hey, the users don't, they're out of guesses, right? We check to see if they were eligible for another guess. And if they weren't, then we're going to say out of guesses is equal to true because they ran out of guesses. All right, there's one more thing we have to do inside of this while loop. And we have to actually modify the while condition. So over here, you can see we have our little condition. And we're going to keep looping while the guess is not equal to the secret word. But now that we've imposed the guessed limit, there's actually one more situation that's going to cause us to stop looping, which is when the users out of guesses. So I want to say I want to keep looping as long as the guest is not equal to the secret word. And as long as the user is not out of guesses, so and not out of guesses. So we're going to keep looping through this loop, we're going to keep asking the user to input information, we're going to keep doing all the code down here, as long as the gas is not equal to the secret word. And as long as the user is not notice I'm using this exclamation point here, out of guesses, right. So now we have our while loop set up, right, we're able to loop through here. As long as the user has guesses left, there's one more thing we have to do down here. So before we just put you one, right before, if the user exited out of that while loop, that means they guessed the word correctly. So we knew for a fact that they won. But now that we're imposing the gas limit, there's actually two situations where the user could exit out of the loop. The first situation is where they got the word right, in which case they won. The second situation, though, is that they ran out of guesses. And if they ran out of guesses, we don't want to tell them they won, we want to tell them they lost. So we can actually check to see which situation caused that loop to end, I can just say if. And I want to check to see if they're out of guesses. And if they are out of guesses, and I'm just going to print out, you lose. But otherwise, if they're not out of guesses, that means that they were able to guess the word correctly within the certain number of guesses. So they win. So this is our basic program. And let's go ahead and test it and see if it works. So again, I'm going to open up the terminal. And over here, I'm just going to run the program. And actually, it looks like I'm getting an error here. Yeah, so I forgot to put an end statement down here. I always forget to do that. So always make sure that you put an end statement down here. And now we'll be able to execute our program correctly. So here we go. Alright, so it says enter a guest. So why don't we just try to lose the game. So I'm just going to enter in one guest. Two guesses. Now I'm on my third guest. So this is my last try if I don't get the secret word on this time, or lose the game, so we're going to not get it and it's going to say you lose. So the program is smart enough to figure out that not only did we run out of guesses, but also that we lost. So let's try it now. But we'll try to win the game. So over here, I'm gonna make a random guess another random guess. So now we're on our last try, it's our last chance to get the guests I'm going to type in the secret word, which is draft. And now the program is going to tell us Hey, you won. So we were able to win the game because we guessed within the guest limit. So that is basically this program. I know this is a lot of codes, I'm just going to step through with you guys one more time just to kind of do a broad overview of what we did. That way you can get a better idea of what's going on. So we have these two variables, secret word and guess. And these two are pretty obvious, right? The secret word stores the word that the user needs to guess, guess is going to end up storing what the user guesses each time through that loop. Right. So we're going to keep looping through this loop as long as the guest is not equal to the secret word. And down here, we're basically going to store whatever the user guesses inside of this guest variable that was like the basic game that we built. Then we added these three new variables and guest count guests limit and out of guesses. Guest count is basically going to tell us how many times the user has guessed. And so every time the user guesses, we're going to come down here and we're going to increment it, right? Guess limit is going to tell us how many times the user can guess in other words, how many guesses they have available to them. And you'll see down here we're using this if statement. So we're checking to see if the guest count is less than the guest limit. If that's true, if they still have some guesses left, then we're going to execute all this code will let them guess. Otherwise, though, we're going to use this out of guesses variable, and we're going to set it equal to true. That's going to tell our program that the user is out of guesses. Up here we also added another condition inside of our while loop so we're saying while the guest is an equal to the secret word And while the user is not out of guesses, so that's going to allow us to control what happens in this loop. Then finally down here, we're checking to see if they're out of guesses. So down here, there was two situations. The first situation was when the user ran out of guesses, so they lost the game. And if that's the case, we're just going to print out you lose. Otherwise, we'll print out you one, stop the basics of building our guessing game. So now your homework is to go off and build a guessing game of your own. In this tutorial, I want to talk to you guys about four loops in Ruby. Now a for loop is basically a structure in Ruby that allows us to loop through a specific collection. So that could be a collection like an array, it could also be a collection of numbers, basically allows us to loop through a connection, a collection, and for each item inside the collection, we can do something. And actually, in this tutorial, we're not just going to be talking about for loops, we're going to be talking about a broad range of different loops, and looping structures, which we can use to loop through different things. Essentially, in Ruby, there's a lot of different ways we can do the same thing. And I'm going to be showing you guys a bunch of different ways to do essentially the same thing. So the first thing I want to show you guys is I have this array set up up here. And it's basically just called friends. And it has a bunch of items in it, you know, basically just a list of someone's friends. And I want to show you guys how we can use a for loop to actually loop through all of the items inside of this friends array. And remember, if I wanted to access a specific item, I could just say friends, and then pass an index. And so if I said friends, one, this is going to print out care and onto the screen, right. So that's kind of how I can access an individual element. But I can also use something called a for loop. And I can say for friend, in friends, and then down here, I also want to end this off. So I'm just going to put end, and inside of this little for loop, I can just say puts friend, and what this is going to do is it's actually going to print out all of the friends inside of this friends array. So now when I run this program, you'll see we're printing out all of the values inside of that array. And essentially, what I'm doing is I'm saying for and I'm specifying the name of a variable. And on every iteration of this for loop, this friend variable is going to represent a different friend. So on the first iteration, it'll represent Kevin, on the second iteration on represented care, etc. And I can actually name this whatever I want it. So I can just say element. And down here, I could print out element, and it doesn't actually matter. So it's all going to be the same. So that's a really easy way that you could loop through all the elements in an array. So for each element inside the array, you could basically do something and really friends could be this could refer to any collection inside of Ruby is basically just a general way to loop through a collection of elements. So this can be really useful when we're dealing with arrays, there's also another way that we could do essentially this same thing. So instead of having this for loop, I could just say friends, dot each, and I can say do and then I want to make two like little vertical bars right here. And I'm just gonna pass in the same thing as we did before, like a variable. And this variable is going to represent a specific friend on each iteration of this loop. So then down here, again, we can just say and, and over here, I can just print out a friend. And so now it's doing the same thing as we did before, we're printing out each one of the friends that was inside of that array. And again, I could, this doesn't have to be friend, this could be anything I want. So that's basically how we can loop through like an array a couple different ways. There's also another thing we can do, we can loop through a range of numbers. So I could specify that I want to go through a loop and go through the code a specific number of times. So I can come down here and I could say like, for index in, let's say zero to five. And I want to do something, so I could just print out the index, this is basically just going to loop through this loop five times. So you'll see over here, it prints out actually I guess it loop through six times. So it prints out 01234 and then five, so it's going to loop through from zero to five. And a lot of times in a lot of cases, you're going to want to go through a loop a specific number of times, and you can do it just like that. There's also another thing we could do, we could say like we could specify a number here, so I can say like six, and I could say dot times do. And inside of these vertical bars, I can just say like index. And again, this doesn't have to be called index, this can be called anything we want. And here it's the same thing. So this is going to loop through something six times. So over here, we're printing out zero through five. So these are all basically different ways that we can loop through other collections or we can loop through something as specific number of times in Ruby and this can come in handy a lot. In this tutorial, I want to talk to you guys about building an exponent method in Ruby, one of the things I wanted to show you guys was how we can use something like a for loop in order to write a little method. And I think one method that could be kind of cool to see how we might be able to write it would be an exponent method. So an exponent method would basically take two numbers, it would take a base number, and it would take a power number, and then it would basically take the base number to the power number. So if we passed in like a two and a three, then this would basically give us like to raise to the third power has essentially like what this method is going to do. And let's just go ahead and create it. So I'm just gonna say def. And why don't we just call this POW for like power, so it'll take a number to a specific power. And then inside of these parentheses, we actually want to have this method accept two parameters as input. So we want the base num, and we also want the pound num. So the base number, and that's going to be taken to the power number. Okay? All right, let's end off this method. Now, inside of here, we need to figure out how can we actually do this, you know, how can we take the base number to the power number, and my solution would be to use a for loop, the first thing I'm going to do actually is create a variable. So I'm just going to call this result and I'm going to set this equal to one, and then down here right before the end of the function, we're just going to return it, so I've just returned result. So ultimately, this variable result is going to represent the value of the base number taken to the power number. So let's use a for loop, essentially, what I want to do is I want to multiply the base number by result, power num times that makes sense. So let's flesh out this for loop. And then we'll kind of see how it's going to work. So I'm going to save this, I'm going to say POW num dot times do. And basically what we're going to do now is we can actually just pass this an index. Now I don't know if we're gonna actually use this index, but it might be good just to pass it in anyway. And down here, I'm just gonna end this off inside of this little loop here, we're basically just going to multiply result times the base node, so I'm just gonna say result is equal to result times base node. So essentially, what's happening is pow, num dot times do index, this is essentially just going to loop through the code inside of here power num times. So if power num is three, we're going to loop through this code three times. If power num is 10, we're going to loop through this code 10 times. And every single time we go through this code, we're gonna multiply the result times the base num. So the first time through the loop, it's just going to be resolved, which is one time as base num, so results gonna end up just being based on second time through, it's gonna end up being like base num squared. Third time through, it's gonna end up being like based on q. So this is essentially how we can go ahead and write this method. Now it's important to note that this is only going to work for positive number exponents. So if power num is a negative number, then this method is actually not going to work. But just for our purposes, In this tutorial, let's just assume that we're always going to use a positive exponent. So once we've multiplied result times, based on as many times as we need to, then we can just return it. So believe it or not, this is actually all we need for this method to work. So let's go ahead and call this method and we'll see what we get. So down here, I'm actually just gonna print this out. So I'll just print out pow, and why don't we take two to the third power. Okay, so let's run this. And you can see over here, we get eight. So two cubed is eight. Let's try another one. Why don't we do four cubed. So now we should get 64. Good. Let's do five squared. So we should get 25. And we do so looks like this methods working. So again, this is going to work for positive number exponent. Now you remember exponents, this won't handle it. But for our purposes, this kind of demonstrates how we can use a little for loop or in this case, we're just saying power num times in order to loop through something a certain number of times. And this can be extremely useful when we want to do something like this. And also I just want to point out over here, I had kind of stored this variable index. But you don't actually have to do that. And in this case, we don't need it inside of this method, but it's not as good to just have it there. So that's to kind of give you an idea of like a situation where we might be able to use one of these looping structures in order to like perform a function. In this tutorial, I want to talk to you guys about comments in Ruby. A comment is basically a little line of code that Ruby is actually going to ignore. So a lot of times when we're writing our Ruby program There's going to be situations where we want to leave like little notes, or really just little comments inside of our files. And a comment is exactly that. It's just a little line of code, a little line of text that is meant to be read by humans. So if you're writing a Ruby file, you can leave a little comment. And then when you come back later, you can read the comment or another developer who's looking at the file can read the comment. And you can basically communicate information that's outside of just the actual code in the file. And there's a lot of situations where comments are going to be useful. The basics of making a comment is you essentially go to a line of code, and you can use this hashtag symbol. And anything that you put after this hashtag symbol is going to be in the comments. So you'll notice that my text editor is actually styling this a little bit differently. So if I was just to come down here and type out some random text, you can see that this is actually going to get rendered by the program. But if I put random text over here, after this hashtag, this is going to be considered a comment. So I can basically write any plain text over here. And when I run the program, you'll notice that nothing gets printed out, you know, that's inside of this comment block. So like I said, comments are really useful for leaving little messages or little reminders inside of your programs. You can also put comments after lines of code. So for example, here, we have just a line of code. If I wanted after this line of code, I can put my hashtag. And I could type a comment after here. And this is something that you'll see a lot in programs like people will include comments either after lines of code, or directly above lines of code. And a lot of times people will use comments in order to like describe what a line of code is doing. So I can say like, this line prints text. So obviously, you know, it's pretty obvious what this line is doing. But if I wanted, I can put a comment there. Another thing that comments are used for is commenting out code. So there's going to be certain situations when you're programming where you might want to run your program, but without a specific line of code. So if you have like this whole, you know, big method, and you want to see what your program would be like without a specific line, Well, one thing you could do would be just to erase the line of code, right, you could get rid of it, and you can go ahead and you can run the file. And, you know, basically the codes gone. But the problem with that is you have to physically delete the line of code, a better way would be just to come over here and right before the line of code, we can put a comment there. And this is what's called commenting out a line of code. And a lot of times developers we'll use this to basically temporarily, like disable a line of code. So now when I run the program, we're not printing out comments or fun anymore, because it's commented out. And the great thing is when I want this line of code back, I can just get rid of the comment and we're back in business. So real really a comment is just kind of like open for business, like whatever you want to do with it, whatever you you know, you think you can accomplish with a comment, you can go ahead and do that. A lot of times people will also put comments on multiple lines. So you'll see some people they'll have like, you know, line one of a comment and then down here, they'll make another hashtag will have line two. This is one way that you can put comments on multiple lines. And honestly, this would probably be the recommended way like the most, you know, Ruby asked way to do it. There is another way that we can do this, though. So yeah, like I said, normally with these hashtags, like it only applies to the one line, right. But if you wanted, you could create a comment block and all you have to do is just say equals begin. And then wherever you want the comment block to end you can just say equals end. And it's important to know that these can't have any whitespace before them. So you see if I put waste whitespace there, it disables the comment. So down here, you can just type whatever you want inside of the comment. And it will be rendered as a comment. But like I said, I think probably a cleaner way to do it is just to put a hashtag on every line, especially you know, if you're moving to other programming languages, a lot of other programming languages will do stuff like this. So you know, just something to keep in mind. One final thought about comments, you want to use comments only when they're absolutely necessary. You know, comments, if you have too many of them and they're too active in the document. A lot of times they can be a little bit distracting. Generally, your goal should be to write code that is as readable and clean as possible, so that you don't need comments to explain it. But a lot of times a comment can come in handy. So if there's a situation where you think you need to comment, don't be afraid to put one in. In this tutorial, I'm going to show you the basics of reading from an external file in Ruby. And one of the useful things we can do with Ruby is we can actually read from external files that are on our computer. So if I had like a file that was on my computer somewhere I could actually read from that file inside of my Ruby program. So I'm gonna show you guys how to do that I actually created a txt file over here. It's in the same directory as this draft dot Ruby file. It's called employees dot txt. So I'm going to open that up. And you can see over here it's just a very simple text file. have employees. So these might be like employees at an office or you know, whatever we have, you know the name. And then we have the position. So Jim is in sales Andes and sales creed is in quality assurance, basically just says their names. And then it says what they do so their jobs. So this is a, you know an example of maybe a text file that you might want to read from inside of your Ruby files. So I'm going to show you guys how we can read from this file over here in my program, I have to use a special command. So I'm just going to say file dot open. And now I'm going to make an open and closed parentheses. And so inside of this open and close parentheses, I want to give this a couple of different parameters, the first one is going to be the name of the file, in my case, I have this file stored in the same directory as this Ruby file. So I can actually just put in the name of the file, so I can say, employees dot txt, but if this isn't in the same directory as the Ruby file, you're gonna have to include either a relative path in here. So for example, if it was in a directory called like files, I could say, forward slash files, or, you know, files forward slash, or you're gonna have to include an absolute path that starts at your hard drive. So that would be if you're on Windows, it could be something like C, you know, users whatever. So basically, it's some sort of path to the file, or if it's in the same directory, you can just put the file name. And we also need one more parameter in here, which is going to be the mode that we want to open the file. And so when you open a file in Ruby, you can actually open it in a couple different modes. And there's maybe like six or seven different modes that you can open files in, the one we're going to be using is called read. So I'm just going to type an R in here. And that's going to tell Ruby that all we want to do is read the files, we don't want to modify it, we don't want to write to it, we don't want to overwrite it, we just want to read it. And now what I can do is I can say do, and over here, I can make two open vertical bars, and I'm just gonna say file. And basically what this is doing is it's storing this file that we just opened inside of this file variable. So I now have a variable called file, which will represent the file that we just opened. And basically, what I want to do is I want to come down here and down below here, I basically just want to say, and so this is one way that we can open up a file. And I think for a beginner, this is probably the easiest way to do it. So you just say file dot open the name of the file, the mode, in our case, our do and then this is now going to store this file inside of this variable. So whenever we want to do with this file, we can do inside of here. And the reason that we need this END block is because this n block is going to signify when we're done working with the file. And when we're done working with the file, it's just going to go ahead and close the file. So we're not going to be using it anymore, we're not going to have it open anymore. So this is going to be good just as a beginner just to kind of, you know play around with working with and reading from files. So inside of here, we can use this file variable that we created over here, and we can actually do some stuff. So the first thing I could do would be just to print this out. So I can just say puts file. And now you'll see over here on the screen, it's printing out like all this information. This is essentially like some like metadata about our file. It's basically like how it's stored in Ruby. But if we want, we can read the file, so I can say puts file dot read. And now we're going to get all the information in the file. So you see we're printing out all the different names all the different employees from our file. So read is basically just like you're reading the entire file. And if you want, you can use any sort of, you know, string methods on this, I mean, this is basically just giving us a string. So I could say like read dot includes, or include, and, you know, we could see if like someone in there is named Jim or whatever. And we get true back so that, you know, essentially, this is just giving us a string with all the information in the file. There's also another thing which we can do, which is called read line. And read line will basically read a line from the file. So if I print out file dot read line, it's going to read the first line of the file. But what this is actually going to do is it's going to read the first line, and then it's basically going to say like, Okay, now we're on the second line. So let me show you guys what that means. So if I was to copy this line, and paste it down here, this is going to print out the first line of the file, and then this one's going to print out the next line in the file. So you'll see when I run this, it prints out Jim and then Andy. So every time we read the line, we're basically telling the file that we want to move on to the next line. So this is a good way if you want to read like each line individually. You can also do the same thing but with the characters. So I could say read char and then down here I could also say to recharge and instead of reading the individual lines, this is just going to read the different characters inside the file one by one so now we'll be able to print out Jim yeah So recharging and relying can both be really useful. Like as you go through a file, there's one more I want to show you, which will allow us to loop through all of the lines in the file. And then for each line in the file, we can like do a specific thing. So I can do is I can actually say, for line in file dot read lines, and read lines is a little method, which is basically just going to return an array of all of the lines. So actually, let me show you guys what this is going to give us, I'm going to print this out. So I'm going to print out file dot read lines. And you'll see it's just printing out all the lines in the file. But this is actually stored as an array, so I get access. Like, if I wanted the third line in the file, then I'll be able to access it like that. So we can loop through this array, like you would normally loop through an array. So we could say like for to line in file dot read lines. And down here, we can just put some code that we want to do for each line. So I mean, obviously, I could just print them out. So I could say put line. And this will print out every line. But in here, we can modify the line, we can look through it, we could do anything we wanted to each individual line in the file. And here's the thing, you know, these are just sort of the basics. You know, I mean, this is everything that you need to basically take a file, you know, a text file, loop through every line, and then you're basically just given a string. So this line over here, I mean, these are all just strings in our program. So you know, you can use all the different string methods to parse through those lines to figure out what they're saying, get information from them. And, you know, really, it's honestly super easy to actually read from a file. So I would say that's all like the main, you know, those are sort of like the most popular the most commonly used methods when we're talking about files, I also do want to show you another way that we can open a file. So you see over here, we said file, dot open the name of the file, and then we did this whole, like do file thing. There's another way that we could actually do this. So instead of saying this stuff over here, I could actually just store this in a variable. So I can say like file is equal to all of this. And we can do exactly the same stuff we did before. So I could say like, puts file dot read and will still be able to print out all the contents of the file. The only thing with this though, is whenever you create a file like this, you always want to make sure that you close the file when you're done with it. Closing the file basically means you're saying that you're done with the file. So you don't want to leave a bunch of files like open and in memory. So if you can just say file dot close, and this will go ahead and close the file. And you won't have to worry about it like taking up any more space in your program. But that's really the basics. And you know, you can really just sort of go from here, right? practice playing around reading different files, practice reading different types of files, these can be, they don't just have to be text files, they can be any type of file. In this tutorial, I want to talk to you guys about writing to files in Ruby. One of the cool things about Ruby is we can read files, but also we can write file, so I can actually write information out to a file. And I can do that right inside of my program. So in the last tutorial, we talked a little bit about reading files. So we kind of opened up a file here, we opened up employees dot txt, which was just this text file that had a bunch of like, I don't know, employees and a company in it. And we basically stored that file inside this file variable, we could do all sorts of stuff with it. Now I want to talk to you guys about actually writing information to files. And the first thing I want to kind of talk to you guys about are the different file modes. So different ways that we can open up a file, you'll see over here, I'm passing in two arguments to this open method, I'm passing in the name of the file, obviously. But then over here, I have this little r. And this is basically a file mode. So this kind of tells Ruby, like when we're opening the file, it kind of gives Ruby an idea of like what we want to be able to do with it, right? If I say R, this stands for read, but there's actually a bunch of other ones. So I'm gonna head over here to my web browser. And I'm just on a Stack Overflow page. And I think this actually gives a pretty good explanation of all the different file modes in Ruby. As you can see, here, R is basically just a read only starts at the beginning of the file, r plus is a read write, W is write only, it truncates the existing file, w plus is read, right? So there's all these different, like file modes that we can open up. And this is a pretty cool list, you know, one thing that's can be fun to do is just play around with a file and opening it and all these different modes just to kind of see what they do. And this tutorial, I'm going to be opening the file in a couple of these different modes. And I think it's going to be pretty fun. So the first thing I want to show you guys is how to append to a file. So over here I have my little list of employees, right, let's say that I wanted to add an employee onto this file. So I didn't want to modify any of the existing employees. I basically just wanted to append one to the bottom of the file. So we want to add In a new employee, well, I can open up this file in what's called the append mode. So I'm just going to put an eight here. And that basically means all we can do to this file is just add information onto the end of it. So we can't read from it, we can't write to it. Well, we can write to it, but we can only write at the end of the file. So we can just append something. So down here, what I could do is I could say file dot write. And inside of the parentheses, we can put whatever we want to write to the file. So why don't we try to add a new employee. So why don't we say well add Oscar who is in accounting, basically, what's gonna happen is when I run this program, this line of text is going to get appended onto the end of the employees dot txt file. So I'm gonna go ahead and run this. And now over here in the employees dot txt file, you'll see we have this Oscar from accounting line, but it actually just got appended right onto the end of the fall. So literally right after the last character, and I want to show you guys what we can do to mitigate that. So I'm just going to get rid of that. And we're going to run this again. This time, though, I'm going to run it with a new line in front. And basically, what this will do is it'll go on to the next line, and then it'll print Oscar from accounting. So now, when I run the program, we should get what we want, which is this. So Oscar, is just on the next line. Here's the thing, when you're appending to a file, it really when you're writing to a file, you need to be careful, because if I was to run this program again, so I'm just going to run it again. And I go back over to this employees dot txt file, you'll notice that Oscar and got a pendant to the end of the file again. Alright, so every time you run your program, it's going to keep modifying the file. So you need to be careful whenever you're writing to files because you're modifying the actual file. So if you, you know, mess up and you run your program one too many times, and your files are basically going to be, you know, if not ruined, they're going to have information in there that you didn't want. So that is the basics of appending, you can just append something onto the end of the file, it's super simple, super straightforward. And that can be really useful. In a lot of different scenarios. Another thing we can do is just write to the file. So instead of a, I'm going to say w here. And this basically gives us the ability to modify information in a file, overwrite information in a file and also create new files, which is pretty cool. So over here, if I was to say file dot write, and I just did Oskar accounting. Now, what this is going to do is it's going to overwrite this entire employees dot txt file. So let's go ahead and do that. I'm going to run this. And you'll see over here, this is actually overwritten the entire file, so we've overwritten everything in this file. And that's basically what happens when we write to a file. So I'm actually going to undo this. And we'll bring this back to how it was I want to show you guys another thing we can do, which is when you're writing to a file, you can actually create new files. So for example, let's say I wanted to create a new file, I can actually come up here, put the name of the new file that I wanted to create. So maybe I want to create like an HTML file, I could call it index dot HTML. Down here, I could actually write out some HTML into this new file. So I could say file dot write. And we can just put some, I mean, we can put like HTML, you know, whatever. So HTML is like another sort of programming language. And now what's going to happen is, when I run this program, a new file called index dot HTML is going to get created. And this is actually going to get written into that file. So you'll see over here, index dot HTML has been created. And it has a header one, and it's just saying, hello, that's pretty cool. You can create all different types of files, you can use all different types of file extensions over here. And that's, you know, really useful way to create files. Another thing I want to show you guys is another file mode. So instead of just writing, we're actually going to read and write, so I'm just gonna say R plus. And basically, what this means is we can read the file, and we can write the file. And when we're doing stuff like this, and makes it really useful. So okay, so we have all of our employees here, I can actually use some of the read methods that we learned in the last tutorial and some of the right methods in order to write information at specific points in the file. So for example, we could insert text at a specific point in the file. So I can say like, file dot read line. And this is basically going to move to the next line in the file. So whenever you're reading a file, there's like something called a file cursor. Or you'll hear people call it like the the file buffer, sometimes, basically like it, when we open the file, we start at a specific place in the file. So if you come back over here, you'll see like read read only starts at beginning of file, right? Our plus read right starts at beginning of the file. So in certain times, when we use these certain modes, they'll start at certain positions in the far right, a little cursor, whatever. When I say file dot read line that moves that little cursor to the next line in the file, right? And so now, essentially, where this cursor is, is that the second line of the file. So I can come over here and I could say file dot write. And I can basically say, like, overridden. And now when I run this, and I go over to my file, and actually, we got to change this back to employees dot txt, my bad. So when I go back over to my file, you'll see that it says overridden down here, right? So I was able to override the text that was on that second line, I can even do the same just for parts of it. So if I just wrote out like, high down here, you'll see that high is going to get inserted only in these first two positions, right? So you're just overriding like the positions right after that little cursor. And so that can be really, you know, useful. And really, you can use this read line. And there's also another one called read, char, and recharge will just read like an individual character. So it'll move that cursor like one character, you can use these different functions to move that cursor on the file and insert text, you know, in very specific places. And that, you know, you can just kind of play around with that to be able to do stuff like that. But I would say those are kind of the basics. You know, we learn how to create new files, we learn how to override existing files, we learn how to insert text into specific places and specific files, we learned about the different modes. So again, you know, go off research some of the different modes where you can open a file, but I would say really writing to files is extremely useful. And there's a lot lot lot of programs that do stuff like this and rely on stuff like this. In this tutorial, I want to talk to you guys about Exception Handling in Ruby. Now, sometimes when you're writing your Ruby programs, you're going to come across certain errors. So a lot of times when we get an error in Ruby, it'll crash our program. In fact, every time we get an error in Ruby, it's going to crash our program. And sometimes when you're writing Ruby code that you want to be able to execute for, you know, months and months, or even like a couple years at a time, you want to make sure that you're able to handle any errors or exceptions that pop up in your program. And I'm going to show you guys how you can do that today using something called a rescue. So let's go ahead and trigger an error in our program, one of the easiest ways to do this is to divide something by zero. So if you're familiar with, you know, math, you can't actually divide something by zero. So if I said like, num is equal to 10, divided by zero, when I run this program, you'll see over here, we're getting a bunch of red, we're getting an error, it says divided by 00 Division error. So Ruby's telling us, you had a zero division error, right? Another area that we could use, and I'm actually just going to comment, this guy out right here, would be trying to access an invalid index in an array. So we can try to access an array index using something like a string. So I just have this array over here of lucky numbers. If I was to say, like lucky nums, like zero, this is going to be fine, this will give me this four. But if I said lucky, nums dog, I can't actually pass a string into here. So I'm going to get another error. And over here, it says no imposition, implicit conversion of string into integer. So I'm getting a type error. And there's a bunch of these different errors in Ruby, you know, they handle a bunch of different situations going wrong. But the point is that if a situation like this comes up in my program, a lot of times, I'm gonna want it to not break the program, like, I'm gonna not want it to explode the program. And then you know, the program is done running. So we can actually watch out for some of these common errors. And we can do what's called catching them. And when we catch an error, or we catch an exception, that means we're basically saying to the program, like, Hey, we know some of them went wrong, but we're handling it, and it's all good, don't worry about it, you don't need to crash and burn. So I'm going to show you guys how you can do that. And really, the most basic way to do it is just to use something called rescue and begin tags. So over here, I'm just going to say begin. And down below here, I'm going to say rescue. And then down here, I'm going to say and so this is the basic structure, any code that I think is going to throw an error or an exception in my program, I want to put it inside of these, this little BEGIN block. So for example, this division by zero, let's grab this, and we can put this in here. As long as this code, like the code that we think might break is inside of that BEGIN block. Then if something does go wrong here, then it's basically just going to go down to the code inside this rescue block and execute that. So I can say down here like puts division by zero error. So now when I run my program, instead of the program just exploding, it's gonna say division by zero error. So the program actually didn't break the program didn't stop executing our program just handled the error. And defaulted down here and basically printed out, hey, there's a division by zero error. Here's the thing, the same thing is going to work for these lucky numbers. So if I was to grab this lucky numbers, and I put this over here, and I'm actually going to comment this out. Now when I run this program, you'll see that the lucky numbers is going to do the same thing. So over here, it says division by zero error. Here's the problem, though. Let's say I have more than one piece of code inside of this BEGIN block that has the potential to break the program. Right. So these two blocks of code will break the program, right? We we know for a fact that they will. But let's say that they'll only break the program some of the time, right. So maybe we have a program where the user can enter in two numbers to divide, and sometimes they're going to enter into zero, in which case, we're going to have to handle this error. And maybe sometimes they won't. The problem is that if I just put division by zero error down here, this is just going to catch any error that gets thrown. So it'll catch this error up here, it will also catch this error. And remember, those are two different types of error. One was a division by zero error, one was a type error. So there's actually a way that we can specify specific rescue blocks for specific types of errors. So for example, that division by zero, if I wanted, I can come down here and I could say rescue, and then I can just type out zero division error. And remember, this is basically the error that got thrown when we divided by zero. And so here's the thing, when I run this num 10 divided by zero thing, it's going to get caught by this division by zero error when I run the program. But if I was to run this lucky numbers, so if I just uncomment, this, this isn't gonna get caught. So this is still going to break the program, you'll see over here, we're still getting a type error. So actually, what I could do is I could create another rescue block for that specific type of error. And we could just say, type error. And then down here, inside of this rescue block, we could, you know, print out a message like, wrong type. And so now this lucky numbers with the dog index is going to get caught. And it's going to say, wrong type. So a lot of times in Ruby, you're going to want to be specific about what errors you want to catch. And so basically, what this means is, in the case of a zero division error, I could do something, I could put a bunch of code inside of here, that's going to do something, in the case of a type error, I could do something else, another thing we can do is we can actually take the error that got thrown, and we can store it in a variable. So I could say type, err, an equal sign and a greater than sign. And then I can just type in the name of a variable, what I want to store the exception that got thrown, so I'm just going to call it E. And down here, I could actually print out E. So when this type error gets called, instead of just typing out, hey, wrong type, it's going to tell us what the actual error was. So it says no implicit conversion of string into integer. And a lot of times this can be useful, because different situations will cause this type error to run. In other words, like different stuff up here might cause the Type error. So by storing the error inside of a variable called E and printing it out, we can tell the user exactly what went wrong. So that's pretty useful. And this is optional, you don't have to do this. But a lot of times, you're going to want to and it's usually a good practice, if you're writing a script or a piece of code that's going to be running for long periods of time. For example, if you need a piece of code to be running for like a couple months, or like even a couple years at a time, like on some server somewhere, using these rescue tags is extremely useful, because you'll basically prevent your program from terminating or your prey program from blowing up when stuff goes wrong. And just one more thought on this. And, you know, different people have different opinions about this. But generally, it's a good idea to specify the specific errors that you want to catch, it's usually not a good idea just to use rescue. The problem is because this is just going to catch any error under the sun. So a lot of times like you're going to want to be able to respond to individual errors differently. So this is kind of like almost too broad in a sense, because you're just casting a huge net, and catching every error in your entire program. But if you want to use that, then it's available to you. So that's the basics of using those begin and rescue tags in order to stop our programs from blowing up. In this tutorial, I want to talk to you guys about classes and objects in Ruby, are classes and objects are a extremely important concept in Ruby. So in this video, I'm going to be giving you a basic overview of what a class is, what an object is, how we can create classes and how we can create objects. So make sure you pay attention because this is a very important topic when it comes to Ruby. Now Ruby is an awesome language because it allows us to use all different types of data inside of our programs. So if you watch the video that I did on data types in Ruby, we looked at some of the basic data types that Ruby gives us things like strings, integers, floating point numbers, things like Booleans. And even like the nil value, right, there's all these different types of data that we can represent. And we can work with him we can use in our Ruby programs. But here's the problem is not all things not all information, not all objects, not all entities in the real world can be represented by just those pieces of information, right? You can't represent everything with just a string, or with just a number, or with just a Boolean, right? There's a lot of things in the real world, like a lot of you know, different things like a person or a phone or a credit card, or a water bottle, or a computer, a keyboard and mouse, like there's a lot of these real world things that can't be represented using just a string or just a number. One of the cool things about Ruby is it allows us to create our own data types. So I could actually create my own data type that it will allow me to represent like a phone inside of my program, or that would allow me to represent a computer or a credit card or a book or a lampshade or a dog, really anything I would want, I could represent inside of my program. And I can essentially just create my own data type. And essentially what that is, it's called a class. So we can create a class in Ruby. And a class is basically just a custom data type. So it's a data type that we can define. So I can basically say, like, I want to represent a book inside of my program. And I can say, here's what a book looks like, in my program, maybe it has like a title it has an author has, like, you know, a certain number of pages associated to it. And then I can take that book data type, and I can create individual books from there. So I can take this book class that we're going to create, and I can create individual books, I can represent individual books inside of my program. So I'm gonna show you guys how we can do that we're going to create a book data type or a book class. And then we're going to create some book objects, this is going to be pretty cool. In order to create a class, I can just come over to my Ruby file, and I'm just going to type out class. And I want to give it a name. And generally, in Ruby, when we create a class, you're gonna want to give it a name with a capital letter. So I could say, like, be okay with capital B. And then I'm going to come down here and just type end. So remember, a class is essentially a custom data type in Ruby. So when we create a class, we're basically modeling a real world entity or a real world object inside of our program. So inside of this book class, I'm basically telling Ruby, what a book is, I'm defining like, here's what a book is. And generally, when we create a class, we're going to give these classes various attributes. And that's how we can create a data type, I can say, Okay, here's my book class, and every book is going to have a title, it's going to have an author, and it's gonna have a number of pages, right? A class is essentially like a blueprint, or a template for a specific entity or object in the real world, like a book is an actual entity in the real world, right? A book is an object that we can interact with and work with. And this class is a template or a blueprint for representing a book inside of our program, we're basically creating our own data type. So inside of this book class, I can actually define a bunch of attributes, and attributes is just going to be information that all books are going to have. So we're essentially telling Ruby, like, hey, all books should have the following information. So inside of this class, I'm just going to type out a TT r underscore, ACC SSR, attribute accessor. And now I'm going to make a space. And over here, I'm going to type in the attributes that a book should have inside of our program. So I'm just going to type a colon, and I'm going to type the name of the attribute I want to define. So all books should have a title, I'm going to put a comma book should have an author. And then book should also have a number of pages. So I'm just going to say pages. So essentially, what I'm doing here is, again, I'm laying out the blueprint for a book inside of my program. So I'm essentially saying like, here's the book datatype. And all books are gonna have a title, they're gonna have an author, and they're gonna have pages. So this is like our overall blueprint, our overall template. So now that we've created this, now that we've told Ruby, what a book is, we can actually go and create individual books inside of our programs. And these are called objects. And an object is essentially just an instance of a book or an instance of a class. So I can create a book object, and that book object would represent an individual book in my program. So I'm going to come down here and you can create objects, essentially the same way that you create variables and actually as we'll learn all variables in Ruby are actually just objects. So I'm going to give this a name. So we'll just call this book one. And I'm going to set it equal to book dot new. And we're gonna make an open and close parentheses. Basically, what this is doing is it's telling Ruby that we want to create a new book. So we want to create an actual book inside of our program. In other words, we want to store the book datatype, inside of this book, one variable. Now down here, what I can do is I can actually give this book attributes. So remember, we defined a book up here that it's going to have a title, an author, and a number of pages. So down here, I can basically say book one dot title, is equal to, and we can make this like a Harry Potter book, right? So I'm basically defining what the title of this book is. And down here, I could say, Book Two dot author. And we'll make the author, JK Rowling. And we can say, actually, whoops, this has to be book one, I'm sorry. And then we can say book one dot pages. And we can set this equal to like, I don't know, maybe has 400 pages or something. So essentially, what I'm doing is I'm creating this book object. And remember, an object is an instance of a class. So when a book object is basically just like a given book inside of our program that's going to have all of these attributes. And I'm giving it all of these different attributes, I'm assigning it some information. So what I can actually do now is I can interact with this object. So I can say puts book one dot title. And this is going to print out the title of book one onto the screen. You see over here, it's printing out Harry Potter. Over here, I could print out book one dot pages, and it's going to print out all of the pages in book one. So there's 400. And we could do the same with the author. So essentially, what I did was I created my own data type up here, I created a template for what a book is, inside of our program, I said the book is going to have these certain attributes, I created a new instance of a book. So I created a book object. And then I gave all of those attributes specific information. So I said, like the title of book one is going to be Harry Potter, the author of book one's going to be JK Rowling. And what's cool about objects is we can create as many of them as we want. So down here, I could actually create another book, I could say, book two is equal to book dot new. And then I can start giving this some attribute. So I could say like, Book Two dot title is equal to Lord of the Rings, you'd say Book Two dot author, is equal to token and book two pages, is equal to, let's say, 500. And so now I'm actually representing another separate book inside of my program. So I can come down here and say, like, puts book to the author. And this is going to print out the author of book two over here in the console. So essentially, what we did again, was we defined the template for what a book is going to be inside of our program. And this is a class. And then we can create instances of that class, which are called objects. And an object is just like an actual book. So we have the Harry Potter book. And we also have the Lord of the Rings book down here. And we can access all the attributes from inside those books by saying book to author book to pages, we can just refer to them directly. And that's one of the cool things about classes and objects is they allow you to create your own custom data types inside of Ruby. And one of the cool things about Ruby is that everything, all data is actually classes and objects. So all data is actually an object, a string is an object. An integer, like a number is an object. a floating point number is not a Boolean is an object. All these different things are objects, and they all have classes which define them. That's really one of the cool things about Ruby. And one thing that sets it apart from a lot of other programming languages is that everything is an object. In this tutorial, I want to talk to you guys about the initialize method in Ruby classes. So in the last tutorial, we looked at creating Ruby classes and then creating objects of those classes. And this tutorial, I'm going to show you a way that we can actually make creating these objects a little bit easier. So notice down here, when I created my two book objects, I said book one is equal to book dot new. And then I had to manually set the book's title, the books author and the books pages. So just to create one book, I had to type out four full lines of code. Right down here, I do the same thing. So when I created the second book, had to type out four full lines of code. And this is kind of a problem because if I wanted to create, for example, like, you know, 10 or 20 different books, it's gonna take up seriously a lot of space inside of my Ruby files. Also just having to go through and manually say like book one title is equal to Harry Potter book, one author like, that gets really tedious after a while, there's actually a way that we can give our objects all this information right up front when we create them, instead of having to do it manually like this. And that's by using something called an initialize method. An initialize method is actually a method that's going to get called whenever we create an object. So remember, up here, we have this class. And this class is basically just a template. It's a blueprint for what a book is, in our program, when I create an object, it stops being a template, it stops being a blueprint, and it becomes an actual book. So this book, one object down here is representing the Harry Potter book, you know, with the author of JK Rowling 400 pages, this is like a physical book that we use that template of there to create. So when we end up creating a book, we can actually give it some default information. And I'm going to show you guys how to do that. So up here in our class, I want to create a method. And it's going to be called initialize. So I'm just going to say def, and it's initialized just like that. And I'm actually going to create this just like I would a normal method. So I'm going to say, and down here, inside of these parentheses, I can actually pass some information. But before I do that, I want to show you guys what's going to happen. So for example, I can put a print statement here, actually, let's do a put statement. And it's going to say, creating book. Now when I run my program, you'll see that over here, it actually types out creating book twice. Essentially, what's happening when I say book dot new, this initialize method up here is getting called. So every time I use this new method down here, and I call it, this initialize method is actually getting called. So if I was to pass a parameter into here, so let's have this initialized method, take a parameter, like we'll have a take name, I could come over here, and I could basically print out like, Hello, name. So I can pass a name into here, I could say, like Mike. And then down here, I could say another name, like Bill or whatever. And when I run my program, you'll see it's printing out Hello, Mike, and Hello, Bill. So this is essentially just a method that we can call just like any other method in any of our programs. But this method special because it gets called when we create an object. So what we can do is we can actually pass this initialize method, some information. And we can use that information to give our object specific information. So essentially, what I can do over here is I can say, initialize is going to accept three parameters. So when we call this new method down here, we're going to have to pass it three things, the first thing we're going to have to pass in is the title of the book that we want to create. The second thing we're going to have to pass it is the author of the book we want to create. And the third thing is going to be the number of pages for the book that we want to create. So now whenever I want to create a book, I have to give it a title, and author and a number of pages. Once I'm inside this initialize method, I can do something special. So I can actually take the values that the user passed in. So I can take the title, the author and the pages. And I can assign them to the attributes of the object. So I can assign them to the title of the object, the title of the author and the title of the pages, I can basically do what I did down here. So I can basically say like book one dot title is equal to whatever the title they passed in was. And this is going to save us tons of time when we're writing our programs. And the way that I can do that as I can, I can just say app, and I can say title is equal to title. So let me walk you guys through this line of code. When I say at title, this is referring to the title attribute in our objects is referring to the title attribute that we defined up here is rented that title of their right, this is saying the title of the object that we're creating is going to be equal to the title that the user passed in. Remember, this title, this is just a parameter that got passed into this new method down here. This is just a parameter just like I pass in the name, it's the same thing. We're passing it a parameter. And I could even name this something else. I can name this like, you know, I couldn't I could name it, you know, whatever I wanted. And, but I'm just calling it title, because that's what it is. It's the title. So I'm setting the title of the object equal to the title that got passed in. I can do that for all of these. So I can say the author of the object is going to be equal to the author that got passed in. And the number of pages is going to be equal to the number of pages that got passed in. And so essentially What I can do now is when I create my new book, instead of having to say like book one title book, one author, I can just take all this information and put it up here. So I can pass it into this initialize method. So I can just say, Harry Potter. And this is going to be JK Rowling rolling, and then the number of pages is just going to be 400. So I can actually get rid of all of this code over here, because I don't need this anymore. And I can do the same thing for this other book down here. So we'll pass in Lord of the Rings, token and 500 pages, and I can actually just get rid of all of this stuff. So now, instead of having all that other stuff, like where I had to like manually set each of those attributes, I can reduce the lines of code, I have to write down to two. And this is going to do exactly the same thing as we were doing before. So I could come down here and I could, you know, print out like Book Two dot title. And it's still going to be able to print it out to see it's printing out Lord of the Rings, I could print out book one dot author. And it's going to be able to print data. So I'm doing exactly what I was doing before, except now I'm making it a lot easier on myself by using this initialize method. And again, whenever we say like book dot new, this means we're calling this initialize method, we're passing it some parameters. And I'm setting the attributes of the current object equal to the attribute that we pass in when we create that object. So that's how we can use that initialize method to make our lives way easier. And you're always going to want to use an initialize method for the most part, just because it makes everything so convenient. In this tutorial, I want to talk to you guys about instance methods in Ruby. Now, sometimes you'll hear people call these instance methods, you'll also hear people call them object methods, sometimes they'll even call them class methods. Essentially, what we're going to do is we're going to come inside of a class that we create in Ruby, and we're going to give it some methods. And then when we're using objects of that class, we can access those methods to get information about our objects. So I want to show you guys my setup over here, I actually have a class here called student. And this class is basically just modeling or it's acting as a blueprint or a template for a student in our program. Essentially, we created like a student data type. So I defined the attributes for a student to be name, Major, and GPA. And down here we have this initialize method. So we're passing in a name a major and a GPA. And we're setting the attributes of this student object have an individual student object to be equal to what gets passed in. So this is like our student class. And down here, I'm creating two student objects. So we're making one, his name is Jim, he's studying business, he has a GPA of 2.6, then we have Pam, who's studying art, and her GPA is 3.6. So these are student one and student two. Now imagine that for each of the students in our program, we wanted to be able to figure out if they had honors or not. So imagine you're writing a program for a college or university, and you want it to be able to figure out whether or not a particular student had honors, let's say that the rules for honors would were constantly changing, right? So one day, maybe you had honors, if you had a GPA over 3.5. And maybe, then they you know, would change it to be like 3.3. In other words, like, imagine, if we wanted to be able to find out which students had honors in which didn't, well, we can actually write a method inside of our student class. And then that method will be able to tell us whether or not a specific object has honors. So I'm gonna show you guys how to do that over here in our class, I'm just going to come down here below this initialize method. And we can actually create a method of our own. So I'm going to go ahead and define a method. And I'm just going to call this has honors. And this method is not going to take in any information. So we're not going to need open and closed parentheses. And down here, we're just going to end it off. So this has honors method is basically going to return either true or false. If the current student if the object that's calling this method has honors and return true, if they don't, it's going to return false. So how can we figure out if the student has honors? Well, we could use an if statement. So I could say if I want to check to see if the student's GPA is greater than or equal to a specific number. So what I can do is I can actually access the GPA attribute inside of our student object and use it here. So I can say if at GPA is greater than or equal to and let's say that in order to have honors we we have to have a 3.5 or above. So if their GPA is greater than or equal to 3.5, then we're going to return true otherwise We're just going to return false. So this is basically our method if the GPA is greater than 3.5, return true, otherwise, we return false. So now what I can actually do is I can use this has honors method on each one of my student objects. So I can come down here, and you'll see I've created these two students, right, Pam. And, Jim. If I wanted, I could print out whether or not they have on him. So I could say puts, and let's check to see if student one, which is Jim has honor. So I could say student one dot has honors. And when I run this, it's going to print out whether or not he has honors. So in our case, it's going to be false. But if I ran this method on student two, so if I ran this method on pam, pam actually does have honors because she has a 3.6. So now this is going to return true. And what I want to point out is this has honors method is going to be different depend or it's going to be using different information depending on what object is calling it. Right. So when student one when Jim is calling this object, Jim has a GPA less than 3.5. So it's going to return false for Jim. So for the gym objects for the gym instance, it's going to return false. But for the PAM object, Pam's GPA is higher than 3.5. So it's going to return true, we can basically define a method that can be used on all of the objects for our specific class. And we can do it using something like this. So you can define as many of these as you want inside of your class. And these can be really useful, a lot of good classes out there and Ruby are going to have a bunch of good methods like this, which are going to allow you to, you know, either find out information about the specific object, or you know, modify the object or do something to the object in some way, shape, or form. So that can be really useful. And just consider, you know, writing some methods inside of your classes when they're appropriate. This is a good example of, you know, where a method can come in handy, because it can tell us whether or not the student has honors, they can tell us something about the student, using the attributes using the information that we've stored about that object. In this tutorial, I'm going to show you guys how we can create a multiple choice quiz in Ruby. So we're going to use some of the stuff that we've learned so far in this course, like classes, we're going to use loops, we're going to use variables. And if statements, in order to create a multiple choice quiz, basically, we're going to be asking the user a series of questions, the user is going to input whatever answers they think are correct, we'll grade the test, and we'll tell the user how they did. So this is going to be pretty fun. First thing I want to do is talk to you guys about some stuff that I already have set up. First thing I did was I wrote out a few questions for our multiple choice test. Down here, I have p one, p two, and P three. And these are all basically prompts. So this is what we're going to prompt the user with. And we're going to ask them the question. So over here, it says, what color apples red, purple or orange? What color are bananas? pink, red, or yellow? What color are pairs? yellow, green, orange. So this is a really easy multiple choice test just asking you about the colors of different fruits. Over here, I've defined a class called question. And this is basically modeling a question in our program. So essentially created like a question data type. And down here, we have these attribute accessors. So we're defining a question has a prompt and an answer. So the prompt is basically what we're asking the user. So it would be like, for example, all these questions down here? And then the answer is the actual answer to the question. So like, we're giving them a prompt that has a bunch of different options, multiple choices, the answer is going to be like what the actual answer is. And then we have this initialize method, which will just initialize the object so we can create like questions inside of our program now. So what I want to do is I want to create an array of questions. And we're going to have one question for each of the prompts that we have up here. So I'm actually just going to create a an array, we're going to call it questions. And I'm just going to set it equal to a bunch of different questions. So actually, inside of this array, we can create a couple different questions. So I'm going to say, question dot new. And I'm going to create this first question. So remember, we need to give this a prompt and we need to give it an answer. So for the first question, I'm going to pass it p one as the prompt, because this is the prompt for the first question. And I want to give it the answer. So the answer to what color or apples is going to be a red, so I'm just going to pass in a now I can create another question. So you'll notice over here, I can just create a question by saying question dot new, and then I can pass in the initial information. So I'm going to say question dot new. And now we'll make one for p two for that second prompt says what color are bananas? And the answer is going to be C Yellow. So we'll put a C inside of here. And finally, we'll make another question. And this is going to be P three. And the answer to what color or pears is going to be be green. So we're going to go ahead and put a B in here. Essentially, what I've done is I've created three questions in my program. And I've stored them inside of this array called questions. So we have an array that stores all the questions for our test. Now the next step is we need to actually be able to run the test. So what I want to do is I want to be able to go through each of the questions in the test, I want to be able to ask the user the question, I want to be able to get their answer. And I want to figure out whether or not they got the answer, right. So what we can do is we can actually create a method. So why don't we create a method that will run the test. So this method will accept one parameter, which is going to be an array of questions. It'll use those questions to run the test. And it'll basically like ask the user all the questions, figure out what their answers were, and score and grade the test. So let's do that down here, I'm going to create a method and we're just going to call it run test. And this method is going to take one parameter, so it's going to be an array of questions. So we could say, questions. And we're just going to call the parameter that we pass in questions. And we can go ahead and end off this method. Now, inside of this method, we want to do a few things, the first thing we want to do is basically just loop through and ask the user all the questions. So what I want to do is create a variable called answer. And I'm just gonna set this equal to the empty string initially. And what we're going to do is we're going to store all of the user's answers inside of that answer variable. So like, we'll store you know the answer to the first question, the second question, the third question, etc. Now, what we want to do is want to loop through all of the questions inside of this questions array. So I'm going to create a loop, I'm just going to say for question, in questions. So for each question inside of this questions array, I want to do something and down here, we'll just end this off. Now inside of here, essentially, what I want to do is ask the user the question, so I'm basically going to say puts, and I'm going to print out the prompt. So I can say puts question dot prompt. So remember, this is going to be an array of question objects. And the question class says, two attributes, it has a prompt, and it has an answer. So essentially, what I'm doing down here, is I'm printing out the prompt for the current question that we're looping through. Once I've printed out the prompt, I can get the input from the user. So I can just say answer is equal to get dot chomp. And this is basically just going to get whatever the user enters and it's going to store it inside of answer. Now what we need to do is we need to be able to keep score. So we need to be able to keep track of how many questions that user gets right, and how many they get wrong. So I'm going to create another variable up here called score. And I'm going to set this equal to zero initially. And whenever a user gets a question, right, we're going to increment the score. So every time they answer the question correctly, score will get incremented. And by the end of the of the test, we'll be able to tell how many questions they got. Right? So down here, I want to check to see if the answer that they gave is equal to the correct answer. So I can just say if answer is equal to and now I want to compare this to the answer to the question. So I can say question dot answer. And remember, this is just another attribute from inside of that questions class. So down here, I'll just end this off. And if the answer is equal to question dot answer, then I can basically just increment the score variable. So I can say score plus equals one, and that will increment the score. Now, finally, down here, after this for loop, I'm just gonna print out how they did. So I'll say puts, and we'll basically just say, like, you got, however, questions out of however, right, so we'll basically be like puts, you got score out of. And now we're just going to type out the total number of questions. So we can say questions dot length. And this is just gonna tell us how many questions were inside of that questions. Right? So this is obviously a lot of code. And you know, this run test method is obviously a lot of code. But everything looks like it's right. So why don't we try to run this, and we'll see how we do. So remember, whenever we're going to get input from the user, we always want to use the command prompt in the terminal to do that. So I'm going to open up my terminal. And I'm going to go ahead and run this Ruby file. So I'm just gonna say Ruby draft.rb, because that's the name of the file. And we'll run this. And so actually, whoops, totally forgot, we have to call this run test methods. So I didn't actually call this run test method. So I need to do that. So let's come down here, and we're just going to call it so I'm just going to say run test and we're just going to pass in that Questions array. So we're passing in the array of questions that we created. Up here, we're passing in this guy. And actually, you know what, there's one more thing we have to change. So down here, I'm printing out the score, I have to say.to S. So we're converting the score into a string. And we're going to have to do the same down here. So I've just saved up to s. And now that we have this, we can actually run our program from inside of the terminal. So let's go ahead and do that. So here in the terminal, I'm just going to run this file, I'm going to say Ruby draft.rb. And you'll see it's asking us the first question. So it says, What color are apples? So let's just try to get them all right, I'm gonna say apples are a red, what color bananas, let's say see yellow, what color are pears, let's say be green. So you can see here, once we entered in all the answers it typed out, you got three out of three, correct. So it's actually telling us how many of these we got correct. And that's pretty awesome. So let's try this again. But let's try to get something wrong. So I'm going to run this same exact file. And let's get the first one wrong, we'll say apples or purple, we'll get the second one wrong, we'll say bananas or pink. And we'll get the third one, right, so we'll say pears are green. So now it's going to say you got one out of three, because we only got one out of three questions correct. So that's basically how we can build a little multiple choice test. In this tutorial, I want to talk to you guys about inheritance in Ruby. And inheritance basically allows us to extend the functionality of one class into other classes. So I can basically define what we would call like a superclass. And then I can create subclasses, from that superclass, which will inherit all of the methods, all the functionality, all the attributes from that original superclass. So that doesn't make sense, don't worry, I'm gonna give you guys a full example of what this is and how it works. But let me show you guys first what I have over here. So I created a class over here, which is called chef. And this chef class, I'm going to expand it, it has three methods inside of it. So the first method over here is called make chicken. And this method basically just prints out the chef makes chicken. And then it has a make salad method, same thing prints out the chef make salad. And then finally, we have the make special dish method, which just prints out, the chef makes barbecue ribs. So essentially, we're just like creating a chef inside of our program. If I wanted, I could come down here and create an instance of the chef. So I can say, chef is equal to chef dot new. And now that I have my chef object, I could say like chef dot make chicken. And now when I run my program, you'll see it says over here, the chef makes chicken. So we're telling the chef to make a chicken, we can tell the chef to make a salad or to make the special dish. Now, let's say that in addition to having this chef class, right, this general overall chef class, we also wanted to define another type of chef, we also wanted to model another type of chef in our program. So let's say that in addition to this generic chef, we wanted to create a more specialized type of chef, so wanting to create an Italian chef. So I could say, Italian chefs, we're creating an Italian chef class, and down here, we'll just end this off. But let's say that our Italian chef can do everything that our normal chef can do. So the Italian chef can also make chicken can also make a salad and can also make a special dish. So the Italian chef can do everything that the normal chef can do. In other words, the Italian chef can have all the same methods as the normal chef, well, I can actually use something called inheritance. And I can pass down all of the functionality from inside of this chef class into the Italian chef class. In order to do that, all I have to do is come down here. And after I say the name of the class, I can just make less than sign. And I can just type out the name of the class that I want to inherit from. So when I say chef right here, that means that the intent of the Italian chef is going to inherit all of the functionality from this chef class. So it's essentially going to inherit all of these methods. So let me demonstrate this. You'll notice there's nothing inside of this class. I didn't type anything inside of there. But I could come down here and I can create an Italian chef object. So I could just say, Italian chef, Chef dot new so I'm creating a new Italian chef. And then down here, I can just say Italian chef dot make salad. So even though I don't have any code up here, inside of this Italian chef class, not a single line of code, I can create an Italian chef object and I can still tell this Italian chef to make salad. Now when I run my program, you see down here in addition to the normal chef making chicken, we're also able to use the Italian chef to make a salad so over here it says the chef makes salad So this Italian chef object has access to all of the functionality from inside of the chef class, because I inherited it. So I'm using inheritance here. And I'm inheriting all the functionality from the chef class. But here's a question right? The normal chef over here has a special dish. So the normal chef makes a special edition that says the chef makes barbecued ribs. But let's say that the Italian chef is going to have a different special dish from the just generic chef, what I can do is I can actually do what's called overriding a method. So I can override the make special dish method inside of this Italian chef class. So I could actually say, make special dish and ended off and then inside of here, I can put what I want the Italian chef's special dish to be. So I could just say puts, and we'll say like, the chef makes eggplant parm. So this is going to be the Italian chef's special dish. So now if I was to come down here and say chef dot make special dish, and Italian chef dot make special dish. You'll see when I print these out, or when I run my program, it says the chef makes barbecued ribs. And the chef makes eggplant parm. So inside of the Italian chef class, I was actually able to override this make special dish method. And that is a super useful thing to do. Another thing I can do is add functionality into this. So let's say that the Italian chef, in addition to doing everything that the normal chef can do, can also make pasta. So I can make a method here it's make pasta. And down here, it's just going to be the chef makes pasta. So now inside of my Italian chef object, I can make some pasta. So I could say Italian chef dot make pasta, and the Italian chef will be able to make pasta. But the normal chef down here doesn't have a make pasta method. So it's not going to be able to make pasta. So let's go over what we did. Essentially, I created this class chef, this chef had a bunch of functionality it can make chicken can make salad can make a special dish, right? Then I created a nother class, Italian chef. And this Italian chef could do all the same stuff as the normal chef. So what I did was I inherited all the functionality from the chef class into here, right. But there was a circumstance where the Italian chef was actually going to have a different special dish than the normal chef. So I overrode this method I basically defined redefined the method inside of the Italian chef class. And I was able to make it do what I wanted it to do. I also extended the functionality. So I was able to actually make the Italian chef different. So the Italian chef, in addition to doing everything that the normal chef could do could also make pasta. And that's the basics of inheritance, we can define what's called a superclass. So this chef up here, this is the superclass. And then we can also define subclasses. So this Italian chef is a subclass. And it's considered a subclass, because it inherits from the chef superclass. And this can be really awesome. So a lot of times in Ruby, you're going to have different hierarchies of classes. So we'll have like the chef class. And then we'll have a subclass and Italian chef, I can also create other subclasses, like a Chinese chef or a French chef, or a Mexican chef, right, I can have different, you know, types of chef different subclasses of chef's that would all inherit the functionality from the generic chef class. So that is super useful feature in Ruby, it's really going to come in handy, especially if you start creating lots and lots of classes. In this tutorial, I'm going to talk to you about using modules in Ruby. Now module is basically just a container where we can store groups of methods. So as you start programming more and more in Ruby, and as your programs get more and more complicated, you're going to want to organize all the different methods that you're using. So a lot of times in a Ruby script, you're going to be writing out a bunch of different methods that are going to do different things in the they'll have different tasks. And one thing we can do is we can take methods that are doing similar things, or that should be grouped together, we can put them inside something called a module. So over here, I have this file open. It's called useful tools.rb. And in here, I've defined a module. So I'm just going to open this up. And you'll see inside of this module, I just said module, and then tools. So whenever we create a module, you can create it by saying module. And generally you're going to want to give modules a name with a capital letter, so you need to do that. And down here, I have two methods. inside of this module, I have a method called Say hi. And it says hi to a user and I have
