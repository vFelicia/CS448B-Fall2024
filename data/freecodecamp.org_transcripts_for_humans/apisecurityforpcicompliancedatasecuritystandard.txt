With timestamps:

00:00 - Learn about API security with this course
that is tailored to address the pivotal PCI
00:05 - DSS 4.0 requirements. PCI DSS stands for payment
card industry data security standard. It is a
00:12 - set of security standards designed to ensure that all companies that accept, 
00:17 - process, store, or transmit credit card information maintain a secure environment.
00:22 - As the PCI standard takes a definitive turn to spotlight API security for the first time, understanding its intricacies becomes crucial for businesses.
00:32 - Dive in to decode what DSS 4.0 means for your organization, why APIs are now in the limelight of attackers,
00:40 - and gain invaluable insights into ensuring compliance.
00:44 - Equip yourself with knowledge, best practices, and stay a step ahead in safeguarding your operations.
00:50 - This course was developed by Dan Barahona who has 20 years of cybersecurity experience.
00:57 - Hello, Free Code Camp community and
welcome to APIsec University and this
01:01 - course on APS security for PCI compliance.
01:05 - My name is Dan Barahona, one of the
co founders here at APIsec University,
01:09 - and for the next hour, you'll
learn all about the new PCI DSS 4.
01:13 - 0 and what it.
01:14 - And what requirements
it has for API security.
01:17 - I also invite you to check out all our
free courses on apisecuniversity.com,
01:22 - including a hands on course on API
Pen Testing, an introductory course
01:26 - on API Security Fundamentals, this
course on PCI Compliance, as well
01:30 - as one on the OWASP API Top 10,
API Documentation and more to come.
01:37 - All the courses on our site include
quizzes to assess your knowledge.
01:40 - And if you complete everything and
pass the final quiz, we'll issue you
01:43 - a certificate and badge to recognize
your accomplishment, which you can
01:47 - also display on your LinkedIn profile.
01:49 - Thanks again for watching, and
I hope you enjoy this course.
02:01 - Hi, and welcome to our course on
API Security for PCI Compliance.
02:06 - In 2022, PCI released version 4.0 of
the Data Security Standard, and it's the
02:12 - first major update in the last 10 years.
02:15 - A lot has changed since then, not just in
the standard, but in the world of APIs.
02:20 - If you think back to 2013 when 3.0
came out Google was just releasing
02:25 - their Glass product, we were on
the iPhone 5, Instagram was just
02:30 - adding video to their platform.
02:32 - And the OWASP community was six years away
from releasing an API Security Top 10.
02:39 - Adoption of APIs was  at a
fraction of where it is today.
02:43 - And whole industries have
emerged around APIs, particularly
02:47 - in fintech and e-commerce.
02:49 - Companies that rely entirely on APIs.
02:53 - And it's hard to imagine any credit card
transaction taking place today that is
02:57 - not using APIs somewhere in the chain.
03:01 - And APIs don't even appear in
3.0 of the DSS standards at all,
03:07 - but feature prominently in 4.0.
03:10 - The goal of this course is to
introduce you to the changes in 4.0,
03:14 - specifically as they apply to APIs.
03:17 - And not only to show you how to
achieve compliance, but to elevate
03:22 - your security posture overall.
03:24 - I hope you enjoy the course.
03:29 - Well, let's dive right in and review what
we're going to be covering in this course.
03:33 - We're going to start with the basics.
03:35 - Why are we even talking about API
security in the context of PCI and DSS?
03:41 - How are APIs even relevant
and why should we care?
03:44 - For those who are new to PCI, we'll do
a very brief introduction of the PCI
03:49 - standard itself, follow that up with
a review of the DSS, Data Security
03:54 - Standard, and examine what's new in 4.0.
03:58 - What's changed and when
you need to comply.
04:01 - And then we'll get into the core of
the course here, reviewing the DSS 4.0
04:06 - standards and requirements in detail.
04:09 - We'll be unpacking individual
sections of 4.0, understanding
04:13 - what the requirements are.
04:15 - The best practices and exploring
what this means for APIs and how
04:19 - to keep your organization safe.
04:22 - As always, we'll wrap it up with some
best practices and do's and don'ts
04:26 - that you can start implementing today.
04:28 - We'll feature some quizzes as we
go along and a final quiz as well.
04:32 - And if you complete the whole course,
we'll be pleased to send you a certificate
04:36 - and badge to demonstrate your achievement.
04:43 - But first, let me introduce myself.
04:45 - I'm your instructor for this course.
04:47 - My name is Dan Barahona.
04:48 - I've been in the cybersecurity
industry for over 20 years, held
04:52 - lots of different roles, spanning
marketing, sales, products.
04:58 - Holding leadership roles at places
like Qualys, HP and ArcSight,
05:02 - Anomali, and over here at APIsec.
05:05 - From an education perspective, I earned
engineering degrees from Rensselaer
05:09 - and Cornell University before doing
an MBA over at University of Michigan.
05:14 - I'm the co-founder here
of APIsec University.
05:18 - And I really love to be in touch.
05:19 - So if you want to look me up and connect
with me on LinkedIn, or you can email
05:24 - me anytime at dan@apisecuniversity.com.
05:28 - Happy to get your messages, questions,
feedback, anything we can do to continue
05:32 - to grow this APIsec University site.
05:34 - Thanks so much.
05:39 - So let's kick things off by understanding
why API security is such an important
05:44 - topic and why it's so relevant to PCI.
05:49 - And there are three important
dynamics happening now with APIs.
05:54 - The first is that APIs are exploding.
05:58 - We've known this for years
and it just continues.
06:01 - You've probably seen the statistic
that over 83% of all internet
06:07 - traffic now is API based.
06:09 - This is a study from Akamai, they
analyzed all their network traffic
06:13 - and discovered this incredible
prevalence of API-sourced traffic.
06:19 - Look at the API calls, a hundred
billion open banking API calls this
06:23 - year and expected to grow by 5X over
the next five years to 500 billion.
06:30 - There's really no end in sight of
the adoption of APIs, and that's
06:34 - thanks to just the sheer value and
benefit that these APIs provide.
06:39 - And they're powering virtually everything.
06:41 - Every e-commerce transaction, our
medical devices, our connected
06:45 - cars, you can lock and unlock,
start and stop engines through APIs.
06:50 - They're really powering
virtually everything.
06:53 - But APIs are also under heavy attack.
06:57 - The stats are really quite staggering.
06:59 - 40 to 75 billion dollars a year
in cyber loss related to APIs.
07:05 - For years, Gartner, the analyst firm, has
been predicting that by 2022 APIs would
07:12 - become "the most frequent attack vector."
07:15 - I think that has been borne
out and continues to be true.
07:20 - I have another course, API Security
Fundamentals, if you want to learn
07:23 - more about specific breaches, we
go into a lot of detail there and
07:27 - explore how APIs were exploited.
07:30 - So I recommend you check out
that course if you're interested.
07:33 - But the third dynamic is API security.
07:36 - Our APIs are seriously under-secured.
07:39 - And if you just look at testing alone,
this report from stateofapis.com looks at
07:45 - all of the testing we do on APIs, and only
4% of that effort is focused on security.
07:52 - And there's a reason for this.
07:54 - How we build applications has
fundamentally changed, but
07:56 - security is still keeping up.
08:00 - I want to share some thoughts from a
recent Gartner report that really nailed
08:04 - the challenges and the changes happening
in application development and security.
08:09 - This comes from a Hype Cycle
report on application security that
08:13 - Gartner published in July 2023.
08:16 - Some of the key trends are that we're
now developing apps more quickly, in more
08:21 - agile ways, we're relying more and more on
developers to secure the code to integrate
08:27 - security into their applications.
08:29 - And we've changed how we deploy
and operate our applications with
08:33 - things like cloud native strategies.
08:35 - And these are challenging our
traditional and established
08:38 - approaches  to application development
and provisioning and deployment.
08:45 - However, our existing application
security controls have not kept up,
08:50 - and they've become less effective.
08:54 - Dionisio from Gartner summarizes it well.
08:56 - API attacks have resulted in a stream
of data breaches, and DevSecOps teams
09:02 - have increasingly become interested
in API testing and security.
09:06 - However, our traditional AST tools,
application security testing tools,
09:12 - were not originally designed to
test for some of the unique types
09:15 - of vulnerabilities associated
with typical attacks against APIs.
09:20 - And his point is really spot on.
09:22 - API attacks are fundamentally
different and let's examine why.
09:28 - So organizations have long used tools
like SAST and DAST, static and dynamic
09:33 - application security testing solutions.
09:36 - And these are very mature, well known
tools that look for poor coding practices,
09:41 - injection flaws, cross site scripting,
things like CSRF, cross site request
09:47 - forgery, SSRF, server side request
forgery, misconfigurations and the like.
09:53 - These tools are looking for common
vulnerabilities, common flaws that
09:57 - might exist in your applications.
10:00 - But if you look at the breaches
that successfully exploit APIs and
10:06 - result in the losses of hundreds
of millions of records, this is
10:10 - not what's causing those breaches.
10:12 - It's not injections.
10:13 - It's not cross site scripting.
10:15 - API breaches exploit something different.
10:18 - Typically business logic flaws
or gaps in authorization or weak
10:23 - authentication and the like.
10:26 - And if you want to keep up on this
there's a great site, apisecurity.io,
10:30 - where they capture these types of
events and exploits and breaches.
10:34 - And you'll see how API breaches
happen just doesn't look like our
10:38 - traditional web application attacks.
10:41 - And this graphic down
below reinforces the point.
10:44 - Our web scanners, for the most
part, are scanning at the UI layer.
10:49 - Mobile UI, Web UI.
10:51 - And there are two issues
with this approach.
10:54 - First, we've been relying on the UI layer
for too long to do more than presentation.
11:00 - The UI layer is also providing security.
11:03 - It's filtering what data users
can see, what actions they can
11:07 - take, what buttons they can press.
11:09 - And this is a problem.
11:11 - The UI should really be about
presentation, not about security.
11:16 - And the reason why is that
UIs are powered by APIs.
11:21 - And attackers are going to go right
around your UI straight to the API.
11:26 - And at the API level, you don't have
the benefit of this UI and the filtering
11:31 - and the controls that it's providing.
11:34 - So if an attacker can dream up a
request for an API, they can send it.
11:39 - And if your backend app logic
doesn't know to block those
11:42 - requests, they'll get executed.
11:44 - And that's how API breaches happen.
11:47 - Again, we have a whole course
focused on this topic, the API
11:51 - Security Fundamentals course, where
you can learn a lot more on this.
11:56 - No API security course would be
complete without a mention of
11:59 - the OWASP API Security Top 10.
12:03 - The OWASP is the Open Web
Application Security Project.
12:07 - It's a community that has produced truly
foundational application security guides
12:12 - and is famous for its top 10 lists.
12:14 - In 2019, OWASP added a dedicated top
10 for API security, which differed
12:21 - quite a bit from their web app top 10.
12:24 - These lists are widely considered
to be industry standards for
12:27 - how to secure your applications.
12:30 - And in 2023, The OWASP community
released an updated version of the
12:35 - API top 10, which you can see here.
12:38 - There've been some changes,
some additions and deletions,
12:40 - and some items remain the same.
12:43 - The top two are still at the top.
12:45 - And for good reason, the vast
majority of API breaches violate
12:49 - one or both of these items.
12:52 - Number one is Broken Object Level
Authorization, also known as BOLA.
12:56 - And it refers to the ability of,
say, one user being able to access
13:02 - another user's data through an API.
13:04 - And there are many examples of these which
we cover in some of our other courses.
13:10 - Number two is Broken Authentication, which
is also a frequent cause of breaches.
13:15 - Many times, API endpoints are
left open with no authentication,
13:20 - with organizations assuming these
endpoints won't be discovered.
13:24 - You should always assume they will
be discovered, as attackers will try
13:28 - their best to find these endpoints.
13:31 - And you should protect all
endpoints with security, regardless
13:34 - of whether they are documented,
published, internal, or external.
13:39 - One of the new entries on the OWASP
top 10 is number six, Unrestricted
13:43 - Access to Sensitive Business Flows.
13:45 - And this is the first time that OWASP has
referenced business logic specifically,
13:51 - recognizing the opportunities
to exploit logic flaws in your
13:55 - applications to access sensitive data.
13:58 - And you'll see that this concept of
business logic appears in DSS 4.0 as well.
14:04 - There's a specific requirement that
we'll cover to test business logic
14:07 - of your applications and your APIs
in order to find any vulnerabilities.
14:13 - We've got a whole course dedicated
just to the OWASP API Security Top 10,
14:18 - which you can also find on our website.
14:24 - If you're new to PCI, let's have a very
quick review about what it's all about.
14:29 - PCI stands for Payment Card Industry,
and the primary goal is to safeguard
14:35 - sensitive cardholder data and maintain
trust in the payment card industry.
14:40 - Until PCI was created, the five major
credit card brands, Visa, MasterCard,
14:45 - American Express, Discover, JCB all
had their own security standards.
14:50 - And in 2004, they all got together,
formed the PCI, and created a unified
14:55 - set of security requirements, starting
with defining what data needs to be
15:00 - protected, which you can see below.
15:03 - Data like the primary account
number or PAN, cardholder name,
15:07 - expiration, verification, stripe
and chip data, PINs and more.
15:13 - Now PCI is not a law.
15:15 - There's no government
enforced regulation here.
15:18 - But it is a contractual obligation
that applies to any entity that
15:22 - stores, transmits, or processes
credit card transactions.
15:27 - You can see the timeline
of PCI here on the right.
15:30 - It was launched in 2004.
15:32 - In 2006 and 2009 we saw major credit card
breaches at TJ Maxx, where 45 million
15:40 - records were breached, and at Heartland
Payment Systems, where 130million records
15:45 - were breached, which really reinforced
the criticality of PCI and led to the
15:49 - release of DSS 2.0 in 2010, 3.0 in 2013
and 4.0 another nine years later in 2022.
16:02 - Within PCI, there are a number of
different security standards, and
16:05 - you can see some of them here below.
16:07 - Each focuses on a different aspect
of payment card transactions.
16:12 - For example, there are standards
on encryption, on PIN security,
16:16 - on point of sale devices.
16:19 - The one standard that affects virtually
every organization that's covered by
16:22 - PCI, organizations that store, process,
or transmit credit card transactions
16:27 - is DSS, the Data Security Standard.
16:31 - And that's what we'll be focusing
on for the rest of this course.
16:38 - So let's start at the top with
the data security standard.
16:41 - Throughout this course, I
will use direct excerpts from
16:43 - the DSS documentation itself.
16:46 - You can find the documentation
and much more in the PCI Document
16:49 - Library at PCISecurityStandards.org.
16:53 - Let's focus first on the
six primary goals of DSS.
16:57 - Running secure networks and systems.
16:59 - Protecting account data.
17:01 - Finding and fixing vulnerabilities.
17:03 - Control who can access what.
17:05 - Testing and monitoring.
17:06 - And maintaining a security policy.
17:09 - Those six goals are further broken
down into 12 DSS Requirement
17:13 - categories, which you can see here.
17:15 - Everything from updating default passwords
to controlling user access to testing
17:20 - apps for vulnerabilities is covered here.
17:22 - Each requirement provides a detailed
description, how to test for compliance,
17:27 - and guidance on Purpose and Best Practice.
17:30 - We are going to focus on
Requirement 6, Develop and Maintain
17:33 - Secure Systems and Software.
17:35 - Here is where the DSS specifies how
organizations must develop, test,
17:39 - and operate secure applications.
17:46 - Next, let's dig into what's new in 4.0.
17:49 - DSS 4.0 is a huge update to
the Data Security Standard.
17:54 - As you can see, the requirements doc
itself grew by over 2.5X to 360 pages.
18:01 - The PCI Security Standards Council
has outlined four primary goals
18:06 - for the new 4.0 standard, starting
with, of course continuing to meet
18:11 - the security standards and security
needs of the payment industry.
18:16 - Promoting the concept of security
being a continuous process, not a
18:20 - one time or periodic assessment.
18:23 - Adding flexibility for different
methodologies and recognizing that not
18:27 - all organizations do things the same way.
18:30 - So DSS 4.0 provides some options for
compliance and certain requirements.
18:35 - And finally to enhance validation methods.
18:38 - Being more explicit about what compliance
looks like and how to assess it.
18:43 - Now what's especially noteworthy
with respect to APIs is that in
18:48 - 3.0 there was no mention of APIs.
18:51 - And APIs appear in multiple sections
throughout Requirement 6 of the DSS 4.0.
18:58 - And even where APIs aren't explicitly
mentioned they still are very relevant.
19:03 - And one way to think about this is
if your APIs are in scope for your
19:08 - attackers, then they ought to be in
scope for your security programs too.
19:13 - Let's look at what the compliance
timeline looks like for 4.0 real quick.
19:18 - The 4.0 standard was published
in Q1 and Q2 of 2022 and as of Q2
19:26 - 2022, organizations could begin
certifying against the 4.0 standard.
19:32 - That's the beginning of the transition
period that you see here in the timeline.
19:36 - The deadline for 4.0
compliance is March 31, 2024.
19:42 - Meaning all organizations
must comply with the DSS 4.0
19:46 - requirements by the end of Q1 ' 24.
19:51 - There are a few requirements that the DSS
has provided a longer compliance period.
19:57 - Those are all required by March 31, 2025.
20:02 - I'll flag those where
relevant in the coming slides.
20:05 - And if you want to learn more about any
of this, here are a few useful resources.
20:10 - I've shared the links
in the course materials.
20:16 - This brings us to the core of this course,
reviewing the specific requirements in
20:20 - DSS 4.0 and what they mean for APIs.
20:23 - We'll be reviewing about a dozen
sections in the Data Security
20:26 - Standard, mostly from Requirement
6, and examining in detail what is
20:31 - being required and how to achieve it.
20:33 - In each case, I'll show you the actual
text from the DSS document itself,
20:37 - discuss how this requirement applies
to APIs, and provide best practices
20:41 - to comply and keep your APIs secure.
20:45 - So let's get started.
20:50 - Starting with 2.2.7, which states " all
non console administrative access is
20:56 - encrypted using strong  cryptography."
20:58 - I bring this one up as this
requirement explicitly mentions APIs.
21:02 - In fact, it's the first time
the Data Security Standard
21:05 - has flagged API specifically.
21:08 - In this case, the requirement highlights
that encrypted admin console access
21:12 - is required, not just for browser
based UIs, but also for application
21:17 - programming interfaces or APIs.
21:19 - So it's a pretty straightforward
requirement, and of course, all our
21:22 - application communication should
be done over encrypted channels.
21:30 - Now we'll get into the core of DSS 4.0,
which is Requirement 6, "Developing and
21:34 - Maintaining Secure Systems and Software."
21:37 - Here you see a number of sub requirements,
which we'll get into, but one term
21:42 - you'll see throughout Requirement 6
is " Bespoke and Custom Software."
21:46 - This refers to any custom code developed
by your organization or provided to you
21:51 - by another party, and this is subject
to these DSS requirements, specifically
21:56 - if that software stores, processes,
or transmits account data, or it could
22:01 - impact the security of account data.
22:04 - This definition encompasses APIs.
22:06 - So if your bespoke and custom software
incorporates APIs, those are in scope.
22:12 - So as we review the requirements
throughout DSS 4.0, if it applies to
22:16 - your custom developed applications.
22:18 - it applies to those APIs as well.
22:20 - Now, here at the bottom, PCI has provided
guidance that for custom software,
22:25 - "numerous vulnerabilities can be
avoided by applying software lifecycle
22:29 - processes and secure coding techniques."
22:32 - Organizations should strive to create a
culture of security across the application
22:36 - development team, understanding
application risks, writing more secure
22:41 - code, testing for vulnerabilities,
and fixing ahead of production.
22:47 - Moving ahead to section 6.2.1, " Bespoke
and Custom Software are developed securely
22:53 - as follows: based on industry standards
or best practices for secure development,
22:59 - in accordance with the PCI DSS, and
incorporating consideration of information
23:05 - security issues during each stage of
the software development lifecycle."
23:10 - That's the requirement of 6.2.1.
23:12 - Further, The DSS standard instructs
organizations to "understand how sensitive
23:17 - data is handled by the application
to inform how to protect the data."
23:22 - The implication for APIs
here is pretty clear.
23:25 - PCI wants organizations to bake-in
security as early as possible in the
23:29 - creation of custom code, or "shift
left" security as you may have heard it.
23:34 - Stating that "DSS requirements
must be considered when developing
23:38 - software by design rather than trying
to retrofit the software later."
23:43 - To achieve this requirement,
organizations need to ensure application
23:46 - developers are aware of the API
security risks and can create and
23:50 - test code to mitigate those risks.
23:57 - Where 6.2.1 calls for organizations
to utilize industry best practices
24:01 - for secure application development,
6.2.2 goes a step further and
24:06 - mandates training for developers.
24:08 - It states, " Software development
personnel working on bespoke
24:11 - and custom software must be
trained at least every 12 months.
24:15 - And that training needs to be: 1.
24:18 - Relevant to their job function
and development languages.
24:21 - 2.
24:22 - Include secure software
design and coding techniques.
24:25 - And 3.
24:26 - Train on the use of security
testing tools for detecting
24:29 - vulnerabilities in software."
24:31 - As organizations develop applications
with APIs, engineering teams must
24:36 - be trained on API related risks as
well as best practices for avoiding
24:40 - API exposures and vulnerabilities.
24:43 - Organizations should arm development teams
with API-focused security training, such
24:48 - as what we provide on APIsec University.
24:51 - The standard also points to a
need for vulnerability detection
24:55 - and testing custom software.
24:57 - For APIs, organizations need to begin
or expand their security testing.
25:02 - And as we saw earlier, Only 4% of all
API testing is focused on security.
25:09 - New API security testing tools do
exist that will automate API testing
25:13 - and give you continuous assessment.
25:16 - Organizations can't rely solely
on manual testing or once
25:20 - or twice a year pen testing.
25:22 - And finally.
25:23 - Development teams need to be
trained on these tools and how to
25:26 - use them to find vulnerabilities
before they ever get to production.
25:30 - I'd like to point out that APIsec
University makes our courses compatible
25:34 - with internal Learning Management Systems.
25:37 - So if you'd like to provide our
courses to your colleagues and
25:39 - employees within your LMS, we can help.
25:43 - Feel free to get in touch.
25:47 - Section 6.2.3 continues the theme
of looking for and addressing
25:52 - vulnerabilities in code.
25:54 - " Bespoken custom software must be reviewed
prior to being released into production
25:57 - or to customers to identify correct
potential coding vulnerabilities."
26:02 - These code reviews need to look for
new and emerging vulnerabilities.
26:06 - And traditionally, new and
emerging vulnerabilities refers
26:08 - to things like zero-days or other
newly discovered vulnerabilities.
26:13 - These vulnerabilities are most likely to
be related to third party libraries and
26:17 - APIs that you use in your applications.
26:20 - So make sure to keep updated
on any vulnerability reports.
26:24 - A critical best practice,
though, when using third party
26:26 - APIs is to trust nothing.
26:29 - Your application should not assume
that the data coming back from
26:32 - external providers is legitimate.
26:34 - Check all responses to make sure that
it fits with what you're expecting.
26:38 - For example, if your app uses a third
party API to normalize, say, physical
26:43 - addresses, make sure you don't accept
responses that could be malicious, like
26:48 - URLs, or strings with slashes, or anything
that doesn't look like an address.
26:53 - And the final item in the Good Practice
section is especially relevant.
26:57 - "Checking for logical vulnerabilities."
27:00 - This is perhaps the most dangerous
type of flaw in applications.
27:03 - If there is a logic flaw in your app,
that flaw will get exposed via the API,
27:08 - allowing an attacker to exploit it.
27:11 - Your custom software must be analyzed
and tested to find these logic flaws.
27:20 - This section of Requirement 6 is
one of the most substantial in terms
27:23 - of testing for vulnerabilities,
and I like to think of 6.2.4 as
27:27 - the OWASP section of Requirement 6.
27:30 - It mandates the use of "software
engineering techniques to prevent
27:34 - or mitigate common software
attacks and vulnerabilities in
27:37 - bespoke and custom software."
27:40 - So this section details a whole lot of
attack vectors that need to be considered.
27:44 - Things like injections, authentication
exploits, bypassing authorization,
27:49 - cross site scripting, cross
site request forgery, security
27:53 - misconfiguration, and more.
27:55 - All of these covered by the OWASP Top 10.
27:59 - It also explicitly flags APIs as an
interface that must be considered
28:04 - when addressing these risks.
28:06 - Your testing programs must
include APIs,  not just the
28:09 - web and mobile app interfaces.
28:12 - 6.2.4 also reinforces the concept of
business logic attacks that we just
28:16 - learned about in the prior section and
the need to examine your own application
28:21 - functionality and consider not only
how your apps are meant to be used, but
28:26 - critically, how your apps might be abused.
28:29 - For example, and here's a real
world example, there was an
28:33 - attacker who exploited an API on
a crypto trading platform to sell
28:38 - his Ethereum stock as Bitcoin.
28:42 - The API allowed a user to overwrite
what asset they were trading
28:46 - and sell it as something else.
28:47 - A great example of a logic flaw.
28:50 - Web scanners and pen testers regularly
test UIs for injection vulnerabilities,
28:55 - and that must be expanded to
include testing at the API layer.
28:59 - In the last callout box here,
you'll see developers should be
29:03 - familiar with different types of
vulnerabilities and potential attacks,
29:07 - and use measures to avoid potential
attack vectors when developing code.
29:11 - The need for security training
for developers repeats
29:15 - throughout Requirement 6.
29:17 - Again, the API Security Fundamentals
course offers great training
29:20 - for developers and others who
need to understand API risks.
29:27 - 6.3.1 covers Vulnerability
Management and sets the
29:31 - requirements for how organizations
need to operate a VM program.
29:35 - To start, security teams need to have
access to vulnerability information.
29:39 - There are plenty of
vulnerability databases.
29:41 - And  the industry standard
source for vulnerabilities is
29:44 - the CVE database hosted by MITRE.
29:47 - You can find it at cve.mitre.org.
29:51 - CVE stands for Common
Vulnerabilities and Exposures.
29:53 - And pretty much every reported
vulnerability gets documented here
29:57 - and is issued a CVE ID number.
30:00 - But what you'll find here, as the name
states, are common vulnerabilities.
30:05 - I.
30:05 - e., vulnerabilities in third party
code, apps, and libraries that you use.
30:10 - But notice the statement here
at the bottom to specifically
30:14 - look for vulnerabilities in
custom code and bespoke software.
30:18 - And here, the DSS adds more detail
about where to find vulnerabilities
30:23 - in your third party software.
30:26 - And all of this so far really
focuses on the third party.
30:30 - But here in the last callout box,
you'll see DSS showing concern for
30:34 - your proprietary application logic.
30:37 - And this is a really critical element.
30:39 - DSS states, "for control over
in house developed software, the
30:43 - organization may receive such
information from external sources."
30:48 - And then they highlight bug
bounty programs, independent
30:51 - investigators, and more.
30:53 - Now, this requirement has big
implications for your APIs.
30:57 - First, you need to secure the third party
APIs that your applications consume.
31:02 - That means keeping up to date on
versions, patching that's required,
31:06 - monitoring for new vulnerabilities.
31:08 - And second, you need to look at
your internally generated code,
31:12 - including anything that's exposed
by APIs to find vulnerabilities or
31:16 - logic flaws, authorization gaps or
anything else that can be exploited.
31:21 - And you're not going to find
this in any CVE database or Patch
31:25 - Tuesday alert or anything else.
31:27 - Flaws in your code are your
own personal zero-days.
31:31 - And these vulnerabilities are
the types of vulnerabilities
31:34 - attackers most want to find.
31:37 - The traditional and common
vulnerabilities, things like injections
31:39 - and cross site scripting, are rarely
the cause of major API breaches.
31:46 - Your APIs expose your application
logic, the good and the bad, and
31:50 - any flaws in your application
logic will also get exposed.
31:54 - So it's critical to, 1.
31:57 - keep up to date on the latest
API attack techniques, and 2.
32:01 - perform security testing on
your applications regularly.
32:04 - That means not once or twice a
year, but with every release.
32:08 - And make sure that testing covers your
APIs and is  providing adequate coverage.
32:12 - That means testing every endpoint
across dozens of attack vectors,
32:15 - including logic and authorization tests.
32:18 - Now, this probably sounds a bit daunting,
and the only way to achieve this level of
32:22 - continuous assessment is with automation.
32:24 - There are API optimized testing
tools out there to help.
32:31 - 6.3.2 focuses on having an up to date,
complete, and accurate software inventory,
32:37 - specifically your bespoke and custom
software, as well as any third party code
32:42 - you're using in your custom applications.
32:44 - The stated goal of this inventory
is to "facilitate vulnerability
32:49 - and patch management."
32:50 - And here in the Purpose section,
the DSS explicitly calls out
32:55 - third party libraries and APIs.
32:57 - These need to be known, tracked,
and managed to address any
33:01 - vulnerabilities that they might have.
33:03 - Actually, having an accurate inventory
of your software and APIs isn't just
33:08 - good for security, it's critical to
your overall application governance.
33:12 - I've met with many security teams who
claim they have little awareness of all
33:16 - the APIs running in their organization,
and this is undoubtedly true.
33:20 - But the fact that security teams
don't have this information
33:23 - doesn't mean it doesn't exist.
33:25 - So security teams have to partner
with Engineering to deal with
33:29 - these API security concerns.
33:31 - The reason why is APIs are
fundamentally gateways to your
33:35 - application functionality.
33:37 - And most vulnerabilities will need to
get addressed inside the app code in
33:41 - collaboration with the engineering team.
33:44 - We've got whole courses dedicated
to API governance, but that's really
33:47 - where security needs to start.
33:50 - Governance means knowing what APIs you
have, but also what function they provide,
33:55 - who has access to them, how they need to
be secured, things like authentication,
33:59 - access controls, input validation, etc.
34:03 - And governance also means setting
standards for how your APIs are
34:07 - documented, what policies you
have for handling sensitive data,
34:11 - when you need new versions, what
happens to the old versions.
34:15 - And governance also means APIs
get deployed into production in a
34:18 - standard way where every release
goes through, not just functional
34:22 - testing, but security testing too.
34:25 - And all APIs get managed in a common
platform, like an API gateway.
34:29 - This gives your organization, not
just great consistency and operational
34:33 - efficiency, but also enables security.
34:36 - What APIs you have, how they're being
used, and they have to clear the
34:40 - necessary gates to get into production.
34:43 - For this requirement, organizations
have until March 31, 2025, one year
34:48 - later than most of the DSS 4.0.
34:52 - And that's likely a reflection of
the challenges organizations have in
34:55 - even producing an accurate inventory.
34:57 - Until then, DSS calls this
a best practice, which I
35:01 - couldn't agree more with.
35:02 - Definitely invest the effort
to produce an inventory.
35:06 - But if you're going to do this,
then make the most out of it.
35:10 - Use this as a driver for
better overall security in your
35:13 - organization and better governance
across the entire API lifecycle.
35:17 - Look at your API program from design to
coding to testing to deployment to really
35:22 - reap the benefits of better governance.
35:29 - We're next going to cover 6.4.1 and 6.4.2
together, and you'll see why in a second.
35:34 - This requirement addresses the need
to actively protect public facing
35:38 - web applications against attacks.
35:40 - The purpose, of course, is to make
sure applications are resilient against
35:45 - attacks, as web applications are going to
be the primary target for those attacks.
35:50 - As DSS states, "poorly coded
web applications provide an easy
35:55 - path for attackers to gain access
to sensitive data and systems."
35:59 - But pay attention to that
term web application.
36:01 - Many will interpret that as
referring to their web, and
36:06 - maybe mobile, user interfaces.
36:08 - When we think of an application,
we tend to picture something you
36:11 - can look at and interact with.
36:14 - But this is not the full
scope of your application.
36:16 - You have to look at any interface,
human or machine, that can
36:20 - exercise your application.
36:22 - And that includes APIs.
36:24 - So the choices DSS provides here are
to either perform a vulnerability
36:28 - assessment or implement some kind of
inline automated protection solution.
36:35 - If you go with the vulnerability
assessment route, the requirement is to
36:38 - perform the scan every 12 months or after
any major change to your application.
36:43 - The assessment must be performed
by an organization that specializes
36:47 - in application security.
36:49 - It has to cover all the threats
that we talked about in 6.2.4.
36:53 - You have to rank all the vulnerabilities
you find and correct them, as specified in
36:58 - 6.3.1, and then retest your apps to make
sure the vulnerabilities are remedied.
37:03 - Now for the automated protection approach,
this has to be installed in front of
37:07 - your web app, running continuously
to find and block any attacks.
37:12 - And it must produce audit logs that
can be analyzed later as needed.
37:16 - The most common example of an
automated protection solution is
37:19 - a WAF, a Web Application Firewall.
37:22 - These are widely used to analyze
application layer traffic and
37:25 - block against known threats like
injections, high volume attacks,
37:29 - cross site scripting, etc.
37:32 - An API gateway will also provide
protection and can perform things like
37:37 - API input validation, user authentication,
access controls, rate limiting, IP
37:43 - and geographic whitelisting and more.
37:46 - There are API specific runtime
protection solutions as well
37:49 - that act like WAFs for APIs.
37:52 - In terms of timing, 6.4.1 gives
organizations a choice of approaches,
37:57 - but you have to comply with one
or the other by March 31, 2024.
38:01 - Now, under 6.4.2, that option goes away,
and you must deploy an automated approach,
38:08 - or an automated technical solution,
and that is due by March 31, 2025.
38:14 - Now, although runtime detection and
blocking of active threats is very
38:18 - appealing, the reality is certain
attacks are nearly impossible to
38:22 - detect in real time, as signature
based blocking and anomaly detection
38:25 - aren't able to identify every attack.
38:28 - Some of the most damaging API attacks
we've seen exploit unique application
38:32 - logic where unintended flaws exist.
38:36 - In the example I gave earlier
with the crypto trading platform,
38:39 - the user exploited a flaw in the
API where they could change their
38:42 - asset from one type to another.
38:44 - This would be virtually impossible
to detect in any automated way.
38:48 - So really the best practice here is both.
38:51 - To do both automated blocking where
possible, and to complement that
38:55 - with comprehensive testing to uncover
flaws before attackers find them.
39:04 - Section 7 of the DSS focuses on access
controls to critical data and systems.
39:09 - I just want to touch on this section
in general and highlight a few
39:12 - requirements and best practices.
39:14 - The purpose of this whole
Requirement 7 boils down to who
39:18 - has access to applications and
systems and what can they do.
39:22 - Of course, this applies to the
underlying infrastructure that
39:25 - supports your applications.
39:26 - The servers, containers,
databases, network devices.
39:30 - You have to make sure access is
secure and controlled internally.
39:34 - At the application layer, though,
you have to think about all the
39:37 - functionality, the data accessibility,
the business flows, and your user types.
39:41 - For example, a regular user should be
able to access their account balance.
39:46 - They should not be able to
see any other user's data.
39:49 - But maybe you have support
personnel who need to be able to
39:52 - access any user's information.
39:54 - Or take that end user
accessing their balance.
39:57 - They should be able to see their
balance, but not modify it.
40:00 - So what this means is, you need to
build a matrix of all functionality
40:04 - available through your APIs, and map that
across all of your user types, whether
40:08 - that's an end user, support person,
QA engineer, developer, admin, etc.
40:14 - And even map that across your
different environments, development,
40:18 - testing, staging, production.
40:20 - It's not enough to do this
analysis at the UI level.
40:23 - As we've seen before, while UIs provide
the ability to control user behavior,
40:28 - filter data, and manage what they can do,
when you take the UI out of the equation,
40:33 - you're left with individual API endpoints.
40:36 - So make sure you're analyzing
access controls at the API level.
40:40 - Now let's talk for a second about
authentication versus authorization.
40:45 - You definitely want to set up policies
around API endpoint authentication and
40:49 - define those policies in an API Style
Guide that all your developers can use.
40:54 - For example, if an endpoint is
purely informational, has no user
40:58 - data, for example, an endpoint that
checks where the nearest bank branch
41:02 - is, then maybe you don't need any
authentication on that endpoint.
41:05 - But another endpoint could let a
user check their account balance.
41:08 - So you'll want to authenticate them.
41:10 - And maybe even higher security
for performing a transfer, like
41:13 - putting in a two factor challenge.
41:16 - That's all about confirming that
the user is who they say they are.
41:19 - And this can be managed at the API layer.
41:22 - And the best practice is to centralize
all that access in an API gateway.
41:27 - But authentication is not the same
as authorization, and we've seen
41:30 - many breaches where an organization
implemented user authentication but
41:34 - failed to address authorization.
41:37 - Let's use another example.
41:38 - There's a popular exercise equipment
vendor that provides an API that has
41:42 - access to all users in the platform.
41:45 - Although the API required users
to authenticate properly to access
41:48 - the endpoints, it did not control
which records they could see.
41:52 - So once authenticated, the user could
see not only their own records, they
41:56 - could see anyone else's as well.
41:58 - This is more common
than you might imagine.
42:01 - The point is authorization needs
to be considered and defined
42:05 - and then implemented within the
application logic itself, not at
42:09 - a gateway or other access point.
42:12 - Lastly, once you've got your access
controls defined and implemented properly.
42:17 - You want to make sure nothing changes.
42:19 - And if something does, you know about it.
42:22 - Here's where we recommend
RBAC monitoring, i.
42:25 - e.
42:25 - continuous testing of Role Based
Access Controls, to see if any settings
42:29 - get adjusted so you can be aware
and ensure no control gaps emerge.
42:39 - Here's another section
I'll cover at a high level.
42:41 - 10.0, "Log and Monitor All Access to
System Components and Cardholder Data."
42:47 - This section spells out in detail all
the requirements for collecting logs,
42:50 - storing the data in a central repository,
and analyzing the activity records for
42:54 - security and incident response purposes.
42:58 - As the DSS states, "logs allow
thorough tracking, alerting, and
43:02 - analysis when something does go wrong.
43:04 - Determining the cause of a compromise
is difficult, if not impossible,
43:08 - without system activity logs."
43:10 - Now typically logging is enabled
and captured at the system level, i.
43:15 - e.
43:15 - all the servers, databases, network
devices, firewalls, and more.
43:20 - But logging must also be captured
at the application level.
43:24 - Here's where you'll see the
details of user behavior and be
43:27 - able to find anomalous activity.
43:30 - To get this level of granularity, your
application must first be instrumented
43:34 - to produce the logs in the first place.
43:37 - Make sure your developers add
logging events into their code that
43:40 - captures all the relevant details.
43:42 - Who's performing the action?
43:44 - What are they doing?
43:45 - When did it occur?
43:46 - From what source or IP address?
43:49 - Was the action successful?
43:51 - Another great source of application
level logging is at the API Gateway.
43:56 - These platforms will natively record all
accesses to APIs and individual endpoints.
44:02 - Finally, be sure to centralize all
this data in a common repository
44:06 - where your security team can analyze
and detect threats as they happen.
44:15 - And the last section I want to cover
in PCI DSS 4.0 is Requirement 11.
44:20 - "Test security of systems
and networks regularly."
44:23 - Throughout this course, and across
many of the DSS 4.0 sections, we've
44:27 - talked about how important testing is.
44:30 - Many of the DSS requirements specify
security objectives, with the need
44:34 - to test to confirm programs are
running as designed, to ensure
44:38 - vulnerabilities aren't appearing,
and access controls are set properly.
44:43 - Section 11.0 formalizes this need
to test for security regularly, and
44:48 - DSS recognizes that "vulnerabilities
are being discovered continually by
44:53 - malicious individuals and researchers,
and being introduced by new software.
44:57 - System components, processes, and
bespoke and custom software should
45:01 - be tested frequently to ensure
security controls continue to
45:04 - reflect a changing environment."
45:06 - As you can see, this requirement
specifically refers to bespoke and
45:10 - custom software and the vulnerabilities
that your code can create.
45:15 - It also mandates organizations test
applications frequently to ensure
45:19 - no vulnerabilities go undiscovered.
45:22 - As we've discussed throughout
this course, application testing
45:24 - cannot be limited to UI alone.
45:27 - Public facing applications rely
on public facing APIs, and these
45:31 - are ripe targets for attackers.
45:33 - So your testing programs must include
APIs and should be automated to ensure
45:37 - complete coverage of every API endpoint,
simulate attacks across all of the
45:42 - OWASP Top 10 categories and more.
45:45 - And run in a continuous
manner, recognizing that modern
45:48 - organizations update code
monthly, weekly, and even daily.
45:52 - So make sure your testing keeps up.
45:59 - Okay, we've covered a lot of ground
here and have examined how organizations
46:02 - need to address API security concerns
to stay compliant with PCI DSS 4.0.
46:08 - So let's bring it all together and
summarize what the requirements
46:11 - are, some of the best practices
for not only complying with the
46:14 - standard, but in elevating your
organization's security posture.
46:18 - And we'll wrap it up with
a list of do's and don'ts.
46:22 - First, let's summarize the
various sections of DSS 4.0
46:25 - and what they mean for APIs.
46:28 - Starting with 2.2.7, this requires secure
access to admin consoles, including
46:33 - encryption of all communications.
46:35 - Make sure you're looking at API access
to consoles as well, and not only
46:39 - encrypting the communication, but
controlling access to those endpoints.
46:44 - 6.0 is the core of DSS 4.0 with respect
to securing payment related applications.
46:51 - We spent a lot of time looking at many
different subsections of Requirement 6.
46:55 - The key to remember here is that with
DSS 4.0, APIs are 100% in scope now.
47:01 - All your bespoke and custom
software, the code you write to
47:04 - power your organization's unique
offerings, is powered by APIs.
47:08 - And those APIs need to be secured
as much, or even more than your
47:12 - classic web and mobile applications.
47:15 - The subsections in requirement 6
get more specific about securing
47:19 - your custom applications.
47:21 - 6.2.1 focuses on secure software
development, and requires
47:26 - engineers to be aware of API
security and vulnerability risks.
47:29 - to ensure code is free of
flaws that can be exploited.
47:32 - DSS recommends integrating as far left
as possible to find vulnerabilities
47:36 - before they reach production.
47:39 - 6.2.2 sets requirements for
annual training of developers.
47:43 - APIs have unique attack patterns, so
it's critical that your developers
47:46 - understand what these look like and
how to create more secure applications.
47:51 - 6.2.3 requires organizations to review
and test code for security flaws.
47:56 - Here, DSS highlights how attackers
are targeting your custom code
48:00 - via the APIs, and looking to find
and exploit logic vulnerabilities.
48:04 - 6.2.4 covers a wide range of well known
application attack types and mirrors
48:09 - closely the threats listed in the OWASP
application and API security top 10 lists.
48:15 - This section rightly calls out API
specifically and highlights attacks on
48:19 - business logic and manipulation of APIs.
48:22 - The point being, your vulnerability
discovery efforts need to
48:25 - cover APIs, not just UIs.
48:28 - 6.3.1 calls on organizations to implement
vulnerability management programs.
48:33 - It's important to focus on
the vulnerabilities that are
48:35 - likely to cause the most damage.
48:37 - And while injections and cross site
scripting are legitimate vulnerabilities,
48:41 - and you absolutely need to test
and fix these flaws, these rarely
48:45 - are the cause of major breaches.
48:47 - What we see regularly are logic
flaws, weak authentication,
48:51 - and authorization gaps.
48:52 - These are the vulnerabilities you need
to test for, especially at the API level.
48:57 - 6.3.2 requires organizations to develop
and maintain an accurate and up to
49:02 - date inventory of all custom software.
49:05 - This must include your APIs.
49:07 - Having that accurate inventory is really
part of a solid application governance
49:11 - program where you standardize how APIs
get created, set security policies that
49:16 - are implemented consistently and all APIs
get tested and deployed in a common way.
49:22 - 6.4.1 gives organizations an option to
perform either periodic vulnerability
49:27 - assessments or implement runtime
attack detection and blocking.
49:32 - The option goes away in 2025 when
all PCI covered entities must enforce
49:37 - active detection and blocking.
49:39 - Just be aware that not all threats
can be detected in real time.
49:43 - There's no magic firewall that
will protect against all threats,
49:46 - and in fact, frequently the most
damaging exploits aren't detectable.
49:51 - So you need to keep up testing
and detection of vulnerabilities,
49:54 - and then fix this in the code.
49:57 - 7.0 requires strong access controls.
50:00 - Here you need to examine the entire
infrastructure and application
50:03 - stack and look at what users can
access and what they can see.
50:07 - It's important to review these controls
down to the individual API endpoint level
50:11 - to make sure there aren't any access gaps.
50:14 - And definitely implement continuous
testing to uncover and alert on
50:17 - any changes in access permissions.
50:21 - 10.0 requires organizations to
capture logs from all systems
50:24 - involved in payment processing.
50:26 - This is critical to detect threats
and perform root cause analysis.
50:30 - Make sure you're capturing user activity
logs on APIs as well, and this is
50:34 - best accomplished with an API gateway.
50:37 - And 11.0 calls on organizations to perform
regular testing of their custom software.
50:42 - So make sure that includes
all of your APIs as well.
50:49 - All right, as we wrap up this course,
let's touch on some of the core best
50:52 - practices, not just to comply with
PCI, but to run a more efficient
50:56 - and effective API security program.
50:59 - We'll start with governance.
51:01 - API security is not really
something you can bolt on.
51:04 - You want to integrate security into
the entire application lifecycle, from
51:08 - design, to product, to retirement,
creating a culture of security
51:12 - throughout your organization.
51:14 - This starts with putting time and
effort into defining your API policies,
51:18 - how your APIs get used, who can use
them, what they can do, then defining
51:23 - your standards, what APIs should
look like, how do they get created.
51:28 - And then standardizing your processes.
51:31 - How do APIs move from development
through QA and into production
51:34 - in a consistent manner.
51:36 - It's highly recommended that you
centralize all your APIs in a
51:39 - common platform, something like
an API gateway or a marketplace.
51:43 - This will let you manage APIs
consistently, define common policies,
51:47 - and give you a central source for
auditing and logging user behavior.
51:52 - And make sure all your APIs only go
into production having passed the
51:55 - required gates, including documentation,
testing, security audit, and so forth.
52:01 - Our next best practice focuses on how to
create a culture of security within the
52:05 - engineering and development organizations.
52:08 - We've hosted many roundtables
with cybersecurity leaders
52:11 - and noticed a common theme.
52:12 - The CISOs uniformly agreed on
the need to integrate security
52:16 - into the development team.
52:18 - And one of the best ways to create that
security awareness was to embed security
52:22 - champions right into those teams.
52:25 - As we've discussed, especially with
applications and APIs, development
52:29 - shares the responsibility for
security, as most vulnerabilities will
52:33 - require dev involvement to remediate.
52:36 - Security champions are security
savvy personnel who can work
52:40 - and operate directly within
the development organization,
52:43 - providing insights, best practices,
answering questions, and so forth.
52:48 - Number three on our best practices
list is actually straight out of the
52:51 - DSS document: providing API security
training to all relevant employees.
52:56 - And this should include any
developers creating APIs, any API
52:59 - product owners, and ops teams.
53:02 - As we've seen, APIs face new and different
types of attacks, so make sure the
53:06 - training covers API specific threats,
the OWASP API Security Top 10, and
53:11 - best practices for keeping APIs secure.
53:14 - We've got a great course
at APIsec University called
53:17 - API Security Fundamentals.
53:18 - It covers everything I just mentioned
and can even be deployed in an
53:21 - internal Learning Management System.
53:24 - And our last best practice
here focuses on testing.
53:27 - APIs expose so much application
functionality, and it's more
53:31 - critical than ever to really pressure
test that functionality to make
53:35 - sure your apps can't be abused.
53:37 - This means testing every single API
endpoint across all kinds of attack types,
53:42 - everything you see in the OWASP Top 10,
and examine your app logic to look for
53:47 - any flaws or gaps that can be exploited.
53:50 - And you need to do this with automation.
53:51 - Implement a testing program that will
run automatically, create the test
53:55 - coverage you need, and run against
every release to find vulnerabilities
53:59 - before they get to production.
54:04 - I'd like to wrap up my courses with some
really tactical do's and don'ts that you
54:08 - can take back and implement right away.
54:10 - As we've mentioned a number of
times, DO educate your development
54:14 - team and API owners on API risks.
54:16 - They're under attack, and the
threats are different than
54:19 - what our web apps have seen.
54:21 - DO integrate security
into the dev process.
54:24 - Make sure engineers understand how to
code more resilient APIs and test for
54:28 - vulnerabilities ahead of production.
54:30 - DO build communication between
security and development.
54:33 - The gap here is way
too big, way too often.
54:37 - Both teams need to collaborate
to keep APIs secure.
54:40 - DO mandate documentation on all APIs.
54:43 - This feels like one that
shouldn't be needed, but far too
54:46 - many APIs are not documented.
54:48 - Under documented or not updated.
54:51 - Documentation helps drive
consistency, reusability,
54:54 - integrations, and also security.
54:57 - DON'T treat internal APIs
as inherently secure.
55:01 - They may be harder to find, but
attackers are pretty clever, and
55:04 - we've seen many internal APIs
get accessed in unexpected ways.
55:08 - DO centralize API management and
control in something like a gateway.
55:13 - Many organizations end up using
multiple gateways, which is fine.
55:16 - Just use some platform to manage
all your APIs in a consistent way.
55:21 - DON'T rely exclusively on
manual security testing.
55:25 - A once or twice a year penetration
test will not keep up with
55:28 - the pace of your code changes.
55:30 - And it won't give you the breadth
of coverage considering how many
55:33 - endpoints you have and the attack
types you need to simulate.
55:36 - Which leads to our next
item, DO automate testing.
55:40 - Integrate your testing
with your CI/CD pipeline.
55:43 - Make sure every release gets
tested before they go live.
55:46 - DON'T filter data in the UI.
55:48 - This is one I can't stress enough.
55:50 - If your app returns all the fields of
a record, and you rely on the UI to
55:54 - filter out the sensitive stuff, then
all an attacker needs to do is go
55:58 - around the UI and call the API directly
and get the raw, unfiltered data.
56:04 - DO take time to carefully
define API standards.
56:07 - This falls under the governance umbrella.
56:09 - It's really important to have
a well defined, thought out set
56:12 - of API standards and policies.
56:14 - This will aid your entire API lifecycle,
including security and compliance.
56:19 - DO pressure test your
APIs for logic flaws.
56:22 - These are nearly impossible to detect
in real time, so make sure you test
56:26 - your APIs in ways they're not meant
to be used to find these flaws.
56:31 - DO use runtime protection
to block well known attacks.
56:34 - This is mandated in PCI
and is a best practice.
56:38 - So use a web application firewall
or other device to block volumetric
56:42 - attacks, injections, and others.
56:45 - But DON'T expect the firewall
to prevent all threats.
56:48 - Some are going to get through, so make
sure you're finding those vulnerabilities.
56:52 - especially logic vulnerabilities
through testing before production.
56:56 - And finally, DO train your API teams
on the OWASP API Security Top 10.
57:02 - This is the industry standard on API risks
for a good reason, and you definitely want
57:06 - your developers to understand the threats.
57:12 - That wraps up the API Security
for PCI Compliance course.
57:15 - Congratulations on making
it all the way through.
57:18 - I hope you enjoyed the course.
57:19 - We'll be sending you a certificate
of completion and badge to
57:22 - recognize your accomplishment.
57:24 - I really appreciate you taking
the time for this course, and I
57:27 - invite you to check out our other
courses at apisecuniversity.com.
57:31 - I'd love to hear from you if you've
got any feedback, suggestions, or just
57:34 - want to connect for any other reason.
57:36 - You can find me on LinkedIn and
you're welcome to email me directly.
57:40 - Thanks again and I hope to see
you in another course soon.
57:44 - Okay, that wraps up the API
Security for PCI Compliance course.
57:48 - Hope you enjoyed it.
57:49 - If you'd like to earn a badge and
certificate for this course, please enroll
57:53 - at apisecuniversity.com, take the quizzes,
and we'll be happy to issue your cert.
57:58 - While you're there, be sure to
check out our other courses,
58:01 - including API Pentesting, API
Security Fundamentals, and more.
58:05 - We also host many webinars with
API experts across industries,
58:08 - disciplines, and geographies.
58:10 - You'll see these listed on our
website and on our YouTube channel.
58:13 - Please subscribe.
58:15 - Thanks for watching, and
hope to see you again soon.

Cleaned transcript:

Learn about API security with this course that is tailored to address the pivotal PCI DSS 4.0 requirements. PCI DSS stands for payment card industry data security standard. It is a set of security standards designed to ensure that all companies that accept, process, store, or transmit credit card information maintain a secure environment. As the PCI standard takes a definitive turn to spotlight API security for the first time, understanding its intricacies becomes crucial for businesses. Dive in to decode what DSS 4.0 means for your organization, why APIs are now in the limelight of attackers, and gain invaluable insights into ensuring compliance. Equip yourself with knowledge, best practices, and stay a step ahead in safeguarding your operations. This course was developed by Dan Barahona who has 20 years of cybersecurity experience. Hello, Free Code Camp community and welcome to APIsec University and this course on APS security for PCI compliance. My name is Dan Barahona, one of the co founders here at APIsec University, and for the next hour, you'll learn all about the new PCI DSS 4. 0 and what it. And what requirements it has for API security. I also invite you to check out all our free courses on apisecuniversity.com, including a hands on course on API Pen Testing, an introductory course on API Security Fundamentals, this course on PCI Compliance, as well as one on the OWASP API Top 10, API Documentation and more to come. All the courses on our site include quizzes to assess your knowledge. And if you complete everything and pass the final quiz, we'll issue you a certificate and badge to recognize your accomplishment, which you can also display on your LinkedIn profile. Thanks again for watching, and I hope you enjoy this course. Hi, and welcome to our course on API Security for PCI Compliance. In 2022, PCI released version 4.0 of the Data Security Standard, and it's the first major update in the last 10 years. A lot has changed since then, not just in the standard, but in the world of APIs. If you think back to 2013 when 3.0 came out Google was just releasing their Glass product, we were on the iPhone 5, Instagram was just adding video to their platform. And the OWASP community was six years away from releasing an API Security Top 10. Adoption of APIs was at a fraction of where it is today. And whole industries have emerged around APIs, particularly in fintech and ecommerce. Companies that rely entirely on APIs. And it's hard to imagine any credit card transaction taking place today that is not using APIs somewhere in the chain. And APIs don't even appear in 3.0 of the DSS standards at all, but feature prominently in 4.0. The goal of this course is to introduce you to the changes in 4.0, specifically as they apply to APIs. And not only to show you how to achieve compliance, but to elevate your security posture overall. I hope you enjoy the course. Well, let's dive right in and review what we're going to be covering in this course. We're going to start with the basics. Why are we even talking about API security in the context of PCI and DSS? How are APIs even relevant and why should we care? For those who are new to PCI, we'll do a very brief introduction of the PCI standard itself, follow that up with a review of the DSS, Data Security Standard, and examine what's new in 4.0. What's changed and when you need to comply. And then we'll get into the core of the course here, reviewing the DSS 4.0 standards and requirements in detail. We'll be unpacking individual sections of 4.0, understanding what the requirements are. The best practices and exploring what this means for APIs and how to keep your organization safe. As always, we'll wrap it up with some best practices and do's and don'ts that you can start implementing today. We'll feature some quizzes as we go along and a final quiz as well. And if you complete the whole course, we'll be pleased to send you a certificate and badge to demonstrate your achievement. But first, let me introduce myself. I'm your instructor for this course. My name is Dan Barahona. I've been in the cybersecurity industry for over 20 years, held lots of different roles, spanning marketing, sales, products. Holding leadership roles at places like Qualys, HP and ArcSight, Anomali, and over here at APIsec. From an education perspective, I earned engineering degrees from Rensselaer and Cornell University before doing an MBA over at University of Michigan. I'm the cofounder here of APIsec University. And I really love to be in touch. So if you want to look me up and connect with me on LinkedIn, or you can email me anytime at dan@apisecuniversity.com. Happy to get your messages, questions, feedback, anything we can do to continue to grow this APIsec University site. Thanks so much. So let's kick things off by understanding why API security is such an important topic and why it's so relevant to PCI. And there are three important dynamics happening now with APIs. The first is that APIs are exploding. We've known this for years and it just continues. You've probably seen the statistic that over 83% of all internet traffic now is API based. This is a study from Akamai, they analyzed all their network traffic and discovered this incredible prevalence of APIsourced traffic. Look at the API calls, a hundred billion open banking API calls this year and expected to grow by 5X over the next five years to 500 billion. There's really no end in sight of the adoption of APIs, and that's thanks to just the sheer value and benefit that these APIs provide. And they're powering virtually everything. Every ecommerce transaction, our medical devices, our connected cars, you can lock and unlock, start and stop engines through APIs. They're really powering virtually everything. But APIs are also under heavy attack. The stats are really quite staggering. 40 to 75 billion dollars a year in cyber loss related to APIs. For years, Gartner, the analyst firm, has been predicting that by 2022 APIs would become "the most frequent attack vector." I think that has been borne out and continues to be true. I have another course, API Security Fundamentals, if you want to learn more about specific breaches, we go into a lot of detail there and explore how APIs were exploited. So I recommend you check out that course if you're interested. But the third dynamic is API security. Our APIs are seriously undersecured. And if you just look at testing alone, this report from stateofapis.com looks at all of the testing we do on APIs, and only 4% of that effort is focused on security. And there's a reason for this. How we build applications has fundamentally changed, but security is still keeping up. I want to share some thoughts from a recent Gartner report that really nailed the challenges and the changes happening in application development and security. This comes from a Hype Cycle report on application security that Gartner published in July 2023. Some of the key trends are that we're now developing apps more quickly, in more agile ways, we're relying more and more on developers to secure the code to integrate security into their applications. And we've changed how we deploy and operate our applications with things like cloud native strategies. And these are challenging our traditional and established approaches to application development and provisioning and deployment. However, our existing application security controls have not kept up, and they've become less effective. Dionisio from Gartner summarizes it well. API attacks have resulted in a stream of data breaches, and DevSecOps teams have increasingly become interested in API testing and security. However, our traditional AST tools, application security testing tools, were not originally designed to test for some of the unique types of vulnerabilities associated with typical attacks against APIs. And his point is really spot on. API attacks are fundamentally different and let's examine why. So organizations have long used tools like SAST and DAST, static and dynamic application security testing solutions. And these are very mature, well known tools that look for poor coding practices, injection flaws, cross site scripting, things like CSRF, cross site request forgery, SSRF, server side request forgery, misconfigurations and the like. These tools are looking for common vulnerabilities, common flaws that might exist in your applications. But if you look at the breaches that successfully exploit APIs and result in the losses of hundreds of millions of records, this is not what's causing those breaches. It's not injections. It's not cross site scripting. API breaches exploit something different. Typically business logic flaws or gaps in authorization or weak authentication and the like. And if you want to keep up on this there's a great site, apisecurity.io, where they capture these types of events and exploits and breaches. And you'll see how API breaches happen just doesn't look like our traditional web application attacks. And this graphic down below reinforces the point. Our web scanners, for the most part, are scanning at the UI layer. Mobile UI, Web UI. And there are two issues with this approach. First, we've been relying on the UI layer for too long to do more than presentation. The UI layer is also providing security. It's filtering what data users can see, what actions they can take, what buttons they can press. And this is a problem. The UI should really be about presentation, not about security. And the reason why is that UIs are powered by APIs. And attackers are going to go right around your UI straight to the API. And at the API level, you don't have the benefit of this UI and the filtering and the controls that it's providing. So if an attacker can dream up a request for an API, they can send it. And if your backend app logic doesn't know to block those requests, they'll get executed. And that's how API breaches happen. Again, we have a whole course focused on this topic, the API Security Fundamentals course, where you can learn a lot more on this. No API security course would be complete without a mention of the OWASP API Security Top 10. The OWASP is the Open Web Application Security Project. It's a community that has produced truly foundational application security guides and is famous for its top 10 lists. In 2019, OWASP added a dedicated top 10 for API security, which differed quite a bit from their web app top 10. These lists are widely considered to be industry standards for how to secure your applications. And in 2023, The OWASP community released an updated version of the API top 10, which you can see here. There've been some changes, some additions and deletions, and some items remain the same. The top two are still at the top. And for good reason, the vast majority of API breaches violate one or both of these items. Number one is Broken Object Level Authorization, also known as BOLA. And it refers to the ability of, say, one user being able to access another user's data through an API. And there are many examples of these which we cover in some of our other courses. Number two is Broken Authentication, which is also a frequent cause of breaches. Many times, API endpoints are left open with no authentication, with organizations assuming these endpoints won't be discovered. You should always assume they will be discovered, as attackers will try their best to find these endpoints. And you should protect all endpoints with security, regardless of whether they are documented, published, internal, or external. One of the new entries on the OWASP top 10 is number six, Unrestricted Access to Sensitive Business Flows. And this is the first time that OWASP has referenced business logic specifically, recognizing the opportunities to exploit logic flaws in your applications to access sensitive data. And you'll see that this concept of business logic appears in DSS 4.0 as well. There's a specific requirement that we'll cover to test business logic of your applications and your APIs in order to find any vulnerabilities. We've got a whole course dedicated just to the OWASP API Security Top 10, which you can also find on our website. If you're new to PCI, let's have a very quick review about what it's all about. PCI stands for Payment Card Industry, and the primary goal is to safeguard sensitive cardholder data and maintain trust in the payment card industry. Until PCI was created, the five major credit card brands, Visa, MasterCard, American Express, Discover, JCB all had their own security standards. And in 2004, they all got together, formed the PCI, and created a unified set of security requirements, starting with defining what data needs to be protected, which you can see below. Data like the primary account number or PAN, cardholder name, expiration, verification, stripe and chip data, PINs and more. Now PCI is not a law. There's no government enforced regulation here. But it is a contractual obligation that applies to any entity that stores, transmits, or processes credit card transactions. You can see the timeline of PCI here on the right. It was launched in 2004. In 2006 and 2009 we saw major credit card breaches at TJ Maxx, where 45 million records were breached, and at Heartland Payment Systems, where 130million records were breached, which really reinforced the criticality of PCI and led to the release of DSS 2.0 in 2010, 3.0 in 2013 and 4.0 another nine years later in 2022. Within PCI, there are a number of different security standards, and you can see some of them here below. Each focuses on a different aspect of payment card transactions. For example, there are standards on encryption, on PIN security, on point of sale devices. The one standard that affects virtually every organization that's covered by PCI, organizations that store, process, or transmit credit card transactions is DSS, the Data Security Standard. And that's what we'll be focusing on for the rest of this course. So let's start at the top with the data security standard. Throughout this course, I will use direct excerpts from the DSS documentation itself. You can find the documentation and much more in the PCI Document Library at PCISecurityStandards.org. Let's focus first on the six primary goals of DSS. Running secure networks and systems. Protecting account data. Finding and fixing vulnerabilities. Control who can access what. Testing and monitoring. And maintaining a security policy. Those six goals are further broken down into 12 DSS Requirement categories, which you can see here. Everything from updating default passwords to controlling user access to testing apps for vulnerabilities is covered here. Each requirement provides a detailed description, how to test for compliance, and guidance on Purpose and Best Practice. We are going to focus on Requirement 6, Develop and Maintain Secure Systems and Software. Here is where the DSS specifies how organizations must develop, test, and operate secure applications. Next, let's dig into what's new in 4.0. DSS 4.0 is a huge update to the Data Security Standard. As you can see, the requirements doc itself grew by over 2.5X to 360 pages. The PCI Security Standards Council has outlined four primary goals for the new 4.0 standard, starting with, of course continuing to meet the security standards and security needs of the payment industry. Promoting the concept of security being a continuous process, not a one time or periodic assessment. Adding flexibility for different methodologies and recognizing that not all organizations do things the same way. So DSS 4.0 provides some options for compliance and certain requirements. And finally to enhance validation methods. Being more explicit about what compliance looks like and how to assess it. Now what's especially noteworthy with respect to APIs is that in 3.0 there was no mention of APIs. And APIs appear in multiple sections throughout Requirement 6 of the DSS 4.0. And even where APIs aren't explicitly mentioned they still are very relevant. And one way to think about this is if your APIs are in scope for your attackers, then they ought to be in scope for your security programs too. Let's look at what the compliance timeline looks like for 4.0 real quick. The 4.0 standard was published in Q1 and Q2 of 2022 and as of Q2 2022, organizations could begin certifying against the 4.0 standard. That's the beginning of the transition period that you see here in the timeline. The deadline for 4.0 compliance is March 31, 2024. Meaning all organizations must comply with the DSS 4.0 requirements by the end of Q1 ' 24. There are a few requirements that the DSS has provided a longer compliance period. Those are all required by March 31, 2025. I'll flag those where relevant in the coming slides. And if you want to learn more about any of this, here are a few useful resources. I've shared the links in the course materials. This brings us to the core of this course, reviewing the specific requirements in DSS 4.0 and what they mean for APIs. We'll be reviewing about a dozen sections in the Data Security Standard, mostly from Requirement 6, and examining in detail what is being required and how to achieve it. In each case, I'll show you the actual text from the DSS document itself, discuss how this requirement applies to APIs, and provide best practices to comply and keep your APIs secure. So let's get started. Starting with 2.2.7, which states " all non console administrative access is encrypted using strong cryptography." I bring this one up as this requirement explicitly mentions APIs. In fact, it's the first time the Data Security Standard has flagged API specifically. In this case, the requirement highlights that encrypted admin console access is required, not just for browser based UIs, but also for application programming interfaces or APIs. So it's a pretty straightforward requirement, and of course, all our application communication should be done over encrypted channels. Now we'll get into the core of DSS 4.0, which is Requirement 6, "Developing and Maintaining Secure Systems and Software." Here you see a number of sub requirements, which we'll get into, but one term you'll see throughout Requirement 6 is " Bespoke and Custom Software." This refers to any custom code developed by your organization or provided to you by another party, and this is subject to these DSS requirements, specifically if that software stores, processes, or transmits account data, or it could impact the security of account data. This definition encompasses APIs. So if your bespoke and custom software incorporates APIs, those are in scope. So as we review the requirements throughout DSS 4.0, if it applies to your custom developed applications. it applies to those APIs as well. Now, here at the bottom, PCI has provided guidance that for custom software, "numerous vulnerabilities can be avoided by applying software lifecycle processes and secure coding techniques." Organizations should strive to create a culture of security across the application development team, understanding application risks, writing more secure code, testing for vulnerabilities, and fixing ahead of production. Moving ahead to section 6.2.1, " Bespoke and Custom Software are developed securely as follows based on industry standards or best practices for secure development, in accordance with the PCI DSS, and incorporating consideration of information security issues during each stage of the software development lifecycle." That's the requirement of 6.2.1. Further, The DSS standard instructs organizations to "understand how sensitive data is handled by the application to inform how to protect the data." The implication for APIs here is pretty clear. PCI wants organizations to bakein security as early as possible in the creation of custom code, or "shift left" security as you may have heard it. Stating that "DSS requirements must be considered when developing software by design rather than trying to retrofit the software later." To achieve this requirement, organizations need to ensure application developers are aware of the API security risks and can create and test code to mitigate those risks. Where 6.2.1 calls for organizations to utilize industry best practices for secure application development, 6.2.2 goes a step further and mandates training for developers. It states, " Software development personnel working on bespoke and custom software must be trained at least every 12 months. And that training needs to be 1. Relevant to their job function and development languages. 2. Include secure software design and coding techniques. And 3. Train on the use of security testing tools for detecting vulnerabilities in software." As organizations develop applications with APIs, engineering teams must be trained on API related risks as well as best practices for avoiding API exposures and vulnerabilities. Organizations should arm development teams with APIfocused security training, such as what we provide on APIsec University. The standard also points to a need for vulnerability detection and testing custom software. For APIs, organizations need to begin or expand their security testing. And as we saw earlier, Only 4% of all API testing is focused on security. New API security testing tools do exist that will automate API testing and give you continuous assessment. Organizations can't rely solely on manual testing or once or twice a year pen testing. And finally. Development teams need to be trained on these tools and how to use them to find vulnerabilities before they ever get to production. I'd like to point out that APIsec University makes our courses compatible with internal Learning Management Systems. So if you'd like to provide our courses to your colleagues and employees within your LMS, we can help. Feel free to get in touch. Section 6.2.3 continues the theme of looking for and addressing vulnerabilities in code. " Bespoken custom software must be reviewed prior to being released into production or to customers to identify correct potential coding vulnerabilities." These code reviews need to look for new and emerging vulnerabilities. And traditionally, new and emerging vulnerabilities refers to things like zerodays or other newly discovered vulnerabilities. These vulnerabilities are most likely to be related to third party libraries and APIs that you use in your applications. So make sure to keep updated on any vulnerability reports. A critical best practice, though, when using third party APIs is to trust nothing. Your application should not assume that the data coming back from external providers is legitimate. Check all responses to make sure that it fits with what you're expecting. For example, if your app uses a third party API to normalize, say, physical addresses, make sure you don't accept responses that could be malicious, like URLs, or strings with slashes, or anything that doesn't look like an address. And the final item in the Good Practice section is especially relevant. "Checking for logical vulnerabilities." This is perhaps the most dangerous type of flaw in applications. If there is a logic flaw in your app, that flaw will get exposed via the API, allowing an attacker to exploit it. Your custom software must be analyzed and tested to find these logic flaws. This section of Requirement 6 is one of the most substantial in terms of testing for vulnerabilities, and I like to think of 6.2.4 as the OWASP section of Requirement 6. It mandates the use of "software engineering techniques to prevent or mitigate common software attacks and vulnerabilities in bespoke and custom software." So this section details a whole lot of attack vectors that need to be considered. Things like injections, authentication exploits, bypassing authorization, cross site scripting, cross site request forgery, security misconfiguration, and more. All of these covered by the OWASP Top 10. It also explicitly flags APIs as an interface that must be considered when addressing these risks. Your testing programs must include APIs, not just the web and mobile app interfaces. 6.2.4 also reinforces the concept of business logic attacks that we just learned about in the prior section and the need to examine your own application functionality and consider not only how your apps are meant to be used, but critically, how your apps might be abused. For example, and here's a real world example, there was an attacker who exploited an API on a crypto trading platform to sell his Ethereum stock as Bitcoin. The API allowed a user to overwrite what asset they were trading and sell it as something else. A great example of a logic flaw. Web scanners and pen testers regularly test UIs for injection vulnerabilities, and that must be expanded to include testing at the API layer. In the last callout box here, you'll see developers should be familiar with different types of vulnerabilities and potential attacks, and use measures to avoid potential attack vectors when developing code. The need for security training for developers repeats throughout Requirement 6. Again, the API Security Fundamentals course offers great training for developers and others who need to understand API risks. 6.3.1 covers Vulnerability Management and sets the requirements for how organizations need to operate a VM program. To start, security teams need to have access to vulnerability information. There are plenty of vulnerability databases. And the industry standard source for vulnerabilities is the CVE database hosted by MITRE. You can find it at cve.mitre.org. CVE stands for Common Vulnerabilities and Exposures. And pretty much every reported vulnerability gets documented here and is issued a CVE ID number. But what you'll find here, as the name states, are common vulnerabilities. I. e., vulnerabilities in third party code, apps, and libraries that you use. But notice the statement here at the bottom to specifically look for vulnerabilities in custom code and bespoke software. And here, the DSS adds more detail about where to find vulnerabilities in your third party software. And all of this so far really focuses on the third party. But here in the last callout box, you'll see DSS showing concern for your proprietary application logic. And this is a really critical element. DSS states, "for control over in house developed software, the organization may receive such information from external sources." And then they highlight bug bounty programs, independent investigators, and more. Now, this requirement has big implications for your APIs. First, you need to secure the third party APIs that your applications consume. That means keeping up to date on versions, patching that's required, monitoring for new vulnerabilities. And second, you need to look at your internally generated code, including anything that's exposed by APIs to find vulnerabilities or logic flaws, authorization gaps or anything else that can be exploited. And you're not going to find this in any CVE database or Patch Tuesday alert or anything else. Flaws in your code are your own personal zerodays. And these vulnerabilities are the types of vulnerabilities attackers most want to find. The traditional and common vulnerabilities, things like injections and cross site scripting, are rarely the cause of major API breaches. Your APIs expose your application logic, the good and the bad, and any flaws in your application logic will also get exposed. So it's critical to, 1. keep up to date on the latest API attack techniques, and 2. perform security testing on your applications regularly. That means not once or twice a year, but with every release. And make sure that testing covers your APIs and is providing adequate coverage. That means testing every endpoint across dozens of attack vectors, including logic and authorization tests. Now, this probably sounds a bit daunting, and the only way to achieve this level of continuous assessment is with automation. There are API optimized testing tools out there to help. 6.3.2 focuses on having an up to date, complete, and accurate software inventory, specifically your bespoke and custom software, as well as any third party code you're using in your custom applications. The stated goal of this inventory is to "facilitate vulnerability and patch management." And here in the Purpose section, the DSS explicitly calls out third party libraries and APIs. These need to be known, tracked, and managed to address any vulnerabilities that they might have. Actually, having an accurate inventory of your software and APIs isn't just good for security, it's critical to your overall application governance. I've met with many security teams who claim they have little awareness of all the APIs running in their organization, and this is undoubtedly true. But the fact that security teams don't have this information doesn't mean it doesn't exist. So security teams have to partner with Engineering to deal with these API security concerns. The reason why is APIs are fundamentally gateways to your application functionality. And most vulnerabilities will need to get addressed inside the app code in collaboration with the engineering team. We've got whole courses dedicated to API governance, but that's really where security needs to start. Governance means knowing what APIs you have, but also what function they provide, who has access to them, how they need to be secured, things like authentication, access controls, input validation, etc. And governance also means setting standards for how your APIs are documented, what policies you have for handling sensitive data, when you need new versions, what happens to the old versions. And governance also means APIs get deployed into production in a standard way where every release goes through, not just functional testing, but security testing too. And all APIs get managed in a common platform, like an API gateway. This gives your organization, not just great consistency and operational efficiency, but also enables security. What APIs you have, how they're being used, and they have to clear the necessary gates to get into production. For this requirement, organizations have until March 31, 2025, one year later than most of the DSS 4.0. And that's likely a reflection of the challenges organizations have in even producing an accurate inventory. Until then, DSS calls this a best practice, which I couldn't agree more with. Definitely invest the effort to produce an inventory. But if you're going to do this, then make the most out of it. Use this as a driver for better overall security in your organization and better governance across the entire API lifecycle. Look at your API program from design to coding to testing to deployment to really reap the benefits of better governance. We're next going to cover 6.4.1 and 6.4.2 together, and you'll see why in a second. This requirement addresses the need to actively protect public facing web applications against attacks. The purpose, of course, is to make sure applications are resilient against attacks, as web applications are going to be the primary target for those attacks. As DSS states, "poorly coded web applications provide an easy path for attackers to gain access to sensitive data and systems." But pay attention to that term web application. Many will interpret that as referring to their web, and maybe mobile, user interfaces. When we think of an application, we tend to picture something you can look at and interact with. But this is not the full scope of your application. You have to look at any interface, human or machine, that can exercise your application. And that includes APIs. So the choices DSS provides here are to either perform a vulnerability assessment or implement some kind of inline automated protection solution. If you go with the vulnerability assessment route, the requirement is to perform the scan every 12 months or after any major change to your application. The assessment must be performed by an organization that specializes in application security. It has to cover all the threats that we talked about in 6.2.4. You have to rank all the vulnerabilities you find and correct them, as specified in 6.3.1, and then retest your apps to make sure the vulnerabilities are remedied. Now for the automated protection approach, this has to be installed in front of your web app, running continuously to find and block any attacks. And it must produce audit logs that can be analyzed later as needed. The most common example of an automated protection solution is a WAF, a Web Application Firewall. These are widely used to analyze application layer traffic and block against known threats like injections, high volume attacks, cross site scripting, etc. An API gateway will also provide protection and can perform things like API input validation, user authentication, access controls, rate limiting, IP and geographic whitelisting and more. There are API specific runtime protection solutions as well that act like WAFs for APIs. In terms of timing, 6.4.1 gives organizations a choice of approaches, but you have to comply with one or the other by March 31, 2024. Now, under 6.4.2, that option goes away, and you must deploy an automated approach, or an automated technical solution, and that is due by March 31, 2025. Now, although runtime detection and blocking of active threats is very appealing, the reality is certain attacks are nearly impossible to detect in real time, as signature based blocking and anomaly detection aren't able to identify every attack. Some of the most damaging API attacks we've seen exploit unique application logic where unintended flaws exist. In the example I gave earlier with the crypto trading platform, the user exploited a flaw in the API where they could change their asset from one type to another. This would be virtually impossible to detect in any automated way. So really the best practice here is both. To do both automated blocking where possible, and to complement that with comprehensive testing to uncover flaws before attackers find them. Section 7 of the DSS focuses on access controls to critical data and systems. I just want to touch on this section in general and highlight a few requirements and best practices. The purpose of this whole Requirement 7 boils down to who has access to applications and systems and what can they do. Of course, this applies to the underlying infrastructure that supports your applications. The servers, containers, databases, network devices. You have to make sure access is secure and controlled internally. At the application layer, though, you have to think about all the functionality, the data accessibility, the business flows, and your user types. For example, a regular user should be able to access their account balance. They should not be able to see any other user's data. But maybe you have support personnel who need to be able to access any user's information. Or take that end user accessing their balance. They should be able to see their balance, but not modify it. So what this means is, you need to build a matrix of all functionality available through your APIs, and map that across all of your user types, whether that's an end user, support person, QA engineer, developer, admin, etc. And even map that across your different environments, development, testing, staging, production. It's not enough to do this analysis at the UI level. As we've seen before, while UIs provide the ability to control user behavior, filter data, and manage what they can do, when you take the UI out of the equation, you're left with individual API endpoints. So make sure you're analyzing access controls at the API level. Now let's talk for a second about authentication versus authorization. You definitely want to set up policies around API endpoint authentication and define those policies in an API Style Guide that all your developers can use. For example, if an endpoint is purely informational, has no user data, for example, an endpoint that checks where the nearest bank branch is, then maybe you don't need any authentication on that endpoint. But another endpoint could let a user check their account balance. So you'll want to authenticate them. And maybe even higher security for performing a transfer, like putting in a two factor challenge. That's all about confirming that the user is who they say they are. And this can be managed at the API layer. And the best practice is to centralize all that access in an API gateway. But authentication is not the same as authorization, and we've seen many breaches where an organization implemented user authentication but failed to address authorization. Let's use another example. There's a popular exercise equipment vendor that provides an API that has access to all users in the platform. Although the API required users to authenticate properly to access the endpoints, it did not control which records they could see. So once authenticated, the user could see not only their own records, they could see anyone else's as well. This is more common than you might imagine. The point is authorization needs to be considered and defined and then implemented within the application logic itself, not at a gateway or other access point. Lastly, once you've got your access controls defined and implemented properly. You want to make sure nothing changes. And if something does, you know about it. Here's where we recommend RBAC monitoring, i. e. continuous testing of Role Based Access Controls, to see if any settings get adjusted so you can be aware and ensure no control gaps emerge. Here's another section I'll cover at a high level. 10.0, "Log and Monitor All Access to System Components and Cardholder Data." This section spells out in detail all the requirements for collecting logs, storing the data in a central repository, and analyzing the activity records for security and incident response purposes. As the DSS states, "logs allow thorough tracking, alerting, and analysis when something does go wrong. Determining the cause of a compromise is difficult, if not impossible, without system activity logs." Now typically logging is enabled and captured at the system level, i. e. all the servers, databases, network devices, firewalls, and more. But logging must also be captured at the application level. Here's where you'll see the details of user behavior and be able to find anomalous activity. To get this level of granularity, your application must first be instrumented to produce the logs in the first place. Make sure your developers add logging events into their code that captures all the relevant details. Who's performing the action? What are they doing? When did it occur? From what source or IP address? Was the action successful? Another great source of application level logging is at the API Gateway. These platforms will natively record all accesses to APIs and individual endpoints. Finally, be sure to centralize all this data in a common repository where your security team can analyze and detect threats as they happen. And the last section I want to cover in PCI DSS 4.0 is Requirement 11. "Test security of systems and networks regularly." Throughout this course, and across many of the DSS 4.0 sections, we've talked about how important testing is. Many of the DSS requirements specify security objectives, with the need to test to confirm programs are running as designed, to ensure vulnerabilities aren't appearing, and access controls are set properly. Section 11.0 formalizes this need to test for security regularly, and DSS recognizes that "vulnerabilities are being discovered continually by malicious individuals and researchers, and being introduced by new software. System components, processes, and bespoke and custom software should be tested frequently to ensure security controls continue to reflect a changing environment." As you can see, this requirement specifically refers to bespoke and custom software and the vulnerabilities that your code can create. It also mandates organizations test applications frequently to ensure no vulnerabilities go undiscovered. As we've discussed throughout this course, application testing cannot be limited to UI alone. Public facing applications rely on public facing APIs, and these are ripe targets for attackers. So your testing programs must include APIs and should be automated to ensure complete coverage of every API endpoint, simulate attacks across all of the OWASP Top 10 categories and more. And run in a continuous manner, recognizing that modern organizations update code monthly, weekly, and even daily. So make sure your testing keeps up. Okay, we've covered a lot of ground here and have examined how organizations need to address API security concerns to stay compliant with PCI DSS 4.0. So let's bring it all together and summarize what the requirements are, some of the best practices for not only complying with the standard, but in elevating your organization's security posture. And we'll wrap it up with a list of do's and don'ts. First, let's summarize the various sections of DSS 4.0 and what they mean for APIs. Starting with 2.2.7, this requires secure access to admin consoles, including encryption of all communications. Make sure you're looking at API access to consoles as well, and not only encrypting the communication, but controlling access to those endpoints. 6.0 is the core of DSS 4.0 with respect to securing payment related applications. We spent a lot of time looking at many different subsections of Requirement 6. The key to remember here is that with DSS 4.0, APIs are 100% in scope now. All your bespoke and custom software, the code you write to power your organization's unique offerings, is powered by APIs. And those APIs need to be secured as much, or even more than your classic web and mobile applications. The subsections in requirement 6 get more specific about securing your custom applications. 6.2.1 focuses on secure software development, and requires engineers to be aware of API security and vulnerability risks. to ensure code is free of flaws that can be exploited. DSS recommends integrating as far left as possible to find vulnerabilities before they reach production. 6.2.2 sets requirements for annual training of developers. APIs have unique attack patterns, so it's critical that your developers understand what these look like and how to create more secure applications. 6.2.3 requires organizations to review and test code for security flaws. Here, DSS highlights how attackers are targeting your custom code via the APIs, and looking to find and exploit logic vulnerabilities. 6.2.4 covers a wide range of well known application attack types and mirrors closely the threats listed in the OWASP application and API security top 10 lists. This section rightly calls out API specifically and highlights attacks on business logic and manipulation of APIs. The point being, your vulnerability discovery efforts need to cover APIs, not just UIs. 6.3.1 calls on organizations to implement vulnerability management programs. It's important to focus on the vulnerabilities that are likely to cause the most damage. And while injections and cross site scripting are legitimate vulnerabilities, and you absolutely need to test and fix these flaws, these rarely are the cause of major breaches. What we see regularly are logic flaws, weak authentication, and authorization gaps. These are the vulnerabilities you need to test for, especially at the API level. 6.3.2 requires organizations to develop and maintain an accurate and up to date inventory of all custom software. This must include your APIs. Having that accurate inventory is really part of a solid application governance program where you standardize how APIs get created, set security policies that are implemented consistently and all APIs get tested and deployed in a common way. 6.4.1 gives organizations an option to perform either periodic vulnerability assessments or implement runtime attack detection and blocking. The option goes away in 2025 when all PCI covered entities must enforce active detection and blocking. Just be aware that not all threats can be detected in real time. There's no magic firewall that will protect against all threats, and in fact, frequently the most damaging exploits aren't detectable. So you need to keep up testing and detection of vulnerabilities, and then fix this in the code. 7.0 requires strong access controls. Here you need to examine the entire infrastructure and application stack and look at what users can access and what they can see. It's important to review these controls down to the individual API endpoint level to make sure there aren't any access gaps. And definitely implement continuous testing to uncover and alert on any changes in access permissions. 10.0 requires organizations to capture logs from all systems involved in payment processing. This is critical to detect threats and perform root cause analysis. Make sure you're capturing user activity logs on APIs as well, and this is best accomplished with an API gateway. And 11.0 calls on organizations to perform regular testing of their custom software. So make sure that includes all of your APIs as well. All right, as we wrap up this course, let's touch on some of the core best practices, not just to comply with PCI, but to run a more efficient and effective API security program. We'll start with governance. API security is not really something you can bolt on. You want to integrate security into the entire application lifecycle, from design, to product, to retirement, creating a culture of security throughout your organization. This starts with putting time and effort into defining your API policies, how your APIs get used, who can use them, what they can do, then defining your standards, what APIs should look like, how do they get created. And then standardizing your processes. How do APIs move from development through QA and into production in a consistent manner. It's highly recommended that you centralize all your APIs in a common platform, something like an API gateway or a marketplace. This will let you manage APIs consistently, define common policies, and give you a central source for auditing and logging user behavior. And make sure all your APIs only go into production having passed the required gates, including documentation, testing, security audit, and so forth. Our next best practice focuses on how to create a culture of security within the engineering and development organizations. We've hosted many roundtables with cybersecurity leaders and noticed a common theme. The CISOs uniformly agreed on the need to integrate security into the development team. And one of the best ways to create that security awareness was to embed security champions right into those teams. As we've discussed, especially with applications and APIs, development shares the responsibility for security, as most vulnerabilities will require dev involvement to remediate. Security champions are security savvy personnel who can work and operate directly within the development organization, providing insights, best practices, answering questions, and so forth. Number three on our best practices list is actually straight out of the DSS document providing API security training to all relevant employees. And this should include any developers creating APIs, any API product owners, and ops teams. As we've seen, APIs face new and different types of attacks, so make sure the training covers API specific threats, the OWASP API Security Top 10, and best practices for keeping APIs secure. We've got a great course at APIsec University called API Security Fundamentals. It covers everything I just mentioned and can even be deployed in an internal Learning Management System. And our last best practice here focuses on testing. APIs expose so much application functionality, and it's more critical than ever to really pressure test that functionality to make sure your apps can't be abused. This means testing every single API endpoint across all kinds of attack types, everything you see in the OWASP Top 10, and examine your app logic to look for any flaws or gaps that can be exploited. And you need to do this with automation. Implement a testing program that will run automatically, create the test coverage you need, and run against every release to find vulnerabilities before they get to production. I'd like to wrap up my courses with some really tactical do's and don'ts that you can take back and implement right away. As we've mentioned a number of times, DO educate your development team and API owners on API risks. They're under attack, and the threats are different than what our web apps have seen. DO integrate security into the dev process. Make sure engineers understand how to code more resilient APIs and test for vulnerabilities ahead of production. DO build communication between security and development. The gap here is way too big, way too often. Both teams need to collaborate to keep APIs secure. DO mandate documentation on all APIs. This feels like one that shouldn't be needed, but far too many APIs are not documented. Under documented or not updated. Documentation helps drive consistency, reusability, integrations, and also security. DON'T treat internal APIs as inherently secure. They may be harder to find, but attackers are pretty clever, and we've seen many internal APIs get accessed in unexpected ways. DO centralize API management and control in something like a gateway. Many organizations end up using multiple gateways, which is fine. Just use some platform to manage all your APIs in a consistent way. DON'T rely exclusively on manual security testing. A once or twice a year penetration test will not keep up with the pace of your code changes. And it won't give you the breadth of coverage considering how many endpoints you have and the attack types you need to simulate. Which leads to our next item, DO automate testing. Integrate your testing with your CI/CD pipeline. Make sure every release gets tested before they go live. DON'T filter data in the UI. This is one I can't stress enough. If your app returns all the fields of a record, and you rely on the UI to filter out the sensitive stuff, then all an attacker needs to do is go around the UI and call the API directly and get the raw, unfiltered data. DO take time to carefully define API standards. This falls under the governance umbrella. It's really important to have a well defined, thought out set of API standards and policies. This will aid your entire API lifecycle, including security and compliance. DO pressure test your APIs for logic flaws. These are nearly impossible to detect in real time, so make sure you test your APIs in ways they're not meant to be used to find these flaws. DO use runtime protection to block well known attacks. This is mandated in PCI and is a best practice. So use a web application firewall or other device to block volumetric attacks, injections, and others. But DON'T expect the firewall to prevent all threats. Some are going to get through, so make sure you're finding those vulnerabilities. especially logic vulnerabilities through testing before production. And finally, DO train your API teams on the OWASP API Security Top 10. This is the industry standard on API risks for a good reason, and you definitely want your developers to understand the threats. That wraps up the API Security for PCI Compliance course. Congratulations on making it all the way through. I hope you enjoyed the course. We'll be sending you a certificate of completion and badge to recognize your accomplishment. I really appreciate you taking the time for this course, and I invite you to check out our other courses at apisecuniversity.com. I'd love to hear from you if you've got any feedback, suggestions, or just want to connect for any other reason. You can find me on LinkedIn and you're welcome to email me directly. Thanks again and I hope to see you in another course soon. Okay, that wraps up the API Security for PCI Compliance course. Hope you enjoyed it. If you'd like to earn a badge and certificate for this course, please enroll at apisecuniversity.com, take the quizzes, and we'll be happy to issue your cert. While you're there, be sure to check out our other courses, including API Pentesting, API Security Fundamentals, and more. We also host many webinars with API experts across industries, disciplines, and geographies. You'll see these listed on our website and on our YouTube channel. Please subscribe. Thanks for watching, and hope to see you again soon.
