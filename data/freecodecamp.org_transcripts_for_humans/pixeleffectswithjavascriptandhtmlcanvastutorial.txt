With timestamps:

00:00 - today i want to show you something you
00:02 - might not have seen before in this
00:04 - course we will use html5 canvas element
00:07 - and plain vanilla javascript to create
00:09 - interactive animated particle effects we
00:12 - will start with a very simple project
00:14 - where we learn about the draw image and
00:16 - get image data built in canvas methods
00:19 - and how to use them to create a pixel
00:21 - array then we take it to the next level
00:24 - and use that pixel array data to make
00:26 - our particles do amazing things let me
00:28 - show you the real power of html canvas
00:30 - using just basic fundamental javascript
00:33 - tools and techniques if you get stuck or
00:35 - you need some help with the code we are
00:36 - about to write you can message me on
00:38 - twitter or catch me somewhere on my
00:40 - youtube channel special thanks to bo
00:42 - from freecodecamp for letting me share
00:44 - this course with you i hope you get some
00:45 - value out of this let me take you
00:47 - through the code step by step and
00:49 - explain how to use html canvas to create
00:52 - beautiful things
00:54 - [Music]
00:59 - in index.html i create html canvas
01:02 - element with an id of canvas 1.
01:04 - i link style css and script.js files
01:11 - in style css i target the body element
01:14 - and give it black background
01:17 - canvas will have border solid white
01:20 - top 50
01:22 - left 50
01:25 - position absolute
01:27 - width 800 pixels and height 450 pixels
01:31 - transform translate minus 50 to minus 50
01:35 - will center our absolutely positioned
01:37 - canvas element both vertically and
01:40 - horizontally
01:44 - in script js the usual basic canvas
01:46 - setup constant variable i call canvas is
01:49 - equal to document.getelementbyid
01:52 - and i pass it id i gave it in index html
01:55 - which was canvas one
01:57 - constant ctx shortcut for context equals
02:00 - canvas variable from line 1 dot get
02:03 - context 2d
02:04 - this way i make my ctx variable an
02:07 - instance of canvas 2d api object and i
02:10 - can call all built-in canvas methods on
02:12 - this variable now such as ctx fill
02:15 - rectangle to draw a rectangle
02:17 - and so on
02:20 - canvas width will be 800 and canvas
02:22 - height will be 450. these values need to
02:26 - be the same as values we set for canvas
02:28 - in css file to make sure we get the
02:30 - correct scaling i will bring an image
02:32 - with dimensions of 800 times 450 pixels
02:36 - to my project first i create a custom
02:38 - variable i call for example image 1 and
02:41 - i set it equal to new image
02:43 - new is a special keyword in javascript
02:45 - and image with capital i is a special
02:48 - built-in class constructor doing this
02:50 - will just create a new blank object and
02:53 - assign it values and properties based on
02:55 - built-in javascript image blueprint
02:57 - simply said we just created blank new
02:59 - image object that comes with src
03:02 - property if you consulate image 1 you
03:04 - will see it
03:05 - i set this src source property to path
03:08 - to my own image like this image 1 src
03:12 - equals image1png
03:14 - for you the path might be different
03:16 - remember that the path must be relative
03:18 - to wherever you placed your script.js
03:20 - file inside your project structure for
03:22 - javascript to be able to see your image
03:25 - now i will try to draw the image by
03:27 - using built-in draw image method if i
03:30 - just give it three arguments like this
03:31 - the first one is the image i want to
03:34 - draw so my image one variable from line
03:36 - six
03:38 - the second argument is the x coordinate
03:40 - and the third one is vertical y
03:42 - coordinate where i want to draw it on
03:45 - canvas
03:46 - i want the image to start from
03:47 - coordinates 0 0 which is the top left
03:50 - corner the reason the canvas is still
03:52 - blank and no image has been drawn is
03:54 - because javascript code runs very fast
03:56 - even though the image loads relatively
03:58 - fast as well it is not yet loaded when
04:01 - draw image method runs i have to take
04:03 - variable image 1 from line 6 and since i
04:06 - gave it src attribute on line 7 i can
04:09 - give it event listener for load event
04:12 - image 1 add event listener
04:14 - and when a load event occurs which means
04:17 - after the image has been fully loaded
04:19 - only then run the following code i
04:21 - placed inside the callback function if i
04:24 - put the draw image method inside this
04:26 - callback function the image will be
04:28 - drawn
04:29 - so this was the first issue we face when
04:31 - handling images on canvas solved
04:34 - draw image built-in method has three
04:36 - versions depending on how many arguments
04:38 - we pass to it
04:40 - we use the shortest one here with only
04:41 - three arguments we can also pass it five
04:44 - arguments where the fourth and the fifth
04:46 - one stand for width and height of the
04:48 - image my image is exactly the same size
04:51 - as my canvas so i don't need it but if
04:53 - your image is a different size you can
04:54 - give it different width and height doing
04:56 - that you can scale your image however
04:58 - you want by passing it different values
05:00 - here the third version of draw image
05:02 - method takes nine arguments and we can
05:04 - use it to crop out pieces of a sprite
05:06 - sheet for example like we did in my game
05:09 - development series to create animated
05:11 - characters
05:13 - we will not do that today
05:15 - i want to know colors of each individual
05:17 - pixel that makes up this image html
05:20 - canvas provides us with a built-in
05:22 - method that can do just that
05:24 - i create a constant variable called
05:26 - scannedimage and i set it equal to
05:28 - ctx.getimagedata
05:31 - this method takes four arguments which
05:33 - define what area of canvas i want to
05:36 - scan for pixel information i want to
05:38 - scan the entire canvas so i pass it 0 0
05:41 - for starting coordinates and canvas
05:43 - width and canvas height for the end
05:45 - coordinates
05:46 - this method scans all pixels on canvas
05:49 - it goes from left to right row by row
05:52 - from top to bottom
05:53 - the order is important if you want to
05:55 - determine coordinates for each pixel it
05:57 - scans all pixels and it returns image
06:00 - data object
06:01 - if i console lock my scanned image
06:03 - variable we can see that object here
06:06 - let's open it and we can see it contains
06:08 - something called data which is an array
06:11 - we also have height and width properties
06:13 - which correspond with the size of an
06:14 - area i scanned with the get image data
06:17 - method and it also has some prototype
06:19 - methods which are not important now
06:22 - if i open data we can see it's a massive
06:25 - array but it's not a regular javascript
06:27 - array i can see it is called something
06:30 - like uint8 clamped array and it contains
06:33 - one million four hundred and forty
06:35 - thousand elements uint eight clamped
06:38 - array is a special type of array it is
06:40 - very simple basically each of its
06:42 - elements has to be a number from a
06:44 - certain range it can only contain
06:46 - numbers between 0 and 255
06:49 - if you used css before you remember rgb
06:52 - color declaration and you will know that
06:54 - any color can be declared by combining
06:56 - three numbers between 0 and 255 and
07:00 - that's what this is we are basically
07:01 - looking at color values uh numbers that
07:05 - make up colors of each individual pixel
07:08 - but it is a bit strange because each
07:10 - element in the array contains only one
07:12 - number and we actually need four numbers
07:14 - red green and blue and alpha for opacity
07:17 - the way this array is structured is that
07:19 - each pixel is spread into four elements
07:22 - so the first four elements in the array
07:24 - combined are rgba color value for the
07:27 - first pixel the next four values are
07:29 - rgba for the second pixel and so on i
07:32 - can see that this array has one million
07:34 - four hundred and forty thousand elements
07:37 - now that we know that four elements make
07:39 - one pixel i also know that my image is
07:42 - made out of one million four hundred and
07:44 - forty thousand divided by four which is
07:46 - three hundred and sixty thousand pixels
07:52 - it makes complete sense because my image
07:54 - is eight hundred times four hundred and
07:56 - fifty pixels in width and height
07:58 - and 800 times 450 is also 360 thousand
08:03 - these pixels are organized in rows from
08:05 - left to right starting at the top left
08:07 - corner so the first pixel is 1 70 139
08:12 - 1 is right 70 is green 139 is blue so
08:15 - that's rgb and alpha of this pixel is
08:18 - 247
08:20 - alpha or opacity in this array is also
08:23 - declared in a range between 0 which is
08:25 - invisible to 255 which is fully visible
08:29 - that's one thing that's different from
08:30 - the standard rgba color declaration we
08:33 - use in css where alpha is a number
08:35 - between 0 and 1.
08:37 - i was able to scan my image with no
08:39 - issues but in some browsers due to
08:41 - cross-origin resource sharing security
08:44 - you will get an error that says
08:45 - something like canvas has been tainted
08:48 - by cross-origin content and we cannot
08:50 - scan it for image data i don't really
08:52 - know if people can actually put viruses
08:54 - in images or something chrome for
08:56 - example considers your locally stored
08:58 - images as cross-origin unless you run
09:00 - this code through a server
09:03 - if you ever experience this problem when
09:04 - scanning image data with a get image
09:06 - data method for your creative coding
09:08 - projects instead of trying to navigate
09:10 - through server settings and so on there
09:12 - is an easy work around you can actually
09:15 - convert any image into data string and
09:17 - place that string directly into your
09:19 - file this will avoid all cross-origin
09:21 - resource sharing issues
09:23 - we can convert an image into data string
09:26 - using two data url built in javascript
09:29 - method just by calling it on the image
09:32 - but today i will just do it using this
09:34 - quick free online tool if you google png
09:37 - to base64 this will also work on jpeg
09:40 - images and other types by the way not
09:42 - just pngs
09:44 - i go to this address onlinepngtools.com
09:48 - convert png to base64
09:51 - you can just drag and drop your image
09:52 - here it doesn't have to be in png format
09:56 - on the right hand side it will generate
09:58 - base64 string that contains all data we
10:01 - need to draw this image with javascript
10:03 - without needing the actual image file
10:06 - if your string doesn't start with data
10:08 - colon image like mine does make sure you
10:11 - tick this checkbox down here that says
10:13 - create a valid data image url
10:18 - so i just copy this huge long string in
10:21 - script js on line 7 instead of using the
10:24 - image file as a source
10:28 - if you ever get tainted canvas error in
10:30 - console just replace the path to the
10:32 - image with this long data string
10:34 - and it will fix everything
10:41 - it will give me exactly the same image
10:42 - like this you can see in the console
10:45 - that it contains identical image data
10:47 - and everything it is the same image
10:49 - so as i said this data array i see in
10:52 - console when i console log my scan image
10:54 - variable contains all pixel that make up
10:57 - my image the image was scanned from top
10:59 - left corner going left to right
11:01 - row by row and every set of four
11:03 - elements in this array contains rgba
11:06 - values for one pixel this is all i need
11:09 - to manipulate colors in my image i can
11:11 - save that pixel array in a separate
11:13 - variable if i want
11:15 - let's call it scanned data and it's
11:17 - equal to scanned image from line 12 dot
11:20 - data which is the uint8 cloud array we
11:23 - see in the console
11:29 - i can for example create a for loop that
11:31 - will cycle through the entire array
11:39 - notice i don't do i plus plus at the end
11:41 - but i do i plus equals 4 because i know
11:44 - each time we skip by 4 we have new pixel
11:47 - so first i will be 0 because arrays
11:50 - start from 0 not from 1 then the second
11:52 - will be 4 then 8 and so on
11:55 - let's make our image grayscale
11:57 - there is one strange thing going on with
11:59 - colors
12:00 - we know that any color is a combination
12:02 - of certain amount of red green and blue
12:04 - i'm not sure if you knew but if you take
12:06 - any value between 0 and 255
12:10 - and assign the same value as red green
12:12 - and blue like this
12:14 - you will get a shade of gray from dark
12:16 - to very light
12:17 - this is not a canvas thing this is how
12:19 - rgb colors work in general
12:21 - so what i can do is take color value for
12:24 - each pixel calculate average and assign
12:27 - the same average value as red green and
12:29 - blue on that same pixel turning it to
12:32 - grayscale
12:33 - i create a constant variable called
12:35 - total which will be a sum of values for
12:37 - red green and blue we are jumping
12:40 - through the array four pixels at a time
12:42 - so scanned data i is always the red
12:45 - pixel value
12:50 - scanned data i plus 1 is always the
12:52 - green pixel
12:56 - and scanned data i plus 2 is always blue
13:00 - then there will be alpha and then we
13:01 - have another red and so on
13:04 - average color value is simply total sum
13:06 - divided by three because we achieved
13:08 - that sum by adding three numbers
13:11 - now i have the average color value and i
13:13 - need to assign that same value to all
13:15 - three colors in this pixel to turn it
13:18 - into grayscale so scanned data i red
13:21 - pixel is equal to average color value
13:23 - variable from line 17
13:25 - scanned data i plus 1 green pixel is
13:27 - gonna be the same average color value
13:30 - and also blue pixel scanned data i plus
13:32 - 2 is equal to average color value
13:36 - now i reassigned color values in my
13:38 - scanned data array i declared on line 14
13:41 - and i want to use it and override data
13:44 - array on the image so scanned image
13:46 - variable dot data
13:49 - i set its built-in data array to my
13:51 - altered array with grayscale colors
14:02 - now i use built input image data method
14:05 - which simply paints data from the given
14:07 - image data object onto the canvas i pass
14:10 - it my altered scanned image and i want
14:13 - it to be drawn from coordinates 0 0
14:16 - we can also manipulate individual color
14:18 - levels like this for example
14:20 - i know there is a css filter property
14:22 - called grayscale that allows us to do
14:25 - this with one line of code but we
14:27 - wouldn't know how to scan image for
14:28 - pixel data and how to go from here to
14:31 - create more advanced particle effects
14:33 - which is exactly what we will do in the
14:35 - next episode this is why i wanted to
14:37 - take you through the basic concept
14:38 - slowly because once you have full mental
14:41 - picture of what's going on here you will
14:43 - be able to better understand the trick i
14:44 - will teach you next time where i make
14:46 - particles move at different speeds based
14:48 - on brightness of underlying image layer
14:51 - it's going to be more advanced than this
14:53 - but i will do my best to help you
14:54 - understand
14:56 - hope you are learning something new
14:57 - today if you do click the like please so
15:00 - now we understand how to draw image on
15:02 - canvas how to analyze it for pixel data
15:04 - and how to manipulate color values of
15:06 - these pixels let's take it one step
15:09 - further and use index of that pixel in
15:11 - pixel array to calculate its x and y
15:14 - position on canvas once we have that
15:16 - information we can do amazing things in
15:18 - this next part i will show you how to
15:20 - create simple particle system and we
15:22 - will make these particles flow over
15:24 - canvas based on data from an image we
15:26 - will make them move faster over dark
15:28 - areas and much slower over light areas
15:32 - we will remove all pixels and recreate
15:34 - the entire image from a stream of
15:36 - flowing particles
15:40 - let's start in index.html by creating
15:42 - html5 canvas element i give it id of
15:45 - canvas1 i also link css stylesheet and
15:48 - javascript file
15:52 - here in style css i use asterisk
15:55 - selector to target all elements on the
15:57 - page and i do global reset to make sure
15:59 - our styles are the same across different
16:01 - browsers margin 0 padding 0 box size and
16:04 - set to body box and let's also do black
16:07 - background
16:10 - i give canvas border 2 pixels solid
16:13 - white and i center it by setting its
16:15 - position 50 from top
16:17 - this will actually only work if i set
16:18 - its position to absolute
16:21 - left will also be fifty percent and
16:23 - transform translate minus fifty percent
16:25 - minus fifty percent will center it both
16:26 - vertically and horizontally i make the
16:28 - canvas exactly the same size as the
16:30 - image i will be using so for you it
16:32 - might be different my image is five
16:34 - hundred times 706 pixels everything else
16:37 - will be done with javascript in script
16:39 - js file
16:41 - i will start by bringing my image into
16:43 - the project so constant variable i call
16:45 - for example my image and i set it equal
16:47 - to new image now i can give it src
16:50 - property which could point to an image
16:52 - file but because some browsers don't
16:54 - like it when you analyze pixels of image
16:57 - with get image data when that image is
16:59 - not hosted on the same server to avoid
17:01 - all different kinds of cross
17:02 - cross-origin resource sharing errors i
17:05 - will convert our image into url string
17:08 - that way the image itself is part of
17:09 - javascript file and everything will work
17:12 - without errors we can use javascript to
17:14 - convert the image but for speed today
17:16 - let's use a website that will do it for
17:18 - us
17:18 - i google something like png to base64
17:22 - and i choose this link my image can be
17:24 - any image format it doesn't have to be
17:26 - png
17:28 - here i can just drag and drop image i
17:30 - will be using my advice is to make the
17:32 - image as small as possible otherwise you
17:34 - will get a very long data string and
17:36 - since we need to be cycling through
17:38 - these pixels later with javascript
17:40 - smaller image will improve your
17:41 - performance
17:42 - also if you saw the final effect you
17:44 - don't need very fine image resolution
17:46 - for this effect to look great
17:48 - so i made my image as small as possible
17:50 - you can go even smaller if you are
17:52 - having any performance issues i drag and
17:54 - drop it here and i convert it to base
17:56 - 64. for us to be able to use it we need
18:00 - string to start with data colon image so
18:03 - make sure you tick this checkbox here
18:06 - now i copy this extremely long data
18:08 - string which just basically converted
18:10 - the entire image into a line of code so
18:13 - we won't need the actual image file at
18:15 - all i paste that code on line 2 to bring
18:18 - the image into our project
18:21 - now the usual canvas setup const canvas
18:23 - equals to
18:25 - document.getelementbyid and i pass it
18:27 - canvas 1 the id i gave it earlier
18:30 - ctx shortcut for context is equal to
18:33 - this canvas variable dot
18:35 - getcontext2d now we have access to all
18:38 - 2d canvas drawing methods
18:41 - i set canvas width and canvas height to
18:43 - be the same values i declared in style
18:45 - css to make sure the scaling is right
18:48 - now i draw the image on canvas by using
18:50 - built-in html canvas method called draw
18:53 - image
18:54 - it has three versions we will use the
18:55 - middle version of this method that
18:57 - expects five arguments the first is the
19:00 - image i want to draw so my image
19:02 - variable from line one
19:04 - i want the image to start from top left
19:06 - corner of canvas so coordinates 0 0 and
19:09 - i want it to cover the entire canvas
19:11 - area so end coordinates of image
19:13 - rectangle will be canvas with canvas
19:15 - height sometimes drawing your image this
19:18 - way will not work for you because the
19:19 - draw image method only works when image
19:22 - has been fully loaded to make sure we
19:24 - avoid any potential errors we can wrap
19:26 - this whole thing in event listener
19:28 - since we gave our image src property we
19:31 - can now listen for load event on it like
19:34 - this
19:36 - and in callback function only after the
19:38 - image has been fully loaded we run all
19:40 - the code that depends on that image
19:42 - i will just put everything inside like
19:44 - this why not we are now all set let's
19:46 - create a simple particle system that
19:48 - will produce a set of falling particles
19:50 - to flow over the image
19:52 - i create a led variable called particles
19:54 - array and i set it equal to an empty
19:56 - array i use led here so that i can
19:59 - reassign it to a new empty array later
20:01 - if i want to
20:04 - i create a constant variable called
20:05 - number of particles and i set it to
20:08 - let's say 5000
20:10 - i create a javascript class called
20:12 - particle with capital p
20:14 - we will use it to create 5 000 similar
20:17 - particle data objects and we will push
20:19 - them inside particles array from line
20:22 - 12.
20:23 - constructor is a mandatory method on
20:25 - javascript class and it will contain
20:27 - blueprint for each individual particle
20:29 - this dot x horizontal x coordinate will
20:32 - be a random number between a zero and
20:33 - canvas width
20:35 - i want particles to kind of splash over
20:37 - the image from top so i set start and
20:39 - distance y horizontal coordinate to zero
20:42 - you can also do other things here maybe
20:44 - you want the particles to flow from
20:45 - bottom to top or from left to right
20:48 - or maybe you want them to spiral around
20:50 - in a circle you would adjust starting x
20:52 - and y based on the final effect you are
20:54 - going for falling speed will be 0 at
20:56 - first i will also have velocity which
20:58 - will be a random number between 0 and
21:00 - 0.5 basically here i have falling speed
21:03 - which will be calculated based on
21:05 - brightness of background so particles
21:08 - will fall over black areas very fast and
21:11 - over light areas of the image much
21:13 - slower velocity is here just to give it
21:15 - some additional randomness i think it
21:17 - will look good particles will have
21:19 - random size between 1 and 2.5 pixels for
21:22 - example
21:23 - update method will calculate particle
21:25 - position for each frame before we draw
21:27 - it let's start simply by adding plus one
21:30 - to a horizontal y-coordinate once
21:32 - particles fall below the bottom edge of
21:34 - canvas i want them to reset to position
21:37 - zero up top so they can fall down again
21:40 - at the same time i will also give them
21:42 - different random horizontal x position
21:45 - this is important because particles will
21:47 - fall slower over light areas of the
21:49 - image
21:50 - actually rather than to have all
21:52 - particles fall at the same speed we can
21:54 - randomize it a bit this dot y plus
21:56 - equals this dot velocity
21:58 - and velocity on line 20 is a random
22:00 - number between 0 and 3.5
22:04 - custom draw method will simply just draw
22:06 - a circle to represent each particle
22:08 - begin path to start drawing fill style
22:11 - will be white
22:17 - ctx arc to draw a circle i pass it x and
22:20 - y size start angle and end angle
22:28 - then i call ctx fill to fill circular
22:30 - pathway color
22:33 - i create a custom function called init
22:35 - shortcut for initialize this function
22:37 - will just have a for loop that will run
22:39 - as many times depending on number of
22:41 - particles variable in this case 5000
22:47 - each time it runs i call built-in push
22:49 - method on particles array from line 12.
22:52 - push method places whatever we pass to
22:54 - it at the end of the array so i pass it
22:57 - new particle the new keyword will
22:59 - trigger particle class constructor on
23:01 - line 16. it will create one new blank
23:04 - particle object and assign it properties
23:07 - and randomized values
23:08 - based on the blueprint
23:11 - for loop will run 5000 times filling
23:13 - particle array with 5000 randomized
23:16 - particle objects
23:18 - now i call init to fill the array
23:22 - function animate will be our main
23:24 - animation loop first i want a
23:26 - semi-transparent black rectangle to be
23:28 - drawn over the canvas for every frame
23:31 - this will give particles fading trails i
23:34 - set global alpha to 0.05 this just
23:37 - specifies transparency value that is
23:39 - applied to shapes and images on canvas 0
23:42 - is fully transparent one is fully opaque
23:45 - now i set fill style to rgb 0 0 0 which
23:50 - is black color
23:54 - i draw a rectangle that covers the
23:55 - entire canvas ctx fill rect starting
23:58 - coordinates 0 0 and in coordinates
24:01 - canvas with canvas height
24:05 - i will cycle through the entire
24:07 - particles array
24:10 - and for each particle object in the
24:12 - array i call their associated update
24:14 - method from line 23
24:16 - and a draw method we declared on line
24:18 - 30.
24:20 - this for loop will cycle through all
24:22 - 5000 particles for each frame of
24:24 - animation
24:25 - it will recalculate their position with
24:27 - update method and it will draw them at
24:29 - their new coordinates with draw method
24:33 - now i just call animate to kick off
24:34 - animation loop
24:36 - this will not work because i also have
24:38 - to call a request animation frame here
24:40 - and i pass it animate
24:42 - request animation frame is a built-in
24:44 - javascript method when i pass it animate
24:46 - the name of its parent function from
24:48 - line 43 that way animate will run all
24:51 - its code and it will just call itself
24:53 - again here on line 51 create an
24:56 - animation loop through a programming
24:57 - principle called recursion when function
25:00 - calls itself over and over
25:02 - that worked now we have falling white
25:04 - particles that leave trials perfect
25:08 - i can temporarily copy draw image call
25:10 - from line 10 and i put it inside
25:12 - animation loop so that we can see the
25:14 - original image for now
25:19 - particles are falling and ignoring the
25:21 - image how do i make them fall at
25:22 - different speeds based on brightness of
25:25 - the area they are moving over one way to
25:27 - do that is to create a brightness map of
25:30 - the entire image it will correspond to x
25:32 - and y coordinates of each pixel then i
25:34 - can run this information against
25:36 - particle's current x and y position and
25:39 - adjust particle's speed based on its
25:41 - current coordinates let's do it step by
25:43 - step first i create a new led variable
25:45 - called mapped image this will be an
25:47 - empty array at first my goal is to have
25:50 - this array hold brightness value of each
25:51 - pixel in the image along with that
25:54 - pixels x and y coordinates so i can
25:56 - compare it to x and y coordinates of
25:58 - each particle and adjust their movement
26:00 - speed accordingly so on the first page
26:03 - load we just draw image on canvas here
26:05 - on line 10.
26:06 - i create a custom variable called for
26:08 - example pixels and i set it equal to ctx
26:10 - dot get image data built in canvas
26:13 - method this method scans area of canvas
26:16 - for pixel information and it will return
26:18 - an array like object that holds red
26:21 - green blue and alpha value for each
26:23 - individual pixel in the scanned area
26:26 - i want to scan the entire canvas so i
26:28 - pass it 0 0 as starting coordinates
26:31 - and canvas with canvas height as the end
26:34 - coordinates so now my custom pixels
26:37 - variable holds whatever get image data
26:39 - returned after scanning the designated
26:42 - area in our case the entire canvas
26:45 - if i count to lock pixels i see this
26:47 - returned image data object if i open it
26:51 - it contains array called data it also
26:54 - contains height and width attributes
26:55 - that correspond to width and height of
26:57 - the scanned area we scan the entire
27:00 - canvas so width and height correspond to
27:02 - canvas width and canvas height from
27:03 - lines 7 and 8. let's inspect the data
27:06 - array
27:07 - you can see it is called uint clamped
27:09 - array that means unassigned integer so
27:12 - it can only contain elements that are
27:14 - whole numbers with no decimal points it
27:17 - also says clamped because these numbers
27:19 - are limited to a range between 0 and 255
27:24 - if you work with css before you know
27:26 - that in rgba color declaration every
27:28 - color can be declared by combination of
27:31 - red green and blue with values between 0
27:34 - and 255 for each we established that
27:38 - each element in this data array could
27:40 - only be a number between 0 and 255.
27:43 - if you look at the data structure you
27:45 - can see that every 4 pixels in the array
27:48 - combined create rgba color declaration
27:51 - of 1 pixel in our image
27:53 - so this one for example is 0 for red 0
27:57 - for green 0 for blue and 255 for alpha
28:01 - opacity
28:02 - in this case alpha is also declared as a
28:04 - value between 0 which is fully
28:06 - transparent to 255 fully opaque
28:11 - we can double check if you are right
28:12 - about this we have an array of 1 million
28:15 - four hundred and twelve thousand
28:16 - elements and we know that each four
28:18 - elements in this array represent rgba
28:21 - color value of one pixel so one million
28:25 - four hundred and twelve thousand divided
28:27 - by four is 350 000. these numbers depend
28:32 - on the size of the image you uploaded so
28:33 - for you it might be different
28:36 - we know the image i'm using is 500
28:38 - pixels wide and 706 pixels high
28:42 - so 500 times 706 is also 353 000 so that
28:48 - checks out
28:49 - let's look at the pixels with color that
28:50 - are not black for example here we have
28:52 - 111 for red 83 for green blue and 255
28:57 - for alpha then 139 is right of the next
29:00 - pixel and so on so now we understand how
29:02 - the color data returned by getimagedata
29:05 - method is organized we can cycle through
29:07 - it and save it in our own array and
29:09 - since we know width and height of the
29:11 - scanned area we can calculate x and
29:13 - y-coordinates of each pixel
29:16 - since we know how many pixels fit on one
29:18 - row and we know how many rows and how
29:20 - many columns our image has
29:22 - this is the only a bit more difficult
29:24 - part in this tutorial so if you are a
29:25 - beginner keep in mind this is not easy
29:28 - don't feel bad if you struggle to
29:29 - imagine what exactly is going on i made
29:31 - a beginner friendly version of this
29:33 - technique where we cycle through all
29:34 - pixels and turn image into grayscale
29:37 - sometimes it's easier to first try this
29:39 - with a simple project i will link it in
29:41 - the video description we will cycle
29:43 - through every pixel in this image row by
29:46 - row from left to right starting from the
29:48 - top left corner
29:50 - so the first for loop will have a
29:52 - vertical y coordinate at zero
29:54 - our image is 500 pixels wide so y will
29:57 - be 0 and x will be 0 1 2 3 all the way
30:01 - to 500
30:02 - then we increase y to 1 and again we
30:06 - cycle through pixels 0 to 500
30:09 - horizontally
30:10 - then we increase y to 2 and we cycle
30:12 - through the entire x-coordinate of
30:14 - pixels again
30:16 - we will do this 706 times because our
30:18 - image is 706 pixels high which means it
30:22 - contains 706 rows of horizontal pixels
30:26 - the code will look like this
30:28 - we will use nested for loops which means
30:31 - loop inside of another loop
30:33 - the outer loop will represent vertical y
30:35 - coordinate so it will run 706 times
30:38 - because our image is 706 pixels high
30:41 - which means we have 706 rows of pixels
30:45 - we will start with top row 0 and go all
30:48 - the way down to row 706 on the bottom
30:51 - for each row of pixels in the image i
30:53 - will create an array called row
30:56 - it will hold our pixel data for each of
30:58 - the rows for every one of these rows we
31:00 - enter the inner loop and index of this
31:03 - in loop will correspond to horizontal
31:05 - x-coordinate of pixel within the image
31:08 - starting from x-coordinate 0 and going
31:11 - to the right until we reach pixel 500
31:13 - because our image is 500 pixels wide
31:17 - then we just exit the inner loop
31:19 - increase y by one therefore jump in to
31:22 - the next row and going through the
31:24 - horizontal pixels from left to right
31:26 - from zero to 500 again
31:29 - i'm not sure if i'm over explaining this
31:31 - or if you need me to explain it more let
31:33 - me know in the comments please i'm just
31:35 - trying to make it accessible for
31:36 - beginners as well
31:37 - so now we have two nested for loops that
31:39 - work together to cycle through every
31:41 - single pixel in the image for each
31:43 - individual pixel i want to read its
31:45 - color values so here i will create a
31:47 - temporary variables for red green and
31:50 - blue
31:51 - red for each pixel will be pixels
31:53 - variable from line 11 dot data which is
31:56 - this data object here with 1 million
31:59 - and twelve thousand elements
32:01 - where we know each four elements
32:03 - represent red green blue and alpha of
32:06 - one pixel there are many ways we can
32:08 - skip array index by four i will use this
32:10 - formula i'm sure there is easier way to
32:12 - do this let me know in the comments
32:15 - the first part that says y times 4 times
32:18 - pixel's width just keeps track of
32:20 - overall number of array elements from
32:22 - previous rows
32:23 - and the second part that says x times 4
32:27 - just adds the items from the current row
32:29 - to it
32:30 - so the final number we get is array
32:32 - position of red value for pixel with
32:35 - this y-coordinate and this x-coordinate
32:38 - this is not programming anymore this is
32:40 - more like advanced logic and
32:41 - visualization i wish i had more visual
32:43 - tools to show you better what's going on
32:46 - i will try to come up with something for
32:47 - future tutorials in the meantime let's
32:49 - just finish this once we know what index
32:51 - red color value is it's easy to get
32:53 - green blue and alpha because we know
32:56 - that this data array is organized in a
32:58 - way where red is followed by green which
33:00 - is followed by blue and alpha
33:03 - since i know this i know that green is
33:06 - whatever red is plus one
33:12 - and blue is position of right
33:14 - in pixels array plus 2.
33:17 - so now i have calculated red green and
33:20 - blue of pixels at this vertical y
33:22 - coordinate and this horizontal x
33:24 - coordinate
33:25 - i could just add them together and
33:27 - divide them by 3 to get their average
33:29 - value which is the same technique we
33:30 - used to turn image into grayscale in the
33:33 - previous episode for beginners link in
33:35 - the video description there is a strange
33:37 - thing about human eye that we don't
33:39 - perceive red green and blue the same the
33:42 - same amount of red is not the same
33:44 - brightness as the same amount of blue
33:46 - when perceived by human eye
33:49 - we can create a simple utility function
33:51 - that will take red green and blue value
33:53 - we just calculated for each pixel it
33:56 - will adjust them by different amount
33:59 - based on human brightness perception and
34:01 - it will return a single number
34:03 - representing relative brightness of that
34:05 - pixel
34:06 - custom function called for example
34:08 - calculate relative brightness it will
34:11 - expect three arguments red green and
34:14 - blue we calculated on lines 20 21 and
34:17 - 22.
34:18 - it will just straight up return a number
34:20 - calculated by following formula i found
34:23 - this formula online we don't have to
34:25 - fully understand it because all it does
34:27 - it adjusts red green and blue by
34:30 - different amounts to make up for the
34:32 - fact that the human eye doesn't perceive
34:34 - these three colors the same when it
34:36 - comes to their relative brightness
34:38 - this is just for fun to make it more
34:40 - visually accurate i guess as i said this
34:42 - formula could have been a simple other
34:44 - red plus green plus blue divided by 3 to
34:47 - get average and it would work as well
34:50 - of course then you have to adjust the
34:51 - rest of the code like particle falling
34:53 - speed based on the range of numbers this
34:55 - would return
34:57 - up on line 23 i create a variable called
34:59 - brightness
35:00 - thanks to javascript principle called
35:02 - hoisting i can call my custom calculate
35:04 - relative brightness function i declared
35:06 - on line 27 up here on line 23 before
35:10 - that function is declared hosting allows
35:13 - us to do that
35:14 - it expects three arguments so i pass it
35:16 - right i calculated here on line 20. this
35:19 - simply is a reference to index in pixels
35:21 - array as we cycle through it so for
35:23 - example for this pixel red would be zero
35:26 - green would be zero and blue would be
35:29 - zero so brightness is zero as well
35:34 - i create a constant variable called cell
35:36 - and i set it equal to an array
35:38 - i give it property called cell
35:40 - brightness and i set it equal to
35:42 - brightness variable from line 23
35:44 - here inside the cell array you could
35:47 - also create another property called cell
35:49 - color and create rgb color declaration
35:52 - where you concatenate red green and blue
35:54 - and you save this pixel's actual color
35:56 - so we can use it in fill style on draw
35:58 - method for that particle that way you
36:00 - can persist original colors
36:02 - of the image more on that later
36:04 - so we calculated relative brightness of
36:06 - pixel of this vertical y and this
36:08 - horizontal x coordinate and saved it in
36:11 - a custom array i call cell
36:13 - i take row variable from line 18 and i
36:15 - push cell from line 24 to that array we
36:18 - will create this cell array for every
36:20 - pixel in every row so row variable from
36:23 - line 18 will be created
36:25 - times because outside for loop will run
36:28 - for every row of our image which is 706
36:31 - pixels high
36:33 - and inside of each of these 706 rows we
36:36 - create cell array here on line 24.
36:38 - we will have 500 cells for each row
36:41 - because our image is 500 pixels wide
36:44 - each cell holds relative brightness
36:46 - value for each individual pixel in the
36:48 - image
36:49 - so every time the loop is done and we
36:51 - pushed 500 cells into that row we take
36:54 - the entire row from line 18 and push it
36:56 - into mapped image array from line 16.
36:59 - that way when all these loops have run
37:02 - we have mapped image array with 706 row
37:06 - arrays inside of each of these row
37:08 - arrays
37:09 - there are 500 cell arrays each cell
37:12 - array from line 24 represents one pixel
37:15 - in the image
37:17 - we did it we cycled through pixels
37:19 - variable from line 11 we took that image
37:21 - data
37:22 - and created our own array called mapped
37:24 - image that contains brightness values
37:26 - for each pixel on canvas
37:28 - if i consolidate mapped image you see
37:30 - 706 items
37:34 - these are the raw arrays from line 18.
37:37 - each one holds 500 cell elements from
37:40 - line 24 and each cell is an array that
37:43 - contains only one element that is this
37:45 - cell brightness property that contains
37:48 - relative brightness of each pixel we
37:50 - calculated we will get a lot of zeros as
37:52 - cell brightness value because there are
37:54 - large black areas around my image but if
37:57 - i keep looking i will be able to find
37:58 - other values here as well see
38:01 - now i just need to take this information
38:03 - about brightness i stored in mapped
38:05 - image variable and somehow make
38:06 - particles fall at different speeds based
38:09 - on that
38:10 - first of all we need to navigate in
38:12 - indexes of that array based on particles
38:14 - current x and y coordinates since array
38:17 - index has to be integer whole number
38:19 - with no decimal points here on line 48
38:22 - and 49 inside particles class
38:24 - constructor i create position 1 and
38:26 - position 2 custom variables that will
38:28 - simply round down this dot x and this.y
38:32 - making sure that these numbers don't
38:33 - have decimal points
38:42 - i also need to put these values here
38:44 - inside update method to make sure every
38:46 - time we update x and y position these
38:49 - values stay rounded down as whole
38:51 - numbers as integers
38:53 - now the main trick of how this entire
38:55 - effect works i will adjust this dot
38:58 - speed from line 45 i will literally take
39:00 - values from my custom mapped image array
39:03 - and since we organized pixel data in the
39:05 - array to the same width and height as
39:07 - our canvas using our nested for loops i
39:10 - pull value from a mapped image array
39:12 - based on particles current x and y
39:14 - position this dot position 1 corresponds
39:17 - to particles current vertical y
39:19 - coordinate as we declared on line 52 and
39:22 - adding it as index like this on line 54
39:25 - will access custom row array in mapped
39:28 - image which has the same vertical y
39:30 - position as the particle currently has
39:33 - then we go one level deeper inside map
39:36 - image array to access horizontal x
39:38 - position i called these arrays cells if
39:41 - you remember and they contain only one
39:44 - property called cell brightness so
39:46 - that's array position 0.
39:49 - so what we have here is mapped image
39:51 - custom row array from line 18 custom
39:54 - cell array from line 24 and it has only
39:57 - one element i called cell brightness
39:59 - from line 25 so position in this array
40:02 - is zero
40:04 - and since outer loop that created mapped
40:06 - image on line 17 matches height of
40:09 - canvas and in a loop from line 19
40:12 - matches canvas width the brightness
40:14 - information held in mapped image will
40:16 - correspond exactly with our image
40:19 - let me show you
40:20 - i appreciate this might be hard to
40:22 - follow and imagine what's going on at
40:23 - first if you can't follow what i'm
40:25 - explaining here with no problems
40:26 - congratulations you are not in majority
40:28 - of us
40:29 - it took me a while to realize how this
40:31 - works to create a full mental picture i
40:33 - bet some of you will be able to tell me
40:35 - there is a much simpler way to do this
40:37 - and i am looking forward to these
40:38 - comments i've learned a lot from your
40:40 - comments already so please keep them
40:41 - coming
40:42 - so here on line 54 i take speed from
40:44 - line 45 and i assign it to brightness
40:47 - value of that area in the original image
40:51 - then i create a custom variable let's
40:53 - call it movement for example relative
40:55 - brightness we calculated earlier and
40:57 - which is now reflected in this dot speed
40:59 - because of line 54 with a small number
41:01 - between 0 and 2.5 approximately i think
41:05 - since i want dark particles that have
41:07 - brightness close to zero move very fast
41:09 - and i want light particles with relative
41:11 - brightness close to 2.5 to move very
41:14 - slow i flip it by saying 2.5 which is
41:17 - the maximum minus this dot speed and i
41:21 - also want to randomize it a bit so if we
41:23 - have a
41:24 - large area of particles with the same
41:26 - color they still don't move exactly the
41:28 - same speed
41:30 - to do that i just do plus this dot
41:32 - velocity from line 46
41:34 - now here on line 57 i say this dot y
41:37 - plus equals movement and we should be
41:39 - able to see that particles react to
41:41 - image now
41:43 - velocity on line 46 is too high let's
41:46 - change it to random number between 0 and
41:48 - 0.5
41:50 - perfect
41:51 - important part of this effect is that
41:53 - the faster the particles move the more
41:55 - transparent they are on line 77 inside
41:58 - animate i remove the image so it's not
42:01 - been redrawn over and over
42:04 - you can see we are getting something
42:06 - nice on canvas already
42:08 - code between lines 77 and 79 just
42:11 - creates a semi-transparent rectangle
42:13 - that is being drawn on canvas over and
42:15 - over given particles fade in trails once
42:18 - we draw it i want global alpha to
42:20 - increase to let's say 0.2 and here
42:23 - inside for loop that cycles through all
42:26 - particles for every animation frame
42:28 - before we actually draw the particle i
42:30 - will adjust global alpha for that
42:32 - particle to be equal to particle's speed
42:34 - property
42:38 - that's a bit too much let's half it
42:41 - speed times 0.5
42:47 - up on line 10 on the first page load i
42:49 - draw the original image on canvas using
42:51 - built-in html canvas draw image method
42:54 - on line 11 i call get image data on it
42:57 - to get information about all its pixels
42:59 - and i save it to my custom pixels
43:01 - variable
43:02 - at that point i don't need the image
43:04 - anymore so i just clear canvas deleting
43:06 - the original image when i do this we
43:08 - will never see that image at all it will
43:10 - be drawn analyzed and deleted when page
43:13 - loads are very fast there are a lot of
43:15 - moving parts and many ways to customize
43:17 - this effect you can try to tweak some
43:18 - values and see what it does
43:20 - idea for this effect came from this
43:22 - brilliant code pen link in the video
43:24 - description luis also has many other
43:27 - interesting animations on there you can
43:29 - follow him if you want there is a lot of
43:31 - code in that code pen today we wrote our
43:33 - own version line by line using just
43:35 - plain vanilla javascript and we
43:37 - explained exactly what's going on on
43:39 - each line of code i hope it gave you
43:41 - some value and brought you one step
43:42 - closer to becoming a master of web
43:44 - animation now you should be able to
43:46 - understand it and tweak it to make your
43:48 - own variations or maybe even build on it
43:51 - and create something completely new
43:53 - now we know how to make black and white
43:54 - pixel rain how about we take it to the
43:57 - next level we will add colors give
43:59 - particles a different movement patterns
44:01 - and shapes experiment with filters blend
44:03 - modes gradients and i will try to create
44:06 - fire effect let's see what comes out of
44:08 - that click like please
44:13 - in the previous episode we built this
44:15 - black and white pixel rain effect step
44:17 - by step completely from scratch and i
44:19 - explained how everything works let's
44:21 - just have a play with it and create
44:23 - variations using different javascript
44:25 - tools and techniques let's see what
44:27 - comes out of that
44:29 - in style css i move the canvas slightly
44:31 - more upwards
44:32 - first of all i will quickly swap to a
44:34 - different image we are using data string
44:36 - that contains all image data to replace
44:39 - it i just enable word drop in my code
44:41 - editor
44:42 - i select beginning of the string
44:45 - then i scroll all the way to the end and
44:47 - on my windows pc using vs code editor
44:50 - when i hold down shift key and click
44:53 - here
44:53 - left click
44:55 - it will highlight all the code in
44:57 - between i delete it and replace it with
44:59 - a different image
45:00 - when replacing images in your projects
45:02 - make sure canvas width and canvas height
45:04 - on lines 7 and 8 as well as install css
45:07 - file is updated to much dimensions of
45:10 - the new image you are using in my case i
45:12 - made sure the new image is the same size
45:14 - as the old one i gave you a challenge
45:16 - last time instead of black and white
45:18 - effect to try and dynamically assign
45:21 - colors of the original image to the
45:23 - particles as they flow over areas with
45:25 - different colors solution is very simple
45:28 - we already calculated red green and blue
45:30 - here anyway to get our brightness so i
45:32 - just create another property in custom
45:34 - cell array called cell color
45:37 - and i concatenate string rgb
45:42 - plus right
45:44 - plus comma
45:46 - plus green
45:49 - plus comma
45:50 - plus blue
45:52 - plus closing bracket
45:53 - now this little cell array we create for
45:56 - each pixel contains two values
45:58 - relative brightness and original color
46:02 - to use this color all i need to do is go
46:05 - down here to draw method on particle
46:07 - class and on line 67 instead of setting
46:10 - fill style to white i set it to this new
46:12 - color property inside cell array
46:15 - same as we do with brightness on line 56
46:19 - i go down two levels inside my custom
46:21 - mapped image array and inside cell array
46:24 - i see that cell brightness is the first
46:26 - property so index 0
46:29 - and cell color is index 1.
46:32 - down here on line 67 i set the last
46:35 - index to 1 and here we go we are drawing
46:38 - in color that was easy
46:39 - let's play with particle movement now we
46:42 - will face a weird bug here i will tell
46:44 - you why it's happening and i will show
46:46 - you easy way to fix it when i increase
46:49 - vertical y value particles fall down
46:52 - what if at the same time i increase
46:54 - horizontal x position
46:56 - oh here is the bug one of our particles
46:58 - moved outside the canvas area and
47:01 - because of lines 56 and 68 javascript
47:04 - doesn't have indexes for these
47:05 - coordinates in mapped image array and
47:08 - everything breaks
47:09 - in this case i can fix it by resetting x
47:11 - and y correctly on line 61 if vertical y
47:15 - position reaches bottom of canvas i set
47:17 - it back to 0
47:19 - and i randomize x horizontally i will
47:21 - also check when horizontal x position is
47:23 - more than canvas width
47:26 - and i set x back to 0
47:29 - and randomize y vertically
47:32 - this solves the bug we are getting when
47:34 - particles move outside the canvas area
47:37 - but for the next effect i want to use
47:39 - trigonometry and make particles move in
47:41 - waves
47:42 - i won't be able to make sure particles
47:44 - never reach outside of canvas area when
47:46 - we have complex flowing movement like
47:48 - that so i will have to fix that back in
47:50 - a different way
47:52 - by the way you can also change angle at
47:54 - which particles fall by adjusting lines
47:56 - 59 and 60 like this
48:00 - first let's try to apply some
48:02 - fluctuation to particles movement and
48:04 - let's see what happens on line 52 inside
48:07 - particle class constructor i create this
48:09 - dot angle property this will be
48:11 - individual for each particle and the
48:13 - reason i make separate angle for each
48:15 - particle is because i want each particle
48:18 - to fluctuate at different speed
48:20 - depending on the brightness of the
48:22 - underlying area just like we did with
48:24 - movement speed earlier
48:26 - let me show you how
48:28 - at first i will increase this.angle
48:30 - inside update method for each particle
48:32 - by one for every frame
48:34 - so far all particles will have identical
48:37 - motion i take that angle value and i
48:39 - pass it to trigonometry function called
48:42 - math.sine
48:44 - this will just take the angle value and
48:46 - periodically run it between plus 1 and
48:50 - -1 over and over which will give us
48:52 - fluctuating movement
48:54 - immediately when i do it i will get an
48:56 - error it is because particles wiggle now
48:59 - and on line 61 i say this.y is movement
49:02 - plus this wiggle created by math.sine
49:05 - the problem is this imagine this
49:07 - particle is all the way to the bottom
49:09 - edge and method sign is added to that
49:11 - position on line 61 making the particle
49:14 - move further down outside the canvas
49:17 - area
49:18 - in reset check on line 63 particles this
49:21 - dot y is not past the bottom edge of
49:23 - canvas yet so it will not reset y to
49:25 - zero but because we added mod.sign to it
49:28 - on line 61 particle's actual coordinate
49:31 - is outside canvas
49:33 - normally that wouldn't be a problem but
49:34 - here on line 57 i calculate speed of
49:37 - particles based on their coordinates
49:39 - because each set of coordinates has
49:41 - different underlying brightness and the
49:43 - speed depends on that
49:46 - my mapped image array on line 57 has
49:48 - only values for actual image dimensions
49:50 - so when i ask it to access vertical
49:53 - index 710
49:55 - when my original image was only 700
49:57 - pixels tall this index in mapped image
50:00 - array doesn't exist in this case
50:02 - javascript will not know what to do and
50:04 - the entire animation will stop
50:06 - in console log you will see something
50:08 - like this cannot read property some
50:10 - number of undefined because we are
50:12 - asking for index in mapped image array
50:15 - outside the canvas area and mapped image
50:18 - array is set exactly to match canvas
50:20 - dimensions as we explained in the last
50:22 - episode so this index in that array
50:25 - doesn't exist
50:27 - so on line 57 we only want to assign a
50:29 - new speed value if particle is within
50:32 - canvas so that we can check for
50:34 - brightness of underlying area by
50:36 - accessing associated indexes and mapped
50:39 - image array
50:40 - i will just simply do an if statement
50:42 - here
50:47 - if vertical y position is within canvas
50:49 - area this.position1
50:53 - and at the same time horizontal x
50:55 - position is not undefined as well only
50:57 - then assign new value to this dot speed
51:00 - otherwise just use all the distort speed
51:02 - value that was assigned in previous
51:04 - frames
51:08 - that's fixed but i get another error on
51:10 - line 76 the same issue here we are
51:12 - asking for color of the original image
51:15 - but particle is currently outside canvas
51:17 - area so mapped image array doesn't have
51:19 - color data for this position
51:22 - i do exactly the same fix if statement
51:25 - only if horizontal and vertical position
51:27 - have corresponding indexes in mapped
51:29 - image array and are not undefined only
51:33 - then change fill style to new color
51:35 - otherwise fill style will just stay the
51:37 - same color from the previous frame
51:39 - problem solved now we can give particles
51:41 - any crazy movement and the effect will
51:44 - not break the wiggle is barely
51:45 - noticeable let's make particles spin
51:48 - around properly
51:50 - i also add circular movement to this dot
51:53 - x
51:59 - i change sine to cosine on line 61 angle
52:03 - is increased by one per frame of
52:05 - animation way too fast look what happens
52:07 - when i slow it down
52:09 - we can actually see the circle movement
52:11 - now but all particles are moving in the
52:13 - same rhythm
52:15 - i put angle property on particle class
52:17 - constructor on line 52 which means each
52:20 - particle has its own individual angle
52:22 - value
52:23 - if i wanted all particles to move the
52:25 - same like this angle could have been a
52:27 - global variable and it would have saved
52:29 - javascript a lot of calculation since we
52:31 - have separate angle for each particle
52:33 - let's make each particle spin around
52:36 - based on its distort speed property
52:38 - which is individually calculated on line
52:40 - 58 based on brightness of the underlying
52:43 - area meaning that the dark areas of our
52:46 - image will create different circular
52:48 - patterns than light areas
52:50 - this dot speed is too fast let's divide
52:53 - it by 10.
52:54 - interesting
52:56 - making it even smaller number will
52:57 - really show off what's going on because
53:00 - particles move slower over light areas
53:02 - just because they spend more time in
53:04 - there they are more likely to make a
53:06 - complete spin and it kind of looks in
53:07 - some places like particles are actually
53:09 - bouncing off the light areas in the
53:11 - image
53:12 - how about we create our own spectrum
53:15 - that's also very easy up on line 9 i
53:17 - create a constant variable called
53:19 - gradient 1 and i set it equal to ctx
53:22 - create linear gradient
53:25 - this is a built in canvas method it
53:27 - expects four arguments two sets of
53:29 - coordinates these determine direction of
53:31 - the gradient imagine drawing a line
53:33 - between them to see the direction i want
53:35 - my gradient to go from top left corner
53:38 - coordinate 0 0 to bottom right corner
53:41 - coordinates canvas width canvas height
53:43 - i take this gradient one variable i just
53:45 - created and i call at color stop built
53:48 - in method on it
53:50 - it expects two arguments position
53:52 - between 0 and 1 and color we want at
53:55 - that position i will just speed this up
53:57 - and make some color stops to create
53:58 - rainbow my color stops will be at 20
54:01 - 30 40 50 60 70 and 80 percent and the
54:05 - colors will be for example pink red
54:08 - orange yellow green turquoise and violet
54:14 - to apply this i can simply go down to
54:16 - line 84
54:20 - i disable colors from the original image
54:22 - for now
54:23 - and i set fill style to gradient one
54:26 - variable we just created
54:30 - upon line 9 you can change these
54:32 - coordinates to change angle of your
54:34 - gradient
54:37 - what if i want size of particles to be
54:40 - small in dark areas and larger in bright
54:42 - areas
54:43 - very simple to do as well i go down to
54:46 - line 70 inside update method and i set
54:48 - this dot size to this dot speed as speed
54:52 - already depends on brightness anyway how
54:54 - about speed times 2
54:57 - maybe speed times 1.5
55:01 - let's comment outline 88 and uncomment
55:03 - this to get original colors
55:07 - how about instead of filled circles we
55:09 - use stroked rectangles
55:18 - this works but we didn't set our stroke
55:20 - style so it defaults to black
55:23 - i just added here on line 87
55:28 - the rectangles are too small maybe size
55:30 - times five
55:36 - how about size times three
55:42 - interesting
55:43 - you can put any drawing code here to
55:45 - represent each particle even more
55:46 - complex shapes or image from a sprite
55:49 - sheet like we do in game dev videos for
55:51 - example if you use more complex particle
55:54 - shapes you have to consider the number
55:55 - of particles that make up our effect it
55:58 - might be a lot for our computer to
56:00 - handle and draw all these complex shapes
56:03 - let's try to replace particles with
56:05 - letters
56:06 - for example with capital m
56:09 - that seems to run okay even though
56:11 - replacing circle with letter is a bit
56:13 - more demanding on performance
56:15 - how about i create a constant variable
56:17 - called letters and i set it equal to an
56:19 - array
56:20 - the array will contain some letters for
56:22 - example we can spell mandalorian
56:25 - or let's just do n a n
56:28 - then down here in particle class
56:30 - constructor i create a new property and
56:33 - each particle when it is created will be
56:35 - assigned one of these letters randomly i
56:38 - do that by saying this.letter equals
56:41 - letters array i just created and index
56:44 - will be a random number between 0 and
56:46 - letter's length this will give us
56:48 - numbers with decimal points but array
56:50 - has only indexes 0 1 and 2 because i
56:53 - have 3 elements in my letters array to
56:56 - make sure we only get integers whole
56:58 - numbers without decimal points i wrap it
57:01 - in math.floor which will round it down
57:03 - to the nearest integer
57:06 - now i can take this new letter property
57:08 - i just created and in draw method on
57:11 - line 95 inside fill text instead of
57:14 - hard-coded letter m i pass it this dot
57:17 - letter
57:18 - now our particles are random letter from
57:20 - that array
57:22 - up on line 25 i reduce the number of
57:24 - particles so that we can actually make
57:25 - up individual letters better
57:28 - inside animation loop i comment out line
57:30 - 12 that changes particles opacity based
57:33 - on their movement speed and i set
57:35 - everything to full opacity global alpha
57:37 - equals to 1.
57:39 - this looks pretty cool
57:42 - what if i want only certain percentage
57:43 - of my particles to be letters and the
57:45 - rest regular circles how do i control
57:48 - that i can for example create
57:50 - this.random property on particle class
57:52 - constructor and i just set it the math
57:54 - at random like this
57:56 - math random code like this returns a
57:58 - random small number between 0 and 1.
58:01 - each particle gets assigned a different
58:03 - random number at the point when the
58:05 - constructor gets called and that
58:07 - particle is created
58:08 - on line 96 inside our custom draw method
58:11 - on particle class i can say if this dot
58:14 - random is less than 0.1 which should
58:17 - roughly be in 10 percent of the cases
58:20 - then draw particle as text as one of the
58:24 - letters from letters array
58:26 - else draw it as a circle
58:29 - this way you can control different
58:31 - percentages of particles and give them
58:33 - different properties based on that you
58:35 - can do anything here if i change 0.1 to
58:38 - 0.5 now approximately 50 of my particles
58:41 - should appear as letters
58:44 - i can use ctx font to set text size and
58:46 - font family let's try 20 pixels aerial
58:50 - i can tweak the amount of text particles
58:53 - by tweaking if statement on line 97
58:57 - i can replace text with stroke
58:59 - rectangles
59:01 - make them larger
59:03 - okay back to the circles
59:06 - this effect also works with global
59:08 - composite operation property where you
59:09 - can blend particles together in
59:11 - different ways
59:12 - i like when particles flow from one side
59:15 - and wash over the image
59:16 - until now it only ever happened on the
59:18 - first page load if i set start in x or y
59:21 - position to edge of canvas what if i
59:24 - want particles to come in waves and
59:26 - periodically create this splash movement
59:29 - let's create a variable that will switch
59:30 - between two values
59:32 - i will call it for example switch
59:34 - oh no that's a reserved word in
59:36 - javascript let's do switcher
59:38 - and another one called counter
59:41 - both will be let variables because i
59:43 - will be changing their values
59:45 - i create set interval that takes two
59:47 - arguments callback function to run and
59:50 - how often in milliseconds to run it
59:53 - i want it to run every 500 milliseconds
59:56 - every time it runs i increase counter
59:58 - plus 1 and now i can use that to set
60:01 - periodic events in my code base i say if
60:04 - counter modulus 12 is equal to 0 modulus
60:07 - operator percentage symbol is also
60:10 - called remainder operator this if
60:13 - statement means if counter value is
60:15 - divisible by 12 with a remainder of 0
60:18 - which means as counter increases by 1
60:20 - every 500 milliseconds this if statement
60:22 - will be true at 0 12 24 36 and so on
60:28 - every time counter variables from line
60:30 - 20 increases by 12 set switcher variable
60:33 - from line 19 to its opposite value
60:35 - switcher times equals -1
60:38 - at first switcher is set to 1 so 1 times
60:42 - -1 is -1 then it runs again switcher is
60:46 - minus 1 so minus 1 times minus 1 is plus
60:49 - 1.
60:50 - it will just repeat and switch between
60:52 - plus 1 and -1 over and over every 12
60:55 - cycles of this interval
60:58 - on line 84 inside custom update method
61:01 - on particle class i can say if switcher
61:03 - is plus 1
61:06 - do something
61:09 - else do something else
61:13 - let me show you what global composite
61:15 - operation does
61:17 - i can set it for example to soft light
61:21 - oh i actually misspelled it it's
61:22 - supposed to be operation
61:24 - you can see these values control
61:26 - compositing or blending mode operations
61:28 - on canvas they can blend shapes adjust
61:31 - contrast hue brightness and other
61:33 - properties of canvas giving us different
61:35 - effects
61:36 - there are over 20 different values soft
61:39 - light affects how light and dark is
61:40 - displayed
61:42 - luminosity preserves luma or brightness
61:45 - of the top layer and it also preserves
61:47 - you and chroma of the bottom layer from
61:50 - their official descriptions it's really
61:52 - hard to guess what will the final result
61:54 - look like so i just try and see what
61:56 - happens some of them like source out
61:58 - might freeze your browser because what
62:00 - it does is performance intensive when
62:03 - you have so many particles like we do in
62:05 - this effect so be careful
62:07 - i can use my custom switcher variable to
62:09 - switch between two different blend modes
62:11 - periodically just for fun combining two
62:14 - specific ones might create something
62:16 - interesting let's swap between
62:17 - luminosity
62:19 - and lighter
62:25 - at the same time i say if counter
62:27 - modulus 10 is 0 every 10 cycles of
62:30 - counter variable set x and y to zero so
62:34 - particles splash over the canvas over
62:37 - and over
62:42 - what if i randomize it this way
62:47 - let's reset y to zero and leave x as a
62:50 - random number
62:54 - now the image automatically switches
62:56 - between two different blend modes and
62:58 - particles periodically reset so they can
63:00 - flow over the image in a wave again
63:06 - let's comment out this bit
63:10 - i can swap sine and cosine on lines 94
63:13 - and 96 this will affect the circular
63:15 - path particles take tweaking anything on
63:18 - these lines will affect particle
63:19 - movement in a major way
63:31 - i can for example make particles move
63:33 - upwards
63:34 - if i do that i need to adjust reset
63:36 - check on line 96 i'm just playing with
63:38 - the reset checks trying to get it right
63:51 - on line 67 i can change particle size
63:54 - actually no because i am overriding it
63:56 - on line 82 because i wanted particle
63:58 - size to be relative to particle's
64:00 - current speed
64:02 - i'm trying to build a fire effect now i
64:05 - need to get the right size here
64:11 - install css i apply css filters
64:17 - i will use blur 2 pixels and then i
64:20 - sharpen it with contrast
64:26 - contrast is just a number without pixels
64:37 - adjustment size on line 85 will affect
64:39 - how the fire looks like
64:43 - what variations can you come up with do
64:45 - you have any ideas how to tweak this
64:46 - effect and create something interesting
64:48 - let me know we can also use pixel array
64:51 - to turn text into particles in the next
64:53 - creative coding experiment i will show
64:55 - you how to create interactive particle
64:57 - text effect in three steps first i will
65:00 - create a set of particles randomly
65:02 - spread around canvas we will give them
65:05 - some physics i will try to give their
65:06 - movement some elasticity and physics by
65:09 - applying forces of friction and
65:11 - acceleration when they interact with
65:13 - mouse then in the next step i will write
65:15 - some text on canvas i will scan it with
65:18 - get image data
65:19 - and i will make particles take shape of
65:22 - these letters as the final third step i
65:24 - will apply constellations effect that
65:26 - was made famous by particles.js library
65:29 - but i will use no libraries we will
65:31 - write all the code using just plain
65:33 - vanilla javascript to achieve
65:35 - constellations effect we just have to
65:36 - calculate distance between each particle
65:39 - and connect particles that are close
65:41 - enough to each other with lines i think
65:43 - this effect looks really good what do
65:45 - you think let me know in the comments if
65:47 - you get stuck and need some help feel
65:49 - free to reach out to me on twitter or
65:50 - message me somewhere on my youtube
65:52 - channel i do a lot of creative coding
65:54 - experiments canvas animations and game
65:56 - development click like please
65:59 - in index.html i'll link css stylesheet
66:01 - create html5 canvas element with an id
66:04 - of canvas1 and ilinkscript.js file which
66:07 - will contain all javascript logic
66:10 - in style css i just do the basic reset
66:12 - to make sure the page appears the same
66:14 - in all browsers ask the risk selector to
66:16 - target all elements on the page and i
66:19 - set margin to 0 padding 0 and book size
66:22 - into border box border box means that
66:25 - elements padding and border will be
66:27 - included in its total width and height
66:29 - on the body element i set overflow to
66:31 - hidden to hide potential scroll bars and
66:34 - give it black background i choose to
66:36 - place the background on the body element
66:38 - instead on the canvas because this will
66:40 - allow us to use liquid or distortion svg
66:42 - filters if we choose to especially
66:44 - liquid filter only works if canvas
66:46 - background is transparent
66:48 - canvas will have position absolute job 0
66:51 - left 0
66:53 - everything else will be done with the
66:54 - javascript in script.js file
66:57 - i create a variable i call canvas and i
66:59 - set it equal to document getelementbyid
67:02 - canvas1
67:04 - ctx shortcut for context is equal to
67:06 - canvasgetcontext2d
67:08 - doing this will create a built-in
67:10 - context object that contains all kinds
67:12 - of 2d drawing methods that come built in
67:15 - in any browser using canvas api now i
67:18 - can call all of them using our ctx
67:20 - variable
67:22 - canvas width is the window in a width
67:24 - and canvas height is the window in a
67:26 - height
67:27 - this will make sure the canvas covers
67:28 - the entire browser window
67:33 - i create a variable called particle
67:35 - array and i set it equal to an empty
67:37 - array this will contain all our particle
67:40 - objects that each contains information
67:42 - like size color and coordinates
67:45 - and we will pull this information from
67:46 - here to draw them on canvas before we do
67:49 - that i will write some code to handle
67:51 - mouse interactions i create a custom
67:54 - variable i call for example mouse and i
67:56 - set it equal to javascript object
67:59 - by using curly brackets like this i give
68:01 - this custom object some properties x
68:03 - will be the current position of mouse on
68:05 - horizontal x-axis y will be positioned
68:08 - on the vertical y axis
68:10 - radius will be size of a circle area
68:12 - around the mouse within which the
68:14 - particles react to mouse
68:18 - i create an event listener it takes two
68:20 - attributes type of event to listen for
68:23 - and call back function to run every time
68:24 - that particular event occurs
68:27 - i want to listen for mouse move event
68:29 - and every time user moves the mouse
68:31 - within the browser window i want to run
68:33 - the following code callback function on
68:35 - event listener has one special thing
68:37 - about it it has access to built-in
68:39 - object that contains all different
68:41 - details about the event that is
68:43 - occurring
68:44 - all i need here are x and y coordinates
68:46 - of the event so that i can assign them
68:48 - dynamically to our customer mouse object
68:50 - i created on line 8. i need to assign
68:53 - them to the custom object to pull that
68:55 - coordinate information outside of event
68:57 - listener so i can use this information
68:59 - all over our application
69:02 - so as an argument to the callback
69:04 - function i write down event some people
69:06 - just put letter e here it doesn't really
69:08 - matter javascript knows this variable
69:10 - will stand for that built-in event
69:12 - object and will let you use it whatever
69:14 - you call it here as long as you refer to
69:16 - it using the same variable name later on
69:19 - so inside the callback function i set
69:21 - mousex which is property declared on
69:24 - line 9 to event.x and mouse y to event.y
69:28 - if you console.log event inside this
69:31 - event listener you will notice it is
69:32 - quite similar to our custom mouse object
69:34 - on line 9. the only difference is that
69:37 - it contains many more properties and it
69:38 - is only available inside an event
69:40 - listener that's why i am pulling the
69:42 - information from it here and sending it
69:45 - outside to our customer mouse object so
69:47 - that mouse coordinates are available all
69:49 - over our application wherever i might
69:51 - need them later on
69:54 - i can check if it works by console login
69:56 - mouse x and mouse y
69:59 - now if i move mouse over the canvas with
70:02 - open console i can see we are getting
70:04 - values great this is one of my favorite
70:07 - ways to handle mouse input it is useful
70:09 - for everything from generative art
70:11 - website interactions to games
70:14 - now let's draw some text on canvas ctx
70:17 - font properties sets the current font
70:19 - properties for text context on the
70:20 - canvas you can also set bold or italic
70:23 - here if you want
70:24 - then you put size and the last attribute
70:27 - will be font family let's just try 30
70:29 - pixels verdana for start
70:32 - now i call ctx filtex method
70:35 - which will just draw and fill text on
70:38 - canvas it expects at least three
70:40 - attributes the first one is the text we
70:42 - want to write
70:44 - i just put capital letter a for now
70:47 - the second one is x coordinate on canvas
70:49 - where you want to draw that text the
70:51 - third attribute is y coordinate
70:54 - there is also an optional fourth
70:56 - attribute where you can define max width
70:58 - of the text in pixels we will leave it
71:00 - empty for now but keep that in mind
71:03 - by default the text will be black unless
71:06 - you set it to any other color using fill
71:08 - style property so i call ctx fill style
71:10 - method and set it to white
71:16 - now we can see we are drawing our text
71:17 - at specified coordinates i can change it
71:20 - by adjusting its size on line 21 or its
71:23 - position on line 22.
71:26 - now what i want to do is to scan a small
71:29 - area of canvas around the white letter a
71:31 - analyze the pixels filter out pixels
71:34 - with no opacity because that's where the
71:36 - text is and only save those pixels that
71:39 - are not transparent into our particles
71:41 - array
71:42 - more specifically i want to save their x
71:44 - and y coordinates and i can also save
71:46 - their color values if i want to
71:49 - that way we can replicate the shape of
71:51 - letter with particles by using x and y
71:54 - coordinates of each pixel as coordinates
71:56 - for our particles
72:01 - remember that the black background is on
72:03 - body element so canvas is completely
72:05 - transparent with only letter a in white
72:07 - color to do this i just use another
72:09 - canvas method called get image data
72:13 - we used it before to turn image into
72:14 - particles in one of my all-time most
72:16 - popular videos and we will do something
72:18 - similar today with text
72:20 - official definition of this method is
72:22 - that it returns image data object
72:24 - representing the underlying pixel data
72:26 - of a specified portion of the canvas if
72:29 - i want to say it much simpler you give
72:31 - this method four coordinates for
72:33 - rectangular area somewhere on canvas it
72:35 - scans that area pixel by pixel and it
72:38 - saves coordinates and color information
72:40 - for each pixel inside of a huge data
72:43 - array
72:45 - since we know how the data is organized
72:47 - we can easily extract that information
72:49 - and use it for anything we want
72:51 - so i create a variable i call for
72:53 - example data
72:55 - and i set it equal to ctx.getimagedata
72:58 - and i pass it for attributes to tell it
73:00 - what part of canvas we want to scan
73:04 - i want to start from top left corner so
73:06 - coordinate 0 0 and i want to scan just
73:09 - small bit let's say square of 100 x 100
73:12 - pixels
73:13 - so i pass it with 100 height 100 which
73:16 - is somewhere around here
73:18 - if i want to visualize the area we
73:20 - scanned i can just stroke white
73:21 - rectangle there so we can see
73:23 - stroke style set to white
73:26 - stroke rectangle and i pass it the same
73:28 - area i passed to get image data method
73:30 - on line 25
73:37 - see this is the area we will be scanning
73:39 - so our data variable on line 25 will
73:41 - contain array with coordinates and color
73:43 - information for each pixel inside this
73:45 - small square okay let's delete this it
73:48 - was just so we can visualize what's
73:50 - going on
73:51 - now i need a way to create many similar
73:53 - particles that will each represent one
73:55 - interactive dot in our final effect
73:58 - for that i will use javascript class i
74:00 - call it particle with capital p
74:02 - each class has one mandatory method
74:04 - called a constructor
74:06 - constructor will run just once for each
74:08 - particle it will create a new blank
74:11 - object and assign it properties and
74:13 - values based on information i will
74:14 - declare inside of it
74:16 - it will serve as a blueprint
74:18 - our constructor will expect just two
74:20 - attributes x and y coordinates which
74:22 - will be different for each particle and
74:24 - we will pass them to the constructor
74:26 - from the outside to make it spell out
74:28 - our letters for the final effect
74:31 - inside i just say this dot x property on
74:34 - a new blank object you are creating is
74:36 - equal to x we passed as an attribute
74:40 - same for vertical y coordinate
74:42 - we will have other properties but these
74:44 - will be set or randomized here inside
74:46 - the constructor we don't need to add
74:48 - them from the outside so we don't need
74:50 - to pass them as arguments on line 26
74:55 - this dot size will be radius of each
74:57 - circle particle so let's try for example
74:59 - 3 pixels
75:02 - i will also set this to base x and set
75:05 - it to this dot x and this dot base y and
75:08 - set it to this dot y
75:10 - base x and base y properties will hold
75:13 - the initial position for each particle
75:15 - from the first time they appeared the
75:17 - reason for that is that we will be
75:19 - moving and pushing the particles around
75:21 - by changing their this dot x and this.y
75:23 - properties but i want each particle to
75:25 - remember where it came from so it can
75:27 - return to its original position when
75:29 - mouse interaction ends
75:31 - also i choose to set this.basex equal to
75:34 - this dot x property from line 27 instead
75:37 - of setting it to x attribute passed on
75:40 - line 26
75:41 - it will be the same but doing this will
75:43 - allow me to modify the starting position
75:45 - of this dot x on line 27 like this
75:48 - and our base x variable will remember
75:50 - that modified state
75:53 - it can be used for interesting
75:54 - distortion effects not sure if we do it
75:56 - today but there is no harm if we set up
75:58 - our code base for it anyway
76:01 - distal density will be a random number
76:03 - between 1 and 30. it will determine how
76:06 - heavy our particles are and how fast
76:09 - they move away from the mouse
76:11 - i want each particle to move slightly
76:13 - different speeds to simulate some
76:15 - physics
76:17 - so now the blueprint is complete we will
76:19 - also need a custom draw method each of
76:21 - our particles will have access to it
76:23 - because it will be sitting on the
76:24 - particle class
76:26 - this method will just take x and y and
76:28 - radius from the constructor and draw a
76:30 - circle there representing our particle
76:34 - i set fill style to white
76:37 - we are drawing a circle on canvas so i
76:38 - need to use ctx begin path method think
76:41 - of it as pencil touching down on canvas
76:43 - to start drawing
76:45 - i call canvas arc method and i pass it
76:48 - this dot x and this dot y coordinates
76:50 - this dot size will be radius of the
76:52 - circle
76:53 - start angle will be 0
76:55 - and end angle will be math.pi times 2
76:58 - which is value in radians that
77:00 - represents that actually converts to 360
77:03 - degrees so we have just drawn a circular
77:05 - path from 0 to 360 degrees which is a
77:09 - full circle if you change start angle
77:11 - and end angle values here you can use
77:13 - arc method to create half circle or even
77:15 - many other shapes
77:17 - i call close path and ctx fill to fill
77:20 - the path with white color
77:23 - now i create another custom function i
77:26 - call init its job is to take particle
77:28 - class we just created and call it many
77:31 - times the fill particle array with
77:33 - randomized particle objects
77:35 - first i will set particle array to an
77:37 - empty array in case it's not empty at
77:39 - the moment
77:41 - now i call push method which will take
77:43 - whatever we pass to it and pushes that
77:46 - to the end of the array we call it on
77:49 - i pass it new particle the new keyword
77:52 - is a special command in javascript it
77:54 - will call constructor of its associated
77:57 - class in our case it will go
77:59 - up to line 26
78:01 - create one new blank object
78:03 - and give it values and properties as
78:05 - described in the blueprint between lines
78:07 - 27 and 32.
78:11 - on the line 26 we can see our
78:13 - constructor expects x and y coordinates
78:15 - as attributes so here on line 45 i pass
78:18 - it 50 50 as coordinates for now
78:23 - now i call init to push one particle
78:25 - into the array
78:27 - i count lock particle array to see if it
78:29 - works
78:31 - i need to comment outline 17 that's
78:33 - still log in our mouse position
78:36 - yes
78:37 - now i can see the array contains one
78:39 - particle
78:40 - i can add another one at coordinates 80
78:43 - and 50.
78:47 - and now we have two particles in our
78:49 - array
78:50 - i create a custom function i call
78:52 - animate which will handle animation loop
78:55 - first i call ctx clear rectangle and
78:57 - pass it canvas dimensions to clear the
78:59 - entire canvas between every frame of
79:01 - animation
79:04 - i create a for loop that will cycle
79:06 - through the entire particles array and
79:07 - for each particle object inside that
79:10 - array it will call its custom draw
79:12 - method we declared on line 34.
79:15 - the last thing i need to do is to call
79:17 - requestanimationframe and pass it
79:18 - animate the name of its parent function
79:21 - this way animate will run all of its
79:23 - code and it will call itself again over
79:27 - and over create an animation loop so far
79:29 - i have just declared animate i also need
79:31 - to call it to start our animation loop
79:35 - it is not drawing our particles and in
79:37 - console i can see we have error on line
79:39 - 37 where i misspelled arc
79:44 - fixed now we are drawing two particles
79:46 - as i declare them on line 45 and 46.
79:50 - i can change their x and y coordinates
79:52 - and you can see they will move around as
79:54 - i change these values
79:56 - so instead of calling the particles
79:58 - individually like this i create a for
80:00 - loop that will run for example 10 times
80:04 - i comment out the two individual
80:06 - particles and inside the for loop i do
80:08 - the same thing particle array push and i
80:11 - pass it new particle
80:13 - it expects x and y coordinates so i will
80:16 - create a temporary x variable
80:18 - its only job is to generate random
80:20 - number between 0 and 500
80:23 - i do the same for y coordinate
80:26 - now i call new particle and i pass it
80:28 - temporary x and y variables i have just
80:30 - created on line 46 and 47.
80:35 - you can see we are drawing 10 randomized
80:37 - particles because for loop on line 45
80:40 - runs 10 times
80:42 - if i want the particles to be randomly
80:44 - spread all around the canvas i can set x
80:46 - to a random number between 0 and canvas
80:48 - width
80:50 - and temporary y variable to a random
80:52 - number between 0 and canvas height
80:55 - now our entire canvas is covered with
80:57 - particles i increase the amount of
80:59 - particles to let's try 500.
81:03 - well done we have base structure for our
81:05 - generative art project in place
81:08 - first we declare global variables
81:10 - then created object to store mouse
81:13 - coordinates
81:14 - then on line 25 we create a blueprint
81:17 - that will be used to create particles
81:20 - function init online 43 will use that
81:23 - blueprint to fill particle array with
81:25 - particle objects
81:26 - and lastly we created animation loop on
81:29 - line 56 which is running over and over
81:31 - and redrawing our canvas for every frame
81:34 - even though it looks static now we are
81:36 - actually drawing the same thing over and
81:38 - over
81:39 - let's make it move now
81:42 - on line 35 i can change color let's try
81:45 - red
81:48 - i create another custom method i call
81:49 - update its job is to calculate distance
81:52 - between current mouse position and
81:53 - current particle position if they are
81:56 - close enough i want particles to be
81:57 - pushed away from the mouse
82:00 - now i will show you how to calculate the
82:01 - distance between two points this can be
82:03 - used for creative coding and it is also
82:05 - very useful for games let's calculate
82:08 - distance between two points on the
82:09 - horizontal x-axis first i will call this
82:12 - variable dx
82:14 - it is simply the difference between
82:15 - their position on x-axis
82:17 - let's say if mouse position x was 50
82:20 - and particle position x was 30 dx will
82:23 - be 50 minus 30 which is 20. simple is
82:26 - just the difference
82:28 - same for dui which is the difference
82:30 - between position of two elements we are
82:31 - comparing vertically
82:33 - we are comparing mouse against all
82:35 - particles one by one so d y is mouse dot
82:38 - y minus this dot y
82:40 - this dot y stands for each individual
82:42 - particle as we cycle through all of them
82:45 - one by one imagine these two values we
82:48 - have just calculated create a right
82:50 - angle triangle between mouse and
82:52 - particle
82:53 - we have dx side
82:55 - we have a d y side of the triangle
82:58 - and we know there is a right angle
83:00 - between them so 90 degrees
83:02 - we can get distance between these two
83:04 - points by calculating the longest side
83:06 - of the triangle
83:08 - opposite to the right angle it is also
83:10 - called hypotenuse
83:12 - there is a built-in method hypotenuse
83:14 - method in javascript but today i will
83:16 - just use pythagoras theorem to calculate
83:18 - it we have two sides of right angle
83:21 - triangle and we know there is a 90
83:24 - degree angle between them
83:26 - we need to calculate the third side
83:29 - and that will be the distance between
83:30 - two points which is what we need formula
83:34 - is mod square root dx times dx plus dy
83:38 - times dy which also is which is the same
83:41 - thing as mod square root dx squared plus
83:45 - dy squared
83:47 - since this is calculated inside update
83:49 - method on particle object each particle
83:51 - will always be aware of how far away it
83:54 - is from a mouse so here i can say if
83:56 - distance between particle and mouse is
83:59 - less than 500 run this code
84:02 - if particles are closer to mouse than
84:04 - 500 i will set their size to 50 pixels
84:08 - else digital size will return back to 3
84:11 - which is the original value
84:12 - we declared on line 29
84:15 - to run this code i need to go inside
84:17 - animation loop and on line 68 inside for
84:19 - loop that cycles through the entire
84:21 - particles array for every frame of
84:23 - animation the same way i call draw
84:25 - method for every particle i will also
84:27 - call update the method we have just
84:29 - created
84:31 - and you see it works
84:33 - now i can change the distance particles
84:35 - react to mouse here on line 45
84:38 - i can also create more particles on line
84:40 - 55.
84:45 - now you can see the distance is being
84:47 - correctly calculated and we have a nice
84:49 - boilerplate for creative particle effect
84:55 - we can do so many things now maybe if
84:57 - you want before we continue you can save
84:58 - and copy this code base in a different
85:00 - folder and experiment with it later on
85:02 - it's always good to have the base setup
85:04 - stored away somewhere and now you can
85:06 - just focus on your experiments
85:09 - so what i want to do now is for
85:11 - particles that are close to mouse to
85:13 - start moving away from it i want them to
85:16 - move from the center point of the circle
85:18 - towards the edge
85:19 - i also want particles to move at
85:21 - different speeds depending on their
85:23 - weight
85:24 - we defined earlier when we assigned this
85:26 - density property inside particle class
85:29 - constructor
85:30 - and third thing i want to happen is for
85:32 - particles to move fast if they are close
85:34 - to mouse but gradually slow down
85:38 - the closer they are to the outer edge of
85:40 - circular interaction area until they
85:42 - reach speed of zero
85:44 - when they touch the outer edge basically
85:46 - we will introduce some basic physics to
85:48 - particle movement this might sound like
85:50 - a complicated thing to do with code but
85:52 - i will show you a nice calculation that
85:54 - can do all of this for us
85:56 - i create a variable i call force
85:58 - direction x
85:59 - and i set it equal to dx divided by
86:02 - distance
86:04 - force direction y will be d y divided by
86:06 - distance
86:09 - on line 48 if particles are closer to
86:11 - the mouse than 300 pixels i will add
86:14 - force direction x to particles current x
86:16 - position
86:17 - and force direction y to particles
86:20 - current y position
86:22 - this will just make them slowly move
86:24 - towards the mouse
86:26 - if i multiply these values by let's say
86:29 - 3 it will make the movement faster
86:36 - now i want to set a distance past which
86:38 - particle's movement speed is zero so i
86:41 - create another variable i call it max
86:43 - distance
86:45 - it will be equal to mouse.radius we
86:47 - declared on line 11.
86:50 - any particle that is more distant from
86:52 - the current mouse position than this
86:54 - will stop moving
86:57 - this calculation i'm about to do takes
86:59 - any range of numbers and converts it to
87:01 - a range between 1 and 0. it will convert
87:04 - values between 0 and max distance into a
87:07 - range of 1 to 0 just so i can multiply
87:10 - values on line 51 and 52 by this number
87:14 - and get the particles to slow down as
87:16 - the distance between them and mouse
87:17 - increases until they reach speed 0 as
87:20 - they reach the outer radius of
87:22 - interaction's circle around the mouse
87:26 - so i will call that variable for example
87:28 - force
87:31 - all i want to do now is to take number
87:33 - range of 0 to 250 and convert it to
87:37 - number between 1 and 0
87:40 - depending on where on range between
87:42 - these two values the number is
87:44 - 0 is particle with a distance zero from
87:47 - the mouse
87:48 - so it will be touching the mouse i want
87:50 - this number to be converted to one so i
87:53 - can multiply current particle speed by
87:55 - this which will make the particle move
87:57 - at its full speed
87:59 - the second side of that range is number
88:01 - 250 which is represented
88:04 - by max distance variable i want any
88:06 - particle that are further away from the
88:08 - mouse than this to have speed 0
88:11 - so they stop moving let's say there is a
88:14 - particle halfway between 0 and 250 so
88:18 - this particle is roughly halfway between
88:20 - these values it is 125 pixels away from
88:23 - the mouse
88:24 - at that point i want that particle to be
88:27 - moving at 50 speed so i need force
88:30 - variable to be equal to 0.5 at that
88:33 - point
88:34 - if i multiply current speed times 0.5 it
88:37 - will move at 50 speed
88:40 - when particle reaches 80 percent towards
88:42 - the outer edge of interaction circle i
88:44 - want it to move at 20 speed so i want
88:47 - force to be 0.2
88:49 - when particle is at 90 percent i want it
88:52 - to be moving only at 10 percent of its
88:54 - original speed and so on
88:56 - to get this behavior i need to convert
88:58 - range between 0 and 250 or whatever max
89:02 - distance variable
89:03 - is on line 48
89:05 - i want to convert this range
89:07 - to a smaller range between 1 and 0.
89:10 - once i have that value i will multiply
89:12 - it times particle speed
89:15 - and it will cause particles to slow down
89:17 - in proportions to its current distance
89:19 - from the mouse
89:20 - you can already see the calculation i
89:23 - say max distance minus current distance
89:25 - to see how far particle currently is
89:27 - from the max distance area
89:29 - and once i have that value i divide it
89:32 - by max distance again which will tell me
89:35 - what proportion of max distance it is
89:37 - quick example if max distance is 100
89:40 - pixels and particles current distance
89:43 - from mouse was 20 pixels
89:45 - max distance minus current distance
89:47 - would be 80.
89:49 - then
89:50 - 80 divided by 100 is 0.8
89:54 - so our force would be 0.8
89:57 - basically anything multiplied times 0.8
90:01 - is 20 percent less so it will slow our
90:03 - particle down by 20 percent
90:05 - i'm not sure if this is just me or this
90:07 - is quite difficult mathematical
90:09 - operation to understand it took me a
90:10 - very long time to work this out
90:13 - i will get back to this again and try to
90:14 - explain it better next time we use it
90:16 - let me know in the comments if it's
90:18 - unclear and we can talk about it
90:21 - so now i have the force which is the
90:23 - multiplier that will be slowing
90:25 - particles down as they get further away
90:27 - from the mouse
90:28 - i create a variable called direction x
90:30 - which will combine all factors that play
90:32 - a role in particle's movement speed
90:36 - direction x is equal to force direction
90:38 - x on line 46 times force we just
90:41 - calculated on line 49 times this dot
90:45 - density from line 33. i add this to
90:49 - density into the mix because i also want
90:51 - individual particles to have different
90:53 - mass and i want that value to affect
90:55 - their movement speed
90:57 - it will look more natural
90:59 - otherwise all particles will move the
91:01 - same speed as
91:02 - particles around it
91:07 - i do the same thing for direction y it
91:09 - will be equal to force direction y from
91:11 - line 47 times force which will cause it
91:14 - to slow down as it moves further away
91:16 - from the mouse times distal density
91:19 - which is individual and different for
91:20 - each particle
91:22 - it's a random number between 1 and 31 as
91:24 - we declared on line 33.
91:29 - now on line 53 i say if distance is more
91:32 - than mouse radius which we declared on
91:34 - line 11
91:36 - this dot x plus equals direction x
91:39 - variable from line 49 which combines all
91:42 - forces that pull and drag on our
91:44 - particle
91:47 - and i do the same thing for particles
91:48 - word
91:49 - and i do the same thing for particles
91:51 - vertical y position this dot y plus
91:54 - equals direction y
91:56 - that was calculated on line 50.
92:01 - it works yay
92:03 - particles move slow at first and speed
92:05 - up as they get closer to the mouse the
92:07 - only problem is that i want them to be
92:09 - pushed away so i change plus sign to a
92:11 - minus sign
92:13 - on lines 53 and 54.
92:17 - yes this is good
92:19 - and this is how you implement quite
92:20 - complex physics with javascript i really
92:23 - like the movement and we will enhance it
92:25 - even further by the way this was the
92:27 - difficult part
92:31 - i am not sure why i put mouse radius
92:33 - here on line 17 inside mouse move event
92:36 - that's wrong i will just delete that
92:40 - radius is set to 450 pixels on line 11.
92:44 - if you look closely particles move at
92:46 - full speed when they are close to the
92:48 - mouse
92:48 - and when they get close to the outer
92:50 - edge of interaction circle they move
92:52 - slower and slower until they stop
92:58 - i can make them move faster by changing
93:00 - density
93:01 - let's try range between 50 and 200.
93:10 - you can change the movement speed by
93:11 - adjusting the range of values here on
93:13 - line 31.
93:16 - so on line 51 i check if distance
93:18 - between particles and mouse
93:21 - is smaller than a certain number defined
93:23 - in mouse radius
93:25 - if it is i push them away from the mouse
93:28 - as you can see particles stay where they
93:30 - are when mouse interaction ends i would
93:32 - like them to return to their original
93:34 - position
93:35 - so here on line 54
93:37 - in else statement i say if this.x is not
93:41 - equal
93:42 - to this.basex
93:44 - basex is defined on line 29 and it
93:46 - captures the initial position of each
93:48 - particle so if this dot x has changed
93:52 - because we pushed particles around
93:54 - and it is no longer equal to base x
93:56 - which is particles original position
93:58 - i will calculate distance between this
94:00 - dot x which is particles current
94:02 - position
94:03 - and
94:04 - this dot base x which is particles
94:06 - original position on the horizontal x
94:08 - axis
94:10 - once i know the difference
94:13 - i can just return particle to its
94:15 - original horizontal position by saying
94:17 - this dot x minus equals dx but to make
94:21 - particles move back slower i say dx
94:24 - divided by 10.
94:26 - it will eventually get to its original
94:27 - position because this code is run for
94:30 - each frame of animation it will just get
94:32 - there slower also keep in mind we are
94:34 - currently inside else statement which
94:36 - will be entered only when particle is
94:38 - not close enough to the mouse so
94:40 - particles will only try to return to
94:42 - their original position once mouse
94:44 - moves far enough from them
94:47 - so this way we corrected particles
94:49 - horizontally
94:51 - we can also correct them vertically
94:54 - notice i don't do else if here i just do
94:56 - simple if statement because i don't want
94:58 - these to be mutually exclusive
95:03 - if particle has been displaced on x-axis
95:06 - and also on y-axis both of these
95:08 - statements will run for each frame of
95:10 - animation
95:11 - but also they can just run separately in
95:13 - case on the x axis or only y axis
95:16 - position needs to be corrected to return
95:18 - particle to its original position as we
95:21 - saved this original position in base x
95:23 - and base y variables so if this dot y is
95:26 - not equal to this dot base y i calculate
95:29 - d y value
95:31 - distance y value and i adjust this dot y
95:34 - by saying minus equals d y divided by
95:37 - 10.
95:38 - by changing values on line 57 and 61 i
95:41 - can change how fast particles return to
95:43 - their original position
95:46 - so this all works at the moment we are
95:48 - just spreading particles randomly around
95:49 - the entire canvas area by calculating
95:52 - random x and y values here on line 70
95:54 - and passing them as attributes to
95:56 - particles class constructor on line 72
96:00 - how do we make the particles spell out
96:01 - letters of text for that we use data
96:04 - variable we declared on line 22.
96:07 - here we call canvas image data
96:10 - inbuilt method that takes four
96:12 - attributes for a rectangular area of
96:14 - canvas we want to scan
96:16 - and it returns image data object that
96:19 - contains information like coordinates
96:21 - and color of the pixels from that area
96:23 - on canvas
96:26 - actually let me rename this variable for
96:28 - clarity i rename data to text
96:31 - coordinates so now this variable i
96:33 - called text coordinates holds whatever
96:36 - get image data method returned
96:43 - i go down inside our custom init
96:45 - function which at the moment runs a for
96:47 - loop thousand times each time it runs it
96:50 - calculates random x and y position and
96:52 - creates a particle there
96:54 - i delete all this code because we don't
96:56 - want our particles to be randomly
96:57 - distributed around canvas we have just
97:00 - scanned the part of canvas where we drew
97:02 - some text and now i will filter that
97:04 - returned object that resulted from our
97:06 - scan
97:07 - and i will remove all pixels with
97:09 - transparent background leaving only data
97:11 - points for pixels that contain color
97:13 - which will be coordinates for particles
97:15 - that make out our text effect keep in
97:18 - mind that canvas is transparent the
97:20 - black color you see is set on body
97:22 - element so the only pixels with color
97:24 - are the actual letters
97:26 - let's go through it step by step
97:29 - i create a for loop
97:31 - and i will do something a bit weird
97:33 - instead of just declaring one variable
97:35 - here as the first attribute i declare
97:37 - two variables
97:39 - i say let y equal 0
97:41 - comma y2 equals text coordinates dot
97:45 - height
97:46 - as long as y is less than y2 y plus plus
97:50 - this is almost a normal for loop two
97:52 - things to mention here
97:54 - first yes you can do this in javascript
97:56 - you can put more than one variable
97:57 - inside a for loop
97:59 - also
98:01 - i could have just declared y2 variable
98:02 - outside the for loop and it would work
98:04 - as well
98:06 - second thing is that i say y2 equals
98:08 - text coordinates height text coordinates
98:11 - holds
98:12 - image data object that resulted from a
98:15 - scanning small portion of canvas using
98:17 - get image data method
98:18 - this object has height property in
98:20 - pixels and since i want to scan the
98:22 - resultant pixel data line by line in
98:25 - this case row by row i will run this for
98:27 - loop for every row of pixel data we have
98:30 - so we declared two variables and i say
98:32 - as long as y is less than y2 y plus plus
98:36 - don't overthink this we just have two
98:37 - variables y will keep increasing until
98:40 - it reaches the same value as y2
98:42 - so our for loop will run until that
98:44 - happens
98:46 - so this is analyzing pixels row by row
98:48 - each time i enter row of pixels i want
98:50 - to go through them one by one from left
98:52 - to right so i create a nested for loop
98:55 - which simply is loop inside of another
98:57 - loop
98:58 - here i say let x equal 0
99:01 - x 2 is text coordinates width
99:04 - which is simply just width of scanned
99:06 - area in pixels in this case we scanned
99:08 - rectangle 100 times 100 pixels as you
99:10 - can see on line 22.
99:13 - so
99:14 - text coordinates height is 100 text
99:16 - coordinates width is 100 as well
99:19 - this outer for loop will run 100 times
99:21 - and each time it runs it will run in a
99:23 - for loop 100 times so we're gonna
99:26 - analyze 100 times 100 10 000 pixels
99:30 - i will explain this further in a minute
99:32 - back on line 70 i say as long as x is
99:35 - less than x2 x plus plus
99:37 - this nested for loop might look
99:39 - complicated but all that's happening
99:40 - here is i have a grid of 100 times 100
99:42 - pixels i go through them row by row or
99:45 - 969 each time i enter one row i go
99:49 - through that row of pixels one by one
99:51 - until i reach the end
99:53 - in this case pixel number 100
99:56 - in for loop on line 70 will exit we jump
99:59 - back to the outer loop on line 69
100:02 - y will increase by 1 which will give us
100:04 - another row we enter in a loop on line
100:07 - 70 again and go through all the pixels
100:09 - on that new row from pixel 1 to pixel
100:12 - 100
100:13 - then we exit the inner loop again enter
100:15 - the outer loop
100:17 - increase y by one which gives us the
100:19 - next row and we do this for all 100 rows
100:22 - analyzing all 100 pixels in each row
100:25 - as i said we have 100 times 100 pixels
100:28 - because that's the area of canvas i have
100:30 - decided to scan using get image data
100:32 - method online 22.
100:36 - this nested loop basically allows us to
100:38 - cycle through every pixels in that
100:39 - hundred times 100 pixel area
100:42 - for each pixel i check if opacity of
100:44 - that pixel is more than 128
100:47 - i will explain what that means in a
100:48 - second text coordinates custom variable
100:51 - holds built-in image data object that
100:53 - was returned by get image data
100:55 - javascript method
100:57 - this object has built-in data property
100:59 - which is an array of elements that
101:01 - represent pixels from the scanned area
101:03 - of canvas
101:05 - we can look inside by console login text
101:07 - coordinates
101:09 - in the console i can see it holds image
101:11 - data object
101:13 - if i open it you can see that object has
101:16 - a data property
101:17 - and this data property holds data array
101:20 - with 40 000 elements
101:23 - more down you can also see that it has
101:26 - height and width properties set to 100
101:28 - which are the values we used in the
101:30 - nested for loops
101:33 - don't get scared this is very simple it
101:35 - is not a normal array if you look
101:37 - closely you will see this type of array
101:39 - is called something
101:41 - like
101:41 - uint8 clamped array
101:44 - if i simplify this it's a special type
101:46 - of array that can hold only numbers and
101:49 - those numbers are limited to a certain
101:51 - range you can say they are clamped
101:53 - each element in this array can only be a
101:55 - number between 0 and 255
102:00 - if you work with html and css you have
102:02 - seen rgba color declaration which looks
102:05 - like this
102:07 - any color can be created by combining
102:09 - different amounts of red green and blue
102:12 - and the range for each color is from 0
102:14 - to 255. one weird thing about this
102:18 - clamped array is that it also handles
102:20 - alpha or opacity this way so 0 alpha is
102:23 - invisible
102:24 - 255 alpha is fully visible
102:27 - this is different because in rgba color
102:29 - declaration opacity is a small number
102:31 - between 0 and 1.
102:34 - so why does this array have 40 000
102:36 - elements when the area we are scanning
102:38 - is 100 times 100 pixels and we know
102:41 - hundred times hundred is only ten
102:43 - thousand not forty thousand
102:45 - also remember that this is a special
102:47 - type of array called clamped array so
102:50 - every element it contains can only be a
102:52 - number between zero and two hundred and
102:54 - fifty-five again very simple explanation
102:57 - let's look back at our rgba color
102:59 - declaration each color is made out of
103:02 - four properties red green blue and alpha
103:05 - same with this clamped array data object
103:08 - the way it's organized is every four
103:10 - elements in that array
103:12 - represent these four color values for
103:14 - one pixel so color for pixel one is the
103:17 - first four numbers in this array color
103:19 - for pixel 2 is the next four numbers and
103:22 - so on that's why we have 40 000 numbers
103:25 - in this array and we only have 10 000
103:27 - pixels it's because we need four numbers
103:29 - to make one color each number is
103:31 - something between 0 and 255
103:34 - including the number for alpha opacity
103:39 - that's why online 70 i check if value is
103:41 - more than 128 which would be around 50
103:44 - opacity it's like halfway between 0 and
103:47 - 255
103:49 - roughly 50
103:51 - any pixels with more than 50 opacity
103:53 - will be added to our particle array
103:55 - each one will create a point in the
103:57 - final font shape
104:00 - to extract these values we have our
104:02 - nested for loops if particle passed
104:04 - check here inside if statement i create
104:07 - a temporary variable i call it for
104:09 - example position x and i set it equal to
104:12 - x which is the variable from line 70 and
104:14 - it represents number of pixels in a row
104:17 - that passed our opacity check
104:20 - i do the same for position y which will
104:22 - be equal to y from line 69 which
104:25 - represents a row
104:26 - vertical position of that pixel we are
104:29 - analyzing right now
104:32 - so in terms of x and y coordinates it's
104:34 - a vertical position of pixel that passed
104:37 - our opacity check
104:40 - so i cycle through all pixels i check
104:42 - their opacity value and if their opacity
104:44 - is more than 50
104:46 - i capture their coordinates in temporary
104:49 - variables position x and position y
104:52 - and i call push on particle array which
104:54 - is my custom array i created to hold
104:56 - particles for my effect
104:59 - push method just takes whatever we pass
105:01 - to it and places it at the end of array
105:03 - so i pass it new particle which we'll
105:06 - call particle class constructor that
105:08 - uses es6 class blueprint we created
105:10 - earlier and creates a blank object and
105:13 - assigns it values and properties based
105:15 - on the rules we declared in the
105:16 - blueprint
105:18 - our particular class constructor expects
105:20 - two values to come from the outside for
105:22 - x and y coordinates so i pass it
105:24 - position x and position y variables from
105:27 - lines 72 and
105:29 - remember that this code runs only when
105:31 - opacity is more than 50 so only these
105:34 - particles from the scanned area will be
105:36 - added to our array
105:38 - there is just one more little problem to
105:40 - sort out as i said clamped array that is
105:42 - held in text coordinates data object
105:44 - contains four elements for each pixel
105:47 - we have ten thousand pixels but this
105:49 - array has forty thousand elements it
105:52 - holds a value for red green blue and
105:54 - alpha for each pixel
105:56 - right now i am just checking one pixel
105:58 - because i passed index one in that array
106:01 - inside square brackets here
106:03 - what i want to do is to cycle through
106:04 - the entire data array and take every
106:07 - fourth value because i know every fourth
106:09 - value stands for opacity for each pixel
106:12 - it's always red value green value blue
106:15 - value
106:16 - opacity value and so on
106:19 - so i need to replace one
106:21 - with some code that will allow us to
106:23 - skip three elements check the fourth one
106:26 - skip another three elements check the
106:27 - next one and so on
106:30 - one way to do this is i say in brackets
106:33 - y times four times data with
106:36 - plus x times four
106:39 - plus three
106:41 - remember that we are inside a for loop
106:42 - so y will be one then two then three as
106:45 - we cycle through rows and x will be one
106:48 - two three as four loop cycles through
106:50 - pixels in each individual row
106:53 - this calculation is not very intuitive
106:56 - just know what i'm doing is i'm cycling
106:58 - through 40 000 elements and always
107:00 - skipping three and checking the fourth
107:02 - one
107:03 - i am not a math expert so this took me
107:05 - forever to understand but i think for
107:07 - now it's good enough for us just to show
107:09 - just so you know what i'm doing
107:12 - i'm sure there are simple calculations
107:13 - to lock every fourth item in an array
107:15 - anyway i will explore it more when we
107:17 - use this technique next time that's it
107:20 - this is how you scan portion of canvas
107:22 - filter out pixels with no opacity and
107:25 - save their coordinates in your own data
107:27 - array
107:28 - since the font we scanned is very small
107:31 - as you can see here we don't want our
107:33 - particles to cover this small area we
107:36 - want to spread them out evenly while
107:38 - keeping the shape of our letter a so
107:40 - here on line 74 i just multiply position
107:43 - x times 10
107:46 - and position y times 10.
107:51 - i made a small mistake on line 71.
107:54 - earlier i renamed data to text
107:56 - coordinates but here i still refer to it
107:58 - as data let me fix that
108:02 - and we are drawing particles in the
108:04 - shape of a letter a well done this is
108:06 - some advanced coding
108:09 - i can change spread of the particles and
108:11 - therefore size of particle text by
108:13 - adjusting values here on line 74.
108:18 - since we are taking particles from
108:19 - certain area and multiplying their
108:21 - coordinates to spread them around it's
108:23 - not that easy to move the text left and
108:26 - right
108:26 - but i can still do that by adding
108:28 - adjustment variable here on line 72
108:32 - and also on line 73
108:35 - i call them adjust x and adjust y
108:39 - and up here on line 6 i declare them
108:42 - and let's push x
108:44 - 10 pixels to the right
108:47 - and why 10 pixels down
108:50 - now you can move your particle text
108:52 - shape around anywhere you want by
108:54 - adjusting these two values
109:01 - size of the effect can be changed here
109:03 - on line 76
109:06 - let me just center it in the middle
109:11 - and of course you can change the text we
109:13 - draw here on line 23
109:15 - some of you might like this effect
109:16 - already but that's not all i also want
109:18 - to connect particles that are close
109:20 - enough with lines similar to the famous
109:22 - particles.js constellations effect
109:25 - but on a text instead on random floating
109:28 - particles and instead of using a library
109:30 - we will write our code ourselves
109:41 - i create a custom function i call
109:43 - connect its job will be just a cycle
109:46 - through the array of particles that make
109:47 - up our letter and measure distance
109:50 - between each particle if they are close
109:52 - enough we will take coordinates of the
109:54 - first particle and we draw a line to the
109:56 - coordinates of the second particle
109:58 - that's it
110:00 - click the like please if you're getting
110:01 - value from my tutorials
110:04 - so i create a for loop that cycles
110:06 - through the entire particles array
110:09 - since this for loop will have to run for
110:11 - every frame of animation let's optimize
110:13 - it a little bit
110:14 - normally i would just do nested for
110:16 - loops and i would compare every particle
110:18 - to every other particle in the same
110:20 - array but i don't have to do that the
110:22 - inner for loop only needs to cycle
110:24 - through the remaining particles in the
110:26 - array because all the particles before
110:27 - have already been compared in previous
110:29 - cycles of the outer for loop
110:31 - i'm not sure if i'm explaining it
110:33 - clearly but let's write some code and i
110:35 - will try again
110:37 - so in the inner nested for loop instead
110:39 - of cyclin through the entire particle
110:41 - array again just so i can compare every
110:44 - particle against every other particle
110:46 - i will only cycle through particles that
110:49 - have a higher index than a because
110:52 - anything with lower index has already
110:54 - been compared in previous cycles of the
110:56 - for loop
110:57 - so here i say let b is equal to a
111:02 - as long as b is less than particles
111:04 - array length b plus plus
111:07 - if you look at line 96 again when the
111:10 - outer loop runs for the first time it
111:12 - will cycle through the entire for loop
111:14 - in the outer loop and inside the inner
111:17 - loop as well but eventually when
111:19 - variable a in the outer loop reaches
111:22 - number let's say 50
111:24 - in the inner loop we say b is equal to a
111:27 - and we cycle only through particles from
111:29 - index 50 to the end of the array
111:32 - this will pair up all individual
111:34 - particles inside particles array
111:37 - all i need to do here is calculate their
111:39 - distance and say if distance is less
111:42 - than some value connect them with a line
111:45 - we have already calculated distance
111:47 - between mouse and particles on line 45
111:50 - so again it's exactly the same thing dx
111:52 - variable will hold distance between two
111:55 - elements we are comparing on the
111:56 - horizontal x-axis
111:59 - the ui variable will hold distance
112:01 - between two points in this case between
112:03 - particle a and particle b on vertical y
112:06 - axis
112:07 - this will give us two sides of right
112:09 - triangle and we know that the distance
112:11 - between these two points is hypotenuse
112:14 - the longest side of the right triangle
112:17 - the side that is opposite to the right
112:19 - angle
112:20 - to calculate it we can use pythagoras
112:22 - theorem formula which we learned in
112:24 - school a long time ago math square root
112:27 - from dx squared plus d y squared or in
112:31 - other words math square root from dx
112:33 - times dx plus dy times dy
112:37 - so to calculate dx distance of two
112:39 - particles on the x-axis i say particle
112:42 - array a x
112:45 - minus particle array b x
112:48 - a and b variables will be changing as we
112:50 - cycle through both for loops so this
112:52 - code will compare every particle against
112:54 - every other particle by the time the for
112:56 - loop has finished
112:58 - d y will be particles array a y minus
113:02 - particles array b y
113:05 - now we have two sides of imaginary right
113:07 - triangle and all we need to do to get
113:10 - distance between these two particles is
113:12 - to calculate hypotenuse so math square
113:15 - root dx squared plus d y squared
113:21 - now i can say if distance is less than
113:23 - 100 pixels
113:25 - i set stroke style to white because we
113:27 - want white lines
113:29 - line width will be 2 pixels for example
113:32 - on canvas line is the same as arc we
113:35 - used to draw circle it is considered to
113:37 - be a path so to start drawing i will
113:40 - have to call begin path
113:42 - to draw a line on canvas you need to
113:45 - call move2 method to set starting x and
113:48 - y coordinates
113:49 - and line 2 method to set target x and y
113:53 - coordinates when you do that a line will
113:55 - be drawn between these two points each
113:58 - point defined by two coordinates x and y
114:02 - so at first i call a ctx move to method
114:05 - which creates a starting point of a new
114:07 - path at coordinates we pass to it
114:10 - we are inside an if statement that only
114:13 - runs when two particles are close enough
114:15 - to each other so i just want to draw a
114:17 - line from one particle to another the
114:20 - starting point of the line will be x and
114:22 - y coordinates of particle a
114:25 - that passed our distance check
114:27 - then i call a line 2 inbuilt canvas
114:30 - method this method simply said creates a
114:33 - straight line from coordinates we pass
114:35 - to it to the last previous point inside
114:38 - the same path start and end of path on
114:41 - canvas will be defined by beginpath and
114:43 - close path method calls here
114:46 - so i call line 2 and i pass it x and y
114:49 - coordinates of particle b
114:51 - that passed the distance check
114:53 - now that you kind of understand how
114:55 - parts and lines work you might be able
114:57 - to see that we can keep drawing more and
114:59 - more paths
115:00 - like this and create custom complex
115:02 - shapes but i only want to draw a single
115:04 - line connecting particle a and particle
115:06 - b all you need to do to create the
115:08 - popular particles.js constellations
115:10 - effect with vanilla javascript is this
115:13 - code we just wrote from line 94 inside
115:16 - our custom connect function we have just
115:18 - declared a function we also need to call
115:20 - it inside our animation loop to actually
115:22 - run the code so on line 90 i call
115:25 - connect and here we go this is just the
115:28 - basic effect we can make it a little bit
115:30 - nicer than this here on line 105 you can
115:34 - change the distance limit the limit will
115:36 - determine maximum distance between
115:38 - particles that get connected by white
115:40 - line
115:48 - i think 50 looks pretty good but for you
115:50 - it might be slightly different number
115:51 - depending on your base font and how much
115:53 - you decided to scale your particle shape
115:55 - earlier just try different numbers here
115:57 - and see what you like one important
115:59 - visual thing that particles.js library
116:01 - does is that the lines are not always
116:03 - fully visible they don't just appear and
116:05 - disappear as particles move closer and
116:08 - away from each other lines slowly fade
116:10 - away and slowly appear again basically
116:12 - opacity of the lines is dynamically
116:14 - calculated based on the distance between
116:16 - particles
116:18 - it looks much cleaner that way to do
116:20 - this in our custom code base is very
116:22 - simple on line 96 i create a new
116:24 - variable called opacity value and
116:26 - initially i set it to 1 full visibility
116:30 - then here on line 107 i set stroke style
116:34 - to rgba color declaration
116:36 - rgb value for white is 255 255 255 and i
116:41 - will concatenate opacity value variable
116:44 - as the last fourth attribute for opacity
116:47 - like this now we have a variable that
116:49 - can dynamically change an opacity of
116:51 - lines will change with it to make
116:53 - opacity proportionate to the current
116:55 - distance between particle a and particle
116:57 - b i run this strange formula basically
117:00 - what i want is if distance is close to
117:02 - zero particles are very close to each
117:04 - other so i want opacity to be close to
117:07 - one
117:08 - as the distance between particles
117:10 - increases i want to decrease the opacity
117:12 - value until particles are far enough and
117:14 - opacity will be 0. there are many ways
117:17 - to do this simple way is to say 1 which
117:20 - is full opacity full visibility so lines
117:23 - are visible
117:24 - minus distance divided by 50. notice
117:27 - that i divided by the same number don't
117:30 - overthink this let me give you two
117:31 - examples if distance is zero
117:35 - particles are close line is fully
117:37 - visible
117:38 - on the other hand if distance is 50
117:41 - 1 minus 50 divided by 50
117:44 - is 1 minus 1 so 0
117:47 - lines are invisible when the distance
117:50 - between particle a and particle b
117:52 - reaches 50 or whatever you set the limit
117:55 - to
117:56 - if you want particles to have zero
117:58 - opacity when they reach maximum distance
118:00 - keep these two numbers on lines 106 and
118:03 - 107 the same if you change distance to
118:07 - 100 change the formula on line 107 200
118:10 - as well and the effect will work the
118:12 - same lines will still disappear when
118:14 - they reach or get very close to maximum
118:17 - distance
118:19 - here i am struggling a bit because i
118:20 - didn't notice i forgot one comma on line
118:23 - 108 inside rgba color declaration just
118:26 - bear with me a bit nothing is changing
118:28 - about the code i'm just trying to find
118:29 - the problem
118:32 - now i notice the missing comma and
118:33 - suddenly everything works
118:38 - what i will do now i will copy these two
118:41 - lines and place them outside the if
118:42 - statement which thinking back was not
118:45 - necessary because lines are only drawn
118:47 - if we enter the if statement on line
118:49 - 107.
118:52 - now i just restore the formula to
118:54 - dynamically calculate opacity on line
118:56 - 105 and the base effect is a ton
119:01 - there are many tweaks that can be done
119:03 - now to achieve different results hope
119:05 - you had fun coding with me today if you
119:07 - did let me know what you've built html
119:09 - canvas is a powerful tool and it allows
119:11 - us to do so many things these days good
119:13 - luck with your coding studies i hope to
119:15 - see you again for more creative coding
119:17 - experiments
119:20 - [Music]

Cleaned transcript:

today i want to show you something you might not have seen before in this course we will use html5 canvas element and plain vanilla javascript to create interactive animated particle effects we will start with a very simple project where we learn about the draw image and get image data built in canvas methods and how to use them to create a pixel array then we take it to the next level and use that pixel array data to make our particles do amazing things let me show you the real power of html canvas using just basic fundamental javascript tools and techniques if you get stuck or you need some help with the code we are about to write you can message me on twitter or catch me somewhere on my youtube channel special thanks to bo from freecodecamp for letting me share this course with you i hope you get some value out of this let me take you through the code step by step and explain how to use html canvas to create beautiful things in index.html i create html canvas element with an id of canvas 1. i link style css and script.js files in style css i target the body element and give it black background canvas will have border solid white top 50 left 50 position absolute width 800 pixels and height 450 pixels transform translate minus 50 to minus 50 will center our absolutely positioned canvas element both vertically and horizontally in script js the usual basic canvas setup constant variable i call canvas is equal to document.getelementbyid and i pass it id i gave it in index html which was canvas one constant ctx shortcut for context equals canvas variable from line 1 dot get context 2d this way i make my ctx variable an instance of canvas 2d api object and i can call all builtin canvas methods on this variable now such as ctx fill rectangle to draw a rectangle and so on canvas width will be 800 and canvas height will be 450. these values need to be the same as values we set for canvas in css file to make sure we get the correct scaling i will bring an image with dimensions of 800 times 450 pixels to my project first i create a custom variable i call for example image 1 and i set it equal to new image new is a special keyword in javascript and image with capital i is a special builtin class constructor doing this will just create a new blank object and assign it values and properties based on builtin javascript image blueprint simply said we just created blank new image object that comes with src property if you consulate image 1 you will see it i set this src source property to path to my own image like this image 1 src equals image1png for you the path might be different remember that the path must be relative to wherever you placed your script.js file inside your project structure for javascript to be able to see your image now i will try to draw the image by using builtin draw image method if i just give it three arguments like this the first one is the image i want to draw so my image one variable from line six the second argument is the x coordinate and the third one is vertical y coordinate where i want to draw it on canvas i want the image to start from coordinates 0 0 which is the top left corner the reason the canvas is still blank and no image has been drawn is because javascript code runs very fast even though the image loads relatively fast as well it is not yet loaded when draw image method runs i have to take variable image 1 from line 6 and since i gave it src attribute on line 7 i can give it event listener for load event image 1 add event listener and when a load event occurs which means after the image has been fully loaded only then run the following code i placed inside the callback function if i put the draw image method inside this callback function the image will be drawn so this was the first issue we face when handling images on canvas solved draw image builtin method has three versions depending on how many arguments we pass to it we use the shortest one here with only three arguments we can also pass it five arguments where the fourth and the fifth one stand for width and height of the image my image is exactly the same size as my canvas so i don't need it but if your image is a different size you can give it different width and height doing that you can scale your image however you want by passing it different values here the third version of draw image method takes nine arguments and we can use it to crop out pieces of a sprite sheet for example like we did in my game development series to create animated characters we will not do that today i want to know colors of each individual pixel that makes up this image html canvas provides us with a builtin method that can do just that i create a constant variable called scannedimage and i set it equal to ctx.getimagedata this method takes four arguments which define what area of canvas i want to scan for pixel information i want to scan the entire canvas so i pass it 0 0 for starting coordinates and canvas width and canvas height for the end coordinates this method scans all pixels on canvas it goes from left to right row by row from top to bottom the order is important if you want to determine coordinates for each pixel it scans all pixels and it returns image data object if i console lock my scanned image variable we can see that object here let's open it and we can see it contains something called data which is an array we also have height and width properties which correspond with the size of an area i scanned with the get image data method and it also has some prototype methods which are not important now if i open data we can see it's a massive array but it's not a regular javascript array i can see it is called something like uint8 clamped array and it contains one million four hundred and forty thousand elements uint eight clamped array is a special type of array it is very simple basically each of its elements has to be a number from a certain range it can only contain numbers between 0 and 255 if you used css before you remember rgb color declaration and you will know that any color can be declared by combining three numbers between 0 and 255 and that's what this is we are basically looking at color values uh numbers that make up colors of each individual pixel but it is a bit strange because each element in the array contains only one number and we actually need four numbers red green and blue and alpha for opacity the way this array is structured is that each pixel is spread into four elements so the first four elements in the array combined are rgba color value for the first pixel the next four values are rgba for the second pixel and so on i can see that this array has one million four hundred and forty thousand elements now that we know that four elements make one pixel i also know that my image is made out of one million four hundred and forty thousand divided by four which is three hundred and sixty thousand pixels it makes complete sense because my image is eight hundred times four hundred and fifty pixels in width and height and 800 times 450 is also 360 thousand these pixels are organized in rows from left to right starting at the top left corner so the first pixel is 1 70 139 1 is right 70 is green 139 is blue so that's rgb and alpha of this pixel is 247 alpha or opacity in this array is also declared in a range between 0 which is invisible to 255 which is fully visible that's one thing that's different from the standard rgba color declaration we use in css where alpha is a number between 0 and 1. i was able to scan my image with no issues but in some browsers due to crossorigin resource sharing security you will get an error that says something like canvas has been tainted by crossorigin content and we cannot scan it for image data i don't really know if people can actually put viruses in images or something chrome for example considers your locally stored images as crossorigin unless you run this code through a server if you ever experience this problem when scanning image data with a get image data method for your creative coding projects instead of trying to navigate through server settings and so on there is an easy work around you can actually convert any image into data string and place that string directly into your file this will avoid all crossorigin resource sharing issues we can convert an image into data string using two data url built in javascript method just by calling it on the image but today i will just do it using this quick free online tool if you google png to base64 this will also work on jpeg images and other types by the way not just pngs i go to this address onlinepngtools.com convert png to base64 you can just drag and drop your image here it doesn't have to be in png format on the right hand side it will generate base64 string that contains all data we need to draw this image with javascript without needing the actual image file if your string doesn't start with data colon image like mine does make sure you tick this checkbox down here that says create a valid data image url so i just copy this huge long string in script js on line 7 instead of using the image file as a source if you ever get tainted canvas error in console just replace the path to the image with this long data string and it will fix everything it will give me exactly the same image like this you can see in the console that it contains identical image data and everything it is the same image so as i said this data array i see in console when i console log my scan image variable contains all pixel that make up my image the image was scanned from top left corner going left to right row by row and every set of four elements in this array contains rgba values for one pixel this is all i need to manipulate colors in my image i can save that pixel array in a separate variable if i want let's call it scanned data and it's equal to scanned image from line 12 dot data which is the uint8 cloud array we see in the console i can for example create a for loop that will cycle through the entire array notice i don't do i plus plus at the end but i do i plus equals 4 because i know each time we skip by 4 we have new pixel so first i will be 0 because arrays start from 0 not from 1 then the second will be 4 then 8 and so on let's make our image grayscale there is one strange thing going on with colors we know that any color is a combination of certain amount of red green and blue i'm not sure if you knew but if you take any value between 0 and 255 and assign the same value as red green and blue like this you will get a shade of gray from dark to very light this is not a canvas thing this is how rgb colors work in general so what i can do is take color value for each pixel calculate average and assign the same average value as red green and blue on that same pixel turning it to grayscale i create a constant variable called total which will be a sum of values for red green and blue we are jumping through the array four pixels at a time so scanned data i is always the red pixel value scanned data i plus 1 is always the green pixel and scanned data i plus 2 is always blue then there will be alpha and then we have another red and so on average color value is simply total sum divided by three because we achieved that sum by adding three numbers now i have the average color value and i need to assign that same value to all three colors in this pixel to turn it into grayscale so scanned data i red pixel is equal to average color value variable from line 17 scanned data i plus 1 green pixel is gonna be the same average color value and also blue pixel scanned data i plus 2 is equal to average color value now i reassigned color values in my scanned data array i declared on line 14 and i want to use it and override data array on the image so scanned image variable dot data i set its builtin data array to my altered array with grayscale colors now i use built input image data method which simply paints data from the given image data object onto the canvas i pass it my altered scanned image and i want it to be drawn from coordinates 0 0 we can also manipulate individual color levels like this for example i know there is a css filter property called grayscale that allows us to do this with one line of code but we wouldn't know how to scan image for pixel data and how to go from here to create more advanced particle effects which is exactly what we will do in the next episode this is why i wanted to take you through the basic concept slowly because once you have full mental picture of what's going on here you will be able to better understand the trick i will teach you next time where i make particles move at different speeds based on brightness of underlying image layer it's going to be more advanced than this but i will do my best to help you understand hope you are learning something new today if you do click the like please so now we understand how to draw image on canvas how to analyze it for pixel data and how to manipulate color values of these pixels let's take it one step further and use index of that pixel in pixel array to calculate its x and y position on canvas once we have that information we can do amazing things in this next part i will show you how to create simple particle system and we will make these particles flow over canvas based on data from an image we will make them move faster over dark areas and much slower over light areas we will remove all pixels and recreate the entire image from a stream of flowing particles let's start in index.html by creating html5 canvas element i give it id of canvas1 i also link css stylesheet and javascript file here in style css i use asterisk selector to target all elements on the page and i do global reset to make sure our styles are the same across different browsers margin 0 padding 0 box size and set to body box and let's also do black background i give canvas border 2 pixels solid white and i center it by setting its position 50 from top this will actually only work if i set its position to absolute left will also be fifty percent and transform translate minus fifty percent minus fifty percent will center it both vertically and horizontally i make the canvas exactly the same size as the image i will be using so for you it might be different my image is five hundred times 706 pixels everything else will be done with javascript in script js file i will start by bringing my image into the project so constant variable i call for example my image and i set it equal to new image now i can give it src property which could point to an image file but because some browsers don't like it when you analyze pixels of image with get image data when that image is not hosted on the same server to avoid all different kinds of cross crossorigin resource sharing errors i will convert our image into url string that way the image itself is part of javascript file and everything will work without errors we can use javascript to convert the image but for speed today let's use a website that will do it for us i google something like png to base64 and i choose this link my image can be any image format it doesn't have to be png here i can just drag and drop image i will be using my advice is to make the image as small as possible otherwise you will get a very long data string and since we need to be cycling through these pixels later with javascript smaller image will improve your performance also if you saw the final effect you don't need very fine image resolution for this effect to look great so i made my image as small as possible you can go even smaller if you are having any performance issues i drag and drop it here and i convert it to base 64. for us to be able to use it we need string to start with data colon image so make sure you tick this checkbox here now i copy this extremely long data string which just basically converted the entire image into a line of code so we won't need the actual image file at all i paste that code on line 2 to bring the image into our project now the usual canvas setup const canvas equals to document.getelementbyid and i pass it canvas 1 the id i gave it earlier ctx shortcut for context is equal to this canvas variable dot getcontext2d now we have access to all 2d canvas drawing methods i set canvas width and canvas height to be the same values i declared in style css to make sure the scaling is right now i draw the image on canvas by using builtin html canvas method called draw image it has three versions we will use the middle version of this method that expects five arguments the first is the image i want to draw so my image variable from line one i want the image to start from top left corner of canvas so coordinates 0 0 and i want it to cover the entire canvas area so end coordinates of image rectangle will be canvas with canvas height sometimes drawing your image this way will not work for you because the draw image method only works when image has been fully loaded to make sure we avoid any potential errors we can wrap this whole thing in event listener since we gave our image src property we can now listen for load event on it like this and in callback function only after the image has been fully loaded we run all the code that depends on that image i will just put everything inside like this why not we are now all set let's create a simple particle system that will produce a set of falling particles to flow over the image i create a led variable called particles array and i set it equal to an empty array i use led here so that i can reassign it to a new empty array later if i want to i create a constant variable called number of particles and i set it to let's say 5000 i create a javascript class called particle with capital p we will use it to create 5 000 similar particle data objects and we will push them inside particles array from line 12. constructor is a mandatory method on javascript class and it will contain blueprint for each individual particle this dot x horizontal x coordinate will be a random number between a zero and canvas width i want particles to kind of splash over the image from top so i set start and distance y horizontal coordinate to zero you can also do other things here maybe you want the particles to flow from bottom to top or from left to right or maybe you want them to spiral around in a circle you would adjust starting x and y based on the final effect you are going for falling speed will be 0 at first i will also have velocity which will be a random number between 0 and 0.5 basically here i have falling speed which will be calculated based on brightness of background so particles will fall over black areas very fast and over light areas of the image much slower velocity is here just to give it some additional randomness i think it will look good particles will have random size between 1 and 2.5 pixels for example update method will calculate particle position for each frame before we draw it let's start simply by adding plus one to a horizontal ycoordinate once particles fall below the bottom edge of canvas i want them to reset to position zero up top so they can fall down again at the same time i will also give them different random horizontal x position this is important because particles will fall slower over light areas of the image actually rather than to have all particles fall at the same speed we can randomize it a bit this dot y plus equals this dot velocity and velocity on line 20 is a random number between 0 and 3.5 custom draw method will simply just draw a circle to represent each particle begin path to start drawing fill style will be white ctx arc to draw a circle i pass it x and y size start angle and end angle then i call ctx fill to fill circular pathway color i create a custom function called init shortcut for initialize this function will just have a for loop that will run as many times depending on number of particles variable in this case 5000 each time it runs i call builtin push method on particles array from line 12. push method places whatever we pass to it at the end of the array so i pass it new particle the new keyword will trigger particle class constructor on line 16. it will create one new blank particle object and assign it properties and randomized values based on the blueprint for loop will run 5000 times filling particle array with 5000 randomized particle objects now i call init to fill the array function animate will be our main animation loop first i want a semitransparent black rectangle to be drawn over the canvas for every frame this will give particles fading trails i set global alpha to 0.05 this just specifies transparency value that is applied to shapes and images on canvas 0 is fully transparent one is fully opaque now i set fill style to rgb 0 0 0 which is black color i draw a rectangle that covers the entire canvas ctx fill rect starting coordinates 0 0 and in coordinates canvas with canvas height i will cycle through the entire particles array and for each particle object in the array i call their associated update method from line 23 and a draw method we declared on line 30. this for loop will cycle through all 5000 particles for each frame of animation it will recalculate their position with update method and it will draw them at their new coordinates with draw method now i just call animate to kick off animation loop this will not work because i also have to call a request animation frame here and i pass it animate request animation frame is a builtin javascript method when i pass it animate the name of its parent function from line 43 that way animate will run all its code and it will just call itself again here on line 51 create an animation loop through a programming principle called recursion when function calls itself over and over that worked now we have falling white particles that leave trials perfect i can temporarily copy draw image call from line 10 and i put it inside animation loop so that we can see the original image for now particles are falling and ignoring the image how do i make them fall at different speeds based on brightness of the area they are moving over one way to do that is to create a brightness map of the entire image it will correspond to x and y coordinates of each pixel then i can run this information against particle's current x and y position and adjust particle's speed based on its current coordinates let's do it step by step first i create a new led variable called mapped image this will be an empty array at first my goal is to have this array hold brightness value of each pixel in the image along with that pixels x and y coordinates so i can compare it to x and y coordinates of each particle and adjust their movement speed accordingly so on the first page load we just draw image on canvas here on line 10. i create a custom variable called for example pixels and i set it equal to ctx dot get image data built in canvas method this method scans area of canvas for pixel information and it will return an array like object that holds red green blue and alpha value for each individual pixel in the scanned area i want to scan the entire canvas so i pass it 0 0 as starting coordinates and canvas with canvas height as the end coordinates so now my custom pixels variable holds whatever get image data returned after scanning the designated area in our case the entire canvas if i count to lock pixels i see this returned image data object if i open it it contains array called data it also contains height and width attributes that correspond to width and height of the scanned area we scan the entire canvas so width and height correspond to canvas width and canvas height from lines 7 and 8. let's inspect the data array you can see it is called uint clamped array that means unassigned integer so it can only contain elements that are whole numbers with no decimal points it also says clamped because these numbers are limited to a range between 0 and 255 if you work with css before you know that in rgba color declaration every color can be declared by combination of red green and blue with values between 0 and 255 for each we established that each element in this data array could only be a number between 0 and 255. if you look at the data structure you can see that every 4 pixels in the array combined create rgba color declaration of 1 pixel in our image so this one for example is 0 for red 0 for green 0 for blue and 255 for alpha opacity in this case alpha is also declared as a value between 0 which is fully transparent to 255 fully opaque we can double check if you are right about this we have an array of 1 million four hundred and twelve thousand elements and we know that each four elements in this array represent rgba color value of one pixel so one million four hundred and twelve thousand divided by four is 350 000. these numbers depend on the size of the image you uploaded so for you it might be different we know the image i'm using is 500 pixels wide and 706 pixels high so 500 times 706 is also 353 000 so that checks out let's look at the pixels with color that are not black for example here we have 111 for red 83 for green blue and 255 for alpha then 139 is right of the next pixel and so on so now we understand how the color data returned by getimagedata method is organized we can cycle through it and save it in our own array and since we know width and height of the scanned area we can calculate x and ycoordinates of each pixel since we know how many pixels fit on one row and we know how many rows and how many columns our image has this is the only a bit more difficult part in this tutorial so if you are a beginner keep in mind this is not easy don't feel bad if you struggle to imagine what exactly is going on i made a beginner friendly version of this technique where we cycle through all pixels and turn image into grayscale sometimes it's easier to first try this with a simple project i will link it in the video description we will cycle through every pixel in this image row by row from left to right starting from the top left corner so the first for loop will have a vertical y coordinate at zero our image is 500 pixels wide so y will be 0 and x will be 0 1 2 3 all the way to 500 then we increase y to 1 and again we cycle through pixels 0 to 500 horizontally then we increase y to 2 and we cycle through the entire xcoordinate of pixels again we will do this 706 times because our image is 706 pixels high which means it contains 706 rows of horizontal pixels the code will look like this we will use nested for loops which means loop inside of another loop the outer loop will represent vertical y coordinate so it will run 706 times because our image is 706 pixels high which means we have 706 rows of pixels we will start with top row 0 and go all the way down to row 706 on the bottom for each row of pixels in the image i will create an array called row it will hold our pixel data for each of the rows for every one of these rows we enter the inner loop and index of this in loop will correspond to horizontal xcoordinate of pixel within the image starting from xcoordinate 0 and going to the right until we reach pixel 500 because our image is 500 pixels wide then we just exit the inner loop increase y by one therefore jump in to the next row and going through the horizontal pixels from left to right from zero to 500 again i'm not sure if i'm over explaining this or if you need me to explain it more let me know in the comments please i'm just trying to make it accessible for beginners as well so now we have two nested for loops that work together to cycle through every single pixel in the image for each individual pixel i want to read its color values so here i will create a temporary variables for red green and blue red for each pixel will be pixels variable from line 11 dot data which is this data object here with 1 million and twelve thousand elements where we know each four elements represent red green blue and alpha of one pixel there are many ways we can skip array index by four i will use this formula i'm sure there is easier way to do this let me know in the comments the first part that says y times 4 times pixel's width just keeps track of overall number of array elements from previous rows and the second part that says x times 4 just adds the items from the current row to it so the final number we get is array position of red value for pixel with this ycoordinate and this xcoordinate this is not programming anymore this is more like advanced logic and visualization i wish i had more visual tools to show you better what's going on i will try to come up with something for future tutorials in the meantime let's just finish this once we know what index red color value is it's easy to get green blue and alpha because we know that this data array is organized in a way where red is followed by green which is followed by blue and alpha since i know this i know that green is whatever red is plus one and blue is position of right in pixels array plus 2. so now i have calculated red green and blue of pixels at this vertical y coordinate and this horizontal x coordinate i could just add them together and divide them by 3 to get their average value which is the same technique we used to turn image into grayscale in the previous episode for beginners link in the video description there is a strange thing about human eye that we don't perceive red green and blue the same the same amount of red is not the same brightness as the same amount of blue when perceived by human eye we can create a simple utility function that will take red green and blue value we just calculated for each pixel it will adjust them by different amount based on human brightness perception and it will return a single number representing relative brightness of that pixel custom function called for example calculate relative brightness it will expect three arguments red green and blue we calculated on lines 20 21 and 22. it will just straight up return a number calculated by following formula i found this formula online we don't have to fully understand it because all it does it adjusts red green and blue by different amounts to make up for the fact that the human eye doesn't perceive these three colors the same when it comes to their relative brightness this is just for fun to make it more visually accurate i guess as i said this formula could have been a simple other red plus green plus blue divided by 3 to get average and it would work as well of course then you have to adjust the rest of the code like particle falling speed based on the range of numbers this would return up on line 23 i create a variable called brightness thanks to javascript principle called hoisting i can call my custom calculate relative brightness function i declared on line 27 up here on line 23 before that function is declared hosting allows us to do that it expects three arguments so i pass it right i calculated here on line 20. this simply is a reference to index in pixels array as we cycle through it so for example for this pixel red would be zero green would be zero and blue would be zero so brightness is zero as well i create a constant variable called cell and i set it equal to an array i give it property called cell brightness and i set it equal to brightness variable from line 23 here inside the cell array you could also create another property called cell color and create rgb color declaration where you concatenate red green and blue and you save this pixel's actual color so we can use it in fill style on draw method for that particle that way you can persist original colors of the image more on that later so we calculated relative brightness of pixel of this vertical y and this horizontal x coordinate and saved it in a custom array i call cell i take row variable from line 18 and i push cell from line 24 to that array we will create this cell array for every pixel in every row so row variable from line 18 will be created times because outside for loop will run for every row of our image which is 706 pixels high and inside of each of these 706 rows we create cell array here on line 24. we will have 500 cells for each row because our image is 500 pixels wide each cell holds relative brightness value for each individual pixel in the image so every time the loop is done and we pushed 500 cells into that row we take the entire row from line 18 and push it into mapped image array from line 16. that way when all these loops have run we have mapped image array with 706 row arrays inside of each of these row arrays there are 500 cell arrays each cell array from line 24 represents one pixel in the image we did it we cycled through pixels variable from line 11 we took that image data and created our own array called mapped image that contains brightness values for each pixel on canvas if i consolidate mapped image you see 706 items these are the raw arrays from line 18. each one holds 500 cell elements from line 24 and each cell is an array that contains only one element that is this cell brightness property that contains relative brightness of each pixel we calculated we will get a lot of zeros as cell brightness value because there are large black areas around my image but if i keep looking i will be able to find other values here as well see now i just need to take this information about brightness i stored in mapped image variable and somehow make particles fall at different speeds based on that first of all we need to navigate in indexes of that array based on particles current x and y coordinates since array index has to be integer whole number with no decimal points here on line 48 and 49 inside particles class constructor i create position 1 and position 2 custom variables that will simply round down this dot x and this.y making sure that these numbers don't have decimal points i also need to put these values here inside update method to make sure every time we update x and y position these values stay rounded down as whole numbers as integers now the main trick of how this entire effect works i will adjust this dot speed from line 45 i will literally take values from my custom mapped image array and since we organized pixel data in the array to the same width and height as our canvas using our nested for loops i pull value from a mapped image array based on particles current x and y position this dot position 1 corresponds to particles current vertical y coordinate as we declared on line 52 and adding it as index like this on line 54 will access custom row array in mapped image which has the same vertical y position as the particle currently has then we go one level deeper inside map image array to access horizontal x position i called these arrays cells if you remember and they contain only one property called cell brightness so that's array position 0. so what we have here is mapped image custom row array from line 18 custom cell array from line 24 and it has only one element i called cell brightness from line 25 so position in this array is zero and since outer loop that created mapped image on line 17 matches height of canvas and in a loop from line 19 matches canvas width the brightness information held in mapped image will correspond exactly with our image let me show you i appreciate this might be hard to follow and imagine what's going on at first if you can't follow what i'm explaining here with no problems congratulations you are not in majority of us it took me a while to realize how this works to create a full mental picture i bet some of you will be able to tell me there is a much simpler way to do this and i am looking forward to these comments i've learned a lot from your comments already so please keep them coming so here on line 54 i take speed from line 45 and i assign it to brightness value of that area in the original image then i create a custom variable let's call it movement for example relative brightness we calculated earlier and which is now reflected in this dot speed because of line 54 with a small number between 0 and 2.5 approximately i think since i want dark particles that have brightness close to zero move very fast and i want light particles with relative brightness close to 2.5 to move very slow i flip it by saying 2.5 which is the maximum minus this dot speed and i also want to randomize it a bit so if we have a large area of particles with the same color they still don't move exactly the same speed to do that i just do plus this dot velocity from line 46 now here on line 57 i say this dot y plus equals movement and we should be able to see that particles react to image now velocity on line 46 is too high let's change it to random number between 0 and 0.5 perfect important part of this effect is that the faster the particles move the more transparent they are on line 77 inside animate i remove the image so it's not been redrawn over and over you can see we are getting something nice on canvas already code between lines 77 and 79 just creates a semitransparent rectangle that is being drawn on canvas over and over given particles fade in trails once we draw it i want global alpha to increase to let's say 0.2 and here inside for loop that cycles through all particles for every animation frame before we actually draw the particle i will adjust global alpha for that particle to be equal to particle's speed property that's a bit too much let's half it speed times 0.5 up on line 10 on the first page load i draw the original image on canvas using builtin html canvas draw image method on line 11 i call get image data on it to get information about all its pixels and i save it to my custom pixels variable at that point i don't need the image anymore so i just clear canvas deleting the original image when i do this we will never see that image at all it will be drawn analyzed and deleted when page loads are very fast there are a lot of moving parts and many ways to customize this effect you can try to tweak some values and see what it does idea for this effect came from this brilliant code pen link in the video description luis also has many other interesting animations on there you can follow him if you want there is a lot of code in that code pen today we wrote our own version line by line using just plain vanilla javascript and we explained exactly what's going on on each line of code i hope it gave you some value and brought you one step closer to becoming a master of web animation now you should be able to understand it and tweak it to make your own variations or maybe even build on it and create something completely new now we know how to make black and white pixel rain how about we take it to the next level we will add colors give particles a different movement patterns and shapes experiment with filters blend modes gradients and i will try to create fire effect let's see what comes out of that click like please in the previous episode we built this black and white pixel rain effect step by step completely from scratch and i explained how everything works let's just have a play with it and create variations using different javascript tools and techniques let's see what comes out of that in style css i move the canvas slightly more upwards first of all i will quickly swap to a different image we are using data string that contains all image data to replace it i just enable word drop in my code editor i select beginning of the string then i scroll all the way to the end and on my windows pc using vs code editor when i hold down shift key and click here left click it will highlight all the code in between i delete it and replace it with a different image when replacing images in your projects make sure canvas width and canvas height on lines 7 and 8 as well as install css file is updated to much dimensions of the new image you are using in my case i made sure the new image is the same size as the old one i gave you a challenge last time instead of black and white effect to try and dynamically assign colors of the original image to the particles as they flow over areas with different colors solution is very simple we already calculated red green and blue here anyway to get our brightness so i just create another property in custom cell array called cell color and i concatenate string rgb plus right plus comma plus green plus comma plus blue plus closing bracket now this little cell array we create for each pixel contains two values relative brightness and original color to use this color all i need to do is go down here to draw method on particle class and on line 67 instead of setting fill style to white i set it to this new color property inside cell array same as we do with brightness on line 56 i go down two levels inside my custom mapped image array and inside cell array i see that cell brightness is the first property so index 0 and cell color is index 1. down here on line 67 i set the last index to 1 and here we go we are drawing in color that was easy let's play with particle movement now we will face a weird bug here i will tell you why it's happening and i will show you easy way to fix it when i increase vertical y value particles fall down what if at the same time i increase horizontal x position oh here is the bug one of our particles moved outside the canvas area and because of lines 56 and 68 javascript doesn't have indexes for these coordinates in mapped image array and everything breaks in this case i can fix it by resetting x and y correctly on line 61 if vertical y position reaches bottom of canvas i set it back to 0 and i randomize x horizontally i will also check when horizontal x position is more than canvas width and i set x back to 0 and randomize y vertically this solves the bug we are getting when particles move outside the canvas area but for the next effect i want to use trigonometry and make particles move in waves i won't be able to make sure particles never reach outside of canvas area when we have complex flowing movement like that so i will have to fix that back in a different way by the way you can also change angle at which particles fall by adjusting lines 59 and 60 like this first let's try to apply some fluctuation to particles movement and let's see what happens on line 52 inside particle class constructor i create this dot angle property this will be individual for each particle and the reason i make separate angle for each particle is because i want each particle to fluctuate at different speed depending on the brightness of the underlying area just like we did with movement speed earlier let me show you how at first i will increase this.angle inside update method for each particle by one for every frame so far all particles will have identical motion i take that angle value and i pass it to trigonometry function called math.sine this will just take the angle value and periodically run it between plus 1 and 1 over and over which will give us fluctuating movement immediately when i do it i will get an error it is because particles wiggle now and on line 61 i say this.y is movement plus this wiggle created by math.sine the problem is this imagine this particle is all the way to the bottom edge and method sign is added to that position on line 61 making the particle move further down outside the canvas area in reset check on line 63 particles this dot y is not past the bottom edge of canvas yet so it will not reset y to zero but because we added mod.sign to it on line 61 particle's actual coordinate is outside canvas normally that wouldn't be a problem but here on line 57 i calculate speed of particles based on their coordinates because each set of coordinates has different underlying brightness and the speed depends on that my mapped image array on line 57 has only values for actual image dimensions so when i ask it to access vertical index 710 when my original image was only 700 pixels tall this index in mapped image array doesn't exist in this case javascript will not know what to do and the entire animation will stop in console log you will see something like this cannot read property some number of undefined because we are asking for index in mapped image array outside the canvas area and mapped image array is set exactly to match canvas dimensions as we explained in the last episode so this index in that array doesn't exist so on line 57 we only want to assign a new speed value if particle is within canvas so that we can check for brightness of underlying area by accessing associated indexes and mapped image array i will just simply do an if statement here if vertical y position is within canvas area this.position1 and at the same time horizontal x position is not undefined as well only then assign new value to this dot speed otherwise just use all the distort speed value that was assigned in previous frames that's fixed but i get another error on line 76 the same issue here we are asking for color of the original image but particle is currently outside canvas area so mapped image array doesn't have color data for this position i do exactly the same fix if statement only if horizontal and vertical position have corresponding indexes in mapped image array and are not undefined only then change fill style to new color otherwise fill style will just stay the same color from the previous frame problem solved now we can give particles any crazy movement and the effect will not break the wiggle is barely noticeable let's make particles spin around properly i also add circular movement to this dot x i change sine to cosine on line 61 angle is increased by one per frame of animation way too fast look what happens when i slow it down we can actually see the circle movement now but all particles are moving in the same rhythm i put angle property on particle class constructor on line 52 which means each particle has its own individual angle value if i wanted all particles to move the same like this angle could have been a global variable and it would have saved javascript a lot of calculation since we have separate angle for each particle let's make each particle spin around based on its distort speed property which is individually calculated on line 58 based on brightness of the underlying area meaning that the dark areas of our image will create different circular patterns than light areas this dot speed is too fast let's divide it by 10. interesting making it even smaller number will really show off what's going on because particles move slower over light areas just because they spend more time in there they are more likely to make a complete spin and it kind of looks in some places like particles are actually bouncing off the light areas in the image how about we create our own spectrum that's also very easy up on line 9 i create a constant variable called gradient 1 and i set it equal to ctx create linear gradient this is a built in canvas method it expects four arguments two sets of coordinates these determine direction of the gradient imagine drawing a line between them to see the direction i want my gradient to go from top left corner coordinate 0 0 to bottom right corner coordinates canvas width canvas height i take this gradient one variable i just created and i call at color stop built in method on it it expects two arguments position between 0 and 1 and color we want at that position i will just speed this up and make some color stops to create rainbow my color stops will be at 20 30 40 50 60 70 and 80 percent and the colors will be for example pink red orange yellow green turquoise and violet to apply this i can simply go down to line 84 i disable colors from the original image for now and i set fill style to gradient one variable we just created upon line 9 you can change these coordinates to change angle of your gradient what if i want size of particles to be small in dark areas and larger in bright areas very simple to do as well i go down to line 70 inside update method and i set this dot size to this dot speed as speed already depends on brightness anyway how about speed times 2 maybe speed times 1.5 let's comment outline 88 and uncomment this to get original colors how about instead of filled circles we use stroked rectangles this works but we didn't set our stroke style so it defaults to black i just added here on line 87 the rectangles are too small maybe size times five how about size times three interesting you can put any drawing code here to represent each particle even more complex shapes or image from a sprite sheet like we do in game dev videos for example if you use more complex particle shapes you have to consider the number of particles that make up our effect it might be a lot for our computer to handle and draw all these complex shapes let's try to replace particles with letters for example with capital m that seems to run okay even though replacing circle with letter is a bit more demanding on performance how about i create a constant variable called letters and i set it equal to an array the array will contain some letters for example we can spell mandalorian or let's just do n a n then down here in particle class constructor i create a new property and each particle when it is created will be assigned one of these letters randomly i do that by saying this.letter equals letters array i just created and index will be a random number between 0 and letter's length this will give us numbers with decimal points but array has only indexes 0 1 and 2 because i have 3 elements in my letters array to make sure we only get integers whole numbers without decimal points i wrap it in math.floor which will round it down to the nearest integer now i can take this new letter property i just created and in draw method on line 95 inside fill text instead of hardcoded letter m i pass it this dot letter now our particles are random letter from that array up on line 25 i reduce the number of particles so that we can actually make up individual letters better inside animation loop i comment out line 12 that changes particles opacity based on their movement speed and i set everything to full opacity global alpha equals to 1. this looks pretty cool what if i want only certain percentage of my particles to be letters and the rest regular circles how do i control that i can for example create this.random property on particle class constructor and i just set it the math at random like this math random code like this returns a random small number between 0 and 1. each particle gets assigned a different random number at the point when the constructor gets called and that particle is created on line 96 inside our custom draw method on particle class i can say if this dot random is less than 0.1 which should roughly be in 10 percent of the cases then draw particle as text as one of the letters from letters array else draw it as a circle this way you can control different percentages of particles and give them different properties based on that you can do anything here if i change 0.1 to 0.5 now approximately 50 of my particles should appear as letters i can use ctx font to set text size and font family let's try 20 pixels aerial i can tweak the amount of text particles by tweaking if statement on line 97 i can replace text with stroke rectangles make them larger okay back to the circles this effect also works with global composite operation property where you can blend particles together in different ways i like when particles flow from one side and wash over the image until now it only ever happened on the first page load if i set start in x or y position to edge of canvas what if i want particles to come in waves and periodically create this splash movement let's create a variable that will switch between two values i will call it for example switch oh no that's a reserved word in javascript let's do switcher and another one called counter both will be let variables because i will be changing their values i create set interval that takes two arguments callback function to run and how often in milliseconds to run it i want it to run every 500 milliseconds every time it runs i increase counter plus 1 and now i can use that to set periodic events in my code base i say if counter modulus 12 is equal to 0 modulus operator percentage symbol is also called remainder operator this if statement means if counter value is divisible by 12 with a remainder of 0 which means as counter increases by 1 every 500 milliseconds this if statement will be true at 0 12 24 36 and so on every time counter variables from line 20 increases by 12 set switcher variable from line 19 to its opposite value switcher times equals 1 at first switcher is set to 1 so 1 times 1 is 1 then it runs again switcher is minus 1 so minus 1 times minus 1 is plus 1. it will just repeat and switch between plus 1 and 1 over and over every 12 cycles of this interval on line 84 inside custom update method on particle class i can say if switcher is plus 1 do something else do something else let me show you what global composite operation does i can set it for example to soft light oh i actually misspelled it it's supposed to be operation you can see these values control compositing or blending mode operations on canvas they can blend shapes adjust contrast hue brightness and other properties of canvas giving us different effects there are over 20 different values soft light affects how light and dark is displayed luminosity preserves luma or brightness of the top layer and it also preserves you and chroma of the bottom layer from their official descriptions it's really hard to guess what will the final result look like so i just try and see what happens some of them like source out might freeze your browser because what it does is performance intensive when you have so many particles like we do in this effect so be careful i can use my custom switcher variable to switch between two different blend modes periodically just for fun combining two specific ones might create something interesting let's swap between luminosity and lighter at the same time i say if counter modulus 10 is 0 every 10 cycles of counter variable set x and y to zero so particles splash over the canvas over and over what if i randomize it this way let's reset y to zero and leave x as a random number now the image automatically switches between two different blend modes and particles periodically reset so they can flow over the image in a wave again let's comment out this bit i can swap sine and cosine on lines 94 and 96 this will affect the circular path particles take tweaking anything on these lines will affect particle movement in a major way i can for example make particles move upwards if i do that i need to adjust reset check on line 96 i'm just playing with the reset checks trying to get it right on line 67 i can change particle size actually no because i am overriding it on line 82 because i wanted particle size to be relative to particle's current speed i'm trying to build a fire effect now i need to get the right size here install css i apply css filters i will use blur 2 pixels and then i sharpen it with contrast contrast is just a number without pixels adjustment size on line 85 will affect how the fire looks like what variations can you come up with do you have any ideas how to tweak this effect and create something interesting let me know we can also use pixel array to turn text into particles in the next creative coding experiment i will show you how to create interactive particle text effect in three steps first i will create a set of particles randomly spread around canvas we will give them some physics i will try to give their movement some elasticity and physics by applying forces of friction and acceleration when they interact with mouse then in the next step i will write some text on canvas i will scan it with get image data and i will make particles take shape of these letters as the final third step i will apply constellations effect that was made famous by particles.js library but i will use no libraries we will write all the code using just plain vanilla javascript to achieve constellations effect we just have to calculate distance between each particle and connect particles that are close enough to each other with lines i think this effect looks really good what do you think let me know in the comments if you get stuck and need some help feel free to reach out to me on twitter or message me somewhere on my youtube channel i do a lot of creative coding experiments canvas animations and game development click like please in index.html i'll link css stylesheet create html5 canvas element with an id of canvas1 and ilinkscript.js file which will contain all javascript logic in style css i just do the basic reset to make sure the page appears the same in all browsers ask the risk selector to target all elements on the page and i set margin to 0 padding 0 and book size into border box border box means that elements padding and border will be included in its total width and height on the body element i set overflow to hidden to hide potential scroll bars and give it black background i choose to place the background on the body element instead on the canvas because this will allow us to use liquid or distortion svg filters if we choose to especially liquid filter only works if canvas background is transparent canvas will have position absolute job 0 left 0 everything else will be done with the javascript in script.js file i create a variable i call canvas and i set it equal to document getelementbyid canvas1 ctx shortcut for context is equal to canvasgetcontext2d doing this will create a builtin context object that contains all kinds of 2d drawing methods that come built in in any browser using canvas api now i can call all of them using our ctx variable canvas width is the window in a width and canvas height is the window in a height this will make sure the canvas covers the entire browser window i create a variable called particle array and i set it equal to an empty array this will contain all our particle objects that each contains information like size color and coordinates and we will pull this information from here to draw them on canvas before we do that i will write some code to handle mouse interactions i create a custom variable i call for example mouse and i set it equal to javascript object by using curly brackets like this i give this custom object some properties x will be the current position of mouse on horizontal xaxis y will be positioned on the vertical y axis radius will be size of a circle area around the mouse within which the particles react to mouse i create an event listener it takes two attributes type of event to listen for and call back function to run every time that particular event occurs i want to listen for mouse move event and every time user moves the mouse within the browser window i want to run the following code callback function on event listener has one special thing about it it has access to builtin object that contains all different details about the event that is occurring all i need here are x and y coordinates of the event so that i can assign them dynamically to our customer mouse object i created on line 8. i need to assign them to the custom object to pull that coordinate information outside of event listener so i can use this information all over our application so as an argument to the callback function i write down event some people just put letter e here it doesn't really matter javascript knows this variable will stand for that builtin event object and will let you use it whatever you call it here as long as you refer to it using the same variable name later on so inside the callback function i set mousex which is property declared on line 9 to event.x and mouse y to event.y if you console.log event inside this event listener you will notice it is quite similar to our custom mouse object on line 9. the only difference is that it contains many more properties and it is only available inside an event listener that's why i am pulling the information from it here and sending it outside to our customer mouse object so that mouse coordinates are available all over our application wherever i might need them later on i can check if it works by console login mouse x and mouse y now if i move mouse over the canvas with open console i can see we are getting values great this is one of my favorite ways to handle mouse input it is useful for everything from generative art website interactions to games now let's draw some text on canvas ctx font properties sets the current font properties for text context on the canvas you can also set bold or italic here if you want then you put size and the last attribute will be font family let's just try 30 pixels verdana for start now i call ctx filtex method which will just draw and fill text on canvas it expects at least three attributes the first one is the text we want to write i just put capital letter a for now the second one is x coordinate on canvas where you want to draw that text the third attribute is y coordinate there is also an optional fourth attribute where you can define max width of the text in pixels we will leave it empty for now but keep that in mind by default the text will be black unless you set it to any other color using fill style property so i call ctx fill style method and set it to white now we can see we are drawing our text at specified coordinates i can change it by adjusting its size on line 21 or its position on line 22. now what i want to do is to scan a small area of canvas around the white letter a analyze the pixels filter out pixels with no opacity because that's where the text is and only save those pixels that are not transparent into our particles array more specifically i want to save their x and y coordinates and i can also save their color values if i want to that way we can replicate the shape of letter with particles by using x and y coordinates of each pixel as coordinates for our particles remember that the black background is on body element so canvas is completely transparent with only letter a in white color to do this i just use another canvas method called get image data we used it before to turn image into particles in one of my alltime most popular videos and we will do something similar today with text official definition of this method is that it returns image data object representing the underlying pixel data of a specified portion of the canvas if i want to say it much simpler you give this method four coordinates for rectangular area somewhere on canvas it scans that area pixel by pixel and it saves coordinates and color information for each pixel inside of a huge data array since we know how the data is organized we can easily extract that information and use it for anything we want so i create a variable i call for example data and i set it equal to ctx.getimagedata and i pass it for attributes to tell it what part of canvas we want to scan i want to start from top left corner so coordinate 0 0 and i want to scan just small bit let's say square of 100 x 100 pixels so i pass it with 100 height 100 which is somewhere around here if i want to visualize the area we scanned i can just stroke white rectangle there so we can see stroke style set to white stroke rectangle and i pass it the same area i passed to get image data method on line 25 see this is the area we will be scanning so our data variable on line 25 will contain array with coordinates and color information for each pixel inside this small square okay let's delete this it was just so we can visualize what's going on now i need a way to create many similar particles that will each represent one interactive dot in our final effect for that i will use javascript class i call it particle with capital p each class has one mandatory method called a constructor constructor will run just once for each particle it will create a new blank object and assign it properties and values based on information i will declare inside of it it will serve as a blueprint our constructor will expect just two attributes x and y coordinates which will be different for each particle and we will pass them to the constructor from the outside to make it spell out our letters for the final effect inside i just say this dot x property on a new blank object you are creating is equal to x we passed as an attribute same for vertical y coordinate we will have other properties but these will be set or randomized here inside the constructor we don't need to add them from the outside so we don't need to pass them as arguments on line 26 this dot size will be radius of each circle particle so let's try for example 3 pixels i will also set this to base x and set it to this dot x and this dot base y and set it to this dot y base x and base y properties will hold the initial position for each particle from the first time they appeared the reason for that is that we will be moving and pushing the particles around by changing their this dot x and this.y properties but i want each particle to remember where it came from so it can return to its original position when mouse interaction ends also i choose to set this.basex equal to this dot x property from line 27 instead of setting it to x attribute passed on line 26 it will be the same but doing this will allow me to modify the starting position of this dot x on line 27 like this and our base x variable will remember that modified state it can be used for interesting distortion effects not sure if we do it today but there is no harm if we set up our code base for it anyway distal density will be a random number between 1 and 30. it will determine how heavy our particles are and how fast they move away from the mouse i want each particle to move slightly different speeds to simulate some physics so now the blueprint is complete we will also need a custom draw method each of our particles will have access to it because it will be sitting on the particle class this method will just take x and y and radius from the constructor and draw a circle there representing our particle i set fill style to white we are drawing a circle on canvas so i need to use ctx begin path method think of it as pencil touching down on canvas to start drawing i call canvas arc method and i pass it this dot x and this dot y coordinates this dot size will be radius of the circle start angle will be 0 and end angle will be math.pi times 2 which is value in radians that represents that actually converts to 360 degrees so we have just drawn a circular path from 0 to 360 degrees which is a full circle if you change start angle and end angle values here you can use arc method to create half circle or even many other shapes i call close path and ctx fill to fill the path with white color now i create another custom function i call init its job is to take particle class we just created and call it many times the fill particle array with randomized particle objects first i will set particle array to an empty array in case it's not empty at the moment now i call push method which will take whatever we pass to it and pushes that to the end of the array we call it on i pass it new particle the new keyword is a special command in javascript it will call constructor of its associated class in our case it will go up to line 26 create one new blank object and give it values and properties as described in the blueprint between lines 27 and 32. on the line 26 we can see our constructor expects x and y coordinates as attributes so here on line 45 i pass it 50 50 as coordinates for now now i call init to push one particle into the array i count lock particle array to see if it works i need to comment outline 17 that's still log in our mouse position yes now i can see the array contains one particle i can add another one at coordinates 80 and 50. and now we have two particles in our array i create a custom function i call animate which will handle animation loop first i call ctx clear rectangle and pass it canvas dimensions to clear the entire canvas between every frame of animation i create a for loop that will cycle through the entire particles array and for each particle object inside that array it will call its custom draw method we declared on line 34. the last thing i need to do is to call requestanimationframe and pass it animate the name of its parent function this way animate will run all of its code and it will call itself again over and over create an animation loop so far i have just declared animate i also need to call it to start our animation loop it is not drawing our particles and in console i can see we have error on line 37 where i misspelled arc fixed now we are drawing two particles as i declare them on line 45 and 46. i can change their x and y coordinates and you can see they will move around as i change these values so instead of calling the particles individually like this i create a for loop that will run for example 10 times i comment out the two individual particles and inside the for loop i do the same thing particle array push and i pass it new particle it expects x and y coordinates so i will create a temporary x variable its only job is to generate random number between 0 and 500 i do the same for y coordinate now i call new particle and i pass it temporary x and y variables i have just created on line 46 and 47. you can see we are drawing 10 randomized particles because for loop on line 45 runs 10 times if i want the particles to be randomly spread all around the canvas i can set x to a random number between 0 and canvas width and temporary y variable to a random number between 0 and canvas height now our entire canvas is covered with particles i increase the amount of particles to let's try 500. well done we have base structure for our generative art project in place first we declare global variables then created object to store mouse coordinates then on line 25 we create a blueprint that will be used to create particles function init online 43 will use that blueprint to fill particle array with particle objects and lastly we created animation loop on line 56 which is running over and over and redrawing our canvas for every frame even though it looks static now we are actually drawing the same thing over and over let's make it move now on line 35 i can change color let's try red i create another custom method i call update its job is to calculate distance between current mouse position and current particle position if they are close enough i want particles to be pushed away from the mouse now i will show you how to calculate the distance between two points this can be used for creative coding and it is also very useful for games let's calculate distance between two points on the horizontal xaxis first i will call this variable dx it is simply the difference between their position on xaxis let's say if mouse position x was 50 and particle position x was 30 dx will be 50 minus 30 which is 20. simple is just the difference same for dui which is the difference between position of two elements we are comparing vertically we are comparing mouse against all particles one by one so d y is mouse dot y minus this dot y this dot y stands for each individual particle as we cycle through all of them one by one imagine these two values we have just calculated create a right angle triangle between mouse and particle we have dx side we have a d y side of the triangle and we know there is a right angle between them so 90 degrees we can get distance between these two points by calculating the longest side of the triangle opposite to the right angle it is also called hypotenuse there is a builtin method hypotenuse method in javascript but today i will just use pythagoras theorem to calculate it we have two sides of right angle triangle and we know there is a 90 degree angle between them we need to calculate the third side and that will be the distance between two points which is what we need formula is mod square root dx times dx plus dy times dy which also is which is the same thing as mod square root dx squared plus dy squared since this is calculated inside update method on particle object each particle will always be aware of how far away it is from a mouse so here i can say if distance between particle and mouse is less than 500 run this code if particles are closer to mouse than 500 i will set their size to 50 pixels else digital size will return back to 3 which is the original value we declared on line 29 to run this code i need to go inside animation loop and on line 68 inside for loop that cycles through the entire particles array for every frame of animation the same way i call draw method for every particle i will also call update the method we have just created and you see it works now i can change the distance particles react to mouse here on line 45 i can also create more particles on line 55. now you can see the distance is being correctly calculated and we have a nice boilerplate for creative particle effect we can do so many things now maybe if you want before we continue you can save and copy this code base in a different folder and experiment with it later on it's always good to have the base setup stored away somewhere and now you can just focus on your experiments so what i want to do now is for particles that are close to mouse to start moving away from it i want them to move from the center point of the circle towards the edge i also want particles to move at different speeds depending on their weight we defined earlier when we assigned this density property inside particle class constructor and third thing i want to happen is for particles to move fast if they are close to mouse but gradually slow down the closer they are to the outer edge of circular interaction area until they reach speed of zero when they touch the outer edge basically we will introduce some basic physics to particle movement this might sound like a complicated thing to do with code but i will show you a nice calculation that can do all of this for us i create a variable i call force direction x and i set it equal to dx divided by distance force direction y will be d y divided by distance on line 48 if particles are closer to the mouse than 300 pixels i will add force direction x to particles current x position and force direction y to particles current y position this will just make them slowly move towards the mouse if i multiply these values by let's say 3 it will make the movement faster now i want to set a distance past which particle's movement speed is zero so i create another variable i call it max distance it will be equal to mouse.radius we declared on line 11. any particle that is more distant from the current mouse position than this will stop moving this calculation i'm about to do takes any range of numbers and converts it to a range between 1 and 0. it will convert values between 0 and max distance into a range of 1 to 0 just so i can multiply values on line 51 and 52 by this number and get the particles to slow down as the distance between them and mouse increases until they reach speed 0 as they reach the outer radius of interaction's circle around the mouse so i will call that variable for example force all i want to do now is to take number range of 0 to 250 and convert it to number between 1 and 0 depending on where on range between these two values the number is 0 is particle with a distance zero from the mouse so it will be touching the mouse i want this number to be converted to one so i can multiply current particle speed by this which will make the particle move at its full speed the second side of that range is number 250 which is represented by max distance variable i want any particle that are further away from the mouse than this to have speed 0 so they stop moving let's say there is a particle halfway between 0 and 250 so this particle is roughly halfway between these values it is 125 pixels away from the mouse at that point i want that particle to be moving at 50 speed so i need force variable to be equal to 0.5 at that point if i multiply current speed times 0.5 it will move at 50 speed when particle reaches 80 percent towards the outer edge of interaction circle i want it to move at 20 speed so i want force to be 0.2 when particle is at 90 percent i want it to be moving only at 10 percent of its original speed and so on to get this behavior i need to convert range between 0 and 250 or whatever max distance variable is on line 48 i want to convert this range to a smaller range between 1 and 0. once i have that value i will multiply it times particle speed and it will cause particles to slow down in proportions to its current distance from the mouse you can already see the calculation i say max distance minus current distance to see how far particle currently is from the max distance area and once i have that value i divide it by max distance again which will tell me what proportion of max distance it is quick example if max distance is 100 pixels and particles current distance from mouse was 20 pixels max distance minus current distance would be 80. then 80 divided by 100 is 0.8 so our force would be 0.8 basically anything multiplied times 0.8 is 20 percent less so it will slow our particle down by 20 percent i'm not sure if this is just me or this is quite difficult mathematical operation to understand it took me a very long time to work this out i will get back to this again and try to explain it better next time we use it let me know in the comments if it's unclear and we can talk about it so now i have the force which is the multiplier that will be slowing particles down as they get further away from the mouse i create a variable called direction x which will combine all factors that play a role in particle's movement speed direction x is equal to force direction x on line 46 times force we just calculated on line 49 times this dot density from line 33. i add this to density into the mix because i also want individual particles to have different mass and i want that value to affect their movement speed it will look more natural otherwise all particles will move the same speed as particles around it i do the same thing for direction y it will be equal to force direction y from line 47 times force which will cause it to slow down as it moves further away from the mouse times distal density which is individual and different for each particle it's a random number between 1 and 31 as we declared on line 33. now on line 53 i say if distance is more than mouse radius which we declared on line 11 this dot x plus equals direction x variable from line 49 which combines all forces that pull and drag on our particle and i do the same thing for particles word and i do the same thing for particles vertical y position this dot y plus equals direction y that was calculated on line 50. it works yay particles move slow at first and speed up as they get closer to the mouse the only problem is that i want them to be pushed away so i change plus sign to a minus sign on lines 53 and 54. yes this is good and this is how you implement quite complex physics with javascript i really like the movement and we will enhance it even further by the way this was the difficult part i am not sure why i put mouse radius here on line 17 inside mouse move event that's wrong i will just delete that radius is set to 450 pixels on line 11. if you look closely particles move at full speed when they are close to the mouse and when they get close to the outer edge of interaction circle they move slower and slower until they stop i can make them move faster by changing density let's try range between 50 and 200. you can change the movement speed by adjusting the range of values here on line 31. so on line 51 i check if distance between particles and mouse is smaller than a certain number defined in mouse radius if it is i push them away from the mouse as you can see particles stay where they are when mouse interaction ends i would like them to return to their original position so here on line 54 in else statement i say if this.x is not equal to this.basex basex is defined on line 29 and it captures the initial position of each particle so if this dot x has changed because we pushed particles around and it is no longer equal to base x which is particles original position i will calculate distance between this dot x which is particles current position and this dot base x which is particles original position on the horizontal x axis once i know the difference i can just return particle to its original horizontal position by saying this dot x minus equals dx but to make particles move back slower i say dx divided by 10. it will eventually get to its original position because this code is run for each frame of animation it will just get there slower also keep in mind we are currently inside else statement which will be entered only when particle is not close enough to the mouse so particles will only try to return to their original position once mouse moves far enough from them so this way we corrected particles horizontally we can also correct them vertically notice i don't do else if here i just do simple if statement because i don't want these to be mutually exclusive if particle has been displaced on xaxis and also on yaxis both of these statements will run for each frame of animation but also they can just run separately in case on the x axis or only y axis position needs to be corrected to return particle to its original position as we saved this original position in base x and base y variables so if this dot y is not equal to this dot base y i calculate d y value distance y value and i adjust this dot y by saying minus equals d y divided by 10. by changing values on line 57 and 61 i can change how fast particles return to their original position so this all works at the moment we are just spreading particles randomly around the entire canvas area by calculating random x and y values here on line 70 and passing them as attributes to particles class constructor on line 72 how do we make the particles spell out letters of text for that we use data variable we declared on line 22. here we call canvas image data inbuilt method that takes four attributes for a rectangular area of canvas we want to scan and it returns image data object that contains information like coordinates and color of the pixels from that area on canvas actually let me rename this variable for clarity i rename data to text coordinates so now this variable i called text coordinates holds whatever get image data method returned i go down inside our custom init function which at the moment runs a for loop thousand times each time it runs it calculates random x and y position and creates a particle there i delete all this code because we don't want our particles to be randomly distributed around canvas we have just scanned the part of canvas where we drew some text and now i will filter that returned object that resulted from our scan and i will remove all pixels with transparent background leaving only data points for pixels that contain color which will be coordinates for particles that make out our text effect keep in mind that canvas is transparent the black color you see is set on body element so the only pixels with color are the actual letters let's go through it step by step i create a for loop and i will do something a bit weird instead of just declaring one variable here as the first attribute i declare two variables i say let y equal 0 comma y2 equals text coordinates dot height as long as y is less than y2 y plus plus this is almost a normal for loop two things to mention here first yes you can do this in javascript you can put more than one variable inside a for loop also i could have just declared y2 variable outside the for loop and it would work as well second thing is that i say y2 equals text coordinates height text coordinates holds image data object that resulted from a scanning small portion of canvas using get image data method this object has height property in pixels and since i want to scan the resultant pixel data line by line in this case row by row i will run this for loop for every row of pixel data we have so we declared two variables and i say as long as y is less than y2 y plus plus don't overthink this we just have two variables y will keep increasing until it reaches the same value as y2 so our for loop will run until that happens so this is analyzing pixels row by row each time i enter row of pixels i want to go through them one by one from left to right so i create a nested for loop which simply is loop inside of another loop here i say let x equal 0 x 2 is text coordinates width which is simply just width of scanned area in pixels in this case we scanned rectangle 100 times 100 pixels as you can see on line 22. so text coordinates height is 100 text coordinates width is 100 as well this outer for loop will run 100 times and each time it runs it will run in a for loop 100 times so we're gonna analyze 100 times 100 10 000 pixels i will explain this further in a minute back on line 70 i say as long as x is less than x2 x plus plus this nested for loop might look complicated but all that's happening here is i have a grid of 100 times 100 pixels i go through them row by row or 969 each time i enter one row i go through that row of pixels one by one until i reach the end in this case pixel number 100 in for loop on line 70 will exit we jump back to the outer loop on line 69 y will increase by 1 which will give us another row we enter in a loop on line 70 again and go through all the pixels on that new row from pixel 1 to pixel 100 then we exit the inner loop again enter the outer loop increase y by one which gives us the next row and we do this for all 100 rows analyzing all 100 pixels in each row as i said we have 100 times 100 pixels because that's the area of canvas i have decided to scan using get image data method online 22. this nested loop basically allows us to cycle through every pixels in that hundred times 100 pixel area for each pixel i check if opacity of that pixel is more than 128 i will explain what that means in a second text coordinates custom variable holds builtin image data object that was returned by get image data javascript method this object has builtin data property which is an array of elements that represent pixels from the scanned area of canvas we can look inside by console login text coordinates in the console i can see it holds image data object if i open it you can see that object has a data property and this data property holds data array with 40 000 elements more down you can also see that it has height and width properties set to 100 which are the values we used in the nested for loops don't get scared this is very simple it is not a normal array if you look closely you will see this type of array is called something like uint8 clamped array if i simplify this it's a special type of array that can hold only numbers and those numbers are limited to a certain range you can say they are clamped each element in this array can only be a number between 0 and 255 if you work with html and css you have seen rgba color declaration which looks like this any color can be created by combining different amounts of red green and blue and the range for each color is from 0 to 255. one weird thing about this clamped array is that it also handles alpha or opacity this way so 0 alpha is invisible 255 alpha is fully visible this is different because in rgba color declaration opacity is a small number between 0 and 1. so why does this array have 40 000 elements when the area we are scanning is 100 times 100 pixels and we know hundred times hundred is only ten thousand not forty thousand also remember that this is a special type of array called clamped array so every element it contains can only be a number between zero and two hundred and fiftyfive again very simple explanation let's look back at our rgba color declaration each color is made out of four properties red green blue and alpha same with this clamped array data object the way it's organized is every four elements in that array represent these four color values for one pixel so color for pixel one is the first four numbers in this array color for pixel 2 is the next four numbers and so on that's why we have 40 000 numbers in this array and we only have 10 000 pixels it's because we need four numbers to make one color each number is something between 0 and 255 including the number for alpha opacity that's why online 70 i check if value is more than 128 which would be around 50 opacity it's like halfway between 0 and 255 roughly 50 any pixels with more than 50 opacity will be added to our particle array each one will create a point in the final font shape to extract these values we have our nested for loops if particle passed check here inside if statement i create a temporary variable i call it for example position x and i set it equal to x which is the variable from line 70 and it represents number of pixels in a row that passed our opacity check i do the same for position y which will be equal to y from line 69 which represents a row vertical position of that pixel we are analyzing right now so in terms of x and y coordinates it's a vertical position of pixel that passed our opacity check so i cycle through all pixels i check their opacity value and if their opacity is more than 50 i capture their coordinates in temporary variables position x and position y and i call push on particle array which is my custom array i created to hold particles for my effect push method just takes whatever we pass to it and places it at the end of array so i pass it new particle which we'll call particle class constructor that uses es6 class blueprint we created earlier and creates a blank object and assigns it values and properties based on the rules we declared in the blueprint our particular class constructor expects two values to come from the outside for x and y coordinates so i pass it position x and position y variables from lines 72 and remember that this code runs only when opacity is more than 50 so only these particles from the scanned area will be added to our array there is just one more little problem to sort out as i said clamped array that is held in text coordinates data object contains four elements for each pixel we have ten thousand pixels but this array has forty thousand elements it holds a value for red green blue and alpha for each pixel right now i am just checking one pixel because i passed index one in that array inside square brackets here what i want to do is to cycle through the entire data array and take every fourth value because i know every fourth value stands for opacity for each pixel it's always red value green value blue value opacity value and so on so i need to replace one with some code that will allow us to skip three elements check the fourth one skip another three elements check the next one and so on one way to do this is i say in brackets y times four times data with plus x times four plus three remember that we are inside a for loop so y will be one then two then three as we cycle through rows and x will be one two three as four loop cycles through pixels in each individual row this calculation is not very intuitive just know what i'm doing is i'm cycling through 40 000 elements and always skipping three and checking the fourth one i am not a math expert so this took me forever to understand but i think for now it's good enough for us just to show just so you know what i'm doing i'm sure there are simple calculations to lock every fourth item in an array anyway i will explore it more when we use this technique next time that's it this is how you scan portion of canvas filter out pixels with no opacity and save their coordinates in your own data array since the font we scanned is very small as you can see here we don't want our particles to cover this small area we want to spread them out evenly while keeping the shape of our letter a so here on line 74 i just multiply position x times 10 and position y times 10. i made a small mistake on line 71. earlier i renamed data to text coordinates but here i still refer to it as data let me fix that and we are drawing particles in the shape of a letter a well done this is some advanced coding i can change spread of the particles and therefore size of particle text by adjusting values here on line 74. since we are taking particles from certain area and multiplying their coordinates to spread them around it's not that easy to move the text left and right but i can still do that by adding adjustment variable here on line 72 and also on line 73 i call them adjust x and adjust y and up here on line 6 i declare them and let's push x 10 pixels to the right and why 10 pixels down now you can move your particle text shape around anywhere you want by adjusting these two values size of the effect can be changed here on line 76 let me just center it in the middle and of course you can change the text we draw here on line 23 some of you might like this effect already but that's not all i also want to connect particles that are close enough with lines similar to the famous particles.js constellations effect but on a text instead on random floating particles and instead of using a library we will write our code ourselves i create a custom function i call connect its job will be just a cycle through the array of particles that make up our letter and measure distance between each particle if they are close enough we will take coordinates of the first particle and we draw a line to the coordinates of the second particle that's it click the like please if you're getting value from my tutorials so i create a for loop that cycles through the entire particles array since this for loop will have to run for every frame of animation let's optimize it a little bit normally i would just do nested for loops and i would compare every particle to every other particle in the same array but i don't have to do that the inner for loop only needs to cycle through the remaining particles in the array because all the particles before have already been compared in previous cycles of the outer for loop i'm not sure if i'm explaining it clearly but let's write some code and i will try again so in the inner nested for loop instead of cyclin through the entire particle array again just so i can compare every particle against every other particle i will only cycle through particles that have a higher index than a because anything with lower index has already been compared in previous cycles of the for loop so here i say let b is equal to a as long as b is less than particles array length b plus plus if you look at line 96 again when the outer loop runs for the first time it will cycle through the entire for loop in the outer loop and inside the inner loop as well but eventually when variable a in the outer loop reaches number let's say 50 in the inner loop we say b is equal to a and we cycle only through particles from index 50 to the end of the array this will pair up all individual particles inside particles array all i need to do here is calculate their distance and say if distance is less than some value connect them with a line we have already calculated distance between mouse and particles on line 45 so again it's exactly the same thing dx variable will hold distance between two elements we are comparing on the horizontal xaxis the ui variable will hold distance between two points in this case between particle a and particle b on vertical y axis this will give us two sides of right triangle and we know that the distance between these two points is hypotenuse the longest side of the right triangle the side that is opposite to the right angle to calculate it we can use pythagoras theorem formula which we learned in school a long time ago math square root from dx squared plus d y squared or in other words math square root from dx times dx plus dy times dy so to calculate dx distance of two particles on the xaxis i say particle array a x minus particle array b x a and b variables will be changing as we cycle through both for loops so this code will compare every particle against every other particle by the time the for loop has finished d y will be particles array a y minus particles array b y now we have two sides of imaginary right triangle and all we need to do to get distance between these two particles is to calculate hypotenuse so math square root dx squared plus d y squared now i can say if distance is less than 100 pixels i set stroke style to white because we want white lines line width will be 2 pixels for example on canvas line is the same as arc we used to draw circle it is considered to be a path so to start drawing i will have to call begin path to draw a line on canvas you need to call move2 method to set starting x and y coordinates and line 2 method to set target x and y coordinates when you do that a line will be drawn between these two points each point defined by two coordinates x and y so at first i call a ctx move to method which creates a starting point of a new path at coordinates we pass to it we are inside an if statement that only runs when two particles are close enough to each other so i just want to draw a line from one particle to another the starting point of the line will be x and y coordinates of particle a that passed our distance check then i call a line 2 inbuilt canvas method this method simply said creates a straight line from coordinates we pass to it to the last previous point inside the same path start and end of path on canvas will be defined by beginpath and close path method calls here so i call line 2 and i pass it x and y coordinates of particle b that passed the distance check now that you kind of understand how parts and lines work you might be able to see that we can keep drawing more and more paths like this and create custom complex shapes but i only want to draw a single line connecting particle a and particle b all you need to do to create the popular particles.js constellations effect with vanilla javascript is this code we just wrote from line 94 inside our custom connect function we have just declared a function we also need to call it inside our animation loop to actually run the code so on line 90 i call connect and here we go this is just the basic effect we can make it a little bit nicer than this here on line 105 you can change the distance limit the limit will determine maximum distance between particles that get connected by white line i think 50 looks pretty good but for you it might be slightly different number depending on your base font and how much you decided to scale your particle shape earlier just try different numbers here and see what you like one important visual thing that particles.js library does is that the lines are not always fully visible they don't just appear and disappear as particles move closer and away from each other lines slowly fade away and slowly appear again basically opacity of the lines is dynamically calculated based on the distance between particles it looks much cleaner that way to do this in our custom code base is very simple on line 96 i create a new variable called opacity value and initially i set it to 1 full visibility then here on line 107 i set stroke style to rgba color declaration rgb value for white is 255 255 255 and i will concatenate opacity value variable as the last fourth attribute for opacity like this now we have a variable that can dynamically change an opacity of lines will change with it to make opacity proportionate to the current distance between particle a and particle b i run this strange formula basically what i want is if distance is close to zero particles are very close to each other so i want opacity to be close to one as the distance between particles increases i want to decrease the opacity value until particles are far enough and opacity will be 0. there are many ways to do this simple way is to say 1 which is full opacity full visibility so lines are visible minus distance divided by 50. notice that i divided by the same number don't overthink this let me give you two examples if distance is zero particles are close line is fully visible on the other hand if distance is 50 1 minus 50 divided by 50 is 1 minus 1 so 0 lines are invisible when the distance between particle a and particle b reaches 50 or whatever you set the limit to if you want particles to have zero opacity when they reach maximum distance keep these two numbers on lines 106 and 107 the same if you change distance to 100 change the formula on line 107 200 as well and the effect will work the same lines will still disappear when they reach or get very close to maximum distance here i am struggling a bit because i didn't notice i forgot one comma on line 108 inside rgba color declaration just bear with me a bit nothing is changing about the code i'm just trying to find the problem now i notice the missing comma and suddenly everything works what i will do now i will copy these two lines and place them outside the if statement which thinking back was not necessary because lines are only drawn if we enter the if statement on line 107. now i just restore the formula to dynamically calculate opacity on line 105 and the base effect is a ton there are many tweaks that can be done now to achieve different results hope you had fun coding with me today if you did let me know what you've built html canvas is a powerful tool and it allows us to do so many things these days good luck with your coding studies i hope to see you again for more creative coding experiments
