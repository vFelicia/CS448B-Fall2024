With timestamps:

00:00 - in this course you will learn how to
00:01 - build cross-platform desktop
00:03 - applications in Python that can run on
00:07 - Windows Mac and Linux this course will
00:10 - teach you the fundamentals of working
00:11 - with QT to build GUI applications using
00:14 - pi side 6. Daniel gakuaya developed this
00:17 - course Daniela is an experienced
00:19 - software engineer and he's the creator
00:21 - of our most viewed course of the last
00:23 - year
00:25 - hello guys and welcome to this new
00:27 - course on Pi side sex in this course I
00:30 - will show you how to use Python and Pi
00:32 - side 6 to World great graphical user
00:36 - interfaces that run on desktop that's
00:39 - Windows Mac and Linux and you will be
00:41 - writing your code once and all you have
00:43 - to do is to run your python application
00:45 - on a different operating system and
00:48 - that's going to run seamlessly so that's
00:50 - the point of the course here building
00:52 - cross-platform graphical user interfaces
00:54 - applications using QT under the pi side
00:58 - sex umbrella Pi side 6 is really a
01:01 - technology that allows you to mix up
01:02 - Python and QT to take advantage of the
01:05 - foundation that QT provides and I may
01:08 - hear some of you asking what is QT well
01:11 - QT is a cross-platform framework to
01:14 - build a graphical user interface
01:15 - applications but it is originally
01:17 - written in the C plus plus and the pi
01:20 - side 6 is a project that aims to give us
01:24 - the ability to to take advantage of what
01:26 - QT provides using the Python programming
01:30 - language and this is really cool if you
01:32 - are a python developer you can take
01:34 - advantage of what QT offers without
01:37 - needing to learn C plus plus and that's
01:39 - a huge Advantage you might want to take
01:41 - advantage of in your career as a python
01:44 - developer so this course aims at giving
01:47 - you the ability to build applications
01:48 - like notepad here you see it is a
01:51 - graphical user interface it has a bunch
01:53 - of menus and toolbars we have a status
01:55 - bar here we can type text here this is
01:58 - one of the applications we will get a
01:59 - chance to build and this is going to
02:01 - give you a foundation to really build
02:03 - any kind of application you might want
02:05 - in your career as a python developer
02:08 - another great aspect of this course is
02:10 - that we try to take advantage of every
02:13 - opportunity to teach you how to use the
02:15 - documentation so if you want to search
02:18 - for something for example Pi site 6 and
02:21 - Q widget
02:22 - okay you can come to your favorite
02:24 - search engine and search here you will
02:27 - have the information on this component
02:29 - and you can learn about it we will be
02:31 - doing this a lot in the course and I
02:33 - hope this is going to give you the
02:35 - ability to even learn more on your own
02:37 - because I can't really show you
02:39 - everything in a course like this but
02:41 - this is going to give you a great
02:43 - Foundation to build your own work on top
02:46 - of the requirements for the course are
02:48 - not really that bad all you need is a
02:50 - basic python understanding if you can
02:53 - work with variables functions if you can
02:55 - work with basic object oriented
02:58 - programming if you know things like
02:59 - classes inheritance you will have a good
03:02 - time with the course the most important
03:04 - thing is really the strong drive and
03:07 - willingness to learn so if you have a
03:09 - roadblock for example if there is
03:11 - something you don't understand
03:12 - you should have the drive to actually
03:15 - try and go in a search engine put that
03:18 - in a search bar and really try to
03:20 - understand what is going on once you
03:22 - understand that you can come back to the
03:24 - course but you are not on your own we
03:27 - have a community on Discord you can join
03:29 - to be together with other people that
03:32 - are going through the course if you post
03:34 - a question there I will try and help the
03:37 - best I can and if you go through this
03:39 - course you will have a strong Foundation
03:41 - to build graphical user interfaces using
03:44 - pi side 6. this is going to give you the
03:46 - ability to build graphical user
03:48 - interfaces for your existing python
03:50 - projects so if you are an existing
03:53 - python developer this is going to be a
03:55 - great asset for your career another
03:57 - thing is that the knowledge you get in
03:59 - this course is transferable so if you
04:02 - learn to build the graphical user
04:04 - interfaces using buy side sex the
04:06 - knowledge you gain is going to also be
04:08 - useful if you later choose to use
04:10 - another toolkit for example there is
04:13 - another project which is called the pi
04:15 - cutie which also allows you to build the
04:17 - QT applications using python so if you
04:20 - go through the course here you will have
04:22 - the ability to take advantage of that
04:24 - framework pretty fast because the API is
04:26 - the same but the ideas on graphical user
04:31 - interfaces aren't really tied to a
04:33 - single graphical user interface toolkit
04:35 - so once you've learned the foundations
04:37 - you can use other toolkits fairly easily
04:41 - okay so now that you know a bit about
04:43 - the course let's talk about myself here
04:45 - my name is Daniel acquire I am a
04:47 - software engineer I have been using QT
04:49 - for a lot of years and I happen to have
04:51 - a few courses on QT on udemy most of
04:55 - these courses are using C plus plus but
04:58 - I release the new course which is using
05:00 - cute for python but don't feel pressured
05:03 - to take that course if you want you can
05:05 - take it but this one on YouTube is going
05:07 - to give you enough to build a lot of
05:09 - things and once you have that knowledge
05:12 - you can go on and use the documentation
05:14 - to even learn more than I can tell you
05:17 - in a course like this this is really all
05:19 - I had to share in this lecture so let's
05:21 - stop here and start learning about pie
05:24 - side sex in the next lecture go ahead
05:26 - and finish up here and meet me there I
05:29 - would like to welcome you in this course
05:31 - and congratulate you on taking a step to
05:33 - become a better cute for python
05:35 - developer cute is a cross-platform
05:38 - application development framework you
05:40 - can use it to write applications for
05:42 - Windows Mac Linux Android iOS and even
05:45 - embedded devices the way QT works you
05:47 - write your code once and recompile it
05:50 - for your Target platform so for example
05:53 - if you write your application on Windows
05:56 - if you wanted to generate a Linux binary
05:58 - what you need to do is to recompile your
06:01 - code on a Linux machine and that's going
06:04 - to give you a binary that can run on
06:06 - Linux you can repeat the process on the
06:09 - Mac and that's going to drastically
06:11 - reduce your development time because you
06:13 - basically write your code once and run
06:16 - it or recompile it for whatever Target
06:18 - where you want to run your application
06:20 - now python is one of the official
06:23 - languages we can use to develop cute
06:25 - applications the main language for QT is
06:27 - currently C plus plus but python is
06:30 - quickly catching up under the umbrella
06:32 - of QT for python or Pi side 6 as it is
06:36 - currently known again going through
06:38 - python you can write applications that
06:40 - are cross-platforms that run on Windows
06:43 - Linux and Mac but currently support for
06:45 - mobile and embedded is in development I
06:48 - wouldn't really use this in production
06:50 - but there should be good progress in
06:53 - this area in the future now if you talk
06:55 - about Pi side sex some people are going
06:57 - to mention Pi QT what about by QT
07:00 - piquity is another Library which is
07:02 - available to let you write QT
07:04 - applications using the Python
07:06 - programming language and it can mostly
07:08 - do the same things we can do with pi
07:11 - side 6 but Pi side 6 has probably a
07:15 - better future because it is under the
07:17 - official QT project so you can expect
07:20 - support for things like Android and iOS
07:23 - to go faster than Pi QT another thing is
07:26 - that to use piquity in a commercial
07:28 - application and you need to buy a
07:30 - separate license for pi QT and you also
07:34 - need to buy another license for QT so if
07:36 - you really want to drive your cost down
07:39 - it is beneficial to use Pi side because
07:42 - you will be buying the license once
07:45 - which is going to include the QT and Pi
07:47 - side sex so that's something for you to
07:49 - consider but I'm going to leave the
07:51 - decision to you whether you use Pi QT
07:53 - and Pi side this course is not going to
07:55 - cover up iqt but the good news is that
07:58 - once you have Pi side 6 mastered it is
08:01 - going to be very fast to pick up Pi QT
08:03 - because the apis are mostly similar
08:06 - what's going to change is what you
08:08 - import in your python files and you will
08:10 - be basically able to do the same thing
08:11 - so whether you use 5qt or Pi side 6
08:14 - that's going to be your choice but we
08:16 - will be focusing on Pi side 6 and the
08:19 - API should help you to pick up iqt if
08:22 - you happen to need that now let's head
08:24 - over to the QT page on Wikipedia and see
08:27 - some information about QT it is a
08:30 - cross-platform application development
08:32 - framework you can use to write
08:33 - applications for Android iOS Linux you
08:37 - can see a lot of things here you can
08:39 - write applications for using QT it was
08:42 - developed by these two guys Harvard and
08:45 - Eric and it is currently developed by
08:48 - the QT Company the company owning
08:50 - licenses of QT it is written in C plus
08:53 - plus and what I want you to see is a
08:57 - bunch of applications that are written
08:58 - in QT to kind of give you an idea of
09:01 - what you can do if you learn a QT
09:03 - properly if you go down here you see
09:05 - Autodesk Maya which is a popular
09:07 - application for building 3D stuff we can
09:10 - go down and find the Creator here which
09:12 - is a design software you can use to do
09:15 - painting and drawing things like that
09:17 - you can say Mathematica if you are a
09:19 - scientist you must know this you can see
09:21 - OBS here which is what I am using to
09:24 - record this video you can see Cube bit
09:27 - torrent you can use to download torrents
09:28 - and things it's like that there are
09:30 - really powerful applications that are
09:33 - written in QT you can see VLC media
09:36 - player you can see WPS office which is
09:38 - really cool if you wanted to do some
09:40 - office stuff and if you go down you will
09:43 - find a bunch of organizations that are
09:45 - using QT and there are some big names in
09:49 - here you can see AMD you can see
09:51 - blizzard you can see DreamWorks you can
09:53 - see Panasonic Phillips you can see CMS
09:56 - and Samsung you can see Tesla there's a
09:58 - lot of big companies using QT and this
10:01 - should give you an idea of how powerful
10:03 - QT really is and you can be in the same
10:06 - league as these companies and these
10:08 - pieces of software if you learn to
10:11 - develop applications with QT properly
10:13 - and this course is a perfect starting
10:16 - point if you want to use Python to
10:18 - develop cute widgets applications okay
10:21 - one thing I want you to know is that
10:22 - there are two apis when it comes to
10:24 - developing QT applications there is the
10:28 - cute widgets API AI which provides
10:30 - components you can use to build
10:32 - graphical user interfaces for desktop
10:34 - this is mainly targeted for desktop
10:37 - platforms mainly Windows Linux and Mac
10:39 - but there is a new API which is called
10:43 - qml which also includes new devices like
10:48 - mobile devices and embedded devices and
10:52 - you can use this to build Dynamic and
10:54 - fluid graphical user interfaces that
10:56 - look modern and really feel like they
10:58 - are from our time here but make no
11:01 - mistake qml applications can also run on
11:03 - desktop so you will need to do some
11:05 - research to decide whether you want to
11:07 - use cute Widgets or qml but if you
11:10 - exclusively want to Target a desktop I
11:13 - would still recommend using cute widgets
11:15 - because it is a mature API it is tested
11:18 - it has been in use since the 1990s and
11:21 - it is really powerful so use that if you
11:23 - don't care about mobile or embedded if
11:25 - you want to Target mobile and embedded
11:27 - please use qml in it is best suited for
11:30 - that and one thing I want to point out
11:32 - is that this course is about cute
11:34 - widgets if you are interested in qml
11:36 - please check out other courses we have
11:38 - on qml because this course is not
11:40 - talking about qml I wanted that to be
11:43 - super clear now if you decide to use QT
11:45 - to build your applications regardless of
11:48 - whether you are using widgets for Q
11:49 - amount you will be writing your logic in
11:52 - some programming language and the two
11:54 - official languages that are supported by
11:57 - the QT company or the cute projects in
11:59 - general is python which we will be
12:02 - covering in this course year and C plus
12:04 - plus but this course as I said is about
12:07 - using python to develop cute widgets
12:10 - applications so this is going to be our
12:12 - Focus here using python to write cute
12:15 - widgets application that can run on
12:18 - Windows Mac and Linux another thing I
12:20 - would like you to know is that cute is
12:23 - not just about graphical user interfaces
12:25 - many people can mistake it for that cute
12:28 - can can be used for much more if you
12:30 - happen to be using QT already for a
12:33 - graphical user interface you still have
12:35 - a window to take advantage of even more
12:37 - things from the QT framework you can do
12:40 - networking you can do threading you can
12:42 - write database applications you can use
12:44 - tons of other utility classes that are
12:46 - provided by QT so if you are already
12:49 - using QT take some time to see some
12:52 - other things you can take advantage of
12:54 - in this course I will touch on some
12:56 - networking and show you how you can do
12:58 - some basic HTTP stuff but that's not
13:01 - enough to really call yourself a network
13:04 - developer using QT if you want to really
13:07 - go deep you will need to do more
13:08 - research but this course should give you
13:11 - a good foundation on which to build even
13:14 - more cool stuff now this course is going
13:16 - to be a perfect starting point for you
13:18 - if you want to build graphical user
13:20 - interfaces in Python using pi side 6
13:22 - obviously but I think it is even going
13:26 - to give you a good foundation even if
13:28 - you plan to use them out if you are new
13:30 - to the QT ecosystem I usually recommend
13:32 - shredding by cute widgets which is what
13:35 - we cover in this course and from there
13:37 - you will grasp the fundamentals of how
13:39 - to use QT to write cross-platform
13:41 - applications and that's going to really
13:44 - be easy for you to do that because you
13:46 - will be writing your applications on
13:48 - desktop you will be able to generate
13:50 - applications that run on the same
13:52 - machine where you are sitting once you
13:54 - have the fundamentals you can Venture
13:56 - into qml and the same fundamentals you
13:59 - get from cute widgets are going to apply
14:01 - more or less in qml qml is a declarative
14:05 - language and that makes it easy to pick
14:07 - up by designers but this course is about
14:10 - cute widgets using Python and it is
14:12 - going to give you the fundamentals that
14:15 - are going to help you out even if later
14:17 - you decide to use qml that's the point I
14:20 - am trying to make here now I will be
14:22 - preparing this course on a Windows
14:24 - machine but that's not going to be a
14:27 - problem because Python and high side 6
14:29 - run where both on Windows Linux and Mac
14:32 - so you can watch what I do on Windows
14:34 - and try to adapt that to your operating
14:36 - system and that's going to work really
14:38 - well don't worry about that this course
14:40 - is going to work for you whether you are
14:42 - on Windows Linux or Mac the requirements
14:45 - for this course are not really that hard
14:47 - all I require is a basic understanding
14:49 - of Python and the basic understanding of
14:52 - object-oriented programming in Python if
14:55 - you can use things like classes objects
14:57 - inheritance and polymorphism you will
14:59 - probably be fine with the course using
15:01 - python here the most important thing in
15:04 - my opinion is the strong drive and
15:06 - willingness to learn which is going to
15:08 - go a long way if you come along problems
15:11 - you won't give up easily you will keep
15:13 - trying until you get to the thing
15:14 - running here but I will do my best to
15:17 - explain everything I use in the course
15:19 - if you need a refresher on python please
15:22 - note this course is going to assume you
15:23 - already know python so make sure you
15:26 - learn python first before you take all
15:28 - discourse now this is all I had to cover
15:31 - in this video here I hope you found it
15:33 - interesting and you are encouraged and
15:36 - excited to learn about Pi side six we
15:39 - are going to head over in the next
15:40 - lecture and show you some of the cool
15:42 - applications you get to build as you go
15:44 - through the course here go ahead and
15:46 - finish up here and meet me there in this
15:49 - lecture we're going to see how you can
15:51 - get the most out of the course here and
15:53 - there is really no magic build you can
15:55 - take to get to the knowledge from the
15:57 - course Detroit and true way is to follow
15:59 - along watch the videos try to practice
16:02 - the things I do in the course try to
16:04 - modify the code and make it yours and
16:06 - that's really how you are going to get
16:08 - the mask out of the course here another
16:10 - thing I would recommend is to use the QT
16:13 - examples so if you go to the browser for
16:16 - example and search for QT examples I
16:20 - think they have a lot of examples you
16:22 - can browse to this link they will show
16:24 - you tons and tons of examples and this
16:27 - is a way you can get full running
16:29 - applications you can try out most of
16:33 - these are going to be for C plus plus
16:34 - but once you have the fundamentals in
16:36 - this course you will have the necessary
16:39 - Basics to try and understand what is
16:41 - going on here if you go down you see
16:43 - examples for acute widgets for example
16:45 - if we open the text editor example here
16:48 - all the model view example people you
16:50 - will see that you can build something
16:51 - like this and this is something we even
16:52 - built in our course here but that's
16:56 - going to be in Python you can learn
16:58 - about the model view architecture you
16:59 - can really do all kinds of prison things
17:01 - through these examples here so if you
17:04 - have an idea come to the QT examples see
17:06 - if there is something similar try to
17:08 - build on top of that this is the best
17:11 - way I can recommend to even learn QT by
17:13 - yourself without even needing a course
17:16 - like this but if you are a beginner the
17:18 - documentation like this can be hard to
17:20 - understand you still need the basics
17:22 - this course is going to give you the
17:24 - basics to allow you to take advantage of
17:26 - this but start trying to browse through
17:28 - these examples now see what you can pick
17:31 - up or even identify the things you need
17:33 - to focus on in the course here once you
17:35 - have the knowledge you can come back and
17:37 - use it another thing I recommend is to
17:39 - use the source code that is going to be
17:41 - provided in the course here the link is
17:44 - going to be shared at each lecture so if
17:46 - you want you can go to the lecture
17:48 - download the source code and use that
17:50 - however you want another thing I would
17:52 - recommend is asking questions if you get
17:54 - stuck the course platform will provide a
17:57 - mechanism to ask questions so you can
17:59 - ask a question I will try to respond as
18:01 - best as I can so take advantage of that
18:04 - if you get stuck we also have a bunch of
18:06 - groups on Facebook and Discord you can
18:09 - join and help each other out that's a
18:12 - really good way to learn and to find
18:13 - people who are going through the same
18:15 - thing take advantage of all these
18:17 - channels to make the most out of the
18:19 - course here I want you to be successful
18:21 - in using pi site 6 to build
18:24 - cross-platform desktop applications now
18:27 - that you know this it is time we headed
18:29 - over to the next lecture and started
18:31 - setting up the environment for building
18:34 - Pi side 6 applications in no time go
18:37 - ahead and finish up here and meet me
18:39 - there
18:40 - in this video we are going to set up the
18:43 - environment that is going to allow us to
18:46 - build cute for python applications or Pi
18:49 - side 6 applications and the tools we
18:52 - install should work on Windows Mac and
18:54 - Linux because that's the essence of QT
18:56 - QT is a cross-platform framework that
19:00 - allows us to write applications once and
19:03 - be able to build them on different
19:05 - platforms and in this course we are
19:07 - interested in building for Windows Mac
19:10 - and Linux so here are the tools we are
19:13 - going to need we will need an
19:14 - installation of python once we have
19:16 - python we will install Pi side 6 and we
19:19 - will need an editor through which we
19:21 - will be typing python or Pi side 6 code
19:25 - later in the course we will need QT
19:28 - designer but I am going to show you how
19:30 - to install it later at that time for now
19:33 - we will get into the process of
19:36 - installing python Pi side 6 and the
19:39 - editor that we are are going to be using
19:41 - in this course here another thing I
19:43 - should say is that you don't have to use
19:45 - Visual Studio code it happens to be an
19:47 - editor that I prefer because it's free
19:49 - it's cross-platform it looks and feels
19:52 - the same whether you are on Windows Mac
19:54 - and Linux and I expect a lot of students
19:57 - to be watching this course on a
19:59 - different operating systems so visual
20:01 - studio code is a good choice here okay
20:03 - so let's start with python here if you
20:05 - go to your search engine and type python
20:08 - install we will go to the python.org
20:12 - website and you will find binaries you
20:15 - can download for whatever operating
20:17 - system you are on so if you hit download
20:20 - here you will download it and install it
20:22 - like you install any other application
20:24 - and when you are done installing python
20:26 - you should be able to go to your
20:28 - terminal whatever terminal you have
20:30 - installed and say Python and if you see
20:33 - a message like this it means that python
20:35 - is installed on your system now we have
20:37 - python installed let's set out of this
20:40 - accept okay we are done here now that we
20:45 - have python installed okay now that we
20:47 - have python installed we need to install
20:49 - Pi side six and to do that it's really
20:52 - simple all you have to do is to open
20:54 - your terminal here and use the PIP
20:57 - package manager for python we will be
21:00 - using version three here so let's say
21:02 - pip 3 install Pi side six type this on
21:07 - your terminal if you hit enter the tool
21:10 - is going to go to work and it is going
21:12 - to download and install Pi type 6 on
21:14 - your system and at this point we will
21:16 - have python at Pi side 6 installed on
21:19 - our system the next thing we want to do
21:21 - is to install an editor and as I said we
21:24 - will be using visual studio code in this
21:26 - course here so let's go back to our
21:29 - search engine and say Visual Studio code
21:31 - download this should spit out a link to
21:36 - the website or Visual Studio code and
21:38 - you can download and install for for
21:41 - your operating system I am on windows at
21:43 - this moment so I can download and
21:46 - install it on Windows but you can do the
21:48 - same whether you are on Linux or on a
21:51 - Mac once you have this installed you
21:53 - will need to open it up if you open it
21:56 - it's going to look something like this
21:58 - and the first thing I want you to do
22:00 - once you have it installed is to install
22:02 - a python extension that is going to make
22:05 - our life easier when working with python
22:08 - code and all you have to do is type a
22:10 - python in the search bar here let's make
22:13 - sure it is highlighted so everybody can
22:15 - see it so we have this guy here and I
22:18 - want you to choose the one that says
22:20 - python here and I want you to choose the
22:22 - one that says python here okay the one
22:26 - from Microsoft if you click on it it's
22:28 - going to say intellisense the LinkedIn
22:30 - debugging for whatever in a visual
22:32 - studio code you will click on install
22:34 - and wait for it to be installed and at
22:37 - that moment you will be ready to start
22:40 - using Visual Studio code to develop cute
22:43 - for python applications using pi site 6.
22:47 - okay now that we have this installed
22:49 - it's time to test it and see that it
22:51 - actually works what we are going to do
22:54 - is to open a folder on our system let's
22:56 - go somewhere on my drive here I have a
22:59 - folder it is an empty folder you can
23:01 - name it whatever you want and if you go
23:03 - in you're going to see that it is an
23:05 - empty folder what we are going to do is
23:08 - to drag and drop this on top of Visual
23:12 - Studio code and this is going to open
23:13 - the folder inside videos video code we
23:16 - are going to get a window that says do
23:18 - we trust this folder yes I trust this
23:21 - because I created it so yes trust the
23:24 - authors and we will have something on
23:27 - the left here and this is going to be
23:29 - where we see our files and this section
23:33 - here is going to be the editor in which
23:35 - we're going to be typing stuff so
23:37 - nothing special here let's go on the
23:39 - left and hover over these buttons here
23:42 - you see we see one that says new file
23:45 - another says new folder we want to click
23:48 - on the one that says new file and in
23:51 - this window we will type main.py for
23:55 - python if we do that we will create a
23:58 - python file here and all we need to do
24:00 - is to put in Python code that is going
24:02 - to attempt to use the pi side
24:04 - installation we just brought into our
24:07 - computer here okay so what we are going
24:09 - to do is to put in some code to test
24:11 - things out I don't really expect you to
24:14 - understand everything we do here all we
24:16 - want to do is to make sure that the
24:18 - environment works we will have a chance
24:20 - to learn about all the things we see in
24:22 - this piece of code and even more so
24:25 - let's put in an import statement and
24:27 - this is just going to import Q
24:30 - application and Q widget and these are
24:32 - classes we're going to be using to
24:34 - create our widgets application after
24:36 - that we can go down and say import sys
24:39 - and this is going to import a facility
24:42 - that allows us to work with command line
24:45 - options in Python if you know python you
24:48 - probably know about command line options
24:50 - we can go down and create a variable app
24:53 - and we're going to say Q application and
24:55 - assists args and after that we will
24:59 - create a window
25:00 - and it's going to be a q winner
25:03 - we will show the window and after that
25:05 - we will start the application by calling
25:08 - the exec method okay now that we have
25:10 - this we can try to run it but before we
25:13 - do please make sure you have exactly the
25:16 - same thing as I do here I would even
25:18 - recommend going to the GitHub repository
25:20 - for the course and copying and pasting
25:23 - this entire code here because at this
25:26 - point you may not be familiar with these
25:28 - things like Q application Q widget and
25:30 - some people are going to introduce typos
25:32 - and have unnecessary frustrations so I
25:35 - do recommend using the code AS is here
25:38 - so you can copy from the GitHub
25:40 - repository and paste in here okay once
25:42 - you have the code in make sure you save
25:44 - so you can control s on this or file and
25:48 - save and after this we will open a
25:51 - terminal window we're going to come to
25:52 - view and say terminal and it's going to
25:55 - open a terminal window inside Visual
25:57 - Studio code in our current folder here
25:59 - which is a bit convenient and we will
26:01 - type python
26:03 - main.py and if we wait we're going to
26:06 - see a window pop-up and this is
26:08 - confirming that our installation of both
26:11 - Python and Pi side 6 is working and we
26:15 - are ready to start learning about cute
26:16 - for Python and this is really cool this
26:19 - is really all I had to share in this
26:21 - lecture and again the goal was to set up
26:23 - a development environment we can use to
26:26 - do what we do in this course here we
26:28 - have Python 3 installed we have Pi side
26:31 - 6 installed and we installed the editor
26:33 - that we will be using throughout this
26:36 - course here don't worry about QT
26:38 - designer at this point because we're
26:39 - going to need it later in the course and
26:42 - when we get to need it we will install
26:43 - it and you're going to see how cool all
26:45 - this is we are going to stop here in
26:47 - this lecture and I will see you in the
26:49 - next one
26:50 - in this lecture we are going to try and
26:52 - understand what is actually going on
26:54 - here in the last lecture we blindly
26:57 - typed in the code to make sure the
26:59 - environment is working but now is the
27:01 - time to try and get an idea of what is
27:04 - going on here
27:06 - before we do that we are going to go to
27:08 - where we saved our code and we'll copy
27:10 - the code from the last lecture and
27:13 - rename this zero to understanding the
27:15 - code I think that's going to work better
27:19 - and it's zero two not zero one so my
27:23 - body here and I am going to drag and
27:25 - drop this on top of Visual Studio code
27:26 - to open that project
27:29 - if I hit on main.py here you see the
27:32 - exact same thing we saw in the last
27:33 - lecture we have syntax highlighting now
27:37 - and the first thing I want you to do
27:39 - that is going to save you a little bit
27:40 - of time is to come to file and the
27:43 - toggle or to save okay you're going to
27:46 - click on auto save here and now things
27:49 - are going to be Auto saved as you type
27:51 - things and you won't have to hit Ctrl s
27:53 - or come here to say save that's going to
27:56 - save you a bit of time now let's try to
27:58 - understand the code but before we do
28:00 - let's make sure it actually runs so we
28:02 - can come to view terminal and hit the
28:06 - app arrow and this is going to bring
28:07 - back the command we typed the last time
28:09 - we run a visual studio code this is
28:11 - really cool if you want it
28:14 - you could uh type this python
28:18 - main.py and hit enter and uh python
28:24 - let's type that correctly
28:27 - and if we run we're going to see our
28:28 - window pop-up here now the code here the
28:32 - first line is importing the components
28:34 - that we need for this code for this
28:37 - project we need Q application and Q
28:39 - widget and these are part of the cute
28:41 - widgets module that comes as part of the
28:45 - pi side installation that we did so this
28:48 - is really important the components we
28:50 - need
28:51 - and here you could either import CIS or
28:54 - not import it but I just wanted you to
28:56 - see that it is possible if you want to
28:58 - process command line arguments okay so
29:01 - since is a module that is responsible
29:03 - for processing command line arguments
29:06 - and once you have them they are going to
29:08 - be picked up by the queue application
29:09 - instance you have here and you will be
29:12 - able to process them in your QT
29:14 - application so that's what the system
29:17 - here does okay once we have our assist
29:19 - thing here we can create our application
29:22 - and an application is really like a
29:25 - wrapper that is going to be in globing
29:28 - everything you do in your QT application
29:30 - so it is going to be the thing
29:32 - responsible for running your application
29:35 - and waiting for things to happen as you
29:38 - interact with your application for
29:39 - example if you click on a button all
29:41 - those things are going to be happening
29:43 - under a wrapper that is this app object
29:46 - here this is as simply as I can explain
29:49 - it after we have our application we will
29:51 - create our widget and we name it window
29:54 - in our application here and by default
29:57 - Widgets or Windows in qt are hidden so
30:00 - we need to show show it and after we
30:02 - show it we will call the exec method on
30:04 - our application to start the event Loop
30:07 - and the event Loop already is a while
30:10 - loop something that keeps looping around
30:12 - waiting for things to happen so for
30:14 - example if we run our application let's
30:17 - bring back our terminal and we run it
30:20 - again
30:21 - so for example if we run it and it
30:23 - happens to be a button in our
30:27 - application here if you click on the
30:29 - button the event Loop is going to be the
30:32 - thing that catches that click you do on
30:35 - the button and it is going to respond I
30:37 - realize I am jumping around here trying
30:40 - to go as deep as I can but that's the
30:42 - gist of what is happening here the exact
30:45 - call here is going to start the event
30:46 - Loop so let's say that here okay and
30:50 - this is really all that is happening
30:51 - here another thing I want to say is that
30:55 - if you have been working with python you
30:58 - may have seen things like this calling
31:01 - the exact method with an underscore
31:03 - after the C and let's try to run the
31:06 - code with this so let's bring back our
31:09 - terminal and try to run again and you're
31:12 - going to see that it is going to work
31:13 - but you see a comment saying that this
31:16 - thing will be removed in a future
31:19 - versions of python and they are
31:21 - recommend demanding using exec instead
31:23 - and this is coming because of older
31:27 - versions of python that had problems
31:29 - with the exact command here in Python 3
31:32 - I believe this is going to work well so
31:35 - the convention we will be using here is
31:37 - not to use the underscore we will be
31:39 - typing exactly like this and you will
31:42 - see the same things on the print
31:44 - function you have in Python so if you
31:46 - wanted to print something you can say
31:47 - print and it is going to print that but
31:50 - you can also use an underscore again
31:52 - this is something that comes from older
31:54 - versions of python but in this course we
31:57 - won't be using these underscores here
31:59 - another thing I want to point out is
32:01 - that you can use the documentation to
32:03 - learn about everything you want about Pi
32:05 - side 6. so for example if you want to
32:07 - learn about this widget thing we are
32:09 - using here you can go to your favorite
32:11 - search engine and say Pi site sets and
32:15 - say kill with it and this is going to
32:18 - pull the documentation for acute for
32:20 - python if you open this you will have
32:23 - all the information about that thing
32:26 - so let's see what they say here you can
32:28 - click on more
32:30 - and you can increase the size of this
32:32 - because I like larger text and it is the
32:36 - atom of the user interface it is a base
32:38 - widget on top of which you can build a
32:41 - lot of other things I do recommend
32:42 - reading up on this if this is your first
32:44 - time with QT so you can create a widget
32:47 - a widget can have a bunch of components
32:49 - you can create other widgets on top of
32:51 - this but we will have a chance to learn
32:53 - about all these things as we progress in
32:55 - the course but it won't hurt to take a
32:57 - moment and read about this and how you
32:59 - can use this in your python applications
33:03 - so this is all I had to share in this
33:06 - lecture trying to shade some more light
33:08 - on what is going on behind the scenes we
33:11 - are going to stop here in this lecture
33:12 - and the next one we will try and
33:14 - organize our code in separate files so
33:18 - that things are easier to work with I
33:20 - will see you in the next lecture in this
33:23 - lecture we are going to organize the
33:26 - code in classes to make things a bit
33:28 - easier to work with in the last lecture
33:31 - we did something like this even if we
33:33 - didn't use cumin window but the code
33:35 - looks strikingly similar and here we
33:38 - will be using everything in the global
33:41 - scope so we will be doing things in a
33:43 - single file you see we are importing
33:46 - this here to be able to process command
33:48 - line arguments we are creating a window
33:50 - and this is a different kind of window
33:52 - that can have menus toolbars and things
33:56 - like this and we will have a chance to
33:57 - learn about this later you're going to
33:59 - see how it looks in a minute another
34:01 - special thing about this kind of widget
34:03 - or window is that we can give it a
34:05 - central widget and that's what we want
34:07 - to do here to be able to use buttons so
34:10 - we have the window here we are going to
34:12 - give it a title using the set window
34:14 - title method and after that we will set
34:17 - up a button which is meant to leave
34:19 - inside this window here a button is
34:22 - something you can click on you can give
34:24 - it the text and once you have your
34:27 - windows set up again we have the window
34:29 - let's try to draw this here we have a
34:31 - big window inside the big window we will
34:34 - have a button and this button is going
34:36 - to have text here press me and this
34:39 - button is going to be within this window
34:42 - because of the setting we are doing here
34:44 - that's how these things work after we
34:47 - have the window we will show it and we
34:48 - will start our event Loop and the
34:50 - application is going to work now someone
34:53 - would argue that putting all the logic
34:56 - for these buttons and things in the same
34:58 - file is really bad and we need to
35:00 - organize this the first level of
35:03 - organization we're going to do is to
35:05 - extract the logic for the window in its
35:08 - own class and we do that using the code
35:10 - you see here so we will create a class
35:13 - in Python the class is going to be named
35:16 - button holder as you see right here and
35:19 - it's going to be inheriting from Humane
35:21 - window we will give it a Constructor and
35:23 - if you know python object-oriented
35:25 - programming this is not new to you so we
35:28 - will have a Constructor and in the
35:30 - Constructor we will be doing the things
35:32 - we were doing in our main python file
35:35 - you see we are setting up the window
35:36 - title we are setting up the button and
35:39 - we are telling the button to beat the
35:40 - central widget for this button holder
35:43 - class once we have this class setup we
35:46 - will create an object of it in our main
35:48 - python file again we have the
35:52 - application object we created a window
35:54 - notice what kind of window it is it is
35:57 - button holder and this is going to
35:59 - create an instance of the class that we
36:02 - just set up on top here once we have the
36:04 - window we're going to show it and kick
36:06 - off the event Loop and this is going to
36:08 - extract the logic of setting up the
36:10 - window and doing all kinds of crazy
36:12 - things in this class here someone would
36:15 - argue that this is still not
36:17 - maintainable it is bad we see the logic
36:20 - for the buttons and the windows in our
36:22 - main python file well we can do even
36:24 - better and create a version 3 of our
36:27 - application in which we are going to
36:29 - extract the button in a separate file so
36:32 - we can do something like this we can
36:33 - create a file and name it
36:35 - buttonholder.py and inside that file we
36:39 - will put in the code to create our
36:40 - buttons and windows and all kinds of
36:42 - crazy things now in the main file what
36:45 - we are going to do is to import the
36:47 - things we need to use we will Import
36:49 - Sales import application import button
36:52 - holder and after that we will be able to
36:54 - use button holder even if the details of
36:58 - this battle holder class are not in this
37:00 - file here and our main adopt py file is
37:03 - going to be a bit easier to look at and
37:06 - this is the main goal of this lecture
37:08 - here making it easier to organize or
37:10 - code in classes to make it easier to
37:12 - work with now that we know this we're
37:14 - going to head over to visual studio code
37:16 - and play with us a little more okay here
37:18 - we are in Visual Studio code and here is
37:22 - the code we will be using here
37:23 - organizing code in classes if you go in
37:27 - you're going to see that it is a folder
37:29 - with the main python file so we're going
37:32 - to be starting from there let's drag it
37:34 - and drop it on top of Visual Studio code
37:36 - or to open it and if you look it is the
37:39 - same thing we had in the last lecture
37:41 - let's clean all this up and we will put
37:44 - in the code for this lecture here we
37:46 - will go on top and put in version one of
37:49 - our code and to save on time I am just
37:52 - going to paste in the code here and take
37:55 - a moment to explain it because typing it
37:57 - would really waste our time I will type
37:59 - when I see that it is going to add value
38:01 - but for now we just want the code here
38:03 - in our editor so we are importing the
38:06 - things we need we need queue application
38:07 - Q main window and Q push button and now
38:10 - that you see these new classes that you
38:13 - don't know about it is a good time to go
38:15 - to the search engine and try to learn as
38:18 - much as you can about them so we can go
38:21 - to
38:22 - our search engineer and say Q main
38:26 - window okay Q main window
38:28 - and if we go and click here and again I
38:32 - do recommend reading as much as you can
38:34 - about this this is a main window that
38:36 - provides a framework for building and
38:38 - applications user interface and one
38:41 - thing that is special about this class
38:43 - is that it allows you to set up things
38:45 - like menu bars toolbars dock widgets
38:48 - status bars and things like this and it
38:51 - is a really cool thing to have in your
38:52 - application if you need these kinds of
38:54 - things so we are going to be using a
38:57 - basic version of this but I don't
38:59 - recommend reading as much as you can
39:01 - about this so let's come back to our
39:03 - editor so we have a main window object
39:06 - we are creating that is going to allow
39:08 - us to set up menu bars status bars and
39:11 - all kinds of crazy things we are going
39:13 - to give it a window title and down below
39:16 - we are creating a button Q push button
39:18 - and again this is a good time to come to
39:21 - your search engine and look for a q push
39:24 - button so let's do that okay come here
39:27 - you should really drill this Habit in
39:30 - your workflow because it's going to
39:31 - allow you to learn more things than I
39:34 - could even tell you in a course like
39:36 - this so the push button or command
39:38 - button is perhaps the most commonly used
39:40 - widget in any graphical user interface
39:42 - so you can click on it and things are
39:45 - going to happen and this is really how
39:46 - it works this is how you create it and
39:48 - you can connect slots to it and you can
39:50 - do all kinds of crazy things with this
39:53 - button component here for now we are
39:55 - just interested in making it show up in
39:58 - our user interface because it is easier
40:00 - to work with after we have the button we
40:02 - will tell our main window to use the
40:05 - button as it's Central widget once we
40:08 - have the window we will show it and we
40:10 - will kick off the event Loop by calling
40:13 - the exact method here this is all we are
40:15 - doing now that we have this remember
40:17 - this is going to auto save because of
40:19 - the setting we did here you see autosave
40:21 - is toggled on we can show our terminal
40:24 - okay and we can hit up to bring back our
40:29 - Command and let's make sure it is
40:31 - highlighted so everybody can see it this
40:33 - is the command we have right here python
40:36 - main.py if we hit enter with this this
40:39 - is going to show a window and if we
40:42 - resize just a little bad I want you to
40:44 - notice some of the things we did we have
40:47 - our window title on top here okay you
40:50 - can see it right here and we set it up
40:51 - using this line here and we have a
40:54 - button in the middle of the window right
40:56 - here this is our button and it is saying
40:59 - press me you can see the text here and
41:01 - it is the text we set up here and I
41:04 - really want you to make sure you
41:06 - understand the relationship between the
41:08 - code you type and the things you see
41:10 - when you get to run your application
41:13 - because this is going to give you a firm
41:15 - understanding of how Pi side is working
41:18 - to give you the user interface you are
41:20 - seeing here now we have the application
41:22 - here but some of you might argue that it
41:26 - is really not well organized to save the
41:29 - list to have the window and button logic
41:32 - in our main python file and we will try
41:35 - to improve on this what we are going to
41:37 - do is to comment out our version one
41:39 - here and I am going to put in a pair
41:42 - year of block comments in Python this is
41:45 - how you do it in Python you have three
41:48 - double quotes and three double quotes
41:49 - and in the middle you're going to put in
41:51 - your code and that's going to be
41:52 - commented down and I can copy what I
41:55 - want to comment down
41:56 - okay so let's put my code in here and
41:59 - leave the comment on top this is a one
42:02 - line comment in Python this is how you
42:04 - do it and we will do version two and in
42:08 - version two we will be creating a
42:10 - separate class but the class is going to
42:12 - still be living inside our main python
42:14 - file here to do things in steps we can
42:17 - go down and do our Imports these are the
42:20 - same things we have been doing for a
42:22 - long time we will go down and set up our
42:25 - class
42:26 - class battle holder and it is going to
42:29 - be inheriting the Q main window we will
42:32 - set up our Constructor
42:36 - and it is going to be calling the parent
42:39 - Constructor
42:40 - and it is going to be calling the super
42:44 - Constructor or the its parent
42:46 - Constructor
42:47 - now this class is going to be inheriting
42:50 - from Human window so it is also going to
42:52 - be some kind of human window in other
42:55 - words it is going to have access to
42:57 - methods we have in Q main window what
43:00 - that means is that we can say something
43:02 - like self set window title and we will
43:06 - be we will be stealing this method from
43:10 - cumin window and being able to use that
43:12 - in our button holder class this is
43:14 - classic inheritance in object oriented
43:16 - programming so I don't need to say much
43:19 - about this so let's put in our text
43:22 - after that we will set up our button
43:24 - because we have q push button imported
43:27 - here so let's say button
43:29 - equals Q push button press me
43:33 - and the next thing we need to do is to
43:36 - set up the button as our Central widget
43:39 - again we have access to descent Central
43:42 - widget method because this is a main
43:45 - window it is inheriting from Human
43:47 - window again that's what you should
43:50 - understand here so we're going to say
43:51 - self set Central widget and we will pass
43:55 - our Button as the central widget
43:58 - okay now that we have this we can go
44:00 - down and do the usual thing we did on
44:03 - top for example we can even copy from
44:06 - what we did before okay so we can create
44:09 - our application objects we're going to
44:11 - go all the way to the bottom
44:13 - we're going to create our application we
44:16 - want to create a main window now we are
44:19 - going to be creating a button holder so
44:22 - what we can do is go on top and say
44:25 - button holder so we will have our button
44:27 - holder here and we will take out the
44:30 - line to set the central widget because
44:33 - we are doing that in our button holder
44:36 - now that we have this I think we are
44:38 - ready to start running this thing again
44:41 - we have our class which is going to be
44:42 - wrapping around the logic to show the
44:44 - window and put in the fence inside the
44:47 - window and we are doing all this in the
44:49 - Constructor of our button holder class
44:51 - this is really cool let's bring up our
44:54 - terminal window and make sure we can run
44:57 - this
44:58 - and if we run this huh what is the
45:01 - problem here I think it is the self-tent
45:04 - we are passing here so let's try to run
45:06 - again
45:07 - and now you see that we see the same
45:10 - thing we saw before but now we have
45:12 - extracted the logic for a button holder
45:14 - and setting up the window and putting
45:16 - things inside the window in its own
45:19 - class and this is really cool now again
45:21 - we can do better than this by moving
45:24 - this button holder class in its own
45:26 - separate class or its own separate file
45:29 - I should say let's do that we are going
45:31 - to comment out this let's put in our
45:35 - blog comment section and we are going to
45:37 - move everything we don't want in here
45:40 - from this section into our comment and
45:44 - what we will do is to create
45:47 - a new file let's copy the code for the
45:52 - button holder class here and I'm going
45:55 - to copy that let's go to the left and
45:58 - create a new file call it button
46:00 - holder
46:02 - Dot py and inside this file we are going
46:05 - to paste in our class again nothing
46:07 - special here we don't need the queue
46:09 - application here because your
46:11 - application is used in our main python
46:13 - file but we need the Q main window and Q
46:16 - push button we don't need this imported
46:18 - here okay now what we need to do is to
46:22 - just copy the part that instantiates the
46:25 - button holder fan okay we can do that
46:29 - and for this to work we need to import Q
46:33 - application so let's do that we can copy
46:35 - the line that does this here and says
46:38 - think we need CC I think we also need
46:41 - the sales imported let's do that and now
46:44 - we need to also import the battle holder
46:47 - class we are going to say from button
46:50 - holder import
46:53 - button holder and this is going to give
46:55 - us access to these things and you see
46:58 - that all the Dirty Work to set up the
47:00 - main window and put fence inside the
47:01 - window is moved in our button holder
47:05 - file and this is really cool this is
47:07 - what I wanted you to see and we will be
47:09 - doing things this way going forward in
47:11 - the course to make our organization a
47:13 - bit easier let's show our terminal
47:17 - window and run to make sure everything
47:19 - still works I think we still have
47:22 - something running here let's run let's
47:25 - say python Main
47:28 - and if we do that this is going to run
47:31 - and we see our thing here and our code
47:33 - is organized in classes and this
47:36 - achieves what we set out to do in this
47:38 - lecture here in this lecture we are
47:40 - going to learn about signals and slots
47:43 - in queued and the signals and Slots are
47:46 - a mechanism that QT provides to connect
47:49 - things in other words when something
47:52 - happens we want to respond in some other
47:55 - part of our code suppose on the left
47:58 - here we have a push button and we want
48:00 - to do something when that button is
48:02 - clicked the way we do that we set up a
48:05 - piece of code that is going to respond
48:06 - to the right here
48:08 - and when the button is clicked QT is
48:11 - going to emit the signal this signal is
48:13 - going to be picked up by whoever might
48:15 - be interested in this button being
48:17 - clicked and they are going to respond
48:20 - the mechanism QT provides allows us to
48:23 - connect signals to slots and when you
48:26 - have made this connection when somebody
48:28 - clicks on the button the method that is
48:31 - responsible for responding is going to
48:33 - respond and do whatever it is you do in
48:35 - the body of that method suppose we are
48:38 - operating a message whenever you click
48:39 - on the button we are going to print a
48:41 - message whenever you click on the button
48:42 - we are going to print a message
48:44 - and QT provides a simple syntax to allow
48:47 - us to do that let's look at that here I
48:50 - have a piece of code and what I am
48:53 - setting up here is a simple button
48:56 - you can see that right here and we want
48:59 - to respond when this button is clicked
49:01 - we say that we want to respond in this
49:04 - piece of syntax you see here so we say
49:07 - button the name of the variable we say
49:09 - that and then we say the signal that we
49:12 - want to respond to in this case the
49:15 - Signal's name happens to be clicked and
49:19 - once we do this we are going to call the
49:21 - connect method on this
49:23 - and when we say connect we are going to
49:25 - specify the method that is going to
49:28 - respond to this button being clipped
49:31 - Within These parenthesis here in this
49:34 - case it happens to be button collect if
49:36 - you look on top here we have this method
49:39 - we are defining it and in the body of
49:41 - this method we are just saying a message
49:43 - you clicked on the button so this is
49:45 - what we are doing here we are connecting
49:47 - a slot or a method that is going to
49:51 - respond when this button is clicked and
49:54 - this is what does this connection here
49:56 - so some of you must be asking Daniel how
49:59 - did you know that we have this clicked
50:01 - signal on our button and this is another
50:05 - instance of where you need to use the
50:07 - documentation so we are interested in
50:10 - the Q push button component we want to
50:12 - see which kind of signals this component
50:15 - emits let's go to our search engine
50:17 - pretty fast
50:19 - so let's close all of this here and we
50:22 - are going to say Q push button or QT for
50:25 - a python and if we do that we will have
50:28 - the documentation for a q push button if
50:30 - you click on more it is going to tell
50:32 - you everything about this component but
50:35 - what we really want is to see the
50:37 - signals that this component emits and if
50:40 - you go down in here we see synopsis
50:42 - functions virtual functions slots so
50:45 - this is a slot you can activate if you
50:47 - want to do something like this but we
50:50 - don't see any signal from this component
50:53 - and this is because all of these signals
50:56 - are coming from a parrot class of this
51:00 - push button component
51:02 - and that happens to be what you see here
51:04 - this little thing called the two
51:06 - abstract button the documentation for
51:09 - cute for python is not really good for
51:11 - example we can't scroll around to see
51:13 - the things that are cropped off but we
51:15 - are lucky in this instance we can see Q
51:17 - abstract button if you click on this
51:20 - this is going to open the documentation
51:22 - for Q abstract button if you click on
51:24 - more it's going to tell you what this
51:26 - does it is going to implement an
51:29 - abstract button and all kinds of buttons
51:31 - we have in qt are going to be inheriting
51:34 - from this button here but again what we
51:36 - are interested then are the signals that
51:39 - might be emitted by this component again
51:41 - we see functions if we scroll down we're
51:44 - going to see virtual functions if we go
51:47 - down we're going to see slots we can
51:49 - activate if we go down we're going to
51:51 - see signals and this is what we are
51:53 - interested in so the Q push button
51:56 - component can emit a signal to let us
51:58 - know that it is clicked it can emit to
52:00 - let us know it is pressed it is released
52:03 - it is toggled and we can do all kinds of
52:05 - crazy things we can even grab these
52:08 - arguments or these parameters and use
52:10 - them to do things in our QT for python
52:13 - applications so let's go back to our
52:16 - slides now that you know where I got to
52:19 - the information that we have
52:21 - this clicked signal so we have connected
52:24 - to it and then after we do this
52:26 - connection and start the application
52:28 - when we click on the button we're going
52:30 - to see the message from our method here
52:33 - and this is going to be really cool so
52:35 - we are just responding when we click on
52:37 - the button and we know the syntax we use
52:39 - to do that and this is really cool we
52:41 - can go even further and grab the
52:43 - parameter that is emitted by the signal
52:46 - for example if you go back to our
52:48 - documentation in the browser you're
52:50 - going to see that the clicked signal can
52:52 - emit a parameter to let us know whether
52:55 - the button is checked or not we're going
52:58 - to take advantage of this and show you
53:00 - how to handle parameters and signals we
53:03 - can go back to the slides and what we
53:06 - are doing here after we set up the
53:07 - button we're going to make it checkable
53:10 - and this is going to make it toggle its
53:13 - state whenever we click on it so if we
53:16 - click on it first it's going to be
53:17 - checked if we click on it again it's
53:19 - going to be unchecked and it is really
53:21 - going to be simulating the behaviors we
53:24 - have with check boxes if you click on
53:27 - the checkbox it's going to be checked
53:29 - you click on it again it's going to be
53:30 - unchecked and it is basically going to
53:32 - be titling between these two states
53:34 - that's what we are simulating here with
53:36 - our Q push button component but we are
53:39 - doing this because we know when it emits
53:42 - the clicked signal it can also give us
53:44 - information whether it is checked or not
53:47 - and we are going to be printing that
53:49 - state in this print statement here so we
53:53 - are just going to say print
53:55 - and we are going to print the data
53:57 - parameter that we get in this function
53:58 - here and we are just doing the usual
54:01 - connection we did before notice we are
54:02 - saying button clicked connect and we are
54:05 - activating the button clicked method
54:08 - whenever this button is clicked and that
54:10 - method happens to be on top here so this
54:13 - is something we can do we can respond
54:15 - when something happens and grab the data
54:17 - that was sent to us by the signal and
54:20 - use that in our method and this is
54:22 - really cool
54:23 - let's look at another example before we
54:26 - head over to visual studio code and play
54:28 - with us here we are going to use a
54:30 - slider so we will set up a slider
54:32 - component and again this is something we
54:34 - have in QT this is going to be something
54:37 - like this where you have a slider that
54:39 - you can slide around to increase or
54:41 - decrease values we are going to give it
54:43 - a minimum a maximum and a value and
54:46 - whenever we move the slider the slider
54:49 - is going to emit signals that its value
54:51 - is changing and because I checked the
54:54 - documentation I know that the slider has
54:57 - a value changed signal let's go to the
55:00 - documentation and really show you this
55:02 - you should be able to find things out on
55:05 - your own in the documentation let's say
55:07 - Q slider
55:08 - and if we open this up in another tab
55:12 - we are going to see all about this
55:14 - component you can read about this here
55:16 - but we are interested in signals that it
55:19 - might Emit and we don't see
55:22 - okay if we go down here
55:25 - we're going to say that this slider is
55:27 - going to inherit a comprehensive set of
55:30 - signals and among these signals we have
55:33 - a value changed okay if we click on this
55:37 - we are going to see that this signal is
55:39 - going to pass a value to us and we can
55:41 - grab this value and do things with it in
55:44 - our QT for python applications so this
55:47 - is what we are doing in the slides here
55:48 - we are grabbing that value okay and
55:52 - printing that out in our print statement
55:54 - here and all this is happening because
55:57 - of the connection we did here so
55:58 - whenever the value changes we want to
56:01 - call this method to respond to the
56:03 - slider moving and we will grab the
56:05 - current value from the slider and do
56:07 - things with that now that you know all
56:09 - this and again I realize it is a lot of
56:12 - information but we're going to go
56:13 - through the step by step in Visual
56:15 - Studio code and I hope you are going to
56:17 - understand so let's go there and play
56:19 - with this okay here we are in a visual
56:21 - studio code we have an empty folder in
56:24 - which we will be doing our thing let's
56:26 - grab and drag on top of Visual Studio
56:29 - code to open this and we will create our
56:31 - main python file main.py and this is
56:35 - going to give us our starting point the
56:37 - first thing we are going to do is to put
56:39 - in version one of our application here
56:43 - and again I am not going to type all
56:46 - this we are just importing the
56:48 - components we need we are setting up a
56:50 - method that is going to respond when the
56:52 - button is clicked we are setting up our
56:54 - application object the button
56:56 - and we are doing the most important
56:58 - thing here let's take out the line and
57:01 - do the connection ourselves so we are
57:03 - saying button whenever the button is
57:04 - clicked and you see that we don't have
57:07 - autocomplete here so we have to auto
57:10 - complete the signal and then connect
57:12 - that's what we do and we want to specify
57:16 - the thing that is going to respond when
57:18 - this button is clicked so that's going
57:20 - to be button clicked here
57:23 - now we have the connection made and we
57:25 - are just going to show the button here
57:27 - notice that all we have in our
57:28 - application here is a simple button so
57:31 - this is what we are going to see when we
57:34 - run this application here let's bring up
57:36 - our terminal window
57:38 - and we will simply run this just like we
57:42 - did other applications and when we do
57:45 - that we see a little window pop up that
57:47 - is saying oppressed me so this is our
57:50 - button inside this window here and if we
57:53 - click on it you see it's going to print
57:55 - the message and it is doing that because
57:58 - of the connection we did here let's
58:00 - close this and comment out this
58:02 - connection to show you that if we don't
58:05 - make the connection we won't see this
58:07 - message when we click on the button
58:09 - because there is no connection between
58:11 - this button whatsoever to this slot here
58:14 - or this method if I can say it like that
58:16 - let's run it again
58:18 - to see this going on we have the button
58:21 - and if I click on it a thousand times
58:23 - I'm not going to see a single message
58:25 - here unless I come back in my code and
58:28 - activate the connection and run the
58:30 - application again then we will see the
58:32 - button and if we click on it we're going
58:34 - to see things happening as a response to
58:37 - the connection that we did here this is
58:39 - really the syntax again how do I know we
58:41 - had this clicked signal I use the
58:44 - documentation let's go down and show you
58:47 - that you can also handle parameters or
58:50 - arguments coming in your signals let's
58:53 - comment this up so we have this done
58:55 - here and we will put in version two of
58:59 - our code let's go down and uncomment
59:01 - this
59:03 - let's take out my blog comment here and
59:06 - again notice that we have a parameter in
59:09 - our slot here and we don't have any
59:12 - mention of that parameter because the
59:16 - clicked signal is going to send it
59:17 - anyway it is our decision to decide
59:19 - whether we handle it or not that's what
59:22 - we are doing here so we have the
59:24 - parameter and we're going to be printing
59:26 - the checked State and to be able to
59:28 - toggle between the checked and not check
59:31 - the state you have to enable that on
59:34 - your button component and that's what we
59:36 - are doing here setting checkable to True
59:39 - once you have this you can run the
59:41 - application and you are going to see
59:43 - that as you click on the button it is
59:45 - going to be constantly toggling between
59:47 - the chat and unchecked Stage let's run
59:51 - this we can go to view
59:53 - and a terminal and run this again but
59:57 - before we do I think we need to kill the
59:59 - application that was running earlier so
60:02 - let's clear and bring up our application
60:05 - if we click press me it is going to
60:09 - check it is going to say checked true we
60:11 - click again checked false we click again
60:13 - checked true this is happening because
60:17 - a behavior that is built into this
60:19 - battle component is that if you click on
60:22 - it while you have this property set to
60:24 - true it is going to be constantly
60:27 - toggling between a checked and unchecked
60:29 - that's what we can do here and again the
60:31 - real intent in this example is to show
60:34 - you that you can handle parameters that
60:36 - come in your slots and at the syntax you
60:38 - use to connect doesn't really change you
60:41 - decide whether you handle them or not by
60:43 - putting the parameter here if you put
60:45 - the parameter in here you can handle it
60:47 - in your application depending on the
60:49 - data inside this data parameter if you
60:52 - decide not to handle it you can just
60:54 - take this out and you're going to fall
60:56 - back to what we had in our previous
60:59 - example
61:00 - so let's run again so we can show our
61:04 - terminal and kill the application that
61:07 - was running
61:08 - and I started again now if you click
61:11 - you're going to see that we are just
61:13 - going to see the message but we don't
61:15 - see the state because we're not handling
61:17 - our parameter here if we put it back in
61:20 - and say data
61:23 - okay and run again I think we can run
61:26 - again now we are going to see the
61:28 - checked State because we are handling
61:31 - that in our slot here I hope this makes
61:34 - sense and I did the best I could to put
61:37 - in a bunch of understandable comments so
61:39 - that you can really understand what is
61:41 - going on here let's comment this out and
61:43 - give you another example using a slider
61:46 - because that's a bit more interesting
61:51 - so let's put our code in the comment
61:54 - block here and we can go down a bit long
61:57 - and put in our code and again we are
61:59 - just going to be importing the
62:00 - components we need
62:03 - okay notice that we are importing the QT
62:06 - named space if I can say it like that we
62:08 - have our slot which is going to be
62:11 - handling some data but the slot is going
62:14 - to be responding to a slider being
62:17 - removed and again we talked about this
62:19 - in the slides we have our slider we want
62:21 - it to be horizontal if you want you can
62:23 - make it vertical but it's not going to
62:25 - be beautiful we have the minimum set
62:27 - again I know about these methods because
62:30 - I am familiar with QT for a lot of years
62:33 - but if you are just getting started your
62:36 - best bet is use the documentation to
62:38 - read about all these things for example
62:40 - again if you go back to slider I think
62:43 - we have that somewhere here
62:46 - you can see the methods that it has okay
62:49 - so we have a maximum method to get the
62:52 - maximum we have a method to set the
62:54 - maximum you can read about all these
62:56 - methods to see things you can do with
62:59 - your UI components in your QT for python
63:02 - applications and again after we have the
63:05 - slider we are connecting to the value
63:07 - change signal and we want our method to
63:10 - be activated whenever the value changes
63:13 - and whenever the value changes we are
63:15 - going to grab the current value which is
63:17 - sent to us
63:19 - as part of this signal and we will be
63:22 - printing that right here
63:24 - if this is not making too much sense
63:27 - maybe we can run the application so
63:29 - let's go to terminal
63:31 - and run it
63:33 - and this is going to give us a slider
63:35 - here
63:36 - okay and if we move it you're going to
63:39 - see things happening here again you see
63:41 - that it was starting at 25 if we move it
63:44 - up it's going to go to 27 28 29 it's
63:48 - going to go all the way to the maximum
63:50 - which is 100 or we can bring it all the
63:53 - way to the bottom which is one okay and
63:56 - we can move things around you can use
63:58 - this component in your application and
64:00 - it is going to work really well but
64:01 - again in the meat of this lecture here
64:03 - is to let you know how to make
64:06 - connections between signals and slots
64:09 - and I hope you know how to do this right
64:11 - now this is really all I had to share in
64:13 - this lecture I hope you found it useful
64:15 - we are going to stop here in this one
64:17 - and I will see you in the next lecture I
64:20 - would like to welcome you in this new
64:22 - chapter where we are going to be
64:24 - exploring cute Wizards and widgets are
64:27 - really the basic components you use to
64:30 - build your user interfaces and in QT
64:33 - these are going to be coming from the
64:35 - cute widgets module we will have a
64:37 - chance to look at Q push button q line
64:40 - edit and all these widgets you see here
64:42 - and they will allow you to build cool
64:45 - user interfaces without waiting anymore
64:47 - let's head over to the next lecture and
64:50 - get started in this lecture we are
64:53 - exploring the Q widget component we have
64:56 - in the QT framework and this is a
64:58 - fundamental component in built-in user
65:01 - interfaces in that it is going to give
65:03 - you a base window on top of which you
65:06 - can do all other things so for example
65:08 - if we set up a q widget component and
65:11 - show it we will have a pair window and
65:14 - on top of this window we can really
65:16 - build any kind of structure to have all
65:19 - kinds of crazy user interfaces we might
65:22 - wish for in our QT applications and to
65:26 - use this it's really simple now you have
65:28 - the fundamentals of how you do things in
65:31 - q24 Python here I am going to show you a
65:34 - simple example and this is a class that
65:36 - is going to be living in its own file
65:39 - the class name is Rock widget it is
65:41 - going to be inherited from Q widget and
65:43 - Q widget is really the base class that
65:46 - we can use in our QT applications it is
65:48 - going to have a Constructor and in the
65:50 - Constructor we're going to be doing our
65:53 - basic work here another thing I am going
65:55 - to show you in this lecture is how we
65:57 - can use layout to lay things out nicely
66:00 - this is really not the place to
66:02 - introduce layouts but we really need
66:04 - them to have the flexibility to lay
66:07 - things out flexibly inside our widget so
66:11 - that's why I am doing that here you also
66:14 - see that we are having a bunch of
66:15 - components we have a bunch of buttons we
66:18 - are doing connections to slots
66:20 - and we want to respond when these
66:22 - buttons are clicked and in our code we
66:24 - will also set up these methods that are
66:26 - going to respond once we have the widget
66:28 - we are going to display it in our main
66:31 - python file and here you see that we are
66:34 - doing the usual we are importing the
66:37 - file that contains our Rock widget class
66:39 - and we are setting up a widget which is
66:42 - an instance of our Rock widget component
66:45 - we are showing it and kicking off the
66:47 - event Loop to have our application show
66:49 - up now that you know these things we are
66:52 - going to head over to visual studio code
66:54 - and play with us step by step okay here
66:56 - we are in our Visual Studio code editor
66:59 - I have an empty folder which is going to
67:01 - be containing the source code for our
67:04 - example here let's drag it and drop it
67:06 - on top of Visual Studio code to open it
67:08 - and I can create my main python file and
67:12 - in here we can do the usual we can
67:14 - import the things we need we can also
67:16 - import sys set up our application object
67:21 - and we are going to say window equals Q
67:23 - widget we are going to show the window
67:25 - and we are going to say up exact okay to
67:29 - start our application here notice that
67:31 - we say it's the windows here and we
67:33 - don't have q widget imported and we can
67:36 - import that here Q widget it is part of
67:40 - the widgets module in pi side 6 and if
67:43 - we do this and run the application we
67:45 - should see a widget pop-up let's show
67:48 - our terminal so that we can run the
67:50 - application easily and we can go up
67:53 - until we find the command to run this
67:55 - and you see this is going to pop up our
67:57 - widget nothing special here what we are
67:59 - going to do is to move the logic to set
68:02 - up the widget inside a separate class
68:04 - and have that widget as a base on top of
68:08 - which we can build other things so let's
68:10 - do that we are going to create another
68:12 - file we are going to call it Rock widget
68:15 - and in that file we are going to import
68:18 - Q widget from PI side Q2 Edge yet so
68:22 - let's do Q widget and we'll set up our
68:24 - class the class is going to be named The
68:27 - Rock widget it is going to be inherited
68:29 - from Q widget and it is going to have a
68:32 - Constructor so let's make sure we put
68:34 - that in and for example we can give it a
68:37 - window title let's say self set window
68:40 - title and we are going to call this rock
68:43 - widget and now that we have this notice
68:45 - that we did just the minimum we needed
68:48 - to have this be a valid python class
68:51 - here so we can come back to main.py and
68:54 - import we're going to say from from Rock
68:57 - widget import Rock widget and we want to
69:00 - create a q widget component this time we
69:02 - will create a rock widget you can do
69:04 - something like this now that we have
69:06 - this we can run let's see if this
69:08 - actually works and if we run we should
69:11 - see the same thing we saw before but now
69:13 - this is not an instance of Q widget it
69:16 - is an instance of rock widget which
69:18 - itself inherits from the Q widget class
69:21 - now that we have this we can start doing
69:23 - all kinds of crazy things on top of this
69:25 - curated component what can we do for
69:27 - example we can set up a bunch of buttons
69:29 - let's do that we will also import Q push
69:32 - button okay we already know Q push
69:34 - button let's say button one equals Q
69:37 - push button and say button one you can
69:40 - do this
69:41 - if I can type what are we going to see
69:44 - when we run this application let's try
69:46 - to run it we are instantiating an object
69:48 - of rock widget in main.py remember and
69:51 - we want to see where this button is
69:54 - going to show up in our user interface
69:55 - that's a question you might have let's
69:57 - try to run and if we do this you see
70:00 - that we don't see our button but we set
70:02 - it up in our code the reason this is
70:04 - happening is that this widget doesn't
70:07 - know where to put the button and to put
70:10 - things inside our widgets or our window
70:13 - we need to use layout and the layout is
70:17 - a way let's try to draw this so that it
70:20 - is really easy to understand now we have
70:22 - our widget component and we put our
70:25 - button in our code here to attempt to
70:27 - put some kind of button in our user
70:29 - interface but this widget component
70:32 - doesn't know how to lay them out there
70:35 - is a way in QT you can tell a widget to
70:38 - lay things out either vertically okay
70:40 - something like this or horizontally from
70:43 - left to right and you do that using
70:46 - layout let's start with a horizontal
70:49 - layout to start out we have a class
70:51 - which is called qh box layout and it is
70:56 - a way we have to lay things out
70:59 - horizontally in our class and to do that
71:02 - you set up a an object of that class we
71:05 - are going to say layout or button layout
71:08 - okay we can do something like this and
71:10 - it is going to be a qh box layout
71:14 - component okay once we have the layout
71:16 - we can add events to this layout so
71:18 - let's say button layout add the widget
71:21 - and you see we have a bunch of methods
71:24 - you can add other layouts inside this
71:26 - layout you can add the trial to widget
71:28 - but in this case we are just interested
71:30 - in adding the widget which is going to
71:33 - be our button one so please make sure
71:35 - you really understand the flow of things
71:37 - here we have our parent widget and we
71:40 - want to put things inside this widget
71:42 - using this layout here once we have our
71:45 - widget in the layout now we can call the
71:49 - set layout method on the widget to let
71:52 - it use this layout component to lay
71:55 - things out inside the widget component
71:57 - here so we're going to say self set
72:00 - layout and we are going to say button
72:02 - layout we can do this now if we run we
72:05 - should see our button inside our widget
72:08 - and if we do this you see that we have
72:10 - button one here and this is really cool
72:12 - now that we have this infrastructure in
72:15 - place we can add other buttons so for
72:17 - example we can go down and copy this I
72:20 - think we can do that Ctrl alt down this
72:23 - is going to copy this in Visual Studio
72:25 - code and we can name this two button too
72:29 - okay and we can add a widget again Ctrl
72:32 - alt down this is going to copy the line
72:34 - and we can say button 2 here and now we
72:37 - can go down and try to run we should
72:39 - have two buttons button one and button
72:41 - two and you can keep going putting in as
72:44 - many buttons as you want another thing I
72:46 - want you to see is that you can lay
72:47 - things out even vertically so we can
72:50 - change this to be a vertical layout
72:52 - let's do that QV box layout and we can
72:56 - change this to be a QV box layout this
72:59 - is all we need to do and because this is
73:01 - a vertical layout now when we add these
73:04 - buttons here they are going to be added
73:06 - in vertical order let's try to run
73:09 - button one should be on top button two
73:11 - should be below let's run again
73:14 - and we have this here and this is really
73:15 - cool now you can see that we can use
73:18 - this widget and this is really the idea
73:20 - I was trying to convey here as a base on
73:23 - top of which we can build as a complex
73:26 - user interfaces and we will be doing a
73:28 - lot of that in the course here right now
73:31 - we are just laying the foundation so
73:33 - that you really understand what is going
73:35 - on under the hood now that we have these
73:37 - buttons we can really do all kinds of
73:39 - crazy things for example we can set up a
73:42 - bunch of slots that are going to be
73:43 - activated whenever we click on these
73:45 - buttons now you already know how to do
73:47 - this lens but now we are going to be
73:50 - putting in these methods as part of this
73:53 - class they are going to be methods of
73:54 - this class here so for example you can
73:56 - say def button one and when it is
73:59 - correct we are going to print a message
74:01 - saying button one clicked okay we can do
74:04 - something like this we can even copy
74:05 - this method code I think we can do that
74:07 - okay so let's do that and do that for
74:10 - button tool clicked and we are going to
74:13 - say button two collect and we can
74:16 - connect signals to these slots that we
74:19 - are setting up here the way you do that
74:20 - you come down say button one you already
74:22 - know this if it is clicked okay we want
74:25 - to connect to a signal to a slot that's
74:27 - going to be self button one clicked we
74:31 - have this for button one we can
74:33 - duplicate this button too so we can
74:36 - select the line shift alt down this is
74:40 - going to copy the line in Visual Studio
74:42 - code that's why I love Visual Studio
74:44 - code and we can put the code here to
74:47 - duplicate it and we are going to say
74:49 - button 2 click now we have the
74:51 - connection from this buttons to the
74:54 - slots we have down here if you click on
74:56 - button one you should see this message
74:58 - if you click on button two you should
75:00 - see this message let's view terminal
75:03 - and we are going to try and run again
75:06 - but we have the previous application
75:08 - instance running so we can kill it and
75:11 - run again and if it runs Watch What
75:14 - Happens below here
75:16 - okay so let's click on button one button
75:19 - one clicked
75:21 - what is going on here ah the problem is
75:25 - that we are setting these methods up as
75:29 - methods of the class but we're not
75:33 - telling these methods that they belong
75:35 - to this class here you do that by
75:37 - passing in the self argument sorry for
75:39 - that so let's do self and I think at
75:42 - this moment this should work let's clear
75:44 - and run again and if we click on button
75:47 - one it's going to say button one clicked
75:49 - if we click on button two it is going to
75:51 - say button to clicked if you wanted you
75:53 - could change this to be laid out
75:55 - horizontally by using q h box layout
75:59 - that is going to lay out thanks
76:00 - horizontally if you run again they are
76:03 - going to be laid out horizontally if you
76:05 - click button one clicked if you click
76:07 - button to clicked this is really all I
76:10 - wanted you to see in this lecture again
76:12 - if you don't know what qh box layout and
76:15 - the QV box layout to do I invite you to
76:19 - use the documentation let's do that QV
76:21 - box layout and you are going to have a
76:24 - lot of information about these things
76:26 - you can really read this if this is your
76:28 - first time you are going to pick up a
76:30 - lot of information and this is going to
76:32 - be very helpful in your career as a QT
76:36 - for a python developer we are going to
76:39 - stop here in this lecture and I will see
76:40 - you in the next one
76:42 - in this lecture we are going to explore
76:44 - the Q main window class this is a class
76:47 - that allows us to work with things like
76:49 - menus toolbars status bars actions and
76:53 - it is really cool what this is going to
76:55 - give us is a window like this but a
76:58 - window that has little parts or
77:00 - components that we can customize for
77:03 - example in many applications at least
77:06 - graphical user interface applications we
77:08 - have something like a toolbar or a menu
77:10 - bar on top and below that we might have
77:13 - a toolbar that contains things we can
77:16 - click on to make things happen after
77:18 - that we are going to have something like
77:20 - a main or a central widget and in that
77:23 - widget we are going to put in the main
77:25 - component of our application if it is an
77:27 - editor or a text processing application
77:29 - users will be able to type things in
77:32 - this component and things like that we
77:33 - might even have a storage bar or
77:35 - something we can use to show some
77:37 - messages or whatever you can design your
77:40 - applications reusing this components
77:42 - that are built into the Q main window
77:45 - class that you can instantiate in your
77:47 - QT applications so this is what we are
77:49 - going to do here we will create a class
77:52 - that is going to be building on top of Q
77:55 - main window and on top of that we will
77:58 - be doing our own things and you're going
78:00 - to see that we will have the ability to
78:02 - add menu bars toolbars status bars and
78:04 - that's going to be really cool once we
78:07 - have this class inherited we can add
78:09 - menus like we see here so we can call
78:12 - the menu bar function on Humane window
78:14 - and this is going to give us a menu bar
78:16 - object that we can manipulate once we
78:19 - have it we can add other menus for
78:21 - example you see here we are adding a
78:23 - file menu and the add menu method is
78:26 - going to give us a menu object that we
78:29 - can use to manipulate our menu here for
78:32 - example we can add actions to our menu
78:35 - and we are doing that right here and
78:38 - this is going to give us an action we
78:40 - can manipulate later here in our QT
78:43 - applications I realize this is a bit
78:45 - convoluted but actions are a thing that
78:49 - you can use to manipulate a user doing
78:51 - something in your application suppose we
78:54 - have a quick action like this and we
78:56 - want the user to be able to trigger this
78:59 - either from the menu bar or the toolbar
79:03 - so the user could go in a file menu and
79:05 - select quit or they can go on the
79:08 - toolbar directly and click quit the way
79:11 - QT does this it adds in an intermediary
79:15 - step through which you can go to trigger
79:18 - this action and this is what this action
79:20 - is an action is an object that you can
79:24 - either add to the toolbar or the menu
79:26 - bar and when the user tries to quit
79:28 - either through the menu or the toolbar
79:30 - all these things are going to go through
79:32 - the same action and you can connect this
79:35 - action to a method that is going to do
79:37 - things in your QT application and you
79:40 - don't have to duplicate your code either
79:42 - in the menu bar or in the toolbar I am
79:45 - going to show you this when we hit
79:46 - Visual Studio code if it is not making
79:48 - sense yet but this is a really good
79:51 - design when it comes to the QT framework
79:53 - so we have the action here and this is
79:56 - the action that we will be connecting
79:58 - slots to for example you can see
80:00 - whenever this action is triggered this
80:03 - is a signal that is emitted by Q action
80:06 - you can go in the documentation to take
80:08 - to check this out when this actually is
80:10 - triggered we will call a method called
80:12 - quit and this is going to quit our
80:14 - application as you are about to see
80:16 - again the meat of this here is to show
80:19 - you how you can manipulate menus in your
80:21 - QT applications once you have the menu
80:24 - bars you can add menus to that menu bar
80:27 - and once you add the menu you will have
80:29 - a menu object you can add actions to we
80:32 - are repeating the same process here we
80:34 - are adding an edit menu and in this edit
80:38 - menu we will add actions to copy cut
80:40 - paste and do and do and we will be
80:43 - seeing these things in our user
80:45 - interface and if we really want it we
80:47 - could grab these actions and connect
80:49 - slots to them to do things in our
80:52 - application and I think we will even do
80:54 - an application like this later in the
80:56 - chapter here so stay tuned for that down
80:59 - here you see that we have a bunch of
81:01 - other menus we have Windows settings
81:03 - help we can do this next another thing
81:06 - we can do is also manipulate the toolbar
81:08 - and you do that by setting up a toolbar
81:11 - object like you do here once you have
81:14 - the toolbar you're going to add that to
81:16 - the main window using this method here
81:18 - and you can add actions to the toolbar
81:21 - you see we are adding an action we are
81:23 - adding an action and before we add the
81:25 - action we're going to create it so this
81:27 - is how you create your action you can
81:28 - put in a bunch of things and you can
81:30 - connect slots to the action this is
81:32 - really what we are doing here another
81:34 - thing I want you to see is that you can
81:36 - even pass an icon when you create the
81:38 - action and this icon is going to show up
81:41 - wherever ever you add that action in
81:44 - your user interface and this is really
81:45 - cool down here we are adding a separator
81:48 - in our toolbar and we are even adding a
81:51 - push button in our toolbar you can do
81:53 - that if you want it is possible let's
81:55 - see how you can also use storage bars to
81:57 - use this notice bar you set the status
81:59 - bar on your main window using the
82:02 - setting we have here and we are creating
82:04 - a status bar object in place and passing
82:07 - that in down below you see that we are
82:09 - doing a button that is going to be
82:11 - showing up as our Central widget and
82:13 - once we showed this we are going to see
82:15 - the entire application here and this is
82:17 - really cool down here we have our
82:20 - methods that are going to respond
82:21 - whether we click on buttons or things in
82:25 - the toolbar all the menu bars and you
82:27 - see the method here you also see the
82:30 - method to quit and once you have
82:31 - distance your application is going to
82:33 - work now that you have this we can head
82:36 - over to visual studio code and play with
82:38 - us step by step okay here we are in our
82:41 - Visual Studio code editor we have an
82:43 - empty folder that we are going to be
82:45 - using to do whatever we do in this
82:46 - lecture here let's drag and drop this on
82:49 - top of Visual Studio code and we will
82:52 - create our main.py file on top of this
82:56 - we will also create a main window file
82:58 - let's do that and this is going to be
83:01 - where we create our main window class
83:03 - the first thing we want to do is to make
83:05 - sure we have the correct Imports so we
83:08 - are including queue application and Q
83:10 - main window we will need to pass an
83:13 - application object to this window to be
83:15 - able to quit you're going to see how we
83:17 - wire these things up but for now just
83:19 - put Q application here let's go down and
83:22 - set up our class it is going to be
83:23 - nothing really special the class is
83:25 - going to be called main window it's
83:27 - going to be inheriting from Q main
83:30 - window let's make sure you can see that
83:32 - it is going to be inheriting from cumin
83:34 - window here we are doing our Constructor
83:37 - then and we have a member which is
83:40 - called app which is going to be the
83:42 - application instance that created this
83:44 - main window here and we will be using
83:46 - this application member to quit the
83:48 - application again you will see how we
83:50 - use these things in a minute now we have
83:52 - a main window object I think we can go
83:55 - in the main py file and try to use this
83:59 - so let's go down and put that in here it
84:01 - is not going to be anything special we
84:03 - have q application imported we are
84:05 - importing main window from our main
84:07 - window file the class we just set up
84:10 - here and we are creating the window
84:13 - which is main window we are showing it
84:15 - and we are kicking off the event Loop
84:17 - nothing special here so let's show the
84:20 - terminal window to be able to run this
84:22 - and we are going to say Python
84:24 - main.py and if we do this we will see a
84:27 - window pop-up here but you may think
84:30 - this is a normal widget to Daniel why
84:32 - all the fuss around two main window let
84:35 - me show you we are going to go back to
84:37 - main window here and we are going to put
84:39 - in a piece of code like this okay so
84:42 - this is going to be setting up our menu
84:44 - bar so we will call the menu bar method
84:47 - on our main window object and it is
84:49 - going to give us a menu bar that we can
84:52 - use to add menus to our main window
84:55 - object here and again how do I know this
84:58 - the documentation let's go back to our
85:00 - browser and we can say Q main window
85:03 - here Q main window and if we look here
85:07 - we can see a method called menu bar you
85:10 - can see that right here and they are
85:13 - going to say whatever this method does
85:15 - it is going to return the menu bar for
85:17 - the main window this function creates
85:19 - and returns an empty menu bar if the
85:22 - menu bar does not exist so we are going
85:24 - to create it and we can go through these
85:26 - menu bars to add menus to our main
85:30 - window this is really cool right so we
85:32 - are calling add menu to our menu bar
85:35 - object again we can go to the
85:37 - documentation and see what we get from
85:40 - this guy this is going to return the Q
85:42 - menu bar okay and uh this is why I don't
85:47 - like the documentation for cute for
85:49 - python there should be a link for a q
85:51 - mini bar you can click on to go there
85:53 - but we have to go back and search here
85:56 - so let's do Q menu bar and we can open
85:58 - this in our browser once you see this
86:01 - you're going to see that we can do a lot
86:03 - of things and one of these is add a menu
86:06 - and this is what we are using in our
86:08 - application here to add a menu called
86:10 - the file on our menu here let's run and
86:14 - see our menu live let's clear
86:17 - properly and run python main.py if we do
86:22 - that look at what we have here we have a
86:25 - menu we can click on it to do things but
86:27 - it doesn't have anything inside yet but
86:30 - we're going to fix this in a minute
86:31 - let's close the application first but
86:34 - what we can say for example is file menu
86:37 - okay file menu add action and we are
86:40 - going to say something like quit if we
86:42 - do this and run and come back to our
86:46 - window here if we click on file you see
86:49 - we have a credit we can add menu options
86:52 - in our menus and this is really cool
86:54 - okay another thing we can do is actually
86:56 - grab this action and use it to respond
86:59 - whenever the user triggers this action
87:01 - for example you can say quit action okay
87:04 - we can name this quit action and we can
87:06 - connect to it and make a slot respond
87:09 - whenever this action here is triggered
87:11 - and this is really cool so let's go down
87:13 - and Define a quit method so let's go
87:17 - down here and say def quit app for
87:20 - example and it's a method so we need to
87:22 - pass a self here and down below we are
87:25 - going to say app quit and can we quit
87:29 - we're going to say quet autocomplete is
87:33 - not helping here but I think this is
87:34 - going to work so let's go with this and
87:37 - once we have the action we can connect
87:39 - this slot to it so we can say create
87:41 - action trigger connect and we will
87:45 - connect the self method that is called
87:47 - quit app let's see what happens if we do
87:50 - this and this is really cool if it's
87:52 - going to work let's clear and run the
87:55 - application now we have our file menu
87:57 - and if we hit quit the application is
88:00 - going to go away let's try it again file
88:03 - quit it is going to go away and this is
88:05 - really cool we can add a bunch of other
88:07 - menus now that you know how to work with
88:10 - ADD menu and add actions on menus so to
88:13 - populate this I am going to add an edit
88:16 - menu and let's take out these unprisoned
88:20 - symbols because we don't want to go into
88:22 - that here they have some use in QT but
88:25 - we're not going to go into that here now
88:27 - we have another menu added to our menu
88:30 - bar and we are going through this menu
88:32 - to add a copycat paste and do redo menu
88:35 - options and we will see them in our user
88:38 - interface if we run the application
88:40 - let's go to view terminal and a clear
88:42 - and run our application if we do that we
88:46 - have an edit menu this is really cool if
88:49 - we click on it copy cut paste and do
88:51 - redo and this is really cool you can do
88:53 - this things using the Q main window
88:55 - class in cute for python let's add a
88:58 - bunch of other menus to make this a
89:00 - little bit interesting we have window
89:02 - we have settings we have help and let's
89:06 - add a comment here if we run let's see
89:09 - if we can see these things showing up on
89:12 - our user interface and we see our thing
89:15 - here and this is really cool now I hope
89:17 - you know how to work with menus and many
89:19 - options and you even know how to respond
89:22 - when one of your many options is
89:24 - triggered now let's focus on toolbars
89:27 - the first thing we do is to create a
89:29 - toolbar object and a set a few
89:32 - properties on that
89:34 - and before we create the toolbar we need
89:37 - to import the toolbar and the queue size
89:39 - class here we are using to give it the
89:42 - icon size the size object here is coming
89:45 - from cute core so let's put that n and
89:48 - if you want to know how I knew that how
89:51 - did I know that queue size is coming
89:52 - from cute core well you have to use the
89:55 - documentation and if we go back to our
89:58 - browser
89:59 - I really want you to be familiar with
90:02 - using the documentation because it is an
90:04 - invaluable skill queue size for acute
90:08 - for python or Pi side 6. and if we look
90:12 - for it they should tell us where this
90:14 - thing lives
90:15 - cue size you see it lives in the cuticle
90:19 - module that's how I know this lens
90:21 - because I don't memorize them so we have
90:23 - this imported I think we can import Q
90:26 - toolbar from cute widgets because that's
90:29 - the module where it lives we don't even
90:32 - need the Q application imported here
90:34 - because we don't need this so let's take
90:36 - this out I think this is going to work
90:38 - and we can go down and keep working on
90:40 - our toolbar here once we have the
90:42 - toolbar we can add in a bunch of actions
90:45 - so to start let's say toolbar add action
90:48 - and add in our reduction how about that
90:51 - we can add the quit action to the
90:53 - toolbar and you do that by saying
90:55 - toolbar add action and let's say quit
90:58 - action because I think we have it on top
91:00 - create action where is our quit action I
91:03 - think we have it right here we can copy
91:05 - it and put that down below here I think
91:07 - this is going to work let's see what
91:09 - happens if we run this application this
91:12 - is going to be really interesting and
91:14 - this is going to explain why we have two
91:17 - actions in QT so let's see our toolbar
91:20 - you can see our action right here here
91:23 - and if we go in file you are also going
91:26 - to see that we have a quick thing set up
91:28 - here but we are managing what happens
91:30 - when a user triggers this action in one
91:33 - place whenever this action is triggered
91:35 - we are going to call the quit app but we
91:37 - can trigger this action from different
91:39 - places in our application and we can
91:42 - either do that from the menu or from the
91:44 - toolbar if we create from the menu the
91:46 - application is going to die if we quit
91:49 - from the toolbar the application is
91:51 - going to die and we have one single
91:53 - method to respond to all those possible
91:56 - sources of this action being triggered
91:59 - and I really hope this makes sense so
92:01 - let's go down and keep playing with our
92:03 - toolbar here another thing we can do is
92:05 - create our own action just like we do
92:08 - here action one Q action we are giving
92:10 - it some information and apparent because
92:13 - its Constructor requires this
92:15 - information again I know this because I
92:18 - read the documentation so go in the
92:21 - documentation read the information for Q
92:24 - action and you will know why we need to
92:26 - do things like we do here now we need to
92:28 - import a few action Q action leaves in
92:32 - the cute GUI module so we will import
92:34 - that like we do here and if we go down
92:37 - our application should be happy now that
92:40 - we have the action we can pass a lot of
92:43 - information for example we can pass a
92:45 - status tip and this is something that is
92:48 - going to pop up when you hover over your
92:50 - action we can do something like this you
92:52 - can respond when this action is
92:54 - triggered and this is going to be a
92:56 - method we set up in our application and
92:58 - after we have the action ready we can
93:00 - add it in our toolbar just like we added
93:02 - our quit action on top here and this is
93:04 - really cool before we run let's go down
93:07 - and actually set up this method so let's
93:09 - copy and say that
93:11 - and we will pass self as a parameter we
93:15 - will go in the body of the method and we
93:18 - can print a message saying action one
93:21 - trigger okay can do something like this
93:24 - now that we have this let's make sure it
93:26 - is the same name we are using here
93:28 - option one triggered yeah or we can use
93:31 - it or we can even say action triggered
93:33 - this is going to do let's run the
93:35 - application okay we have some action
93:37 - added to our toolbar if we click on it
93:41 - we're going to see that our action is
93:42 - triggered so you can respond to things
93:44 - happening in your toolbar and this is
93:46 - really cool we can even set up another
93:49 - action but before we do let's go to the
93:52 - place where our source code is and we
93:55 - will add in an image because we want to
93:57 - pass an icon to our action here and make
94:00 - it show up in our user interface you can
94:02 - download the source code and have access
94:04 - to this short image here okay so you can
94:07 - use this let's go back to our code and
94:11 - we can go down and set up another action
94:13 - this action is going to be taking up an
94:15 - icon and I think icon is coming from the
94:18 - cute GUI module so let's say Q icon I
94:21 - think we have that imported here here so
94:23 - we can do this and if we set up this
94:26 - then we can pass our start PNG icon it
94:30 - is in our project we just pasted this in
94:32 - here and we can pass the icon on top of
94:35 - the other pieces of information that we
94:37 - passed earlier so we have some text that
94:40 - we pass in our action we have a parent
94:43 - we can pass the status tip message here
94:46 - and we can respond when this thing is
94:48 - clicked and again this is going to
94:50 - activate our slot here that we set up we
94:54 - can make this thing checkable and to be
94:57 - honest I don't remember what this does
94:59 - but we're going to figure this out when
95:00 - we run this and we are going to add this
95:03 - to our toolbar let's try to run this and
95:06 - see what the checkable thing does
95:08 - okay so we can run this and we have our
95:12 - theme showing up here we see this thing
95:15 - is triggered and the checkable thing
95:19 - is not helping out in this moment I
95:21 - think we can comment it out and see what
95:23 - happens this is how you learn about
95:25 - distance okay so let's recite this and
95:30 - if you click you see this thing is
95:32 - triggered I think the checkerboard then
95:34 - here is working in the same way as we
95:37 - saw for a push button so we're not going
95:39 - to be talking about this anymore here if
95:42 - you want to see the signals that are
95:44 - sent by a q action again we can go to
95:47 - the documentation and look for queue
95:50 - action
95:51 - let's do that Q action in cute for
95:54 - python you can read all you can about
95:57 - this class if we go down hopefully we're
96:00 - going to see the signals that it emits
96:02 - you see it has a triggered signal and it
96:06 - can pass a parameter which may be useful
96:09 - if you have set the checkable state here
96:12 - I think that's the use for that so you
96:14 - have this now you can read the
96:15 - documentation on Q action and know all
96:18 - you can do with it now I think we know
96:21 - how to work with toolbars let's see how
96:23 - we can work with the status bar and the
96:26 - starters bar is this little section
96:30 - below your window I think we should show
96:34 - this it is this little thing Below in
96:36 - which you can show a bunch of messages
96:38 - and we're going to show how this works
96:40 - in a minute so let's go back to the code
96:43 - but before we go to status bars I just
96:45 - remembered something I didn't show you
96:47 - we can add a separator to separate
96:49 - lengths in our toolbar and we can even
96:53 - add a widget something like button in
96:56 - the toolbar and this is really cool if
96:59 - this is helpful for whatever you are
97:00 - building with QT for python please take
97:03 - advantage of that let's import Q push
97:06 - button for that to work so Q push button
97:09 - and let's go down and make sure we have
97:11 - no more squiggles so we have the thing
97:13 - here let's run and see what this gives
97:15 - us and you can see that you can even add
97:18 - a button okay if you look closely you're
97:21 - going to see that we have a separator
97:23 - here so you can separate things in your
97:25 - toolbars now let's go and work on status
97:28 - bars and all you have to do to work with
97:31 - the status bar is to set a status bar
97:33 - object to your main window so we use the
97:37 - set throttle support method here and we
97:39 - will create the object in place and set
97:42 - that as our own status bar status bar is
97:46 - in the cute widgets module so let's add
97:49 - that here kill status bar and once we
97:52 - have it we can start showing things in
97:55 - the status bar what we are going to do
97:57 - is to set a message to the status bar so
98:01 - let's go in our slot so let's go in our
98:05 - slot that responds when the toolbar
98:07 - button is clicked so we're going to say
98:10 - Self Storage bar and we are going to say
98:14 - show message this is a method you can
98:16 - use to show a piece of message and you
98:19 - can pass the message so message from my
98:22 - app let's say that and you need to
98:24 - specify a timeout you can specify you
98:27 - can leave this empty let's first see
98:29 - what happens if you leave this empty so
98:31 - let's do that if you click it's going to
98:34 - say message from my app and you can see
98:36 - that if you click on this the message in
98:38 - the status bar is going to change and
98:40 - another thing that is wiredate QT is
98:42 - that if you hover over something that
98:44 - has a tooltip message that tooltip is
98:46 - going to show up in the status bar
98:47 - that's what you see here but if you
98:49 - click you see that my message is going
98:51 - to show up and it is not going to go
98:53 - away it's going to stay there as long as
98:55 - you are hovering over the thing you can
98:57 - pass the timeout parameter here so let's
99:00 - say we want to wait for this for three
99:02 - seconds three thousand milliseconds this
99:04 - is what we mean here so we can run the
99:07 - application again if we run it and click
99:10 - on our thing the message is going to
99:11 - show up but it should go away in three
99:14 - seconds and it does go away so click one
99:17 - two three and it is going to go away
99:19 - after three seconds and these are the
99:21 - things you can really do with your Q
99:23 - main window class we saw that we could
99:25 - use it to play with menus and menu bars
99:28 - we played with toolbars and we later
99:31 - played with service bars another thing
99:33 - you can do with our application to make
99:35 - it a little less boring is to put some
99:38 - button in the middle as the central
99:41 - widget and we are setting up the button
99:43 - here and we are going to set up a method
99:46 - that is going to respond when this thing
99:49 - is clicked when the button is clicked
99:51 - here so let's make sure this is aligned
99:53 - properly and we wanted to respond when
99:55 - it is clear effect so let's put our
99:57 - method here we are going to define a
99:59 - method let's say Def and we are going to
100:02 - give it a name and we want to go inside
100:04 - and put some message out clicked
100:09 - on the button you can do something like
100:11 - this and this is going to be our Central
100:13 - widget and we want to mark this as a
100:18 - method and if we show the terminal and
100:21 - run we're sure to see a button
100:24 - in the middle of our application and if
100:27 - you click on it you're going to see the
100:28 - message here and this is really all I
100:30 - wanted you to see in this lecture I
100:32 - apologize it turned out to be really
100:34 - long but Q main window is really
100:36 - interesting now you know how to add
100:38 - menus to your application you know how
100:41 - to work with the toolbar and you know
100:43 - how to add status bar messages to your
100:46 - application the toolbar is very flexible
100:49 - I think you can even move it so you see
100:51 - you can move it around in your
100:53 - application you can play with us it is
100:54 - really cool we are going to stop here in
100:57 - this lecture and I will see you in the
100:58 - next one
101:00 - in this video we will learn about the Q
101:03 - message box class and this is a class
101:05 - that allows us to set up transient
101:07 - temporary message Windows like this you
101:11 - can see something like this it has a
101:12 - title it has a message inside and we
101:15 - have two buttons one to accept and one
101:17 - to reject and it can really be any kind
101:20 - of message and Q message box allows us
101:22 - to set up something like this in QT
101:25 - there are different ways to do this and
101:28 - we will start by looking at the hard way
101:30 - to do this and here is a simple function
101:32 - that is going to do this we will set up
101:35 - a q message box object and through a
101:38 - bunch of method calls we will apply a
101:41 - bunch of properties to our message box
101:44 - object so we can give it a title we can
101:46 - give it the message to show we can
101:48 - really do all kinds of crazy things but
101:50 - one other good thing I want you to
101:52 - notice is that you can control the type
101:56 - of message box this is going to be by
101:59 - changing icon here so you can make it a
102:02 - critical message box you can make it a
102:04 - warning message box you're going to see
102:06 - what all these things mean here another
102:08 - thing you can do is specify the buttons
102:11 - that are going to show up on your
102:12 - message box so in this case we want to
102:15 - see an okay and cancel button but it is
102:18 - also possible to put in other buttons if
102:20 - you want to you can just keep ordering
102:23 - those types of button in these
102:26 - parentheses and they will show up we
102:28 - will also set to the default button so
102:31 - the OK button is going to be on by
102:34 - default or it's going to be highlighted
102:35 - if I can say it like that once we have
102:38 - the message box object set up we will
102:40 - show it and we show it by calling the
102:42 - exact method this is going to make it
102:44 - pop up on the screen and we will grab
102:48 - whether the user pressed OK or cancel
102:50 - through this return variable so if the
102:53 - value of this is Q message box okay we
102:56 - will know that the user chose okay if it
102:58 - is something else we will note that the
103:00 - user has chosen cancel and if you pop up
103:03 - this message box you will see all this
103:05 - kind of information here I know this may
103:07 - be cryptic if this is the first time you
103:09 - work with something like this but I will
103:11 - show you how this works in a minute when
103:13 - we hit Visual Studio code so this is the
103:16 - hard way to do things QT provides a
103:19 - bunch of static methods you can call on
103:22 - Q message box to show different kinds of
103:25 - message boxes and it's really simple to
103:28 - trigger all you have to do is say cue
103:31 - message box critical this is going to
103:33 - give you a critical message box you can
103:35 - pass in the parent you can pass in the
103:37 - title the message and the kinds of
103:40 - buttons this vent is going to show okay
103:42 - once this thing shows up and the user
103:44 - chooses either of these buttons you will
103:46 - know through this return variable that
103:49 - we are setting up here and we will do
103:51 - the usual check we do to know whether
103:53 - the user pressed OK or cancel so this is
103:56 - one kind we can also have information
103:58 - message boxes and and you can really see
104:01 - that what is changing here is the method
104:04 - you call if you call the information
104:06 - method you will get an information
104:08 - message box if you call the critical
104:12 - method you will get a critical message
104:15 - box and we can keep going on really
104:17 - going through them all we have a warning
104:19 - one we have an about message box and
104:23 - here you see how you can trigger those
104:25 - message boxes what we will do is set up
104:28 - a bunch of buttons in our user interface
104:30 - and whenever you click on one of these
104:33 - buttons we're going to trigger a
104:34 - different kind of message box so this
104:37 - one is going to trigger the message box
104:39 - we set up the hard way the second one
104:42 - here is going to trigger a critical
104:43 - message box and we will keep going until
104:45 - we hear to the about message box as you
104:49 - see down here and here is how our
104:51 - buttons are going to look so nothing
104:53 - complicated here but one thing you
104:55 - should notice is that we are using a
104:57 - vertical layout to lay these guys out
105:00 - how you see them here so we're going to
105:02 - do this in a minute when we hit the
105:04 - visual studio code so let's head over to
105:05 - the editor and actually do this so here
105:08 - we are in our editor Visual Studio code
105:11 - we will set up a new project and we will
105:13 - be working in this folder called message
105:15 - box you can see that it is an empty
105:18 - folder we can drag it and drop it on top
105:20 - of Visual Studio code to open it here
105:22 - and we will create our main profile and
105:26 - we need a widget file that is going to
105:28 - be containing our widget we will set up
105:30 - our widget class like we do any other
105:34 - widget so we will import the components
105:36 - we need and we will set up a widget
105:38 - class here once we have this we can head
105:40 - over in our main dot py file and put in
105:44 - the code that is going to trigger that
105:46 - widget I think at this point we can
105:48 - actually run to see that our application
105:52 - actually works and then we can start
105:53 - building other things we need let's
105:55 - clear and say python main pi and if we
105:59 - do this we should see a window pop-up
106:02 - here and we will build our user
106:03 - interface on top of this the first thing
106:05 - I'm going to do in our widget class is
106:08 - initialize the buttons that we will be
106:11 - using in our Constructor so let's do
106:15 - something like this and I am going to
106:17 - just put them in and we will be looking
106:20 - at the meaning of this as we go through
106:22 - the lecture here so we are setting up a
106:25 - window title for the widget here and we
106:29 - want to set up a bunch of buttons we
106:31 - have a hard button that is going to
106:33 - trigger the message box we set up the
106:35 - hard way we have a critical button a
106:38 - question button an information button a
106:41 - warning button and an about button and
106:43 - each of these buttons is going to be
106:45 - triggering a different kind of message
106:47 - box to kind of learn about all these
106:49 - things here once we have the buttons if
106:51 - we run the application remember we're
106:53 - not going to see them because we need to
106:55 - tell this widget class how it's going to
106:58 - be laying out all these buttons here but
107:00 - let's try and show you what is going to
107:02 - happen if you try to run the application
107:04 - at this point if you do it's really not
107:07 - going to work but here it is just
107:10 - complaining about the slots that we
107:12 - don't have in place but the point is
107:14 - that this is not going to show the
107:16 - buttons the way we wanted them shown so
107:18 - we needed to use a bunch of layouts here
107:20 - and you can see that I imported a v box
107:24 - layout because I have a purpose for this
107:26 - okay so let's go down and set up our
107:29 - layout you already know about layouts
107:31 - here we will set up a vertical layout
107:33 - and once we have the layout we will be
107:35 - adding all these buttons to the layout
107:37 - then we will set the layout to the
107:39 - current widget here this is how we are
107:41 - doing this let's say that we are setting
107:44 - up the layouts here and let's see if we
107:48 - try to run we are probably going to get
107:51 - a problem because we don't have the
107:53 - methods n but we can set up all these
107:56 - methods here so what I am going to do is
107:58 - copy this and go all the way to the
108:00 - bottom so this is a Constructor we can
108:03 - go down below and set up the method and
108:06 - I am going to duplicate this
108:09 - one two three four five times so let's
108:13 - do one two three four five okay and this
108:16 - is going to be critical let's do that
108:20 - okay the second one is going to be
108:22 - critical the third one is going to be
108:24 - questioning I am doing this live so that
108:27 - you guys don't have a problem with what
108:29 - I am doing here so let's do this
108:32 - together question information let's do
108:35 - this so let's go down and do information
108:38 - we're going to paste this in and this is
108:41 - going to say information and we're going
108:44 - to go to the
108:46 - warning button
108:48 - so this is the slot we need to set up
108:51 - after information
108:55 - let's do this warning
108:58 - and we need to go to the last one which
109:01 - is going to be about
109:04 - okay so let's deal about
109:08 - and this is going to say about
109:10 - and let's try to fix our
109:15 - indentation here because python is very
109:18 - serious about this
109:20 - so we need to use one tab space after
109:24 - the line of the functional definition
109:27 - here let's go to view and show terminal
109:31 - and if we do this
109:33 - and run again
109:35 - this should run now and it is going to
109:37 - show our buttons we have done the signal
109:40 - slot connections after the definition of
109:43 - each button so at this point if we click
109:45 - on hard we should see hard if we click
109:48 - on critical we should see critical if we
109:50 - click on question we should see question
109:52 - and let's make sure that everything is
109:55 - working here and about is about now we
109:59 - need to show a bunch of message boxes
110:01 - and we will start by the hard way here
110:03 - so let's take out the text we have in
110:07 - our function
110:09 - or method and I will go on top and say
110:13 - that we are doing things the hard way
110:14 - here and I am going to put in my
110:17 - function definition what this is going
110:19 - to do it's going to create a message box
110:21 - object and you can check this class out
110:23 - in the documentation you already know
110:25 - how to do that but let's do it together
110:27 - anyway so let's say Pi side 6 Q message
110:32 - box this is going to open the page for
110:36 - this class in the QT documentation and
110:39 - you can click on more to read on what
110:42 - this class does this is going to display
110:44 - a primary text to alert the user to a
110:47 - situation and you can really read all
110:50 - you want about this this is how it looks
110:52 - on the Mac this is how you set it up and
110:54 - it is what we are basically doing in our
110:57 - example here okay let's come back to our
110:59 - code we will set up the message box
111:01 - object we will give it a size we wanted
111:03 - to have a minimum size of 700 and width
111:07 - and 200 in height this is the meaning
111:09 - here you can give it a window title we
111:11 - can give it the text to show we can give
111:13 - it some informative text we can give it
111:15 - an icon we're going to make it a
111:17 - critical message box
111:18 - and we can give it the buttons that it
111:21 - is going to show and after this we will
111:24 - specify the default button and the
111:26 - critical thing here
111:28 - is to show the message box
111:31 - okay and you do that by calling the
111:33 - exact method on this once you call the
111:35 - exact method the method box is going to
111:38 - show up and when the user clicks on
111:40 - either of the buttons we will know which
111:43 - button the user clicked on through the
111:45 - return value here so if the user clicks
111:48 - on OK we will get a number representing
111:50 - the OK button if they click on cancel we
111:52 - will get a number representing the
111:54 - cancel button this is how these things
111:56 - work now that we have this I think we
111:58 - can run and see it in action we're going
112:01 - to show our terminal window
112:03 - and we will run
112:05 - okay we are going to click on the hard
112:08 - button and if we do that we're going to
112:10 - see something pop up here so we have a
112:14 - message box here and if we click back on
112:17 - our code let's make sure you see what
112:20 - all these things mean you see the title
112:22 - we set up is showing up here okay you
112:25 - see the informative text is showing up
112:27 - here and the message we set up is
112:30 - showing up here and you see the buttons
112:32 - we set up to try and play with us you
112:35 - can play you can click on cancel it is
112:38 - going to say user choose cancel if you
112:41 - click on OK you can see that we know
112:44 - which button the user clicked up on but
112:46 - you can even play with this for example
112:48 - let's take out the cancel button in our
112:51 - standard buttons here
112:53 - so let's check this out and if we run
112:56 - let's run again okay and click on hard
112:59 - we're going to see that we only have the
113:01 - OK button okay so and this is really
113:03 - cool now you know that you can use these
113:06 - standard buttons to control which
113:08 - buttons show up in your message boxes
113:10 - and this is one way to set up a message
113:12 - box if you want you can do it this way
113:14 - but QT provides a rather easier way to
113:18 - do this because all the work here is
113:20 - really repetitive it is just setting up
113:22 - these messages the title The text the
113:25 - informative text and really the
113:27 - differentiating factor is the kind of
113:30 - Icon you apply to the message box let's
113:33 - change this to warning for example to
113:36 - show you that you can do this so we can
113:38 - change the icon to change the kind of
113:40 - message box this is going to show let's
113:43 - try to run again so we can run and if we
113:47 - hit this is going to show a different
113:48 - icon let's cancel out of this and change
113:51 - this back to what it was was let's hit
113:54 - Ctrl C to go back there it was a
113:56 - critical one let's try again
113:59 - and if we hit hard we're going to see
114:02 - that we have a different icon so they
114:04 - are different in which icons they show
114:07 - the rest is really the same so because
114:09 - of this reason QT provides a bunch of
114:12 - easier to use static methods that you
114:15 - can call directly to get this then show
114:18 - up without doing all the repetitive work
114:20 - here we will start by the critical one
114:22 - because it is what we have here and I am
114:24 - just going to put in the code all you
114:26 - have to do to get this to work is to say
114:29 - qmessagebox dot critical and called the
114:32 - critical method on the Q message box
114:34 - class and then you pass in the parent to
114:37 - the title the message you want to show
114:39 - and the buttons you want the message box
114:41 - to have this is really all you have to
114:43 - do the rest is the same we will check
114:45 - which button the user clicked through
114:48 - the return value of the critical method
114:50 - here and if it is equal to the number
114:53 - that represents Q message box okay we
114:55 - will know that they also chose okay if
114:58 - it is another value we will note that
115:00 - the user didn't choose OK and they chose
115:02 - cancel because we only have two buttons
115:04 - here or they just closed the message box
115:07 - so that's another option too let's run
115:10 - and make sure we see what is happening
115:12 - here we will click on the critical
115:15 - button we can show our terminal and run
115:17 - again and if we click on critical you
115:20 - see that we have a really good message
115:22 - box here again you can see the title we
115:26 - set on top here you can see the message
115:28 - and you can see our buttons here let's
115:31 - go down and try the other ones if we
115:34 - choose cancel you see that it is cancel
115:36 - if we choose OK you see that it is okay
115:39 - down here and this is working exactly as
115:41 - we want the rest is really the same all
115:44 - we are going to be changing is the kind
115:47 - of method we call so we can go down and
115:50 - do the question one let's put some space
115:52 - in here and put in the code for the
115:54 - question message box and we are calling
115:57 - the question method the value is going
116:00 - to be captured in the return value and
116:02 - we will check which button the user
116:03 - chose here let's run and see this
116:06 - running so we can show this question
116:09 - asking the question we can click Ok
116:11 - We're going to know if we click OK we
116:13 - can click on cancel on question and we
116:16 - will note that we have chosen cancel I
116:19 - am just going to go down and put in the
116:21 - rest of the methods then I am going to
116:23 - show you this running so that you have a
116:26 - full working example on these guys here
116:28 - okay so let's go down and put in the
116:30 - information one so we call the
116:33 - information method we can go down and
116:36 - put in the warning one let's do that and
116:40 - we can go down and put in the about
116:42 - message box here all these are things
116:44 - you can do I think it is better to also
116:47 - document this let's say about here we
116:49 - can go on top here and say warning we
116:53 - can go on top here and say information
116:56 - and on top here we will say question and
116:59 - we will go to the top and say critical
117:02 - and here the hard way was critical as
117:05 - well
117:06 - okay we have the thing and now if we run
117:09 - all these buttons should work let's
117:12 - bring up our terminal window
117:15 - we can clear so that we have a clean
117:17 - slate here if we run we should see our
117:20 - tank show up if we click on hard we will
117:23 - say message box we click on critical we
117:25 - see a message box we click on question
117:28 - we see a message box we click on
117:30 - information we have an information
117:31 - message box and be careful to look at
117:34 - the different icons that show up because
117:36 - that's really the main differentiating
117:39 - factor we have a warning one and if we
117:43 - click on about we will have some method
117:45 - here and we can click OK and really run
117:48 - this so the last one doesn't really need
117:52 - to capture the return value because it's
117:54 - just going to give the user a message so
117:56 - the user can just close the thing that's
117:59 - why we are seeing a cancel even if we
118:01 - click on OK because the okay we click on
118:04 - is not meant to give us a return value
118:07 - that's how this link works so this is
118:09 - really all a habit to share in this
118:11 - lecture again if you want to learn more
118:13 - about Q message box you are welcome to
118:16 - read the documentation here you see the
118:18 - documented the kinds of message boxes
118:20 - you can look at but I think we have a
118:23 - good starting point to work with us
118:25 - throughout this lecture here I am going
118:28 - to stop here and I will see you in the
118:30 - next lecture
118:31 - in this lecture we are going to look at
118:33 - the Q push button class and you might
118:35 - say haven't we used a lot of Q push
118:38 - buttons enough by now well we're going
118:42 - to look at it again because I want you
118:44 - to see more on the signals you can
118:47 - process in your QT applications on the Q
118:50 - push button component here so you can
118:53 - process the clicked signal you can
118:55 - process the Pressed signal you can also
118:57 - process the release decision depressed
119:00 - and released signals are going to become
119:02 - increasingly important if for example
119:04 - you are doing a drawing application in
119:07 - which you want to know if the user has
119:10 - pressed it down and moving without
119:12 - having pressed the release button so
119:15 - that's why I want you to know about
119:16 - these signals here and we will set up an
119:18 - application like this so we will have a
119:20 - button that says click we will connect
119:23 - to these signals and we will be
119:25 - processing these signals in these slots
119:28 - that we set up below here and here in
119:31 - the middle you see that we are setting
119:33 - up a layout to have this button show up
119:34 - better in the widget that we are
119:37 - building here now that you know this we
119:39 - can head over to visual studio code and
119:41 - actually do this here we are in our
119:44 - editor Visual Studio code we have an
119:47 - empty folder in which we will be working
119:49 - for this project here you can drag it
119:51 - and drop it on top of Visual Studio code
119:53 - when we do that we will create a main.py
119:57 - file and we will create our widget file
120:00 - once we have the widget file we will put
120:03 - in our starter code we will import the
120:06 - components we need and we will set up a
120:08 - class that inherits Q widget nothing
120:10 - special here we will also go into the
120:14 - main file and put in our boilerplate
120:17 - code if I can say it like that it is
120:19 - going to create the application object
120:21 - and we will create an instance of our
120:23 - widget object here we will show it and
120:25 - kick off the event Loop you already know
120:27 - this let's go to the widget and set up
120:29 - our button and connect to the signals
120:32 - that we are interested in but before we
120:35 - do that we can go to the documentation
120:37 - and actually read a little bit about
120:39 - these signals here so we can go to Q
120:42 - message box now we want to look at Q
120:44 - push button sorry for that let's go to Q
120:47 - push button and if you remember we
120:50 - didn't see the signals that this thing
120:52 - has because most of these signals are
120:55 - coming from the parent class of Q push
120:58 - button and that happens to be the Q
121:01 - abstract button class so we can click on
121:03 - this thing here we will get to the
121:06 - documentation and if we go down we will
121:09 - see the slot but we are interested in
121:11 - the signals and if you look here we have
121:13 - the clicked signal we have used like a
121:17 - gazillion times by now but we have the
121:19 - Pressed signal and the released signal
121:22 - that we are interested in playing with
121:25 - in this lecture here another one you can
121:27 - play with is the toggled signal that is
121:30 - going to be triggered with after you
121:31 - change the state of the button when you
121:34 - have set the button to be checkable like
121:36 - we have done in a bunch of previous
121:38 - lectures but we won't be using this
121:40 - signal here you can play with it if you
121:42 - want let's go back to the code and
121:44 - actually do what we want to do we will
121:46 - come back to our widget class and put in
121:49 - our Constructor code The Constructor is
121:52 - going to set the window title it's going
121:54 - to set up our button and we will be
121:56 - connecting to different signals from
121:58 - this button here and you can see that we
122:01 - are trying to process the clicked signal
122:03 - the Pressed signal and the released
122:06 - signal and we're going to see how this
122:08 - work to be able to see this in action we
122:10 - need to implement these slots here so
122:13 - let's do that so we can go down and
122:16 - Implement these slots as methods of our
122:20 - class and we have the clicked slot which
122:23 - is going to be triggered when you click
122:25 - on the button we have the Pressed slot
122:28 - which is going to be triggered when we
122:30 - press and down below we have the
122:33 - released slot which is going to be
122:35 - triggered whenever our button is
122:37 - released here and we have all the code
122:39 - we need now that we have this in place
122:41 - we can show our terminal window
122:44 - and we can clear and run the application
122:47 - if we do we should see our button here
122:49 - and once we see it we can press on it
122:53 - you see we we see pressed once we go out
122:56 - of the window of our widget we're going
122:59 - to see that the system is going to think
123:00 - that the button is released but if we
123:03 - click again and release you see that we
123:07 - have two signals when we release the
123:09 - button we have the release signal but
123:12 - one thing worth noting here is that the
123:14 - clerk is both depressed and the released
123:17 - signal so a click is going to be
123:19 - triggered when you press and release but
123:22 - if you want to do things only when you
123:24 - press you can use the Pressed signal if
123:27 - that is making any sense that's the
123:29 - meaning of these signals here and I
123:31 - really wanted you to be aware of this if
123:34 - you really want to learn more about
123:36 - these signals you can come to the
123:38 - documentation and see what the official
123:40 - QT guys are saying about this but this
123:44 - is the gist of it this is really all I
123:46 - had to share in this lecture I hope you
123:48 - found it interesting we are going to
123:50 - stop here in this one and I will see you
123:52 - in the next one
123:54 - in this lecture we are going to look at
123:56 - the Q level and the q line edit
123:59 - components in the QT framework and these
124:03 - are components that allow us to set up a
124:06 - component like this in which you can
124:08 - type a single line of text so this is a
124:11 - queue line edit and the label is
124:14 - something you can use to set up some
124:16 - level text something like the full name
124:18 - you see here and if you need these kinds
124:21 - of things in your QT application you
124:23 - will be using Q level and queue line
124:25 - edit the thing we have down here is also
124:28 - a level and in the middle we have a
124:30 - button that we will want to be using to
124:33 - show the capabilities of q line edit
124:36 - here to set these things up all you have
124:38 - to do is to create these components
124:40 - wherever you need them in your QT
124:42 - application you can create a level just
124:44 - like you do here you have a variable
124:46 - label and you call the Constructor Q
124:49 - level and you pass in whatever the label
124:51 - text is going to be you create a line
124:53 - edit component like this and we can do
124:55 - all kinds of crazy things down here you
124:58 - see that we are trying to connect to a
125:01 - bunch of signals from the line edit and
125:04 - we will be playing with this thing but
125:07 - what I wanted to draw your attention on
125:09 - is how we are going to lay things out to
125:13 - make the user interface show up like
125:15 - this and what we are going to do we will
125:18 - first have an in globing vertical layout
125:21 - okay that's what we're going to do then
125:23 - we will take the full name level and the
125:27 - line edit here and put them in a
125:30 - horizontal layout so this horizontal
125:32 - layout is going to show up somewhere
125:35 - like here and then we will set up a
125:38 - vertical layout which is going to be
125:39 - this one and add these components to
125:42 - that vertical layout so the vertical
125:44 - layout is going to have the horizontal
125:46 - layout added to add and after that we
125:49 - will add the button and add the level
125:51 - you see down here I want you to keep
125:54 - this idea in mind because this confuses
125:56 - a lot of people starting out with QT now
125:59 - that we notice we can look at the
126:01 - signals that we can play with for a q
126:04 - line edit for example we can know when
126:07 - the text in the line edit changes we can
126:11 - know when the cursor position changes we
126:14 - can know when the user finishes editing
126:16 - and this mostly means the user hitting
126:19 - enter we can know when return is pressed
126:21 - which is also enter I don't know why QT
126:24 - provides two signals for this maybe the
126:26 - reason difference but I didn't care
126:28 - enough to go investigate that we can
126:30 - know when the selection is changed we
126:32 - can know when the text is edited we can
126:35 - do all kinds of crazy things
126:38 - with these components end we will set up
126:40 - the methods that are going to be
126:41 - triggered by the signals and you have
126:43 - all of them here we will play with them
126:45 - in a minute when we hit Visual Studio
126:47 - code but I do recommend pausing the
126:49 - video and looking at each of them before
126:51 - we go there so that you have an idea
126:54 - about what we are about to do now that
126:56 - we have this out of the way we are going
126:58 - to head over to visual studio code and
127:00 - play with us a little more here we are
127:03 - in Visual Studio code we are going to be
127:05 - working on this folder here which is
127:07 - empty as you can see we can drag it and
127:10 - drop it on top of Visual Studio code to
127:12 - open it and this is going to open our
127:15 - project in the folder let's create our
127:17 - main python file and our widget file and
127:21 - in the widget file we will create our
127:23 - class like we always do make sure you
127:26 - see the Imports we do here because we
127:28 - will be using all these components we
127:30 - can head over in the main file and put
127:33 - in our code that is going to trigger the
127:36 - widget showing up and and we can try
127:39 - this to see if it actually works so
127:42 - let's do that if we show it we're going
127:44 - to have an empty widget and now we can
127:46 - put in a bunch of line edits and labels
127:50 - before we do let's go to the
127:52 - documentation and read as much we can
127:55 - about these guys you can look at Q level
127:59 - if we open this in our browser this is
128:02 - going to tell you what this component
128:04 - does it is used for displaying text or
128:07 - an image we will talk about images later
128:09 - for now we are concerned with text and
128:12 - if you go up you will see a bunch of
128:14 - methods you can call on this to really
128:15 - do all kinds of crazy things but this is
128:18 - mostly used to show text in your QT user
128:21 - interfaces we can also look at queue
128:24 - line edit and pay Special Care on the
128:28 - signals that this component has
128:31 - so if we click on more we're going to
128:33 - see it shows something like this in your
128:36 - QT application you use it to type a
128:38 - single line of text and you can do all
128:40 - kinds of crazy things but for now we
128:42 - will do the basics one thing I want you
128:44 - to see is the signals that this thing
128:47 - has because they are the most
128:49 - interesting thing if you think about it
128:51 - you use a line edit like this if you
128:55 - want users to type text n and you may be
128:58 - interested in different aspects of how
129:01 - the user is putting in text for example
129:03 - you may be interested in tracking the
129:06 - cursor position you may be interested in
129:08 - knowing when the user has finished
129:10 - editing so that you can do something
129:11 - with the text you can do all kinds of
129:13 - crazy things and we will be playing with
129:16 - a bunch of these signals if you see some
129:19 - of that interest you I do recommend
129:21 - clicking on them and seeing what they do
129:23 - to really have an idea about these
129:25 - things here and make sure you read this
129:27 - detailed description to really know
129:30 - about this component even more Ghana can
129:33 - tell you in a course like this the
129:35 - documentation is your weapon when it
129:38 - comes to working with QT and QT happens
129:41 - to have one of the best pieces of
129:43 - documentation I have known in my career
129:46 - as a software developer so let's come
129:48 - back to our code and do what we need to
129:51 - do the first thing we are going to do is
129:53 - to put in our label and line edit
129:55 - component
129:57 - before we do that we will set up a
129:59 - window title to make this
130:02 - self-descriptive and we create a level
130:04 - like this you can see that there is
130:05 - nothing special about this and we have
130:07 - our line added we have made our line
130:10 - edit a member because of the soft
130:12 - failure and we do that because we want
130:15 - to be accessing this in Our member
130:18 - variables if we don't make it a member
130:19 - like this we want to be able to access
130:21 - it in our methods I mean okay we have
130:24 - this in place I think we will also need
130:26 - another level which is going to show
130:29 - something like this let me show you we
130:33 - need another label that is going to show
130:35 - the text here and we needed the button
130:37 - so we can go down and put in our button
130:40 - and make sure it is aligned properly and
130:44 - we can even go down and put in our label
130:46 - once we have these components the next
130:49 - job is to lay them out we know that we
130:52 - want the level and the line edits to
130:55 - show up in a horizontal layout so we
130:57 - will have the levels in something like
131:00 - this then after that horizontally we
131:02 - will have the line added so for this we
131:04 - will be using a horizontal layout once
131:07 - we have this horizontal layout we will
131:09 - use an including vertical layout on
131:12 - which we will be adding the button okay
131:15 - so let me display it like this and at
131:17 - the level
131:18 - like this so this is the user interface
131:21 - we want to set up and we will first set
131:23 - up this horizontal layout here so let's
131:26 - come down and set up our horizontal
131:28 - layer it is going to be a qh box layout
131:32 - we already know that and on this layout
131:34 - we will be adding our label which is on
131:37 - top here and the line edit once we have
131:40 - this we will set up a vertical layout
131:42 - which in turn is going to contain
131:44 - everything in our user interface here
131:46 - and we will apply the vertical layout on
131:49 - the entire widget let's do this so we
131:52 - can go down and put in our vertical
131:55 - layout QV box layout and to be able to
131:58 - do this you need to have imported all
132:00 - these components here so we add our
132:03 - horizontal layout to make it show up
132:05 - first in our vertical layout so if this
132:09 - is our vertical layout the first thing
132:11 - is going to be the horizontal layout the
132:13 - second thing is going to be the button
132:15 - and the last thing is going to be the
132:17 - text holder let people here once we have
132:20 - the vertical layout we can apply it to
132:23 - our widget and to do that you say self
132:25 - set layout and we will be using V layout
132:29 - here once we do this we should have our
132:31 - user interface and the next thing will
132:34 - be to play with our line edit component
132:37 - here let's show the terminal window so
132:40 - that we can run the application if we
132:43 - run we should see our user interface
132:46 - here let's make sure you can see it
132:48 - because I just closed it by accident you
132:51 - can resize it okay we have the full name
132:54 - on the left because it is what we say in
132:57 - our horizontal layout here we have the
132:59 - line edit here we have the button and we
133:02 - have our level here which we are going
133:04 - to play with in a minute you can play
133:05 - with the line edit and really type in
133:07 - whatever you want you can say the sky is
133:09 - blue my friend and you can really do all
133:11 - kinds of crazy things one thing you
133:13 - might be interested in when you have a
133:16 - component like this is to grab the data
133:18 - and we will be grabbing the data in our
133:22 - line and edit and printing that to the
133:24 - console when the user clicks on the grab
133:27 - data button here so the first thing
133:30 - we're going to do is come back to our
133:32 - code and set up a method and the method
133:36 - is going to be at this level so let's
133:39 - make sure we take this to the correct
133:42 - indentation in Python so this is going
133:45 - to be triggered whenever the user clicks
133:47 - on our button that says grab data and
133:50 - what we are going to do we will grab the
133:52 - text in the line edit notice that we are
133:55 - saying self line edit and this is going
133:57 - to be grabbing this component here the
134:00 - line edit that we set up in our user
134:01 - interface and we can call the text
134:04 - method to grab whatever text is
134:06 - currently in the line edit component so
134:09 - all we need to do now is to do our
134:11 - connection we can say button select net
134:15 - self button required we already know
134:18 - this must be becoming second nature here
134:20 - let's run and see this in action we can
134:24 - open the terminal we can run the
134:26 - application it is already running I
134:29 - think so let's close it
134:31 - we're going to run it again to run the
134:33 - new version of the application and we
134:36 - can say this guy is blue if we grab data
134:40 - we will see that the full name is the
134:44 - sky is blue but we can put in something
134:45 - like John snow and if we grab data it's
134:50 - going to say full name it's Jon Snow you
134:52 - can see that we can grab data in our
134:55 - line edit component this is really cool
134:58 - if you want it you can take this text
135:01 - and actually apply it to the other line
135:03 - edit we have down below here let's play
135:07 - with this to really show you that you
135:08 - can do that so we can close and we will
135:12 - grab the name of the other line edit and
135:15 - what is that text holder level
135:18 - so we can do this okay we can copy it
135:21 - and go in our method and we can say set
135:26 - text on this guy and the text is going
135:29 - to be what we get from the line edit
135:32 - here so we can copy this and put that in
135:36 - here this is something you can do you
135:37 - can really play with this things and I
135:39 - do encourage that let's make sure the
135:42 - application is not running we can run
135:44 - again have
135:46 - and if we say Jon Snow in our line edit
135:50 - and grab data we will see this print on
135:53 - the terminal because we are printing
135:55 - here but we will see that the text T now
135:58 - are as the level here is also going to
136:00 - change to John's now you can keep
136:02 - playing with this let's say Daniel gray
136:05 - and grab data it's going to say Daniel
136:07 - gray and it is really working this is
136:10 - one way you can use a line edit you can
136:12 - grab the text in the line edit and use
136:15 - it to do whatever it is you want to do
136:17 - in your QT application let's play with
136:21 - the other signals we have on our
136:23 - component here for example we can
136:26 - respond whenever the text in our line
136:29 - edit changes let's go back to our line
136:32 - edit which is down here let's put in
136:34 - some space so that we can easily spot it
136:37 - we are going to set up a connection we
136:39 - are going to say whenever the text
136:40 - changes in our line edit what we are
136:44 - saying here we want to trigger the 10
136:46 - text changed method and we can grab the
136:49 - correct text and show it before we do
136:51 - that to though let's go in our other
136:54 - thing and comment out to the line that
136:57 - prints the text because we are going to
136:59 - be printing a lot of links we don't want
137:01 - to be confused by this let's go and put
137:05 - in the slot that is triggered whenever
137:08 - the text changes so we can go down and
137:11 - actually do that okay we have our text
137:13 - changed slot and it is going to be
137:16 - triggered whenever the text changes you
137:18 - see we commented out to the print line
137:20 - here we just want to see the changes in
137:22 - our user interface this is okay let's
137:25 - show the terminal and run and if we say
137:29 - Daniel gray in here you see whenever we
137:33 - type something we will be notified and
137:36 - we will be responding in our slot here
137:38 - and this is something you might be
137:39 - interested in doing if you want you can
137:42 - even uncomment the line that prints
137:45 - something
137:45 - and run again if you do that you will
137:49 - see the changes both in the user
137:51 - interface and on the terminal here
137:53 - because that's where we are printing
137:55 - with the print statement here this is
137:57 - what the text changed signal does we can
138:01 - comment out to the connection here
138:03 - because we still have a lot to play with
138:05 - so let's do that we might also be
138:08 - interested in knowing when the cursor
138:11 - position changes and we can set up a
138:13 - connection like this to be notified and
138:16 - we need to set up this slot that is
138:18 - going to respond the slot right here the
138:22 - cursor position method is going to have
138:25 - two parameters one is going to be the
138:28 - old position the other is going to be
138:29 - the new position and how do I know this
138:31 - well the documentation let's go back to
138:34 - the documentation or queue line edit and
138:38 - we can see cursor position changed you
138:41 - can see that it has two arguments one is
138:43 - the old position the other is going to
138:45 - be the new
138:46 - but the QT documentation didn't care
138:49 - enough to name these things properly him
138:52 - on uqt this is bad you should name these
138:55 - things properly let's go back to our
138:57 - code though so we will do better old new
139:00 - we will know that this the old position
139:02 - and this is the new position
139:05 - and because of the connection we did
139:07 - here we will have access to these guys
139:10 - when this slot is triggered so we will
139:14 - be printing this lens here let's make
139:16 - sure we don't have anything else we
139:18 - don't want to see printed we have the
139:20 - Auto Connection commented out I think
139:22 - this is going to do what we want let's
139:24 - go up and run so we can run this and if
139:28 - we do you see the crucial position
139:30 - changing as we add events if we go back
139:33 - you see the cursor position is also
139:35 - changing this is really cool and at each
139:38 - trigger of the method we have the old
139:41 - position and the new position and this
139:43 - is really cool this is something you can
139:45 - do with this method here let's go up and
139:48 - comment it out we might be interested in
139:51 - knowing when the editing is finished
139:53 - this is another signal we have on the
139:56 - line edit component we will put in this
139:58 - method here so we can go all the way to
140:01 - the bottom and put in that method and
140:04 - let me extra we remove spaces we don't
140:08 - need and we have the connection and this
140:11 - is going to be triggered whenever the
140:13 - editing finishes and this is going to be
140:15 - mostly when the user hits enter on the
140:18 - line edit after typing in some text
140:21 - let's show our terminal window and we
140:25 - can go up and run and if we say DDD and
140:30 - hit enter this is going to say that
140:32 - editing is finished you see this is
140:34 - triggered when you hit enter this is all
140:36 - you can do with this signal here we also
140:39 - have the return pressed signal let's put
140:42 - in the connection for that and comment
140:44 - out what we had before okay and this is
140:47 - going to do the same thing as editing
140:49 - finished again I don't know why QT
140:52 - provides these two maybe they have a
140:54 - difference but honestly I don't know
140:56 - that difference yet let's put in this
140:59 - method implementation that's going to be
141:02 - return pressed we can go to the bottom
141:05 - and put this in return press if we run
141:09 - we should see that if we type DDD or
141:12 - whatever you type in your line edit and
141:14 - you hit enter you will know that return
141:16 - is pressed and again it's when you hit
141:18 - enter after you finish putting in some
141:21 - text in your line editor another
141:24 - interesting signal is one that lets you
141:27 - know when the selection changes in your
141:30 - line edit you might be interested in
141:31 - this in your QT application so when the
141:34 - user does something like this and
141:36 - selects okay you will be notified of the
141:39 - current selection and this is
141:40 - interesting in some applications so we
141:43 - have the connection and all we need to
141:45 - do now is put in the implementation for
141:49 - this method here so let's do that we can
141:52 - go all the way to the bottom and put in
141:54 - the method implementation selection
141:56 - changed we have the connection whenever
141:59 - the selection changes we call the
142:01 - selected text method to know the
142:03 - currently selected text and this may be
142:06 - important in your QT application so
142:09 - let's do that we can run this and
142:12 - whenever we can type in something let's
142:14 - say for example Jon Snow and if we
142:17 - select John you see as we select more
142:20 - things
142:21 - the currently selected thing is going to
142:23 - be shown here we just selected John if
142:26 - we select to know we will see that in
142:28 - our QT application here if we select the
142:31 - entire thing even backwards I think
142:33 - that's going to work you see we have Jon
142:35 - Snow selected and this is really cool
142:37 - this is something you can do in your QT
142:40 - applications the last signal we are
142:42 - going to process is text edited and as
142:46 - the name says it is going to be
142:47 - triggered whenever you have text changed
142:50 - in your line edit and I think it also
142:53 - provides two arguments showing the old
142:56 - text and the new text to be sure you can
142:59 - check the documentation for now I am
143:01 - just going to put in the implementation
143:02 - here let's go to the bottom looks like
143:06 - it only gives the new text which is yeah
143:10 - it's useful so we will be printing the
143:13 - new text here which is going to be
143:14 - passed to us in this signal here and
143:18 - this is really cool let's try to run we
143:20 - can clear
143:22 - and run I think this is going to
143:24 - conflict with other things now this is
143:28 - going to do you see whenever we change
143:30 - we have the new text show up and this is
143:32 - really cool let's type in something
143:34 - meaningful instead of this junk here so
143:37 - we can say Jon Snow you can see that
143:40 - whenever we change the text the changes
143:42 - are going to be reflected in our
143:44 - application here because of the
143:45 - connection we did
143:47 - and you can go on and play with more
143:49 - signals I think I gave you enough
143:51 - examples in this lecture here again the
143:54 - goal was to be able to play with q line
143:56 - edit and Q level Q level is going to be
144:00 - used when you want to show a piece of
144:02 - static text in your user interfaces
144:04 - something like this you can use q line
144:08 - edit when you want your user to type in
144:10 - a line of text and this may come in
144:12 - handy for example if you are setting up
144:14 - a form to collect information from the
144:17 - user the first name is the last name the
144:19 - address the job they do whatever you can
144:21 - collect all these things in your QT
144:23 - applications and do things with them
144:25 - this is all I had to share in this
144:27 - lecture I hope you found it interesting
144:29 - we are going to stop here in this one
144:31 - and I will see you the next one in this
144:33 - lecture we are going to look at the Q
144:35 - text edit component and this is a
144:38 - component that allows you
144:40 - to type multiple lines of text in your
144:44 - user interface or something like this
144:46 - and I am sure you have seen this in a
144:49 - lot of graphical user interface
144:51 - applications so what we are going to do
144:53 - is to set this up in a demo QT
144:56 - application using pi side of course and
144:59 - we will be able to type in the text get
145:01 - the current text in this component like
145:03 - we did for q line edit but we can do
145:06 - much more for example we have the
145:08 - capability to copy text to cut text to
145:11 - paste text we can undo and redo
145:13 - something you see in a lot of text
145:15 - processing applications and this is
145:17 - going to be really cool to set this up
145:20 - it's nothing really special all you have
145:22 - to do is to use the Q text edit
145:24 - component you will set this up in a
145:27 - widget that we will set up in a short
145:29 - while when we hit Visual Studio code and
145:31 - we will set up a bunch of buttons that
145:33 - are going to allow us to manipulate
145:36 - things in our text edit component one
145:39 - thing I want you to see is that for
145:41 - example to copy text from our text edit
145:45 - component we are not going to go through
145:48 - separate slot methods like we did before
145:52 - what we will do is take advantage of the
145:55 - fact that the text edit component itself
145:59 - already has a slot that is going to copy
146:02 - data so instead of delegating to a
146:04 - custom slot that we set up in our own
146:06 - application we will immediately call the
146:10 - copy slot in our connection here and
146:12 - this is something you might want to do
146:14 - in your QT application apart from that
146:17 - it is standard stuff we have been doing
146:19 - all along and it's really not going to
146:21 - be anything complicated now that you
146:23 - know this we can head over to visual
146:25 - studio code and play with us a little
146:27 - more here we are in Visual Studio code
146:30 - we have an empty folder that we will be
146:32 - playing with in this lecture here let's
146:35 - drag and drop it on top of Visual Studio
146:37 - code we will close this and create
146:40 - create our main Pi file Ty I mean let's
146:45 - do that and we will create our widget
146:47 - file like we always do
146:49 - and in our widget we will put in our
146:52 - starter code this is going to create a
146:54 - starter widget which is empty and notice
146:57 - the Imports we do here for the things we
146:59 - will be needing here so it's quite a lot
147:02 - make sure you put these things in once
147:04 - we have this in we will head over to our
147:07 - main file and put in the code that needs
147:09 - to be there it's just going to be
147:11 - creating an instance of our own widget
147:13 - and showing it nothing special here we
147:16 - can come back but before we do anything
147:18 - it is my Habit to try and run the code
147:21 - to make sure that I have no problems in
147:25 - there so let's do that we should see an
147:27 - empty widget pop-up and it does here now
147:30 - what we are going to do is set up our
147:32 - text edit component
147:34 - together with a bunch of buttons that
147:38 - will allow us to play with that the
147:40 - first thing we do here we are putting in
147:42 - a window title because this is a cute
147:45 - text edit demo we set up our text edit
147:48 - and if you go down for now you can
147:51 - ignore the connections we are doing here
147:53 - the first thing we are interested in is
147:55 - laying things out so that we can see
147:57 - them in our user interface we will talk
148:00 - about all these connections later so we
148:02 - have a copy button we have a cut button
148:04 - we have a bunch of buttons all the way
148:06 - to the clear button here now that we
148:08 - have them we need to lay them out and
148:11 - the way we want to do things we want all
148:14 - these buttons to show up in a horizontal
148:18 - layout that is going to be on top so
148:20 - these are going to be our buttons and
148:23 - below the buttons we will be putting our
148:25 - text edit component if I can draw it
148:28 - here so this other big thing below is a
148:31 - text edit component so this is going to
148:33 - be a horizontal layout and this is going
148:36 - to be our text edit component and they
148:39 - are going to be laid out in a vertical
148:40 - layout so we will set up this horizontal
148:42 - layout and add horizontal layout to the
148:46 - vertical layout after the horizon Auto
148:48 - layout decided we will be adding our
148:51 - text edit component I hope this makes
148:52 - sense so let's go down and put in our
148:56 - layouts we can do something like this we
148:59 - will set up our horizontal layout which
149:01 - is going to be an instance of qh box
149:03 - layout after that we will be adding our
149:06 - buttons to copycat paste and do reduce
149:08 - set plain text set HTML and clear after
149:13 - that we will set up the vertical layout
149:15 - which is going to be containing our
149:17 - horizontal layout and the text edit and
149:20 - notice that the text edit is set up as a
149:23 - member because of the self plan here and
149:25 - we are doing this because we will be
149:27 - needing accessing this in a bunch of
149:30 - slots that we will set up later the
149:32 - let's take out this connection because I
149:34 - think it might give us problems because
149:36 - we don't have this slot in yet
149:39 - and now that we have the vertical layout
149:41 - we can go below and say itself set
149:44 - layout and pass and this vertical layout
149:47 - I think with this we will be able to run
149:50 - our user interface and be able to see
149:52 - our text edit component along with the
149:55 - buttons that we set up here so let's
149:57 - clear clear properly and run the
150:00 - application and what is pro the problem
150:03 - here set plain text we don't have these
150:07 - guys yet I think we have a connection
150:09 - that mentions that plain text let's
150:11 - comment this out because we don't have
150:14 - this n yet and we can try to run again
150:17 - and if we do this is going to show up
150:19 - and the meter of this lecture really is
150:22 - to play with the Q text edit component
150:25 - that we have down here
150:28 - what you can do with it you can type
150:29 - text you can say the sky is blue I am
150:33 - and my city something like that you can
150:36 - really do all you want you can put in a
150:38 - lot of text and this is what you can do
150:40 - with something like this and you can see
150:42 - that using this as a business you can
150:45 - really set up something like the Notepad
150:47 - application you see in Windows here you
150:49 - can do something like this you see it
150:51 - does exactly the same thing now that you
150:53 - know how to work with Q main window you
150:55 - can set up a two main window object and
150:57 - put in these files and menus and
150:59 - whatever you can copy and edit you can
151:01 - do all kinds of crazy things you can see
151:04 - that now you even have the knowledge to
151:05 - be able to set up a status bar you can
151:07 - set up toolbars you can do all kinds of
151:09 - crazy things so now that we have this in
151:12 - place I think we need a way to play with
151:16 - us so the first thing I am going to show
151:18 - you is that we can copy the text in here
151:21 - and paste it but I think the most basic
151:24 - thing is to grab the text we have in our
151:27 - text edit component but before we even
151:30 - do that I forgot to tell you that you
151:32 - should use the documentation to learn
151:34 - about these fans so let's do q-text edit
151:37 - here okay so we can come in here and
151:40 - look at this and you can click on more
151:42 - to go down and learn all you can about
151:44 - this let's go to see the methods that
151:47 - this thing has so we have a clear append
151:51 - cut we have a bunch of signals we can
151:54 - play with this on this and I think we
151:57 - have a method called to play with text
152:00 - we can use to get to the current text in
152:03 - our text edit component here that's what
152:05 - I was looking for so what do we do I
152:09 - think we need to add another button
152:10 - unfortunately so let's do that I think
152:13 - it's going to be the first button so
152:15 - we're going to say current text button
152:18 - okay it's going to be a push button and
152:21 - it's going to say current text so we can
152:23 - put it in and we're going to connect
152:26 - click connect
152:28 - and we want to set up a method that says
152:32 - current text button clicked so we will
152:35 - go down and set up this method this is
152:37 - the usual thing we do we can go all the
152:40 - way to the bottom to the level of our
152:43 - Constructor we will Define this method
152:45 - it's going to be a member we can say a
152:48 - print the current text so what do we do
152:51 - we say self text edit
152:54 - to plain text this is something that is
152:56 - going to print the current text in our
152:59 - text edit component here and this is
153:01 - something we can do so let's run and see
153:03 - this in action and we can see this and
153:07 - if we say this guy is blue I love my
153:10 - city we don't have the thing in the
153:13 - layout so let's go back and add the
153:15 - current Button as the first thing in our
153:19 - horizontal layout we forgot that no
153:22 - problem we can fix that add with it and
153:25 - we're going to make this show up as the
153:27 - first thing in our horizontal layout now
153:30 - we can run if we do and type the sky is
153:33 - blue and put in some other text here if
153:36 - we get the current text you see that we
153:38 - can see this so we are able to grab the
153:41 - text in our component here now that we
153:44 - can see this we can play with the copy
153:46 - method or the copy slot if we go to the
153:49 - documentation for a q text edit let's go
153:52 - to the top again and look at the slots
153:55 - that we have available on this component
153:57 - we will see a coffee slot we can call it
154:00 - and what it's going to do it's going to
154:02 - copy any selected text to the clipboard
154:05 - any selected text from the Q text edit
154:08 - component here let's go down and play
154:11 - with us
154:12 - so we can open this up in our editor go
154:16 - to the point where we declare the copy
154:19 - button and what this is going to do it's
154:22 - going to call the copy slot and this is
154:23 - what I meant when I said we can avoid to
154:27 - set up our own slot and immediately
154:30 - forward the work to copy to the copy
154:35 - slot of the text edit component we can
154:37 - do it like we do here so this is going
154:40 - to work right away we can run the
154:42 - application and if you go down you see
154:44 - that we can also catch because we are
154:46 - forwarding The Cutting work to the cut
154:49 - slot of the text edit component here
154:51 - let's show our terminal and we can do
154:55 - something like this and run now we can
154:59 - say the sky is blue I think I don't need
155:01 - to type my text all the time I think we
155:04 - can copy from the QT documentation here
155:06 - to have some text show up in our text
155:10 - edit I mean we can paste here so once we
155:13 - put in some text we can select something
155:16 - and copy it okay how do I know it's
155:19 - copied it's going to be leaving on my
155:21 - clipboard I can even paste this in
155:23 - another application so let's open
155:25 - notepad and paste I am going to select
155:28 - and paste you see that I am able to copy
155:31 - from my QT application to another
155:33 - application this is really cool so let's
155:36 - cut because the cat feature is also
155:38 - going to work because again it is
155:40 - forwarding The Cutting work to the cut
155:43 - slot of our text edit component if we
155:46 - cut the text is going to go away if we
155:48 - cut the text is going to go away if we
155:50 - cut the tax is going to go away but we
155:52 - can't paste yet why because our paste
155:56 - button doesn't have a slot that can
155:59 - immediately paste connected let's do
156:02 - that to be able to really play with us
156:04 - so we can say self text to edit paste
156:07 - and this is going to forward the work to
156:10 - the paste slot that we have available in
156:13 - our text edit component again if you go
156:15 - to the top you can you see that we have
156:17 - a paste slot right here let's make sure
156:22 - it is highlighted so everybody can see
156:24 - it you can see it right here if you want
156:26 - you can click on it and you can see all
156:28 - about this slot here let's go back to
156:30 - our application and clear and go up and
156:34 - run again
156:36 - we can still copy from the QT
156:39 - documentation we can grab all this no
156:42 - problem so let's come back to our
156:45 - application and paste in and if we want
156:48 - we can um okay we can copy the entire
156:51 - thing here and we can go below here and
156:54 - hit paste and you see that we can paste
156:57 - text in here and this is really cool I
156:59 - can't tell you how excited I was the
157:02 - first time I could do this with QT but
157:04 - it wasn't with pi side at the time it
157:06 - was with C plus plus but the excitement
157:09 - is the same
157:10 - so we can copy cut and paste another
157:13 - thing I want you to see is that if you
157:15 - want you can set up your own paste slot
157:18 - so for example we can say something like
157:21 - this
157:22 - okay we will be calling our own paste
157:25 - slot and if we set it up we can copy
157:29 - and go down and set it up can say Define
157:33 - paste and it's going to be a method now
157:37 - once we are in the body of this method
157:39 - we can say self text edit and call the
157:42 - paste slot ourselves because we can do
157:45 - that this is something you can do and it
157:47 - is going to behave exactly the same way
157:50 - so let's do the paste button make sure
157:52 - it is working it should be let's go up
157:55 - and run
157:56 - we can paste in the code
157:59 - from what we have in the clipboard we
158:02 - have something from our editor don't
158:04 - want that so let's grab from the website
158:07 - here and we can copy the entire thing
158:11 - okay we click on the copy button here
158:14 - and if we go down we can paste again we
158:16 - can hit the paste button to paste if we
158:19 - want we can even cut so we select
158:21 - something we cut it out it's going to go
158:23 - away we select something else we cut it
158:25 - out it's going to go away and we can
158:26 - keep pasting and really playing with
158:28 - this to have as much fun as we can with
158:31 - our application here another thing you
158:33 - can do is undo and redo and I think
158:36 - again these are forwarding the work to
158:39 - undo to the slots in Q text edit if you
158:42 - go to undo you see it here if you look
158:45 - at redo you can see it here so I think
158:48 - we can even undo if we hit and do this
158:50 - is going to undo the operations we did
158:52 - before if we redo this is going to be
158:55 - redoing and you can do something like
158:57 - this let's look at set plane text set
159:00 - HTML we have the connections then but
159:03 - they are disabled because we don't have
159:06 - the correct slots implemented let's
159:08 - Implement these slots here so we can go
159:11 - all the way to the bottom and put these
159:13 - M and let's take out the space here set
159:18 - plane text is going to call the set
159:21 - plain text method so this is the method
159:24 - you can look up in the documentation and
159:26 - we will just put in a bunch of text that
159:29 - I stole from somewhere set HTML can say
159:33 - it HTML formatted text to your plain
159:37 - text edit component and you see I have a
159:39 - few things with a few HTML headers we
159:42 - have the BR tag we can set up a list and
159:46 - you can see it right here this is basic
159:49 - HTML if you happen to know something
159:51 - about HTML let's show the terminal and
159:54 - we will play with that a little bit and
159:56 - we can run
159:58 - okay if we do set plane text this is
160:01 - going to put in the text if we say set
160:03 - HTML you can see that our HTML is going
160:06 - to show up here we have a header we have
160:08 - an unordered list here and we have
160:11 - something this is something you can do
160:13 - in your application another thing you
160:15 - can do with Q text edit is to clear the
160:18 - text and you do that by calling the
160:20 - clear slot that we have in our text edit
160:25 - component if we go back to the
160:26 - documentation again that's the best
160:29 - source of information for you so let's
160:31 - look at the slots that we have we have a
160:34 - clear slot which is going to delete all
160:36 - the text in the text edit let's go back
160:38 - to our application and see that clear
160:41 - the text goes away set plain text clear
160:44 - the text goes away we can undo we can
160:47 - redo we can do all kinds of crazy things
160:49 - this is really all I had to share in
160:52 - this lecture showing you how you can
160:53 - play with Q text edit have as much fun
160:56 - as you can with this component and then
160:58 - we are going to stop here and I will see
161:00 - you in the next lecture in this lecture
161:02 - we are going to see another use for the
161:05 - Q level component and that's using it to
161:07 - show an image
161:09 - what we want to end up with is something
161:11 - like this we will have a level component
161:14 - contained in our widget window and that
161:18 - level is going to be displaying an image
161:20 - let's look at how we can do this it's
161:22 - really simple here we have our class
161:24 - implementation we will set up an image
161:27 - level that's going to be the name of the
161:29 - variable it's going to be a q level
161:30 - component and we will call the set Pixma
161:34 - method.net and give it the image that it
161:37 - is going to be displaying this image is
161:39 - going to be living in our project under
161:42 - the images folder and we will access it
161:44 - and display it in all level once we have
161:47 - the level we will add it in the layout
161:48 - and apply the layout to our widget and
161:51 - this is going to show the application
161:53 - that we see here now that you know this
161:55 - we're going to head over to visual
161:56 - studio code and do this here we are in
162:00 - our editor we are going to be working in
162:02 - this folder here if you look in it is an
162:05 - empty folder so let's drag and drop it
162:07 - on top of Visual Studio your Cody here
162:10 - and we will do the usual setup our main
162:12 - dot python file we're going to set up
162:15 - our widget file and in our widget file
162:18 - we will set up our class which is going
162:20 - to be inheriting from Q widget let's
162:22 - make sure you see all the Imports that
162:24 - we have here we're going to be needing a
162:27 - lot of these and we can go in our main
162:29 - file and put in our starter code which
162:32 - is going to instantiate our widget
162:35 - object and show it nothing special here
162:38 - now that we have this we can try and run
162:40 - it to make sure we have no problems so
162:43 - let's do that clear and run this should
162:46 - give us an empty widget and before we do
162:49 - anything let's make sure that our image
162:51 - is in the folder so what I am going to
162:54 - do I am going to grab an image that I
162:57 - have lying on my drive here I am going
162:59 - to hop over in my project that contains
163:02 - my main python file and paste in that
163:05 - folder I am going to share this project
163:07 - on GitHub so you can download this
163:10 - project and grab this images folder and
163:12 - use it inside you will find my image
163:14 - here called Minions and it is a PNG file
163:17 - now that we have this we can set up our
163:19 - level component let's go back to the
163:21 - widget file I mean we will set our
163:24 - window title in and set up our label
163:28 - component that's what we are doing here
163:30 - after we have this we need to set a
163:32 - pixmap to our level so let's go back to
163:35 - the label documentation we can go back
163:38 - there I really want you to see these
163:40 - things in the documentation so let's do
163:42 - Q level and if we go to the
163:44 - documentation it should have a set Pixma
163:47 - method set Pixma but we have that we
163:50 - have a pixmap method which is going to
163:52 - give us the pixmap which is really a
163:54 - representation of the image that is
163:56 - displayed in the level but I can't find
163:58 - the set pixmap function not shown here
164:01 - don't know why we have it as a slot so
164:04 - we have set pixmap here and if we go in
164:07 - okay we see set pics map this property
164:11 - holds the level Peaks map setting the
164:13 - Pixma clears any previous content and
164:16 - you can see all the information here so
164:18 - this is what we do with this you can
164:20 - look at the qpix map class itself let's
164:23 - go to the top they say what this class
164:26 - does it provides a way to show an image
164:29 - basically and all the information here
164:30 - you can read if you want for now we are
164:33 - going to come back to our project and
164:36 - say Image level set Pixma and we will
164:39 - build World a qpix map object in place
164:42 - and you build it by giving it a path to
164:45 - the image that it is going to be
164:47 - displaying in our case the image leaves
164:50 - in the images folder you can see here
164:52 - and it is called minions.png let's do
164:56 - that minion dot PNG and that's going to
165:00 - be our offend now what we need to do is
165:02 - to set up a layout so we can say layout
165:04 - equals Q you can use any kind of layout
165:07 - you want let's use QV box layout why not
165:10 - we will add thanks to the layout so we
165:13 - will be adding the widget that's going
165:15 - to be our Image level and after we do
165:18 - that we will set the layout to be
165:20 - applied to our widget here set layout
165:23 - this is the flow you have to drill in
165:25 - your mind if you want to work with
165:27 - layouts with them your QT widgets let's
165:30 - pass in our layout here and I think we
165:32 - have everything we need hopefully let's
165:35 - show our terminal window what do we have
165:38 - here the application is still running we
165:40 - can kill it and clear and run again and
165:43 - if we do look at what we see here we
165:45 - have our minions image showing up this
165:47 - is really how you use a level to display
165:50 - an image and this is really all we set
165:52 - out to do I hope you found this lecture
165:54 - interesting we are going to stop here
165:56 - and I will see you in the next one in
165:59 - this lecture we are going to look at
166:01 - cute size policies and stretches and
166:04 - this is a concept we use to decide how
166:08 - our widgets we have if the user
166:10 - interface grows or shranks we will start
166:13 - by talking about sites policies and a
166:16 - science policy is a property you can
166:18 - apply to your widget to decide how that
166:22 - widget is going to behave if the user
166:25 - interface grows or shrinks for example
166:28 - if we resize the in globin window here
166:32 - we have the option to let the level here
166:35 - and the line edit grow at the same time
166:38 - so the sound so the label is going to
166:40 - grow and the line edit is going to grow
166:42 - or we can choose to say the level is not
166:46 - going to grow it's going to say to the
166:48 - same width but the line edit is going to
166:50 - grow and we can control these things
166:53 - using size policies I know this concept
166:56 - can be hard to grab but you are going to
166:59 - see what this really means when we get
167:01 - it to run this in Visual Studio code in
167:03 - a minute another concept to that I
167:05 - wanted to cover before we head over to
167:07 - the editor is the concept of stretch and
167:11 - the stretch is a property that says how
167:14 - many units each widget is going to
167:17 - occupy in a layout what do I mean here
167:22 - if you look at our buttons.org in a
167:26 - horizontal layout I set them up in a way
167:29 - that the button that says one has twice
167:33 - the width of two and three here and you
167:36 - can set up by setting up a stretch so
167:39 - what I really did I said the button
167:41 - saying one here is going to have a
167:43 - stretch of two the two bottle is going
167:46 - to have a stretch of one the three
167:48 - button is going to have a stretch of one
167:49 - and at any point when the user interface
167:52 - grows horizontally the button saying one
167:55 - is going to be occupying twice the size
167:58 - occupied by either of the other buttons
168:00 - this is how you can say it using
168:02 - stretches and you can use these Concepts
168:04 - in your QT application if you happen to
168:07 - need that
168:08 - here is the code that is going to allow
168:10 - us to do these things here for example
168:13 - we have our level
168:14 - okay and the line edit and we can set
168:17 - the size policy you can say I want my
168:20 - widget to expand horizontally or
168:22 - vertically when the user interface that
168:25 - includes my widget resizes and if you
168:29 - want to expand horizontally you pass
168:30 - that as the first parameter of the set
168:35 - method here and if you want to expand
168:37 - vertically you pass that as the second
168:40 - parameter here in this case we are
168:42 - saying we want to expand horizontally
168:43 - for a design edit and we don't want to
168:46 - expand vertically so vertically we're
168:48 - going to be fixed this is how you say it
168:50 - if you want to be expanded in both of
168:52 - directions you can say it like we do
168:54 - here and this is going to work down here
168:56 - you see that we can do the same on the
168:58 - level component you're going to see the
169:00 - behavior of this when we hit the editor
169:02 - in a minute down here we have the layout
169:05 - the usual thing you already know
169:07 - now we can look at switches and a
169:10 - stretch again is specifying how many
169:13 - units each component is going to be
169:15 - using in the layout
169:19 - in the example I showed I had an example
169:23 - where the first veteran occupied twice
169:27 - the space occupied by each other button
169:29 - here so let's make sure I can at least
169:32 - try to visualize this
169:34 - so suppose the first button here has two
169:37 - units okay it occupies two units and
169:40 - each other one is going to be occupying
169:42 - one unit you specify your stretch as the
169:46 - second parameter to the add widget
169:47 - method so we are saying that button one
169:51 - is going to have a stretch of two button
169:54 - two is going to have a stretch of one
169:56 - and button three is going to have a
169:58 - stretch of one and we can add these guys
170:00 - to the layout to show them in our user
170:02 - interface now that you know this we're
170:04 - going to head over to visual studio code
170:06 - and see this in action here we are in
170:10 - our editor Visual Studio code we have an
170:12 - empty folder that we will be using for
170:14 - this project here we can drag it and
170:16 - drop it on top of Visual Studio code
170:19 - once we have this opened we can create
170:21 - our files the main python file and at
170:25 - the widget python file once we have the
170:27 - widget python file we can put in our
170:29 - starter code we have that right here and
170:32 - we just set the window title this and we
170:36 - can head over to the main python file
170:38 - and put in our code which is going to
170:39 - import the components we need we are
170:42 - going to set up our widget and we are
170:44 - going to show it
170:45 - we can try to run this to make sure we
170:48 - have no problems so let's show our
170:51 - terminal here
170:53 - and clear if I can type and we can show
170:57 - the application we have our widget here
170:59 - everything is working as expected the
171:01 - first thing I am going to do is to set
171:03 - up my components so that I have my full
171:06 - user interface once we have it we will
171:08 - play with size policies and stretches so
171:11 - we have the level and the line edit we
171:13 - will go down and set up the layout that
171:15 - is going to be containing our line edit
171:18 - and level
171:20 - and this is nothing complicated so what
171:22 - this is going to do is to set up a
171:25 - horizontal layout
171:26 - and it the horizontal layout is going to
171:28 - be containing our level and our line
171:31 - edit this is what we want to do here we
171:33 - also want to set up another layout which
171:35 - is going to be containing three buttons
171:37 - and these are going to be laid out like
171:40 - this this is the goal we have using
171:42 - stretches so the first button is going
171:45 - to be occupying twice the space occupied
171:47 - by the other buttons let's go down and
171:50 - put in the buttons let's put in the
171:52 - buttons here I am going to paste them in
171:55 - to save on some typing time here button
171:57 - one button two button three and we will
172:00 - add them to their own layout once we
172:03 - have this we will set up a vertical
172:04 - layout on which we will be adding these
172:07 - layouts here to have them on separate
172:09 - rows each one being horizontal if that
172:13 - is making any sense okay we have our
172:15 - vertical layout we can add in our
172:18 - horizontal layouts and we set the layout
172:20 - to the widget here okay now that we have
172:22 - this I think we can actually take out
172:25 - the second parameters for add widget
172:27 - here because we will add them when we
172:29 - want to play with stretches for now we
172:31 - want to see our user interface and I
172:33 - think we have it set up again if you are
172:35 - confused we have our label component the
172:38 - line edit we are laying them out
172:41 - horizontally so the label is going to be
172:43 - to the left the line editor is going to
172:45 - be to the right after that we set up our
172:47 - buttons one is going to say one two two
172:49 - and three they are going to be saying
172:52 - one two three here and we laid the
172:54 - buttons in a horizontal layout as well
172:57 - after that we will be setting up a
172:59 - vertical layout which is going to be
173:01 - containing those two layouts again to
173:04 - the top we will be having our line edit
173:08 - and our level so the level is going to
173:12 - be to the left and the line edit is
173:14 - going to be to the right down below we
173:16 - will have our buttons so at this point
173:18 - we don't have any stretch applied so
173:20 - they will have the same size
173:23 - as I can roughly draw here this is what
173:26 - we intend to see when we run the
173:28 - application let's go to view
173:30 - and the terminal
173:32 - and we can run again if we do we should
173:37 - see our user interface and let's try to
173:40 - play with it and see what is happening
173:42 - here so if we resize the user interface
173:45 - horizontally you see that the level
173:48 - which is saying some text here is not
173:50 - growing but the line edit on top is
173:54 - occupying all the space
173:56 - down below we can see that the buttons
173:59 - are all growing horizontally at the same
174:02 - rate and this is the default Behavior we
174:06 - have for buttons in the layout let's try
174:08 - to expand vertically and see what
174:11 - happens you see the buttons don't expand
174:14 - and the line edit and the level don't
174:17 - expand vertically so let's try to use
174:20 - size policies on the line edit to
174:24 - simulate the behavior we have by default
174:28 - so what we can do is go to the line edit
174:31 - component here we can say line edit set
174:34 - size policy because this is the method
174:36 - that is going to be setting our size
174:38 - policy and we can tell that Q science
174:40 - policy horizontally I want to expand so
174:44 - it's going to be expanding horizontally
174:46 - we can say it like this but vertically
174:49 - it's going to be fixed so let's do that
174:51 - Q size policy fixed you can say that
174:54 - here and this is going to be simulating
174:56 - the default Behavior we just experienced
174:59 - in a minute let's try to view and the
175:02 - terminal and try to run if we do and we
175:05 - try to expand horizontally you see
175:07 - nothing changes because we are
175:09 - simulating the defaults if we're trying
175:12 - to expand it vertically we're going to
175:14 - see that we're not going to expand
175:16 - vertically but if we want we can set the
175:19 - size policy fixed even horizontal let's
175:21 - see what happens if we do that so we're
175:23 - going to say fixed here if I can type
175:25 - that and we are going to run the
175:27 - application again now we have the
175:29 - application and you see that if we
175:32 - expand horizontally the line edit is
175:35 - going to have a fixed size it's not
175:36 - going to grow whatsoever and this is a
175:39 - setting you might want to do if this
175:41 - makes sense for whatever you are
175:43 - designing your user interface for I am
175:46 - going to turn this back to expanding but
175:49 - another weird thing I want you to see is
175:51 - that you can set your line edit to
175:54 - expand even virtue so we're going to say
175:57 - it's random here and if we try to run
176:00 - again we will see that it will try to
176:02 - occupy as much space as possible
176:04 - vertically you can shrink it it's going
176:06 - to go down but if we go up we're going
176:08 - to see that it's going to be growing
176:11 - vertically and it is still a line edit
176:13 - even if it doesn't look like so so this
176:16 - is where you shouldn't really do that I
176:18 - am doing this to show you the effects of
176:20 - size policies in your applications let's
176:22 - turn this back to fixed you can also
176:25 - apply size policies to the level for now
176:28 - the label is not expanding either
176:30 - horizontally or vertically but we can
176:33 - play with us and really make it to do
176:35 - weird things so let's shift alt down to
176:38 - copy the line we're going to make this
176:41 - apply something on the level and the
176:44 - level is going to be expanding as well
176:46 - horizontally because that's the setting
176:48 - we have here let's see what happens and
176:51 - we can run
176:53 - and it is level with lowercase I think
176:56 - that's the problem here let's run again
176:59 - now it's going to run and you see that
177:01 - the level now is occupying space all of
177:05 - this space you see down here which is
177:08 - gray is occupied by the level and it is
177:11 - growing horizontally as well we can also
177:13 - set it to grow vertically but we're not
177:15 - going to do that you can play with it if
177:17 - you want my intent here is to show you
177:19 - how to use science policies to your
177:21 - advantage and the main intent for size
177:23 - policies is to Define how your widgets
177:27 - are going to behave when the user
177:30 - interface grows or shranks if the user
177:33 - interface grows your widget may decide
177:35 - to grow horizontally or vertically and
177:37 - you can control these properties using
177:39 - site's policies now that we have this
177:41 - out of the way we can focus on stretches
177:44 - stretches control how much space is
177:48 - occupied by each widget in the user
177:51 - interface for example if we run the
177:53 - application again let's do that we see
177:55 - that our buttons are occupying the same
177:58 - space so you can say that each widget is
178:01 - really occupying one unit of space
178:03 - because they are all occupying the same
178:06 - space to kind of simulate the default
178:09 - Behavior we have we can specify a
178:11 - stretch as a second parameter to the add
178:13 - widget method as we saw but we will be
178:16 - using a stretch of one okay so the unit
178:19 - is going to be one and each of these
178:21 - widgets is going to be occupying the
178:23 - same space in the layout this is
178:25 - something we can do let's scale the
178:27 - application here
178:29 - and run it again you're going to see
178:30 - that it is going to be doing exactly the
178:33 - same thing but now that we know about
178:35 - stretches we can decide to choose one
178:37 - widget and tell it to occupy however
178:40 - many units we want so the unit is one
178:42 - but we want the first widget to for
178:45 - example occupy three units with this
178:48 - setting button two is going to have one
178:49 - unit button Loop 3 is going to have one
178:52 - unit but button one is going to have
178:54 - three units let's try and run we expect
178:57 - button one to occupy three times the
179:00 - space occupied by button 2 and button
179:02 - three that's the setting we have here
179:04 - and if our user interface grows you see
179:07 - that that's going to be three times if
179:10 - you measure this you're going to find
179:11 - that out I think it is easier to see it
179:13 - if we set button one to two so let's do
179:17 - that
179:17 - and as we grow now button one is
179:21 - occupying two times the space occupied
179:25 - by the other buttons here you can see
179:28 - that right here this is really all I had
179:30 - to share in this lecture showing you how
179:32 - to play with size policies and stretches
179:34 - use this if it makes sense in your QT
179:37 - applications we will stop here in this
179:39 - lecture and we'll see you in the next
179:41 - one
179:42 - in this lecture we are going to look at
179:44 - the cube read layout component in your
179:47 - QT applications and this is a component
179:50 - that allows you to lay out widgets in a
179:53 - grid and it's really likable so you have
179:57 - a table here which has three rows and
180:01 - three columns as you can see here and
180:04 - the first thing here is going to have an
180:06 - index of zero zero so it's going to be
180:09 - at row 0 column zero this is going to be
180:13 - at Row one column one that should be
180:16 - this thing here if you target this
180:18 - linear it should be at row two zero one
180:22 - two and column two you use these kinds
180:25 - of indexes to Target where you want your
180:28 - widget to show up in the grid layout now
180:32 - that you have the idea let's see what we
180:34 - can achieve with this in this lecture we
180:36 - will be setting up a user interface like
180:38 - this this is going to be a grid but you
180:40 - see that we have the ability to tell a
180:42 - component to occupy more than one row or
180:48 - more than one column and we do this with
180:51 - a property called row span or column
180:54 - span and we do that in code as you see
180:57 - here so here is an example we have our
181:00 - buttons we are setting them up button
181:02 - one all the way to button seven we set
181:04 - up a grid layout component and we
181:07 - specify the location where the buttons
181:09 - are going to leave for example button
181:12 - one is going to be at 0 0 so the first
181:15 - one is the row the other one is the
181:17 - column button two is going to leave at 0
181:20 - 1 button 3 is going to leave at one zero
181:24 - button 4 is going to leave at 1 1 and
181:27 - all the way to button 7 which is going
181:29 - to be leaving at 2-2 and you might be
181:31 - asking what are these additional
181:34 - parameters you pass when you set up
181:37 - button two and button three well this is
181:41 - because we want to set up a structure
181:43 - like this so suppose we have three rows
181:47 - and three columns let's try to do this
181:50 - as evenly as I can and we want button
181:53 - one to occupy slot zero zero that's
181:56 - going to be this guy here zero zero zero
181:59 - zero column that's the minion and we
182:03 - have button 2 occupying zero one so this
182:07 - is going to be button two button two is
182:11 - way to occupy one row okay the
182:14 - additional parameters are going to be
182:16 - specified the row span and the column
182:19 - span and this button is going to be
182:22 - spanning one row and two columns so
182:24 - button two is going to show up
182:25 - throughout here okay this is what we
182:28 - want to do for button three it is going
182:31 - to be at index one zero so that's going
182:34 - to be our three here
182:35 - but it is going to take up two slots
182:38 - vertically the rose band is two that's
182:41 - what we see here and down below this
182:44 - should be three two if we go to button
182:47 - four it's going to take one one so one
182:51 - one that's going to be our button four
182:53 - and you can keep completing these things
182:56 - as you see but the main idea is that
182:58 - button 2 is going to occupy two columns
183:01 - because we have two as the column span
183:04 - and button three is going to occupy two
183:06 - rows because we have a row span of two
183:09 - hopefully this is making some sense and
183:12 - if you go to the top you see that we are
183:13 - setting up a size policy for button
183:15 - three because we want it to expand in
183:18 - all directions to occupy as much space
183:21 - as possible and that's going to allow us
183:23 - to have a user interface like this that
183:25 - we are after now that you notice we can
183:28 - head over to visual studio code and play
183:30 - with us a little more okay here we are
183:32 - in our editor the current project is
183:35 - going to be living in this folder here
183:37 - grid layout we can grab it and drop it
183:40 - on the Visual Studio code editor and we
183:45 - are going to create our files main.py as
183:47 - usual and we want to do widget that P1
183:51 - once we have this we will put in our
183:53 - code for the widget usual stuff really
183:55 - make sure you see the Imports we have
183:57 - here
183:58 - you can see them all but we will be
184:01 - needing some of these and we can head
184:04 - over to the main file and put in our
184:06 - starter code make sure this runs so
184:08 - let's bring up terminal and run this
184:12 - and we should see an empty widget now
184:15 - that we have this running we can come
184:16 - back to our widget and actually set up
184:19 - our buttons remember the user interface
184:21 - we are after we have a bunch of buttons
184:23 - so we have button one all the way to
184:26 - button seven here they have names one
184:28 - through seven and we are going to use
184:31 - the grid layout to show them in this
184:34 - widget here so let's go down and make
184:36 - sure we set up our layout here it is
184:39 - going to be a grid layout to be able to
184:41 - use this you need to have imported Q
184:44 - grid layout I don't think we need the
184:48 - horizontal layout here we don't need the
184:50 - vertical layout here if we need them we
184:52 - will import them back but if you have
184:54 - Imports you don't need you can take them
184:56 - out here
184:57 - so do we need to line edit we don't I
185:00 - think let's remove that and we will need
185:03 - the size policy in a minute okay now we
185:05 - have the layout and one thing I want you
185:07 - to see is that we specify the location
185:09 - where the widget is going to show up in
185:12 - our grid layout using indexes like this
185:15 - so we have the row position and the
185:19 - column position
185:20 - after that you may also specify the rows
185:23 - panel like we do for button 2 and button
185:25 - three in this case button 2 is going to
185:28 - take up one row and two columns button
185:32 - three is going to take up two rows and
185:34 - one column and that's going to give us
185:36 - the user interface we want once we have
185:38 - this we can set the layout to the
185:40 - current weather layout and it's going to
185:43 - be grid layout you can do that and I
185:46 - think we can run the application and see
185:48 - our user interface in action let's go to
185:50 - view and terminal
185:52 - and run
185:53 - if we run we will have our user
185:55 - interface you can see that button 2 is
185:58 - taking up space
186:00 - for
186:02 - two columns okay and button three is
186:06 - taking up space for two rows but we
186:09 - can't see this because we didn't
186:10 - instruct this button to expand in all
186:13 - spaces as much as it wants so let's do
186:16 - that we are going to go back to the code
186:18 - and enable this line that sets the size
186:22 - policy to expand in all directions once
186:24 - we do that our button is going to expand
186:26 - and fill as much space as it can and you
186:30 - can see that it is working to our
186:32 - advantage now this is really all I had
186:34 - to share in this lecture showing you how
186:36 - you can use grid layout use it if it
186:39 - makes sense in your QT applications we
186:42 - are going to stop here in this lecture
186:43 - and I will see you in the next one in
186:46 - this lecture we are going to look at the
186:48 - Q checkbox and Q radio button components
186:52 - in your QT applications and these are
186:55 - things you use to let users choose
186:58 - options in your applications for example
187:00 - you may want your users to choose an
187:02 - operating system that they like and you
187:05 - may want to give them the option to
187:06 - choose multiple choices so you can let
187:09 - them for example choose windows and
187:11 - Linux or either of these options another
187:15 - option is to let them only choose one
187:17 - and if you want to do that you may do
187:21 - something like this using radio buttons
187:23 - if they choose one the other is going to
187:26 - be disabled and at any point they will
187:29 - only be able to choose one thing so they
187:32 - can either choose a b or c but they
187:34 - can't have a and b enabled at the same
187:38 - time and this is what we call an
187:40 - exclusive button if you want you may
187:43 - also set up a checkbox to be exclusive
187:46 - and I will show you how to do this in a
187:47 - minute but this is what we are after in
187:49 - this lecture here we will build a user
187:51 - interface like this using qradio button
187:54 - and Q check box here is a simple example
187:57 - of how you can set up non-exclusive
188:00 - checkboxes in your application and the
188:03 - main message I wanted to convey here is
188:05 - that if you want to group a bunch of
188:07 - check boxes you will put them in a group
188:10 - box this is something very crucial to be
188:13 - able to work with these components so we
188:16 - will set up a group box for the
188:17 - operating system that's what I'm in here
188:19 - and we will set up our check boxes we
188:22 - have a Windows checkbox we have a Linux
188:24 - checkbox and we have a Mac checkbox and
188:28 - we are doing some connections here to
188:30 - know when the user toggles the checkbox
188:32 - but for now let's worry about laying
188:35 - these things out once we have the group
188:38 - box we will set up a layout that is
188:41 - going to be shown in our group box and
188:43 - we will be adding these check boxes to
188:47 - the layout this is a bit convoluted but
188:49 - this is really what we have to work with
188:51 - in QT so again we have a group box we
188:54 - have our check boxes and we will be
188:57 - adding the check boxes to the layout
189:00 - that is going to be shown in our group
189:03 - box so we will be adding the windows
189:06 - Linux and Mac checkboxes to the layout
189:08 - and after that we will be applying this
189:11 - layout to our group box this is what we
189:14 - do here and once we do this our group
189:17 - box is going to be kind of wrapping
189:19 - around our checkboxes and treating them
189:22 - as a single unit you can move around if
189:24 - you want to do that and we will see that
189:27 - we can add this group box to other
189:29 - layouts to really have a complex user
189:32 - interface in our QT applications here
189:35 - you see the slots that we will be using
189:37 - to know when the user toggles our
189:40 - checkboxes if they toggle the windows
189:42 - checkbox this method is going to be
189:45 - activated if they toggle the Linux one
189:47 - we will activate this if they tackle the
189:49 - Mach 1 will activate this nothing
189:51 - special here
189:53 - if we go down we will see that we can
189:55 - also set up exclusive checkboxes and the
189:58 - meat of this is to set up a button group
190:01 - again that is going to be logically
190:04 - grouping these buttons together and once
190:07 - you have this button group you can say
190:10 - that you want them to be exclusive by
190:14 - calling to set exclusive and passing in
190:16 - a true value and this is going to make
190:18 - these buttons exclusive once you do this
190:21 - you want to have the option to choose
190:23 - multiple options again we may have
190:25 - something like this for checkboxes and
190:28 - once they are exclusive you can only
190:30 - have one chat you can't have more than
190:33 - one selected and that's the behavior you
190:36 - have with the exclusivity here if you
190:39 - wanted the default exclusive Behavior
190:41 - you can use radio buttons and again they
190:44 - work the same we can have our group box
190:46 - here once we do that we set up our radio
190:49 - buttons we will be adding the radio
190:51 - buttons to a layout okay and we will be
190:54 - applying this layout to the group box
190:57 - that we have here using the line here
191:00 - now that you know this I think we can
191:02 - head over to visual studio code and play
191:04 - with us a little more okay here we are
191:07 - in our editor the folder we will be
191:10 - using is right here so it is an empty
191:12 - folder we can drag it and drop it on top
191:15 - of Visual Studio code this is going to
191:17 - open it up we are creating our main
191:20 - python file and the widget file and we
191:24 - put in our starter code for the widget
191:26 - we can head over to the main file and
191:29 - also put in our code and let's see if
191:31 - this actually runs before we do anything
191:34 - else this is my habit if we run we will
191:37 - have our empty widget and we can start
191:39 - doing our crazy things here let's come
191:41 - back to the widget and remember we are
191:44 - after a user interface like this the
191:46 - first thing we're going to do is to set
191:48 - up this group of check boxes we can do
191:51 - that by coming up in our Constructor and
191:54 - setting up that group I am going to put
191:56 - in the code to save on some typing here
191:59 - and I will do my best to explain this so
192:02 - this is going to first to set up a group
192:04 - box okay as I said it before you can
192:07 - think of a group box as a container of
192:11 - check boxes okay in this case we are
192:14 - interested in check boxes suppose we
192:16 - have three checkboxes in here we are
192:19 - going to put them in a group box and it
192:21 - will be this group box that we move
192:23 - around but to have it set up we have to
192:26 - actually set up our check boxes that's
192:28 - what we do here we have one for Windows
192:30 - one for Linux one for mac and once we
192:33 - have the check boxes we will set up a
192:36 - layout that is going to be within this
192:39 - grouper box here so this is going to be
192:42 - our layout and we will apply the layout
192:45 - to the grouped box this is the setup we
192:48 - have here take a moment to really
192:51 - understand this it is a bit convoluted
192:52 - but once you understand this it's going
192:54 - to be a piece of cake to work with
192:56 - checkboxes and radio buttons in your QT
192:58 - applications okay we have our checkbox
193:02 - but we can't really see it yet let's see
193:05 - what I can do to be able to see this and
193:09 - increase the complexity of our user
193:11 - interface as we go I think this is going
193:13 - to be a good exercise what we can do is
193:16 - set up a layout so let's say layout and
193:19 - we are going to say QV box layout it's
193:22 - going to be a vertical layout we will
193:25 - add our operating system group box to
193:27 - the layout add the widget I want to get
193:30 - autocomplete here because I am lazy so
193:33 - we want to add OS which is a group box
193:35 - and we want to set the layout to the
193:37 - current widget here so we're going to
193:39 - say self set layout and we want the
193:43 - layout applied I think if we run we
193:45 - should see our checkboxes showing on our
193:47 - user interface so let's do this we're
193:50 - going to show the terminal and run and
193:52 - what do we have here no attribute
193:55 - Windows tackled so we have connections
193:57 - that are not working yet let's comment
194:00 - this out because they are going to just
194:02 - give us a hard time here and we can try
194:05 - to run again and if we do notice what we
194:08 - see we have our group books and we have
194:11 - our check boxes and we can check them
194:14 - all if we want or we can check two or we
194:17 - can check one because this is not
194:19 - exclusive so you can have multiple ones
194:21 - selected and once we have these we may
194:24 - be interested in getting the information
194:27 - out of these guys for example if the
194:29 - user checks windows we want to do
194:31 - something in our application to take
194:33 - into account that the user choose the
194:35 - window checkbox here and
194:37 - by connecting to the toggled signal so
194:41 - we're going to set up these slots here
194:42 - let's activate these connections that we
194:45 - did here and I think we can put a space
194:47 - in here to make it easier to read and
194:50 - let's put in these implementations so
194:53 - let's go all the way to the bottom where
194:55 - we have our Constructor defined and we
194:57 - are going to Define our 2 or 3 method
195:01 - implementations notice that we have a
195:04 - parameter how do I know we have a
195:06 - parameter well I read the documentation
195:08 - for the signals for checkbox let's go
195:11 - there to do this together so that you
195:14 - can really see what is going on here
195:16 - let's do Q check box but it is the same
195:19 - thing you have for Q push button so it's
195:22 - kind of a repetition here but I am going
195:24 - to show you that anyway if you look you
195:26 - see that we don't have the signals the
195:28 - same behavior we saw for the Q push
195:31 - button but we can go to the parent class
195:33 - and what this says is that really 2
195:37 - checkbox has a lot of things it shares
195:40 - with Q push button it just happens to
195:43 - display differently but because it
195:46 - inherits Q abstract button it shares
195:49 - many behaviors with Q push button I want
195:51 - you to keep that in mind let's go to Q
195:53 - abstract button if we go to signals we
195:56 - will see that we have a toggled signal
195:58 - that happens to send a parameter and
196:02 - this is what we are going to catch and
196:04 - to decide whether the radio pattern is
196:07 - checked or not checked this is really
196:09 - cool let's come back to our code and we
196:12 - can look at our method here if checked
196:15 - we will so that it is checked if it's
196:18 - not checked we will say that it is
196:20 - unchecked the same applies to Linux and
196:22 - Mac here we have done the connections so
196:25 - this should work if we run the
196:27 - application let's show our terminal
196:30 - window clear and take out all this
196:33 - garbage we have here and we will run if
196:37 - we check window cells Windows is checked
196:39 - if we uncheck windows it's unchecked
196:41 - let's do the same for Linux you see it
196:44 - works let's do the same format you see
196:46 - it works this is really how you can
196:48 - process this information in your QT
196:50 - applications now that we have this we
196:52 - can set up an exclusive set of check
196:55 - boxes let's go down and do that and I
196:58 - think we can go down below here and say
197:02 - exclusive checkboxes and this is going
197:05 - to be allowing the user to choose ranks
197:08 - this is what we do as an example here
197:10 - and what we do here we will set up a
197:13 - group box
197:14 - okay just like we did for check boxes
197:17 - and we will set up a beer checkbox a
197:20 - juice checkbox and a coffee checkbox we
197:23 - will set the beer one checked by default
197:25 - you can do this programmatically adjust
197:27 - the left in this line to be able to show
197:29 - you this and we will set up a logical
197:32 - grouping of these buttons so that we
197:35 - have the ability to set them to be
197:37 - exclusive so this is how you make them
197:39 - exclusive once you have this you will
197:41 - set up the layout like we did for the
197:43 - other checkboxes we will add them to the
197:46 - layout and we will apply the layout to
197:49 - the drinks group box here once we have
197:53 - this we can add this to our user
197:54 - interface but we will have to change the
197:57 - layout a bit for example we can change
197:59 - this to be a horizontal layout okay we
198:03 - can do this and after this we will add
198:05 - the other group box which is going to be
198:07 - containing our drinks let's copy the
198:10 - name here because I tend to forget these
198:13 - things and mess up so let's do layout
198:14 - add widget and we will be adding our
198:17 - drinks group box if we run we should see
198:20 - this showing up on our user interface
198:23 - let's do terminal and run you see we
198:26 - have our drinks and because this is an
198:29 - exclusive set of check boxes we can only
198:32 - choose one at a given time unlike what
198:35 - we can do with the other one for the
198:38 - operating system so you can choose
198:40 - whatever you want in your QT
198:42 - applications let's show you how to work
198:45 - with radio buttons and the behavior is
198:48 - really going to be the same so we can go
198:51 - down and set up a set of radio buttons
198:54 - let's do that I am going to go down here
198:57 - and do that we have our radio buttons
199:00 - here again we have a group box which is
199:02 - going to group them together we set up
199:04 - the radio buttons we set one to be
199:07 - checked by default and we will set up a
199:10 - layout that is going to be applied to
199:13 - the group box we added things to the
199:15 - layout and we apply the layout to our
199:18 - group box here and if we want we can add
199:21 - this to our I think we put our code here
199:24 - in the wrong spot so let's cut this out
199:27 - we don't want to mess up our layout here
199:30 - so we just go below the group for
199:33 - exclusive check boxes and we will put
199:36 - our code in here sorry for that if it
199:38 - was confusing and we will go down and
199:42 - add this to the layout so we can say
199:44 - layout add Twitter and that's going to
199:46 - be answers I think so let's do that
199:49 - answers and if we run okay we can run
199:53 - the application we will have our fan
199:55 - here if you want we can even achieve
199:58 - what we saw in the slides here so all we
200:02 - have to do is set up a vertical layout
200:04 - and add the radio buttons to the bottom
200:07 - of the vertical layout we can do that we
200:10 - already know how to do that let's come
200:12 - back to our code so what we need to do
200:14 - is to take this guy here out of our
200:19 - horizontal layout and we will set up a
200:22 - vertical layout that is going to be the
200:24 - actual layout of the user interface so
200:27 - let's say we layout equals QV box layout
200:31 - and we will name this horizontal layout
200:34 - to be self-descriptive here I don't want
200:38 - the code to be confusing good names are
200:41 - really important you should focus on
200:42 - that make sure the names describe what
200:46 - you are doing in your user interface we
200:48 - have the vertical layout so what we do
200:51 - with the vertical layout we will add
200:53 - the horizontal layout so let's do V
200:56 - layout add layout and we will be adding
200:59 - the H layout that we have set up in our
201:01 - code and after this we will be adding
201:04 - the answers group of radio buttons so
201:09 - let's do the layout add widget answers
201:11 - answers and we will be setting V layout
201:15 - as our layout here I hope you can
201:18 - understand this
201:19 - if you don't please go back to the point
201:21 - where we talked about layout in a bunch
201:24 - of Widgets or you can even ask me I will
201:26 - do the best I can to help you out let's
201:29 - view our terminal and we can clear and
201:32 - run if we run we will have our user
201:35 - interface and ladies and gentlemen this
201:37 - is what we set out to do in this lecture
201:40 - I hope you found it interesting we are
201:42 - going to stop here in this one and I
201:44 - will see you in the next lecture in this
201:46 - lecture we are going to look at The Cue
201:48 - list widget component this is a
201:50 - component that allows you to lay out
201:52 - things in a list in a widget so for
201:54 - example you can set up a widget like
201:56 - this and we have a list of things we
201:58 - have one two three we can even add more
202:00 - and we will see how to do that and you
202:03 - can really use it if you need this kind
202:06 - of list in your user interface in this
202:09 - lecture we will see how to set it up so
202:11 - we will set up a class and set up our
202:13 - widget we will see how to add items we
202:15 - will see how to remove items we will see
202:18 - how to get how many items are in our
202:21 - list we will see how to get selected
202:23 - items and we will get the list of items
202:26 - and print them out to really give you a
202:29 - foundation on using this component in
202:31 - your own QT applications this is how
202:34 - we're going to set it up we will have a
202:36 - list widget component and this is going
202:38 - to be our variable once you have it you
202:41 - can choose to set the selection mode and
202:44 - what this really means is whether you
202:46 - allow users to only select a single item
202:49 - or to be able to select multiple items
202:53 - and you can control this using this
202:54 - setting here you can add items using the
202:58 - add item or add items method and you can
203:01 - connect to a bunch of signals to know
203:04 - whether the current item has changed or
203:07 - whether the current text has changed and
203:09 - you can check the documentation to see
203:11 - other signals that are offered by this
203:14 - component down below we are setting up a
203:16 - bunch of buttons to be able to play with
203:18 - this component and you can see that we
203:21 - can also set up a bunch of methods that
203:23 - are going to be triggered when we do
203:25 - things in our list widget for example
203:28 - this method is going to be triggered
203:29 - whenever the current item changes we
203:32 - will be able to print the new current
203:34 - item we will be able to respond when the
203:38 - current text changes we will be able to
203:40 - call this method to add items and really
203:42 - all these methods to do all kinds of
203:45 - crazy things now that you know this we
203:47 - are going to head over to visual studio
203:49 - code and play with us a little more here
203:52 - we are in our editor this is going to be
203:56 - our current project folder it is empty
203:58 - as you can see now let's drag it and
204:00 - drop it on top of Visual Studio code
204:02 - here this is going to open our project
204:04 - and we can create our files so we needed
204:08 - the widget file and we will put in our
204:10 - starter code which is going to give us
204:12 - an empty widget with a title here we can
204:15 - head over to the main file and put in
204:18 - the code that you are familiar with by
204:20 - now and we can view our terminal to try
204:24 - and run the application to make sure
204:27 - this is working as we want let's run it
204:29 - this will pop up our empty widget here
204:31 - the first thing we want to do is to set
204:34 - up our list widget and we have the
204:37 - needed components imported if you go to
204:39 - the top here you see that we are
204:41 - importing Q list widget we can go down
204:43 - and create a variable for this which is
204:45 - going to be a member of this class here
204:47 - because of the self thing we are doing
204:50 - here this is our list widget we need to
204:52 - give it a parent and we say that we want
204:55 - to be able to select multiple items
204:58 - using this setting here once we do that
205:01 - we are going to add items you can either
205:03 - add a single item using the add item
205:07 - method as you see here or you can use
205:09 - the add items method once we have this I
205:12 - think we can set up a layout let's use a
205:15 - vertical layout so we are going to say V
205:18 - layout QV box layout and we are going to
205:21 - say V layout add the widget add the
205:23 - widget that's going to be
205:25 - self with list we get and we will set
205:29 - this layout to be used by the current
205:31 - widget here so we're going to say self
205:33 - set layout
205:35 - and we will use vla out here and I think
205:39 - if we run we will see our list widget
205:41 - with the three items of data that we
205:45 - have added so let's view terminal
205:48 - and run this and if we do this you see
205:51 - that we have one two three and this is
205:53 - what you can do with a list widget now
205:56 - that we have this we can connect to a
205:58 - bunch of signals from cue list widget
206:00 - but before we do that I think it is a
206:02 - good idea to come back to the
206:04 - documentation so let's say Q list we get
206:06 - here and we can look at what it has to
206:09 - offer I do recommend reading as much as
206:12 - you can on this especially if it is the
206:15 - first time you use this component here
206:16 - so come to more look at what you can do
206:19 - with that if you go to the top you're
206:21 - going to see a bunch of signals you can
206:23 - use if we can find them you see we have
206:25 - a lot of signals that we can play with
206:27 - we have a lot of slots we can play with
206:29 - make sure you look at those that
206:31 - interest you and read the documentation
206:33 - to really know what these things do
206:36 - let's come back to our application and
206:39 - we will put in a bunch of connections
206:41 - here once we have the list widgets set
206:43 - up we will connect to the current item
206:47 - changed signal and the current text
206:49 - change the signal and if you want to
206:52 - know what these signals do again use the
206:56 - documentation to your advantage current
206:58 - item changed let's see what happens here
207:01 - current item changed if we go to the
207:04 - signal this property holds the row of
207:07 - the current item they don't say anything
207:09 - about this signal here
207:11 - and this is a bummer this is really bad
207:14 - because QT should
207:16 - say at least something about this but
207:19 - they don't this is going to be triggered
207:20 - when you change the current item in your
207:23 - list widget if you wanted to see a good
207:26 - documentation for QT for example if you
207:29 - think that the documentation for acute
207:31 - for python is lacking in some way you
207:34 - can use the C plus documentation and all
207:36 - you have to do is say queue list widget
207:39 - and say qt6 for example this is going to
207:42 - give you the C plus plus documentation
207:44 - okay I think I should have said this
207:46 - somewhere I will update the course to be
207:49 - able to say that so we have cue list
207:51 - widget if we go down we see the
207:54 - properties
207:55 - let's look at the signals current item
207:58 - changed and at least they say what the
208:00 - signal does this is what I mean when I
208:03 - say that the python documentation is
208:05 - still lacking so if you want you can use
208:07 - the C plus documentation like I do here
208:10 - or you can use the python documentation
208:12 - we have been using all along let's come
208:15 - back to our project and we need to set
208:18 - up these methods that are going to be
208:20 - triggered when these signals are fired
208:23 - we can go down and put in our method
208:27 - definitions you can do that we have
208:30 - current item changed and you see the
208:33 - signal is going to give us the current
208:34 - item the new item if I can say it like
208:37 - that and the current text change the
208:40 - signal is going to give us the new text
208:42 - let's try to run this and see what
208:44 - happens so view terminal and run this
208:47 - and I think the application is still
208:49 - running but no big deal we can run it
208:52 - again
208:53 - let's go to
208:55 - okay so let's run
208:57 - and if we click on one this is the
209:00 - current item if we click on two we see
209:02 - current item and we can click on three
209:05 - to see the current item and they tell
209:07 - you that the current item text has
209:09 - changed so you can use these signals if
209:11 - you want in your QT application okay now
209:14 - that we have this working we can add a
209:16 - bunch of buttons that will allow us to
209:19 - manipulate our list widget for example
209:21 - we might want to add a new item to get
209:23 - to the current item count and things
209:25 - like that let's do that so we will
209:27 - create a bunch of buttons here and I
209:31 - also put in the connections to be able
209:33 - to connect to the slots directly to save
209:35 - on some time once we have this we will
209:38 - add these buttons to our layout so let's
209:41 - do that we will say video add widget add
209:46 - widget should type that button add item
209:49 - this is the thing we can copy this
209:53 - shift out down to copy the line the
209:56 - other is going to be button delete item
209:58 - let's do that delete item
210:01 - we can copy again line that's going to
210:05 - be button item count button item count
210:08 - and the last one is going to be button
210:11 - selected items and once we have this we
210:13 - should see our buttons in the user
210:16 - interface let's see if we actually see
210:18 - them view terminal run the application
210:22 - and the button add item clicked connect
210:24 - itself add item what is going on here we
210:28 - don't have the the method
210:30 - implementations for the slots we are
210:32 - connecting to our signals so I think it
210:34 - is a good time to add them here so what
210:37 - we can do we can come down to the bottom
210:39 - and I think it is a good idea to
210:42 - actually separate this method
210:43 - definitions okay so let's do that this
210:46 - one is going to be triggered when we
210:48 - want to add a new item and you can see
210:50 - how we are adding a new item we are just
210:52 - calling the add item on our list widget
210:55 - component if we wanted to get the item
210:57 - count we call the count method on our
210:59 - list widget if we want to delete delete
211:01 - an item okay we will call the take item
211:05 - method on our list widget and we will
211:08 - give it the character row okay and this
211:11 - is going to remove the currently
211:13 - selected item this is how we are doing
211:15 - these things here if you want you can
211:18 - Loop through all the selected items and
211:20 - you get a list of selected items by
211:22 - calling the selected items method and
211:24 - you can Loop through this list printing
211:26 - each item's text this is how we do this
211:29 - so let's try and run the application now
211:32 - we can clear and run now the application
211:36 - is going to come up okay if we add item
211:39 - you see we are adding a new item this
211:41 - guy is going to be triggered let me make
211:44 - sure you can see this if we click delete
211:48 - item this is going to delete the
211:50 - currently selected item let's make sure
211:52 - the currently selected item is 2 here if
211:56 - we delete two is going to go away if we
211:59 - click one is going to go away and if we
212:02 - delete new item is going to go away and
212:05 - you see that we have a problem because
212:07 - now current item changed is not going to
212:10 - find the current item to print so this
212:13 - is a problem you might want to fix but
212:16 - we're not going to handle errors here
212:17 - you can handle them in whatever way you
212:20 - usually handle errors in your python
212:22 - applications this is really all I had to
212:25 - share in this lecture showing you how to
212:27 - use the list widget component you can
212:30 - use it if you want to show a list of
212:32 - items in your widget applications and
212:35 - you can check the documentation to see
212:37 - more things you can even do then I had a
212:40 - chance to tell you about in this lecture
212:42 - here I am going to stop here in this
212:44 - lecture and I will see you in the next
212:46 - one in this lecture we are going to look
212:48 - at the queue tab widget component this
212:52 - is a component that allows you to set up
212:54 - a user interface like this in which you
212:56 - have multiple parts of your user
212:59 - interface that you want to tell go
213:02 - through for example here we have the
213:04 - same widget shown in two states the
213:08 - first report is going to show this
213:09 - information here the second part is
213:11 - going to show these buttons but you can
213:13 - toggle between these by clicking on
213:15 - these titles here so if you click on
213:17 - information it is going to show this
213:19 - little widget if you click on buttons it
213:22 - is going to toggle to the state down
213:24 - here and you are able to toggle between
213:26 - different parts of your user interface
213:29 - this is good if you want to set up
213:31 - settings for your application for
213:33 - example and there are many uses for this
213:36 - kind of widget we are going to see how
213:38 - to set it up in your QT applications and
213:41 - we will see how to add tabs and how to
213:43 - use components inside separate tabs the
213:47 - first step to working with this is to
213:49 - create an instance of it in your python
213:52 - application so that's what we have right
213:55 - here
213:56 - and after that we will create our sub
213:58 - widgets if I can call them like that the
214:01 - first one is going to show information
214:02 - it's going to be an instance of Q widget
214:05 - and we will put things inside okay so we
214:08 - have a level and we have a line edit and
214:12 - we will set up a layout that is going to
214:14 - be containing this level and the line
214:16 - edit as we do here and we will apply the
214:19 - layout to our widget here we also set up
214:22 - a bunch of buttons so button one through
214:24 - button three We'll add the buttons to
214:27 - the layout and we set to the layout to
214:30 - the widget here once we have these sub
214:34 - widgets we will add them to our tab
214:38 - widget by calling the add tab method as
214:42 - you see right here once we do that we
214:45 - will specify the widget we want to add
214:47 - and the title information for that
214:50 - widget once we do that we will set up a
214:53 - layout that is going to apply to our
214:55 - container widget and we apply the layout
214:58 - to our widget here and once we finish
215:01 - this setup we can run the application
215:03 - and we will see something like this
215:05 - pop-up now that we notice we can head
215:07 - over to visual studio code and actually
215:09 - do this okay here we are in our Visual
215:13 - Studio code editor the project is going
215:15 - to be leaving in this folder here 12 Hue
215:18 - tab widget you can drag it and drop it
215:21 - on top of Visual Studio code here the
215:23 - first thing we want to do is to create
215:25 - our files so that's going to be
215:28 - mainly.py and the other one is going to
215:30 - be widget.py let's do that we can go in
215:34 - our widget and set up our starter code
215:36 - for the class it's going to be
215:38 - inheriting from Q widget as usual make
215:41 - sure you see the Imports we have here so
215:44 - these are the things we're going to be
215:45 - needing once we have this and we can go
215:48 - to our main file and put in our starter
215:51 - code if you don't want to type this code
215:53 - you can copy from the resource section
215:55 - of the lecture you're going to find the
215:57 - code here you can even download from
215:59 - GitHub if you want to have all the code
216:02 - for the course in one place on your
216:04 - local drive you can use the course
216:06 - however you see fit let's go to terminal
216:09 - and run this and we can run the main
216:12 - file and this is going to give us an
216:14 - empty widget on top of which we can
216:17 - start setting up our qtab widget before
216:19 - we even do anything I think it is a good
216:21 - idea to go to the documentation and look
216:24 - for q-tab widget Q tab widget so we can
216:29 - open it for a cute for python here and
216:32 - if you go to more you're going to read
216:34 - all you can about this okay so make sure
216:38 - you read this if it is the first time
216:39 - you use this component here you can see
216:42 - it has a bunch of signals it has a bunch
216:44 - of thoughts you can really do all kinds
216:45 - of crazy things let's come back to our
216:48 - project here in our widget file and we
216:51 - will set up our tab widget so let's do
216:53 - tab widget equals Q tablet and we will
216:57 - pass a current after that we will set up
216:59 - our sub widgets just like we showed in
217:02 - the slide so I am just going to put in
217:04 - the code here first one is going to be
217:06 - information which is going to take the
217:09 - full name of a person and we will store
217:11 - that in the memory of our application
217:13 - after we have the components set up we
217:16 - are going to add them to a layout that
217:19 - we will then apply to our widget here
217:21 - this is going to set up our widget here
217:24 - we will set up another sub widget which
217:26 - is going to be a widget containing a
217:28 - bunch of buttons one two and three here
217:31 - we are just connecting to the button to
217:33 - show you that you can respond to this
217:35 - clicked signal from this button and once
217:38 - we have these guys we can add them to
217:41 - our tab widget so let's go down and do
217:44 - that we are going to say add tabs to
217:47 - widget and we will say tab with it add
217:50 - tab we can do that you see that you can
217:52 - really add a lot of things you can even
217:54 - add action if you want to you know what
217:56 - this method does please use the
217:58 - documentation for now we will just add
218:01 - the tab and the first one
218:03 - is going to be widget form let's do that
218:07 - and the text is going to be information
218:09 - we will add another one tap widget add
218:13 - Tab and that's going to be widget
218:16 - buttons and we can say buttons here you
218:19 - can really put in whatever text you want
218:20 - so why do we have this squiggle here it
218:24 - must be Visual Studio code getting
218:26 - confused now that we have this we will
218:28 - actually set up the layout let's do that
218:31 - so layout equals QV box layout it's
218:35 - going to be a vertical layout because
218:37 - that's what I prefer we will add the
218:39 - things to the layout and what we add is
218:42 - going to be we need to put a comma here
218:45 - okay let's make sure we do that
218:48 - and we put in a closing double coot now
218:53 - we can do add widget and add our tab
218:57 - widget once we do that we will set the
218:59 - layout to be used by our entire widget
219:01 - here so self set layout and that's going
219:04 - to be our layout here if we have this
219:07 - and run the application we should see
219:09 - our tab widget let's make sure we view
219:12 - our terminal and to make sure we can run
219:15 - this but before we do I know a problem
219:17 - we're going to have we have a connection
219:19 - to a slot which we don't have defined
219:22 - yet so let's go down and do that before
219:24 - we actually try to run So Def we Define
219:28 - the slot it's going to be a member and
219:31 - in the slot we print button clicked we
219:34 - can do that now we can actually try to
219:37 - run the application the code is going to
219:38 - auto save now you see we have our tab
219:41 - widget exactly like we saw
219:43 - in the slides you can resize this if we
219:47 - want this is going to be the minimum
219:49 - size by default we can type in something
219:52 - the first let's say John snow or we can
219:56 - change to the other thing click on
219:57 - button one you see our slot is
220:00 - responding if you want you can also
220:01 - connect to these other buttons but again
220:04 - the main point is to show you how to use
220:06 - qtap widget in your QT applications and
220:10 - this concludes what I had to share in
220:13 - this lecture I hope you found it
220:14 - interesting I will see you in the next
220:16 - one in this lecture we are going to look
220:19 - at the Q combo box component this is a
220:22 - component that allows for the user to
220:25 - choose between a selection of items and
220:29 - it is easier to show it than to talk
220:32 - about it so the component looks like
220:34 - this when you click on this little icon
220:36 - this is going to pop up allowing the
220:39 - user to choose something and if they
220:41 - choose something that's going to be the
220:43 - current item in the combo box here this
220:47 - is how you use it you can get to the
220:49 - camera diagram and use the data to do
220:51 - things in your QT application let's see
220:54 - how you can set it up and here is the
220:57 - code you created by using cucumber box
221:00 - just like we do for other components
221:02 - this is going to give us a variable that
221:04 - we can work with in our application once
221:07 - you have the variable you can use it to
221:09 - add items to the combo box and these are
221:12 - going to be the set of things the user
221:15 - can choose through we will use a bunch
221:19 - of buttons to play with combo box for
221:23 - example we can get to the current value
221:25 - we can set a new value to the combo box
221:28 - we will see how to do that and this is
221:31 - really going to set the current value
221:33 - and we will get the values in our combo
221:36 - box we can do things like this and down
221:38 - below we have a bunch of buttons that
221:40 - are going to help us use this and let's
221:43 - take a look at the slots that we will be
221:45 - using to get to the current value we
221:47 - will be calling the current text method
221:50 - and we can also call the method to get
221:53 - the current index if you need that in
221:56 - your QT application we can also set to
221:59 - the current item by passing in the index
222:01 - so we will say the current item is the
222:04 - second item in the list or the item that
222:07 - is at index 2 and because indexes start
222:10 - at zero this is going to be the third
222:12 - item in the list you need to be careful
222:15 - about this if you want you can even get
222:18 - all the values in your combo box and
222:21 - here we set up a simple Loop to Loop
222:23 - through the items printed each item at
222:26 - an even index in your combo box now that
222:29 - you know this we can head over to visual
222:31 - studio code and actually play with us
222:33 - here we are in our working folder the
222:36 - current project is Q combo box you can
222:38 - see that it is empty here let's drag it
222:41 - and drop it on top of Visual Studio code
222:43 - and we will create the files that we
222:45 - need we have main.py the python file the
222:50 - main python file and we have widget Dot
222:52 - py and we will put in our starter code
222:55 - we can also go in the main python file
222:59 - and put in our main code and once we do
223:02 - that we can bring up our terminal window
223:04 - and try to run the application to see if
223:07 - we see our trusty empty widget here we
223:10 - have it let's go back to widget here and
223:14 - we will go down and set up our combo box
223:16 - it is really nothing special you already
223:19 - know how to do that from the slides so
223:21 - we will create create our combobox
223:23 - component we are using self here because
223:26 - we want it to be a member of this class
223:28 - and that's going to give us the ability
223:30 - to call it from methods because we are
223:33 - using a bunch of methods here that are
223:35 - going to be manipulating our combo box
223:37 - so let's do that we have our thing here
223:40 - okay now we have the combo box we have
223:43 - a bunch of buttons that we can use to
223:46 - manipulate the combobox now we want to
223:48 - lay things out so we will set up a
223:50 - layout and use that layout on this
223:53 - widget here let's go down and do that we
223:56 - will use a vertical layout as we always
223:58 - do let's align this properly so we will
224:02 - have our vertical layout we will add our
224:04 - combo box we will add our buttons and we
224:08 - will set this layout as the layout for
224:10 - the current widget let's run and see
224:13 - view terminal like we always do if we
224:16 - run we should see our thing here and now
224:20 - you can look at what a combobox says it
224:22 - is this thing on top which says Earth if
224:25 - we click on this down error we will have
224:27 - an option to choose one of the planets
224:30 - here for example we can choose Mars but
224:33 - we can also use these buttons to
224:34 - manipulate things in our combo box on
224:37 - top here let's put in the methods and I
224:40 - am going to explain them one by one
224:42 - because now you are a master at using QT
224:45 - so many of these things I don't need to
224:48 - explain line by line by typing each one
224:51 - so let's go down and put in our methods
224:54 - the first method is going to be getting
224:56 - the current value and it is going to be
224:58 - using a bunch of methods on the Q combo
225:01 - box class let's go to the documentation
225:03 - and actually show you the documentation
225:06 - for this
225:07 - I really encourage you to use the
225:09 - documentation as much as you can kill
225:12 - combo box
225:13 - and we open this up you can read more
225:16 - you can see the methods the slots the
225:19 - signals you can use to play with us you
225:22 - can really do all kinds of crazy things
225:23 - let's come back to our project so you
225:27 - can look at current text and current
225:29 - index we will use the Set current index
225:32 - method to set the current index and we
225:35 - can Loop through the values in our combo
225:37 - box printing the text and the current
225:39 - index we might be at in our Loop let's
225:43 - view terminal and run the application to
225:46 - see this running we will see our user
225:49 - interface here and if we get the current
225:52 - value and you see that the current value
225:55 - is Earth we can select Mars for example
225:59 - if we print current value it's going to
226:02 - say Mars at index 2 we can select proton
226:06 - if we get current value it's going to
226:08 - say the current value and the index and
226:10 - we are able to do that because of the
226:12 - current value method we have set up here
226:14 - we can set the current value to be
226:17 - something at index 2 and that's going to
226:19 - be Mars if we get to the current value
226:21 - we're going to get Mars we can print all
226:24 - the values we have in our ascent and the
226:26 - indexes and this is working exactly as
226:29 - we want this is really all I had to
226:31 - share in this lecture I hope you found
226:33 - it interesting we are going to stop here
226:35 - in this one and I will see you next time
226:38 - in this lecture we're going to see a way
226:40 - you can design layouts and user
226:43 - interfaces without hard coding them in
226:47 - your python code like we have been doing
226:49 - so far and we will be using QT designer
226:52 - QT designer is a tool that allows us to
226:55 - build user interfaces just by dragging
226:58 - and dropping components and that's going
227:00 - to give us a cool user interface we can
227:02 - just Import in our python code and use
227:05 - it right away the user interface is
227:07 - going to look something like this this
227:10 - is just a simple introduction we will
227:12 - have time to install this tool and see
227:14 - how to use it but you can see the idea
227:17 - here for example to set up this button I
227:19 - did here all I had to do was to drag and
227:22 - drop this UI component on my formula
227:25 - here and that's going to give me a
227:27 - format you can use and you can see we
227:29 - can do all kinds of crazy things on top
227:31 - here you can see we can do a bunch of
227:33 - layouts we can really build all kinds of
227:36 - crazy interfaces using cute designer so
227:40 - this chapter is going to be about using
227:42 - cute designer we will see how to install
227:43 - it we will see how to create these UI
227:46 - files and we will see different ways we
227:48 - have to import this user interface files
227:51 - into our PI site 6 applications and
227:55 - that's going to be really cool once you
227:57 - design your UI files what you will get
227:59 - out of QT designer is a DOT UI file and
228:04 - it is this kind of file that we will be
228:06 - importing in our PI side application one
228:09 - thing you should know is that we have
228:11 - two way to get access to QT designer you
228:13 - can use the QT designer application that
228:16 - comes bundled into your QT installation
228:19 - or you can use cutecreator one thing I
228:22 - have to say which is a bit inconvenient
228:24 - is that we don't have immediate access
228:26 - to these tools when we install Pi side
228:29 - like we have done so far so what we will
228:32 - do in this lecture is install QT which
228:35 - is going to give us access to the these
228:39 - design tools we will install the C plus
228:42 - plus side of QT that's what we are going
228:44 - to install here and that's going to give
228:46 - us access to QT designer and cute
228:48 - Creator to install QT all you have to do
228:51 - is come to your browser and say QT
228:53 - download that's going to give you a
228:56 - length looking something like this let's
228:57 - open it okay once you are at the QT
229:00 - website you can see we are at qtio slash
229:04 - download once you are here you will
229:06 - click on download try and on this page
229:10 - here we can scroll all the way to the
229:12 - bottom and say download for open source
229:15 - users because we are just interested in
229:18 - the open source version of QT so click
229:21 - on go open source here and once you are
229:23 - on this page you will scroll all the way
229:25 - to the bottom where it says download the
229:29 - QT online installer and you will click
229:31 - on this button they are probably going
229:33 - to detect your operating system once
229:35 - they do you will come all the way to
229:38 - this the location here and hit download
229:40 - and this should start to download in the
229:43 - QT for you here you can see that it is
229:46 - downloading from me but I already have
229:47 - this so all you need to do is to wait
229:50 - for this to download open this file and
229:53 - let it install QT once you have that
229:56 - file downloaded you will double click on
229:58 - it or click on it to start installing QT
230:00 - once you do that you will get a user
230:03 - interface like this asking you to login
230:07 - so if you don't have an account you will
230:10 - create it once you have your account and
230:12 - your credentials you will just hit next
230:14 - here and you will go through a series of
230:17 - steps helping you install QT one thing I
230:20 - should say is that if you get a list of
230:22 - options telling you what you should
230:24 - install make sure you click on custom
230:26 - installation that's going to land you
230:29 - where we are about to go in a minute I
230:32 - can't really show you the exact steps
230:34 - because I already have QT installed on
230:36 - my system here so I am going to do the
230:38 - best I I can to guide you through this
230:40 - but if you choose custom installation
230:42 - and then hit next you are going to land
230:45 - in a place like this once you are here I
230:48 - want you to click on QT and if you click
230:51 - on that you are going to get a series of
230:53 - options make sure you choose the latest
230:55 - version the latest version at the time
230:58 - of this recording is
231:00 - qt640 as you see here that's what I am
231:03 - going to choose I am going to expand
231:05 - that and I am showing you the steps here
231:07 - for Windows and they are going to be
231:09 - similar for Linux and Mac once you are
231:13 - here on Windows you can either choose
231:15 - minty W here or msvc I do recommend
231:19 - using minty W because it is hassle free
231:21 - it's going to be easier to install this
231:23 - if you use msvc here you will need to
231:26 - have the Microsoft Visual Studio IDE
231:29 - installed so if you don't want the
231:31 - visual studio thing just use mintyw here
231:34 - it is going to give you everything you
231:36 - need if you are on Linux you are
231:38 - probably going to see a GCC version here
231:41 - if you are on a Mac you are going to see
231:43 - something saying clang or whatever so
231:46 - make sure you check one just like I have
231:49 - minty W checked here and you are going
231:51 - to click on this button that says next
231:53 - door install or something once you do
231:55 - that you will keep hitting next until
231:57 - you start installing you will age for QT
232:00 - to be installed and at the end you will
232:02 - have a QT installation on your system
232:05 - one thing I should say is that mine is
232:08 - installed in cqt which is going to be
232:11 - the default suggested by QT so after you
232:14 - install QT you will have a cutie folder
232:16 - in your C drive or wherever you
232:20 - instructed the installer to install your
232:23 - QT files on your system okay once you
232:26 - have it installed on your start menu you
232:28 - will have an option to start QT creator
232:31 - you can see I can start it here let's
232:34 - start it to show you how it looks
232:36 - okay this is how QT Creator is going to
232:39 - look if you start it up you can do all
232:41 - kinds of crazy things but at this moment
232:43 - we are interested in using QT designer
232:46 - which is bundled into QT Creator if you
232:50 - start QT designer we also have the
232:52 - option to start it let's say designer
232:54 - and if we do we will have designer
232:56 - whatever the version you have installed
232:59 - so if we started we will have it pop up
233:02 - on our screen and we can start using it
233:04 - and this concludes what we set out to do
233:07 - in this lecture here introducing cute
233:09 - designer and showing you different ways
233:12 - you can have access to it you can either
233:14 - use QT designer or QT Creator and we
233:17 - were able to get access to these things
233:20 - by installing QT just like we did in
233:23 - this lecture here we are going to stop
233:25 - here in this lecture and I will see you
233:27 - in the next one in this lecture we are
233:30 - going to see how to work with QT
233:32 - designer and we have access to this
233:34 - because we installed qt in the last
233:37 - lecture which gave us access to either
233:39 - QT designer or acutecreator what we will
233:42 - be doing in this lecture is to try and
233:45 - create a user interface like this it's a
233:47 - simple form allowing the user to type in
233:49 - their full name and occupation once they
233:52 - do that they can click on the submit
233:54 - button and we can grab all this
233:55 - information and use that in our python
233:59 - application or a pi side application
234:01 - whatever you might want to call and once
234:04 - you have this information you can use
234:05 - that in your Pi side application so
234:09 - let's start the QT designer to start it
234:11 - you come to your starter menu whatever
234:13 - start menu you have on your operating
234:16 - system we can type QT for designer I
234:20 - think that's going to give us access to
234:21 - this once you start it it should show up
234:24 - like this it is going to show you a
234:26 - window that lets you create a form we
234:30 - may choose not to use this because I
234:31 - wanted to show you around so I am going
234:33 - to click close on that and what I want
234:37 - you to see is that we will be storing
234:39 - our files into this folder in our source
234:41 - code saying using QT designer so make
234:45 - sure you have a location where you will
234:47 - save your user interface files and to
234:49 - create a new form all you have to do is
234:52 - come to file new and you see this is
234:55 - going to give us back that user
234:58 - interface we had so let's see the
235:00 - options we have down here so we can
235:04 - create a dialog with buttons at the
235:07 - bottom we can create a dialog with
235:09 - buttons to the right we can create a
235:12 - dialog without buttons or we can create
235:14 - a main window or a widget you can see
235:17 - that we can create a lot of things I
235:19 - think I am going to go for the dialogue
235:21 - without buttons because we will be
235:24 - putting in our own button remember the
235:26 - design we are going after it is
235:28 - something like this so this is just
235:32 - going to be an empty form a dialog
235:35 - without buttons on top of which we will
235:37 - be building our own user interface let's
235:39 - come back to designer okay we're going
235:42 - to choose this so let's click create
235:46 - Metro you have dialog without buttons
235:49 - selected here and you will click on
235:52 - create here so let's come back it's
235:55 - going in our dialogue without buttons
235:56 - create this is going to create our file
235:59 - and once you have this thing created
236:02 - uh we don't want to create a dialogue
236:05 - for what we want because if you go back
236:07 - to our user interface here this is not a
236:11 - dialogue really we want this to be some
236:13 - kind of widget so let's go back and make
236:16 - sure we create a widget because it is
236:17 - important which class you start by so
236:20 - let's discard the changes that we had
236:22 - and we want to create the widget sorry
236:24 - for that make sure you create a widget
236:26 - here and come back here and say create
236:28 - that's going to give you a widget and
236:31 - one thing that is really important when
236:33 - you create your user interface files
236:35 - like this is to remember the object name
236:39 - for your top level widget here and in
236:43 - this case you can see that it it is
236:45 - called the form we want to go back and
236:48 - call this widget
236:50 - just like I did here make sure you name
236:54 - yours with it and we can start doing our
236:56 - thing if you remember we have a bunch of
236:59 - levels and line edits in our user
237:01 - interface that we are after here you can
237:04 - see that the thing we have on the left
237:06 - here is a level and this thing is a line
237:09 - edit and it is the same on the second
237:12 - line here and this is a button let's
237:14 - make sure we add these things into our
237:16 - designer user interface if you want to
237:19 - search for a component you can type the
237:21 - name here we are looking for a label so
237:24 - you see if we type a lip here we're
237:26 - going to get level you can drag two
237:28 - levels because they think we just need
237:30 - the two you can close here by clicking
237:33 - on the X that's to the right of this
237:35 - component here and down below we can
237:38 - grab the button and put it on our user
237:41 - interface we also need a line edit
237:44 - let's type line edit and you see we have
237:46 - it right here we can drag one here and
237:49 - we can drag another one here and we have
237:52 - everything we need in our user interface
237:54 - we can name these things so let's say
237:56 - full name okay we can type in whatever
237:59 - we want and the other one is going to
238:02 - say occupation
238:03 - if I remember correctly down here we are
238:07 - going to say submit in the text and I am
238:10 - just double clicking in these components
238:12 - to have the ability to type text so
238:15 - nothing really complicated here and now
238:17 - that I have my components here the next
238:20 - important thing is to name the
238:23 - components that I think I will be using
238:25 - on the python side of my application
238:27 - here and I will be using these line
238:30 - edits and the submit button so the user
238:33 - will be able to type text in here and I
238:35 - want to be able to grab that text on the
238:37 - python side and I want to know when the
238:39 - user clicks on this submit button here
238:42 - so let's name our thanks I am going to
238:44 - click on either of these and come to
238:46 - object name in my properties to the
238:49 - right here so this one is going to be
238:52 - named full name
238:54 - line edit okay so the other one is going
238:58 - to be occupation line added
239:01 - and the other thing I need to name is my
239:04 - submit button okay make sure you
239:06 - remember these names and at any point
239:08 - you can open this file here and look at
239:11 - this if you click you're going to see
239:13 - the object name to the right in the
239:15 - Tuple here so you can see your object
239:17 - name here if we click the other one we
239:20 - can see our object name right here if we
239:24 - click on the button we can see our
239:27 - object name right here and as I said
239:29 - before make sure you name your top level
239:33 - widget in this case it is named widget
239:35 - here and this is going to be important
239:37 - when we get to the point where we load
239:40 - this on our python side so this is
239:42 - really important once we have this user
239:45 - interface I think we need to put in a
239:47 - bunch of layouts and it is really easy
239:50 - to use layouts from QT designer for
239:52 - example we wanted the full name and the
239:54 - line edit here to be laid out
239:56 - horizontally so we can click on full
239:59 - name and our line edit while having
240:01 - control selected so we can select them
240:04 - all all or we can even click and drag
240:08 - and make sure we have them selected here
240:10 - we can do something like this once you
240:12 - have them selected you can come to the
240:14 - top here where you have these buttons
240:16 - the first one is going to help you lay
240:19 - things out horizontally the second one
240:21 - is going to help you lay things out
240:23 - vertically we want to lay out
240:25 - horizontally so we can hover over this
240:27 - button you see it says layout
240:29 - horizontally if we click on it these
240:31 - guys are going to be aligned
240:33 - horizontally in a layout we are going to
240:36 - do the same for occupation and the line
240:38 - edit to the right of that we are going
240:41 - to put them in a horizontal layout and
240:43 - we want to click on the form here and
240:46 - lay everything out vertically because
240:49 - that's the user interface we are after
240:51 - so click somewhere empty on the form
240:53 - come to the button that says layout
240:56 - vertically if you click on it things are
240:59 - going to be laid out vertically and we
241:01 - can resize our user interface to make it
241:03 - really look nice here I think this is
241:06 - good and we have our user interface so
241:09 - you can come to file and save it and you
241:12 - are going to choose the location where
241:13 - you want to save yours okay this is
241:16 - where we want to save our file we will
241:19 - give it a name let's name it widget
241:23 - dot UI we can do something like this and
241:26 - if we save it is going to be saved and
241:28 - we are done with our design of our user
241:32 - interface here okay now that we are done
241:34 - with this we are going to head over in
241:36 - the next lecture and show you how you
241:37 - can do the same from QT Creator and
241:40 - after that we will worry about importing
241:44 - this user interface for use in your Pi
241:47 - side application that's going to be
241:49 - really cool so I will see you in this
241:51 - lecture
241:52 - in this lecture we are going to look at
241:54 - how we can load our user interface files
241:57 - into a python application there are
242:00 - different ways to do this as I mentioned
242:03 - in a previous lecture probably but we
242:05 - will be looking at a class called Q UI
242:08 - loader which helps us do that let's go
242:11 - to the documentation and actually see
242:13 - what this class does you can come to
242:15 - your research engine and say hi site
242:18 - sucks loader
242:23 - if I can type today this is going to
242:25 - give us a link we can click on and if we
242:28 - go there we're going to learn or we can
242:30 - about this class here they show a little
242:32 - example of how you can use this we will
242:35 - be running a version of this example in
242:38 - our PI side application but make sure
242:40 - you read about this class to know what
242:43 - it does let's come back to the slides
242:45 - and really look at how to use this
242:49 - so to use this class you have to make
242:51 - sure you have imported Qui loader like
242:55 - we are doing here once you do that you
242:57 - will create a loader object just like we
243:00 - do here once you have a loader object
243:02 - all you have to do to load your UI file
243:06 - is to call the load method just like we
243:09 - are doing here so the first parameter is
243:11 - going to be your UI file and what this
243:15 - says is that in this example here we
243:17 - will be putting our python file in the
243:20 - same location as our user interface file
243:23 - if your user interface file lives in
243:26 - another folder you will have to tell
243:28 - your python file to go to that location
243:30 - and find the UI file that's something
243:33 - you need to know and once we call the
243:35 - load method here we will get a widget
243:37 - that we can then use in our application
243:40 - like we use any other widget another
243:43 - thing worth mentioning is that to access
243:45 - things into our UI file we we will be
243:50 - using the notation here notice that we
243:53 - are saying full name line edit because
243:55 - it is the name we used in our UI file
243:58 - remember the object name that's the name
244:01 - you have to use here and then we say dot
244:04 - and access properties of this UI
244:06 - component you see we are doing the same
244:08 - for our occupation line edit to access
244:11 - the text another thing we can do is
244:13 - connect slots to signals coming from the
244:17 - user interface for example here you see
244:19 - that we are saying whenever somebody
244:22 - clicks on the submit button in our
244:24 - window object we want to respond in our
244:28 - do something slot that we have defined
244:31 - on top here and once you have this you
244:34 - will show the window you will call the
244:36 - exact method to kick off the event Loop
244:38 - and your application is going to show up
244:40 - and do things one thing I wanted to warn
244:43 - you about is that the loading that we
244:46 - are doing here is happening at runtime
244:49 - and what that means is that your
244:52 - application will be paying a performance
244:54 - penalty every time the user runs your
244:57 - application that's why I am really not
245:00 - in favor of using Q UI loader to load
245:03 - your user interface files because the
245:06 - penalty is going to be on your users and
245:08 - you will be wasting their time there is
245:10 - a better way to do this and I will show
245:12 - that in the next few lectures but for
245:14 - now you need to be aware of Q UI loader
245:17 - I think Q UI loader can be useful if you
245:21 - are prototyping and things like that but
245:23 - in a production application you
245:25 - shouldn't really use this at least
245:27 - that's my opinion here okay make sure
245:30 - that you know that q u i loader is going
245:33 - to make your users pay the price every
245:36 - time the application runs now that you
245:38 - notice we are going to head over a 2o
245:40 - editor and play with us a little more
245:42 - okay here we are in our editor which is
245:45 - Visual Studio code this is the folder
245:48 - where we will be doing our things here
245:51 - the first thing I want you to do is to
245:53 - make sure that I put my UI file in this
245:57 - project here we can either use the one
245:59 - from QT designer or QT Creator let's
246:01 - grab the one from QT creator doesn't
246:03 - really make a difference they are the
246:05 - same so I am going to put in my UI file
246:08 - and once I do that I will open this
246:11 - project in Visual Studio code let's do
246:13 - that okay the project is opened you can
246:15 - see that we have our UI file what we
246:18 - want to do is to create our main Pi file
246:21 - first thing we want to do is to make
246:23 - sure we import the components we need
246:25 - and we import cute widgets because we
246:28 - will be using the widget that q u i
246:31 - loader is going to load we create our
246:33 - daughter object nothing special here
246:35 - next we go down and create our
246:37 - application instance so it's going to be
246:40 - a queue application object that we call
246:42 - app here we will have a widget or a
246:46 - window that we get by loading our our
246:49 - user interface file it is not called
246:52 - user data UI it is called the widget.ui
246:55 - so let's make sure we correct this a
246:58 - little bit once we call the load method
247:00 - this is going to give us a widget that
247:02 - we can manipulate in our application
247:04 - here we can go down and Define the
247:08 - function that is going to respond when
247:11 - the user manipulates things in a user
247:13 - interface so this is a do something
247:15 - function again it is going through our
247:18 - window object to access the components
247:21 - we have in our designer form let's make
247:25 - sure we open designer because ah we
247:28 - still have this opened in QT Creator so
247:31 - if we go to the line edit again you can
247:34 - come to the object name here and see the
247:37 - object name this is what we will be
247:39 - accessing from our python application so
247:42 - let's make sure we know that let's close
247:45 - out of QT Creator here and we are
247:47 - setting up our window type title on our
247:50 - window object and hopefully this proves
247:52 - that this is a real widget that we can
247:55 - manipulate like we have been
247:56 - manipulating the widgets that we have
247:59 - created ourselves and this is really
248:01 - cool okay let's go down and finish this
248:03 - up we will connect and respond when the
248:07 - submit button is clicked then we will
248:09 - show our widget here and kick off the
248:12 - event Loop so the real meat of this is
248:16 - where we create our daughter object this
248:19 - is how you create it and the other thing
248:21 - is where we load our widget UI file and
248:26 - that's the line here what we call the
248:28 - load method we will be getting a window
248:29 - object which is really a widget and we
248:32 - can do things we are used to do on other
248:35 - widgets for example we can set window
248:38 - title we can access things using the dot
248:41 - notation like we do here and this is
248:43 - really cool now that we have this we can
248:45 - actually try and run the application
248:47 - here let's show a a terminal window like
248:50 - we always do hopefully this is going to
248:52 - work it's not going to blow up in our
248:54 - face
248:55 - fingers crossed and we can go up and try
248:58 - to run our python file and look at this
249:01 - look at what we have here full name
249:03 - occupation let's put in Daniel
249:06 - gray for our full name occupation let's
249:10 - say I am a farmer and if I hit submit
249:14 - Daniel gray is a farmer let's say I am a
249:17 - plumber
249:19 - Daniel gray is a plumber and this is
249:21 - really cool we are able to use our UI
249:25 - file from our python file but again
249:27 - every time the user runs the application
249:30 - notice what's going to happen you know
249:33 - this widget UI file is going to be
249:35 - transformed into Python and the python
249:37 - is going to be loaded into this file
249:39 - here all of that Machinery is going to
249:41 - be really going on when your application
249:44 - runs and this is going to make your
249:46 - users pay a performance penalty whenever
249:49 - they run your application so this is
249:51 - really not good but you need to be aware
249:53 - of this in case you have a logical use
249:57 - case for this this is really all I had
249:59 - to share in this lecture I hope you
250:00 - found it useful before I go make sure
250:03 - you remember your object names it is
250:06 - through these object names you go to
250:09 - access components from your UI file in
250:11 - your python application here this is
250:13 - really cool in the next lecture we will
250:15 - try to reorganize this code in a
250:18 - separate file to make it really easy to
250:20 - manage and play with this a little more
250:22 - so I will see you in the next lecture in
250:25 - this lecture we are going to reorganize
250:28 - our code using Q UI loader and Export
250:32 - that into a separate class so that our
250:34 - main python file is a bit cleaner we're
250:38 - not going to do anything special really
250:39 - it is the same thing we did in the last
250:42 - lecture but here is our loader object
250:44 - that we create in a separate file we
250:47 - will set up a class that we call user
250:49 - interface that is going to be inheriting
250:51 - Q object because we need to connect
250:54 - signals to slots that's why we need to
250:56 - do this and then in our Constructor we
251:00 - will be doing our loading we will set up
251:02 - a UI object that you see here which is a
251:05 - member of this class this is really
251:07 - going to be a widget that we get by
251:09 - calling the load method like we did in
251:11 - the last lecture once we do that we set
251:13 - our window title we do our connection to
251:16 - the button and we set up our slots that
251:18 - is going going to respond and this is
251:20 - really all we need to do here another
251:22 - thing is that we have a show method that
251:25 - we are going to call to make this user
251:28 - interface show up nothing special here
251:30 - once we have this class we will import
251:33 - it in our main python file you see we
251:36 - are creating an object of it like we do
251:38 - here and we are showing it and once we
251:41 - created the wire end to the actual UI
251:44 - file is going to be done in the
251:47 - Constructor by the time we call the show
251:49 - method here the entire window is going
251:52 - to be set up and we will see it pop up
251:54 - on our screen nothing really special
251:56 - here we are just reorganizing what we
251:58 - already had in the last lecture but
252:00 - let's head over to our editor and
252:02 - actually do this
252:04 - okay here we are in our editor we will
252:07 - be working in this folder here you can
252:09 - see that it is empty before we do let's
252:12 - head over to the lecture where we
252:13 - created our widget file and steal it and
252:17 - put a copy of that in our current folder
252:20 - here once we have this we will open this
252:22 - up in Visual Studio code and we will
252:25 - create our main python file so let's
252:28 - make sure we do that okay plus
252:32 - main.py we also need the user interface
252:35 - file let's say user interface
252:38 - dot py which is going to be doing the
252:41 - heavy lifting and bringing in our user
252:44 - interface file that we got from cute
252:47 - designer in this case I am just going to
252:50 - paste in the class because you already
252:52 - know most of these things we will be
252:54 - importing Qui loader once we have it
252:56 - imported we will go in our Constructor
252:59 - and load our user interface file in this
253:02 - case our user interface file is named
253:05 - widget.ui
253:08 - okay so make sure you correct this a
253:10 - little bit we will give it a window
253:12 - title we will make the connection to the
253:14 - button that is coming from our user
253:16 - interface file again we know it is named
253:19 - submit button because that's what we set
253:22 - up in our designer file so let's bring
253:25 - up designer because I think I really
253:28 - need to show you this okay let's close
253:30 - out of this and we will open our current
253:33 - location we go in we can drag our widget
253:36 - file and drop that on top of designer if
253:40 - we go to the submit button it's object
253:43 - name is submit button just like you see
253:47 - here it is this exact name that we have
253:50 - to load in our python file so this is
253:53 - submit button if we go back in designer
253:56 - submit button if you go to the full name
253:59 - line edit the object name is right here
254:02 - so if we come back to our file we should
254:06 - be using that exact object name in our
254:09 - file make sure you really follow this if
254:11 - you mess these names up you're going to
254:13 - be in for a lot of trouble now that we
254:16 - have this we can head over in our main
254:18 - python file so let's do that okay we can
254:22 - put in the code and we will be importing
254:25 - Pi site 6 and we will be importing our
254:28 - user interface class from our user
254:31 - interface file once we have all these in
254:34 - we create our application object we will
254:37 - create our window and it is going to be
254:39 - an object of our user interface class
254:40 - this line is going to trigger a call to
254:43 - the Constructor that we have here and
254:46 - the Constructor is going to be doing the
254:48 - heavy lifting to load our widget UI file
254:51 - and give us an object called UI that we
254:54 - can manipulate in our application here
254:56 - again the loading here is still
254:59 - happening at run time make sure you know
255:02 - this this is going to incur a
255:06 - performance penalty to your users and
255:08 - you don't really want to do that unless
255:10 - you have a really good reason to use
255:12 - this way of loading your user interface
255:15 - files now that we have this I think we
255:18 - can try to run the application and see
255:20 - how it behaves we can show our terminal
255:22 - and we can clear and if we run our
255:26 - python file we should see our thing here
255:29 - exactly like we did in the last lecture
255:32 - if we put in our full name
255:35 - and our occupation let's say we are
255:38 - farmers farmer submit we have farmer if
255:43 - we put in Plumber just like we did in
255:45 - the last lecture we will get to the same
255:47 - thing and this is really all we set out
255:49 - to do in this lecture now that you know
255:52 - how to use Q UI loader we will head over
255:54 - into that structure and show you how we
255:57 - can actually compile our user interface
256:00 - file into python code and that's going
256:02 - to really take the performance penalty
256:05 - and put that on you the developer so you
256:08 - will take your user interface files and
256:10 - turn them into python file and their
256:12 - users will be loading those python files
256:15 - when they run the application and that's
256:17 - going to be much better let's head over
256:19 - to the list lecture and do that in this
256:22 - lecture we are going to see how to
256:25 - compile our user interface files into
256:28 - python code that we can directly Import
256:30 - in our python project and the command to
256:34 - do that is really simple it is what you
256:36 - see here we have a tool that we have
256:38 - access to because we installed Pi site
256:41 - 6. the tool is called Pi side 6 Dash UIC
256:45 - once you call it you will give it your
256:48 - widget user interface file and you got
256:50 - this file from a designer or QT Creator
256:53 - you will put in this arrow and then you
256:56 - will specify the output file name and at
257:00 - the convention I like to use is to say
257:03 - UI Dash and say the name of the file
257:06 - that I got from designer or QT Creator
257:09 - so in this case it's going to be UI Dash
257:12 - widget dot Pi file and this is going to
257:15 - be the file that we get out of this user
257:20 - interface compiler you can say you IC
257:22 - stands for user interface combiner so if
257:25 - we run our designer file in UIC here we
257:29 - will get a file named exactly like this
257:32 - and this is a convention I use to make
257:34 - it easy for me to manage these files
257:37 - especially if you have a really big
257:39 - project it can be really hard to keep
257:41 - track of this so make sure you
257:43 - understand this naming convention once
257:46 - you understand it you can modify it to
257:48 - suit your own needs another thing I
257:50 - would like to warn you about is to
257:52 - remember the name of the top level
257:56 - widget you have in your user interface
257:57 - file in our case we named that widget
258:00 - exactly like this and when we do that
258:04 - the user interface compiler is going to
258:07 - generate a class that we can then load
258:10 - in our own python code and the
258:12 - conversion the UIC compiler uses is to
258:15 - say UI Dash widget this is going to be
258:18 - the name of the class and this is what
258:20 - we will try to manipulate populate in
258:22 - our own python code and make sure you
258:25 - really drill this in your brain because
258:27 - if you don't you are going to have
258:30 - mismatching names either in your user
258:32 - interface code or in your python code
258:34 - make sure these things match up another
258:37 - thing I noticed when using this in
258:39 - Visual Studio code is that the files
258:42 - that I get out of my user interface
258:45 - compiler were encoded in utf-16 and the
258:49 - visual studio code would not understand
258:51 - this I will show you how to bypass this
258:53 - but I just want you to be aware of this
258:56 - if you face this problem here and if you
258:58 - are using a different editors you might
259:01 - have to do research on how to get around
259:03 - these problems and again make sure you
259:06 - remember the convention we are using
259:08 - here the widget that UI file is going to
259:11 - be what we get from QT designer or QT
259:14 - Creator the design file once we pass
259:17 - that file into the user interface
259:19 - compiler we will get a you I Dash
259:23 - widget.py file this is a file generated
259:27 - by the user interface compiler you have
259:29 - no business manipulating it manually and
259:32 - our widget.py file is going to be our
259:36 - own class which is going to be trying to
259:39 - reuse code that was generated for us by
259:42 - the user interface compiler make sure
259:44 - you really understand this convention I
259:46 - will be going through this convention
259:48 - again when we hit Visual Studio code in
259:50 - a minute but I just want you to be aware
259:53 - of this once we have our file generated
259:55 - we will set up our own widget class like
259:59 - this and again this is just a simple
260:02 - widget we are creating this is our own
260:04 - class name it is going to be inheriting
260:07 - both Q widget and the UI widget UI
260:11 - widget is the class that the user
260:13 - interface compiler is going to generate
260:15 - from your UI file again this is going to
260:18 - work because our top level widget that
260:21 - contains our user interface is named
260:24 - widget let's go back to designer and
260:26 - actually show you that I think we still
260:28 - have designer opened if you manage to
260:32 - click around on the lobbying form here
260:34 - you will see that our object name is
260:38 - widget and the user interface compiler
260:41 - is going to pick this up and generate a
260:45 - class that is named UI widget and it is
260:48 - what we are trying to inherit from here
260:51 - I really want you to notice this if you
260:54 - have problems with us it might be really
260:56 - hard to debug so once we have inherited
260:58 - the correct class we will go in our
261:00 - Constructor and because we are
261:03 - inheriting from UI widget we have the
261:05 - things that UI widget has and those
261:08 - things are our submit button we can
261:11 - access it like this our full name line
261:13 - edit we can access it like this and our
261:16 - occupation line edit and we can access
261:18 - it like this again we know the object
261:21 - names because they are what we set up in
261:24 - our designer file let's make sure we
261:26 - open this in designer if we go to the
261:29 - full name line edit the object's name is
261:33 - right here if we go to the occupation
261:35 - line edit the object's name is right
261:39 - here if we go to the submit button the
261:42 - object name is going to be right here
261:45 - for everybody to see make sure you
261:47 - really know these things I don't want
261:49 - you to face problems if you went through
261:51 - this course to learn about Pi side 6.
261:54 - okay once we have events set up we will
261:57 - also set up our slot which is going to
261:59 - respond when the user clicks on our
262:01 - button and the connection is going to
262:03 - make sure that whenever somebody clicks
262:05 - on the button we will be called and this
262:07 - slot here nothing complicated so far and
262:10 - one benefit of doing this is that this
262:13 - is going to be making it easy for your
262:16 - users you went through the trouble to
262:18 - transform your user interface files into
262:21 - Python and the user is not going to be
262:23 - paying that price you the developer will
262:27 - be paying that price and it is really
262:29 - good because you develop your
262:31 - application once and your users will
262:33 - probably be running the application a
262:36 - thousand times or even a million times
262:38 - depending on how successful your
262:40 - application is so if you move the price
262:43 - at the developer time you will be really
262:46 - saving your users a lot of time with the
262:49 - Q UI loader every instance of your
262:51 - application that runs would pay that
262:53 - price but now we are paying that price
262:56 - once when we develop the application
262:58 - that's the benefit of doing things this
263:01 - way okay now that you know this we can
263:03 - head over to visual studio code and play
263:06 - with us a little more okay here we are
263:08 - in our project this is going to be our
263:12 - project folder here it is empty so what
263:15 - we need to do is to steal the UI file
263:18 - that we will be using for this demo here
263:21 - so let's put this in place and I think
263:23 - we can directly open this in Visual
263:26 - Studio code so let's drag this and drop
263:28 - on top of our editor here this is going
263:31 - to give us our project we need to create
263:33 - a few files remember our Diamond
263:35 - convention we need a python file which
263:38 - is going to be the main python file
263:40 - let's do that we will also need to set
263:44 - up a widget
263:46 - dot py file
263:48 - which is what is going to be important
263:51 - things generated by our user interface
263:54 - compiler now that we have the UI file
263:57 - the first thing we need to do is to
264:00 - compile it to python you already know
264:03 - the command because we saw it in our
264:05 - slides but I am going to show that again
264:07 - right here so let's show our terminal
264:10 - and make sure you see everything here
264:12 - let's clear I am going to paste it in
264:15 - the command but you can type it if you
264:17 - want the command says Pi side 6 Dash UIC
264:21 - after that we will specify the input
264:24 - file which is going to be our user
264:26 - interface file that we have here in our
264:29 - folder we will specify an angle bracket
264:32 - facing right this is how we use this
264:35 - tool and you can say the output file
264:39 - right here in our case it is going to be
264:42 - ui-widget.py once you have this typed in
264:45 - correctly you can hit enter the tool is
264:48 - going to go to work and it is going to
264:50 - generate a
264:53 - ui-widget.py file that you see generated
264:55 - here if you want you can even open this
264:58 - in Visual Studio code so let's make sure
265:00 - we click on it and you can see the
265:02 - things that are generated for you by the
265:05 - user interface compiler they say that
265:07 - this file was created by the cute user
265:09 - interface compiler this is the version
265:11 - they warn you that changes to this file
265:14 - may be lost to the next time in the user
265:16 - interface combiner is run but you can
265:19 - browse through it it is really a simple
265:21 - class it's just doing the heavy lifting
265:23 - of generating these layouts and things
265:26 - for you so that you don't have to worry
265:28 - about it if you go in you will see our
265:31 - object names for example you see full
265:33 - name line edit we see occupation line
265:36 - edit if we go down I think we will find
265:38 - our button and these are things we will
265:40 - be loading in our python code one thing
265:43 - I want you to notice though is that this
265:45 - was generated in a UTF F16 encoding
265:50 - Visual Studio code is using utf-8 if I
265:53 - try to run this I will be into problems
265:55 - so I will fix this in a minute when I
265:57 - show you the problem but I just want you
265:59 - to notice this here okay we have our UI
266:02 - widget Pi file again
266:05 - in a dynamic convention we are using
266:07 - files we name like valves are going to
266:10 - be what we get as output from the user
266:13 - interface compiler files we named like
266:16 - widget.py like this are going to be our
266:20 - own code that uses what we got from the
266:24 - user interface compiler make sure you
266:26 - really understand this and widgets that
266:28 - UI is going to be the file we got from
266:31 - UI designer I know this may be confusing
266:34 - but once you do this a couple of times
266:36 - this is going to become second nature
266:38 - let's set up our own widget Pi file and
266:42 - I am just going to paste that in here
266:44 - because I don't want to waste your time
266:46 - typing this it is going to be a class
266:49 - that inherits both Q widget and UI
266:52 - widget this is super important we set up
266:55 - our Constructor which is going to call
266:58 - the set UI method and this is a way QT
267:02 - provides to wire to the class that was
267:05 - generated for you you don't have to
267:07 - worry too much about this just make sure
267:09 - you put in this call once you do that
267:11 - you will have access to everything we
267:13 - had in our user interface file for
267:17 - example we can set up the window title
267:18 - because this is a widget we can access
267:22 - the submit button like this we use the
267:25 - self thing here because now that's part
267:28 - of us because we are inheriting from UI
267:31 - widget and UI widget is named like this
267:34 - because our object name is Widget the
267:39 - top level widget is named widget if we
267:40 - go back to designer that's what we
267:42 - should see here let's click on the top
267:44 - level with it again make sure you see
267:47 - this object name here this is important
267:49 - this has to match what you have after
267:53 - the UI Dash here this is how the user
267:56 - interface compiler is going to do things
267:58 - so once we have everything we will set
268:00 - up our slot and everything is really
268:02 - going to work once we have this we can
268:04 - go to our main main dot python file and
268:08 - we will put in the code which is not
268:10 - going to be anything new so we will
268:13 - create our application object we will
268:15 - create an instance of our own widget
268:17 - this is really important so notice the
268:20 - class is named widget we are creating an
268:22 - instance of it and this is going to show
268:24 - our user interface because we did the
268:27 - wiring in the Constructor of our widget
268:30 - class here now that you have all this
268:32 - done we can try to run the application
268:34 - and a warn you it's not going to work at
268:37 - this point but let's try to do that
268:40 - so we can say python
268:42 - main.py and if we try to do that we will
268:45 - have an error what is it saying uh
268:48 - source code strength cannot contain null
268:50 - bytes and this is happening because our
268:53 - UI widget Pi file was generated in any
268:59 - coding that is different from the one
269:01 - that is being used by Visual Studio code
269:03 - here so what we need to do in our case
269:06 - we can click on this utf-16 thing down
269:10 - below once we do we will have a menu on
269:14 - top here in Visual Studio code and what
269:17 - I want you to do is to click on save
269:19 - with including and we will be using
269:22 - utf-8 here once you do that the thing
269:26 - below here make sure you see this it's
269:28 - going to change to tf8 and now if we run
269:32 - the application it should work let's
269:34 - come down
269:35 - play yarn and run our thing
269:39 - and now it is working we are able to
269:42 - compile our user interface code into
269:44 - python code and loading that python code
269:47 - in our own application and this is
269:49 - really cool we can put in our full name
269:52 - to make sure that our connection to
269:54 - slots and signals are working Daniel
269:56 - gray
269:58 - occupation is going to be a farmer and
270:01 - if we submit you see he is a farmer if
270:05 - we change to plumber
270:06 - he is going to be a plumber and this is
270:09 - working exactly like we want and again
270:12 - the mid of this is to be able to call
270:15 - the user interface compiler the command
270:18 - is what we have here make sure you
270:20 - remember it or have it typed somewhere
270:22 - where you are able to access it easily
270:25 - once you have your python codes
270:28 - generated make sure it is in the correct
270:31 - encoding at least if you are using
270:34 - visual studio code once you have it in
270:36 - the correct encoding you can import the
270:39 - code in your widget.pi file and create
270:43 - your class like we do here once you have
270:45 - your class you will do the necessary
270:47 - connections to manipulate the user
270:50 - interface components remember these are
270:52 - the objects names we have in our
270:54 - designer file once you have your class
270:56 - you will create objects of it and you
270:59 - will play with it however you want we
271:02 - are going to stop here in this lecture
271:04 - and I will see you in the next one in
271:06 - this lecture we are going to look at how
271:09 - to use the cute resource system and this
271:12 - is a powerful system that allows us to
271:15 - bundle files into our python application
271:18 - so that they can be found easily without
271:21 - having to need to put them where our
271:24 - main python binary or script is and we
271:28 - will explain this concept using this
271:30 - little application here so we will have
271:32 - a minus button and a plus button when
271:35 - you click on minus we will decrease the
271:37 - number that we have here when you click
271:40 - on plus we will increment the number and
271:42 - this is going to be a spinbox component
271:44 - I don't think we had a chance to talk
271:46 - about it but you're going to see it as
271:48 - we go in this chapter here the main
271:50 - point is to be able to load the icons
271:53 - for minus and plus here from our QT
271:57 - resource system in this lecture we will
272:00 - be doing things manually from QT
272:03 - designer to show you how to work with
272:05 - this and here is a simple piece of text
272:07 - saying the same thing I just said here
272:10 - but one thing you should keep in your
272:11 - mind is that the files in your resource
272:15 - files are going to be compiled into
272:17 - python code and that's why it is
272:19 - possible to directly find them where
272:22 - your main python script is without
272:24 - having to need to browse through the
272:27 - file system where your python code is
272:30 - running and this is really important but
272:32 - again it's going to incur a price on you
272:35 - the developer to have to compile your
272:38 - resource file into python code and
272:40 - you're going to see that it is really
272:42 - easy we use a QT resource compiler and
272:46 - it's really easy you just have to call
272:48 - the command and you will get a python
272:50 - file that you can then load into your Pi
272:53 - side project the workflow we will be
272:55 - using here is to create the resource
272:57 - file of course you also need to create
273:00 - your user interface files you're going
273:01 - to be needing we will compile the
273:04 - resource into python code we will import
273:06 - the python resource file into our own
273:10 - python application and we will be using
273:13 - that in our application here here I am
273:16 - showing you how we will be doing this in
273:18 - designer so once you have designer
273:19 - opened you will click on this button
273:21 - here this is going to pop up this little
273:24 - widget in this widget you can create a
273:26 - resource file using the menu here and
273:29 - you can add the files to that resource
273:32 - using the menu here I will show you how
273:34 - to do this in a minute when we hit our
273:36 - designer instance once you have your
273:39 - resource file created the file is going
273:41 - to be named
273:43 - resource.qrc this is an extension that
273:46 - Designer understands QT designer I
273:49 - should say and you will run this command
273:51 - Pi side 6 Dash RCC you will give it the
273:55 - resource file you will say that your
273:58 - output file name is resource underscore
274:02 - RC Dot py and it is important to follow
274:06 - this naming convention because other
274:09 - tools like QT designer are going to be
274:11 - looking for it so make sure if your file
274:14 - is resourced to name the output python
274:18 - file resource underscore RC you
274:20 - basically have to add an underscore RC
274:23 - on this then here and this is going to
274:25 - work once you have your python file that
274:28 - you generate you will need to import
274:30 - that in your python project and all you
274:33 - need to do is say something like this
274:35 - and you will be able to use it notice
274:38 - that this is our own class named widget
274:40 - it's going to be inheriting from our UI
274:43 - widget file and it will be accessing the
274:47 - buttons so we are making connections to
274:49 - our buttons just like you see here and
274:52 - we will be setting icons to these
274:55 - buttons and you see we set up the icons
274:57 - like this and the mid of this is what we
275:01 - do here to access our images notice the
275:04 - syntax we use colon backslash images
275:08 - backslash plus this is because our
275:10 - images are going to be leaving in a
275:12 - folder named images and once you follow
275:14 - this convention here everything is going
275:16 - to work we have the plus icon we can set
275:18 - it to our button and our user interface
275:21 - is going to show up exactly like we want
275:23 - okay now that you know this we are going
275:25 - to head over to visual studio code and
275:27 - play with us a little more okay here we
275:30 - are in our project the project we work
275:34 - on is going to be seven resource manual
275:36 - designer and this is where we're going
275:40 - to be playing with this the first thing
275:41 - we need to do is to create our user
275:43 - interface in designer so let's make sure
275:46 - we have designer opened open it if it's
275:48 - not opened for you and we will be
275:51 - creating a new project or a new file
275:54 - it's going to be based off widgets here
275:56 - so let's create this is going to create
275:59 - our user interface we will be creating
276:01 - our user interface a lot of times here
276:04 - because you need to be familiar with us
276:06 - so let's do this we need two buttons the
276:09 - first one is going to be on the left the
276:11 - other one is going to be to the right we
276:13 - need a spin box and we will be using a
276:17 - regular spin box why not we will have
276:20 - the button to the left named minus
276:22 - button so we need to change the object
276:25 - name here and we name the other one plus
276:29 - button
276:31 - okay the one on the left is minus we can
276:34 - change the text
276:35 - let's say minus and say plus to the
276:39 - right here let's look at the object name
276:41 - for our spin box it is named spinbox
276:44 - let's name it spin box with an
276:47 - underscore because this is our naming
276:49 - convention and make sure the object name
276:52 - for the top level widget is widget
276:54 - because this is our conversion layer
276:56 - widget and we have our user interface I
277:01 - think we can apply a horizontal layout
277:03 - immediately by clicking on the empty
277:05 - form and clicking this button here and
277:07 - we can resize this okay to something
277:10 - like this and we have our application
277:12 - here okay we have our file here we can
277:16 - save it let's say file save and we will
277:19 - browse to a location where we would like
277:22 - to save this it is in our project here
277:25 - so we will name it resource or widget.u
277:29 - I not resource sorry for that so we save
277:32 - this on our drive and we have this thing
277:35 - saved once we have this saved we will
277:37 - also create a resource file and we can
277:40 - close this now we don't need to close it
277:42 - because we need an active resource file
277:46 - to be able to create our resource file
277:49 - this is unfortunate in a designer so
277:52 - let's open this again we can go where we
277:54 - saved it sorry if this is a bit
277:56 - convoluted but it is what we have to
277:58 - work with so let's bring this back once
278:01 - we have this created we can head over to
278:05 - our designer we will have a little
278:08 - button like this okay make sure you see
278:11 - this I am going to click on it it is
278:13 - going to pop up another window and on
278:17 - the left here we have the option to
278:19 - create new resource files so let's click
278:22 - on this button here that says new
278:24 - resource file it's going to browse into
278:27 - my system where I want to save my
278:30 - resource file I am going to choose this
278:33 - location here and name it
278:35 - resource.qrc I think the extension is
278:37 - going to be put in automatically when I
278:40 - save the file is going to be saved if I
278:42 - go back to my location I am going to
278:44 - have my file where is that where is it
278:47 - where did I put that file let's try to
278:50 - hit OK and see if this is actually going
278:52 - to save my resource file or I put it in
278:56 - the wrong location yes we have the file
278:57 - here because we closed that so it must
279:00 - be designer that was having problems
279:04 - saving my resource file now that I have
279:06 - the resource file created I can move
279:08 - over to the right here okay and add the
279:12 - prefix a prefix is really like a logical
279:14 - grouping of files into your resource
279:17 - system for now don't worry too much
279:19 - about this click on ADD prefix and take
279:22 - out everything to have a default prefix
279:25 - that is to the root of where your
279:28 - resource file is that's what we are
279:30 - doing here so let's hit enter this is
279:33 - going to give us a no prefix then and
279:37 - once we have a prefix we can add new
279:39 - files I am going to click on add files
279:42 - and this is going to browse it to my
279:44 - location I can go in my images folder
279:47 - don't worry I will be giving you this
279:49 - images folder you can use it in your
279:51 - project you can actually download the
279:53 - source code and you will get that as
279:55 - part of what you download select
279:57 - everything here and open and these
280:00 - things are going to be added in your
280:03 - resource file once you hit OK you will
280:06 - see that these files are going to show
280:07 - up to the right here and you can right
280:11 - click and copy path okay and this is
280:14 - going to give you a path that you can
280:15 - use in your python code so let's make
280:18 - sure we open notepad and paste that here
280:21 - so that you can see it you can see the
280:23 - path we will be using in our python code
280:27 - okay now we have two things we have a
280:29 - user interface file that we need to
280:31 - compile it to python we also have a
280:33 - resource file that we need to compile it
280:35 - to python now we can come out of the
280:38 - editor the designer editor and come back
280:41 - to visual studio code and what do we do
280:45 - we can go to where our project is number
280:48 - seven here and we can load it into
280:52 - Visual Studio code and the first thing
280:55 - we need to do is to compile our user
280:58 - interface let's view and show the
281:00 - terminal I think we still have our
281:03 - Command to compile our widget UI into
281:06 - python it is right here I just got it by
281:08 - hitting up up if you don't have it you
281:11 - can type it if I run it's going to
281:13 - compile my python file that you see here
281:16 - and remember to turn this to utf-8 if
281:21 - you are using visual studio code so
281:23 - let's do that you already done this from
281:25 - the last lecture so we are ready to do
281:27 - this and we need to compile our resource
281:31 - file into python as well again I will be
281:35 - giving you the command here I am going
281:37 - to paste it in pi side 6 Dash RCC you
281:41 - get to this as part of your Pi side 6
281:44 - installation and I will give it the
281:47 - resource file you need to compile you
281:49 - will say Dash o and say the output file
281:53 - name the naming like this is important
281:56 - because your other tooling like designer
281:59 - are going to be looking for that so make
282:00 - sure word that you attach an underscore
282:03 - RC to whatever name you have for your
282:06 - resource file here and once you have
282:08 - this you can hit enter this is going to
282:10 - compile the file this is the output
282:12 - python file you can see that this is
282:14 - binary representation for the files that
282:18 - we have in our resource file
282:21 - now that we have this lens we can
282:23 - actually create our python files we will
282:26 - need a main python file main.py as usual
282:30 - we also need a widget py file I will put
282:35 - in my widget py file immediately here
282:38 - because I don't want to type all this
282:41 - you can type this if you want but you
282:43 - can also download the source code and
282:45 - use it as is here the main point is that
282:48 - you know how to work with resource files
282:50 - in your python applications so notice
282:54 - that we have a squiggle because our
282:56 - widget file starts with an underscore
282:59 - okay so UI widget.py that's what we are
283:03 - importing from we will create our own
283:05 - widget which is going to inherit Q
283:07 - widget and UI widget we will set up a
283:10 - window title we will access our plus
283:13 - button and minus button and we will be
283:16 - setting up our slots that are going to
283:18 - respond whenever something changes in
283:21 - spin box let's change this to say self
283:25 - spin box because I think we named our
283:28 - thing using
283:30 - let's go back and open recent forms
283:34 - that's going to be widget UI and our
283:37 - spin box is named user and underscores
283:40 - make sure you don't mix these things up
283:43 - so spin underscore bucks that's the name
283:47 - spin underscore box that's going to be
283:50 - our thing here and whenever you click on
283:52 - plus we will be incrementing the value
283:55 - in our spin box whenever you click on
283:57 - minus we will be decrementing the value
283:59 - in our spin box that's what we are doing
284:01 - here but the main thing is that we are
284:04 - setting up an icon that is using things
284:06 - in our resource file and we are able to
284:08 - do this because we imported our resource
284:11 - underscore RC file that we got as a
284:15 - result of compiling of a resource file
284:18 - into python make sure you really
284:19 - understand this now that we have this we
284:22 - can create our main python file and it
284:25 - is not going to do anything special it
284:28 - is just going to import things from our
284:31 - widget file which is named with an
284:34 - underscore let's make sure we change
284:35 - that and we will set up our application
284:38 - object we will create our widget and we
284:40 - will show it and everything should work
284:41 - at this point here before we do that
284:44 - let's make sure that our UI widget Pi
284:48 - file is in utf-8 it is so let's try to
284:52 - run this we are going to go to view and
284:55 - show terminal and we can go down and go
284:59 - up up up until we see our Command to run
285:03 - the code and let's see what we have here
285:06 - we have a mismatch for a spin box with
285:09 - camo case here where is it
285:12 - in our widget Pi file line 12 so let's
285:17 - go there
285:18 - widget.py line 12
285:21 - is trying to use the wrong name for our
285:24 - spin box let's make sure we fix this and
285:27 - uh let's try to run again view terminal
285:31 - and we can clear and try to run and if
285:35 - we run you see our application is up
285:37 - here if we click on Plus
285:40 - and we still have problems with our spin
285:42 - box sorry for this
285:44 - but it is something you come across so
285:46 - no problem here the important thing is
285:48 - that we can fix it spin box and let's
285:52 - make sure we run again clear and run
285:56 - it's going to run if we click plus we
285:59 - are going to increment if we click on
286:01 - minus we are going to decrement and
286:03 - everything is working and the meat of
286:06 - this is to be able to load these files
286:08 - from your resource system and some of
286:12 - you might think why go through the
286:14 - trouble to use the resource system it is
286:16 - really important because you don't have
286:19 - to provide these files where your main
286:23 - python file is if you deploy this
286:26 - application to your users and this is
286:29 - really important make sure you take
286:31 - advantage of this in your Pi side
286:33 - applications we are going to stop here
286:36 - in this lecture and I will see you in
286:37 - the next one where we're going to be
286:39 - using QT Creator to create these
286:42 - resource files here so I will will see
286:45 - you there in this lecture we are going
286:47 - to see how to use resources in the QT
286:50 - resource system from your user interface
286:53 - files and this is going to save us from
286:56 - doing what we did here for example by
286:59 - having to manually set the icons to
287:02 - buttons we can avoid this kind of thing
287:05 - and do it right from our user interface
287:08 - files in this case we will be using
287:11 - designer so let's head over to visual
287:13 - studio code and actually set up a
287:15 - project that is going to help us do that
287:17 - and another thing I should point out is
287:19 - that you don't even have to manually
287:21 - import this file in your python project
287:25 - because you will have done this from the
287:28 - user interface file but make sure that
287:31 - you still have your resource file
287:33 - compiled into python because the UI file
287:36 - is going to be looking for that and it
287:38 - will be looking for a name in conversion
287:40 - like this from your resource files so
287:43 - let's head over to visual studio code
287:45 - and do this okay here we are in our
287:47 - editor we will be loading resources from
287:50 - our user interface file and we will be
287:54 - working in this folder here I think we
287:57 - can still code from the last project and
287:59 - use that as our starting point here okay
288:02 - we have the UI file and the resource
288:06 - file we also need these images so let's
288:09 - copy that and put that in our nine
288:13 - project here once we have this we can
288:16 - bring this into Visual Studio code by
288:18 - dragging and dropping here and what we
288:21 - want to do is to go to our python file
288:24 - and take out the import we are doing
288:26 - here we don't need this anymore and we
288:29 - don't need to set the resources like we
288:32 - are doing here because our user
288:34 - interface file is going to take care of
288:37 - that so let's open our designer file and
288:40 - again make sure that you do this once
288:42 - you have a resource file like the
288:44 - resources that Q RC file we will open
288:48 - our user interface file in designer so
288:51 - let's make sure we have designer up and
288:53 - running designer and we can run it and
288:57 - we will hop over to the current project
289:00 - on my file system number nine and drag
289:03 - and drop the design file here so once I
289:06 - have this I can click on this button and
289:09 - I will have a bunch of properties for
289:11 - this button here but before I do that
289:14 - let's make sure that I have a resource
289:16 - file applied to this UI file so what I
289:20 - can do is come to add a resource file
289:24 - let's open a resource file that is
289:26 - already existing so I am going to browse
289:29 - to the location of my project here on my
289:31 - system let's do that let's go there
289:35 - designer number nine that's the current
289:37 - project and we have a resource file that
289:39 - we can open here let's open if we open
289:42 - it it's going to show the images that it
289:44 - has and this is going to work just fine
289:46 - let's hit OK and once we do that we will
289:49 - be seeing our images and the current UI
289:53 - file is ready to start pulling resources
289:56 - from this resource file here that's why
289:58 - we need to do this connection here once
290:00 - we have this we can click on our minus
290:03 - button I think we will have an icon
290:05 - property we can even search by going to
290:08 - the top here and say icon
290:10 - okay we will find icon here and once we
290:14 - have icon we can click to the right here
290:16 - click on the three dots now we don't
290:19 - need to click on the three dots we can
290:21 - click on the downward error here and we
290:25 - can choose resource once we do that
290:27 - we're going to click on images and we
290:29 - can click minus once we do that the
290:32 - minus icon is going to show up we're
290:34 - going to repeat the same process on the
290:37 - plus button click on the down arrow
290:39 - choose resource click on images and on
290:43 - the right here you can choose plus and
290:44 - this is working because we made the
290:46 - connection between the widget UI file
290:49 - and the resource file that we have on in
290:54 - our path here once we have this we can
290:56 - save so let's save this again and
291:00 - because we just changed our user
291:03 - interface file we need to recompile this
291:06 - into Python and this is something I want
291:08 - you to be aware of every time you change
291:10 - your things in your user interface files
291:12 - you need to recompile them into python
291:15 - files so that the python side of your
291:17 - application can pick up those changes so
291:21 - let's come back to visual studio code we
291:23 - can really close out of QT designer here
291:25 - we don't need this anymore we can come
291:28 - back to visual studio code view our
291:31 - terminal okay and we can clear and go up
291:35 - up to compile our user interface file
291:39 - into our python file and we will be
291:42 - using the user interface compiler notice
291:44 - that we don't even need to recompile the
291:48 - resource file because we already had
291:50 - that but if you don't have a resource
291:52 - file or if it is the first time you set
291:55 - up your resource file you will need to
291:57 - compile that into python code I am going
292:00 - to show you why in a minute once we see
292:02 - our newly generated UI widget that Pi
292:06 - file if we go there the first thing I
292:08 - want you to notice is that the the
292:11 - encoding has changed back to utf-16
292:13 - because this is a newly generated file
292:16 - so let's make sure we go back and change
292:18 - this back to utf-8 okay we need to do
292:22 - that and another thing I want you to see
292:24 - is that this file is going to be doing
292:26 - the import for you because it is the one
292:29 - that is doing the setting of the icons
292:31 - on our buttons so make sure you still
292:34 - have your resource file compiled into
292:37 - python code and make sure you use this
292:39 - name and conversion here you see that QT
292:41 - designer or the user interface compiler
292:45 - to be exact is looking for this and you
292:48 - need to follow this conversion for
292:49 - things to fall in place and work so our
292:52 - python file should be clean now it is
292:55 - not important things it is not setting
292:57 - icons but our application should still
292:59 - work let's go to view the terminal and
293:02 - clear and run if we run we should see
293:07 - this coming up here if we click on plus
293:09 - it's going to increase comment if we
293:11 - click on minus it is going to decrement
293:13 - and everything is working as we want
293:15 - this is really all I wanted you to see
293:17 - in this lecture how to connect your user
293:20 - interface files with the resource files
293:22 - make sure that whenever you change
293:24 - something in the user interface file you
293:27 - recompile to python for the python side
293:29 - of your application to pick up the
293:31 - changes and use them I am going to stop
293:34 - here in this lecture in the next one I
293:36 - will show you how to do the same from
293:38 - cute Creator I'll see you there
293:40 - in this lecture we are going to design a
293:43 - slightly involved Q made window
293:45 - application which is going to be using
293:48 - resources intensively we're going to
293:50 - have a chance to play with the menus and
293:52 - toolbars and we will be able to use the
293:57 - images that are coming from a resource
293:59 - file that is going to be attached to our
294:02 - user interface file we're going to be
294:04 - building something like this so this is
294:06 - going to be our application here you can
294:08 - see that we have a bunch of menus we
294:10 - have a toolbar here and we are using
294:13 - icons that we will be pulling from our
294:16 - resource file down in the middle this is
294:19 - going to be a central widget for our
294:21 - main window and it is going to be a text
294:23 - edit component and we will set up this
294:26 - entire user interface in q2designer and
294:29 - use it in Visual Studio code on the
294:31 - python side so let's do this
294:34 - here we are in our working folder we
294:37 - will be working in this folder number
294:39 - 11. you can see that it is an empty
294:42 - folder the first thing we want to do is
294:44 - to open cute designer and actually set
294:46 - up our user interface in this place here
294:48 - let's do that QT designer
294:51 - and it is going to be a main window
294:53 - project that we want to set up so make
294:55 - sure you select main window here and
294:58 - create and this is going to give us a
295:00 - main window that we can play with make
295:03 - sure you know the name of the top level
295:05 - widget in this case it's going to be
295:07 - named main window this is okay and we
295:11 - want to add a bunch of menus just like
295:13 - we saw so we can say file here by
295:17 - clicking and typing let's look at our
295:20 - design we have a file edit and help
295:23 - let's do that we're going to say edit
295:26 - and help
295:28 - let's see what we have in our file menu
295:30 - in the file menu we will have a quick
295:33 - action so let's put in quit
295:36 - okay and you can see that when you
295:38 - double click on the place that says type
295:41 - here you're going to be adding in an
295:44 - action let's go to edit we will put in
295:47 - copy
295:48 - cut paste we can undo but before we do
295:54 - let's add the separator and then undo
295:57 - and redo and help we can say about
296:02 - and about QT
296:05 - I am going to show you how to pop up a
296:07 - bunch of dialogues that show information
296:09 - here and I think we have our user
296:11 - interface if we come down I think we can
296:14 - say add toolbar this is going to give us
296:16 - a place where we can drag and drop
296:18 - thanks so let's go down here in the user
296:22 - interface where it says action editor
296:24 - and in here we can actually add a bunch
296:27 - of actions so you can see that we
296:29 - already have many actions so we have
296:31 - action quit copy cut and paste what we
296:35 - want to do is to but before we add icons
296:40 - to these actions we actually need to add
296:44 - a resource file so let's go to Resource
296:47 - browser here and click you already know
296:50 - how to add the resource we will be
296:51 - adding a new resource file to this
296:54 - project it's going to be saved and let's
296:57 - go somewhere on a drive here 11 here
297:01 - that's the folder the name of the file
297:03 - is going to be resource nothing
297:04 - complicated here dot QRC and that's
297:08 - going to be our resource I am going to
297:11 - copy a folder of images that I will be
297:14 - using in this project here it is going
297:17 - to be available once you download the
297:19 - source code for this lecture here so
297:21 - let's go in the current project and add
297:24 - in our images folder and we can come
297:27 - back to designer and once we have the
297:30 - resource we will be needing to add a
297:32 - prefix click on ADD prefix here take out
297:36 - everything like we did earlier and now
297:38 - you can add files if we go in images we
297:42 - are going to select everything and add
297:44 - all these files here and if we hit OK
297:47 - these files should now be available for
297:51 - a use in the project here now we can
297:53 - come back to the action editor and
297:57 - double click on action quit if we do we
298:00 - will have the option to set an icon
298:02 - let's choose resource and go in images
298:06 - and we will choose the quit icon here so
298:09 - let's hit OK and if we do okay again the
298:13 - icon is going to show up let's do the
298:15 - same for copy let's choose resource
298:18 - images copy where is the copy icon it is
298:21 - right here so let's select that hit okay
298:24 - we are going to go to cat and do the
298:27 - same choose resource images cut icon
298:30 - that's what we want and hit OK we want
298:34 - to paste choose resource images paste
298:38 - and okay we want undo resource images
298:43 - and do where is undo undo is right here
298:47 - let's select it and hit OK we want to
298:50 - redo resource images redo icon after
298:55 - that we have about let's click OK first
298:58 - about let's go choose resource images
299:02 - about that's going to be this icon here
299:05 - which is black we hit OK and about QT
299:08 - let's go to Icon choose resource images
299:13 - and about QT the orange one and we can
299:16 - hit okay now that we have this we can
299:19 - actually drag and drop actions on the
299:21 - toolbar and this is going to be really
299:23 - cool you see it shows up here you can
299:25 - right click and say add separator okay
299:29 - and then we can do copy cat and paste
299:33 - okay this is something we can do once we
299:36 - do this we can even add another
299:39 - separator okay and after we do that we
299:41 - are going to do undo and redo okay we
299:45 - can do something like this
299:47 - another thing we can do is to add the
299:50 - text edit component okay we can drag it
299:53 - and drop it here and we can click in
299:58 - some empty space and use a vertical
300:01 - layout for example to make the text edit
300:04 - fill our user interface and at this
300:07 - point I really think we have everything
300:08 - we need for our user interface file and
300:12 - because it is automatically loading the
300:14 - resources we don't need to manually
300:17 - import the resource file all we need to
300:19 - do is compile our user interface to
300:23 - Python compile the resource to Python
300:26 - and we will be able to set up a main
300:28 - window python file that is going to be
300:30 - using these things on the visual studio
300:32 - code side or the pi side if I can say it
300:36 - like that so let's save this file here
300:38 - let's save and we will be given the
300:42 - option to choose where we want to save
300:43 - it it is going to go where we are saving
300:46 - out of files so let's go to that
300:48 - location and choose this guy the name is
300:51 - going to be main window in lowercase
300:54 - dot UI and if we save it should be
300:58 - available in our current working folder
301:01 - we have the resource file we have the
301:03 - main window file we can close out of
301:06 - designer if we want but for now what we
301:08 - want to do is to load this guy into
301:11 - Visual Studio code so that's going to be
301:14 - our project here so let's drag and drop
301:17 - inside of Visual Studio code we will
301:20 - have our thing here and we want to
301:22 - compile these guys so let's show a
301:26 - terminal window and we can hit up up to
301:29 - go into our Command history we will see
301:32 - how to compile our user interface file
301:35 - we just need to change the name here I
301:38 - am going to change this to main window
301:40 - to UI main window
301:44 - main window
301:46 - this is what we want if I do this this
301:48 - is going to generate my main window file
301:51 - let's go up again and try to find that I
301:55 - wanted to compile the resource file we
301:57 - have a
301:59 - resource.qrc we don't really need to
302:01 - change anything here this is going to
302:02 - compile our file we need to go to the
302:05 - main window python file and change the
302:08 - encoding to utf-8 if you remember
302:11 - correctly so let's change this to utf-8
302:14 - and now we have everything we need we
302:17 - can start creating our python files we
302:21 - can create the main python file we can
302:23 - also create the main window python file
302:27 - and now that we have this and what we
302:31 - will do is just put in the code to use
302:34 - our generated python file main window or
302:39 - UI underscore main window Pi file we are
302:43 - importing the file here and we are going
302:45 - to be inherit from that file as we do
302:48 - here in the Constructor we do really
302:50 - nothing special here we are just taking
302:53 - an application parameter and that's
302:56 - going to be what we use to kill the
302:58 - application when the user triggers the
303:01 - quit action and down here you see that
303:03 - we do connections to our actions so we
303:07 - say action quit when it's triggered we
303:09 - are going to quit the application when
303:12 - the action to copy is triggered we will
303:14 - be running our copy slot which is what
303:17 - we have here and we do all these
303:20 - connections here there is really nothing
303:22 - special and in about we will be putting
303:25 - out a message box that is going to say
303:28 - something that is just going to be
303:30 - saying something here and when the user
303:33 - triggers the about cute action what we
303:36 - will do is show a message from our Q
303:38 - application class here this is something
303:40 - you can do the main thing here is ready
303:43 - to be able to build your user interface
303:46 - from designer and be able to bring those
303:49 - files into use in your Pi site
303:52 - application like we are doing here in
303:54 - Visual Studio code now that we have our
303:57 - main window we can go to the main python
304:00 - file and bring everything together
304:03 - nothing complicated we are just
304:05 - importing our main window file the main
304:08 - window cluster is in there we are
304:10 - creating an object of it and showing it
304:12 - and kicking off the event Loop here
304:15 - again let's make sure that we compiled
304:18 - our resource it is we compiled our UI
304:22 - main window python file it is using
304:24 - utf-8 this looks good let's show our
304:27 - terminal and try to run the application
304:29 - and if we are lucky everything is going
304:32 - to work and it is going to be really
304:34 - cool let's try to run okay so it seems
304:38 - we don't have an action named about
304:41 - underscore cute let's go back to our
304:44 - designer file and make sure that our
304:47 - action is named about QT yes it is named
304:52 - about QT and it seems we are doing
304:55 - something bad in our main window python
304:59 - file so let's go about QT let's take out
305:03 - the underscore let's try to run again
305:06 - terminal
305:08 - clear if we try to run now it is going
305:11 - to run if we quit we should be able to
305:14 - quit the application if we run it again
305:17 - we should be able to see it you see we
305:19 - see our icons in our toolbar if we go to
305:23 - file and quit it is going to go away you
305:25 - already know how to work with Q main
305:27 - window by the way if we edit we can copy
305:30 - cut paste and do redo and for example we
305:33 - can DDD here and do it's going to go
305:36 - away we can copy let's say the sky
305:40 - is blue you can copy this through the
305:44 - toolbar and we can even paste and paste
305:48 - and paste and paste this is going to
305:49 - work we can undo it's going to go away
305:51 - we can redo it's going to come back we
305:53 - can even cut out everything here and
305:55 - paste you see we are really able to use
305:58 - this application and this is really cool
305:59 - let's use the help menu about it's going
306:02 - to show a message box that we triggered
306:04 - in our code if we do about QT it is
306:08 - going to show information about the QT
306:10 - version that was used to compile this
306:12 - application this is really cool and this
306:15 - is all we set out to do in this lecture
306:17 - showing you a slightly practical way to
306:21 - use the resource system to your
306:23 - advantage and again this is going to be
306:25 - really cool because all these resource
306:27 - files are going to be available to our
306:29 - application without having to recopy
306:32 - these images when you deploy your
306:35 - application and this is really cool I am
306:37 - going to stop here in this lecture and I
306:39 - will see you then this one
306:40 - congratulations on hitting the end of
306:43 - the course here you have learned a lot
306:45 - in terms of using qt4 python to build
306:48 - cute widgets applications that you can
306:50 - run on Windows Mac and Linux now that
306:53 - you have these fundamentals you may be
306:54 - asking what's next well you just
306:58 - scratched the surface when it comes to
307:00 - using Q2 widgets to build applications
307:02 - that can run on different platforms and
307:06 - a few other topics I would recommend is
307:08 - learning about events the graphics view
307:10 - framework which allows you to build
307:12 - interactive applications this is
307:14 - actually one of my favorite topics
307:16 - intuitive you can learn about networking
307:19 - you can learn about databases you can
307:21 - learn about threads there is really no
307:23 - shortage of things you can learn about
307:24 - in QT another thing you can learn about
307:27 - is qml which is another API to build a
307:30 - graphical user interfaces that are fluid
307:32 - and dynamic to run on mobile and
307:34 - embedded this is a really hot topic in
307:37 - QT and I would recommend taking a Twist
307:39 - a moment meant to look at this because
307:41 - if you are serious about QT you are
307:43 - probably going to run into qml so that's
307:46 - something you might want to look at we
307:48 - have a few courses on qml if you are
307:50 - interested you can check them out and
307:52 - really what I would recommend is to try
307:55 - and think about things that interest you
307:57 - the most or things you think that you
308:00 - are likely to meet in your career as a
308:02 - developer focus on those things learn
308:05 - how to do those things in QT and your
308:07 - learning experience is going to be much
308:09 - better this is really all I had to share
308:12 - in this lecture again congratulations on
308:14 - hitting the end thanks for giving me the
308:16 - opportunity to be your instructor if you
308:19 - are interested in many of our other
308:21 - courses be sure to check them out I am
308:23 - going to stop here in this lecture and I
308:25 - will see you next time

Cleaned transcript:

in this course you will learn how to build crossplatform desktop applications in Python that can run on Windows Mac and Linux this course will teach you the fundamentals of working with QT to build GUI applications using pi side 6. Daniel gakuaya developed this course Daniela is an experienced software engineer and he's the creator of our most viewed course of the last year hello guys and welcome to this new course on Pi side sex in this course I will show you how to use Python and Pi side 6 to World great graphical user interfaces that run on desktop that's Windows Mac and Linux and you will be writing your code once and all you have to do is to run your python application on a different operating system and that's going to run seamlessly so that's the point of the course here building crossplatform graphical user interfaces applications using QT under the pi side sex umbrella Pi side 6 is really a technology that allows you to mix up Python and QT to take advantage of the foundation that QT provides and I may hear some of you asking what is QT well QT is a crossplatform framework to build a graphical user interface applications but it is originally written in the C plus plus and the pi side 6 is a project that aims to give us the ability to to take advantage of what QT provides using the Python programming language and this is really cool if you are a python developer you can take advantage of what QT offers without needing to learn C plus plus and that's a huge Advantage you might want to take advantage of in your career as a python developer so this course aims at giving you the ability to build applications like notepad here you see it is a graphical user interface it has a bunch of menus and toolbars we have a status bar here we can type text here this is one of the applications we will get a chance to build and this is going to give you a foundation to really build any kind of application you might want in your career as a python developer another great aspect of this course is that we try to take advantage of every opportunity to teach you how to use the documentation so if you want to search for something for example Pi site 6 and Q widget okay you can come to your favorite search engine and search here you will have the information on this component and you can learn about it we will be doing this a lot in the course and I hope this is going to give you the ability to even learn more on your own because I can't really show you everything in a course like this but this is going to give you a great Foundation to build your own work on top of the requirements for the course are not really that bad all you need is a basic python understanding if you can work with variables functions if you can work with basic object oriented programming if you know things like classes inheritance you will have a good time with the course the most important thing is really the strong drive and willingness to learn so if you have a roadblock for example if there is something you don't understand you should have the drive to actually try and go in a search engine put that in a search bar and really try to understand what is going on once you understand that you can come back to the course but you are not on your own we have a community on Discord you can join to be together with other people that are going through the course if you post a question there I will try and help the best I can and if you go through this course you will have a strong Foundation to build graphical user interfaces using pi side 6. this is going to give you the ability to build graphical user interfaces for your existing python projects so if you are an existing python developer this is going to be a great asset for your career another thing is that the knowledge you get in this course is transferable so if you learn to build the graphical user interfaces using buy side sex the knowledge you gain is going to also be useful if you later choose to use another toolkit for example there is another project which is called the pi cutie which also allows you to build the QT applications using python so if you go through the course here you will have the ability to take advantage of that framework pretty fast because the API is the same but the ideas on graphical user interfaces aren't really tied to a single graphical user interface toolkit so once you've learned the foundations you can use other toolkits fairly easily okay so now that you know a bit about the course let's talk about myself here my name is Daniel acquire I am a software engineer I have been using QT for a lot of years and I happen to have a few courses on QT on udemy most of these courses are using C plus plus but I release the new course which is using cute for python but don't feel pressured to take that course if you want you can take it but this one on YouTube is going to give you enough to build a lot of things and once you have that knowledge you can go on and use the documentation to even learn more than I can tell you in a course like this this is really all I had to share in this lecture so let's stop here and start learning about pie side sex in the next lecture go ahead and finish up here and meet me there I would like to welcome you in this course and congratulate you on taking a step to become a better cute for python developer cute is a crossplatform application development framework you can use it to write applications for Windows Mac Linux Android iOS and even embedded devices the way QT works you write your code once and recompile it for your Target platform so for example if you write your application on Windows if you wanted to generate a Linux binary what you need to do is to recompile your code on a Linux machine and that's going to give you a binary that can run on Linux you can repeat the process on the Mac and that's going to drastically reduce your development time because you basically write your code once and run it or recompile it for whatever Target where you want to run your application now python is one of the official languages we can use to develop cute applications the main language for QT is currently C plus plus but python is quickly catching up under the umbrella of QT for python or Pi side 6 as it is currently known again going through python you can write applications that are crossplatforms that run on Windows Linux and Mac but currently support for mobile and embedded is in development I wouldn't really use this in production but there should be good progress in this area in the future now if you talk about Pi side sex some people are going to mention Pi QT what about by QT piquity is another Library which is available to let you write QT applications using the Python programming language and it can mostly do the same things we can do with pi side 6 but Pi side 6 has probably a better future because it is under the official QT project so you can expect support for things like Android and iOS to go faster than Pi QT another thing is that to use piquity in a commercial application and you need to buy a separate license for pi QT and you also need to buy another license for QT so if you really want to drive your cost down it is beneficial to use Pi side because you will be buying the license once which is going to include the QT and Pi side sex so that's something for you to consider but I'm going to leave the decision to you whether you use Pi QT and Pi side this course is not going to cover up iqt but the good news is that once you have Pi side 6 mastered it is going to be very fast to pick up Pi QT because the apis are mostly similar what's going to change is what you import in your python files and you will be basically able to do the same thing so whether you use 5qt or Pi side 6 that's going to be your choice but we will be focusing on Pi side 6 and the API should help you to pick up iqt if you happen to need that now let's head over to the QT page on Wikipedia and see some information about QT it is a crossplatform application development framework you can use to write applications for Android iOS Linux you can see a lot of things here you can write applications for using QT it was developed by these two guys Harvard and Eric and it is currently developed by the QT Company the company owning licenses of QT it is written in C plus plus and what I want you to see is a bunch of applications that are written in QT to kind of give you an idea of what you can do if you learn a QT properly if you go down here you see Autodesk Maya which is a popular application for building 3D stuff we can go down and find the Creator here which is a design software you can use to do painting and drawing things like that you can say Mathematica if you are a scientist you must know this you can see OBS here which is what I am using to record this video you can see Cube bit torrent you can use to download torrents and things it's like that there are really powerful applications that are written in QT you can see VLC media player you can see WPS office which is really cool if you wanted to do some office stuff and if you go down you will find a bunch of organizations that are using QT and there are some big names in here you can see AMD you can see blizzard you can see DreamWorks you can see Panasonic Phillips you can see CMS and Samsung you can see Tesla there's a lot of big companies using QT and this should give you an idea of how powerful QT really is and you can be in the same league as these companies and these pieces of software if you learn to develop applications with QT properly and this course is a perfect starting point if you want to use Python to develop cute widgets applications okay one thing I want you to know is that there are two apis when it comes to developing QT applications there is the cute widgets API AI which provides components you can use to build graphical user interfaces for desktop this is mainly targeted for desktop platforms mainly Windows Linux and Mac but there is a new API which is called qml which also includes new devices like mobile devices and embedded devices and you can use this to build Dynamic and fluid graphical user interfaces that look modern and really feel like they are from our time here but make no mistake qml applications can also run on desktop so you will need to do some research to decide whether you want to use cute Widgets or qml but if you exclusively want to Target a desktop I would still recommend using cute widgets because it is a mature API it is tested it has been in use since the 1990s and it is really powerful so use that if you don't care about mobile or embedded if you want to Target mobile and embedded please use qml in it is best suited for that and one thing I want to point out is that this course is about cute widgets if you are interested in qml please check out other courses we have on qml because this course is not talking about qml I wanted that to be super clear now if you decide to use QT to build your applications regardless of whether you are using widgets for Q amount you will be writing your logic in some programming language and the two official languages that are supported by the QT company or the cute projects in general is python which we will be covering in this course year and C plus plus but this course as I said is about using python to develop cute widgets applications so this is going to be our Focus here using python to write cute widgets application that can run on Windows Mac and Linux another thing I would like you to know is that cute is not just about graphical user interfaces many people can mistake it for that cute can can be used for much more if you happen to be using QT already for a graphical user interface you still have a window to take advantage of even more things from the QT framework you can do networking you can do threading you can write database applications you can use tons of other utility classes that are provided by QT so if you are already using QT take some time to see some other things you can take advantage of in this course I will touch on some networking and show you how you can do some basic HTTP stuff but that's not enough to really call yourself a network developer using QT if you want to really go deep you will need to do more research but this course should give you a good foundation on which to build even more cool stuff now this course is going to be a perfect starting point for you if you want to build graphical user interfaces in Python using pi side 6 obviously but I think it is even going to give you a good foundation even if you plan to use them out if you are new to the QT ecosystem I usually recommend shredding by cute widgets which is what we cover in this course and from there you will grasp the fundamentals of how to use QT to write crossplatform applications and that's going to really be easy for you to do that because you will be writing your applications on desktop you will be able to generate applications that run on the same machine where you are sitting once you have the fundamentals you can Venture into qml and the same fundamentals you get from cute widgets are going to apply more or less in qml qml is a declarative language and that makes it easy to pick up by designers but this course is about cute widgets using Python and it is going to give you the fundamentals that are going to help you out even if later you decide to use qml that's the point I am trying to make here now I will be preparing this course on a Windows machine but that's not going to be a problem because Python and high side 6 run where both on Windows Linux and Mac so you can watch what I do on Windows and try to adapt that to your operating system and that's going to work really well don't worry about that this course is going to work for you whether you are on Windows Linux or Mac the requirements for this course are not really that hard all I require is a basic understanding of Python and the basic understanding of objectoriented programming in Python if you can use things like classes objects inheritance and polymorphism you will probably be fine with the course using python here the most important thing in my opinion is the strong drive and willingness to learn which is going to go a long way if you come along problems you won't give up easily you will keep trying until you get to the thing running here but I will do my best to explain everything I use in the course if you need a refresher on python please note this course is going to assume you already know python so make sure you learn python first before you take all discourse now this is all I had to cover in this video here I hope you found it interesting and you are encouraged and excited to learn about Pi side six we are going to head over in the next lecture and show you some of the cool applications you get to build as you go through the course here go ahead and finish up here and meet me there in this lecture we're going to see how you can get the most out of the course here and there is really no magic build you can take to get to the knowledge from the course Detroit and true way is to follow along watch the videos try to practice the things I do in the course try to modify the code and make it yours and that's really how you are going to get the mask out of the course here another thing I would recommend is to use the QT examples so if you go to the browser for example and search for QT examples I think they have a lot of examples you can browse to this link they will show you tons and tons of examples and this is a way you can get full running applications you can try out most of these are going to be for C plus plus but once you have the fundamentals in this course you will have the necessary Basics to try and understand what is going on here if you go down you see examples for acute widgets for example if we open the text editor example here all the model view example people you will see that you can build something like this and this is something we even built in our course here but that's going to be in Python you can learn about the model view architecture you can really do all kinds of prison things through these examples here so if you have an idea come to the QT examples see if there is something similar try to build on top of that this is the best way I can recommend to even learn QT by yourself without even needing a course like this but if you are a beginner the documentation like this can be hard to understand you still need the basics this course is going to give you the basics to allow you to take advantage of this but start trying to browse through these examples now see what you can pick up or even identify the things you need to focus on in the course here once you have the knowledge you can come back and use it another thing I recommend is to use the source code that is going to be provided in the course here the link is going to be shared at each lecture so if you want you can go to the lecture download the source code and use that however you want another thing I would recommend is asking questions if you get stuck the course platform will provide a mechanism to ask questions so you can ask a question I will try to respond as best as I can so take advantage of that if you get stuck we also have a bunch of groups on Facebook and Discord you can join and help each other out that's a really good way to learn and to find people who are going through the same thing take advantage of all these channels to make the most out of the course here I want you to be successful in using pi site 6 to build crossplatform desktop applications now that you know this it is time we headed over to the next lecture and started setting up the environment for building Pi side 6 applications in no time go ahead and finish up here and meet me there in this video we are going to set up the environment that is going to allow us to build cute for python applications or Pi side 6 applications and the tools we install should work on Windows Mac and Linux because that's the essence of QT QT is a crossplatform framework that allows us to write applications once and be able to build them on different platforms and in this course we are interested in building for Windows Mac and Linux so here are the tools we are going to need we will need an installation of python once we have python we will install Pi side 6 and we will need an editor through which we will be typing python or Pi side 6 code later in the course we will need QT designer but I am going to show you how to install it later at that time for now we will get into the process of installing python Pi side 6 and the editor that we are are going to be using in this course here another thing I should say is that you don't have to use Visual Studio code it happens to be an editor that I prefer because it's free it's crossplatform it looks and feels the same whether you are on Windows Mac and Linux and I expect a lot of students to be watching this course on a different operating systems so visual studio code is a good choice here okay so let's start with python here if you go to your search engine and type python install we will go to the python.org website and you will find binaries you can download for whatever operating system you are on so if you hit download here you will download it and install it like you install any other application and when you are done installing python you should be able to go to your terminal whatever terminal you have installed and say Python and if you see a message like this it means that python is installed on your system now we have python installed let's set out of this accept okay we are done here now that we have python installed okay now that we have python installed we need to install Pi side six and to do that it's really simple all you have to do is to open your terminal here and use the PIP package manager for python we will be using version three here so let's say pip 3 install Pi side six type this on your terminal if you hit enter the tool is going to go to work and it is going to download and install Pi type 6 on your system and at this point we will have python at Pi side 6 installed on our system the next thing we want to do is to install an editor and as I said we will be using visual studio code in this course here so let's go back to our search engine and say Visual Studio code download this should spit out a link to the website or Visual Studio code and you can download and install for for your operating system I am on windows at this moment so I can download and install it on Windows but you can do the same whether you are on Linux or on a Mac once you have this installed you will need to open it up if you open it it's going to look something like this and the first thing I want you to do once you have it installed is to install a python extension that is going to make our life easier when working with python code and all you have to do is type a python in the search bar here let's make sure it is highlighted so everybody can see it so we have this guy here and I want you to choose the one that says python here and I want you to choose the one that says python here okay the one from Microsoft if you click on it it's going to say intellisense the LinkedIn debugging for whatever in a visual studio code you will click on install and wait for it to be installed and at that moment you will be ready to start using Visual Studio code to develop cute for python applications using pi site 6. okay now that we have this installed it's time to test it and see that it actually works what we are going to do is to open a folder on our system let's go somewhere on my drive here I have a folder it is an empty folder you can name it whatever you want and if you go in you're going to see that it is an empty folder what we are going to do is to drag and drop this on top of Visual Studio code and this is going to open the folder inside videos video code we are going to get a window that says do we trust this folder yes I trust this because I created it so yes trust the authors and we will have something on the left here and this is going to be where we see our files and this section here is going to be the editor in which we're going to be typing stuff so nothing special here let's go on the left and hover over these buttons here you see we see one that says new file another says new folder we want to click on the one that says new file and in this window we will type main.py for python if we do that we will create a python file here and all we need to do is to put in Python code that is going to attempt to use the pi side installation we just brought into our computer here okay so what we are going to do is to put in some code to test things out I don't really expect you to understand everything we do here all we want to do is to make sure that the environment works we will have a chance to learn about all the things we see in this piece of code and even more so let's put in an import statement and this is just going to import Q application and Q widget and these are classes we're going to be using to create our widgets application after that we can go down and say import sys and this is going to import a facility that allows us to work with command line options in Python if you know python you probably know about command line options we can go down and create a variable app and we're going to say Q application and assists args and after that we will create a window and it's going to be a q winner we will show the window and after that we will start the application by calling the exec method okay now that we have this we can try to run it but before we do please make sure you have exactly the same thing as I do here I would even recommend going to the GitHub repository for the course and copying and pasting this entire code here because at this point you may not be familiar with these things like Q application Q widget and some people are going to introduce typos and have unnecessary frustrations so I do recommend using the code AS is here so you can copy from the GitHub repository and paste in here okay once you have the code in make sure you save so you can control s on this or file and save and after this we will open a terminal window we're going to come to view and say terminal and it's going to open a terminal window inside Visual Studio code in our current folder here which is a bit convenient and we will type python main.py and if we wait we're going to see a window popup and this is confirming that our installation of both Python and Pi side 6 is working and we are ready to start learning about cute for Python and this is really cool this is really all I had to share in this lecture and again the goal was to set up a development environment we can use to do what we do in this course here we have Python 3 installed we have Pi side 6 installed and we installed the editor that we will be using throughout this course here don't worry about QT designer at this point because we're going to need it later in the course and when we get to need it we will install it and you're going to see how cool all this is we are going to stop here in this lecture and I will see you in the next one in this lecture we are going to try and understand what is actually going on here in the last lecture we blindly typed in the code to make sure the environment is working but now is the time to try and get an idea of what is going on here before we do that we are going to go to where we saved our code and we'll copy the code from the last lecture and rename this zero to understanding the code I think that's going to work better and it's zero two not zero one so my body here and I am going to drag and drop this on top of Visual Studio code to open that project if I hit on main.py here you see the exact same thing we saw in the last lecture we have syntax highlighting now and the first thing I want you to do that is going to save you a little bit of time is to come to file and the toggle or to save okay you're going to click on auto save here and now things are going to be Auto saved as you type things and you won't have to hit Ctrl s or come here to say save that's going to save you a bit of time now let's try to understand the code but before we do let's make sure it actually runs so we can come to view terminal and hit the app arrow and this is going to bring back the command we typed the last time we run a visual studio code this is really cool if you want it you could uh type this python main.py and hit enter and uh python let's type that correctly and if we run we're going to see our window popup here now the code here the first line is importing the components that we need for this code for this project we need Q application and Q widget and these are part of the cute widgets module that comes as part of the pi side installation that we did so this is really important the components we need and here you could either import CIS or not import it but I just wanted you to see that it is possible if you want to process command line arguments okay so since is a module that is responsible for processing command line arguments and once you have them they are going to be picked up by the queue application instance you have here and you will be able to process them in your QT application so that's what the system here does okay once we have our assist thing here we can create our application and an application is really like a wrapper that is going to be in globing everything you do in your QT application so it is going to be the thing responsible for running your application and waiting for things to happen as you interact with your application for example if you click on a button all those things are going to be happening under a wrapper that is this app object here this is as simply as I can explain it after we have our application we will create our widget and we name it window in our application here and by default Widgets or Windows in qt are hidden so we need to show show it and after we show it we will call the exec method on our application to start the event Loop and the event Loop already is a while loop something that keeps looping around waiting for things to happen so for example if we run our application let's bring back our terminal and we run it again so for example if we run it and it happens to be a button in our application here if you click on the button the event Loop is going to be the thing that catches that click you do on the button and it is going to respond I realize I am jumping around here trying to go as deep as I can but that's the gist of what is happening here the exact call here is going to start the event Loop so let's say that here okay and this is really all that is happening here another thing I want to say is that if you have been working with python you may have seen things like this calling the exact method with an underscore after the C and let's try to run the code with this so let's bring back our terminal and try to run again and you're going to see that it is going to work but you see a comment saying that this thing will be removed in a future versions of python and they are recommend demanding using exec instead and this is coming because of older versions of python that had problems with the exact command here in Python 3 I believe this is going to work well so the convention we will be using here is not to use the underscore we will be typing exactly like this and you will see the same things on the print function you have in Python so if you wanted to print something you can say print and it is going to print that but you can also use an underscore again this is something that comes from older versions of python but in this course we won't be using these underscores here another thing I want to point out is that you can use the documentation to learn about everything you want about Pi side 6. so for example if you want to learn about this widget thing we are using here you can go to your favorite search engine and say Pi site sets and say kill with it and this is going to pull the documentation for acute for python if you open this you will have all the information about that thing so let's see what they say here you can click on more and you can increase the size of this because I like larger text and it is the atom of the user interface it is a base widget on top of which you can build a lot of other things I do recommend reading up on this if this is your first time with QT so you can create a widget a widget can have a bunch of components you can create other widgets on top of this but we will have a chance to learn about all these things as we progress in the course but it won't hurt to take a moment and read about this and how you can use this in your python applications so this is all I had to share in this lecture trying to shade some more light on what is going on behind the scenes we are going to stop here in this lecture and the next one we will try and organize our code in separate files so that things are easier to work with I will see you in the next lecture in this lecture we are going to organize the code in classes to make things a bit easier to work with in the last lecture we did something like this even if we didn't use cumin window but the code looks strikingly similar and here we will be using everything in the global scope so we will be doing things in a single file you see we are importing this here to be able to process command line arguments we are creating a window and this is a different kind of window that can have menus toolbars and things like this and we will have a chance to learn about this later you're going to see how it looks in a minute another special thing about this kind of widget or window is that we can give it a central widget and that's what we want to do here to be able to use buttons so we have the window here we are going to give it a title using the set window title method and after that we will set up a button which is meant to leave inside this window here a button is something you can click on you can give it the text and once you have your windows set up again we have the window let's try to draw this here we have a big window inside the big window we will have a button and this button is going to have text here press me and this button is going to be within this window because of the setting we are doing here that's how these things work after we have the window we will show it and we will start our event Loop and the application is going to work now someone would argue that putting all the logic for these buttons and things in the same file is really bad and we need to organize this the first level of organization we're going to do is to extract the logic for the window in its own class and we do that using the code you see here so we will create a class in Python the class is going to be named button holder as you see right here and it's going to be inheriting from Humane window we will give it a Constructor and if you know python objectoriented programming this is not new to you so we will have a Constructor and in the Constructor we will be doing the things we were doing in our main python file you see we are setting up the window title we are setting up the button and we are telling the button to beat the central widget for this button holder class once we have this class setup we will create an object of it in our main python file again we have the application object we created a window notice what kind of window it is it is button holder and this is going to create an instance of the class that we just set up on top here once we have the window we're going to show it and kick off the event Loop and this is going to extract the logic of setting up the window and doing all kinds of crazy things in this class here someone would argue that this is still not maintainable it is bad we see the logic for the buttons and the windows in our main python file well we can do even better and create a version 3 of our application in which we are going to extract the button in a separate file so we can do something like this we can create a file and name it buttonholder.py and inside that file we will put in the code to create our buttons and windows and all kinds of crazy things now in the main file what we are going to do is to import the things we need to use we will Import Sales import application import button holder and after that we will be able to use button holder even if the details of this battle holder class are not in this file here and our main adopt py file is going to be a bit easier to look at and this is the main goal of this lecture here making it easier to organize or code in classes to make it easier to work with now that we know this we're going to head over to visual studio code and play with us a little more okay here we are in Visual Studio code and here is the code we will be using here organizing code in classes if you go in you're going to see that it is a folder with the main python file so we're going to be starting from there let's drag it and drop it on top of Visual Studio code or to open it and if you look it is the same thing we had in the last lecture let's clean all this up and we will put in the code for this lecture here we will go on top and put in version one of our code and to save on time I am just going to paste in the code here and take a moment to explain it because typing it would really waste our time I will type when I see that it is going to add value but for now we just want the code here in our editor so we are importing the things we need we need queue application Q main window and Q push button and now that you see these new classes that you don't know about it is a good time to go to the search engine and try to learn as much as you can about them so we can go to our search engineer and say Q main window okay Q main window and if we go and click here and again I do recommend reading as much as you can about this this is a main window that provides a framework for building and applications user interface and one thing that is special about this class is that it allows you to set up things like menu bars toolbars dock widgets status bars and things like this and it is a really cool thing to have in your application if you need these kinds of things so we are going to be using a basic version of this but I don't recommend reading as much as you can about this so let's come back to our editor so we have a main window object we are creating that is going to allow us to set up menu bars status bars and all kinds of crazy things we are going to give it a window title and down below we are creating a button Q push button and again this is a good time to come to your search engine and look for a q push button so let's do that okay come here you should really drill this Habit in your workflow because it's going to allow you to learn more things than I could even tell you in a course like this so the push button or command button is perhaps the most commonly used widget in any graphical user interface so you can click on it and things are going to happen and this is really how it works this is how you create it and you can connect slots to it and you can do all kinds of crazy things with this button component here for now we are just interested in making it show up in our user interface because it is easier to work with after we have the button we will tell our main window to use the button as it's Central widget once we have the window we will show it and we will kick off the event Loop by calling the exact method here this is all we are doing now that we have this remember this is going to auto save because of the setting we did here you see autosave is toggled on we can show our terminal okay and we can hit up to bring back our Command and let's make sure it is highlighted so everybody can see it this is the command we have right here python main.py if we hit enter with this this is going to show a window and if we resize just a little bad I want you to notice some of the things we did we have our window title on top here okay you can see it right here and we set it up using this line here and we have a button in the middle of the window right here this is our button and it is saying press me you can see the text here and it is the text we set up here and I really want you to make sure you understand the relationship between the code you type and the things you see when you get to run your application because this is going to give you a firm understanding of how Pi side is working to give you the user interface you are seeing here now we have the application here but some of you might argue that it is really not well organized to save the list to have the window and button logic in our main python file and we will try to improve on this what we are going to do is to comment out our version one here and I am going to put in a pair year of block comments in Python this is how you do it in Python you have three double quotes and three double quotes and in the middle you're going to put in your code and that's going to be commented down and I can copy what I want to comment down okay so let's put my code in here and leave the comment on top this is a one line comment in Python this is how you do it and we will do version two and in version two we will be creating a separate class but the class is going to still be living inside our main python file here to do things in steps we can go down and do our Imports these are the same things we have been doing for a long time we will go down and set up our class class battle holder and it is going to be inheriting the Q main window we will set up our Constructor and it is going to be calling the parent Constructor and it is going to be calling the super Constructor or the its parent Constructor now this class is going to be inheriting from Human window so it is also going to be some kind of human window in other words it is going to have access to methods we have in Q main window what that means is that we can say something like self set window title and we will be we will be stealing this method from cumin window and being able to use that in our button holder class this is classic inheritance in object oriented programming so I don't need to say much about this so let's put in our text after that we will set up our button because we have q push button imported here so let's say button equals Q push button press me and the next thing we need to do is to set up the button as our Central widget again we have access to descent Central widget method because this is a main window it is inheriting from Human window again that's what you should understand here so we're going to say self set Central widget and we will pass our Button as the central widget okay now that we have this we can go down and do the usual thing we did on top for example we can even copy from what we did before okay so we can create our application objects we're going to go all the way to the bottom we're going to create our application we want to create a main window now we are going to be creating a button holder so what we can do is go on top and say button holder so we will have our button holder here and we will take out the line to set the central widget because we are doing that in our button holder now that we have this I think we are ready to start running this thing again we have our class which is going to be wrapping around the logic to show the window and put in the fence inside the window and we are doing all this in the Constructor of our button holder class this is really cool let's bring up our terminal window and make sure we can run this and if we run this huh what is the problem here I think it is the selftent we are passing here so let's try to run again and now you see that we see the same thing we saw before but now we have extracted the logic for a button holder and setting up the window and putting things inside the window in its own class and this is really cool now again we can do better than this by moving this button holder class in its own separate class or its own separate file I should say let's do that we are going to comment out this let's put in our blog comment section and we are going to move everything we don't want in here from this section into our comment and what we will do is to create a new file let's copy the code for the button holder class here and I'm going to copy that let's go to the left and create a new file call it button holder Dot py and inside this file we are going to paste in our class again nothing special here we don't need the queue application here because your application is used in our main python file but we need the Q main window and Q push button we don't need this imported here okay now what we need to do is to just copy the part that instantiates the button holder fan okay we can do that and for this to work we need to import Q application so let's do that we can copy the line that does this here and says think we need CC I think we also need the sales imported let's do that and now we need to also import the battle holder class we are going to say from button holder import button holder and this is going to give us access to these things and you see that all the Dirty Work to set up the main window and put fence inside the window is moved in our button holder file and this is really cool this is what I wanted you to see and we will be doing things this way going forward in the course to make our organization a bit easier let's show our terminal window and run to make sure everything still works I think we still have something running here let's run let's say python Main and if we do that this is going to run and we see our thing here and our code is organized in classes and this achieves what we set out to do in this lecture here in this lecture we are going to learn about signals and slots in queued and the signals and Slots are a mechanism that QT provides to connect things in other words when something happens we want to respond in some other part of our code suppose on the left here we have a push button and we want to do something when that button is clicked the way we do that we set up a piece of code that is going to respond to the right here and when the button is clicked QT is going to emit the signal this signal is going to be picked up by whoever might be interested in this button being clicked and they are going to respond the mechanism QT provides allows us to connect signals to slots and when you have made this connection when somebody clicks on the button the method that is responsible for responding is going to respond and do whatever it is you do in the body of that method suppose we are operating a message whenever you click on the button we are going to print a message whenever you click on the button we are going to print a message and QT provides a simple syntax to allow us to do that let's look at that here I have a piece of code and what I am setting up here is a simple button you can see that right here and we want to respond when this button is clicked we say that we want to respond in this piece of syntax you see here so we say button the name of the variable we say that and then we say the signal that we want to respond to in this case the Signal's name happens to be clicked and once we do this we are going to call the connect method on this and when we say connect we are going to specify the method that is going to respond to this button being clipped Within These parenthesis here in this case it happens to be button collect if you look on top here we have this method we are defining it and in the body of this method we are just saying a message you clicked on the button so this is what we are doing here we are connecting a slot or a method that is going to respond when this button is clicked and this is what does this connection here so some of you must be asking Daniel how did you know that we have this clicked signal on our button and this is another instance of where you need to use the documentation so we are interested in the Q push button component we want to see which kind of signals this component emits let's go to our search engine pretty fast so let's close all of this here and we are going to say Q push button or QT for a python and if we do that we will have the documentation for a q push button if you click on more it is going to tell you everything about this component but what we really want is to see the signals that this component emits and if you go down in here we see synopsis functions virtual functions slots so this is a slot you can activate if you want to do something like this but we don't see any signal from this component and this is because all of these signals are coming from a parrot class of this push button component and that happens to be what you see here this little thing called the two abstract button the documentation for cute for python is not really good for example we can't scroll around to see the things that are cropped off but we are lucky in this instance we can see Q abstract button if you click on this this is going to open the documentation for Q abstract button if you click on more it's going to tell you what this does it is going to implement an abstract button and all kinds of buttons we have in qt are going to be inheriting from this button here but again what we are interested then are the signals that might be emitted by this component again we see functions if we scroll down we're going to see virtual functions if we go down we're going to see slots we can activate if we go down we're going to see signals and this is what we are interested in so the Q push button component can emit a signal to let us know that it is clicked it can emit to let us know it is pressed it is released it is toggled and we can do all kinds of crazy things we can even grab these arguments or these parameters and use them to do things in our QT for python applications so let's go back to our slides now that you know where I got to the information that we have this clicked signal so we have connected to it and then after we do this connection and start the application when we click on the button we're going to see the message from our method here and this is going to be really cool so we are just responding when we click on the button and we know the syntax we use to do that and this is really cool we can go even further and grab the parameter that is emitted by the signal for example if you go back to our documentation in the browser you're going to see that the clicked signal can emit a parameter to let us know whether the button is checked or not we're going to take advantage of this and show you how to handle parameters and signals we can go back to the slides and what we are doing here after we set up the button we're going to make it checkable and this is going to make it toggle its state whenever we click on it so if we click on it first it's going to be checked if we click on it again it's going to be unchecked and it is really going to be simulating the behaviors we have with check boxes if you click on the checkbox it's going to be checked you click on it again it's going to be unchecked and it is basically going to be titling between these two states that's what we are simulating here with our Q push button component but we are doing this because we know when it emits the clicked signal it can also give us information whether it is checked or not and we are going to be printing that state in this print statement here so we are just going to say print and we are going to print the data parameter that we get in this function here and we are just doing the usual connection we did before notice we are saying button clicked connect and we are activating the button clicked method whenever this button is clicked and that method happens to be on top here so this is something we can do we can respond when something happens and grab the data that was sent to us by the signal and use that in our method and this is really cool let's look at another example before we head over to visual studio code and play with us here we are going to use a slider so we will set up a slider component and again this is something we have in QT this is going to be something like this where you have a slider that you can slide around to increase or decrease values we are going to give it a minimum a maximum and a value and whenever we move the slider the slider is going to emit signals that its value is changing and because I checked the documentation I know that the slider has a value changed signal let's go to the documentation and really show you this you should be able to find things out on your own in the documentation let's say Q slider and if we open this up in another tab we are going to see all about this component you can read about this here but we are interested in signals that it might Emit and we don't see okay if we go down here we're going to say that this slider is going to inherit a comprehensive set of signals and among these signals we have a value changed okay if we click on this we are going to see that this signal is going to pass a value to us and we can grab this value and do things with it in our QT for python applications so this is what we are doing in the slides here we are grabbing that value okay and printing that out in our print statement here and all this is happening because of the connection we did here so whenever the value changes we want to call this method to respond to the slider moving and we will grab the current value from the slider and do things with that now that you know all this and again I realize it is a lot of information but we're going to go through the step by step in Visual Studio code and I hope you are going to understand so let's go there and play with this okay here we are in a visual studio code we have an empty folder in which we will be doing our thing let's grab and drag on top of Visual Studio code to open this and we will create our main python file main.py and this is going to give us our starting point the first thing we are going to do is to put in version one of our application here and again I am not going to type all this we are just importing the components we need we are setting up a method that is going to respond when the button is clicked we are setting up our application object the button and we are doing the most important thing here let's take out the line and do the connection ourselves so we are saying button whenever the button is clicked and you see that we don't have autocomplete here so we have to auto complete the signal and then connect that's what we do and we want to specify the thing that is going to respond when this button is clicked so that's going to be button clicked here now we have the connection made and we are just going to show the button here notice that all we have in our application here is a simple button so this is what we are going to see when we run this application here let's bring up our terminal window and we will simply run this just like we did other applications and when we do that we see a little window pop up that is saying oppressed me so this is our button inside this window here and if we click on it you see it's going to print the message and it is doing that because of the connection we did here let's close this and comment out this connection to show you that if we don't make the connection we won't see this message when we click on the button because there is no connection between this button whatsoever to this slot here or this method if I can say it like that let's run it again to see this going on we have the button and if I click on it a thousand times I'm not going to see a single message here unless I come back in my code and activate the connection and run the application again then we will see the button and if we click on it we're going to see things happening as a response to the connection that we did here this is really the syntax again how do I know we had this clicked signal I use the documentation let's go down and show you that you can also handle parameters or arguments coming in your signals let's comment this up so we have this done here and we will put in version two of our code let's go down and uncomment this let's take out my blog comment here and again notice that we have a parameter in our slot here and we don't have any mention of that parameter because the clicked signal is going to send it anyway it is our decision to decide whether we handle it or not that's what we are doing here so we have the parameter and we're going to be printing the checked State and to be able to toggle between the checked and not check the state you have to enable that on your button component and that's what we are doing here setting checkable to True once you have this you can run the application and you are going to see that as you click on the button it is going to be constantly toggling between the chat and unchecked Stage let's run this we can go to view and a terminal and run this again but before we do I think we need to kill the application that was running earlier so let's clear and bring up our application if we click press me it is going to check it is going to say checked true we click again checked false we click again checked true this is happening because a behavior that is built into this battle component is that if you click on it while you have this property set to true it is going to be constantly toggling between a checked and unchecked that's what we can do here and again the real intent in this example is to show you that you can handle parameters that come in your slots and at the syntax you use to connect doesn't really change you decide whether you handle them or not by putting the parameter here if you put the parameter in here you can handle it in your application depending on the data inside this data parameter if you decide not to handle it you can just take this out and you're going to fall back to what we had in our previous example so let's run again so we can show our terminal and kill the application that was running and I started again now if you click you're going to see that we are just going to see the message but we don't see the state because we're not handling our parameter here if we put it back in and say data okay and run again I think we can run again now we are going to see the checked State because we are handling that in our slot here I hope this makes sense and I did the best I could to put in a bunch of understandable comments so that you can really understand what is going on here let's comment this out and give you another example using a slider because that's a bit more interesting so let's put our code in the comment block here and we can go down a bit long and put in our code and again we are just going to be importing the components we need okay notice that we are importing the QT named space if I can say it like that we have our slot which is going to be handling some data but the slot is going to be responding to a slider being removed and again we talked about this in the slides we have our slider we want it to be horizontal if you want you can make it vertical but it's not going to be beautiful we have the minimum set again I know about these methods because I am familiar with QT for a lot of years but if you are just getting started your best bet is use the documentation to read about all these things for example again if you go back to slider I think we have that somewhere here you can see the methods that it has okay so we have a maximum method to get the maximum we have a method to set the maximum you can read about all these methods to see things you can do with your UI components in your QT for python applications and again after we have the slider we are connecting to the value change signal and we want our method to be activated whenever the value changes and whenever the value changes we are going to grab the current value which is sent to us as part of this signal and we will be printing that right here if this is not making too much sense maybe we can run the application so let's go to terminal and run it and this is going to give us a slider here okay and if we move it you're going to see things happening here again you see that it was starting at 25 if we move it up it's going to go to 27 28 29 it's going to go all the way to the maximum which is 100 or we can bring it all the way to the bottom which is one okay and we can move things around you can use this component in your application and it is going to work really well but again in the meat of this lecture here is to let you know how to make connections between signals and slots and I hope you know how to do this right now this is really all I had to share in this lecture I hope you found it useful we are going to stop here in this one and I will see you in the next lecture I would like to welcome you in this new chapter where we are going to be exploring cute Wizards and widgets are really the basic components you use to build your user interfaces and in QT these are going to be coming from the cute widgets module we will have a chance to look at Q push button q line edit and all these widgets you see here and they will allow you to build cool user interfaces without waiting anymore let's head over to the next lecture and get started in this lecture we are exploring the Q widget component we have in the QT framework and this is a fundamental component in builtin user interfaces in that it is going to give you a base window on top of which you can do all other things so for example if we set up a q widget component and show it we will have a pair window and on top of this window we can really build any kind of structure to have all kinds of crazy user interfaces we might wish for in our QT applications and to use this it's really simple now you have the fundamentals of how you do things in q24 Python here I am going to show you a simple example and this is a class that is going to be living in its own file the class name is Rock widget it is going to be inherited from Q widget and Q widget is really the base class that we can use in our QT applications it is going to have a Constructor and in the Constructor we're going to be doing our basic work here another thing I am going to show you in this lecture is how we can use layout to lay things out nicely this is really not the place to introduce layouts but we really need them to have the flexibility to lay things out flexibly inside our widget so that's why I am doing that here you also see that we are having a bunch of components we have a bunch of buttons we are doing connections to slots and we want to respond when these buttons are clicked and in our code we will also set up these methods that are going to respond once we have the widget we are going to display it in our main python file and here you see that we are doing the usual we are importing the file that contains our Rock widget class and we are setting up a widget which is an instance of our Rock widget component we are showing it and kicking off the event Loop to have our application show up now that you know these things we are going to head over to visual studio code and play with us step by step okay here we are in our Visual Studio code editor I have an empty folder which is going to be containing the source code for our example here let's drag it and drop it on top of Visual Studio code to open it and I can create my main python file and in here we can do the usual we can import the things we need we can also import sys set up our application object and we are going to say window equals Q widget we are going to show the window and we are going to say up exact okay to start our application here notice that we say it's the windows here and we don't have q widget imported and we can import that here Q widget it is part of the widgets module in pi side 6 and if we do this and run the application we should see a widget popup let's show our terminal so that we can run the application easily and we can go up until we find the command to run this and you see this is going to pop up our widget nothing special here what we are going to do is to move the logic to set up the widget inside a separate class and have that widget as a base on top of which we can build other things so let's do that we are going to create another file we are going to call it Rock widget and in that file we are going to import Q widget from PI side Q2 Edge yet so let's do Q widget and we'll set up our class the class is going to be named The Rock widget it is going to be inherited from Q widget and it is going to have a Constructor so let's make sure we put that in and for example we can give it a window title let's say self set window title and we are going to call this rock widget and now that we have this notice that we did just the minimum we needed to have this be a valid python class here so we can come back to main.py and import we're going to say from from Rock widget import Rock widget and we want to create a q widget component this time we will create a rock widget you can do something like this now that we have this we can run let's see if this actually works and if we run we should see the same thing we saw before but now this is not an instance of Q widget it is an instance of rock widget which itself inherits from the Q widget class now that we have this we can start doing all kinds of crazy things on top of this curated component what can we do for example we can set up a bunch of buttons let's do that we will also import Q push button okay we already know Q push button let's say button one equals Q push button and say button one you can do this if I can type what are we going to see when we run this application let's try to run it we are instantiating an object of rock widget in main.py remember and we want to see where this button is going to show up in our user interface that's a question you might have let's try to run and if we do this you see that we don't see our button but we set it up in our code the reason this is happening is that this widget doesn't know where to put the button and to put things inside our widgets or our window we need to use layout and the layout is a way let's try to draw this so that it is really easy to understand now we have our widget component and we put our button in our code here to attempt to put some kind of button in our user interface but this widget component doesn't know how to lay them out there is a way in QT you can tell a widget to lay things out either vertically okay something like this or horizontally from left to right and you do that using layout let's start with a horizontal layout to start out we have a class which is called qh box layout and it is a way we have to lay things out horizontally in our class and to do that you set up a an object of that class we are going to say layout or button layout okay we can do something like this and it is going to be a qh box layout component okay once we have the layout we can add events to this layout so let's say button layout add the widget and you see we have a bunch of methods you can add other layouts inside this layout you can add the trial to widget but in this case we are just interested in adding the widget which is going to be our button one so please make sure you really understand the flow of things here we have our parent widget and we want to put things inside this widget using this layout here once we have our widget in the layout now we can call the set layout method on the widget to let it use this layout component to lay things out inside the widget component here so we're going to say self set layout and we are going to say button layout we can do this now if we run we should see our button inside our widget and if we do this you see that we have button one here and this is really cool now that we have this infrastructure in place we can add other buttons so for example we can go down and copy this I think we can do that Ctrl alt down this is going to copy this in Visual Studio code and we can name this two button too okay and we can add a widget again Ctrl alt down this is going to copy the line and we can say button 2 here and now we can go down and try to run we should have two buttons button one and button two and you can keep going putting in as many buttons as you want another thing I want you to see is that you can lay things out even vertically so we can change this to be a vertical layout let's do that QV box layout and we can change this to be a QV box layout this is all we need to do and because this is a vertical layout now when we add these buttons here they are going to be added in vertical order let's try to run button one should be on top button two should be below let's run again and we have this here and this is really cool now you can see that we can use this widget and this is really the idea I was trying to convey here as a base on top of which we can build as a complex user interfaces and we will be doing a lot of that in the course here right now we are just laying the foundation so that you really understand what is going on under the hood now that we have these buttons we can really do all kinds of crazy things for example we can set up a bunch of slots that are going to be activated whenever we click on these buttons now you already know how to do this lens but now we are going to be putting in these methods as part of this class they are going to be methods of this class here so for example you can say def button one and when it is correct we are going to print a message saying button one clicked okay we can do something like this we can even copy this method code I think we can do that okay so let's do that and do that for button tool clicked and we are going to say button two collect and we can connect signals to these slots that we are setting up here the way you do that you come down say button one you already know this if it is clicked okay we want to connect to a signal to a slot that's going to be self button one clicked we have this for button one we can duplicate this button too so we can select the line shift alt down this is going to copy the line in Visual Studio code that's why I love Visual Studio code and we can put the code here to duplicate it and we are going to say button 2 click now we have the connection from this buttons to the slots we have down here if you click on button one you should see this message if you click on button two you should see this message let's view terminal and we are going to try and run again but we have the previous application instance running so we can kill it and run again and if it runs Watch What Happens below here okay so let's click on button one button one clicked what is going on here ah the problem is that we are setting these methods up as methods of the class but we're not telling these methods that they belong to this class here you do that by passing in the self argument sorry for that so let's do self and I think at this moment this should work let's clear and run again and if we click on button one it's going to say button one clicked if we click on button two it is going to say button to clicked if you wanted you could change this to be laid out horizontally by using q h box layout that is going to lay out thanks horizontally if you run again they are going to be laid out horizontally if you click button one clicked if you click button to clicked this is really all I wanted you to see in this lecture again if you don't know what qh box layout and the QV box layout to do I invite you to use the documentation let's do that QV box layout and you are going to have a lot of information about these things you can really read this if this is your first time you are going to pick up a lot of information and this is going to be very helpful in your career as a QT for a python developer we are going to stop here in this lecture and I will see you in the next one in this lecture we are going to explore the Q main window class this is a class that allows us to work with things like menus toolbars status bars actions and it is really cool what this is going to give us is a window like this but a window that has little parts or components that we can customize for example in many applications at least graphical user interface applications we have something like a toolbar or a menu bar on top and below that we might have a toolbar that contains things we can click on to make things happen after that we are going to have something like a main or a central widget and in that widget we are going to put in the main component of our application if it is an editor or a text processing application users will be able to type things in this component and things like that we might even have a storage bar or something we can use to show some messages or whatever you can design your applications reusing this components that are built into the Q main window class that you can instantiate in your QT applications so this is what we are going to do here we will create a class that is going to be building on top of Q main window and on top of that we will be doing our own things and you're going to see that we will have the ability to add menu bars toolbars status bars and that's going to be really cool once we have this class inherited we can add menus like we see here so we can call the menu bar function on Humane window and this is going to give us a menu bar object that we can manipulate once we have it we can add other menus for example you see here we are adding a file menu and the add menu method is going to give us a menu object that we can use to manipulate our menu here for example we can add actions to our menu and we are doing that right here and this is going to give us an action we can manipulate later here in our QT applications I realize this is a bit convoluted but actions are a thing that you can use to manipulate a user doing something in your application suppose we have a quick action like this and we want the user to be able to trigger this either from the menu bar or the toolbar so the user could go in a file menu and select quit or they can go on the toolbar directly and click quit the way QT does this it adds in an intermediary step through which you can go to trigger this action and this is what this action is an action is an object that you can either add to the toolbar or the menu bar and when the user tries to quit either through the menu or the toolbar all these things are going to go through the same action and you can connect this action to a method that is going to do things in your QT application and you don't have to duplicate your code either in the menu bar or in the toolbar I am going to show you this when we hit Visual Studio code if it is not making sense yet but this is a really good design when it comes to the QT framework so we have the action here and this is the action that we will be connecting slots to for example you can see whenever this action is triggered this is a signal that is emitted by Q action you can go in the documentation to take to check this out when this actually is triggered we will call a method called quit and this is going to quit our application as you are about to see again the meat of this here is to show you how you can manipulate menus in your QT applications once you have the menu bars you can add menus to that menu bar and once you add the menu you will have a menu object you can add actions to we are repeating the same process here we are adding an edit menu and in this edit menu we will add actions to copy cut paste and do and do and we will be seeing these things in our user interface and if we really want it we could grab these actions and connect slots to them to do things in our application and I think we will even do an application like this later in the chapter here so stay tuned for that down here you see that we have a bunch of other menus we have Windows settings help we can do this next another thing we can do is also manipulate the toolbar and you do that by setting up a toolbar object like you do here once you have the toolbar you're going to add that to the main window using this method here and you can add actions to the toolbar you see we are adding an action we are adding an action and before we add the action we're going to create it so this is how you create your action you can put in a bunch of things and you can connect slots to the action this is really what we are doing here another thing I want you to see is that you can even pass an icon when you create the action and this icon is going to show up wherever ever you add that action in your user interface and this is really cool down here we are adding a separator in our toolbar and we are even adding a push button in our toolbar you can do that if you want it is possible let's see how you can also use storage bars to use this notice bar you set the status bar on your main window using the setting we have here and we are creating a status bar object in place and passing that in down below you see that we are doing a button that is going to be showing up as our Central widget and once we showed this we are going to see the entire application here and this is really cool down here we have our methods that are going to respond whether we click on buttons or things in the toolbar all the menu bars and you see the method here you also see the method to quit and once you have distance your application is going to work now that you have this we can head over to visual studio code and play with us step by step okay here we are in our Visual Studio code editor we have an empty folder that we are going to be using to do whatever we do in this lecture here let's drag and drop this on top of Visual Studio code and we will create our main.py file on top of this we will also create a main window file let's do that and this is going to be where we create our main window class the first thing we want to do is to make sure we have the correct Imports so we are including queue application and Q main window we will need to pass an application object to this window to be able to quit you're going to see how we wire these things up but for now just put Q application here let's go down and set up our class it is going to be nothing really special the class is going to be called main window it's going to be inheriting from Q main window let's make sure you can see that it is going to be inheriting from cumin window here we are doing our Constructor then and we have a member which is called app which is going to be the application instance that created this main window here and we will be using this application member to quit the application again you will see how we use these things in a minute now we have a main window object I think we can go in the main py file and try to use this so let's go down and put that in here it is not going to be anything special we have q application imported we are importing main window from our main window file the class we just set up here and we are creating the window which is main window we are showing it and we are kicking off the event Loop nothing special here so let's show the terminal window to be able to run this and we are going to say Python main.py and if we do this we will see a window popup here but you may think this is a normal widget to Daniel why all the fuss around two main window let me show you we are going to go back to main window here and we are going to put in a piece of code like this okay so this is going to be setting up our menu bar so we will call the menu bar method on our main window object and it is going to give us a menu bar that we can use to add menus to our main window object here and again how do I know this the documentation let's go back to our browser and we can say Q main window here Q main window and if we look here we can see a method called menu bar you can see that right here and they are going to say whatever this method does it is going to return the menu bar for the main window this function creates and returns an empty menu bar if the menu bar does not exist so we are going to create it and we can go through these menu bars to add menus to our main window this is really cool right so we are calling add menu to our menu bar object again we can go to the documentation and see what we get from this guy this is going to return the Q menu bar okay and uh this is why I don't like the documentation for cute for python there should be a link for a q mini bar you can click on to go there but we have to go back and search here so let's do Q menu bar and we can open this in our browser once you see this you're going to see that we can do a lot of things and one of these is add a menu and this is what we are using in our application here to add a menu called the file on our menu here let's run and see our menu live let's clear properly and run python main.py if we do that look at what we have here we have a menu we can click on it to do things but it doesn't have anything inside yet but we're going to fix this in a minute let's close the application first but what we can say for example is file menu okay file menu add action and we are going to say something like quit if we do this and run and come back to our window here if we click on file you see we have a credit we can add menu options in our menus and this is really cool okay another thing we can do is actually grab this action and use it to respond whenever the user triggers this action for example you can say quit action okay we can name this quit action and we can connect to it and make a slot respond whenever this action here is triggered and this is really cool so let's go down and Define a quit method so let's go down here and say def quit app for example and it's a method so we need to pass a self here and down below we are going to say app quit and can we quit we're going to say quet autocomplete is not helping here but I think this is going to work so let's go with this and once we have the action we can connect this slot to it so we can say create action trigger connect and we will connect the self method that is called quit app let's see what happens if we do this and this is really cool if it's going to work let's clear and run the application now we have our file menu and if we hit quit the application is going to go away let's try it again file quit it is going to go away and this is really cool we can add a bunch of other menus now that you know how to work with ADD menu and add actions on menus so to populate this I am going to add an edit menu and let's take out these unprisoned symbols because we don't want to go into that here they have some use in QT but we're not going to go into that here now we have another menu added to our menu bar and we are going through this menu to add a copycat paste and do redo menu options and we will see them in our user interface if we run the application let's go to view terminal and a clear and run our application if we do that we have an edit menu this is really cool if we click on it copy cut paste and do redo and this is really cool you can do this things using the Q main window class in cute for python let's add a bunch of other menus to make this a little bit interesting we have window we have settings we have help and let's add a comment here if we run let's see if we can see these things showing up on our user interface and we see our thing here and this is really cool now I hope you know how to work with menus and many options and you even know how to respond when one of your many options is triggered now let's focus on toolbars the first thing we do is to create a toolbar object and a set a few properties on that and before we create the toolbar we need to import the toolbar and the queue size class here we are using to give it the icon size the size object here is coming from cute core so let's put that n and if you want to know how I knew that how did I know that queue size is coming from cute core well you have to use the documentation and if we go back to our browser I really want you to be familiar with using the documentation because it is an invaluable skill queue size for acute for python or Pi side 6. and if we look for it they should tell us where this thing lives cue size you see it lives in the cuticle module that's how I know this lens because I don't memorize them so we have this imported I think we can import Q toolbar from cute widgets because that's the module where it lives we don't even need the Q application imported here because we don't need this so let's take this out I think this is going to work and we can go down and keep working on our toolbar here once we have the toolbar we can add in a bunch of actions so to start let's say toolbar add action and add in our reduction how about that we can add the quit action to the toolbar and you do that by saying toolbar add action and let's say quit action because I think we have it on top create action where is our quit action I think we have it right here we can copy it and put that down below here I think this is going to work let's see what happens if we run this application this is going to be really interesting and this is going to explain why we have two actions in QT so let's see our toolbar you can see our action right here here and if we go in file you are also going to see that we have a quick thing set up here but we are managing what happens when a user triggers this action in one place whenever this action is triggered we are going to call the quit app but we can trigger this action from different places in our application and we can either do that from the menu or from the toolbar if we create from the menu the application is going to die if we quit from the toolbar the application is going to die and we have one single method to respond to all those possible sources of this action being triggered and I really hope this makes sense so let's go down and keep playing with our toolbar here another thing we can do is create our own action just like we do here action one Q action we are giving it some information and apparent because its Constructor requires this information again I know this because I read the documentation so go in the documentation read the information for Q action and you will know why we need to do things like we do here now we need to import a few action Q action leaves in the cute GUI module so we will import that like we do here and if we go down our application should be happy now that we have the action we can pass a lot of information for example we can pass a status tip and this is something that is going to pop up when you hover over your action we can do something like this you can respond when this action is triggered and this is going to be a method we set up in our application and after we have the action ready we can add it in our toolbar just like we added our quit action on top here and this is really cool before we run let's go down and actually set up this method so let's copy and say that and we will pass self as a parameter we will go in the body of the method and we can print a message saying action one trigger okay can do something like this now that we have this let's make sure it is the same name we are using here option one triggered yeah or we can use it or we can even say action triggered this is going to do let's run the application okay we have some action added to our toolbar if we click on it we're going to see that our action is triggered so you can respond to things happening in your toolbar and this is really cool we can even set up another action but before we do let's go to the place where our source code is and we will add in an image because we want to pass an icon to our action here and make it show up in our user interface you can download the source code and have access to this short image here okay so you can use this let's go back to our code and we can go down and set up another action this action is going to be taking up an icon and I think icon is coming from the cute GUI module so let's say Q icon I think we have that imported here here so we can do this and if we set up this then we can pass our start PNG icon it is in our project we just pasted this in here and we can pass the icon on top of the other pieces of information that we passed earlier so we have some text that we pass in our action we have a parent we can pass the status tip message here and we can respond when this thing is clicked and again this is going to activate our slot here that we set up we can make this thing checkable and to be honest I don't remember what this does but we're going to figure this out when we run this and we are going to add this to our toolbar let's try to run this and see what the checkable thing does okay so we can run this and we have our theme showing up here we see this thing is triggered and the checkable thing is not helping out in this moment I think we can comment it out and see what happens this is how you learn about distance okay so let's recite this and if you click you see this thing is triggered I think the checkerboard then here is working in the same way as we saw for a push button so we're not going to be talking about this anymore here if you want to see the signals that are sent by a q action again we can go to the documentation and look for queue action let's do that Q action in cute for python you can read all you can about this class if we go down hopefully we're going to see the signals that it emits you see it has a triggered signal and it can pass a parameter which may be useful if you have set the checkable state here I think that's the use for that so you have this now you can read the documentation on Q action and know all you can do with it now I think we know how to work with toolbars let's see how we can work with the status bar and the starters bar is this little section below your window I think we should show this it is this little thing Below in which you can show a bunch of messages and we're going to show how this works in a minute so let's go back to the code but before we go to status bars I just remembered something I didn't show you we can add a separator to separate lengths in our toolbar and we can even add a widget something like button in the toolbar and this is really cool if this is helpful for whatever you are building with QT for python please take advantage of that let's import Q push button for that to work so Q push button and let's go down and make sure we have no more squiggles so we have the thing here let's run and see what this gives us and you can see that you can even add a button okay if you look closely you're going to see that we have a separator here so you can separate things in your toolbars now let's go and work on status bars and all you have to do to work with the status bar is to set a status bar object to your main window so we use the set throttle support method here and we will create the object in place and set that as our own status bar status bar is in the cute widgets module so let's add that here kill status bar and once we have it we can start showing things in the status bar what we are going to do is to set a message to the status bar so let's go in our slot so let's go in our slot that responds when the toolbar button is clicked so we're going to say Self Storage bar and we are going to say show message this is a method you can use to show a piece of message and you can pass the message so message from my app let's say that and you need to specify a timeout you can specify you can leave this empty let's first see what happens if you leave this empty so let's do that if you click it's going to say message from my app and you can see that if you click on this the message in the status bar is going to change and another thing that is wiredate QT is that if you hover over something that has a tooltip message that tooltip is going to show up in the status bar that's what you see here but if you click you see that my message is going to show up and it is not going to go away it's going to stay there as long as you are hovering over the thing you can pass the timeout parameter here so let's say we want to wait for this for three seconds three thousand milliseconds this is what we mean here so we can run the application again if we run it and click on our thing the message is going to show up but it should go away in three seconds and it does go away so click one two three and it is going to go away after three seconds and these are the things you can really do with your Q main window class we saw that we could use it to play with menus and menu bars we played with toolbars and we later played with service bars another thing you can do with our application to make it a little less boring is to put some button in the middle as the central widget and we are setting up the button here and we are going to set up a method that is going to respond when this thing is clicked when the button is clicked here so let's make sure this is aligned properly and we wanted to respond when it is clear effect so let's put our method here we are going to define a method let's say Def and we are going to give it a name and we want to go inside and put some message out clicked on the button you can do something like this and this is going to be our Central widget and we want to mark this as a method and if we show the terminal and run we're sure to see a button in the middle of our application and if you click on it you're going to see the message here and this is really all I wanted you to see in this lecture I apologize it turned out to be really long but Q main window is really interesting now you know how to add menus to your application you know how to work with the toolbar and you know how to add status bar messages to your application the toolbar is very flexible I think you can even move it so you see you can move it around in your application you can play with us it is really cool we are going to stop here in this lecture and I will see you in the next one in this video we will learn about the Q message box class and this is a class that allows us to set up transient temporary message Windows like this you can see something like this it has a title it has a message inside and we have two buttons one to accept and one to reject and it can really be any kind of message and Q message box allows us to set up something like this in QT there are different ways to do this and we will start by looking at the hard way to do this and here is a simple function that is going to do this we will set up a q message box object and through a bunch of method calls we will apply a bunch of properties to our message box object so we can give it a title we can give it the message to show we can really do all kinds of crazy things but one other good thing I want you to notice is that you can control the type of message box this is going to be by changing icon here so you can make it a critical message box you can make it a warning message box you're going to see what all these things mean here another thing you can do is specify the buttons that are going to show up on your message box so in this case we want to see an okay and cancel button but it is also possible to put in other buttons if you want to you can just keep ordering those types of button in these parentheses and they will show up we will also set to the default button so the OK button is going to be on by default or it's going to be highlighted if I can say it like that once we have the message box object set up we will show it and we show it by calling the exact method this is going to make it pop up on the screen and we will grab whether the user pressed OK or cancel through this return variable so if the value of this is Q message box okay we will know that the user chose okay if it is something else we will note that the user has chosen cancel and if you pop up this message box you will see all this kind of information here I know this may be cryptic if this is the first time you work with something like this but I will show you how this works in a minute when we hit Visual Studio code so this is the hard way to do things QT provides a bunch of static methods you can call on Q message box to show different kinds of message boxes and it's really simple to trigger all you have to do is say cue message box critical this is going to give you a critical message box you can pass in the parent you can pass in the title the message and the kinds of buttons this vent is going to show okay once this thing shows up and the user chooses either of these buttons you will know through this return variable that we are setting up here and we will do the usual check we do to know whether the user pressed OK or cancel so this is one kind we can also have information message boxes and and you can really see that what is changing here is the method you call if you call the information method you will get an information message box if you call the critical method you will get a critical message box and we can keep going on really going through them all we have a warning one we have an about message box and here you see how you can trigger those message boxes what we will do is set up a bunch of buttons in our user interface and whenever you click on one of these buttons we're going to trigger a different kind of message box so this one is going to trigger the message box we set up the hard way the second one here is going to trigger a critical message box and we will keep going until we hear to the about message box as you see down here and here is how our buttons are going to look so nothing complicated here but one thing you should notice is that we are using a vertical layout to lay these guys out how you see them here so we're going to do this in a minute when we hit the visual studio code so let's head over to the editor and actually do this so here we are in our editor Visual Studio code we will set up a new project and we will be working in this folder called message box you can see that it is an empty folder we can drag it and drop it on top of Visual Studio code to open it here and we will create our main profile and we need a widget file that is going to be containing our widget we will set up our widget class like we do any other widget so we will import the components we need and we will set up a widget class here once we have this we can head over in our main dot py file and put in the code that is going to trigger that widget I think at this point we can actually run to see that our application actually works and then we can start building other things we need let's clear and say python main pi and if we do this we should see a window popup here and we will build our user interface on top of this the first thing I'm going to do in our widget class is initialize the buttons that we will be using in our Constructor so let's do something like this and I am going to just put them in and we will be looking at the meaning of this as we go through the lecture here so we are setting up a window title for the widget here and we want to set up a bunch of buttons we have a hard button that is going to trigger the message box we set up the hard way we have a critical button a question button an information button a warning button and an about button and each of these buttons is going to be triggering a different kind of message box to kind of learn about all these things here once we have the buttons if we run the application remember we're not going to see them because we need to tell this widget class how it's going to be laying out all these buttons here but let's try and show you what is going to happen if you try to run the application at this point if you do it's really not going to work but here it is just complaining about the slots that we don't have in place but the point is that this is not going to show the buttons the way we wanted them shown so we needed to use a bunch of layouts here and you can see that I imported a v box layout because I have a purpose for this okay so let's go down and set up our layout you already know about layouts here we will set up a vertical layout and once we have the layout we will be adding all these buttons to the layout then we will set the layout to the current widget here this is how we are doing this let's say that we are setting up the layouts here and let's see if we try to run we are probably going to get a problem because we don't have the methods n but we can set up all these methods here so what I am going to do is copy this and go all the way to the bottom so this is a Constructor we can go down below and set up the method and I am going to duplicate this one two three four five times so let's do one two three four five okay and this is going to be critical let's do that okay the second one is going to be critical the third one is going to be questioning I am doing this live so that you guys don't have a problem with what I am doing here so let's do this together question information let's do this so let's go down and do information we're going to paste this in and this is going to say information and we're going to go to the warning button so this is the slot we need to set up after information let's do this warning and we need to go to the last one which is going to be about okay so let's deal about and this is going to say about and let's try to fix our indentation here because python is very serious about this so we need to use one tab space after the line of the functional definition here let's go to view and show terminal and if we do this and run again this should run now and it is going to show our buttons we have done the signal slot connections after the definition of each button so at this point if we click on hard we should see hard if we click on critical we should see critical if we click on question we should see question and let's make sure that everything is working here and about is about now we need to show a bunch of message boxes and we will start by the hard way here so let's take out the text we have in our function or method and I will go on top and say that we are doing things the hard way here and I am going to put in my function definition what this is going to do it's going to create a message box object and you can check this class out in the documentation you already know how to do that but let's do it together anyway so let's say Pi side 6 Q message box this is going to open the page for this class in the QT documentation and you can click on more to read on what this class does this is going to display a primary text to alert the user to a situation and you can really read all you want about this this is how it looks on the Mac this is how you set it up and it is what we are basically doing in our example here okay let's come back to our code we will set up the message box object we will give it a size we wanted to have a minimum size of 700 and width and 200 in height this is the meaning here you can give it a window title we can give it the text to show we can give it some informative text we can give it an icon we're going to make it a critical message box and we can give it the buttons that it is going to show and after this we will specify the default button and the critical thing here is to show the message box okay and you do that by calling the exact method on this once you call the exact method the method box is going to show up and when the user clicks on either of the buttons we will know which button the user clicked on through the return value here so if the user clicks on OK we will get a number representing the OK button if they click on cancel we will get a number representing the cancel button this is how these things work now that we have this I think we can run and see it in action we're going to show our terminal window and we will run okay we are going to click on the hard button and if we do that we're going to see something pop up here so we have a message box here and if we click back on our code let's make sure you see what all these things mean you see the title we set up is showing up here okay you see the informative text is showing up here and the message we set up is showing up here and you see the buttons we set up to try and play with us you can play you can click on cancel it is going to say user choose cancel if you click on OK you can see that we know which button the user clicked up on but you can even play with this for example let's take out the cancel button in our standard buttons here so let's check this out and if we run let's run again okay and click on hard we're going to see that we only have the OK button okay so and this is really cool now you know that you can use these standard buttons to control which buttons show up in your message boxes and this is one way to set up a message box if you want you can do it this way but QT provides a rather easier way to do this because all the work here is really repetitive it is just setting up these messages the title The text the informative text and really the differentiating factor is the kind of Icon you apply to the message box let's change this to warning for example to show you that you can do this so we can change the icon to change the kind of message box this is going to show let's try to run again so we can run and if we hit this is going to show a different icon let's cancel out of this and change this back to what it was was let's hit Ctrl C to go back there it was a critical one let's try again and if we hit hard we're going to see that we have a different icon so they are different in which icons they show the rest is really the same so because of this reason QT provides a bunch of easier to use static methods that you can call directly to get this then show up without doing all the repetitive work here we will start by the critical one because it is what we have here and I am just going to put in the code all you have to do to get this to work is to say qmessagebox dot critical and called the critical method on the Q message box class and then you pass in the parent to the title the message you want to show and the buttons you want the message box to have this is really all you have to do the rest is the same we will check which button the user clicked through the return value of the critical method here and if it is equal to the number that represents Q message box okay we will know that they also chose okay if it is another value we will note that the user didn't choose OK and they chose cancel because we only have two buttons here or they just closed the message box so that's another option too let's run and make sure we see what is happening here we will click on the critical button we can show our terminal and run again and if we click on critical you see that we have a really good message box here again you can see the title we set on top here you can see the message and you can see our buttons here let's go down and try the other ones if we choose cancel you see that it is cancel if we choose OK you see that it is okay down here and this is working exactly as we want the rest is really the same all we are going to be changing is the kind of method we call so we can go down and do the question one let's put some space in here and put in the code for the question message box and we are calling the question method the value is going to be captured in the return value and we will check which button the user chose here let's run and see this running so we can show this question asking the question we can click Ok We're going to know if we click OK we can click on cancel on question and we will note that we have chosen cancel I am just going to go down and put in the rest of the methods then I am going to show you this running so that you have a full working example on these guys here okay so let's go down and put in the information one so we call the information method we can go down and put in the warning one let's do that and we can go down and put in the about message box here all these are things you can do I think it is better to also document this let's say about here we can go on top here and say warning we can go on top here and say information and on top here we will say question and we will go to the top and say critical and here the hard way was critical as well okay we have the thing and now if we run all these buttons should work let's bring up our terminal window we can clear so that we have a clean slate here if we run we should see our tank show up if we click on hard we will say message box we click on critical we see a message box we click on question we see a message box we click on information we have an information message box and be careful to look at the different icons that show up because that's really the main differentiating factor we have a warning one and if we click on about we will have some method here and we can click OK and really run this so the last one doesn't really need to capture the return value because it's just going to give the user a message so the user can just close the thing that's why we are seeing a cancel even if we click on OK because the okay we click on is not meant to give us a return value that's how this link works so this is really all a habit to share in this lecture again if you want to learn more about Q message box you are welcome to read the documentation here you see the documented the kinds of message boxes you can look at but I think we have a good starting point to work with us throughout this lecture here I am going to stop here and I will see you in the next lecture in this lecture we are going to look at the Q push button class and you might say haven't we used a lot of Q push buttons enough by now well we're going to look at it again because I want you to see more on the signals you can process in your QT applications on the Q push button component here so you can process the clicked signal you can process the Pressed signal you can also process the release decision depressed and released signals are going to become increasingly important if for example you are doing a drawing application in which you want to know if the user has pressed it down and moving without having pressed the release button so that's why I want you to know about these signals here and we will set up an application like this so we will have a button that says click we will connect to these signals and we will be processing these signals in these slots that we set up below here and here in the middle you see that we are setting up a layout to have this button show up better in the widget that we are building here now that you know this we can head over to visual studio code and actually do this here we are in our editor Visual Studio code we have an empty folder in which we will be working for this project here you can drag it and drop it on top of Visual Studio code when we do that we will create a main.py file and we will create our widget file once we have the widget file we will put in our starter code we will import the components we need and we will set up a class that inherits Q widget nothing special here we will also go into the main file and put in our boilerplate code if I can say it like that it is going to create the application object and we will create an instance of our widget object here we will show it and kick off the event Loop you already know this let's go to the widget and set up our button and connect to the signals that we are interested in but before we do that we can go to the documentation and actually read a little bit about these signals here so we can go to Q message box now we want to look at Q push button sorry for that let's go to Q push button and if you remember we didn't see the signals that this thing has because most of these signals are coming from the parent class of Q push button and that happens to be the Q abstract button class so we can click on this thing here we will get to the documentation and if we go down we will see the slot but we are interested in the signals and if you look here we have the clicked signal we have used like a gazillion times by now but we have the Pressed signal and the released signal that we are interested in playing with in this lecture here another one you can play with is the toggled signal that is going to be triggered with after you change the state of the button when you have set the button to be checkable like we have done in a bunch of previous lectures but we won't be using this signal here you can play with it if you want let's go back to the code and actually do what we want to do we will come back to our widget class and put in our Constructor code The Constructor is going to set the window title it's going to set up our button and we will be connecting to different signals from this button here and you can see that we are trying to process the clicked signal the Pressed signal and the released signal and we're going to see how this work to be able to see this in action we need to implement these slots here so let's do that so we can go down and Implement these slots as methods of our class and we have the clicked slot which is going to be triggered when you click on the button we have the Pressed slot which is going to be triggered when we press and down below we have the released slot which is going to be triggered whenever our button is released here and we have all the code we need now that we have this in place we can show our terminal window and we can clear and run the application if we do we should see our button here and once we see it we can press on it you see we we see pressed once we go out of the window of our widget we're going to see that the system is going to think that the button is released but if we click again and release you see that we have two signals when we release the button we have the release signal but one thing worth noting here is that the clerk is both depressed and the released signal so a click is going to be triggered when you press and release but if you want to do things only when you press you can use the Pressed signal if that is making any sense that's the meaning of these signals here and I really wanted you to be aware of this if you really want to learn more about these signals you can come to the documentation and see what the official QT guys are saying about this but this is the gist of it this is really all I had to share in this lecture I hope you found it interesting we are going to stop here in this one and I will see you in the next one in this lecture we are going to look at the Q level and the q line edit components in the QT framework and these are components that allow us to set up a component like this in which you can type a single line of text so this is a queue line edit and the label is something you can use to set up some level text something like the full name you see here and if you need these kinds of things in your QT application you will be using Q level and queue line edit the thing we have down here is also a level and in the middle we have a button that we will want to be using to show the capabilities of q line edit here to set these things up all you have to do is to create these components wherever you need them in your QT application you can create a level just like you do here you have a variable label and you call the Constructor Q level and you pass in whatever the label text is going to be you create a line edit component like this and we can do all kinds of crazy things down here you see that we are trying to connect to a bunch of signals from the line edit and we will be playing with this thing but what I wanted to draw your attention on is how we are going to lay things out to make the user interface show up like this and what we are going to do we will first have an in globing vertical layout okay that's what we're going to do then we will take the full name level and the line edit here and put them in a horizontal layout so this horizontal layout is going to show up somewhere like here and then we will set up a vertical layout which is going to be this one and add these components to that vertical layout so the vertical layout is going to have the horizontal layout added to add and after that we will add the button and add the level you see down here I want you to keep this idea in mind because this confuses a lot of people starting out with QT now that we notice we can look at the signals that we can play with for a q line edit for example we can know when the text in the line edit changes we can know when the cursor position changes we can know when the user finishes editing and this mostly means the user hitting enter we can know when return is pressed which is also enter I don't know why QT provides two signals for this maybe the reason difference but I didn't care enough to go investigate that we can know when the selection is changed we can know when the text is edited we can do all kinds of crazy things with these components end we will set up the methods that are going to be triggered by the signals and you have all of them here we will play with them in a minute when we hit Visual Studio code but I do recommend pausing the video and looking at each of them before we go there so that you have an idea about what we are about to do now that we have this out of the way we are going to head over to visual studio code and play with us a little more here we are in Visual Studio code we are going to be working on this folder here which is empty as you can see we can drag it and drop it on top of Visual Studio code to open it and this is going to open our project in the folder let's create our main python file and our widget file and in the widget file we will create our class like we always do make sure you see the Imports we do here because we will be using all these components we can head over in the main file and put in our code that is going to trigger the widget showing up and and we can try this to see if it actually works so let's do that if we show it we're going to have an empty widget and now we can put in a bunch of line edits and labels before we do let's go to the documentation and read as much we can about these guys you can look at Q level if we open this in our browser this is going to tell you what this component does it is used for displaying text or an image we will talk about images later for now we are concerned with text and if you go up you will see a bunch of methods you can call on this to really do all kinds of crazy things but this is mostly used to show text in your QT user interfaces we can also look at queue line edit and pay Special Care on the signals that this component has so if we click on more we're going to see it shows something like this in your QT application you use it to type a single line of text and you can do all kinds of crazy things but for now we will do the basics one thing I want you to see is the signals that this thing has because they are the most interesting thing if you think about it you use a line edit like this if you want users to type text n and you may be interested in different aspects of how the user is putting in text for example you may be interested in tracking the cursor position you may be interested in knowing when the user has finished editing so that you can do something with the text you can do all kinds of crazy things and we will be playing with a bunch of these signals if you see some of that interest you I do recommend clicking on them and seeing what they do to really have an idea about these things here and make sure you read this detailed description to really know about this component even more Ghana can tell you in a course like this the documentation is your weapon when it comes to working with QT and QT happens to have one of the best pieces of documentation I have known in my career as a software developer so let's come back to our code and do what we need to do the first thing we are going to do is to put in our label and line edit component before we do that we will set up a window title to make this selfdescriptive and we create a level like this you can see that there is nothing special about this and we have our line added we have made our line edit a member because of the soft failure and we do that because we want to be accessing this in Our member variables if we don't make it a member like this we want to be able to access it in our methods I mean okay we have this in place I think we will also need another level which is going to show something like this let me show you we need another label that is going to show the text here and we needed the button so we can go down and put in our button and make sure it is aligned properly and we can even go down and put in our label once we have these components the next job is to lay them out we know that we want the level and the line edits to show up in a horizontal layout so we will have the levels in something like this then after that horizontally we will have the line added so for this we will be using a horizontal layout once we have this horizontal layout we will use an including vertical layout on which we will be adding the button okay so let me display it like this and at the level like this so this is the user interface we want to set up and we will first set up this horizontal layout here so let's come down and set up our horizontal layer it is going to be a qh box layout we already know that and on this layout we will be adding our label which is on top here and the line edit once we have this we will set up a vertical layout which in turn is going to contain everything in our user interface here and we will apply the vertical layout on the entire widget let's do this so we can go down and put in our vertical layout QV box layout and to be able to do this you need to have imported all these components here so we add our horizontal layout to make it show up first in our vertical layout so if this is our vertical layout the first thing is going to be the horizontal layout the second thing is going to be the button and the last thing is going to be the text holder let people here once we have the vertical layout we can apply it to our widget and to do that you say self set layout and we will be using V layout here once we do this we should have our user interface and the next thing will be to play with our line edit component here let's show the terminal window so that we can run the application if we run we should see our user interface here let's make sure you can see it because I just closed it by accident you can resize it okay we have the full name on the left because it is what we say in our horizontal layout here we have the line edit here we have the button and we have our level here which we are going to play with in a minute you can play with the line edit and really type in whatever you want you can say the sky is blue my friend and you can really do all kinds of crazy things one thing you might be interested in when you have a component like this is to grab the data and we will be grabbing the data in our line and edit and printing that to the console when the user clicks on the grab data button here so the first thing we're going to do is come back to our code and set up a method and the method is going to be at this level so let's make sure we take this to the correct indentation in Python so this is going to be triggered whenever the user clicks on our button that says grab data and what we are going to do we will grab the text in the line edit notice that we are saying self line edit and this is going to be grabbing this component here the line edit that we set up in our user interface and we can call the text method to grab whatever text is currently in the line edit component so all we need to do now is to do our connection we can say button select net self button required we already know this must be becoming second nature here let's run and see this in action we can open the terminal we can run the application it is already running I think so let's close it we're going to run it again to run the new version of the application and we can say this guy is blue if we grab data we will see that the full name is the sky is blue but we can put in something like John snow and if we grab data it's going to say full name it's Jon Snow you can see that we can grab data in our line edit component this is really cool if you want it you can take this text and actually apply it to the other line edit we have down below here let's play with this to really show you that you can do that so we can close and we will grab the name of the other line edit and what is that text holder level so we can do this okay we can copy it and go in our method and we can say set text on this guy and the text is going to be what we get from the line edit here so we can copy this and put that in here this is something you can do you can really play with this things and I do encourage that let's make sure the application is not running we can run again have and if we say Jon Snow in our line edit and grab data we will see this print on the terminal because we are printing here but we will see that the text T now are as the level here is also going to change to John's now you can keep playing with this let's say Daniel gray and grab data it's going to say Daniel gray and it is really working this is one way you can use a line edit you can grab the text in the line edit and use it to do whatever it is you want to do in your QT application let's play with the other signals we have on our component here for example we can respond whenever the text in our line edit changes let's go back to our line edit which is down here let's put in some space so that we can easily spot it we are going to set up a connection we are going to say whenever the text changes in our line edit what we are saying here we want to trigger the 10 text changed method and we can grab the correct text and show it before we do that to though let's go in our other thing and comment out to the line that prints the text because we are going to be printing a lot of links we don't want to be confused by this let's go and put in the slot that is triggered whenever the text changes so we can go down and actually do that okay we have our text changed slot and it is going to be triggered whenever the text changes you see we commented out to the print line here we just want to see the changes in our user interface this is okay let's show the terminal and run and if we say Daniel gray in here you see whenever we type something we will be notified and we will be responding in our slot here and this is something you might be interested in doing if you want you can even uncomment the line that prints something and run again if you do that you will see the changes both in the user interface and on the terminal here because that's where we are printing with the print statement here this is what the text changed signal does we can comment out to the connection here because we still have a lot to play with so let's do that we might also be interested in knowing when the cursor position changes and we can set up a connection like this to be notified and we need to set up this slot that is going to respond the slot right here the cursor position method is going to have two parameters one is going to be the old position the other is going to be the new position and how do I know this well the documentation let's go back to the documentation or queue line edit and we can see cursor position changed you can see that it has two arguments one is the old position the other is going to be the new but the QT documentation didn't care enough to name these things properly him on uqt this is bad you should name these things properly let's go back to our code though so we will do better old new we will know that this the old position and this is the new position and because of the connection we did here we will have access to these guys when this slot is triggered so we will be printing this lens here let's make sure we don't have anything else we don't want to see printed we have the Auto Connection commented out I think this is going to do what we want let's go up and run so we can run this and if we do you see the crucial position changing as we add events if we go back you see the cursor position is also changing this is really cool and at each trigger of the method we have the old position and the new position and this is really cool this is something you can do with this method here let's go up and comment it out we might be interested in knowing when the editing is finished this is another signal we have on the line edit component we will put in this method here so we can go all the way to the bottom and put in that method and let me extra we remove spaces we don't need and we have the connection and this is going to be triggered whenever the editing finishes and this is going to be mostly when the user hits enter on the line edit after typing in some text let's show our terminal window and we can go up and run and if we say DDD and hit enter this is going to say that editing is finished you see this is triggered when you hit enter this is all you can do with this signal here we also have the return pressed signal let's put in the connection for that and comment out what we had before okay and this is going to do the same thing as editing finished again I don't know why QT provides these two maybe they have a difference but honestly I don't know that difference yet let's put in this method implementation that's going to be return pressed we can go to the bottom and put this in return press if we run we should see that if we type DDD or whatever you type in your line edit and you hit enter you will know that return is pressed and again it's when you hit enter after you finish putting in some text in your line editor another interesting signal is one that lets you know when the selection changes in your line edit you might be interested in this in your QT application so when the user does something like this and selects okay you will be notified of the current selection and this is interesting in some applications so we have the connection and all we need to do now is put in the implementation for this method here so let's do that we can go all the way to the bottom and put in the method implementation selection changed we have the connection whenever the selection changes we call the selected text method to know the currently selected text and this may be important in your QT application so let's do that we can run this and whenever we can type in something let's say for example Jon Snow and if we select John you see as we select more things the currently selected thing is going to be shown here we just selected John if we select to know we will see that in our QT application here if we select the entire thing even backwards I think that's going to work you see we have Jon Snow selected and this is really cool this is something you can do in your QT applications the last signal we are going to process is text edited and as the name says it is going to be triggered whenever you have text changed in your line edit and I think it also provides two arguments showing the old text and the new text to be sure you can check the documentation for now I am just going to put in the implementation here let's go to the bottom looks like it only gives the new text which is yeah it's useful so we will be printing the new text here which is going to be passed to us in this signal here and this is really cool let's try to run we can clear and run I think this is going to conflict with other things now this is going to do you see whenever we change we have the new text show up and this is really cool let's type in something meaningful instead of this junk here so we can say Jon Snow you can see that whenever we change the text the changes are going to be reflected in our application here because of the connection we did and you can go on and play with more signals I think I gave you enough examples in this lecture here again the goal was to be able to play with q line edit and Q level Q level is going to be used when you want to show a piece of static text in your user interfaces something like this you can use q line edit when you want your user to type in a line of text and this may come in handy for example if you are setting up a form to collect information from the user the first name is the last name the address the job they do whatever you can collect all these things in your QT applications and do things with them this is all I had to share in this lecture I hope you found it interesting we are going to stop here in this one and I will see you the next one in this lecture we are going to look at the Q text edit component and this is a component that allows you to type multiple lines of text in your user interface or something like this and I am sure you have seen this in a lot of graphical user interface applications so what we are going to do is to set this up in a demo QT application using pi side of course and we will be able to type in the text get the current text in this component like we did for q line edit but we can do much more for example we have the capability to copy text to cut text to paste text we can undo and redo something you see in a lot of text processing applications and this is going to be really cool to set this up it's nothing really special all you have to do is to use the Q text edit component you will set this up in a widget that we will set up in a short while when we hit Visual Studio code and we will set up a bunch of buttons that are going to allow us to manipulate things in our text edit component one thing I want you to see is that for example to copy text from our text edit component we are not going to go through separate slot methods like we did before what we will do is take advantage of the fact that the text edit component itself already has a slot that is going to copy data so instead of delegating to a custom slot that we set up in our own application we will immediately call the copy slot in our connection here and this is something you might want to do in your QT application apart from that it is standard stuff we have been doing all along and it's really not going to be anything complicated now that you know this we can head over to visual studio code and play with us a little more here we are in Visual Studio code we have an empty folder that we will be playing with in this lecture here let's drag and drop it on top of Visual Studio code we will close this and create create our main Pi file Ty I mean let's do that and we will create our widget file like we always do and in our widget we will put in our starter code this is going to create a starter widget which is empty and notice the Imports we do here for the things we will be needing here so it's quite a lot make sure you put these things in once we have this in we will head over to our main file and put in the code that needs to be there it's just going to be creating an instance of our own widget and showing it nothing special here we can come back but before we do anything it is my Habit to try and run the code to make sure that I have no problems in there so let's do that we should see an empty widget popup and it does here now what we are going to do is set up our text edit component together with a bunch of buttons that will allow us to play with that the first thing we do here we are putting in a window title because this is a cute text edit demo we set up our text edit and if you go down for now you can ignore the connections we are doing here the first thing we are interested in is laying things out so that we can see them in our user interface we will talk about all these connections later so we have a copy button we have a cut button we have a bunch of buttons all the way to the clear button here now that we have them we need to lay them out and the way we want to do things we want all these buttons to show up in a horizontal layout that is going to be on top so these are going to be our buttons and below the buttons we will be putting our text edit component if I can draw it here so this other big thing below is a text edit component so this is going to be a horizontal layout and this is going to be our text edit component and they are going to be laid out in a vertical layout so we will set up this horizontal layout and add horizontal layout to the vertical layout after the horizon Auto layout decided we will be adding our text edit component I hope this makes sense so let's go down and put in our layouts we can do something like this we will set up our horizontal layout which is going to be an instance of qh box layout after that we will be adding our buttons to copycat paste and do reduce set plain text set HTML and clear after that we will set up the vertical layout which is going to be containing our horizontal layout and the text edit and notice that the text edit is set up as a member because of the self plan here and we are doing this because we will be needing accessing this in a bunch of slots that we will set up later the let's take out this connection because I think it might give us problems because we don't have this slot in yet and now that we have the vertical layout we can go below and say itself set layout and pass and this vertical layout I think with this we will be able to run our user interface and be able to see our text edit component along with the buttons that we set up here so let's clear clear properly and run the application and what is pro the problem here set plain text we don't have these guys yet I think we have a connection that mentions that plain text let's comment this out because we don't have this n yet and we can try to run again and if we do this is going to show up and the meter of this lecture really is to play with the Q text edit component that we have down here what you can do with it you can type text you can say the sky is blue I am and my city something like that you can really do all you want you can put in a lot of text and this is what you can do with something like this and you can see that using this as a business you can really set up something like the Notepad application you see in Windows here you can do something like this you see it does exactly the same thing now that you know how to work with Q main window you can set up a two main window object and put in these files and menus and whatever you can copy and edit you can do all kinds of crazy things you can see that now you even have the knowledge to be able to set up a status bar you can set up toolbars you can do all kinds of crazy things so now that we have this in place I think we need a way to play with us so the first thing I am going to show you is that we can copy the text in here and paste it but I think the most basic thing is to grab the text we have in our text edit component but before we even do that I forgot to tell you that you should use the documentation to learn about these fans so let's do qtext edit here okay so we can come in here and look at this and you can click on more to go down and learn all you can about this let's go to see the methods that this thing has so we have a clear append cut we have a bunch of signals we can play with this on this and I think we have a method called to play with text we can use to get to the current text in our text edit component here that's what I was looking for so what do we do I think we need to add another button unfortunately so let's do that I think it's going to be the first button so we're going to say current text button okay it's going to be a push button and it's going to say current text so we can put it in and we're going to connect click connect and we want to set up a method that says current text button clicked so we will go down and set up this method this is the usual thing we do we can go all the way to the bottom to the level of our Constructor we will Define this method it's going to be a member we can say a print the current text so what do we do we say self text edit to plain text this is something that is going to print the current text in our text edit component here and this is something we can do so let's run and see this in action and we can see this and if we say this guy is blue I love my city we don't have the thing in the layout so let's go back and add the current Button as the first thing in our horizontal layout we forgot that no problem we can fix that add with it and we're going to make this show up as the first thing in our horizontal layout now we can run if we do and type the sky is blue and put in some other text here if we get the current text you see that we can see this so we are able to grab the text in our component here now that we can see this we can play with the copy method or the copy slot if we go to the documentation for a q text edit let's go to the top again and look at the slots that we have available on this component we will see a coffee slot we can call it and what it's going to do it's going to copy any selected text to the clipboard any selected text from the Q text edit component here let's go down and play with us so we can open this up in our editor go to the point where we declare the copy button and what this is going to do it's going to call the copy slot and this is what I meant when I said we can avoid to set up our own slot and immediately forward the work to copy to the copy slot of the text edit component we can do it like we do here so this is going to work right away we can run the application and if you go down you see that we can also catch because we are forwarding The Cutting work to the cut slot of the text edit component here let's show our terminal and we can do something like this and run now we can say the sky is blue I think I don't need to type my text all the time I think we can copy from the QT documentation here to have some text show up in our text edit I mean we can paste here so once we put in some text we can select something and copy it okay how do I know it's copied it's going to be leaving on my clipboard I can even paste this in another application so let's open notepad and paste I am going to select and paste you see that I am able to copy from my QT application to another application this is really cool so let's cut because the cat feature is also going to work because again it is forwarding The Cutting work to the cut slot of our text edit component if we cut the text is going to go away if we cut the text is going to go away if we cut the tax is going to go away but we can't paste yet why because our paste button doesn't have a slot that can immediately paste connected let's do that to be able to really play with us so we can say self text to edit paste and this is going to forward the work to the paste slot that we have available in our text edit component again if you go to the top you can you see that we have a paste slot right here let's make sure it is highlighted so everybody can see it you can see it right here if you want you can click on it and you can see all about this slot here let's go back to our application and clear and go up and run again we can still copy from the QT documentation we can grab all this no problem so let's come back to our application and paste in and if we want we can um okay we can copy the entire thing here and we can go below here and hit paste and you see that we can paste text in here and this is really cool I can't tell you how excited I was the first time I could do this with QT but it wasn't with pi side at the time it was with C plus plus but the excitement is the same so we can copy cut and paste another thing I want you to see is that if you want you can set up your own paste slot so for example we can say something like this okay we will be calling our own paste slot and if we set it up we can copy and go down and set it up can say Define paste and it's going to be a method now once we are in the body of this method we can say self text edit and call the paste slot ourselves because we can do that this is something you can do and it is going to behave exactly the same way so let's do the paste button make sure it is working it should be let's go up and run we can paste in the code from what we have in the clipboard we have something from our editor don't want that so let's grab from the website here and we can copy the entire thing okay we click on the copy button here and if we go down we can paste again we can hit the paste button to paste if we want we can even cut so we select something we cut it out it's going to go away we select something else we cut it out it's going to go away and we can keep pasting and really playing with this to have as much fun as we can with our application here another thing you can do is undo and redo and I think again these are forwarding the work to undo to the slots in Q text edit if you go to undo you see it here if you look at redo you can see it here so I think we can even undo if we hit and do this is going to undo the operations we did before if we redo this is going to be redoing and you can do something like this let's look at set plane text set HTML we have the connections then but they are disabled because we don't have the correct slots implemented let's Implement these slots here so we can go all the way to the bottom and put these M and let's take out the space here set plane text is going to call the set plain text method so this is the method you can look up in the documentation and we will just put in a bunch of text that I stole from somewhere set HTML can say it HTML formatted text to your plain text edit component and you see I have a few things with a few HTML headers we have the BR tag we can set up a list and you can see it right here this is basic HTML if you happen to know something about HTML let's show the terminal and we will play with that a little bit and we can run okay if we do set plane text this is going to put in the text if we say set HTML you can see that our HTML is going to show up here we have a header we have an unordered list here and we have something this is something you can do in your application another thing you can do with Q text edit is to clear the text and you do that by calling the clear slot that we have in our text edit component if we go back to the documentation again that's the best source of information for you so let's look at the slots that we have we have a clear slot which is going to delete all the text in the text edit let's go back to our application and see that clear the text goes away set plain text clear the text goes away we can undo we can redo we can do all kinds of crazy things this is really all I had to share in this lecture showing you how you can play with Q text edit have as much fun as you can with this component and then we are going to stop here and I will see you in the next lecture in this lecture we are going to see another use for the Q level component and that's using it to show an image what we want to end up with is something like this we will have a level component contained in our widget window and that level is going to be displaying an image let's look at how we can do this it's really simple here we have our class implementation we will set up an image level that's going to be the name of the variable it's going to be a q level component and we will call the set Pixma method.net and give it the image that it is going to be displaying this image is going to be living in our project under the images folder and we will access it and display it in all level once we have the level we will add it in the layout and apply the layout to our widget and this is going to show the application that we see here now that you know this we're going to head over to visual studio code and do this here we are in our editor we are going to be working in this folder here if you look in it is an empty folder so let's drag and drop it on top of Visual Studio your Cody here and we will do the usual setup our main dot python file we're going to set up our widget file and in our widget file we will set up our class which is going to be inheriting from Q widget let's make sure you see all the Imports that we have here we're going to be needing a lot of these and we can go in our main file and put in our starter code which is going to instantiate our widget object and show it nothing special here now that we have this we can try and run it to make sure we have no problems so let's do that clear and run this should give us an empty widget and before we do anything let's make sure that our image is in the folder so what I am going to do I am going to grab an image that I have lying on my drive here I am going to hop over in my project that contains my main python file and paste in that folder I am going to share this project on GitHub so you can download this project and grab this images folder and use it inside you will find my image here called Minions and it is a PNG file now that we have this we can set up our level component let's go back to the widget file I mean we will set our window title in and set up our label component that's what we are doing here after we have this we need to set a pixmap to our level so let's go back to the label documentation we can go back there I really want you to see these things in the documentation so let's do Q level and if we go to the documentation it should have a set Pixma method set Pixma but we have that we have a pixmap method which is going to give us the pixmap which is really a representation of the image that is displayed in the level but I can't find the set pixmap function not shown here don't know why we have it as a slot so we have set pixmap here and if we go in okay we see set pics map this property holds the level Peaks map setting the Pixma clears any previous content and you can see all the information here so this is what we do with this you can look at the qpix map class itself let's go to the top they say what this class does it provides a way to show an image basically and all the information here you can read if you want for now we are going to come back to our project and say Image level set Pixma and we will build World a qpix map object in place and you build it by giving it a path to the image that it is going to be displaying in our case the image leaves in the images folder you can see here and it is called minions.png let's do that minion dot PNG and that's going to be our offend now what we need to do is to set up a layout so we can say layout equals Q you can use any kind of layout you want let's use QV box layout why not we will add thanks to the layout so we will be adding the widget that's going to be our Image level and after we do that we will set the layout to be applied to our widget here set layout this is the flow you have to drill in your mind if you want to work with layouts with them your QT widgets let's pass in our layout here and I think we have everything we need hopefully let's show our terminal window what do we have here the application is still running we can kill it and clear and run again and if we do look at what we see here we have our minions image showing up this is really how you use a level to display an image and this is really all we set out to do I hope you found this lecture interesting we are going to stop here and I will see you in the next one in this lecture we are going to look at cute size policies and stretches and this is a concept we use to decide how our widgets we have if the user interface grows or shranks we will start by talking about sites policies and a science policy is a property you can apply to your widget to decide how that widget is going to behave if the user interface grows or shrinks for example if we resize the in globin window here we have the option to let the level here and the line edit grow at the same time so the sound so the label is going to grow and the line edit is going to grow or we can choose to say the level is not going to grow it's going to say to the same width but the line edit is going to grow and we can control these things using size policies I know this concept can be hard to grab but you are going to see what this really means when we get it to run this in Visual Studio code in a minute another concept to that I wanted to cover before we head over to the editor is the concept of stretch and the stretch is a property that says how many units each widget is going to occupy in a layout what do I mean here if you look at our buttons.org in a horizontal layout I set them up in a way that the button that says one has twice the width of two and three here and you can set up by setting up a stretch so what I really did I said the button saying one here is going to have a stretch of two the two bottle is going to have a stretch of one the three button is going to have a stretch of one and at any point when the user interface grows horizontally the button saying one is going to be occupying twice the size occupied by either of the other buttons this is how you can say it using stretches and you can use these Concepts in your QT application if you happen to need that here is the code that is going to allow us to do these things here for example we have our level okay and the line edit and we can set the size policy you can say I want my widget to expand horizontally or vertically when the user interface that includes my widget resizes and if you want to expand horizontally you pass that as the first parameter of the set method here and if you want to expand vertically you pass that as the second parameter here in this case we are saying we want to expand horizontally for a design edit and we don't want to expand vertically so vertically we're going to be fixed this is how you say it if you want to be expanded in both of directions you can say it like we do here and this is going to work down here you see that we can do the same on the level component you're going to see the behavior of this when we hit the editor in a minute down here we have the layout the usual thing you already know now we can look at switches and a stretch again is specifying how many units each component is going to be using in the layout in the example I showed I had an example where the first veteran occupied twice the space occupied by each other button here so let's make sure I can at least try to visualize this so suppose the first button here has two units okay it occupies two units and each other one is going to be occupying one unit you specify your stretch as the second parameter to the add widget method so we are saying that button one is going to have a stretch of two button two is going to have a stretch of one and button three is going to have a stretch of one and we can add these guys to the layout to show them in our user interface now that you know this we're going to head over to visual studio code and see this in action here we are in our editor Visual Studio code we have an empty folder that we will be using for this project here we can drag it and drop it on top of Visual Studio code once we have this opened we can create our files the main python file and at the widget python file once we have the widget python file we can put in our starter code we have that right here and we just set the window title this and we can head over to the main python file and put in our code which is going to import the components we need we are going to set up our widget and we are going to show it we can try to run this to make sure we have no problems so let's show our terminal here and clear if I can type and we can show the application we have our widget here everything is working as expected the first thing I am going to do is to set up my components so that I have my full user interface once we have it we will play with size policies and stretches so we have the level and the line edit we will go down and set up the layout that is going to be containing our line edit and level and this is nothing complicated so what this is going to do is to set up a horizontal layout and it the horizontal layout is going to be containing our level and our line edit this is what we want to do here we also want to set up another layout which is going to be containing three buttons and these are going to be laid out like this this is the goal we have using stretches so the first button is going to be occupying twice the space occupied by the other buttons let's go down and put in the buttons let's put in the buttons here I am going to paste them in to save on some typing time here button one button two button three and we will add them to their own layout once we have this we will set up a vertical layout on which we will be adding these layouts here to have them on separate rows each one being horizontal if that is making any sense okay we have our vertical layout we can add in our horizontal layouts and we set the layout to the widget here okay now that we have this I think we can actually take out the second parameters for add widget here because we will add them when we want to play with stretches for now we want to see our user interface and I think we have it set up again if you are confused we have our label component the line edit we are laying them out horizontally so the label is going to be to the left the line editor is going to be to the right after that we set up our buttons one is going to say one two two and three they are going to be saying one two three here and we laid the buttons in a horizontal layout as well after that we will be setting up a vertical layout which is going to be containing those two layouts again to the top we will be having our line edit and our level so the level is going to be to the left and the line edit is going to be to the right down below we will have our buttons so at this point we don't have any stretch applied so they will have the same size as I can roughly draw here this is what we intend to see when we run the application let's go to view and the terminal and we can run again if we do we should see our user interface and let's try to play with it and see what is happening here so if we resize the user interface horizontally you see that the level which is saying some text here is not growing but the line edit on top is occupying all the space down below we can see that the buttons are all growing horizontally at the same rate and this is the default Behavior we have for buttons in the layout let's try to expand vertically and see what happens you see the buttons don't expand and the line edit and the level don't expand vertically so let's try to use size policies on the line edit to simulate the behavior we have by default so what we can do is go to the line edit component here we can say line edit set size policy because this is the method that is going to be setting our size policy and we can tell that Q science policy horizontally I want to expand so it's going to be expanding horizontally we can say it like this but vertically it's going to be fixed so let's do that Q size policy fixed you can say that here and this is going to be simulating the default Behavior we just experienced in a minute let's try to view and the terminal and try to run if we do and we try to expand horizontally you see nothing changes because we are simulating the defaults if we're trying to expand it vertically we're going to see that we're not going to expand vertically but if we want we can set the size policy fixed even horizontal let's see what happens if we do that so we're going to say fixed here if I can type that and we are going to run the application again now we have the application and you see that if we expand horizontally the line edit is going to have a fixed size it's not going to grow whatsoever and this is a setting you might want to do if this makes sense for whatever you are designing your user interface for I am going to turn this back to expanding but another weird thing I want you to see is that you can set your line edit to expand even virtue so we're going to say it's random here and if we try to run again we will see that it will try to occupy as much space as possible vertically you can shrink it it's going to go down but if we go up we're going to see that it's going to be growing vertically and it is still a line edit even if it doesn't look like so so this is where you shouldn't really do that I am doing this to show you the effects of size policies in your applications let's turn this back to fixed you can also apply size policies to the level for now the label is not expanding either horizontally or vertically but we can play with us and really make it to do weird things so let's shift alt down to copy the line we're going to make this apply something on the level and the level is going to be expanding as well horizontally because that's the setting we have here let's see what happens and we can run and it is level with lowercase I think that's the problem here let's run again now it's going to run and you see that the level now is occupying space all of this space you see down here which is gray is occupied by the level and it is growing horizontally as well we can also set it to grow vertically but we're not going to do that you can play with it if you want my intent here is to show you how to use science policies to your advantage and the main intent for size policies is to Define how your widgets are going to behave when the user interface grows or shranks if the user interface grows your widget may decide to grow horizontally or vertically and you can control these properties using site's policies now that we have this out of the way we can focus on stretches stretches control how much space is occupied by each widget in the user interface for example if we run the application again let's do that we see that our buttons are occupying the same space so you can say that each widget is really occupying one unit of space because they are all occupying the same space to kind of simulate the default Behavior we have we can specify a stretch as a second parameter to the add widget method as we saw but we will be using a stretch of one okay so the unit is going to be one and each of these widgets is going to be occupying the same space in the layout this is something we can do let's scale the application here and run it again you're going to see that it is going to be doing exactly the same thing but now that we know about stretches we can decide to choose one widget and tell it to occupy however many units we want so the unit is one but we want the first widget to for example occupy three units with this setting button two is going to have one unit button Loop 3 is going to have one unit but button one is going to have three units let's try and run we expect button one to occupy three times the space occupied by button 2 and button three that's the setting we have here and if our user interface grows you see that that's going to be three times if you measure this you're going to find that out I think it is easier to see it if we set button one to two so let's do that and as we grow now button one is occupying two times the space occupied by the other buttons here you can see that right here this is really all I had to share in this lecture showing you how to play with size policies and stretches use this if it makes sense in your QT applications we will stop here in this lecture and we'll see you in the next one in this lecture we are going to look at the cube read layout component in your QT applications and this is a component that allows you to lay out widgets in a grid and it's really likable so you have a table here which has three rows and three columns as you can see here and the first thing here is going to have an index of zero zero so it's going to be at row 0 column zero this is going to be at Row one column one that should be this thing here if you target this linear it should be at row two zero one two and column two you use these kinds of indexes to Target where you want your widget to show up in the grid layout now that you have the idea let's see what we can achieve with this in this lecture we will be setting up a user interface like this this is going to be a grid but you see that we have the ability to tell a component to occupy more than one row or more than one column and we do this with a property called row span or column span and we do that in code as you see here so here is an example we have our buttons we are setting them up button one all the way to button seven we set up a grid layout component and we specify the location where the buttons are going to leave for example button one is going to be at 0 0 so the first one is the row the other one is the column button two is going to leave at 0 1 button 3 is going to leave at one zero button 4 is going to leave at 1 1 and all the way to button 7 which is going to be leaving at 22 and you might be asking what are these additional parameters you pass when you set up button two and button three well this is because we want to set up a structure like this so suppose we have three rows and three columns let's try to do this as evenly as I can and we want button one to occupy slot zero zero that's going to be this guy here zero zero zero zero column that's the minion and we have button 2 occupying zero one so this is going to be button two button two is way to occupy one row okay the additional parameters are going to be specified the row span and the column span and this button is going to be spanning one row and two columns so button two is going to show up throughout here okay this is what we want to do for button three it is going to be at index one zero so that's going to be our three here but it is going to take up two slots vertically the rose band is two that's what we see here and down below this should be three two if we go to button four it's going to take one one so one one that's going to be our button four and you can keep completing these things as you see but the main idea is that button 2 is going to occupy two columns because we have two as the column span and button three is going to occupy two rows because we have a row span of two hopefully this is making some sense and if you go to the top you see that we are setting up a size policy for button three because we want it to expand in all directions to occupy as much space as possible and that's going to allow us to have a user interface like this that we are after now that you notice we can head over to visual studio code and play with us a little more okay here we are in our editor the current project is going to be living in this folder here grid layout we can grab it and drop it on the Visual Studio code editor and we are going to create our files main.py as usual and we want to do widget that P1 once we have this we will put in our code for the widget usual stuff really make sure you see the Imports we have here you can see them all but we will be needing some of these and we can head over to the main file and put in our starter code make sure this runs so let's bring up terminal and run this and we should see an empty widget now that we have this running we can come back to our widget and actually set up our buttons remember the user interface we are after we have a bunch of buttons so we have button one all the way to button seven here they have names one through seven and we are going to use the grid layout to show them in this widget here so let's go down and make sure we set up our layout here it is going to be a grid layout to be able to use this you need to have imported Q grid layout I don't think we need the horizontal layout here we don't need the vertical layout here if we need them we will import them back but if you have Imports you don't need you can take them out here so do we need to line edit we don't I think let's remove that and we will need the size policy in a minute okay now we have the layout and one thing I want you to see is that we specify the location where the widget is going to show up in our grid layout using indexes like this so we have the row position and the column position after that you may also specify the rows panel like we do for button 2 and button three in this case button 2 is going to take up one row and two columns button three is going to take up two rows and one column and that's going to give us the user interface we want once we have this we can set the layout to the current weather layout and it's going to be grid layout you can do that and I think we can run the application and see our user interface in action let's go to view and terminal and run if we run we will have our user interface you can see that button 2 is taking up space for two columns okay and button three is taking up space for two rows but we can't see this because we didn't instruct this button to expand in all spaces as much as it wants so let's do that we are going to go back to the code and enable this line that sets the size policy to expand in all directions once we do that our button is going to expand and fill as much space as it can and you can see that it is working to our advantage now this is really all I had to share in this lecture showing you how you can use grid layout use it if it makes sense in your QT applications we are going to stop here in this lecture and I will see you in the next one in this lecture we are going to look at the Q checkbox and Q radio button components in your QT applications and these are things you use to let users choose options in your applications for example you may want your users to choose an operating system that they like and you may want to give them the option to choose multiple choices so you can let them for example choose windows and Linux or either of these options another option is to let them only choose one and if you want to do that you may do something like this using radio buttons if they choose one the other is going to be disabled and at any point they will only be able to choose one thing so they can either choose a b or c but they can't have a and b enabled at the same time and this is what we call an exclusive button if you want you may also set up a checkbox to be exclusive and I will show you how to do this in a minute but this is what we are after in this lecture here we will build a user interface like this using qradio button and Q check box here is a simple example of how you can set up nonexclusive checkboxes in your application and the main message I wanted to convey here is that if you want to group a bunch of check boxes you will put them in a group box this is something very crucial to be able to work with these components so we will set up a group box for the operating system that's what I'm in here and we will set up our check boxes we have a Windows checkbox we have a Linux checkbox and we have a Mac checkbox and we are doing some connections here to know when the user toggles the checkbox but for now let's worry about laying these things out once we have the group box we will set up a layout that is going to be shown in our group box and we will be adding these check boxes to the layout this is a bit convoluted but this is really what we have to work with in QT so again we have a group box we have our check boxes and we will be adding the check boxes to the layout that is going to be shown in our group box so we will be adding the windows Linux and Mac checkboxes to the layout and after that we will be applying this layout to our group box this is what we do here and once we do this our group box is going to be kind of wrapping around our checkboxes and treating them as a single unit you can move around if you want to do that and we will see that we can add this group box to other layouts to really have a complex user interface in our QT applications here you see the slots that we will be using to know when the user toggles our checkboxes if they toggle the windows checkbox this method is going to be activated if they toggle the Linux one we will activate this if they tackle the Mach 1 will activate this nothing special here if we go down we will see that we can also set up exclusive checkboxes and the meat of this is to set up a button group again that is going to be logically grouping these buttons together and once you have this button group you can say that you want them to be exclusive by calling to set exclusive and passing in a true value and this is going to make these buttons exclusive once you do this you want to have the option to choose multiple options again we may have something like this for checkboxes and once they are exclusive you can only have one chat you can't have more than one selected and that's the behavior you have with the exclusivity here if you wanted the default exclusive Behavior you can use radio buttons and again they work the same we can have our group box here once we do that we set up our radio buttons we will be adding the radio buttons to a layout okay and we will be applying this layout to the group box that we have here using the line here now that you know this I think we can head over to visual studio code and play with us a little more okay here we are in our editor the folder we will be using is right here so it is an empty folder we can drag it and drop it on top of Visual Studio code this is going to open it up we are creating our main python file and the widget file and we put in our starter code for the widget we can head over to the main file and also put in our code and let's see if this actually runs before we do anything else this is my habit if we run we will have our empty widget and we can start doing our crazy things here let's come back to the widget and remember we are after a user interface like this the first thing we're going to do is to set up this group of check boxes we can do that by coming up in our Constructor and setting up that group I am going to put in the code to save on some typing here and I will do my best to explain this so this is going to first to set up a group box okay as I said it before you can think of a group box as a container of check boxes okay in this case we are interested in check boxes suppose we have three checkboxes in here we are going to put them in a group box and it will be this group box that we move around but to have it set up we have to actually set up our check boxes that's what we do here we have one for Windows one for Linux one for mac and once we have the check boxes we will set up a layout that is going to be within this grouper box here so this is going to be our layout and we will apply the layout to the grouped box this is the setup we have here take a moment to really understand this it is a bit convoluted but once you understand this it's going to be a piece of cake to work with checkboxes and radio buttons in your QT applications okay we have our checkbox but we can't really see it yet let's see what I can do to be able to see this and increase the complexity of our user interface as we go I think this is going to be a good exercise what we can do is set up a layout so let's say layout and we are going to say QV box layout it's going to be a vertical layout we will add our operating system group box to the layout add the widget I want to get autocomplete here because I am lazy so we want to add OS which is a group box and we want to set the layout to the current widget here so we're going to say self set layout and we want the layout applied I think if we run we should see our checkboxes showing on our user interface so let's do this we're going to show the terminal and run and what do we have here no attribute Windows tackled so we have connections that are not working yet let's comment this out because they are going to just give us a hard time here and we can try to run again and if we do notice what we see we have our group books and we have our check boxes and we can check them all if we want or we can check two or we can check one because this is not exclusive so you can have multiple ones selected and once we have these we may be interested in getting the information out of these guys for example if the user checks windows we want to do something in our application to take into account that the user choose the window checkbox here and by connecting to the toggled signal so we're going to set up these slots here let's activate these connections that we did here and I think we can put a space in here to make it easier to read and let's put in these implementations so let's go all the way to the bottom where we have our Constructor defined and we are going to Define our 2 or 3 method implementations notice that we have a parameter how do I know we have a parameter well I read the documentation for the signals for checkbox let's go there to do this together so that you can really see what is going on here let's do Q check box but it is the same thing you have for Q push button so it's kind of a repetition here but I am going to show you that anyway if you look you see that we don't have the signals the same behavior we saw for the Q push button but we can go to the parent class and what this says is that really 2 checkbox has a lot of things it shares with Q push button it just happens to display differently but because it inherits Q abstract button it shares many behaviors with Q push button I want you to keep that in mind let's go to Q abstract button if we go to signals we will see that we have a toggled signal that happens to send a parameter and this is what we are going to catch and to decide whether the radio pattern is checked or not checked this is really cool let's come back to our code and we can look at our method here if checked we will so that it is checked if it's not checked we will say that it is unchecked the same applies to Linux and Mac here we have done the connections so this should work if we run the application let's show our terminal window clear and take out all this garbage we have here and we will run if we check window cells Windows is checked if we uncheck windows it's unchecked let's do the same for Linux you see it works let's do the same format you see it works this is really how you can process this information in your QT applications now that we have this we can set up an exclusive set of check boxes let's go down and do that and I think we can go down below here and say exclusive checkboxes and this is going to be allowing the user to choose ranks this is what we do as an example here and what we do here we will set up a group box okay just like we did for check boxes and we will set up a beer checkbox a juice checkbox and a coffee checkbox we will set the beer one checked by default you can do this programmatically adjust the left in this line to be able to show you this and we will set up a logical grouping of these buttons so that we have the ability to set them to be exclusive so this is how you make them exclusive once you have this you will set up the layout like we did for the other checkboxes we will add them to the layout and we will apply the layout to the drinks group box here once we have this we can add this to our user interface but we will have to change the layout a bit for example we can change this to be a horizontal layout okay we can do this and after this we will add the other group box which is going to be containing our drinks let's copy the name here because I tend to forget these things and mess up so let's do layout add widget and we will be adding our drinks group box if we run we should see this showing up on our user interface let's do terminal and run you see we have our drinks and because this is an exclusive set of check boxes we can only choose one at a given time unlike what we can do with the other one for the operating system so you can choose whatever you want in your QT applications let's show you how to work with radio buttons and the behavior is really going to be the same so we can go down and set up a set of radio buttons let's do that I am going to go down here and do that we have our radio buttons here again we have a group box which is going to group them together we set up the radio buttons we set one to be checked by default and we will set up a layout that is going to be applied to the group box we added things to the layout and we apply the layout to our group box here and if we want we can add this to our I think we put our code here in the wrong spot so let's cut this out we don't want to mess up our layout here so we just go below the group for exclusive check boxes and we will put our code in here sorry for that if it was confusing and we will go down and add this to the layout so we can say layout add Twitter and that's going to be answers I think so let's do that answers and if we run okay we can run the application we will have our fan here if you want we can even achieve what we saw in the slides here so all we have to do is set up a vertical layout and add the radio buttons to the bottom of the vertical layout we can do that we already know how to do that let's come back to our code so what we need to do is to take this guy here out of our horizontal layout and we will set up a vertical layout that is going to be the actual layout of the user interface so let's say we layout equals QV box layout and we will name this horizontal layout to be selfdescriptive here I don't want the code to be confusing good names are really important you should focus on that make sure the names describe what you are doing in your user interface we have the vertical layout so what we do with the vertical layout we will add the horizontal layout so let's do V layout add layout and we will be adding the H layout that we have set up in our code and after this we will be adding the answers group of radio buttons so let's do the layout add widget answers answers and we will be setting V layout as our layout here I hope you can understand this if you don't please go back to the point where we talked about layout in a bunch of Widgets or you can even ask me I will do the best I can to help you out let's view our terminal and we can clear and run if we run we will have our user interface and ladies and gentlemen this is what we set out to do in this lecture I hope you found it interesting we are going to stop here in this one and I will see you in the next lecture in this lecture we are going to look at The Cue list widget component this is a component that allows you to lay out things in a list in a widget so for example you can set up a widget like this and we have a list of things we have one two three we can even add more and we will see how to do that and you can really use it if you need this kind of list in your user interface in this lecture we will see how to set it up so we will set up a class and set up our widget we will see how to add items we will see how to remove items we will see how to get how many items are in our list we will see how to get selected items and we will get the list of items and print them out to really give you a foundation on using this component in your own QT applications this is how we're going to set it up we will have a list widget component and this is going to be our variable once you have it you can choose to set the selection mode and what this really means is whether you allow users to only select a single item or to be able to select multiple items and you can control this using this setting here you can add items using the add item or add items method and you can connect to a bunch of signals to know whether the current item has changed or whether the current text has changed and you can check the documentation to see other signals that are offered by this component down below we are setting up a bunch of buttons to be able to play with this component and you can see that we can also set up a bunch of methods that are going to be triggered when we do things in our list widget for example this method is going to be triggered whenever the current item changes we will be able to print the new current item we will be able to respond when the current text changes we will be able to call this method to add items and really all these methods to do all kinds of crazy things now that you know this we are going to head over to visual studio code and play with us a little more here we are in our editor this is going to be our current project folder it is empty as you can see now let's drag it and drop it on top of Visual Studio code here this is going to open our project and we can create our files so we needed the widget file and we will put in our starter code which is going to give us an empty widget with a title here we can head over to the main file and put in the code that you are familiar with by now and we can view our terminal to try and run the application to make sure this is working as we want let's run it this will pop up our empty widget here the first thing we want to do is to set up our list widget and we have the needed components imported if you go to the top here you see that we are importing Q list widget we can go down and create a variable for this which is going to be a member of this class here because of the self thing we are doing here this is our list widget we need to give it a parent and we say that we want to be able to select multiple items using this setting here once we do that we are going to add items you can either add a single item using the add item method as you see here or you can use the add items method once we have this I think we can set up a layout let's use a vertical layout so we are going to say V layout QV box layout and we are going to say V layout add the widget add the widget that's going to be self with list we get and we will set this layout to be used by the current widget here so we're going to say self set layout and we will use vla out here and I think if we run we will see our list widget with the three items of data that we have added so let's view terminal and run this and if we do this you see that we have one two three and this is what you can do with a list widget now that we have this we can connect to a bunch of signals from cue list widget but before we do that I think it is a good idea to come back to the documentation so let's say Q list we get here and we can look at what it has to offer I do recommend reading as much as you can on this especially if it is the first time you use this component here so come to more look at what you can do with that if you go to the top you're going to see a bunch of signals you can use if we can find them you see we have a lot of signals that we can play with we have a lot of slots we can play with make sure you look at those that interest you and read the documentation to really know what these things do let's come back to our application and we will put in a bunch of connections here once we have the list widgets set up we will connect to the current item changed signal and the current text change the signal and if you want to know what these signals do again use the documentation to your advantage current item changed let's see what happens here current item changed if we go to the signal this property holds the row of the current item they don't say anything about this signal here and this is a bummer this is really bad because QT should say at least something about this but they don't this is going to be triggered when you change the current item in your list widget if you wanted to see a good documentation for QT for example if you think that the documentation for acute for python is lacking in some way you can use the C plus documentation and all you have to do is say queue list widget and say qt6 for example this is going to give you the C plus plus documentation okay I think I should have said this somewhere I will update the course to be able to say that so we have cue list widget if we go down we see the properties let's look at the signals current item changed and at least they say what the signal does this is what I mean when I say that the python documentation is still lacking so if you want you can use the C plus documentation like I do here or you can use the python documentation we have been using all along let's come back to our project and we need to set up these methods that are going to be triggered when these signals are fired we can go down and put in our method definitions you can do that we have current item changed and you see the signal is going to give us the current item the new item if I can say it like that and the current text change the signal is going to give us the new text let's try to run this and see what happens so view terminal and run this and I think the application is still running but no big deal we can run it again let's go to okay so let's run and if we click on one this is the current item if we click on two we see current item and we can click on three to see the current item and they tell you that the current item text has changed so you can use these signals if you want in your QT application okay now that we have this working we can add a bunch of buttons that will allow us to manipulate our list widget for example we might want to add a new item to get to the current item count and things like that let's do that so we will create a bunch of buttons here and I also put in the connections to be able to connect to the slots directly to save on some time once we have this we will add these buttons to our layout so let's do that we will say video add widget add widget should type that button add item this is the thing we can copy this shift out down to copy the line the other is going to be button delete item let's do that delete item we can copy again line that's going to be button item count button item count and the last one is going to be button selected items and once we have this we should see our buttons in the user interface let's see if we actually see them view terminal run the application and the button add item clicked connect itself add item what is going on here we don't have the the method implementations for the slots we are connecting to our signals so I think it is a good time to add them here so what we can do we can come down to the bottom and I think it is a good idea to actually separate this method definitions okay so let's do that this one is going to be triggered when we want to add a new item and you can see how we are adding a new item we are just calling the add item on our list widget component if we wanted to get the item count we call the count method on our list widget if we want to delete delete an item okay we will call the take item method on our list widget and we will give it the character row okay and this is going to remove the currently selected item this is how we are doing these things here if you want you can Loop through all the selected items and you get a list of selected items by calling the selected items method and you can Loop through this list printing each item's text this is how we do this so let's try and run the application now we can clear and run now the application is going to come up okay if we add item you see we are adding a new item this guy is going to be triggered let me make sure you can see this if we click delete item this is going to delete the currently selected item let's make sure the currently selected item is 2 here if we delete two is going to go away if we click one is going to go away and if we delete new item is going to go away and you see that we have a problem because now current item changed is not going to find the current item to print so this is a problem you might want to fix but we're not going to handle errors here you can handle them in whatever way you usually handle errors in your python applications this is really all I had to share in this lecture showing you how to use the list widget component you can use it if you want to show a list of items in your widget applications and you can check the documentation to see more things you can even do then I had a chance to tell you about in this lecture here I am going to stop here in this lecture and I will see you in the next one in this lecture we are going to look at the queue tab widget component this is a component that allows you to set up a user interface like this in which you have multiple parts of your user interface that you want to tell go through for example here we have the same widget shown in two states the first report is going to show this information here the second part is going to show these buttons but you can toggle between these by clicking on these titles here so if you click on information it is going to show this little widget if you click on buttons it is going to toggle to the state down here and you are able to toggle between different parts of your user interface this is good if you want to set up settings for your application for example and there are many uses for this kind of widget we are going to see how to set it up in your QT applications and we will see how to add tabs and how to use components inside separate tabs the first step to working with this is to create an instance of it in your python application so that's what we have right here and after that we will create our sub widgets if I can call them like that the first one is going to show information it's going to be an instance of Q widget and we will put things inside okay so we have a level and we have a line edit and we will set up a layout that is going to be containing this level and the line edit as we do here and we will apply the layout to our widget here we also set up a bunch of buttons so button one through button three We'll add the buttons to the layout and we set to the layout to the widget here once we have these sub widgets we will add them to our tab widget by calling the add tab method as you see right here once we do that we will specify the widget we want to add and the title information for that widget once we do that we will set up a layout that is going to apply to our container widget and we apply the layout to our widget here and once we finish this setup we can run the application and we will see something like this popup now that we notice we can head over to visual studio code and actually do this okay here we are in our Visual Studio code editor the project is going to be leaving in this folder here 12 Hue tab widget you can drag it and drop it on top of Visual Studio code here the first thing we want to do is to create our files so that's going to be mainly.py and the other one is going to be widget.py let's do that we can go in our widget and set up our starter code for the class it's going to be inheriting from Q widget as usual make sure you see the Imports we have here so these are the things we're going to be needing once we have this and we can go to our main file and put in our starter code if you don't want to type this code you can copy from the resource section of the lecture you're going to find the code here you can even download from GitHub if you want to have all the code for the course in one place on your local drive you can use the course however you see fit let's go to terminal and run this and we can run the main file and this is going to give us an empty widget on top of which we can start setting up our qtab widget before we even do anything I think it is a good idea to go to the documentation and look for qtab widget Q tab widget so we can open it for a cute for python here and if you go to more you're going to read all you can about this okay so make sure you read this if it is the first time you use this component here you can see it has a bunch of signals it has a bunch of thoughts you can really do all kinds of crazy things let's come back to our project here in our widget file and we will set up our tab widget so let's do tab widget equals Q tablet and we will pass a current after that we will set up our sub widgets just like we showed in the slide so I am just going to put in the code here first one is going to be information which is going to take the full name of a person and we will store that in the memory of our application after we have the components set up we are going to add them to a layout that we will then apply to our widget here this is going to set up our widget here we will set up another sub widget which is going to be a widget containing a bunch of buttons one two and three here we are just connecting to the button to show you that you can respond to this clicked signal from this button and once we have these guys we can add them to our tab widget so let's go down and do that we are going to say add tabs to widget and we will say tab with it add tab we can do that you see that you can really add a lot of things you can even add action if you want to you know what this method does please use the documentation for now we will just add the tab and the first one is going to be widget form let's do that and the text is going to be information we will add another one tap widget add Tab and that's going to be widget buttons and we can say buttons here you can really put in whatever text you want so why do we have this squiggle here it must be Visual Studio code getting confused now that we have this we will actually set up the layout let's do that so layout equals QV box layout it's going to be a vertical layout because that's what I prefer we will add the things to the layout and what we add is going to be we need to put a comma here okay let's make sure we do that and we put in a closing double coot now we can do add widget and add our tab widget once we do that we will set the layout to be used by our entire widget here so self set layout and that's going to be our layout here if we have this and run the application we should see our tab widget let's make sure we view our terminal and to make sure we can run this but before we do I know a problem we're going to have we have a connection to a slot which we don't have defined yet so let's go down and do that before we actually try to run So Def we Define the slot it's going to be a member and in the slot we print button clicked we can do that now we can actually try to run the application the code is going to auto save now you see we have our tab widget exactly like we saw in the slides you can resize this if we want this is going to be the minimum size by default we can type in something the first let's say John snow or we can change to the other thing click on button one you see our slot is responding if you want you can also connect to these other buttons but again the main point is to show you how to use qtap widget in your QT applications and this concludes what I had to share in this lecture I hope you found it interesting I will see you in the next one in this lecture we are going to look at the Q combo box component this is a component that allows for the user to choose between a selection of items and it is easier to show it than to talk about it so the component looks like this when you click on this little icon this is going to pop up allowing the user to choose something and if they choose something that's going to be the current item in the combo box here this is how you use it you can get to the camera diagram and use the data to do things in your QT application let's see how you can set it up and here is the code you created by using cucumber box just like we do for other components this is going to give us a variable that we can work with in our application once you have the variable you can use it to add items to the combo box and these are going to be the set of things the user can choose through we will use a bunch of buttons to play with combo box for example we can get to the current value we can set a new value to the combo box we will see how to do that and this is really going to set the current value and we will get the values in our combo box we can do things like this and down below we have a bunch of buttons that are going to help us use this and let's take a look at the slots that we will be using to get to the current value we will be calling the current text method and we can also call the method to get the current index if you need that in your QT application we can also set to the current item by passing in the index so we will say the current item is the second item in the list or the item that is at index 2 and because indexes start at zero this is going to be the third item in the list you need to be careful about this if you want you can even get all the values in your combo box and here we set up a simple Loop to Loop through the items printed each item at an even index in your combo box now that you know this we can head over to visual studio code and actually play with us here we are in our working folder the current project is Q combo box you can see that it is empty here let's drag it and drop it on top of Visual Studio code and we will create the files that we need we have main.py the python file the main python file and we have widget Dot py and we will put in our starter code we can also go in the main python file and put in our main code and once we do that we can bring up our terminal window and try to run the application to see if we see our trusty empty widget here we have it let's go back to widget here and we will go down and set up our combo box it is really nothing special you already know how to do that from the slides so we will create create our combobox component we are using self here because we want it to be a member of this class and that's going to give us the ability to call it from methods because we are using a bunch of methods here that are going to be manipulating our combo box so let's do that we have our thing here okay now we have the combo box we have a bunch of buttons that we can use to manipulate the combobox now we want to lay things out so we will set up a layout and use that layout on this widget here let's go down and do that we will use a vertical layout as we always do let's align this properly so we will have our vertical layout we will add our combo box we will add our buttons and we will set this layout as the layout for the current widget let's run and see view terminal like we always do if we run we should see our thing here and now you can look at what a combobox says it is this thing on top which says Earth if we click on this down error we will have an option to choose one of the planets here for example we can choose Mars but we can also use these buttons to manipulate things in our combo box on top here let's put in the methods and I am going to explain them one by one because now you are a master at using QT so many of these things I don't need to explain line by line by typing each one so let's go down and put in our methods the first method is going to be getting the current value and it is going to be using a bunch of methods on the Q combo box class let's go to the documentation and actually show you the documentation for this I really encourage you to use the documentation as much as you can kill combo box and we open this up you can read more you can see the methods the slots the signals you can use to play with us you can really do all kinds of crazy things let's come back to our project so you can look at current text and current index we will use the Set current index method to set the current index and we can Loop through the values in our combo box printing the text and the current index we might be at in our Loop let's view terminal and run the application to see this running we will see our user interface here and if we get the current value and you see that the current value is Earth we can select Mars for example if we print current value it's going to say Mars at index 2 we can select proton if we get current value it's going to say the current value and the index and we are able to do that because of the current value method we have set up here we can set the current value to be something at index 2 and that's going to be Mars if we get to the current value we're going to get Mars we can print all the values we have in our ascent and the indexes and this is working exactly as we want this is really all I had to share in this lecture I hope you found it interesting we are going to stop here in this one and I will see you next time in this lecture we're going to see a way you can design layouts and user interfaces without hard coding them in your python code like we have been doing so far and we will be using QT designer QT designer is a tool that allows us to build user interfaces just by dragging and dropping components and that's going to give us a cool user interface we can just Import in our python code and use it right away the user interface is going to look something like this this is just a simple introduction we will have time to install this tool and see how to use it but you can see the idea here for example to set up this button I did here all I had to do was to drag and drop this UI component on my formula here and that's going to give me a format you can use and you can see we can do all kinds of crazy things on top here you can see we can do a bunch of layouts we can really build all kinds of crazy interfaces using cute designer so this chapter is going to be about using cute designer we will see how to install it we will see how to create these UI files and we will see different ways we have to import this user interface files into our PI site 6 applications and that's going to be really cool once you design your UI files what you will get out of QT designer is a DOT UI file and it is this kind of file that we will be importing in our PI side application one thing you should know is that we have two way to get access to QT designer you can use the QT designer application that comes bundled into your QT installation or you can use cutecreator one thing I have to say which is a bit inconvenient is that we don't have immediate access to these tools when we install Pi side like we have done so far so what we will do in this lecture is install QT which is going to give us access to the these design tools we will install the C plus plus side of QT that's what we are going to install here and that's going to give us access to QT designer and cute Creator to install QT all you have to do is come to your browser and say QT download that's going to give you a length looking something like this let's open it okay once you are at the QT website you can see we are at qtio slash download once you are here you will click on download try and on this page here we can scroll all the way to the bottom and say download for open source users because we are just interested in the open source version of QT so click on go open source here and once you are on this page you will scroll all the way to the bottom where it says download the QT online installer and you will click on this button they are probably going to detect your operating system once they do you will come all the way to this the location here and hit download and this should start to download in the QT for you here you can see that it is downloading from me but I already have this so all you need to do is to wait for this to download open this file and let it install QT once you have that file downloaded you will double click on it or click on it to start installing QT once you do that you will get a user interface like this asking you to login so if you don't have an account you will create it once you have your account and your credentials you will just hit next here and you will go through a series of steps helping you install QT one thing I should say is that if you get a list of options telling you what you should install make sure you click on custom installation that's going to land you where we are about to go in a minute I can't really show you the exact steps because I already have QT installed on my system here so I am going to do the best I I can to guide you through this but if you choose custom installation and then hit next you are going to land in a place like this once you are here I want you to click on QT and if you click on that you are going to get a series of options make sure you choose the latest version the latest version at the time of this recording is qt640 as you see here that's what I am going to choose I am going to expand that and I am showing you the steps here for Windows and they are going to be similar for Linux and Mac once you are here on Windows you can either choose minty W here or msvc I do recommend using minty W because it is hassle free it's going to be easier to install this if you use msvc here you will need to have the Microsoft Visual Studio IDE installed so if you don't want the visual studio thing just use mintyw here it is going to give you everything you need if you are on Linux you are probably going to see a GCC version here if you are on a Mac you are going to see something saying clang or whatever so make sure you check one just like I have minty W checked here and you are going to click on this button that says next door install or something once you do that you will keep hitting next until you start installing you will age for QT to be installed and at the end you will have a QT installation on your system one thing I should say is that mine is installed in cqt which is going to be the default suggested by QT so after you install QT you will have a cutie folder in your C drive or wherever you instructed the installer to install your QT files on your system okay once you have it installed on your start menu you will have an option to start QT creator you can see I can start it here let's start it to show you how it looks okay this is how QT Creator is going to look if you start it up you can do all kinds of crazy things but at this moment we are interested in using QT designer which is bundled into QT Creator if you start QT designer we also have the option to start it let's say designer and if we do we will have designer whatever the version you have installed so if we started we will have it pop up on our screen and we can start using it and this concludes what we set out to do in this lecture here introducing cute designer and showing you different ways you can have access to it you can either use QT designer or QT Creator and we were able to get access to these things by installing QT just like we did in this lecture here we are going to stop here in this lecture and I will see you in the next one in this lecture we are going to see how to work with QT designer and we have access to this because we installed qt in the last lecture which gave us access to either QT designer or acutecreator what we will be doing in this lecture is to try and create a user interface like this it's a simple form allowing the user to type in their full name and occupation once they do that they can click on the submit button and we can grab all this information and use that in our python application or a pi side application whatever you might want to call and once you have this information you can use that in your Pi side application so let's start the QT designer to start it you come to your starter menu whatever start menu you have on your operating system we can type QT for designer I think that's going to give us access to this once you start it it should show up like this it is going to show you a window that lets you create a form we may choose not to use this because I wanted to show you around so I am going to click close on that and what I want you to see is that we will be storing our files into this folder in our source code saying using QT designer so make sure you have a location where you will save your user interface files and to create a new form all you have to do is come to file new and you see this is going to give us back that user interface we had so let's see the options we have down here so we can create a dialog with buttons at the bottom we can create a dialog with buttons to the right we can create a dialog without buttons or we can create a main window or a widget you can see that we can create a lot of things I think I am going to go for the dialogue without buttons because we will be putting in our own button remember the design we are going after it is something like this so this is just going to be an empty form a dialog without buttons on top of which we will be building our own user interface let's come back to designer okay we're going to choose this so let's click create Metro you have dialog without buttons selected here and you will click on create here so let's come back it's going in our dialogue without buttons create this is going to create our file and once you have this thing created uh we don't want to create a dialogue for what we want because if you go back to our user interface here this is not a dialogue really we want this to be some kind of widget so let's go back and make sure we create a widget because it is important which class you start by so let's discard the changes that we had and we want to create the widget sorry for that make sure you create a widget here and come back here and say create that's going to give you a widget and one thing that is really important when you create your user interface files like this is to remember the object name for your top level widget here and in this case you can see that it it is called the form we want to go back and call this widget just like I did here make sure you name yours with it and we can start doing our thing if you remember we have a bunch of levels and line edits in our user interface that we are after here you can see that the thing we have on the left here is a level and this thing is a line edit and it is the same on the second line here and this is a button let's make sure we add these things into our designer user interface if you want to search for a component you can type the name here we are looking for a label so you see if we type a lip here we're going to get level you can drag two levels because they think we just need the two you can close here by clicking on the X that's to the right of this component here and down below we can grab the button and put it on our user interface we also need a line edit let's type line edit and you see we have it right here we can drag one here and we can drag another one here and we have everything we need in our user interface we can name these things so let's say full name okay we can type in whatever we want and the other one is going to say occupation if I remember correctly down here we are going to say submit in the text and I am just double clicking in these components to have the ability to type text so nothing really complicated here and now that I have my components here the next important thing is to name the components that I think I will be using on the python side of my application here and I will be using these line edits and the submit button so the user will be able to type text in here and I want to be able to grab that text on the python side and I want to know when the user clicks on this submit button here so let's name our thanks I am going to click on either of these and come to object name in my properties to the right here so this one is going to be named full name line edit okay so the other one is going to be occupation line added and the other thing I need to name is my submit button okay make sure you remember these names and at any point you can open this file here and look at this if you click you're going to see the object name to the right in the Tuple here so you can see your object name here if we click the other one we can see our object name right here if we click on the button we can see our object name right here and as I said before make sure you name your top level widget in this case it is named widget here and this is going to be important when we get to the point where we load this on our python side so this is really important once we have this user interface I think we need to put in a bunch of layouts and it is really easy to use layouts from QT designer for example we wanted the full name and the line edit here to be laid out horizontally so we can click on full name and our line edit while having control selected so we can select them all all or we can even click and drag and make sure we have them selected here we can do something like this once you have them selected you can come to the top here where you have these buttons the first one is going to help you lay things out horizontally the second one is going to help you lay things out vertically we want to lay out horizontally so we can hover over this button you see it says layout horizontally if we click on it these guys are going to be aligned horizontally in a layout we are going to do the same for occupation and the line edit to the right of that we are going to put them in a horizontal layout and we want to click on the form here and lay everything out vertically because that's the user interface we are after so click somewhere empty on the form come to the button that says layout vertically if you click on it things are going to be laid out vertically and we can resize our user interface to make it really look nice here I think this is good and we have our user interface so you can come to file and save it and you are going to choose the location where you want to save yours okay this is where we want to save our file we will give it a name let's name it widget dot UI we can do something like this and if we save it is going to be saved and we are done with our design of our user interface here okay now that we are done with this we are going to head over in the next lecture and show you how you can do the same from QT Creator and after that we will worry about importing this user interface for use in your Pi side application that's going to be really cool so I will see you in this lecture in this lecture we are going to look at how we can load our user interface files into a python application there are different ways to do this as I mentioned in a previous lecture probably but we will be looking at a class called Q UI loader which helps us do that let's go to the documentation and actually see what this class does you can come to your research engine and say hi site sucks loader if I can type today this is going to give us a link we can click on and if we go there we're going to learn or we can about this class here they show a little example of how you can use this we will be running a version of this example in our PI side application but make sure you read about this class to know what it does let's come back to the slides and really look at how to use this so to use this class you have to make sure you have imported Qui loader like we are doing here once you do that you will create a loader object just like we do here once you have a loader object all you have to do to load your UI file is to call the load method just like we are doing here so the first parameter is going to be your UI file and what this says is that in this example here we will be putting our python file in the same location as our user interface file if your user interface file lives in another folder you will have to tell your python file to go to that location and find the UI file that's something you need to know and once we call the load method here we will get a widget that we can then use in our application like we use any other widget another thing worth mentioning is that to access things into our UI file we we will be using the notation here notice that we are saying full name line edit because it is the name we used in our UI file remember the object name that's the name you have to use here and then we say dot and access properties of this UI component you see we are doing the same for our occupation line edit to access the text another thing we can do is connect slots to signals coming from the user interface for example here you see that we are saying whenever somebody clicks on the submit button in our window object we want to respond in our do something slot that we have defined on top here and once you have this you will show the window you will call the exact method to kick off the event Loop and your application is going to show up and do things one thing I wanted to warn you about is that the loading that we are doing here is happening at runtime and what that means is that your application will be paying a performance penalty every time the user runs your application that's why I am really not in favor of using Q UI loader to load your user interface files because the penalty is going to be on your users and you will be wasting their time there is a better way to do this and I will show that in the next few lectures but for now you need to be aware of Q UI loader I think Q UI loader can be useful if you are prototyping and things like that but in a production application you shouldn't really use this at least that's my opinion here okay make sure that you know that q u i loader is going to make your users pay the price every time the application runs now that you notice we are going to head over a 2o editor and play with us a little more okay here we are in our editor which is Visual Studio code this is the folder where we will be doing our things here the first thing I want you to do is to make sure that I put my UI file in this project here we can either use the one from QT designer or QT Creator let's grab the one from QT creator doesn't really make a difference they are the same so I am going to put in my UI file and once I do that I will open this project in Visual Studio code let's do that okay the project is opened you can see that we have our UI file what we want to do is to create our main Pi file first thing we want to do is to make sure we import the components we need and we import cute widgets because we will be using the widget that q u i loader is going to load we create our daughter object nothing special here next we go down and create our application instance so it's going to be a queue application object that we call app here we will have a widget or a window that we get by loading our our user interface file it is not called user data UI it is called the widget.ui so let's make sure we correct this a little bit once we call the load method this is going to give us a widget that we can manipulate in our application here we can go down and Define the function that is going to respond when the user manipulates things in a user interface so this is a do something function again it is going through our window object to access the components we have in our designer form let's make sure we open designer because ah we still have this opened in QT Creator so if we go to the line edit again you can come to the object name here and see the object name this is what we will be accessing from our python application so let's make sure we know that let's close out of QT Creator here and we are setting up our window type title on our window object and hopefully this proves that this is a real widget that we can manipulate like we have been manipulating the widgets that we have created ourselves and this is really cool okay let's go down and finish this up we will connect and respond when the submit button is clicked then we will show our widget here and kick off the event Loop so the real meat of this is where we create our daughter object this is how you create it and the other thing is where we load our widget UI file and that's the line here what we call the load method we will be getting a window object which is really a widget and we can do things we are used to do on other widgets for example we can set window title we can access things using the dot notation like we do here and this is really cool now that we have this we can actually try and run the application here let's show a a terminal window like we always do hopefully this is going to work it's not going to blow up in our face fingers crossed and we can go up and try to run our python file and look at this look at what we have here full name occupation let's put in Daniel gray for our full name occupation let's say I am a farmer and if I hit submit Daniel gray is a farmer let's say I am a plumber Daniel gray is a plumber and this is really cool we are able to use our UI file from our python file but again every time the user runs the application notice what's going to happen you know this widget UI file is going to be transformed into Python and the python is going to be loaded into this file here all of that Machinery is going to be really going on when your application runs and this is going to make your users pay a performance penalty whenever they run your application so this is really not good but you need to be aware of this in case you have a logical use case for this this is really all I had to share in this lecture I hope you found it useful before I go make sure you remember your object names it is through these object names you go to access components from your UI file in your python application here this is really cool in the next lecture we will try to reorganize this code in a separate file to make it really easy to manage and play with this a little more so I will see you in the next lecture in this lecture we are going to reorganize our code using Q UI loader and Export that into a separate class so that our main python file is a bit cleaner we're not going to do anything special really it is the same thing we did in the last lecture but here is our loader object that we create in a separate file we will set up a class that we call user interface that is going to be inheriting Q object because we need to connect signals to slots that's why we need to do this and then in our Constructor we will be doing our loading we will set up a UI object that you see here which is a member of this class this is really going to be a widget that we get by calling the load method like we did in the last lecture once we do that we set our window title we do our connection to the button and we set up our slots that is going going to respond and this is really all we need to do here another thing is that we have a show method that we are going to call to make this user interface show up nothing special here once we have this class we will import it in our main python file you see we are creating an object of it like we do here and we are showing it and once we created the wire end to the actual UI file is going to be done in the Constructor by the time we call the show method here the entire window is going to be set up and we will see it pop up on our screen nothing really special here we are just reorganizing what we already had in the last lecture but let's head over to our editor and actually do this okay here we are in our editor we will be working in this folder here you can see that it is empty before we do let's head over to the lecture where we created our widget file and steal it and put a copy of that in our current folder here once we have this we will open this up in Visual Studio code and we will create our main python file so let's make sure we do that okay plus main.py we also need the user interface file let's say user interface dot py which is going to be doing the heavy lifting and bringing in our user interface file that we got from cute designer in this case I am just going to paste in the class because you already know most of these things we will be importing Qui loader once we have it imported we will go in our Constructor and load our user interface file in this case our user interface file is named widget.ui okay so make sure you correct this a little bit we will give it a window title we will make the connection to the button that is coming from our user interface file again we know it is named submit button because that's what we set up in our designer file so let's bring up designer because I think I really need to show you this okay let's close out of this and we will open our current location we go in we can drag our widget file and drop that on top of designer if we go to the submit button it's object name is submit button just like you see here it is this exact name that we have to load in our python file so this is submit button if we go back in designer submit button if you go to the full name line edit the object name is right here so if we come back to our file we should be using that exact object name in our file make sure you really follow this if you mess these names up you're going to be in for a lot of trouble now that we have this we can head over in our main python file so let's do that okay we can put in the code and we will be importing Pi site 6 and we will be importing our user interface class from our user interface file once we have all these in we create our application object we will create our window and it is going to be an object of our user interface class this line is going to trigger a call to the Constructor that we have here and the Constructor is going to be doing the heavy lifting to load our widget UI file and give us an object called UI that we can manipulate in our application here again the loading here is still happening at run time make sure you know this this is going to incur a performance penalty to your users and you don't really want to do that unless you have a really good reason to use this way of loading your user interface files now that we have this I think we can try to run the application and see how it behaves we can show our terminal and we can clear and if we run our python file we should see our thing here exactly like we did in the last lecture if we put in our full name and our occupation let's say we are farmers farmer submit we have farmer if we put in Plumber just like we did in the last lecture we will get to the same thing and this is really all we set out to do in this lecture now that you know how to use Q UI loader we will head over into that structure and show you how we can actually compile our user interface file into python code and that's going to really take the performance penalty and put that on you the developer so you will take your user interface files and turn them into python file and their users will be loading those python files when they run the application and that's going to be much better let's head over to the list lecture and do that in this lecture we are going to see how to compile our user interface files into python code that we can directly Import in our python project and the command to do that is really simple it is what you see here we have a tool that we have access to because we installed Pi site 6. the tool is called Pi side 6 Dash UIC once you call it you will give it your widget user interface file and you got this file from a designer or QT Creator you will put in this arrow and then you will specify the output file name and at the convention I like to use is to say UI Dash and say the name of the file that I got from designer or QT Creator so in this case it's going to be UI Dash widget dot Pi file and this is going to be the file that we get out of this user interface compiler you can say you IC stands for user interface combiner so if we run our designer file in UIC here we will get a file named exactly like this and this is a convention I use to make it easy for me to manage these files especially if you have a really big project it can be really hard to keep track of this so make sure you understand this naming convention once you understand it you can modify it to suit your own needs another thing I would like to warn you about is to remember the name of the top level widget you have in your user interface file in our case we named that widget exactly like this and when we do that the user interface compiler is going to generate a class that we can then load in our own python code and the conversion the UIC compiler uses is to say UI Dash widget this is going to be the name of the class and this is what we will try to manipulate populate in our own python code and make sure you really drill this in your brain because if you don't you are going to have mismatching names either in your user interface code or in your python code make sure these things match up another thing I noticed when using this in Visual Studio code is that the files that I get out of my user interface compiler were encoded in utf16 and the visual studio code would not understand this I will show you how to bypass this but I just want you to be aware of this if you face this problem here and if you are using a different editors you might have to do research on how to get around these problems and again make sure you remember the convention we are using here the widget that UI file is going to be what we get from QT designer or QT Creator the design file once we pass that file into the user interface compiler we will get a you I Dash widget.py file this is a file generated by the user interface compiler you have no business manipulating it manually and our widget.py file is going to be our own class which is going to be trying to reuse code that was generated for us by the user interface compiler make sure you really understand this convention I will be going through this convention again when we hit Visual Studio code in a minute but I just want you to be aware of this once we have our file generated we will set up our own widget class like this and again this is just a simple widget we are creating this is our own class name it is going to be inheriting both Q widget and the UI widget UI widget is the class that the user interface compiler is going to generate from your UI file again this is going to work because our top level widget that contains our user interface is named widget let's go back to designer and actually show you that I think we still have designer opened if you manage to click around on the lobbying form here you will see that our object name is widget and the user interface compiler is going to pick this up and generate a class that is named UI widget and it is what we are trying to inherit from here I really want you to notice this if you have problems with us it might be really hard to debug so once we have inherited the correct class we will go in our Constructor and because we are inheriting from UI widget we have the things that UI widget has and those things are our submit button we can access it like this our full name line edit we can access it like this and our occupation line edit and we can access it like this again we know the object names because they are what we set up in our designer file let's make sure we open this in designer if we go to the full name line edit the object's name is right here if we go to the occupation line edit the object's name is right here if we go to the submit button the object name is going to be right here for everybody to see make sure you really know these things I don't want you to face problems if you went through this course to learn about Pi side 6. okay once we have events set up we will also set up our slot which is going to respond when the user clicks on our button and the connection is going to make sure that whenever somebody clicks on the button we will be called and this slot here nothing complicated so far and one benefit of doing this is that this is going to be making it easy for your users you went through the trouble to transform your user interface files into Python and the user is not going to be paying that price you the developer will be paying that price and it is really good because you develop your application once and your users will probably be running the application a thousand times or even a million times depending on how successful your application is so if you move the price at the developer time you will be really saving your users a lot of time with the Q UI loader every instance of your application that runs would pay that price but now we are paying that price once when we develop the application that's the benefit of doing things this way okay now that you know this we can head over to visual studio code and play with us a little more okay here we are in our project this is going to be our project folder here it is empty so what we need to do is to steal the UI file that we will be using for this demo here so let's put this in place and I think we can directly open this in Visual Studio code so let's drag this and drop on top of our editor here this is going to give us our project we need to create a few files remember our Diamond convention we need a python file which is going to be the main python file let's do that we will also need to set up a widget dot py file which is what is going to be important things generated by our user interface compiler now that we have the UI file the first thing we need to do is to compile it to python you already know the command because we saw it in our slides but I am going to show that again right here so let's show our terminal and make sure you see everything here let's clear I am going to paste it in the command but you can type it if you want the command says Pi side 6 Dash UIC after that we will specify the input file which is going to be our user interface file that we have here in our folder we will specify an angle bracket facing right this is how we use this tool and you can say the output file right here in our case it is going to be uiwidget.py once you have this typed in correctly you can hit enter the tool is going to go to work and it is going to generate a uiwidget.py file that you see generated here if you want you can even open this in Visual Studio code so let's make sure we click on it and you can see the things that are generated for you by the user interface compiler they say that this file was created by the cute user interface compiler this is the version they warn you that changes to this file may be lost to the next time in the user interface combiner is run but you can browse through it it is really a simple class it's just doing the heavy lifting of generating these layouts and things for you so that you don't have to worry about it if you go in you will see our object names for example you see full name line edit we see occupation line edit if we go down I think we will find our button and these are things we will be loading in our python code one thing I want you to notice though is that this was generated in a UTF F16 encoding Visual Studio code is using utf8 if I try to run this I will be into problems so I will fix this in a minute when I show you the problem but I just want you to notice this here okay we have our UI widget Pi file again in a dynamic convention we are using files we name like valves are going to be what we get as output from the user interface compiler files we named like widget.py like this are going to be our own code that uses what we got from the user interface compiler make sure you really understand this and widgets that UI is going to be the file we got from UI designer I know this may be confusing but once you do this a couple of times this is going to become second nature let's set up our own widget Pi file and I am just going to paste that in here because I don't want to waste your time typing this it is going to be a class that inherits both Q widget and UI widget this is super important we set up our Constructor which is going to call the set UI method and this is a way QT provides to wire to the class that was generated for you you don't have to worry too much about this just make sure you put in this call once you do that you will have access to everything we had in our user interface file for example we can set up the window title because this is a widget we can access the submit button like this we use the self thing here because now that's part of us because we are inheriting from UI widget and UI widget is named like this because our object name is Widget the top level widget is named widget if we go back to designer that's what we should see here let's click on the top level with it again make sure you see this object name here this is important this has to match what you have after the UI Dash here this is how the user interface compiler is going to do things so once we have everything we will set up our slot and everything is really going to work once we have this we can go to our main main dot python file and we will put in the code which is not going to be anything new so we will create our application object we will create an instance of our own widget this is really important so notice the class is named widget we are creating an instance of it and this is going to show our user interface because we did the wiring in the Constructor of our widget class here now that you have all this done we can try to run the application and a warn you it's not going to work at this point but let's try to do that so we can say python main.py and if we try to do that we will have an error what is it saying uh source code strength cannot contain null bytes and this is happening because our UI widget Pi file was generated in any coding that is different from the one that is being used by Visual Studio code here so what we need to do in our case we can click on this utf16 thing down below once we do we will have a menu on top here in Visual Studio code and what I want you to do is to click on save with including and we will be using utf8 here once you do that the thing below here make sure you see this it's going to change to tf8 and now if we run the application it should work let's come down play yarn and run our thing and now it is working we are able to compile our user interface code into python code and loading that python code in our own application and this is really cool we can put in our full name to make sure that our connection to slots and signals are working Daniel gray occupation is going to be a farmer and if we submit you see he is a farmer if we change to plumber he is going to be a plumber and this is working exactly like we want and again the mid of this is to be able to call the user interface compiler the command is what we have here make sure you remember it or have it typed somewhere where you are able to access it easily once you have your python codes generated make sure it is in the correct encoding at least if you are using visual studio code once you have it in the correct encoding you can import the code in your widget.pi file and create your class like we do here once you have your class you will do the necessary connections to manipulate the user interface components remember these are the objects names we have in our designer file once you have your class you will create objects of it and you will play with it however you want we are going to stop here in this lecture and I will see you in the next one in this lecture we are going to look at how to use the cute resource system and this is a powerful system that allows us to bundle files into our python application so that they can be found easily without having to need to put them where our main python binary or script is and we will explain this concept using this little application here so we will have a minus button and a plus button when you click on minus we will decrease the number that we have here when you click on plus we will increment the number and this is going to be a spinbox component I don't think we had a chance to talk about it but you're going to see it as we go in this chapter here the main point is to be able to load the icons for minus and plus here from our QT resource system in this lecture we will be doing things manually from QT designer to show you how to work with this and here is a simple piece of text saying the same thing I just said here but one thing you should keep in your mind is that the files in your resource files are going to be compiled into python code and that's why it is possible to directly find them where your main python script is without having to need to browse through the file system where your python code is running and this is really important but again it's going to incur a price on you the developer to have to compile your resource file into python code and you're going to see that it is really easy we use a QT resource compiler and it's really easy you just have to call the command and you will get a python file that you can then load into your Pi side project the workflow we will be using here is to create the resource file of course you also need to create your user interface files you're going to be needing we will compile the resource into python code we will import the python resource file into our own python application and we will be using that in our application here here I am showing you how we will be doing this in designer so once you have designer opened you will click on this button here this is going to pop up this little widget in this widget you can create a resource file using the menu here and you can add the files to that resource using the menu here I will show you how to do this in a minute when we hit our designer instance once you have your resource file created the file is going to be named resource.qrc this is an extension that Designer understands QT designer I should say and you will run this command Pi side 6 Dash RCC you will give it the resource file you will say that your output file name is resource underscore RC Dot py and it is important to follow this naming convention because other tools like QT designer are going to be looking for it so make sure if your file is resourced to name the output python file resource underscore RC you basically have to add an underscore RC on this then here and this is going to work once you have your python file that you generate you will need to import that in your python project and all you need to do is say something like this and you will be able to use it notice that this is our own class named widget it's going to be inheriting from our UI widget file and it will be accessing the buttons so we are making connections to our buttons just like you see here and we will be setting icons to these buttons and you see we set up the icons like this and the mid of this is what we do here to access our images notice the syntax we use colon backslash images backslash plus this is because our images are going to be leaving in a folder named images and once you follow this convention here everything is going to work we have the plus icon we can set it to our button and our user interface is going to show up exactly like we want okay now that you know this we are going to head over to visual studio code and play with us a little more okay here we are in our project the project we work on is going to be seven resource manual designer and this is where we're going to be playing with this the first thing we need to do is to create our user interface in designer so let's make sure we have designer opened open it if it's not opened for you and we will be creating a new project or a new file it's going to be based off widgets here so let's create this is going to create our user interface we will be creating our user interface a lot of times here because you need to be familiar with us so let's do this we need two buttons the first one is going to be on the left the other one is going to be to the right we need a spin box and we will be using a regular spin box why not we will have the button to the left named minus button so we need to change the object name here and we name the other one plus button okay the one on the left is minus we can change the text let's say minus and say plus to the right here let's look at the object name for our spin box it is named spinbox let's name it spin box with an underscore because this is our naming convention and make sure the object name for the top level widget is widget because this is our conversion layer widget and we have our user interface I think we can apply a horizontal layout immediately by clicking on the empty form and clicking this button here and we can resize this okay to something like this and we have our application here okay we have our file here we can save it let's say file save and we will browse to a location where we would like to save this it is in our project here so we will name it resource or widget.u I not resource sorry for that so we save this on our drive and we have this thing saved once we have this saved we will also create a resource file and we can close this now we don't need to close it because we need an active resource file to be able to create our resource file this is unfortunate in a designer so let's open this again we can go where we saved it sorry if this is a bit convoluted but it is what we have to work with so let's bring this back once we have this created we can head over to our designer we will have a little button like this okay make sure you see this I am going to click on it it is going to pop up another window and on the left here we have the option to create new resource files so let's click on this button here that says new resource file it's going to browse into my system where I want to save my resource file I am going to choose this location here and name it resource.qrc I think the extension is going to be put in automatically when I save the file is going to be saved if I go back to my location I am going to have my file where is that where is it where did I put that file let's try to hit OK and see if this is actually going to save my resource file or I put it in the wrong location yes we have the file here because we closed that so it must be designer that was having problems saving my resource file now that I have the resource file created I can move over to the right here okay and add the prefix a prefix is really like a logical grouping of files into your resource system for now don't worry too much about this click on ADD prefix and take out everything to have a default prefix that is to the root of where your resource file is that's what we are doing here so let's hit enter this is going to give us a no prefix then and once we have a prefix we can add new files I am going to click on add files and this is going to browse it to my location I can go in my images folder don't worry I will be giving you this images folder you can use it in your project you can actually download the source code and you will get that as part of what you download select everything here and open and these things are going to be added in your resource file once you hit OK you will see that these files are going to show up to the right here and you can right click and copy path okay and this is going to give you a path that you can use in your python code so let's make sure we open notepad and paste that here so that you can see it you can see the path we will be using in our python code okay now we have two things we have a user interface file that we need to compile it to python we also have a resource file that we need to compile it to python now we can come out of the editor the designer editor and come back to visual studio code and what do we do we can go to where our project is number seven here and we can load it into Visual Studio code and the first thing we need to do is to compile our user interface let's view and show the terminal I think we still have our Command to compile our widget UI into python it is right here I just got it by hitting up up if you don't have it you can type it if I run it's going to compile my python file that you see here and remember to turn this to utf8 if you are using visual studio code so let's do that you already done this from the last lecture so we are ready to do this and we need to compile our resource file into python as well again I will be giving you the command here I am going to paste it in pi side 6 Dash RCC you get to this as part of your Pi side 6 installation and I will give it the resource file you need to compile you will say Dash o and say the output file name the naming like this is important because your other tooling like designer are going to be looking for that so make sure word that you attach an underscore RC to whatever name you have for your resource file here and once you have this you can hit enter this is going to compile the file this is the output python file you can see that this is binary representation for the files that we have in our resource file now that we have this lens we can actually create our python files we will need a main python file main.py as usual we also need a widget py file I will put in my widget py file immediately here because I don't want to type all this you can type this if you want but you can also download the source code and use it as is here the main point is that you know how to work with resource files in your python applications so notice that we have a squiggle because our widget file starts with an underscore okay so UI widget.py that's what we are importing from we will create our own widget which is going to inherit Q widget and UI widget we will set up a window title we will access our plus button and minus button and we will be setting up our slots that are going to respond whenever something changes in spin box let's change this to say self spin box because I think we named our thing using let's go back and open recent forms that's going to be widget UI and our spin box is named user and underscores make sure you don't mix these things up so spin underscore bucks that's the name spin underscore box that's going to be our thing here and whenever you click on plus we will be incrementing the value in our spin box whenever you click on minus we will be decrementing the value in our spin box that's what we are doing here but the main thing is that we are setting up an icon that is using things in our resource file and we are able to do this because we imported our resource underscore RC file that we got as a result of compiling of a resource file into python make sure you really understand this now that we have this we can create our main python file and it is not going to do anything special it is just going to import things from our widget file which is named with an underscore let's make sure we change that and we will set up our application object we will create our widget and we will show it and everything should work at this point here before we do that let's make sure that our UI widget Pi file is in utf8 it is so let's try to run this we are going to go to view and show terminal and we can go down and go up up up until we see our Command to run the code and let's see what we have here we have a mismatch for a spin box with camo case here where is it in our widget Pi file line 12 so let's go there widget.py line 12 is trying to use the wrong name for our spin box let's make sure we fix this and uh let's try to run again view terminal and we can clear and try to run and if we run you see our application is up here if we click on Plus and we still have problems with our spin box sorry for this but it is something you come across so no problem here the important thing is that we can fix it spin box and let's make sure we run again clear and run it's going to run if we click plus we are going to increment if we click on minus we are going to decrement and everything is working and the meat of this is to be able to load these files from your resource system and some of you might think why go through the trouble to use the resource system it is really important because you don't have to provide these files where your main python file is if you deploy this application to your users and this is really important make sure you take advantage of this in your Pi side applications we are going to stop here in this lecture and I will see you in the next one where we're going to be using QT Creator to create these resource files here so I will will see you there in this lecture we are going to see how to use resources in the QT resource system from your user interface files and this is going to save us from doing what we did here for example by having to manually set the icons to buttons we can avoid this kind of thing and do it right from our user interface files in this case we will be using designer so let's head over to visual studio code and actually set up a project that is going to help us do that and another thing I should point out is that you don't even have to manually import this file in your python project because you will have done this from the user interface file but make sure that you still have your resource file compiled into python because the UI file is going to be looking for that and it will be looking for a name in conversion like this from your resource files so let's head over to visual studio code and do this okay here we are in our editor we will be loading resources from our user interface file and we will be working in this folder here I think we can still code from the last project and use that as our starting point here okay we have the UI file and the resource file we also need these images so let's copy that and put that in our nine project here once we have this we can bring this into Visual Studio code by dragging and dropping here and what we want to do is to go to our python file and take out the import we are doing here we don't need this anymore and we don't need to set the resources like we are doing here because our user interface file is going to take care of that so let's open our designer file and again make sure that you do this once you have a resource file like the resources that Q RC file we will open our user interface file in designer so let's make sure we have designer up and running designer and we can run it and we will hop over to the current project on my file system number nine and drag and drop the design file here so once I have this I can click on this button and I will have a bunch of properties for this button here but before I do that let's make sure that I have a resource file applied to this UI file so what I can do is come to add a resource file let's open a resource file that is already existing so I am going to browse to the location of my project here on my system let's do that let's go there designer number nine that's the current project and we have a resource file that we can open here let's open if we open it it's going to show the images that it has and this is going to work just fine let's hit OK and once we do that we will be seeing our images and the current UI file is ready to start pulling resources from this resource file here that's why we need to do this connection here once we have this we can click on our minus button I think we will have an icon property we can even search by going to the top here and say icon okay we will find icon here and once we have icon we can click to the right here click on the three dots now we don't need to click on the three dots we can click on the downward error here and we can choose resource once we do that we're going to click on images and we can click minus once we do that the minus icon is going to show up we're going to repeat the same process on the plus button click on the down arrow choose resource click on images and on the right here you can choose plus and this is working because we made the connection between the widget UI file and the resource file that we have on in our path here once we have this we can save so let's save this again and because we just changed our user interface file we need to recompile this into Python and this is something I want you to be aware of every time you change your things in your user interface files you need to recompile them into python files so that the python side of your application can pick up those changes so let's come back to visual studio code we can really close out of QT designer here we don't need this anymore we can come back to visual studio code view our terminal okay and we can clear and go up up to compile our user interface file into our python file and we will be using the user interface compiler notice that we don't even need to recompile the resource file because we already had that but if you don't have a resource file or if it is the first time you set up your resource file you will need to compile that into python code I am going to show you why in a minute once we see our newly generated UI widget that Pi file if we go there the first thing I want you to notice is that the the encoding has changed back to utf16 because this is a newly generated file so let's make sure we go back and change this back to utf8 okay we need to do that and another thing I want you to see is that this file is going to be doing the import for you because it is the one that is doing the setting of the icons on our buttons so make sure you still have your resource file compiled into python code and make sure you use this name and conversion here you see that QT designer or the user interface compiler to be exact is looking for this and you need to follow this conversion for things to fall in place and work so our python file should be clean now it is not important things it is not setting icons but our application should still work let's go to view the terminal and clear and run if we run we should see this coming up here if we click on plus it's going to increase comment if we click on minus it is going to decrement and everything is working as we want this is really all I wanted you to see in this lecture how to connect your user interface files with the resource files make sure that whenever you change something in the user interface file you recompile to python for the python side of your application to pick up the changes and use them I am going to stop here in this lecture in the next one I will show you how to do the same from cute Creator I'll see you there in this lecture we are going to design a slightly involved Q made window application which is going to be using resources intensively we're going to have a chance to play with the menus and toolbars and we will be able to use the images that are coming from a resource file that is going to be attached to our user interface file we're going to be building something like this so this is going to be our application here you can see that we have a bunch of menus we have a toolbar here and we are using icons that we will be pulling from our resource file down in the middle this is going to be a central widget for our main window and it is going to be a text edit component and we will set up this entire user interface in q2designer and use it in Visual Studio code on the python side so let's do this here we are in our working folder we will be working in this folder number 11. you can see that it is an empty folder the first thing we want to do is to open cute designer and actually set up our user interface in this place here let's do that QT designer and it is going to be a main window project that we want to set up so make sure you select main window here and create and this is going to give us a main window that we can play with make sure you know the name of the top level widget in this case it's going to be named main window this is okay and we want to add a bunch of menus just like we saw so we can say file here by clicking and typing let's look at our design we have a file edit and help let's do that we're going to say edit and help let's see what we have in our file menu in the file menu we will have a quick action so let's put in quit okay and you can see that when you double click on the place that says type here you're going to be adding in an action let's go to edit we will put in copy cut paste we can undo but before we do let's add the separator and then undo and redo and help we can say about and about QT I am going to show you how to pop up a bunch of dialogues that show information here and I think we have our user interface if we come down I think we can say add toolbar this is going to give us a place where we can drag and drop thanks so let's go down here in the user interface where it says action editor and in here we can actually add a bunch of actions so you can see that we already have many actions so we have action quit copy cut and paste what we want to do is to but before we add icons to these actions we actually need to add a resource file so let's go to Resource browser here and click you already know how to add the resource we will be adding a new resource file to this project it's going to be saved and let's go somewhere on a drive here 11 here that's the folder the name of the file is going to be resource nothing complicated here dot QRC and that's going to be our resource I am going to copy a folder of images that I will be using in this project here it is going to be available once you download the source code for this lecture here so let's go in the current project and add in our images folder and we can come back to designer and once we have the resource we will be needing to add a prefix click on ADD prefix here take out everything like we did earlier and now you can add files if we go in images we are going to select everything and add all these files here and if we hit OK these files should now be available for a use in the project here now we can come back to the action editor and double click on action quit if we do we will have the option to set an icon let's choose resource and go in images and we will choose the quit icon here so let's hit OK and if we do okay again the icon is going to show up let's do the same for copy let's choose resource images copy where is the copy icon it is right here so let's select that hit okay we are going to go to cat and do the same choose resource images cut icon that's what we want and hit OK we want to paste choose resource images paste and okay we want undo resource images and do where is undo undo is right here let's select it and hit OK we want to redo resource images redo icon after that we have about let's click OK first about let's go choose resource images about that's going to be this icon here which is black we hit OK and about QT let's go to Icon choose resource images and about QT the orange one and we can hit okay now that we have this we can actually drag and drop actions on the toolbar and this is going to be really cool you see it shows up here you can right click and say add separator okay and then we can do copy cat and paste okay this is something we can do once we do this we can even add another separator okay and after we do that we are going to do undo and redo okay we can do something like this another thing we can do is to add the text edit component okay we can drag it and drop it here and we can click in some empty space and use a vertical layout for example to make the text edit fill our user interface and at this point I really think we have everything we need for our user interface file and because it is automatically loading the resources we don't need to manually import the resource file all we need to do is compile our user interface to Python compile the resource to Python and we will be able to set up a main window python file that is going to be using these things on the visual studio code side or the pi side if I can say it like that so let's save this file here let's save and we will be given the option to choose where we want to save it it is going to go where we are saving out of files so let's go to that location and choose this guy the name is going to be main window in lowercase dot UI and if we save it should be available in our current working folder we have the resource file we have the main window file we can close out of designer if we want but for now what we want to do is to load this guy into Visual Studio code so that's going to be our project here so let's drag and drop inside of Visual Studio code we will have our thing here and we want to compile these guys so let's show a terminal window and we can hit up up to go into our Command history we will see how to compile our user interface file we just need to change the name here I am going to change this to main window to UI main window main window this is what we want if I do this this is going to generate my main window file let's go up again and try to find that I wanted to compile the resource file we have a resource.qrc we don't really need to change anything here this is going to compile our file we need to go to the main window python file and change the encoding to utf8 if you remember correctly so let's change this to utf8 and now we have everything we need we can start creating our python files we can create the main python file we can also create the main window python file and now that we have this and what we will do is just put in the code to use our generated python file main window or UI underscore main window Pi file we are importing the file here and we are going to be inherit from that file as we do here in the Constructor we do really nothing special here we are just taking an application parameter and that's going to be what we use to kill the application when the user triggers the quit action and down here you see that we do connections to our actions so we say action quit when it's triggered we are going to quit the application when the action to copy is triggered we will be running our copy slot which is what we have here and we do all these connections here there is really nothing special and in about we will be putting out a message box that is going to say something that is just going to be saying something here and when the user triggers the about cute action what we will do is show a message from our Q application class here this is something you can do the main thing here is ready to be able to build your user interface from designer and be able to bring those files into use in your Pi site application like we are doing here in Visual Studio code now that we have our main window we can go to the main python file and bring everything together nothing complicated we are just importing our main window file the main window cluster is in there we are creating an object of it and showing it and kicking off the event Loop here again let's make sure that we compiled our resource it is we compiled our UI main window python file it is using utf8 this looks good let's show our terminal and try to run the application and if we are lucky everything is going to work and it is going to be really cool let's try to run okay so it seems we don't have an action named about underscore cute let's go back to our designer file and make sure that our action is named about QT yes it is named about QT and it seems we are doing something bad in our main window python file so let's go about QT let's take out the underscore let's try to run again terminal clear if we try to run now it is going to run if we quit we should be able to quit the application if we run it again we should be able to see it you see we see our icons in our toolbar if we go to file and quit it is going to go away you already know how to work with Q main window by the way if we edit we can copy cut paste and do redo and for example we can DDD here and do it's going to go away we can copy let's say the sky is blue you can copy this through the toolbar and we can even paste and paste and paste and paste this is going to work we can undo it's going to go away we can redo it's going to come back we can even cut out everything here and paste you see we are really able to use this application and this is really cool let's use the help menu about it's going to show a message box that we triggered in our code if we do about QT it is going to show information about the QT version that was used to compile this application this is really cool and this is all we set out to do in this lecture showing you a slightly practical way to use the resource system to your advantage and again this is going to be really cool because all these resource files are going to be available to our application without having to recopy these images when you deploy your application and this is really cool I am going to stop here in this lecture and I will see you then this one congratulations on hitting the end of the course here you have learned a lot in terms of using qt4 python to build cute widgets applications that you can run on Windows Mac and Linux now that you have these fundamentals you may be asking what's next well you just scratched the surface when it comes to using Q2 widgets to build applications that can run on different platforms and a few other topics I would recommend is learning about events the graphics view framework which allows you to build interactive applications this is actually one of my favorite topics intuitive you can learn about networking you can learn about databases you can learn about threads there is really no shortage of things you can learn about in QT another thing you can learn about is qml which is another API to build a graphical user interfaces that are fluid and dynamic to run on mobile and embedded this is a really hot topic in QT and I would recommend taking a Twist a moment meant to look at this because if you are serious about QT you are probably going to run into qml so that's something you might want to look at we have a few courses on qml if you are interested you can check them out and really what I would recommend is to try and think about things that interest you the most or things you think that you are likely to meet in your career as a developer focus on those things learn how to do those things in QT and your learning experience is going to be much better this is really all I had to share in this lecture again congratulations on hitting the end thanks for giving me the opportunity to be your instructor if you are interested in many of our other courses be sure to check them out I am going to stop here in this lecture and I will see you next time
