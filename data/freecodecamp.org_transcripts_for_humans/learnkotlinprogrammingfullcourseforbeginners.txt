With timestamps:

00:00 - kotlin is the most popular programming
00:02 - language for building Android apps and
00:04 - it can also do a lot of other things in
00:07 - this beginner's course Alex will teach
00:09 - you kotlin from the ground up Alex is an
00:12 - experienced developer who has created
00:14 - multiple Android apps in this course
00:16 - I'll cover everything you need to know
00:18 - in order to be able to create another
00:19 - programs or move to build apps on
00:22 - Android I will start from zero by
00:24 - downloading the software that we need to
00:26 - write code to creating our first program
00:27 - and then we're gonna move to more
00:29 - advanced topics we'll cover things like
00:31 - variables operators Loops arrays object
00:34 - orientated programming generics Lambda
00:37 - functions core routines
00:39 - everything will be covered in depth with
00:41 - great detail additionally I'll use
00:43 - beautiful animation while talking about
00:45 - a concept
00:46 - for who is this course this course is
00:49 - for complete beginners who have no
00:51 - experience with programming and also for
00:53 - experience programmers kotlin is perfect
00:55 - for beginners because it's very
00:57 - intuitive and concise
00:58 - and if you already have a background in
01:00 - other programming languages then this
01:02 - course would be easy for you so let's
01:04 - get started
01:06 - now it's time to download the installing
01:08 - ID and throughout this course I'm going
01:09 - to use an ID called IntelliJ ID which is
01:12 - an ID made by a company called jetbrains
01:14 - now you may be wondering what is an idea
01:16 - an IDs stands for an integrated
01:18 - development environment and it's
01:20 - basically the tool that you're going to
01:21 - use writer code in and intelligent it's
01:23 - like a text editor but a very
01:25 - sophisticated one because it has a lot
01:27 - of features like highlighting our code
01:28 - showing real-time errors and suggestions
01:31 - you can run and compiler coaches by a
01:32 - few clicks in other words it's making
01:34 - the process of writing code easier and
01:37 - better therefore let's download IntelliJ
01:39 - IDEA so I'm going to open my browser
01:42 - and in the search bar to type IntelliJ
01:44 - IDEA
01:45 - press enter
01:47 - and we click on this download link
01:51 - and on the downloading page you're going
01:52 - to see two options ultimate which is
01:54 - paid so you need to pay in order to
01:56 - download it and Community which is free
01:58 - and the difference is that the ultimate
02:01 - has more features and Community has less
02:02 - features but Community is not for our
02:04 - purposes also pay attention on the left
02:06 - hand side when I'm currently recording
02:08 - this video the latest version is
02:11 - 2021.1.2 which was released on the 1st
02:13 - June of 2022. and if you look at the
02:15 - system requirements here if you click on
02:17 - that you will see that this IntelliJ ID
02:20 - only works for a 64-bit version of
02:23 - Windows so if you have a 32-bit version
02:24 - of Windows this will not work for you
02:28 - now if you have macro X or Linux you
02:31 - should download the particular version
02:32 - for your system and if you don't know
02:34 - how it just tell me in the comments and
02:37 - I've made two separate video and shall
02:38 - show you how to do now I'm gonna
02:40 - download the community version for
02:42 - Windows
02:43 - so click to download the community now
02:46 - our downloading is starting on the right
02:48 - hand side on the top and if you have a
02:51 - different browser you'll see this in an
02:52 - infrared place
02:54 - so once the downloading is finished just
02:57 - open this file I'm going to close the
02:58 - browser now because I don't need the
03:00 - browser and the installation will start
03:01 - immediately
03:06 - now it's asking us if you allow this app
03:08 - to make changes to a device click yes
03:10 - you need to click on next this is the
03:12 - for the location or IntelliJ is going to
03:14 - be installed you can keep the default
03:16 - location or you can change it if you
03:17 - want I'm going to keep the default
03:18 - location so I'm going to click on next
03:21 - and here I'm going to check this box to
03:22 - have a desktop shortcut I'm going to
03:24 - click on next now I'm going to click on
03:26 - install and IntelliJ is going to be
03:27 - installed on my computer
03:29 - as you can see on the left hand side
03:30 - IntelliJ already appeared
03:34 - now let's wait until the installation
03:35 - finishes
03:39 - when the installation finishes just
03:41 - check this run Intel GID Community
03:42 - Edition and click on finish now
03:44 - intelligently IntelliJ is going to open
03:47 - now it's asking us if you want to import
03:49 - IntelliJ settings so if you have the
03:51 - previous version of IntelliJ ID you can
03:52 - import the settings here but I'm going
03:54 - to click the not import settings and
03:55 - click on OK
03:56 - now IntelliJ ID is going to open
04:02 - and this is the welcome window of
04:05 - IntelliJ IDEA and here on the left hand
04:07 - side click on customize
04:09 - go here to where it says color theme so
04:11 - you can change this theme because the
04:13 - default team is this dark team I'm Gonna
04:14 - Change it to light because the IntelliJ
04:17 - team is better for tutorials but you can
04:19 - keep the dark team if you want and in a
04:21 - separate video I'm going to show you how
04:22 - to add more themes not just the ones
04:24 - provided by IntelliJ ID
04:26 - now click back on projects click on this
04:29 - plus button where it says a new project
04:32 - because we need to configure the jdk now
04:35 - and now here we have jdk and we have in
04:39 - red and angle brackets we have no JD no
04:42 - SDK
04:43 - and now here we need to add the jdk and
04:46 - jdk stands for Java development kit SDK
04:49 - stands for software development so
04:50 - software developer Kint is the Java
04:53 - development kit no matter how you call
04:55 - it this thing contains the tools that
04:57 - IntelliJ ADN needs in order to be able
05:00 - to compile and run our programs because
05:02 - without them IntelliJ edits like an
05:04 - empty text editor so it needs those
05:06 - tools in order to be able to work with
05:09 - our particular programming language
05:10 - which is kotlin now to download the jdk
05:14 - and we use the Java developing kit
05:16 - because code and Java are interoperable
05:19 - and that means that you can use the
05:20 - existing Tools in library which Java
05:22 - already has in our kotlin project so
05:25 - quickly here on this no SDK and click
05:28 - here where it says download jdk
05:32 - now
05:33 - on this window we select version 17 not
05:35 - version 18 because this is the latest
05:37 - version 18. this change version 17
05:40 - because this is the version which has
05:41 - the long-term support and that means
05:43 - that it will receive bug fixes and
05:45 - updates for several lists to come
05:46 - without you needing to switch to any new
05:49 - version when that new version is
05:51 - released for the average vendor we
05:53 - choose Amazon Creator and
05:55 - I'm gonna let the default location so
05:58 - I'm gonna click download to download the
05:59 - jdk now the jdk is going to be
06:01 - downloaded
06:03 - now the jdk has been installed and is
06:06 - installed on our IntelliJ IDEA and now
06:10 - we can create our projects but I'm not
06:12 - going to create a project so I'm not
06:13 - going to click on create I'm going to
06:14 - click on cancel and in the next video
06:15 - we're going to create our first project
06:17 - and we're also going to talk about a
06:19 - little bit the jdk and the jvm so see
06:22 - you in the next video now it's time to
06:24 - create our first project and there is a
06:25 - traditional programming that our first
06:27 - program should be to Output the text
06:28 - tail over to the console and this is
06:30 - what we're gonna do in this video
06:32 - therefore I'm going to open IntelliJ ID
06:34 - you should open your IntelliJ IDEA
06:44 - on the left hand side make sure to have
06:46 - project selected then click on this plus
06:47 - button to create a new project
06:52 - and here we have a few options the first
06:55 - is the name and here you need to name
06:58 - our project we need to give a name to
06:59 - our project and the name of the project
07:01 - should start with the capital letter and
07:03 - if it has multiple words every word
07:05 - should start to the capital letter
07:07 - so I'm gonna call this uh on on this the
07:10 - way of naming is called the Pascal case
07:12 - so I'm going to call this uh this
07:15 - project hello
07:16 - world
07:17 - and also you should not have y spaces in
07:20 - your name
07:22 - next we have the location and this is
07:24 - where the approach is going to be
07:26 - created you can change this location if
07:27 - you want but I'm going to keep the
07:28 - default location
07:30 - next we have language and here you can
07:32 - here you need to select the language
07:33 - which this project is going to be
07:35 - created so we select Catalan if you Java
07:40 - is selected just select other B system
07:43 - we select IntelliJ and next we have the
07:46 - jdk the Java development kit and if for
07:49 - a terrible reason it says here in angle
07:51 - brackets no LDK just click on that and
07:53 - go down here off down off to afternoon
07:56 - it should say detected as jdks and you
08:00 - will see the jdk down there you're going
08:02 - to see Amazon correct or version 17.
08:04 - just click on that and it's going to be
08:06 - added here
08:08 - next we have this add sample code and
08:11 - what this is going to do as the naming
08:12 - price is gonna generate some code for us
08:15 - but I don't want to have that code
08:17 - generated uh now because I want to that
08:20 - type that code myself and I want to
08:23 - explain that code then in the next video
08:25 - we're gonna check that to generate the
08:26 - code for us so I'm gonna click on create
08:28 - Now to create the project
08:43 - and here we have the tips you can keep
08:45 - the tips activated because it's uh
08:48 - useful information but I'm gonna check
08:51 - this actually I'm gonna just close it
08:57 - here we have those windows which says
08:59 - there is a that is a plug-in update
09:01 - installed
09:03 - I'm going to close this
09:07 - so what we have now on the left hand
09:09 - side is called the project Pane and here
09:11 - we have some folders which IntelliJ IDEA
09:14 - generated for us but now I want to I
09:17 - want to show you how to check for
09:19 - IntelliJ updates because in this way
09:21 - we'll have the latest features
09:23 - throughout this course and to check for
09:24 - IntelliJ updates you go to help
09:26 - and to go down here where it says check
09:28 - for updates and here you can check for
09:30 - IntelliJ updates and you'll see a window
09:32 - down here and if there is an update it's
09:34 - gonna say that that there is an update
09:36 - and you can install that that update
09:38 - but now it's saying that
09:40 - that you already have the latest version
09:42 - of IntelliJ ID and plugins installed
09:44 - because we have the latest updates but
09:46 - it's good to check for this because in
09:49 - this way we'll have the latest updates
09:50 - so throughout this course
09:51 - next just check if you want to check for
09:54 - kotlin updates so for the programming
09:56 - language you kotlin you go to tools
09:58 - kotlin and go here it says configure
10:01 - custom plugin updates and if there is a
10:04 - new update you will see it here and
10:05 - click on install and that update is
10:07 - going to be installed
10:10 - on IntelliJ IDEA so there is no update
10:12 - because we have the latest update I'm
10:14 - going to click on OK
10:16 - now let's focus on the left hand side
10:17 - and if you don't see if you see
10:19 - something like this and you don't see
10:20 - this in this expanded form just click on
10:23 - this greater sign sign in front of his
10:26 - SRC SRC stands for Source this is where
10:29 - our source code is gonna go
10:31 - then click on this greater sign in front
10:34 - of Main and make sure to have the folder
10:37 - kotlin selected on this folder kotlin
10:39 - this is working out our code but first
10:42 - we need to create a file
10:43 - and the file is the thing where we're
10:45 - going to put our code so we right click
10:48 - on this go to new
10:50 - and here we select on the right hand
10:52 - side we select quoting class file
10:55 - now we need to give a name to our file
10:57 - and I'm going to call this file main
10:58 - you'll see the reason for this later so
11:02 - I'm going to call this file Main and
11:04 - then also you should be in Pascal case
11:05 - so if you start with the capital letter
11:07 - and if it has multiple words every words
11:09 - result the capital letter
11:11 - and for the from these options that we
11:13 - have here we select file because we're
11:15 - going to create a setup file now press
11:17 - enter
11:20 - now the file was created for us as you
11:22 - can see in the folder uh kotlin now we
11:25 - have main.at have the file and also to
11:27 - open the file for us let's uh
11:30 - click there now if you don't have the
11:33 - file open then if you have something
11:35 - like this just double click on the file
11:36 - and the file is going to be open for you
11:39 - now
11:40 - here now we're gonna type some code now
11:42 - you need to type exactly what I type so
11:45 - type fun
11:47 - so while I am typing as you can see
11:50 - IntelliJ is trying to help us and is
11:52 - giving us some suggestions so he's
11:54 - saying do you mean fun that and if you
11:57 - want to fill in that photo you just
11:58 - press enter Because I want to to to type
12:01 - that fun keyword fun and it also added
12:04 - the space so fun space
12:07 - then you type Main
12:09 - and next we need to put parenthesis and
12:11 - as you can see display button now
12:13 - appeared I'm going to explain
12:14 - immediately why
12:15 - and we put the left parenthes and when
12:18 - we put the left parenthes the right
12:19 - parenthesis is going to be added
12:20 - automatically
12:22 - so you put less parenthes and the right
12:24 - parenthesis was added automatically then
12:26 - we get outside of the parenthesis we
12:28 - press space now we're going to add curly
12:31 - braces and again we put the left
12:33 - calibrates and the record library is
12:35 - going to be added automatically because
12:36 - IntelliJ is helping us
12:39 - now we would inside the curly braces and
12:42 - now we press enter
12:43 - and it uh
12:46 - added the curly brace on the third line
12:48 - and also indented this line for us
12:52 - now let's talk about what we have here
12:54 - now what we have here is what is called
12:58 - the main function and the main function
13:00 - is the entry point of our program so
13:03 - every program that you create
13:05 - it if it first needs this entry point in
13:08 - order to be able to compile your code
13:11 - but let's take each part of this main
13:13 - function individually to talk about
13:16 - so first to have this fun and fun is the
13:20 - key word for creating a function and uh
13:23 - you can use fun keyword to create your
13:25 - own functions but you're gonna see that
13:27 - in uh in future videos
13:29 - next we have Main and Main is the name
13:32 - of this function functions can have
13:34 - different names but main is a special
13:36 - one as I said because main is the entry
13:39 - point of our program every program that
13:42 - you create needs and needs a main
13:44 - function in order to be able to run your
13:45 - code and in fact if I change the name of
13:48 - this function to fun main let's say a
13:51 - the play path button immediately
13:53 - disappear because now we don't have an
13:56 - entry point and our program can run so
13:59 - this is a special function and functions
14:01 - can have different names as I said and
14:03 - as you'll see we're gonna create your
14:05 - own functions
14:07 - that you can create you can give
14:09 - different names to your functions now
14:10 - next we have parenthesis and you have
14:13 - parentheses because
14:15 - um functions can take parameters and can
14:18 - do some work with that with those
14:20 - parameters but our function doesn't take
14:22 - any parameter but we still need to
14:24 - provide the parentheses because they are
14:27 - part of the syntax and we can think of
14:29 - the syntax like the grammar rules that
14:32 - you need to to to respect in a specific
14:36 - language in order to be to be a to under
14:40 - to be understood to be understood and in
14:43 - the same way this is the syntax in the
14:45 - programming it's like the grammar rules
14:47 - in which the compiler as you will see
14:50 - what is the compiler later
14:52 - the compiler needs
14:55 - enforces you to respect those
14:57 - syntactical rules which is uh to have
15:00 - parenthesis for a function in order to
15:02 - be able to understand your code because
15:04 - if I delete the parenthesis here
15:07 - now we have an underline which says uh
15:10 - expecting parentheses so it's it's it it
15:14 - you need to respect the syntactical
15:17 - rules in order for
15:19 - your code to be to be understood next we
15:22 - have curly braces and we have left curly
15:25 - brace and right curl base and this is
15:28 - called the body of the function so this
15:31 - is where our code goes so
15:33 - this is also called the code block
15:35 - because because it's the block of code
15:37 - this is what our logic our uh our
15:42 - these are our logic our lines of code go
15:45 - they are we Define them inside the the
15:48 - the curly braces so this represents the
15:50 - body of the function
15:52 - and let's add some code and I'm going to
15:54 - type print line here so because when we
15:57 - need to output something in the console
15:59 - so we type here print line
16:01 - so we type print and while I'm dumping
16:05 - you associate suggested and we have the
16:08 - suggestion print line and we select the
16:10 - first one to fill in for us and now we
16:12 - go inside the parenthesis of the print
16:14 - line
16:15 - and we put double quotation marks and
16:19 - inside the double quotation marks we
16:20 - type hello
16:24 - world
16:25 - now we need to
16:28 - we need to run this code in order to run
16:30 - this code to compile this code we can do
16:33 - it in uh two ways first you can click on
16:36 - display button that we have here
16:39 - or you can right click and you can go
16:42 - here where it says runmen.kt and the
16:44 - code is going to be compiled and let's
16:47 - do it from here first so I'm going to
16:48 - click on display button to run our code
16:50 - and I'm going to see the console opening
16:52 - down and you're going to see the text
16:53 - hello old hello world outputted
16:58 - so the console opened and we have hello
17:00 - world we have the text that we type
17:02 - inside this uh thing that we have here
17:04 - this also function and we have this code
17:07 - output now in the console the console
17:09 - opened now I'm gonna I'm gonna close the
17:12 - console to explain what this print line
17:14 - is this print line that we have here is
17:16 - a function also but is that the function
17:19 - which takes some which takes input and
17:23 - the input is this text and this function
17:25 - the its job is to take whatever you pass
17:29 - as the input and to Output that in the
17:32 - console so this is what this print line
17:35 - is doing and this is a function that we
17:37 - didn't create we didn't type free fun
17:40 - print line and then you call it this is
17:43 - a function which is uh
17:45 - build into quantity this is a function
17:48 - which is already built by the kotlin
17:50 - programmers so we just call that
17:53 - function inside our code and we can use
17:55 - you need you don't need to create this
17:56 - function so this is the this is what
17:58 - this print line is doing so it's taking
18:00 - whatever you pass inside the parentheses
18:02 - and it's outputting that in the console
18:05 - so this is our discussion uh about uh
18:09 - the first program which is to Output
18:12 - some text in the console hello world and
18:15 - uh now I'm gonna show you that I know
18:18 - I'm going to show you an illustration to
18:20 - understand what is uh
18:22 - what is the jdk the jvm and the how
18:27 - kotlin and Java achieves this
18:29 - interoperability because Kathleen and
18:32 - Java are fully interoperable and that
18:34 - means that you can
18:35 - have a Java project which you can add
18:38 - kotlin code and you can compile that
18:40 - code and everything to work fine and
18:42 - also I'm going to explain what the what
18:43 - the word compile means
18:46 - and for that I'm going to bring an
18:47 - illustration here
18:50 - so this is the illustration and uh
18:54 - let's talk about what we have here first
18:56 - we have kotlin source code and kotlin
18:59 - source code is the code that we wrote is
19:02 - this squad that is meant to be human
19:05 - readable so this code is the code that
19:08 - we as humans can understand we can write
19:11 - this code we can read this quad but the
19:14 - computer does understand this high level
19:16 - uh high level uh quote that we wrote it
19:19 - needs something it need it needs machine
19:21 - code it needs binary code in order to be
19:23 - able to understand
19:25 - and this is where the jdk comes into
19:28 - action so
19:29 - our continent source code again this
19:32 - quad which is meant to be human readable
19:35 - then it's when when we press on that
19:39 - play button on that and when you press
19:42 - on that play button on this button and
19:44 - the code is compiled
19:47 - what happens under the hood is that that
19:49 - quoting source code is is uh taken by
19:53 - the Java development kit the jdk and
19:57 - through the kotlin compiler so the
19:59 - controlling compiler acts like a
20:01 - translator it takes that high level
20:03 - human readable and writable code
20:07 - it converts that code then into what is
20:10 - called Java byte code and this is not
20:13 - the final step as you can see in this
20:15 - illustration this this is just the
20:17 - intermediary step this is not uh
20:20 - converted into machine code
20:23 - then this Java byte code it's uh
20:27 - taken by the jvn so it's sent to the jvm
20:31 - and the jvm then takes that Java by code
20:34 - and convert the jbox.java by code into
20:37 - something which a machine which a
20:40 - specific machine can understand but
20:43 - let's
20:44 - let's first explain why why kotlin uh
20:49 - why the jdk takes this kotlin source
20:51 - code and then it converts this kotlin
20:53 - source code into Java byte code
20:55 - and this is doing this because different
20:59 - processors and if different operating
21:01 - systems need different instructions in
21:05 - order to understand your code so if we
21:08 - are not will not to have this Java byte
21:12 - code so if we had we'll uh compile our
21:16 - code on a specific platform that code
21:19 - can run only on that specific platform
21:22 - but because our quadrant source code is
21:24 - taken by the jdk and through the
21:26 - quarterly compiler and is converted into
21:28 - Java byte code
21:30 - and the Java byte code then it's
21:34 - it's uh it it's send it to the jvm and
21:37 - jvm stands for Java virtual machine and
21:39 - the jvm then because different platforms
21:42 - and different operating
21:44 - uh different platform and different
21:46 - processors need different instructions
21:49 - the jvm is the one which is doing the
21:53 - hard work of figure out figuring out
21:55 - what kind of instruction that specific
21:58 - platform needs so it converts that Java
22:01 - by code into machine code let's say
22:02 - which a Windows platform can understand
22:05 - then the same thing happens to Linux the
22:09 - J the jvm receives the same Java byte
22:13 - code and then it converts that Java by
22:15 - according to machine code which a Linux
22:17 - platform can understand and then is
22:20 - doing the same thing
22:22 - to a Mac OS so the make waves the jvm is
22:27 - gonna is gonna receive the same Java
22:30 - byte quad and it's going to convert that
22:32 - Java by code into machine code which
22:34 - Macos can understand so this is how uh
22:38 - kotlin and Java can achieve this call
22:40 - this thing called Write once and run
22:43 - everywhere this is because the
22:46 - the work of converting that machine code
22:51 - which which a specific platform Cananda
22:54 - said has shifted from the programmer to
22:57 - the platform which has the which
23:00 - implements that jvm so we just wrote Our
23:03 - quad we run our code through the jdk the
23:07 - jdk converted that code in Java byte
23:10 - code and then the platform which has the
23:12 - jvm
23:13 - installed uh it's doing the work of
23:17 - converting that Java by code that we
23:20 - wrote into something which that platform
23:22 - that specific platform can understand so
23:25 - and this is why uh Java and Kathleen are
23:29 - fully interoperable so you can add
23:32 - you can add Java code to an existing
23:34 - kotlin program and vice versa you cannot
23:38 - uh you can add the Java you can add the
23:41 - quota link code to an existing Java
23:44 - program and that is uh that is possible
23:47 - because uh the jdk is gonna is gonna
23:52 - convert through the compiler
23:54 - all of that code into the same Java by
23:56 - code and then that code is going to be
23:59 - run on the jvm and the jvm is going to
24:01 - convert that into machine code and that
24:03 - code is going to run on a specific
24:05 - platform so this is how Java and kotlin
24:08 - and this is why Java and collecting and
24:10 - are fully interoperable because
24:13 - they uh their core they are ultimately
24:17 - converted into the same Java by code and
24:19 - you can also achieve this right once run
24:23 - everywhere because
24:24 - that code then runs on the jvm Java
24:27 - virtual machine which is doing the hard
24:29 - work or figure out what kind of
24:32 - instructions uh specific platform needs
24:35 - in order to understand that code that we
24:38 - wrote and in this way that hard working
24:42 - has shifted from us to the people who
24:45 - implement the jvm
24:47 - so this is how the jdk and The jvm Works
24:51 - under the hood
24:52 - and if you find this confusing don't be
24:54 - just this is just a relaxed discussion
24:57 - about uh how the jdk what is the jdk and
25:02 - what is the kotlin compiler because I
25:04 - said our cotton I said previously that
25:07 - our code is compiled when I said that
25:09 - this actually what was happening our
25:11 - code was taken by the
25:13 - jdkn through the jdk was covered in Java
25:16 - bytecode then it was sent to the jvm of
25:19 - uh which is on my windows and then that
25:23 - is converted into machine code and then
25:25 - we see in the output hello world
25:28 - so this is our discussion about the
25:31 - first program how to create the first
25:32 - program hello world and this is the
25:33 - additional discussion about how the jdk
25:36 - how the quartering compiler and how the
25:38 - jvm works so see you in the next video
25:41 - so in the previous video we created our
25:44 - first program and even though it was a
25:46 - simple program you should celebrate
25:48 - because you created your first program
25:50 - but if you want to make your program to
25:52 - do something useful you need to store
25:54 - data and in order to store data we need
25:56 - to use variables and this is what we're
25:58 - gonna talk about in this video therefore
26:00 - I'm going to open IntelliJ IDEA
26:07 - I'm gonna create a new project so make
26:10 - sure to that on the left hand side you
26:11 - have project selected click on this plus
26:13 - button to create a new project
26:17 - I'm going to call it variables it should
26:20 - be in Pascal case if it has multiple
26:22 - words language we have already
26:23 - constantly selected for the build system
26:25 - IntelliJ and also make sure to have the
26:28 - jdk selected here
26:30 - and now I'm gonna check this out sample
26:32 - code because this is going to generate
26:33 - the code that we typed previously
26:35 - respectively the main function and the
26:38 - print line to and the hello world
26:41 - text is going to be now Auto generated
26:43 - for us by because we check this box add
26:47 - sample code and it's going to add the
26:49 - code automatically for us so I'm going
26:51 - to click on create
27:13 - now
27:14 - our project is ready to go and as you
27:18 - can see here it generated some code for
27:20 - us and this is similar to what we've did
27:22 - in the previous video where we created
27:24 - our we'll create our code ourselves but
27:28 - we have some additional code and uh I'm
27:30 - gonna delete this additional record
27:32 - because it will make things confusing so
27:34 - I'm going to delete this part
27:37 - sorry I'm gonna delete this part
27:41 - and also uh you have may have noticed
27:45 - that uh here in inside this parenthesis
27:48 - we now we have this args array and
27:51 - string
27:52 - we can delete this too because
27:55 - it will make I think things confusing
27:59 - and we're going to talk about what are
28:02 - the arrays and all of that in the next
28:04 - videos
28:05 - now I'm gonna
28:09 - all right now ready
28:11 - now let's run this code to see
28:16 - to see what is happening it's gonna
28:17 - output that text like it did in the
28:21 - previous video
28:28 - you should open the console in a short
28:30 - moment
28:31 - and indeed it opened the console and it
28:33 - output the text hello world like it did
28:36 - in the previous video so I'm going to
28:37 - close the console now also let's expand
28:40 - this SRC
28:41 - to see the file that it was created
28:44 - automatically for us this time
28:47 - and um
28:49 - let's change this hello world text to
28:52 - print another text let's say
28:54 - let's print the
28:57 - type your name there in my case is Alex
29:00 - so I'm going to run this quad
29:02 - and it will output my name in the
29:05 - console
29:10 - all right so it outputted Hello Alex
29:13 - like we typed here
29:16 - but um
29:18 - it's what we have here is pretty pretty
29:21 - inflexible it's a better way to be to to
29:23 - do that it will be to have something to
29:27 - store this name and then refer that that
29:31 - thing here to call that thing here and
29:34 - this will be a bit more more dynamic
29:38 - and to do that we need to use variables
29:42 - and variables are
29:44 - are like some containers which can hold
29:47 - data values
29:49 - and
29:52 - let's see how to create a variable okay
29:55 - Let's uh put the the the code below
29:59 - above our print Ln statement
30:03 - and if you don't know what a statement
30:06 - is a statement is of complete
30:08 - instruction of execution
30:10 - Now to create a variable we just type
30:15 - the keyword far
30:18 - which stands for variable
30:20 - all right
30:22 - next we need to give a name to our very
30:25 - a variable to be able to refer it later
30:27 - to call it later and I'm going to end
30:29 - the naming convention around the naming
30:31 - variable is called is called camel case
30:34 - and that means that the first
30:38 - letter in the name if it has multiple
30:41 - words so start with the lowercase letter
30:44 - so I'm going to type user
30:46 - and the next word name with the capital
30:49 - letter
30:50 - all right next we need to provide the
30:52 - type of the variable and that means what
30:55 - kind of data this variable is going to
30:57 - hold it's going to store to do that we
30:59 - need to put colon and next we need to
31:02 - say what type of data is going to store
31:04 - what
31:06 - what data is going to store and we want
31:09 - to store text and to store text we need
31:12 - to type here string
31:14 - and string means that this variable is
31:16 - going to store a single a sequence of
31:17 - characters or text
31:19 - now
31:20 - we need to assign a value to this
31:23 - variable and to do that we'll put we put
31:25 - here equals
31:28 - space
31:30 - and because we express the cells here
31:33 - that we're going to put text text or
31:35 - string we put a double pair of quotation
31:38 - marks and we type Alex
31:42 - all right so now we create our variable
31:45 - we
31:47 - give it a name a type and with with also
31:52 - sine of value to this variable next we
31:54 - need to refer this variable down here
31:57 - and to to to refer that variable I'm
32:01 - going to delete this text first and to
32:04 - refer the variable we put dollar sign
32:07 - and after the dollar sign we start
32:10 - typing the name of the variable user and
32:14 - as I'm typing the IntelliJ is giving us
32:17 - some suggestions and it said do you mean
32:19 - this username variable and it also has
32:22 - this V here for variable so I'm going to
32:25 - press enter to fill in that for me
32:27 - and if I
32:31 - run this code
32:33 - you'll see the exact
32:37 - singer
32:39 - Happening Here It outputted the text
32:41 - Hello Alex but this time we didn't type
32:44 - the text directly here which we we
32:47 - stored the text in a variable and we
32:49 - call that variable in uh in our
32:51 - printerland I'm going to add a space
32:53 - here
32:55 - to make things more clear
32:56 - now what we can do is to change the
32:59 - value of this variable by
33:03 - adding below of our variable typing the
33:07 - name of the variable again user name
33:10 - equals and now we can assign a new value
33:13 - to this variable and let's put
33:17 - let's put John here
33:19 - all right let's run this code to see
33:21 - what happens now now this time when this
33:25 - uh this instruction is going to be
33:27 - called it's going to print then the new
33:29 - value of the variable which is John
33:33 - so as you can see down here it output
33:36 - the text hello John so we can change the
33:38 - value of the variable after we assign a
33:41 - value to it but what you can't do is to
33:47 - is to type here username
33:50 - equals 5.
33:53 - and if you hover over here
33:57 - it says integer literature does not
33:58 - conform to the specific type string and
34:01 - in other words it's saying that we said
34:04 - explicit explicitly up here that is
34:06 - gonna store only text and down here we
34:09 - try to put a whole number an integer and
34:13 - that is not going to work because kotlin
34:15 - is a link language which is uh which is
34:20 - called statically typed
34:22 - and that means that it it will check the
34:25 - types of the variable at compile time
34:28 - not at run time and that means it does
34:31 - it you cannot run your code if you
34:33 - assign um a value to to a variable which
34:37 - has a different type that done done the
34:40 - type that you specify specified when you
34:43 - record the variable this is why we get
34:46 - this warning here
34:47 - and if I delete this
34:53 - now let's delete this
34:56 - all right
34:59 - okay
35:00 - the next type of variable that
35:03 - also actually not the next type the word
35:07 - over the next way of declaring a
35:08 - variable is using the keyword
35:11 - file
35:12 - so if you declare if you declare a
35:14 - variable as Val Val means that we cannot
35:18 - change its value after we assign a value
35:22 - to it so if you try if you try to assign
35:25 - a new value to our variable like we did
35:27 - here up here it will not work so let's
35:31 - actually let's actually just change here
35:34 - let's put Val
35:36 - okay and and after I did that you it
35:40 - immediately underlying red username and
35:43 - it says Val cannot be reassigned and
35:46 - that is because if you declare if you
35:48 - declare a variable as Val
35:51 - you cannot change its value later it
35:54 - will you can put a value to that
35:57 - variable only once and that's all we
36:00 - cannot change the very the value of the
36:02 - variable later
36:05 - so let's change this back to VAR
36:08 - to have the ability to change the value
36:13 - now let's look at another type of
36:15 - variable so I'm gonna type VAR
36:19 - again
36:20 - I'm going to call it age
36:25 - I'm going to put colon to specify a type
36:28 - here and now we're going to use another
36:30 - type which is int and int stands for
36:33 - integer or for whole numbers now we need
36:36 - to assign a value to it I'm going to
36:38 - call I'm going to put you know 10 or you
36:42 - know 20
36:44 - 22
36:46 - all right so what we have now is a
36:49 - different type up here we have string
36:52 - and that means that we're going to we're
36:53 - going to store sequence of characters
36:54 - and down here we have integers and that
36:58 - means that we can store
36:59 - um only only numbers only whole numbers
37:03 - and there are different type of numbers
37:05 - which you're gonna look in the next
37:07 - video
37:08 - and if I try here to change this uh
37:12 - to change this so first first let's
37:15 - let's actually
37:17 - let's actually print this uh
37:21 - Hello Alex
37:23 - let's type your
37:26 - age is and here you put dollar sign
37:31 - and we call uh the name of the variable
37:33 - without the name of the variable age so
37:36 - we press enter to fill in that for us
37:39 - and if you run this code
37:47 - now says hello John your age is 22. so
37:52 - now it's using the value the values of
37:55 - this variable in our printerland and we
37:58 - can change for the variable also the its
38:01 - value because it's declared as a VAR not
38:04 - a Val so we can put here age equals
38:06 - let's say 25
38:08 - and if you run this code
38:12 - the change is reflected immediately in
38:15 - our code so now we see hello John your
38:18 - age is 25.
38:20 - what we can't do like in the previous
38:24 - example with the username Here We cannot
38:27 - put a string We cannot put hit
38:30 - Alex
38:31 - because we said explicitly here that
38:34 - this is gonna is gonna hold only
38:36 - integers only whole numbers so I'm gonna
38:38 - delete this let's put it again to 25 and
38:42 - the arrow error disappeared
38:45 - all right now
38:47 - let's look at what we have here because
38:49 - we have this underlines this uh
38:52 - uh great light out of our types and
38:56 - every time you see something like this
38:59 - that means that IntelliJ is trying to
39:01 - say something to you and if you hover
39:03 - over here
39:07 - actually let's hover over over the type
39:10 - it says explicitly given type it's
39:13 - redundant here
39:14 - and that means that uh it does not need
39:18 - to we we don't know we don't need to say
39:22 - explicitly here that is gonna hold
39:25 - of um
39:27 - sequence of characters it's going to
39:28 - hold string because it knows this you
39:31 - can because it quoting has something
39:33 - which is called type inference and that
39:35 - means that it can infer the type of the
39:38 - variable by the value we assigned to it
39:41 - in our case we assign some text so if I
39:43 - delete the type here
39:46 - now
39:48 - is still working and if I as you can see
39:51 - if I if I put here let's say if I try to
39:55 - put your username
39:58 - sorry username
40:03 - equals to tree
40:06 - is still treated as a
40:09 - string because it inferior it it
40:12 - inferred the type by the value assigned
40:15 - to it and similarly this uh this thing
40:19 - applies to to our
40:22 - int type so if I delete this
40:25 - is still working it's tilt it and it is
40:28 - still treating this as a as an end so if
40:30 - you try to put here
40:32 - age equals to a text I don't know again
40:36 - we have this yellow arrow unifarable it
40:39 - says type mismatch required int and
40:41 - found string and that means that it's
40:44 - still uh
40:46 - is still treating this uh variable as an
40:49 - in because as I said it has something
40:51 - which is called type inference and it
40:54 - can infer the type of the variable by
40:56 - the value assigned to it
40:57 - all right this is uh our discussion
41:00 - about variables there are more types of
41:03 - variables and we're going to look at
41:04 - that other types in the next videos and
41:08 - collectively they are called data types
41:11 - okay
41:13 - you can remove the space if you want
41:15 - so I'm going to end this video now and
41:17 - see you in the next video
41:19 - so while I was recording this course
41:21 - jetbrains have released a new version of
41:23 - IntelliJ IDEA
41:24 - and you will see in the course when you
41:27 - when I create a new project you will see
41:29 - a different window it's not that
41:31 - different it's slightly different than
41:33 - this window than the window that you
41:35 - will see when you download IntelliJ ID
41:37 - which is this version now which has this
41:39 - window and when you see this window here
41:42 - you just need to specify a name here you
41:44 - specify the location for the language
41:46 - selecting here you select for the build
41:49 - system IntelliJ and
41:51 - you make sure to have the jdk here and
41:54 - you also check this out sample code and
41:56 - that is going to generate the main
41:57 - function for you and you click on Create
42:00 - and the project is going to be created
42:02 - for you so I thought that it's good to
42:04 - tell you about this and uh if you'll see
42:07 - this window and if this window changes
42:09 - in the future I'm gonna release a new
42:11 - video and so I'm gonna show you how to
42:13 - if they changed specifically the window
42:15 - of creating a new project how to create
42:17 - a new project with that window but for
42:18 - now this is the window of the latest
42:20 - version
42:24 - all right so in the last video we talked
42:26 - about variables and we seen there that
42:28 - you can store different data in our
42:31 - variables and we looked at two different
42:33 - data types or types in short and that
42:36 - was the string type and that in type and
42:39 - the string type was used for storing
42:41 - sequence of characters or text and the
42:43 - in-type was used for storing whole
42:45 - numbers and in this video we're going to
42:47 - take take a deeper look at the integer
42:50 - data type and we're also going to extend
42:52 - our understanding to more
42:55 - types for storing whole numbers and that
42:57 - is the byte the short and the long data
43:01 - types for storing whole numbers you only
43:03 - gonna see what is the difference between
43:05 - this uh these types now let's open
43:08 - IntelliJ ID
43:09 - I'm going to open my IntelliJ ID
43:16 - on the left side make sure that project
43:18 - is created selected click on new project
43:24 - on the left hand side measure the cotton
43:26 - is selected and you don't need to give a
43:28 - name to a project again it should be in
43:29 - Pascal case I'm going to type
43:32 - bite
43:35 - short
43:36 - and
43:38 - long
43:41 - oh
43:42 - now go down here and it's going to
43:43 - select IntelliJ and make sure that the
43:45 - jdk is selected click on next to create
43:48 - a new project and click on finish now
43:51 - our project is going to be created
44:00 - and down here again a setting IntelliJ
44:02 - is setting up our project on the left
44:05 - hand side we have our
44:07 - project pane I can expand this SRC to
44:11 - see our file our main file that we
44:13 - created first now it was
44:16 - generated for us automatically I'm gonna
44:18 - delete this code and here we have
44:20 - something which is called the comments
44:22 - or a comment but they're going to look
44:23 - at comments in a separate video
44:26 - so I'm going to delete this
44:30 - sorry
44:32 - okay I'm gonna add this
44:34 - space here I'm gonna delete this
44:38 - you can keep the RX there it's not gonna
44:41 - affect your code in any way but I want
44:43 - to make it consistent with my previous
44:45 - videos but you can keep the arcs there
44:48 - it will make no difference in uh the way
44:51 - your code is compiled now let's add the
44:55 - code that you had previously
44:56 - and previously we had the we had a
44:59 - variable of type string for storing uh
45:04 - text specifically we store our name
45:06 - there so I'm gonna type the VAR keyword
45:08 - because
45:09 - uh in the last video we we established
45:12 - that you want to change this value later
45:13 - VAR
45:14 - and uh he didn't give a name to our
45:17 - value I'm going to call it name like in
45:19 - the previous video for the type I'm
45:20 - going to choose string
45:23 - and uh I'm gonna put equals and now
45:25 - Center sign of value to it I'm going to
45:27 - put again our text
45:30 - all right
45:31 - and down here I'm going to declare a
45:33 - variable but this time I'm going to
45:34 - declare it as a Val
45:36 - I'm gonna type I'm gonna type for the
45:39 - name H
45:42 - and for the type
45:44 - I'm gonna put int for storing the whole
45:48 - numbers I'm going to put 22.
45:50 - and we see in there that we can delete
45:54 - the type here because cotton has
45:56 - something which is called type inference
45:57 - and that means that it can infer the
46:00 - type of the variable by the value
46:01 - assigned to it so we can delete this
46:04 - type here
46:07 - and our code is going to still be valid
46:10 - and if I hover over here
46:12 - if you look at here is still treating
46:15 - this variable as type of string so
46:19 - but uh in this video I'm Gonna Leave the
46:22 - string type
46:23 - I'm gonna delete this because we're
46:25 - gonna look at the integer more closely
46:28 - and
46:30 - here let's uh
46:33 - let's change this value let's change its
46:35 - name to
46:36 - number
46:39 - and it's also going to be an INT and
46:41 - then let's take a deeper look first
46:42 - let's see what is an integer we know
46:44 - that it's a whole number so you can
46:47 - store whole numbers but what is it's uh
46:51 - it has a range you can put whatever
46:53 - value you want actually there is a range
46:56 - there is a minimum and maximum value
46:58 - that you can put in a in an integer data
47:01 - type so and to get that minimum and
47:03 - maximum value we type
47:07 - I'm going to put a space here to make
47:09 - what the code Mercury I'm going to type
47:10 - Val I'm gonna type Max integer
47:15 - value
47:17 - and for the type I'm going to choose int
47:20 - or you can let it infer the type
47:22 - you can
47:23 - I'm gonna actually put the type here but
47:25 - you can let it infer the type if you
47:27 - want equals and now we type int Dot
47:31 - and Intel J is giving us some
47:33 - suggestions here I'm gonna choose max
47:35 - value
47:36 - and Discord
47:39 - on the right here is gonna give us
47:42 - actually the entire code is going to
47:44 - give us the maximum value in a integer
47:48 - and if you don't if this seems confusing
47:50 - in that and this uppercase so
47:54 - uh you know you don't need to worry
47:55 - about that for now you just need to know
47:58 - that in this way you can get the maximum
48:00 - value to out to be out with in our
48:03 - console and for the minimum value we're
48:04 - going to type Val
48:07 - mean
48:11 - integer
48:12 - value
48:14 - for the type I'm going to choose int
48:17 - now I'm going to type again int Dot and
48:20 - again I'm going to choose from here mean
48:22 - value now to print these two values I'm
48:26 - gonna just delete this text here
48:29 - and I'm going to type int
48:34 - eger or in
48:38 - maximum
48:41 - value
48:43 - is
48:45 - I'm gonna put dollar sign to get the
48:48 - value Max
48:49 - integer value
48:51 - right
48:53 - and below this code we're going to type
48:56 - another println
49:00 - and here you're gonna put
49:02 - two pair of quotation marks again and
49:04 - I'm going to type int
49:08 - minimum value is
49:12 - dollar sign
49:17 - again IntelliJ is giving us suggestions
49:19 - you're going to choose minimum integer
49:20 - value
49:22 - now let's print this uh let's output
49:24 - this code to see what is the minimum
49:28 - maximum value which can be stored in an
49:30 - integer data type
49:33 - and if you want you can add a space here
49:36 - to make things more clear
49:49 - all right and as you can see down here
49:51 - when the console opened that the maximum
49:53 - value is 2 billion and 147 millions and
49:56 - so on and the minimum values to billion
49:59 - 147 millions and so on and these are the
50:03 - minimum and maximum values which can be
50:05 - stored in an INT so that means that you
50:09 - cannot put a value which is which is
50:10 - bigger than this
50:12 - maximum value or the watch or value
50:16 - which is uh uh which is bigger than the
50:19 - minimal values and so if you try to
50:21 - assign and to confirm that if you try to
50:24 - assign here
50:25 - a value which is bigger than the maximum
50:28 - integer value so let's uh type
50:33 - number and
50:36 - now we may be spotted the problem here
50:39 - if I try to put here equals
50:41 - it says
50:43 - Val cannot be reassigned so let's
50:45 - declare this as a bar because I want to
50:47 - change this value now
50:50 - I'm going to put equals and I'm just
50:52 - going to copy this
51:06 - I'm gonna put it here
51:10 - now if I increase this number by one
51:13 - let's say that I put 8 here now it
51:16 - immediately shows an awning and if I
51:18 - hover over here
51:20 - it says that the integer literally does
51:22 - not conform to the expected type int and
51:24 - you may be wondering
51:25 - how this makes any sense because here up
51:29 - here we said explicit that this
51:31 - variable is going to store integers or
51:34 - whole numbers and down here we have a
51:36 - whole number but the problem now is that
51:38 - this whole number is bigger than the
51:40 - maximum integer value which can be
51:42 - stored in an end which is 2 billion one
51:45 - four seven million and forty thousand
51:47 - forty three three thousand six hundred
51:50 - forty seven but now we have a bigger
51:52 - number and um
51:56 - to to store this number need to use a
51:59 - different data type or a different type
52:01 - and gonna see in the next videos
52:03 - precisely what type we need to use and
52:06 - what type we gonna use for storing a
52:08 - bigger number than the integer on the
52:10 - integer maximum value all right
52:13 - also it's important to know because he
52:16 - said he says here now the integer liter
52:20 - so you may be wonder what is this leader
52:21 - the liter is the value that you assign
52:23 - to our variable and it's called the
52:25 - literal because you assign we assign the
52:28 - value directly here so we don't have a
52:30 - what is called a symbolic name here and
52:32 - we're going to see what is a symbolic
52:34 - name in the next videos now I'm gonna
52:37 - edit this video now I'm gonna change it
52:39 - back to seven
52:42 - and also you can delete the types here
52:44 - the code is going to still work
52:47 - the code is going to still be valid
52:51 - and if you delete the type up here also
52:56 - because the type can be inferred
53:00 - like we talked about
53:02 - now
53:04 - I'm gonna add this video now and see you
53:05 - in the next video
53:08 - alright so in the last video we looked
53:10 - at the integer data type and we saw
53:12 - there that you can store a minimum and a
53:14 - maximum value in an integer and uh in
53:17 - this video we're going to look at the
53:18 - next three data types or types for
53:20 - storing whole numbers and those are the
53:22 - byte the short and the long and let's
53:24 - start with the buy to see what is the
53:26 - minimum and maximum value which can be
53:27 - stored in a in a byte so I'm going to
53:29 - type Val
53:31 - my marks byte
53:35 - value for the type I'm going to choose
53:37 - byte
53:39 - equals
53:42 - byte that
53:46 - max value
53:47 - below I'm going to type again Val this
53:49 - time I'm gonna I'm gonna call it my mean
53:53 - my um byte
53:57 - value
53:59 - for the type I'm going to choose byte
54:03 - we're gonna put equals I'm gonna type
54:05 - bite that mean value and now to print
54:09 - this to print the value of those
54:11 - variables I'm gonna copy this to
54:14 - printerland statements
54:20 - I'm going to paste it below here
54:23 - I'm going to change the text to byte
54:32 - and here we need to call our variables
54:35 - to refer all variables so I'm going to
54:38 - type
54:39 - my Max byte value just press enter to
54:43 - fill that for you
54:46 - and below here I'm gonna
54:49 - type my
54:51 - mean byte value
54:53 - now let's print this uh two varus the
54:55 - console to see what is the minimum and
54:57 - maximum value which can be stored in a
54:59 - byte data type so I'm gonna run this
55:02 - code
55:03 - now the console should
55:05 - open in a short moment
55:11 - all right as you can see the byte
55:13 - maximum value is 127 and the byte
55:16 - minimum value is minus 128 and in
55:20 - contrast with those minimum maximum
55:23 - values for the integer type you can see
55:25 - that these two are very very small
55:28 - compared to that now let's look at the
55:30 - next
55:32 - the next type which is the short and I'm
55:34 - gonna do the same
55:37 - the same
55:38 - I'm gonna type the same code AS sorry
55:45 - the same code that you had previously
55:46 - but uh
55:49 - so I'm going to put a space to make it
55:51 - more clear I'm going to close the
55:53 - console
55:54 - so let's see the short type right so I'm
55:57 - going to type Val
55:59 - my
56:00 - marks
56:04 - short
56:05 - value I'm going to put x equals
56:11 - choose short here for the type
56:15 - equals
56:17 - short
56:19 - Dot
56:23 - max value right
56:25 - I'm going to press enter I'm going to
56:26 - type again Val
56:29 - my
56:32 - mean
56:33 - short
56:38 - short value
56:41 - and for the type again short
56:45 - equals
56:47 - short that mean
56:50 - value now let's copy this
56:53 - actually we have already copied that so
56:55 - I'm going to paste that here to print
56:58 - the
57:01 - print our minimum maximum values
57:04 - so I'm gonna change this to short this
57:07 - text
57:11 - I'm gonna change it here to
57:14 - and now we need to call those variables
57:16 - because as you can see right now they
57:18 - are gray out and if you hover over this
57:20 - is the variable my Max short value is
57:22 - never used and that's a clever way to
57:24 - see when a variable is used or not
57:27 - all right let's change it
57:29 - let's change the name here because we
57:30 - want to refer those variables
57:32 - my Max short value and
57:38 - here you're gonna type my
57:40 - mean
57:42 - short value
57:44 - right let's print this to see now what
57:46 - is the minimum and maximum you can be
57:48 - stored in a short
57:56 - all right as you can see down here it
57:58 - output that the short maximum values
58:00 - minus
58:01 - 32
58:03 - 000 70
58:04 - 167 and for uh the short minimum value
58:09 - is minus 32 770 168 right and if you
58:14 - look at the the previous data types you
58:18 - can see that the integers the the
58:21 - biggest is the is the type which can
58:24 - store the biggest number but uh there is
58:28 - one actually which is bigger than the
58:29 - integer so I'm gonna type now the next
58:32 - dot that I put you gonna look at and
58:34 - that is the long which is um
58:37 - much bigger than the in integer so I'm
58:39 - going to close the console I'm going to
58:41 - type the same code
58:44 - I'm going to type Val
58:46 - my
58:51 - Max
58:53 - long value
58:55 - for the type I'm going to choose long
58:59 - and we're going to put equals long I'm
59:02 - going to put that marks value again Val
59:07 - my
59:08 - mean
59:10 - long value
59:12 - for the type I'm going to choose long
59:15 - equals again I'm going to choose now I'm
59:18 - going to type again long
59:20 - Dot
59:22 - minimum volume
59:24 - now I'm going to paste that code below
59:26 - here to Output our
59:28 - variables to Output the minimum maximum
59:31 - bar which can be stored in a long data
59:33 - type so I'm gonna
59:36 - so I'm gonna change this to Long
59:40 - I'm going to change this text also to
59:42 - Long
59:48 - now I need to refer this those two
59:50 - variables up here from up here
59:54 - so I'm gonna
59:56 - delete this I'm going to type my
59:59 - marks
60:02 - long value so I'm going to choose that
60:04 - press enter
60:06 - and here you're going to choose uh I'm
60:08 - going to type my
60:12 - mean long
60:17 - value let's output this uh
60:21 - code to see
60:23 - let's run actually our code to see what
60:26 - is the minimum marketing what you can be
60:27 - stored in a long data type and as you
60:30 - can see the range for the longest much
60:33 - bigger contrast that with the the
60:36 - integer data type you can see that it's
60:39 - a lot a lot bigger this number so the
60:42 - longest has a more is
60:46 - has a range which is much bigger than
60:49 - the integer and
60:52 - I'm going to end this video now and in
60:54 - the next video we're going to look at
60:55 - how we can use those types and um what
61:00 - are the relationships between between
61:02 - them right
61:04 - so I'm going to end this video now and
61:06 - see you in the next
61:07 - all right now it's time to use those for
61:10 - uh data types for storing whole numbers
61:12 - in our code so I'm gonna type some code
61:14 - below of those prison Talent statements
61:17 - I'm going to type Val
61:19 - because I want this very well to be
61:21 - immutable I don't want to change this
61:22 - value later
61:23 - I'm going to call it my number it should
61:25 - be in camel case like our last names and
61:28 - for the type I'm not Define explicit
61:31 - data type here I'm going to put equals
61:32 - I'm going to put the literal value 28.
61:36 - and if I hover over my number
61:39 - you can see that the type which was
61:41 - inferred is an INT now I might be
61:44 - wondering how this makes any sense
61:46 - because this 28 can easily fit in a byte
61:48 - or in a short on a long
61:50 - and that is because the default data
61:53 - type which is automatically inferred is
61:56 - the integer so actually let's confirm
61:59 - that this can fit easily in other data
62:02 - types
62:03 - by running our code to see what at the
62:05 - menu and you can see that that number
62:08 - can easily fit in any of those data
62:10 - types from this list and
62:13 - that is not happening because the
62:15 - automatically as I said the default type
62:17 - which is in third is the integer and if
62:20 - you want this type to be a byte we need
62:22 - to explicitly say explicitly say here
62:25 - buy it
62:27 - now if I hover over here you can see
62:29 - that now it's a byte
62:31 - and if I want to be a short
62:33 - we need to type explicitly here short
62:38 - so if I hover over here now this is a
62:41 - short and if I want to be I want this to
62:44 - be along I just type again here long and
62:47 - for the long there are two ways this is
62:49 - the first way to type
62:50 - the the type explicitly here
62:54 - sorry hover over here it's long or
62:58 - we can put IL suffix at the end of our
63:02 - number
63:04 - but if I put a lowercase letter you eat
63:07 - it immediately show this warning which
63:09 - says use an uppercase L instead of fail
63:12 - and that is because this can easily be
63:13 - confused with one so I'm gonna put a
63:16 - napper KSL
63:18 - and if I hover over here
63:20 - now this is a long even though this can
63:24 - be
63:25 - can be easy can easily fit in any other
63:28 - data type
63:30 - and if I delete this cell and if I
63:33 - exceed the maximum value which can be
63:35 - stored in an integer let's say I put 28
63:37 - or something here
63:39 - and if I hover over here
63:41 - you can see that now it inferred the
63:43 - type to be as long because now this
63:46 - number that I have here exceeds the
63:49 - maximum value which can be stored in an
63:51 - INT and um you may be wondering now when
63:54 - to use one or the other want to use the
63:56 - byte I want to use the short when to use
63:57 - the long and you will find the the
64:01 - answer with the practice where with the
64:04 - working with them but if I run this code
64:12 - the byte and the short will be used in
64:14 - very specific cases and most of the time
64:17 - you'll be working with the integer data
64:19 - type right
64:21 - now I'm gonna end this video and see you
64:23 - on the next video we're gonna talk about
64:25 - the next
64:27 - data types which are the floating data
64:30 - types and those are types which you can
64:33 - hold the numbers which have a fractional
64:36 - part or decimals so see you in the next
64:39 - video
64:44 - all right before we start our discussion
64:45 - about the floating Point numbers
64:47 - respectively about the float and double
64:49 - data type it's important to know what
64:51 - are the difference between the data
64:53 - types for storing whole numbers under
64:55 - the hood because we know now that there
64:58 - is a minimum maximum value which can be
65:00 - stored in those data types and also we
65:04 - need to know what amount of space they
65:07 - occupy under the hood and let's start
65:08 - with a byte and our byte occupy eight
65:12 - bits right
65:14 - so abide occupy bits and we say that a
65:18 - byte has a width of 8. and a short can
65:22 - store La J range of numbers and occupy
65:25 - 16 bits and has a width of 16. an end
65:29 - has a much larger range as you know an
65:31 - occupies 32 bits and has a width of 32.
65:35 - the point here that each data type
65:37 - occupies a different amount of memory we
65:39 - can see that an internet is the four
65:41 - times the amount of space that abide
65:43 - does for example
65:44 - it's not particularly relevant to you to
65:46 - know these numbers but it come up as an
65:48 - interview question and it's useful to
65:50 - know that a certain type takes up more
65:53 - space than others all right now let's
65:56 - close our project because I'm going to
65:58 - create a new project
66:03 - now I'm going to click here on new
66:05 - project because we have our previous
66:07 - project here
66:14 - all right on the left hand side again
66:16 - kotlin should be selected for the name
66:18 - I'm going to call it um
66:21 - it should be in Pascal case
66:23 - float
66:30 - and double
66:33 - all right here is Eric for the best
66:35 - system IntelliJ and for the produce jdk
66:38 - select the indicator I'm going to click
66:41 - on next and I'm going to click on finish
66:42 - now approach is going to be created
66:49 - [Music]
66:59 - right let's delete this code
67:07 - we can keep the arcs and the array
67:10 - string here I'm going to keep it to see
67:11 - that there is no but there's not it's
67:14 - not making any difference in our
67:18 - code
67:20 - I'm going to drain the I'm gonna delete
67:22 - the print again statement
67:25 - and I'm gonna
67:27 - expand this to the left because we don't
67:29 - really need the project pane
67:32 - actually I'm going to expand it full
67:37 - then click here to hide the project pane
67:40 - all right
67:42 - um
67:44 - floating Point numbers are used for
67:46 - storing numbers which have a fractional
67:49 - part which have decimals so floating
67:52 - Point numbers are used when you need
67:54 - more Precision in your calculations and
67:57 - you'll as you'll see in the next video
67:59 - this uh
68:01 - has a practicality now to
68:05 - declare a floating Point number just
68:08 - type
68:09 - Val
68:11 - because I want this variable to be
68:13 - multiple
68:14 - I'm going to call it my number again
68:17 - should be in camera case now first
68:20 - letter first
68:22 - word starts the color case later and the
68:24 - following Awards should start with
68:26 - capital letters
68:29 - and for for the type I'm going to choose
68:32 - let's actually not choose any type let's
68:35 - just put equals and try to try here to
68:38 - assign a value let's put 2.5
68:41 - okay
68:43 - now if you hover over here
68:46 - and if you look at what type this value
68:49 - has
68:51 - what type this variable has you can see
68:53 - that the type which was inferred is the
68:55 - double
68:56 - so
68:59 - if we want to change the type we can
69:03 - put here
69:04 - float let's say to be a float
69:09 - but look what happens when we do this
69:13 - it says that the floating Point
69:14 - literally does not Comfort the safety
69:16 - type float and that is because like you
69:20 - know in our example with the integer the
69:25 - type which is inferred which is
69:28 - automatically assumed by kotlin is
69:32 - double in this case so even though it is
69:34 - set here explicit that you're going to
69:36 - store a float because it types here a
69:38 - literal value it considers this to be a
69:40 - double so to solve this you need to
69:43 - delete this from here
69:48 - and put here at the end of our number
69:50 - and F
69:51 - now if I hover over here
69:55 - now the variable has the type float so
69:59 - this is how you declare a float variable
70:01 - into put if at the end of the number of
70:04 - suffix
70:05 - and the
70:06 - for the for declaring a double you can
70:09 - just uh
70:12 - type Val let's call it my
70:15 - second
70:19 - number
70:21 - equals and if I put 2.5 here
70:25 - 0.5
70:27 - now if I hover hover over here like in
70:29 - uh like I said previously it
70:32 - automatically infer the type to be a
70:33 - double so if you don't specific I if you
70:36 - don't specify a type the automatically
70:39 - inferred type will it will be a double
70:41 - because this is the
70:44 - type which is uh inferred
70:47 - for the floating Point numbers and this
70:50 - is similar to the integer type because
70:52 - there we've seen that the type which is
70:55 - automatically enforcedent so here we
70:58 - have the same thing
71:00 - so this is how you can declare a
71:01 - floating Point number and this is how we
71:03 - can declare a double now what is the
71:06 - difference between this the different in
71:09 - the Precision in which
71:12 - depression with a half and we'll see in
71:15 - the next example in the next video
71:18 - we're going to be talking about
71:19 - operators and operations
71:22 - what is the what is the Precision of a
71:25 - float and what is the position of a
71:26 - double and the float comes from a
71:29 - floating Precision number and double
71:32 - comes for double Precision number and as
71:34 - the name implies
71:36 - the the double data type has a more has
71:40 - more Precision in our calculation and
71:43 - you're going to see an example of this
71:45 - in the next
71:46 - video because you need to First learn
71:49 - about operators and operations before we
71:52 - we introduce any kind of operator here
71:54 - even though we we've already used an
71:58 - operator which is the assignment
71:59 - operator which is this operator here but
72:01 - we're going to talk about this in the
72:03 - next video
72:04 - so I'm gonna end this video now and see
72:07 - you in the next video we're going to
72:08 - start our discussion about operators and
72:10 - also in that video you're going to see
72:12 - uh that the float has a smaller
72:15 - Precision than a double and the double
72:17 - is assumed to be
72:19 - it's assumed to be the default ibicos
72:21 - has a bigger procedure so
72:25 - I'm gonna end this video now see you in
72:27 - the next video but before we end our
72:30 - video actually let's uh print let's
72:32 - output those values in our console let's
72:34 - output the values of the variables in
72:36 - our console so I'm going to type println
72:39 - statement
72:40 - below for code below the creation of our
72:43 - variables and inside the parenthesis I'm
72:46 - going to put the double pair of
72:48 - quotation marks I'm going to type my
72:56 - number
72:57 - equals
73:00 - dollar sign to get a value
73:03 - the content of my
73:05 - number
73:07 - and
73:09 - my
73:10 - second
73:11 - [Music]
73:13 - number
73:17 - we put equals
73:19 - again dollar sign
73:24 - not here
73:29 - my second number now let's finish those
73:31 - values
73:35 - in our console
73:38 - and as you can see output is 2.5 and 2.5
73:41 - but if I hover over here
73:44 - you can see that the type for uh because
73:47 - it's explicitly given here is the float
73:49 - if I hover over here this is the double
73:51 - but let's see what happens if I delete
73:54 - the fractional part and I just actually
73:57 - you can uh you can put a lowercase if
74:00 - lowercase f here or an uppercase F like
74:03 - this if you run this code again
74:10 - you'll have the same output
74:12 - again now let's uh
74:14 - delete the fractional part and just let
74:17 - an F there and here let's also delete
74:21 - the fractional part and it's
74:23 - let's run our code and you may be
74:27 - know what is going to happen now
74:35 - printed 2.0 for uh my number because we
74:39 - said exclusively here that this is a
74:40 - flow so it prints the fractional part
74:42 - but uh okay in the case of my number you
74:46 - only output is the 2 because now this is
74:49 - inferred if you hover over here as an
74:51 - INT so one
74:54 - solution to this maybe to type here
74:57 - double
75:01 - and try to see what happens and if I
75:04 - hover over this hover over here says the
75:06 - interior in the integer literally does
75:08 - not conform the expected to tie double
75:10 - and it's correct because this is assumed
75:12 - to be a need so you cannot uh you cannot
75:16 - even though it said exclusive here that
75:18 - this is going to store doubles here we
75:21 - put an INT an integer value
75:23 - so if I delete the type here
75:26 - let's say if I try to put a d here
75:28 - actually there is no D for the double
75:32 - there is no like in the case of the
75:35 - float you know if even if I try to put
75:37 - the uppercase there is no
75:40 - uh way to add the suffix to our
75:42 - variables the only way is to put
75:44 - directly here to point zero and now
75:49 - this is
75:51 - inferred as a double
75:53 - as you can see here
75:55 - and if I run this
76:02 - now it output the 2.0 and 2.0 in both
76:06 - four variables
76:08 - all right I'm gonna end this video now
76:10 - and uh see on the next video
76:15 - [Music]
76:17 - all right so far in our course you've
76:19 - only dealt with data types which can
76:20 - store numbers but there are two
76:23 - different data types which you're gonna
76:25 - look at in this video which you can use
76:28 - for storing a different type of data and
76:30 - we're going to see what kind of data we
76:33 - can store but those data types are
76:35 - called the Char data type and the
76:36 - Boolean data type but first let's create
76:38 - our project let's create a new project
76:42 - I'm gonna give it a name
76:44 - I'm going to call it char
76:46 - and
76:47 - Boolean again it should be in Pascal
76:49 - case
76:51 - make sure for the build system that you
76:53 - select IntelliJ and measure that have
76:55 - the produce jdk selected so I'm going to
76:57 - click on next to create our project I'm
76:58 - going to click on finish
77:00 - now project is going to be created
77:05 - on the left hand side we have the
77:06 - project pane
77:07 - we have our code Auto generated for us
77:10 - even though this code is gonna we're
77:12 - gonna delete this code which is inside
77:14 - the curly braces because you don't need
77:16 - a squad so I'm going to delete this code
77:20 - and let's also hide the project pane
77:23 - because you don't need a project pay
77:25 - and
77:27 - let's see how we can declare a chart
77:30 - data type and after that we're gonna
77:31 - talk about
77:33 - how where you can use the shutter type
77:36 - in a specific case and what specific
77:37 - cases you can use so I'm going to type
77:39 - Val because I want this variable to be
77:42 - mutable I don't want to change valid
77:44 - value later
77:45 - I'm going to call it my
77:47 - Char value
77:50 - again it should be in camel case
77:53 - and for the type I'm going to put colon
77:55 - I'm going to choose char
77:58 - press enter
78:00 - let's put equals and let's now assign a
78:03 - value to this variable so this time I'm
78:06 - gonna type
78:07 - a single pair of quotation marks not a
78:10 - double pair of quotation marks like we
78:12 - did in our string data type and in a
78:15 - chart data type we can store only a
78:19 - single sum symbol and that symbol can be
78:21 - a letter a number or an
78:24 - exclamation point on the mark
78:27 - so I'm gonna put here a d a single
78:30 - letter D and uh you may be wondering now
78:33 - what is this what is a specific case
78:35 - when you where you can use a charter
78:37 - value a specific case can be let's say
78:40 - if you want to store the last key press
78:41 - the bio user so this is a specific case
78:46 - where you can use the charter data type
78:48 - now let's print this value in our
78:50 - console
78:51 - to see that
78:53 - it should be in a lowercase letters
78:55 - pinterland
78:57 - and uh you can print it by the usual or
79:02 - you put here a double pair of quotation
79:04 - marks and we type a dollar sign and hero
79:07 - we type the name of our variable match
79:10 - our value
79:11 - press enter
79:13 - I messed up the code let's delete this
79:16 - now if I run this
79:24 - the console will start in a short moment
79:28 - and you're gonna see the output
79:31 - of the letter d
79:38 - right so the console opened and now we
79:40 - have output down here the letter d
79:43 - so this is the usual way how one of uh
79:48 - referring a variable that but you can
79:50 - refer the variable even
79:52 - like this
79:55 - by not putting the dollar sign
79:59 - deleted the dollar sign and also the
80:03 - the quotation mark at the beginning now
80:06 - if I run this
80:14 - it's going to still output the battery
80:18 - so we will see that we have now most of
80:20 - the letter A so this is another way of
80:21 - printing the value even in a variable
80:23 - but this uh
80:25 - it's not really the usual way to do it
80:28 - now
80:30 - um let's take a look at the next data
80:32 - type and that is the Boolean data type
80:34 - and to declare a boolean.type we type
80:36 - again Val because again I want this to
80:38 - be multiple and and I'm going to call it
80:41 - my
80:42 - in camel case it should be
80:47 - Boolean value
80:50 - for the type choose
80:52 - Boolean
80:54 - and a Boolean a Boolean data type Can
80:57 - Only Store
80:59 - a true or a false or a false value
81:03 - so you can only assign here true
81:08 - or false
81:10 - so if you type now let's put in those
81:13 - values but this time I'm going to put
81:16 - the parenthesis and I'm going to put the
81:19 - quotation marks I'm going to type my
81:23 - char
81:24 - let's
81:26 - my char
81:28 - value equals
81:31 - dollar sign
81:33 - my chart value
81:36 - and
81:38 - my
81:41 - let's type the name here
81:47 - Boolean value
81:50 - equals and let's put the dollar sign
81:54 - my Boolean value now if we run this code
82:04 - now you can see that my chart value
82:06 - which is this text here
82:10 - has this value which is the content of
82:13 - this variable that we're referring here
82:14 - and uh
82:16 - my Boolean value which is our variable
82:21 - the name of our variable has the content
82:23 - of false so it printed here false now
82:27 - Boolean data types the Boolean Atlas are
82:31 - going to be used in our code a lot
82:33 - because the Boolean data types can be
82:36 - used for controlling the flow of the
82:39 - program so you can in you're gonna see
82:42 - that in combination with the if
82:44 - statement without which you're going to
82:46 - look at in the next video on the next
82:48 - videos uh you can control you can
82:52 - actually control the flow of the program
82:53 - because usually the flow the program is
82:55 - from top to bottom and with the for with
82:58 - the the Boolean data type and with an if
83:01 - statement as you'll see you can control
83:03 - uh actually what
83:04 - you can control to you can control what
83:08 - parts of the code are
83:12 - uh compiled or not
83:14 - based on a certain condition if that
83:16 - function is false or if that condition
83:18 - is true
83:19 - so Boolean dial types are going to be
83:21 - used as you'll see a lot in our code in
83:24 - your coding career as you'll see
83:28 - so these are the
83:30 - two
83:31 - data ties that can be used for storing
83:34 - either a single character or a or
83:42 - a character and this is the data type
83:44 - which can be used for storing true or
83:46 - false which is called the Boolean type
83:49 - also you
83:51 - May so already that you can delete the
83:55 - types yet because as we talked about
83:57 - kotlin has what is called the type
83:59 - inference so can it infer the type by
84:02 - looking
84:03 - at what value assigned to it so in this
84:06 - case
84:08 - you know it knows that this is a type of
84:10 - chart so here you know you can see that
84:13 - the type is a Boolean
84:15 - all right but before we end our video
84:17 - let's do a little recap
84:19 - about the eight data types that we
84:22 - looked at into throughout these videos
84:23 - and the eight data types are the byte
84:27 - short int and along those are for
84:30 - storing the whole numbers
84:32 - and the next two data types are the
84:34 - float and double for storing floating
84:36 - Point numbers for numbers which have a
84:39 - fractional part decimals
84:41 - and the next two ones are the ones that
84:44 - we looked at in do this video and those
84:46 - are the Char and the Boolean
84:48 - and those data types are also called the
84:51 - primitive data types because it has to
84:55 - do with their call like that because it
84:56 - has to do with how they are stored in
84:58 - memory
84:59 - and a string data type is not really A
85:03 - Primitive Delta because the store is
85:05 - stored a little differently also as you
85:07 - can see
85:08 - the string data type has a special
85:11 - language support
85:12 - so you can consider this eight primitive
85:16 - data types as the building blocks for
85:19 - data manipulation and in the next video
85:21 - we're gonna look at those this data
85:23 - manipulation but by looking specifically
85:25 - at
85:26 - what operations we we can do with the
85:29 - those data types because
85:33 - in uh throughout this this video we only
85:35 - looked at how we can store values and
85:38 - how we can output this those values but
85:40 - in uh in a real real app you'll need to
85:44 - to manipulate that data to other to
85:47 - subtract something and we're going to
85:48 - look at all of this in the next video
85:51 - see you next
85:57 - all right so far in our videos we've
85:59 - only looked at how we can store
86:01 - different values in our variables how to
86:03 - Output them to the console but in a real
86:06 - app you'll need to do some mathematical
86:08 - calculations so in this video I'm going
86:10 - to learn about that we're going to look
86:12 - at operators so first let's create a new
86:14 - project I'm going to click on new
86:16 - project I'm going to speed up the
86:18 - process now a little bit because we did
86:19 - this already
86:21 - a few times so I'm going to call it
86:23 - operators
86:24 - I'm going to select IntelliJ click on X
86:26 - and click on finish
86:28 - now our project is going to be created
86:30 - in a short moment
86:32 - again on the left hand side you have the
86:34 - project Pane and we have the main effect
86:36 - function and the
86:38 - code Auto generator for us
86:40 - now we're going to delete the code
86:42 - inside the curly braces inside the
86:44 - calibrations of main function because it
86:46 - only Discord
86:47 - and also I'm going to hide the project
86:49 - pane because I don't need the previous
86:50 - Pane and first let's declare two
86:54 - variables I'm going to declare the first
86:55 - variable as a VAR because I want to
86:58 - reassign this value later I'm going to
87:00 - call it um
87:03 - uh let's say um
87:06 - X and in a real app you should use more
87:09 - descriptiveness because
87:10 - the name of the variable should say what
87:13 - the variable is doing anyway I'm gonna
87:17 - put equals I'm going to assign a value
87:19 - of five
87:20 - and the next variable I'm going to
87:21 - declare it as a Val because I don't want
87:24 - to change its value later
87:26 - I'm going to call it I I'm going to put
87:28 - a value of 3 here
87:30 - and next I'm going to decode another
87:31 - variable this is going to be also
87:35 - or Val I'm going to call it result
87:38 - and we're going to store the
87:42 - sum of 5 and 3 here and to do that type
87:45 - here x
87:47 - and this is the first operator that
87:49 - we're going to looked at look at and
87:52 - that is the add or the plus operator so
87:55 - I'm going to put here X Plus
87:58 - I
87:59 - now
88:01 - let's print this result I'm going to
88:04 - type println
88:07 - I'm gonna put the double pair of
88:10 - quotation marks I'm gonna type result
88:11 - the text
88:13 - equals dollar sign
88:16 - to get the value of the variable here
88:19 - I'm going to press enter to fill that
88:20 - suggestion for me and now let's run this
88:22 - code to see what is going to Output
88:24 - you're gonna see the output 8 here
88:26 - because
88:27 - five plus three is eight
88:30 - the console should open in a short
88:32 - moment
88:33 - right so it output the result equals to
88:37 - eight because five plus three is eight
88:39 - now what we have differently here and we
88:42 - didn't uh we didn't have we didn't had
88:45 - previously is that now we're using a
88:47 - variable the variables here and we're
88:49 - not using liters like we have here five
88:52 - and three type directly
88:54 - and um
88:55 - it's important to to clarify some
89:01 - names here and first is the name operand
89:04 - and open an operand is any object which
89:08 - which isn't affected by an operator in
89:10 - our case the operands are X and I
89:13 - because those those variables are
89:16 - affected by the operator plus because it
89:19 - sums their values and then it puts these
89:23 - values in the variable result so those
89:26 - two variables X and I are called operand
89:29 - also the if you had here little revolves
89:32 - if we put it here let's say 5 and 3.
89:38 - directly these two all are also called
89:41 - operands so literals or variables are
89:44 - called the operands any
89:46 - any objects which is affected by an
89:48 - operator is called an operand because if
89:50 - you now if you
89:53 - now you're gonna see also eight here but
89:56 - let's change it back to
89:58 - to I
90:00 - and X
90:02 - and there is another way to
90:05 - to
90:06 - output the value of x plus I by using a
90:09 - placeholder what is called the
90:11 - placeholder and to do that let's first
90:12 - delete this line of code
90:15 - and
90:17 - this now is red because we don't have
90:19 - the variable declared I'm gonna delete
90:22 - what is inside the quotation marks I'm
90:25 - gonna I'm gonna type here X plus I the
90:28 - text equals and now I'm gonna put here
90:32 - I'm going to put here dollar sign and
90:34 - I'm gonna put curly braces
90:36 - and inside the color braces I'm going to
90:39 - type Let's uh click here to make it
90:42 - clear
90:43 - X
90:45 - plus I
90:48 - so this is called the placeholder and
90:51 - you can use this and in a placeholder we
90:55 - can only put
90:56 - expressions and an expression is a
91:00 - construct which evaluates to a single
91:02 - value so in our case
91:05 - X plus I evaluates to a single value
91:07 - because it Returns the value 8 so this
91:11 - is why we can put here uh X plus I and
91:14 - uh
91:15 - even though if you if you if if you put
91:18 - something which you will not uh
91:21 - be an expression here IntelliJ is going
91:24 - to warn you and I'm gonna see uh in the
91:27 - following minutes
91:28 - um an example of that now let's out for
91:31 - this
91:33 - and you're going to see the same result
91:34 - but now we have the different text here
91:37 - we're gonna have we're going to have X
91:38 - plus I so now I have X Plus PSI equals
91:40 - eight which is the correct result now
91:42 - let's copy this four times and to do to
91:45 - make that easier we can press Ctrl D or
91:50 - command D on Mac
91:52 - so I'm gonna press Ctrl D four times
91:56 - now let's change this to
91:59 - minus because we're going to look at the
92:01 - subtraction
92:04 - now here we're gonna look at I'm gonna
92:07 - look at the multiplication operator
92:10 - which is an Asterix operator so I need
92:13 - to put here inside the curly braces the
92:14 - Asterix because these were
92:17 - the expression is evaluated and the next
92:21 - is the division so we're going to put
92:22 - here a photo forward slash
92:26 - so I'm going to put here also forward
92:28 - slash
92:32 - forward slash right and you know this uh
92:36 - this operators for a month class this
92:40 - one but the one that is not so well
92:42 - known outside the programming uh it's uh
92:46 - it's called the modulus operator
92:49 - and the modulus operator is operator
92:51 - which
92:53 - um
92:54 - gives us the reminder of a division so
92:58 - the models operator is a percent sign so
93:02 - put per second sign here and percenter
93:05 - sign here
93:07 - right
93:08 - now if you run this code
93:17 - all right so now we have the output down
93:20 - here and we have X plus I see eight
93:23 - because five plus three is eight x minus
93:24 - I is 2 because 5 minus uh
93:27 - 3 is 2 x times Y is 15 because 5 times 3
93:32 - is 15 x divided by Y and this is
93:35 - interesting is 1 but because those
93:38 - variables are of typing they're inferred
93:41 - automatically to be of type in it
93:43 - dropped completely the fractional part
93:45 - here so we don't have here 1.6 or
93:48 - something you have only the integer part
93:51 - which is one and here we have the the
93:55 - modulus operator and this gives us the
93:57 - remainder of 5 divided by 3 which is 1
94:01 - and has a reminder of two
94:03 - now if you want to to have here the
94:07 - fractional part you need to declare uh
94:09 - one of the variable uh as a type as a
94:13 - floating Point number and that can be or
94:16 - or either a float or a double so then
94:19 - I'm going to declare the
94:21 - the I variable as a double so I'm going
94:23 - to put 3.0 Here and Now
94:27 - all the variables all the results here
94:29 - are going to be are going to be are
94:31 - going to be of type double so if you run
94:35 - this
94:36 - you're gonna see
94:37 - the fractional part for all the
94:39 - variables here
94:42 - now you can see now we have wipe one
94:45 - 8.0 2.0
94:47 - 15.0 and here we have 1.6666 and 7.
94:54 - now it shows also the fractional part
94:56 - and uh for the reminder all we've we've
94:59 - also have the fractional part here so
95:03 - um now the type of the if you want the
95:07 - type of the expression it's a double
95:09 - because we declare here as a double this
95:12 - variable I as a double and the next one
95:14 - is wide then automatically you don't
95:17 - need to declare also the ex as a double
95:20 - it will be
95:22 - um so if you want widen automatically by
95:24 - the fact that it required the I variable
95:27 - as a double
95:32 - all right
95:33 - and let's continue
95:35 - and often in programming you'll want to
95:38 - increase
95:40 - a variable by a certain number and to do
95:44 - that let's first
95:46 - let's declare again the variable result
95:49 - down here
95:51 - let's declare it as a VAR because I want
95:54 - to resign it
95:56 - let's call it result
95:59 - and let's put again X
96:03 - plus I here
96:07 - now if you want to increase let's say
96:10 - the the value of the variable by 2 we
96:12 - can type something like a result equals
96:15 - result
96:16 - let's say that I want to increase this
96:18 - variable by 2. I'm going to put result
96:20 - equals result Plus 2.
96:23 - and
96:24 - this equals operator is different from
96:28 - a mathematical equals because this equal
96:32 - separate operator is not saying that
96:34 - result equals result plus 2 because I
96:37 - think it's incorrect what this equals
96:39 - operator is is also called it's an
96:42 - assignment operator and what is doing is
96:45 - that it assigns
96:48 - first it adds to to our variable result
96:52 - and then it store stores that that
96:57 - result that result of the that
96:59 - expression in our variable result all
97:02 - right so let's print this value to see
97:05 - what we have here so if I print this
97:08 - you should see
97:10 - 10 here
97:14 - not print
97:18 - I'm and I'm going to put here result
97:22 - equals
97:25 - dollar sign
97:27 - result
97:28 - and in front this code you're going to
97:30 - see 10.
97:38 - right so you have 10 but let's uh let's
97:40 - delete the
97:42 - the fractional part here to
97:45 - have the type of the variable as
97:47 - integers so let's run this code again
97:54 - so now we have 10 here result equals 10
97:56 - and let's copy this called the
97:59 - again four times
98:03 - let's add a space
98:06 - so now I messed up the code and if you
98:09 - mess up the code like I did here you can
98:10 - do you can undo this thing by going to
98:13 - edit and click on undo paste or the
98:17 - shortcut is Ctrl Z and you'll see the
98:22 - corresponding shortcut in a Mac here on
98:25 - the right so please press here and now
98:28 - our code is restored here as you can see
98:30 - so let's copy this again
98:35 - foreign
98:40 - and let's space this down so one
98:44 - two three
98:48 - four
98:51 - all right now let's change this this one
98:53 - to minus
98:55 - let's change this to multiplication
98:58 - which is the Aesthetics operator
99:01 - let's change this to division which is
99:03 - the follow slash
99:07 - and let's change this to modulus which
99:10 - is the percent sign
99:12 - now if you run this code let's run it
99:14 - from the top right right hand side now
99:22 - what you're going to see is that first
99:25 - we have 10 because of now
99:29 - the result has a value of 8 because X
99:33 - plus sign is 5 plus 3 we have eight and
99:36 - now here we we're adding 2 to our result
99:39 - and then we print that value in that
99:42 - variable in our
99:44 - in our console and that is gonna output
99:46 - 10. the next we
99:49 - decrement that variable by 2 and we have
99:52 - eight
99:53 - next we multiply
99:56 - that that uh
99:59 - variable by tools so we have 8 times 2
100:02 - which is 16 which is the result here
100:05 - next we have a result divided by two and
100:09 - uh
100:11 - 16 divided by 2 is 8 so you have eight
100:16 - eight here
100:17 - now
100:19 - now we have result
100:22 - modulus 2 and 8 modulus 2 is 0 because 8
100:27 - divided by
100:28 - by 2 has no reminder right
100:35 - next you can see that we have all of
100:37 - those underlines here and if you hover
100:39 - over one of them it's gonna say
100:41 - replaceable with operator assignments so
100:43 - there is a shorter wave to write the
100:46 - same thing that we have here or there is
100:49 - an abbreviation to write the same thing
100:51 - that we have here and here and here and
100:53 - here because they are so often used in
100:55 - programming they are there is a
100:58 - abbreviation for all of them so let's
100:59 - click on replace with plus and equals
101:03 - replace with minus n equals
101:07 - replace with the
101:09 - multiplication and equals
101:12 - with division and equals and with
101:14 - modulus n equals here
101:20 - all right so this is the abbreviation of
101:23 - what we had previously or a short way a
101:26 - shorter way to write the same thing so
101:28 - if you run this code now you're going to
101:30 - see that it's going to Output the exact
101:32 - uh
101:35 - values that you had previously so we
101:37 - have 10 8 16 8 again and zero so this is
101:41 - a shorter way of
101:43 - abbreviating uh oh actually this is a
101:46 - way of abbreviating what we had
101:48 - previously because as I said they are
101:49 - very very often used in programming what
101:52 - is
101:53 - all right now
101:56 - another important thing to know is
101:59 - operator precedence so first let's type
102:02 - again a println statement
102:06 - and I'm going to put the worker
102:08 - recognition marks and inside the
102:09 - quotation marks I'm going to put the
102:11 - text to three
102:13 - so this is the text three plus three
102:17 - times let's say um
102:20 - four
102:22 - now
102:24 - also inside the quotation marks let's
102:27 - put a dollar let's put equals here
102:30 - the text and let's put a dollar sign
102:32 - here and now let's put curly braces
102:35 - and inside the curly braces I'm going to
102:37 - put three
102:39 - plus three
102:41 - times four
102:47 - let's click here to make it clear times
102:50 - 4. now if you run this code
102:59 - now
103:01 - you see that it outputed 15 because
103:08 - multiplication has precedence over
103:11 - addition so it first
103:13 - multiplies 3 times 4 which is 12 and
103:17 - then it adds 3 to our results so we have
103:21 - 15. but like in a math class you can
103:24 - control which
103:27 - expression is evaluated first by putting
103:29 - parentheses so if I put parenthesis here
103:35 - now this will be evaluated first three
103:38 - plus three and then it will multiply the
103:41 - result by four so if you run this code
103:43 - you're gonna see three plus three is six
103:45 - times four
103:47 - is 24.
103:49 - so you're going to see 24 right now so
103:51 - you can see that operators have
103:53 - precedence but can control that
103:55 - precedence using parentheses like you
103:57 - did here so multiplication and division
104:00 - have precedence over
104:03 - additional and subtraction
104:06 - all right there are two other operators
104:09 - which can be used for increasing or
104:12 - decreasing the value of a variable
104:14 - exactly by one and let's look at this
104:17 - operator
104:19 - but first let's uh use our variable X
104:22 - that we declare above
104:24 - and let's assign a value of 0 to it
104:29 - and to use the
104:32 - increment and decrement operator this is
104:35 - how they are called
104:37 - let's use the printerland statement
104:39 - first to
104:44 - let's put a double pair of quotation
104:46 - marks here
104:47 - and
104:49 - let's type
104:51 - x equals and let's put dollar sign
104:57 - and let's type here
104:58 - [Music]
105:00 - X
105:01 - and to use the increment operator we
105:04 - type plus plus
105:06 - right and what this is gonna do is going
105:10 - to increment
105:11 - the value of our variable which now is 0
105:14 - by 1. and there is another way to
105:16 - increment the value for a variable by
105:18 - putting the increment upper operator or
105:21 - the plus plus operator in front of our
105:24 - variable not at the end of our variable
105:26 - so we can
105:28 - type again a println down here
105:33 - let's put the quotation marks and I'm
105:35 - going to put x equals and now I'm going
105:38 - to put dollar sign
105:42 - plus plus X but this now is not working
105:46 - because
105:47 - dollar sign only works if you refer a
105:50 - variable so to do solve that you're
105:52 - going to put this in a
105:54 - parenthesis
105:56 - actually in curly braces
106:00 - so let's put this in color braces and
106:01 - let's put the
106:03 - above one also in curly braces
106:10 - not here
106:13 - all right and uh both of both of these
106:16 - increment increment value of x by one
106:19 - they differ in
106:22 - what
106:23 - value they return
106:25 - so the first first Returns the value of
106:28 - x which is zero and then it increments
106:31 - and the next increment operator which is
106:35 - before the name of the before the
106:38 - variable it increments the variable and
106:42 - then returns its value so what you're
106:44 - gonna see if you output this code is
106:46 - going to be interesting so if what if
106:48 - you output this code
106:52 - let's bring it down you're gonna see
106:54 - Zero and two and maybe wondering how
106:55 - this makes any sense because you have
106:59 - incremented the value here and uh that's
107:02 - that does this happens because
107:06 - this first Returns the value of x so it
107:10 - returns varices and then it prints the
107:11 - value of 6 which is zero and then it
107:14 - increments so now the X has the value of
107:17 - 1. when the next printerland statement
107:20 - is executed now it with the variable x
107:24 - is incremented by one so it has a value
107:26 - of one and now it will be incremented
107:29 - again but it will also be returned not
107:33 - like in the previous uh increment
107:35 - operator which is the other end so now
107:37 - it will have the value of 2.
107:39 - okay
107:41 - and there is uh the same operator is
107:45 - available available for uh decrementing
107:48 - so if uh if you want to
107:52 - decrement
107:53 - a variable exactly by one I can put here
107:55 - x let's put equals let's put the curly
108:00 - braces actually the dollar sign
108:03 - curly braces and can put x minus minus
108:11 - and let's print
108:14 - just call the printerland function again
108:17 - I'm going to put x equals
108:20 - dollar sign again
108:23 - curly braces and let's put now
108:26 - the decrement operator which is the
108:29 - minus minus in front of our variable
108:32 - now you're going to see something
108:33 - similar but in the inverse way
108:40 - so now we have now we have two and zero
108:42 - and let's explain uh this also so again
108:48 - this printerland statements executed now
108:50 - the X has the value 2 and it returns to
108:54 - and then it decrements so it prints the
108:57 - value of 2 and then it decrements the
108:59 - value of our variable X by one so now we
109:02 - have one
109:04 - when the next printerland statement is
109:06 - executive or function is called
109:09 - now the value is 1 so and it first
109:12 - decrements the value and then it Returns
109:15 - the the the the value of the variable so
109:18 - now we have zero because it was
109:19 - decremented this is why you have uh 0
109:22 - and 2 and 2 and 0 here all right
109:25 - so you see above here that I declare the
109:29 - variable as a VAR so I can reassign this
109:32 - value down here to zero
109:35 - right this is our discussion about
109:37 - operators there are more operators but
109:39 - in order to talk about the next
109:41 - operators we need to first talk about an
109:44 - if statement
109:46 - so now it's time to look at comments and
109:48 - comments are nodes that you can add your
109:50 - code and they are ignored by the
109:52 - compiler and usually they are they are
109:54 - used when you want to add some
109:55 - description about the code so what you
109:58 - want to indicate what the code is doing
110:00 - because you may roll some code and you
110:03 - come to that code a few weeks later and
110:06 - forgot what it's doing and by putting
110:07 - comments you can you can see
110:10 - specifically what that code is doing and
110:12 - when in kotlin we have two types of
110:13 - comments the first is so-called
110:15 - end-of-line comment and to add an end
110:19 - offline comment we put two slices and
110:22 - here we put our comma let's say
110:24 - here we are
110:29 - doing
110:30 - ope
110:33 - operations
110:34 - so this is another End of Line comment
110:36 - and this is a text which you simply says
110:39 - here we are doing operations and this is
110:42 - uh as I said an end of flying comment
110:44 - the next comment that you can use is so
110:47 - called The Block comment and to use a
110:50 - block comment we put slash
110:53 - Aesthetics and now you can press enter
110:57 - or you can put Asterix and slash to add
111:01 - to to add the the next uh to close this
111:05 - comment and you press enter and as you
111:07 - can see it added automatically this
111:09 - Aesthetics and slash or you can type
111:12 - this yourself and here you can put some
111:14 - text which can be some it can be
111:19 - something which is going to say what the
111:20 - code is doing so so those are the two
111:23 - types of comments that you can use in
111:25 - kotlin
111:26 - The End of Line comment and the block
111:28 - the block comment and you can also use
111:31 - comments to disable some code so if I
111:33 - put two slices here
111:36 - now that line of code is going to be
111:37 - ignored by the compiler so this is our
111:40 - discussion about comments see you in the
111:42 - next video
111:43 - alright before we continue discussion
111:45 - about operators let's first introduce
111:47 - the if then else statement and uh
111:51 - let's first start talking about how
111:53 - usually our code is executed and usually
111:55 - our code is executed from top to bottom
111:57 - and that means that our code is executed
112:01 - line by line and that is the flow of the
112:05 - program but with an if then else
112:06 - statement you can break the flow of the
112:09 - program by imposing a condition and you
112:13 - can say to the computer to execute a
112:16 - particular section of quad only if a
112:19 - condition is true
112:20 - so let's see how we can do that so let's
112:23 - first create a variable I'm going to
112:24 - type Val this is going to be multiple
112:28 - I'm not going to reassign this value I'm
112:30 - going to call it it's
112:32 - active and I'm gonna put equals and I'm
112:35 - going to sign a value of Truth way so
112:37 - it's going to be of type Boolean on the
112:39 - next line I'm going to type the if
112:40 - keyword and now IntelliJ is giving us
112:43 - some hints here
112:44 - I'm going to press enter and inside the
112:47 - parenthesis we put our condition so here
112:50 - I'm going to type is active the variable
112:54 - and now I'm going to type equals equals
112:56 - notice that here now we have two equals
112:59 - and here we type true
113:01 - next
113:03 - we put a left curly brace and now we can
113:06 - add the right curly brace or you can
113:09 - press
113:11 - you can press enter and the right curly
113:13 - brace is going to be added automatically
113:15 - by IntelliJ for you so if I press enter
113:18 - now
113:19 - you can see that on the line 40 we the
113:23 - right calibrase was added automatically
113:25 - now
113:27 - let's type here a println statement so
113:30 - I'm going to type println
113:33 - press enter
113:35 - and quotation marks and here we're going
113:37 - to type the text the
113:39 - user is active right
113:43 - and uh
113:45 - if you run this code
113:46 - let's see what happens
113:52 - and we get the output the user is active
113:54 - which is the text that we typed here and
113:57 - let's first talk let's first talk about
114:00 - what we have here
114:01 - and uh
114:04 - the if statement
114:06 - checks to see as I said to see if this
114:09 - condition inside the parenthesis is true
114:12 - this if this expression returns true and
114:15 - it does that by checking to see if the
114:18 - operands are identical or if they are
114:21 - the same so it checks to see if the
114:24 - content of the variable it's acted which
114:26 - is uh true it's equal to true and that
114:30 - is that sounds convenient but it's true
114:32 - because
114:33 - uh our variable it's active has a value
114:36 - of true and here we're checking to see
114:38 - if our uh if those two are equal or if
114:42 - they are the same and that is true and
114:43 - this expression returns true and in
114:47 - effect
114:48 - the code inside the curly braces is
114:51 - executed but if I change this to false
114:56 - so if I change this value and if I run
114:59 - this code now
115:00 - this condition inside the parenthesis is
115:03 - going to be false and the code is not
115:05 - going to be executed so you can see now
115:08 - that you don't see any output because
115:10 - this condition is false and because the
115:14 - condition is false the code inside the
115:15 - curly braces is not going to be executed
115:18 - but uh if you want to cover the
115:22 - part where the condition is false so if
115:25 - you want to execute some code even
115:27 - though the condition is false you can
115:29 - type here else
115:31 - and here you also need to put the
115:33 - calibrases so I'm going to put the left
115:36 - curly brace I'm going to press enter and
115:38 - the right calibrate so that added
115:39 - automatically
115:41 - for me now I'm gonna type println
115:44 - and inside the parenthesis I'm going to
115:46 - put
115:48 - the user is not active so now what is
115:52 - going to happen is that this condition
115:53 - is going to fail it's gonna be false
115:55 - because the two operands are not equal
115:58 - respectively is active and true
116:01 - and is going to be executed the else
116:03 - part in this case it's going to be
116:05 - executed the code which is inside the
116:07 - curly braces of the else so if you run
116:09 - this code you're going to see the output
116:10 - the user is not active
116:16 - so as you can see now it says the user
116:19 - is not active because this condition is
116:21 - false this returns this Boolean
116:24 - expression return false and it jumps to
116:27 - the else part so this is how you can use
116:29 - the else part
116:31 - now what we can
116:34 - also do is to add another if statement
116:38 - below of our if statement to chain more
116:40 - if statements to check for more
116:42 - conditions but to do that we need to use
116:45 - another operator which is the called the
116:48 - greater than operator which is an
116:50 - operator which you may know from your
116:51 - math class
116:53 - and
116:55 - through that let's change for the
116:56 - variable so I'm going to type here a
116:58 - value of
116:59 - 100 to make it an integer and also I'm
117:03 - gonna change its name and to change the
117:05 - name of the variable go right click on
117:06 - the variable go to rename
117:11 - to refactor and go to rename
117:14 - and now if you change the name of the
117:16 - variable here is going to be change
117:18 - every where where the variable is called
117:21 - so if I look what happens if I delete
117:24 - the name here
117:26 - it's changed also on the line 38 we're
117:28 - referring the variable
117:30 - and now I'm going to call the variable
117:31 - my number and I'm going to press enter
117:35 - now the name of the variable it's
117:36 - updated
117:38 - and now this condition is not correct
117:40 - you don't need to put a greater than
117:43 - sign so I'm going to put the greater
117:45 - than sign and let's check for uh let's
117:48 - say if my number is greater than
117:51 - 150 and this is false now because my
117:55 - number has a value of 100 so this is
117:58 - going to evaluate to false this
117:59 - condition this expression
118:01 - now let's add here
118:04 - another if state if statement so we're
118:06 - going to put here else
118:08 - if
118:10 - and
118:11 - inside the bottom test you're going to
118:13 - put the condition and now I'm going to
118:15 - type
118:16 - again my number my variable
118:19 - or variable
118:21 - now you're going to put let's say
118:27 - or greater than 90.
118:31 - now this condition is true so
118:33 - let's add Also the curly braces because
118:35 - we need the
118:37 - we need the
118:39 - to put our code inside there
118:42 - let's put here
118:44 - open until then also
118:47 - let's type here
118:49 - greater
118:55 - than
118:57 - 90.
118:59 - and here let's also change the test to
119:05 - greater than 150
119:09 - and here you can put
119:14 - all the conditions
119:26 - here you can put all the condition
119:27 - failed because the else part is going to
119:29 - be executed only if all the condition
119:31 - that we have here which is uh for that
119:35 - my number is greater than 150 and this
119:38 - is false my number is has a value of 100
119:42 - and if our lcf condition also evaluates
119:46 - to False only then the else part is
119:49 - going to be executed so let's run our
119:51 - code to see what
119:53 - what if
119:56 - statement is going to be executed what
119:58 - part
119:59 - so you can see that we now get we get
120:01 - greater than 90 and that means that this
120:04 - condition is true because it's true that
120:06 - my number has a value of 100 and it
120:10 - checks to see if my number is greater
120:11 - than 90 which is true so it executes the
120:15 - code which is inside the else if part
120:18 - right
120:21 - now the next operator that you can use
120:25 - is greater
120:27 - than or equal to so you can put here
120:30 - greater than or equal
120:32 - now
120:33 - what is gonna check
120:36 - to see is to
120:39 - is that what is going to check is to see
120:42 - if the number that we're comparing to
120:45 - respectively my number
120:47 - is greater than 100 or equal to greater
120:53 - than 150 or equal to 150 so let's change
120:57 - this to let's say um
121:00 - um
121:03 - 100 and uh
121:07 - 49 so look what happens now
121:18 - so now it's executed the this part the
121:21 - lc4 because this is greater the number
121:23 - greater than 90. but if I put here
121:27 - greater
121:29 - let's change the value of my number to
121:33 - um 150 to see what happens
121:43 - and now we get the output greater than
121:45 - 150 and this is correct because now this
121:49 - condition is true my number is greater
121:50 - than equals to 150 and uh
121:55 - my number has the value of 150 it's not
121:59 - greater than 150 but it's greater than
122:02 - or equal to so it's equal to 100 150 so
122:07 - now this condition is uh satisfied and
122:10 - the code inside this curly braces is
122:12 - executed which is greater than 150. all
122:15 - right now I'm gonna end this video and
122:18 - in the next video video we're going to
122:20 - continue our discussion about
122:22 - um those operators
122:25 - right so now let's continue our
122:27 - discussion about the next operators that
122:28 - you can use in kotlin and let's start
122:31 - with the less than operator and to do
122:34 - that let's first change the value of the
122:36 - variable my number to 100.
122:38 - and to use the less than operator you we
122:41 - put here a less than sign which you
122:43 - probably know from your math class
122:45 - now if you run this code
122:54 - I should change here the text to make it
122:58 - consistent let's type here
123:07 - so now if you run this
123:13 - now get the output less than 150 and
123:16 - this is true because the value of the
123:18 - variable my number is less than 150 so
123:20 - this condition now evaluates to true
123:22 - the next operator that you can use is
123:25 - less than or equal to similar to greater
123:28 - than or equal to operator and to use the
123:30 - less than or
123:31 - equal to operator we put here a less
123:33 - sign and the equal sign
123:35 - right and let's change the value here to
123:38 - 150 to make it clear
123:41 - now let's change also the value of the
123:45 - variable to 150
123:47 - and let's also change the text here
124:00 - now if you run this code you're going to
124:02 - see the output less than or equal to 150
124:04 - because
124:05 - now the else if part
124:08 - and the condition of the else if
124:11 - statement evalues to true
124:13 - because
124:14 - now the the value of my number it's not
124:17 - the it's not less than 150 because it's
124:20 - 150 but it's less than or equal to 150
124:23 - so this condition evolves to true
124:26 - right
124:28 - the next operator that you can use is
124:31 - called The Logical
124:34 - not equal operator and that operator is
124:37 - used to check if two operands
124:40 - respectively to if my number let's say
124:43 - or and 150 are not the same let's see
124:47 - how we can do that and to do that to
124:48 - type here
124:50 - an exclamation mark and an equal sign
124:53 - and this operator here which is going to
124:56 - make a mark is gonna check to see if
124:59 - those two operands respectively my
125:02 - number and 150 are not the same
125:05 - and only then the condition is going to
125:08 - evaluate true
125:09 - so let's run this code to see what
125:11 - happens
125:23 - so now we get the output less than or
125:25 - equal to 150 because we still have the
125:27 - volume 150 so it jumps to the lcf part
125:30 - but if I change this to
125:33 - let's say
125:35 - 100 now look what happens
125:43 - now it execute the if
125:46 - now this condition evolves to true
125:48 - because now this operator is checking to
125:51 - see if the two operands if the value of
125:55 - my number the value of my number is not
125:57 - equal to
125:58 - 150 and that is true they are not equal
126:01 - and this is why you get here the output
126:03 - but let's change the output to make it
126:05 - clear let's type here
126:08 - they are not
126:11 - tickle
126:13 - so if you run this code you're going to
126:15 - see the output I are not equal because
126:17 - that condition now Evolution so this is
126:19 - how you can use the
126:21 - logical not equal operator
126:24 - also with the logical not operator we
126:27 - can change the value for Boolean
126:29 - expression from True to false and from a
126:32 - false to true in other words you can
126:34 - negate its value and to do that let's
126:37 - first declare the code that we had
126:39 - previously so I'm going to cut again the
126:41 - Val variable
126:44 - it's active
126:47 - I'm going to assign a value of true
126:53 - I'm going to type the if statement again
126:55 - I'm going to put
126:57 - the same condition
126:58 - equals equals true
127:05 - here you can put the left curly brace
127:07 - and press enter we can add the right
127:09 - color base if you want but it will be
127:11 - added automatically for you
127:12 - I'm going to type else also the left
127:15 - curl base press enter I'm going to put
127:18 - the text that you had previously
127:23 - all right now if you run this code
127:24 - you're going to see the output the user
127:26 - is active because this is going to
127:27 - evaluate to show their
127:30 - are equal they're the same
127:33 - let's expand this
127:38 - so you see the output user is active
127:40 - because this condition average to show
127:42 - and before you look at The Logical not
127:44 - operator how we can get the value let's
127:46 - first see how we can write the same
127:49 - expression that we have here
127:51 - in a shorter way by abbreviating so
127:54 - because you have noticed probably
127:57 - that we have another underline here and
127:59 - if you hover over here
128:02 - it says that the Boolean expression can
128:03 - be simplified so let's click here
128:06 - simplify Boolean expression to see what
128:07 - happens
128:08 - so now we get if it's active and then
128:12 - print then execute the code inside the
128:15 - curly braces so this thing now does the
128:19 - exact same thing that we did previously
128:21 - it's so it checks to see if the value of
128:24 - its active is equal to true so it's a
128:27 - short way of writing the same thing
128:29 - and uh now get the output the user
128:33 - exactly but with the equal not operator
128:35 - you can put
128:36 - the exclamation mark
128:41 - in front of our its active exp
128:45 - expression and it's now now it's going
128:48 - to negate this value now it's going to
128:49 - change its value from True to false so
128:52 - now if you run this code
128:57 - not going to see the output the user is
129:00 - not active because now this logical not
129:03 - operator
129:04 - switch is switching its value to false
129:07 - so now this is going to be this will
129:09 - evaluate to false it and it's going to
129:11 - execute the else part that we have with
129:12 - the user is not active and you can do
129:14 - the same for a
129:16 - false so if you put here false
129:20 - now
129:23 - let's actually
129:24 - execute this without the logical not
129:26 - operator to see what happens now this
129:28 - will not execute so it will execute the
129:30 - else part
129:33 - so you see the user is not active but if
129:35 - I put the logical not operator in front
129:37 - of its active now it's going to change
129:39 - its value from false to true and now
129:42 - this will evaluate to true and it will
129:44 - execute the
129:46 - oh
129:47 - code inside the calibration of the if so
129:49 - now you see that it says the user is
129:51 - active
129:52 - so this is how you can use the logical
129:54 - not operator to flip a value from false
129:57 - to true or from True to false and you
129:59 - can do this for for every Boolean
130:01 - expression
130:02 - that you use so you can put the logical
130:05 - note operator in front of this
130:07 - actually not in front of this
130:09 - um you can put the logical not operator
130:11 - generally speaking in front of any
130:13 - Boolean expression right
130:16 - so this is our discussion about
130:21 - operators so in the next video we're
130:22 - going to look how we can combine
130:24 - multiple Expressions to create a bigger
130:26 - expression which you sell for returns uh
130:28 - true or false
130:30 - value
130:31 - see you in the next
130:33 - alright so I deleted the code that we
130:35 - had previously you can keep the code
130:37 - that you have to use if you want but I
130:39 - deleted to make things more clear
130:41 - and in this video we're going to look at
130:42 - how we can combine multiple Expressions
130:45 - which in essence can return a Boolean
130:48 - value which can be either true or false
130:51 - and uh
130:54 - let's start with the first
130:56 - operator which is called The Logical end
130:59 - operator but less vertical two variables
131:01 - I'm going to declare a Val variable I'm
131:03 - going to call it
131:04 - it's playing
131:07 - I'm going to sign a value of true sweet
131:09 - so it's going to be of type Boolean
131:12 - and on the next line I'm gonna declare
131:14 - another variable also of all and it's
131:17 - going to be called score
131:19 - and it's going to have a value of 80.
131:22 - now down here we'll type if
131:25 - and inside the parenthesis to type is
131:28 - playing
131:30 - equals equals true so this is the equals
131:33 - to operator I didn't then talk really a
131:37 - lot about the equals operator but equals
131:39 - to operator
131:40 - checks to see if the two operands are
131:43 - the same so it in contrast to the one
131:45 - equal operator the one equal operator
131:48 - assigns what's on the right to do our
131:50 - variable which is on the left so in this
131:53 - case assign truth or variable is playing
131:55 - so or it's a sign 80 to a variable score
131:59 - the equals the two equals or the request
132:02 - operator is different because it checks
132:03 - to see if uh what we have on the left or
132:06 - what have on the left in and on the
132:09 - right are the same or are identical next
132:12 - and we know from the previous video that
132:14 - you can abbreviate this you can write
132:16 - this in a shorter way by putting just is
132:18 - playing this will be this is going to be
132:21 - equivalent to what you had producer
132:23 - because as you can see it says that you
132:25 - can simplify the Boon expression
132:27 - and now
132:29 - gonna you use the logical end operator
132:32 - and use the logic logical end operator
132:34 - with type 2 Ampersand science
132:37 - and here we type score now I'm going to
132:39 - use again the equals equals operator
132:42 - this time we need to use it there is not
132:44 - a shorter way to check for a
132:48 - new type if score equals to 100.
132:52 - all right
132:53 - so this expression inside the pattern
132:55 - this is going to evaluate to True only
132:57 - if both
132:59 - Expressions respective is playing and
133:02 - score equals equals to 100 evaluates to
133:05 - true so only if those two conditions
133:09 - are true only then the code inside the
133:12 - parenthesis inside the curly braces
133:14 - actually is going to be executed so
133:16 - let's say that in a real app here you
133:18 - can add the logic to open the next level
133:20 - but here we go just gonna output some
133:23 - text so I'm going to type here
133:26 - next level
133:29 - opened right
133:30 - and also I'm gonna add the else part
133:32 - here
133:36 - and we're gonna put
133:39 - also printerland statement
133:42 - and inside the part of this is going to
133:43 - type
133:45 - steel art
133:47 - the same
133:48 - level now if you run this code
133:52 - you're going to see the output still at
133:54 - the same level because
133:56 - not those conditions are not both true
134:00 - is playing is true but it's playing is
134:04 - equal to true but our score is not equal
134:07 - to 100 so this is going to evaluate to
134:09 - false and the entire expression inside
134:11 - the pattern is going to turn false so
134:12 - it's going to execute Tails part
134:15 - now if we change the order the value of
134:19 - our variable score to 100 now both
134:22 - expressions are true is playing equal to
134:25 - true and score
134:27 - and the score is equal to 100.
134:30 - so now both of our expression are true
134:32 - and gonna see the text Next Level opened
134:38 - and I will see that it output the next
134:40 - level opened
134:42 - so this is The Logical end operator and
134:45 - you're going to be using uh The Logical
134:48 - and operator a lot in your
134:50 - code
134:52 - all right so now it's time to continue
134:54 - our discussion about operators and going
134:57 - to look at the next operator which can
134:59 - be used to combine multiple expression
135:02 - and that is the logical or operator and
135:05 - the logological or operator evaluates an
135:08 - expression or multiple expression in
135:10 - this case to true if one of the
135:13 - condition is true or if both conditions
135:15 - are true so let's see an example of this
135:17 - but first let's comment the code that we
135:19 - have here because to make things
135:22 - confusing
135:23 - so go to code and select comment.light
135:26 - command with line comment or you can
135:29 - press the shortcut Ctrl slash
135:34 - now let's equal to variables down here
135:37 - the first the first is going to be a Val
135:39 - I'm going to call it num1
135:42 - I'm going to sign a value of 5 to it
135:46 - second is going to be also Val it's
135:48 - going to be called num2 and I'm going to
135:49 - send a value of 3 to it or four
135:53 - now I'm going to type the if Dental
135:55 - statement I'm going to type the if
135:57 - keyword inside the parenthesis I'm going
135:59 - to put the condition first is if num1 is
136:02 - greater than zero and now to use the
136:04 - logical or operator we type two vertical
136:07 - bars here
136:09 - now we put our next condition or our
136:11 - next expression and that is num2
136:15 - is also greater than zero and we put a
136:17 - curly brace press enter two
136:20 - to add the right color base
136:22 - and put also the else part
136:26 - and inside the
136:27 - calibrases of the if let's print some
136:30 - text
136:33 - let's say
136:35 - the condition is true
136:43 - all right now if you run this code
136:54 - you're going to see the output the
136:55 - condition is true because now both
136:57 - conditions are true and The Logical
136:59 - operator returns true if both conditions
137:03 - are true or if one of the condition is
137:05 - true so let's see if we change this to
137:08 - -3
137:10 - and now our second condition num2
137:12 - greater than zero is false so now this
137:15 - is also going to evaluate to true
137:17 - because
137:18 - The Logical operator returns through if
137:21 - one actually with one of the
137:23 - conditioners or if both Constructor so
137:26 - now get conditional show but if you
137:28 - change this to
137:29 - also to -5 now our both both conditions
137:33 - are false
137:34 - now you're gonna see that it's gonna be
137:36 - executed the daily spot because this
137:38 - condition is going to be false because
137:39 - both conditions both Expressions num one
137:43 - greater than zero and num two greater
137:44 - than zero are false all right so let's
137:46 - change it back to five
137:50 - now if you're on this code you're gonna
137:51 - see
137:52 - the condition is true because at least
137:54 - one of the condition is true which is
137:56 - this one normal and greater than zero
137:58 - even though the number two condition is
138:00 - false
138:01 - all right and this is how you can use
138:04 - the logical or operator
138:06 - all right now it's time to see how we
138:08 - can use the if Daniel statement as an
138:10 - expression and that means that the if
138:14 - Daniel statement can return a value
138:16 - which can be stored in a variable so
138:18 - let's see how you can do that
138:20 - but first
138:23 - actually skip this code that we have
138:25 - here
138:26 - and uh
138:27 - to use the if Daniel statement as an
138:29 - expression
138:30 - we declare of
138:32 - um
138:33 - a variable first so I'm going to create
138:35 - a Val
138:37 - and let's give it a name I'm going to
138:38 - call it let's say text
138:41 - and to use the if then else statement as
138:44 - an expression we put equals and after
138:47 - the equals we put our if then else
138:50 - statement
138:51 - now
138:52 - we need to assign a value to our
138:55 - variable text to use it as an expression
138:58 - and the value is going to be the last
139:00 - expression in the in the curly braces so
139:05 - here if I type the text let's say uh
139:09 - this
139:11 - is text
139:13 - one
139:15 - and
139:16 - down here if I type
139:18 - quotation marks this is text tool
139:23 - now if I add a print Ln here at the end
139:30 - and if I print the value of the variable
139:31 - text that we declare above
139:34 - let's put a dollar sign and if I type
139:36 - text here
139:38 - now you can see our variable it says
139:40 - it's of type string
139:43 - so if I run this code now
139:47 - you're gonna see first this println
139:50 - inside the curly braces which says the
139:51 - condition is true
139:53 - and
139:54 - after that you're gonna see this text
139:56 - being assigned to our variable text and
139:59 - it will be output out output it down
140:01 - here
140:02 - by the printerline statement so you see
140:04 - this is text
140:06 - two actually I was wrong that condition
140:08 - is false because it will have minus five
140:10 - and minus three and this condition but
140:11 - it's the false and the last the last
140:15 - expression in the
140:17 - in the curly braces is assigned as a
140:20 - value to our variable now
140:23 - uh
140:25 - what you can also do is to remove the
140:27 - curly braces but it's recommended to use
140:30 - to not use the curly braces if you have
140:33 - one only one statement uh
140:37 - in your if Dental statement so let's
140:40 - delete the printerland here let's delete
140:42 - the curly brace here
140:44 - let's also delete the calibrase here
140:46 - let's delete the printerland statement
140:48 - here and let's also delete the curly
140:50 - berries here
140:51 - so now this will work the same to work
140:55 - like previously but uh
140:59 - so now you'll see the same output
141:01 - without the condition without this take
141:02 - the control result because now we don't
141:03 - have the printerline statement so now
141:06 - get this text too because this condition
141:07 - evaluates to false and it assigns this
141:10 - value to our variable text then down
141:12 - here it prints so
141:14 - also you see that this uh they are not
141:17 - aligned here this our variable and two
141:19 - format your code you just go to code
141:22 - and click reform reformat code or place
141:25 - Ctrl alt L on Windows or you can um
141:29 - use another shot you can use the
141:31 - corresponding shortcut on Linux or Mac
141:33 - so click on code
141:36 - and now we're gonna see that our code is
141:38 - formatted if you run this
141:46 - now see this is text too but let's
141:48 - change this to five
141:51 - now this conditional overlay to true and
141:54 - this expression is going to be is going
141:56 - to be assigned or variable text so if we
141:59 - run this
142:00 - hmm
142:05 - you're gonna see this now our variable
142:08 - text is assigned the value of this is
142:10 - text one because this condition is true
142:12 - and inside this value to make things
142:14 - more clear clear you can
142:16 - use a
142:17 - you can you can type your code something
142:20 - like this
142:23 - now this does there's everything is the
142:25 - exact same thing as previously so if you
142:27 - run this code now
142:33 - you're gonna see that now this it says
142:34 - the same thing this is text one
142:37 - now you may be wondering what type this
142:39 - variable is so if you hover over it this
142:42 - is the it is of type string but look
142:46 - what can I do I can put here a number
142:49 - so if this condition evaluates to false
142:51 - this is going to be assigned or variable
142:54 - test so if I run this now
143:02 - now get this text one and let's uh put
143:06 - here -5 for the condition to be false
143:09 - and if you run this code now
143:15 - now I'm going to see five and you may be
143:17 - wondering how this makes any sense
143:20 - because
143:22 - previously our variable was of type
143:24 - string but if you have hover over here
143:27 - now it says Vault text and the type is
143:29 - this thing comparable anyway but what is
143:33 - uh simply doing here is looking at the
143:36 - condition it's looking first at the if
143:38 - statement
143:39 - and if this condition is true then it
143:42 - assigns our text or variable and then it
143:45 - infers the type to be a string right
143:49 - if this condition is false then this
143:52 - part is skipped and then it assigns this
143:54 - value of 5 to our variable text and not
143:57 - and then our variable is going to be of
144:00 - type int so there is no case in which
144:03 - both
144:06 - value is going to be assigned to our
144:08 - variable so this is why you can use here
144:10 - text and here
144:12 - an integer even though but if you
144:14 - declare explicit here that this variable
144:17 - is going to store only strings only
144:19 - sequence of characters or text now he'll
144:22 - get an earning because it says the
144:24 - integral transforms the expected stream
144:26 - so in other words we cannot put here
144:29 - but a number because we said that
144:32 - explains here that is going to store
144:33 - only strings but if you omit the
144:36 - type
144:38 - that is gonna work
144:39 - so you can decide not to
144:42 - depending on the context what to choose
144:45 - so this way of writing the internal
144:48 - statement in one single line like we
144:50 - have here it's okay as long as we use
144:53 - the if the general statement as an
144:55 - expression or in other words if you're
144:56 - assigning a value to a variable like in
145:00 - our case
145:01 - but if you have multiple instruction you
145:04 - know
145:05 - also if you have a single single
145:07 - instruction you can also omit the curly
145:10 - braces but most of the time it's
145:13 - recommended to use the curly braces
145:15 - because that allows the those allows us
145:18 - to execute more than on uh instruction
145:21 - on the statement in your code and it
145:24 - also makes the code more clear so let's
145:27 - change this code
145:29 - from an expression to just a new general
145:31 - statement to
145:33 - see why
145:35 - so I'm going to change this
145:38 - I'm going to add the curly braces
145:45 - from other code press Ctrl
145:49 - alt l
145:52 - all right and low solution it is
145:56 - let's delete this
145:59 - text let's add to print Elena
146:04 - statements here
146:09 - foreign
146:12 - now if you run this code
146:15 - you're gonna see this part executed else
146:17 - part because this condition is false
146:19 - fault of our condition respectively num1
146:22 - great is not greater than zero and
146:25 - also num2 is also not greater than zero
146:27 - so this is going to return false
146:30 - and it's going to execute the else part
146:39 - all right but now if you change this to
146:41 - five and now one of the conditions is
146:43 - going to be true and as you know this
146:46 - entire expression is going to wait is
146:47 - going to evaluate to true now because at
146:50 - least one of the the expression is true
146:52 - so if you run this code
147:00 - now I see this condition is true and
147:02 - also we see all our second printerland
147:05 - statement this condition is running some
147:06 - text
147:07 - but look what happens uh
147:12 - if I uh
147:14 - let's say if I
147:17 - delete the else part
147:22 - right and if I delete the curly braces
147:24 - here
147:26 - all right
147:28 - and now if I run this code
147:34 - you see the now both statements are
147:36 - executed but as I said if you don't use
147:38 - curly braces you want just only one of
147:40 - the
147:41 - uh
147:43 - statements in is going to be executive
147:45 - so why you have both of these because
147:47 - the first is if you executed as part of
147:50 - the if statement because this one is
147:53 - true and the next one is executed
147:55 - because it's part of the code because
147:57 - it's red from top to bottom but if
148:00 - I change this to false and now I want
148:04 - both condition both statements
148:07 - respectively with this one and this one
148:10 - to not be executed look what happens
148:14 - now get this condition experience on
148:16 - text so the first
148:19 - instruction in our if the next element
148:22 - is omitted because it's part of the if
148:24 - the statement but the second one it's
148:27 - executed because it's part of the code
148:30 - so it's going to be red anyway so this
148:34 - is why you need to always use curly
148:35 - braces in this way
148:38 - the entire code is also is gonna be
148:40 - either executed or omitted so this is
148:43 - our discussion about the external
148:44 - statement and you should always use the
148:47 - curly braces and for this part you also
148:51 - you should use the curly braces
148:53 - and um
148:56 - only omit the calibrations if you have
148:59 - only single one single statement or one
149:03 - single expression if you want to use uh
149:05 - leave the statement as an exception to
149:08 - assign a value to a variable but if you
149:10 - have just one single statement let's say
149:13 - you have something like this
149:15 - economy the curly braces like this
149:24 - so now you can see that everything works
149:27 - fine
149:30 - so you can use it like this if you have
149:32 - one single statement like we have here
149:34 - you just print some text to our console
149:36 - or if you use it as an expression so if
149:40 - you
149:41 - sort of value in a variable
149:45 - so see you in the next video
149:48 - all right now it's time to look at the
149:50 - next control flow statement that you can
149:52 - use in kotlin besides the the if Daniel
149:55 - statement and that is the when statement
149:57 - or the one expression but first let's
149:59 - create a new project
150:02 - I'm going to call it Ctrl flow
150:04 - it should be in Pascal case
150:07 - select IntelliJ click on next and finish
150:14 - right now let's delete the code inside
150:15 - the curly braces
150:19 - let's hide the project Pane and let's
150:21 - first declare a variable it's going to
150:24 - be a Val
150:26 - it's going to be called
150:27 - alarm and I'm gonna assign a value of 12
150:32 - to it
150:33 - now to to declare when statement we type
150:36 - here when
150:40 - we put parenthesis and inside the
150:42 - parentheses we put
150:44 - our argument in this case is our
150:47 - variable alarm
150:49 - next
150:51 - put space and we put the curly braces
150:54 - press enter and now we put the
150:58 - expression here so here I'm going to put
151:00 - the value let's say 12.
151:03 - now I'm going to put a minus sign and a
151:06 - greater than sign so I have this Arrow
151:09 - and here I'm gonna type print Ln this is
151:13 - the code that is going to be executed
151:17 - so and I'm gonna type the time is
151:20 - dollar sign
151:23 - alarm
151:25 - let's press Ctrl D to duplicate this
151:30 - two times
151:33 - or three times
151:36 - and let's change the last one to one
151:39 - else
151:48 - all right
151:49 - let's change those values here to
151:53 - 7
151:58 - and 14.
152:01 - now let's run this code to see what to
152:03 - get in the output and after that we're
152:04 - going to discuss our code
152:09 - so getting the output the time is 12 and
152:12 - we get that because what is what the
152:15 - when statement is doing
152:17 - it's using this argument that we passed
152:19 - here in this case it's our variable
152:21 - called alarm
152:23 - and it's comparing this uh the value of
152:26 - this argument with all the branches that
152:29 - we have here respectively it's going to
152:30 - compare it with the expression that we
152:32 - have on the left because on the left we
152:35 - have the expression
152:36 - the this Arrow sign is gonna is is uh
152:41 - saying execute execute this code on the
152:45 - right
152:46 - if this expression on the left is true
152:49 - in this case if our Allah alarm equals
152:53 - equals 12 and it's true we have a value
152:58 - of 12 so this branch is executed and it
153:00 - executes the code on the right which is
153:03 - this this the alarm is 12 but if I
153:07 - change this to 7 now
153:12 - and if I run this code
153:17 - I'm going to see the time is seven and
153:19 - if I change this to
153:21 - let's say
153:25 - 13.
153:27 - and here we have no 13 Dallas part is
153:30 - going to be executed similar to our if
153:32 - Daniel statement
153:37 - you know get the time is 13. so it was
153:40 - it was executed the else part now now
153:43 - and we can combine those uh Expressions
153:47 - by putting a colon and and we can
153:50 - combine them and putting them on on one
153:52 - single line so I can put here colon
153:56 - I can type here
154:00 - seven
154:03 - and fourteen now
154:05 - I'm gonna delete those two
154:09 - now it will check to see if our alarm
154:12 - argument has the value either 12
154:15 - or 7 or 14. so
154:19 - um let's change it to 14 to see
154:22 - so now if you run this code you're gonna
154:24 - see that
154:26 - this will evaluate to true and this code
154:29 - on the right is going to be executed so
154:30 - again the time is 14. and if I change
154:33 - this to 7
154:37 - again this level is true because one of
154:39 - those expressions show so yeah the time
154:42 - is seven
154:43 - all right
154:45 - what you can do next is we can check to
154:48 - see if a number is in a certain range so
154:51 - we can put another
154:54 - another expression here and and here I
154:56 - can type
154:58 - in
155:00 - the in keyword is used to check to see
155:03 - if numbers is to see if a number is in a
155:05 - certain range and to declare a range we
155:09 - type
155:10 - the range let's say that I want to check
155:12 - from
155:14 - let's say uh
155:16 - one
155:18 - from one to ten we put two dots dot dot
155:22 - 10. now what this is gonna do is gonna
155:26 - check to see if our alarm argument in
155:30 - the in this in this case our alarm
155:31 - variable is in the range from 1 to 10.
155:35 - now I'm gonna put a minus sign and a
155:38 - gray and a greater than sign to have the
155:41 - arrow and here I'm going to type the
155:43 - code that I want to be executing in this
155:44 - case it's just a printerland statement
155:46 - and I'm gonna type
155:49 - the number
155:51 - is in
155:55 - the range
155:57 - 1.7
156:00 - now if you run this is only from here
156:08 - we get the time is seven because uh
156:12 - the first branch is checked and this
156:15 - branch is true and uh in effect it
156:17 - executes the code on the right and the
156:20 - next branches are left offs are not
156:22 - executed to and to change that let's put
156:24 - this first so let's copy this
156:32 - now if you run this code
156:36 - now get the number is in range one two
156:38 - ten and it's true our seven is in the
156:41 - range from 1 to 10. what you can do is
156:43 - also you can use the logical not
156:45 - operator so I can put here
156:48 - The Logical not operator which is an uh
156:50 - exclamation mark
156:52 - and this now will negate this value so
156:55 - if you run this code now you'll get the
156:56 - output 7. the time is seven so now we
156:59 - get the output
157:00 - the time is seven because this this
157:03 - switch is this value from True to false
157:06 - and execute this uh part
157:09 - now
157:12 - let's delete this
157:14 - what I can also do is that we can put
157:16 - curly braces so I can put curly braces
157:21 - press enter
157:27 - the same here
157:33 - and
157:35 - here
157:36 - also
157:38 - and it's recommended to use the
157:40 - calibrases only if you have multiple
157:43 - statements in your code in our case we
157:44 - have one one single statement which is
157:46 - this printerland which outputs some text
157:48 - to the console and the the when
157:51 - statement as I said can be used as an
157:53 - expression so I can type here a Val
157:56 - let's say your text and I can assign the
158:01 - when expression to our text variable now
158:05 - we need to give back a value to our text
158:08 - so instead of printing this text I can
158:11 - delete this
158:17 - let's put it like this
158:23 - now the last expression in our block of
158:27 - code which is now we have a single
158:29 - expression but you have multiple
158:31 - Expressions say that we have here
158:32 - another print Ln
158:37 - let's say some text
158:42 - so similar to our if then else
158:43 - expression the last line of code the
158:47 - last expression is going to be assigned
158:49 - to our variable text now let's print
158:51 - this down here
158:53 - torque console so let's type println
159:01 - and let's put director here text
159:05 - now if you run this code
159:12 - now I'm gonna see the text the number is
159:14 - in the range you want to
159:15 - 10 because it checks to see if this
159:19 - expression on the left is true then it
159:23 - executes the car the code inside the
159:25 - curly braces which is this expression
159:27 - and because now we're using the one as
159:30 - an expression it assigns this expression
159:33 - this text or variable text then it
159:37 - outputs that value with the print line
159:39 - down here in our console so you get the
159:42 - number is in the range one two
159:45 - 10. all right now but what if I want to
159:50 - put here a less than sign so you what if
159:53 - I want to put here if
159:58 - is less than seven our alarm argument I
160:02 - can do that the only way to do that is
160:04 - by uh let's delete this now let's put
160:07 - seven
160:09 - not here
160:14 - let's press Ctrl alt L to format the
160:17 - code all right
160:19 - now the only way to put a greater than
160:21 - sign or less than sine or greater than
160:24 - equal or greater or less than equal sign
160:26 - is to delete the argument here but let's
160:29 - first delete the curly braces to make
160:32 - things more clear
160:34 - so let's delete the curly braces
160:37 - let's delete this now because here we
160:39 - have two lines of course so we need to
160:42 - use curly braces this is why I deleted
160:43 - the penalion there and again you should
160:45 - always use curly braces if you have
160:47 - multiple lines of code but in our case
160:49 - we have a simple line of code which is
160:51 - the text on the right which is going to
160:54 - be assigned to our variable text and
160:57 - it's going to be output in the console
160:58 - so always use highly braces if you have
161:00 - multiple lines of code all right all
161:02 - right now this is more concise and more
161:04 - clear and let's say that I want to check
161:06 - to see if our alarm is less than say 10.
161:12 - um to do that we need to delete the
161:14 - argument here
161:18 - all right and now what can I do is I can
161:21 - put here
161:23 - our
161:25 - alarm variable and here I can put less
161:28 - than
161:29 - or equal to 10. so now here we have a
161:33 - Boolean expression on the left
161:36 - sorry
161:40 - so now we have a Boolean expression here
161:43 - on the left
161:44 - and this will check to see if our alarm
161:48 - or variable alarm alarm has a value
161:50 - Which is less than or equal to 10 which
161:53 - is true we have a 7 here so now if you
161:55 - run this call
161:56 - but let's delete this because we need to
161:59 - have now Boolean expression here because
162:01 - here we cannot uh here we have just
162:04 - literal types so here I need to put
162:07 - let's say if let's type alarm
162:12 - equals equals
162:15 - 8
162:18 - or two vertical bars
162:20 - alarm
162:22 - equals equals
162:27 - seven
162:28 - so now if you run this code
162:32 - now you get the output the numbers in
162:33 - the range 1 to 10. because now this on
162:36 - the this expression on the left is true
162:39 - and it executes this text uh
162:42 - it assigns this expression to our
162:45 - variable text and it prints down here
162:48 - the that value so you get here the
162:50 - number is already one to ten
162:52 - but uh
162:55 - this condition is also true so if I swap
163:00 - those two so if I put this one below
163:01 - because as I said if one uh one of the
163:05 - expression evolution true the next ones
163:08 - the the one which are below so this in
163:11 - this case this one is true or not be are
163:14 - not going to be executed are skipped it
163:17 - only executes this code and the
163:20 - subsequent ones are omitted so let's put
163:23 - this
163:25 - below
163:26 - it's good to remember this
163:29 - so now if you run this code
163:39 - now get the time is seven because now
163:42 - this level is true even though this
163:44 - below is also true because our alarm is
163:47 - less than seven because this available
163:50 - is too true it executes the code which
163:52 - is on the right which is assigning this
163:55 - expression to our text and then it
163:57 - leaves the one expression it's not going
163:58 - uh down to execute the next one so it
164:02 - breaks uh like there and it stops it
164:04 - actually stops right there and it's not
164:06 - executing the next branch
164:09 - so this is our discussion about the when
164:12 - statement statement and the one
164:14 - expression see you in the next video
164:16 - now it's time to start a discussion
164:18 - about null ability in kotlin but first
164:20 - i'm going to create a new project I'm
164:22 - going to call it null
164:25 - make sure to have the language
164:27 - culturally select it and for the build
164:30 - system IntelliJ also make sure to have
164:33 - the jdk selected here and I'm gonna
164:34 - check this little box to generate the
164:37 - main function for us and that code that
164:39 - comes with the main function so I'm
164:41 - going to click on create to create a new
164:43 - project
164:44 - now our project is going to be great in
164:46 - a short moment
164:49 - so we got our project created and we get
164:52 - a log you get our main function Auto
164:55 - generated here for us because we check
164:56 - that box so I'm gonna delete this
164:59 - because I don't need this code
165:03 - and I'm going to hide the project pane
165:05 - so what is a null value a null value is
165:07 - basically when you assign to a variable
165:09 - nothing synthetically speaking you
165:11 - assign null to it but what that means is
165:13 - that you have a variable which has no
165:15 - value which has no memory reference and
165:18 - if you try to do some other arithmetic
165:20 - operation with that variable you're
165:21 - getting an impossible scenario where you
165:24 - have nothing try to do some work and
165:26 - that will throw a null pointer exception
165:30 - and this is particularly bad because the
165:33 - null pointer exceptions are only thrown
165:37 - at runtime and not at compile time so
165:39 - you could have your program working well
165:43 - and having no problems and at some point
165:46 - you try to I don't know press a button
165:49 - and somehow somehow that
165:51 - pressing of the button is using that
165:55 - variable which has another value and
165:57 - then it's going to throw an old normal
165:59 - pointer exception and your app will
166:02 - crash
166:03 - and kotlin aims to avoid the and to
166:07 - eliminate the null pointer exceptions
166:09 - and null values that is not to say that
166:11 - we can't have a null value in a kotlin
166:14 - but is very hard to have one so let's
166:17 - see why so what cotton has done to make
166:20 - null values and implicitlyn all
166:23 - pointerizations very hard to get
166:25 - it first made all its styles by default
166:28 - non-nullable and that means that you
166:29 - cannot assign null to it so if I declare
166:32 - here a variable called text I'm going to
166:34 - declare the type explicitly so it's
166:36 - going to be a string
166:37 - and if I assign null so to assign Alto
166:40 - where we'll just type the null and we
166:42 - have the null cured
166:44 - we can't because this variable by
166:46 - default and all the variables by default
166:48 - are non-nullable and that means that you
166:50 - cannot assign a value so if you hover
166:52 - over this underline it says null cannot
166:55 - be a value of a non null type string but
166:58 - what if I want to assign null to it what
167:01 - you if I want to have null for some
167:03 - reason
167:04 - in that case you go at the end of the
167:07 - type and you put question mark and that
167:10 - means that now you have a nullable type
167:12 - that means that you can assign null to
167:14 - this variable so if I put question mark
167:17 - here
167:18 - now I can assign null to this variable
167:21 - so this is
167:23 - how we can assign an altar variable by
167:25 - putting the question mark at the end of
167:27 - the type because that is saying to the
167:29 - compiler hey I'm gonna let I'm gonna let
167:32 - me to assign now to this variable so
167:34 - to avoid that underwriting red now if I
167:39 - try to print this so if I put here print
167:41 - line
167:42 - and I put here text
167:44 - what do you think we're getting the
167:46 - output
167:48 - and output to get null you know you
167:50 - don't get null pointer exception so now
167:53 - if I hide this and let's say that I want
167:56 - to get the length of let's say of the
167:59 - text so let's say that I assign here
168:04 - some text
168:12 - well actually let's put the name here
168:14 - name
168:16 - unless and if I try to get the length
168:19 - here so if I put here
168:23 - dot length
168:26 - I have an underline
168:28 - which says only save and we have this
168:30 - question mark that or not or asserted
168:35 - and have this this operator Cults are
168:38 - allowed on a nullable receiver of type
168:40 - string so it's saying that we can
168:44 - we can only get because you this this
168:48 - variable can have a null value but we
168:51 - know that it doesn't but the compiler is
168:54 - saying to us because we said that this
168:57 - can have null is saying to check first
169:00 - that this variable is not equal to null
169:03 - and then try to get its length and let's
169:06 - do that in the Long Way first so let's
169:08 - delete this
169:10 - so Alex actually just copy this
169:18 - and we type if
169:21 - we put parenthesis if
169:25 - text not equal to null
169:33 - then I'm gonna output this one we're
169:36 - then going to get its length so we're
169:38 - gonna type here text
169:40 - not the length so now that the compiler
169:42 - is happy because it's it's uh it's
169:46 - ensure that is not gonna have no because
169:47 - we checked here especially that this
169:49 - variable uh should have you should not
169:52 - have null in order to get the length so
169:55 - now if I run this
169:59 - I get four so this is the length so we
170:02 - have four letters here and I go I can
170:04 - also add the else part
170:07 - which is which is gonna say
170:12 - the very
170:15 - well it's not so if the variable is not
170:17 - the else part is going to be called
170:20 - so now if you run this
170:25 - will get also four but I'm gonna assign
170:27 - I'm gonna reassign this variable so I'm
170:29 - gonna change it to VAR first
170:31 - so we put here VAR
170:36 - and put here text equals null so now our
170:40 - variable is null and this check is going
170:43 - to fail and it's gonna execute the else
170:45 - part so if I run this code
170:50 - so we get the variable is null because
170:51 - now on the
170:54 - on the third line we assign nullity so
170:56 - this if fails and is executed there spot
170:59 - but as you can see it's a lot of code
171:00 - just to check to to check and imagine if
171:03 - you have multiple variables to check to
171:05 - always check for this that the variable
171:08 - is not normal then print its length and
171:11 - there is a shorter way in kotlin to do
171:13 - that and we saw as a suggestion how to
171:16 - do that previously so if I press Ctrl Z2
171:21 - um undo our code so if I press still
171:24 - pressing now if I hover over this error
171:27 - that we had previously which says
171:30 - only save call so and you have this
171:33 - operator and this is called the
171:37 - safe call operator and if I put here
171:40 - just a question mark
171:43 - this is equivalent to having if which is
171:46 - checking to see if the length is null if
171:49 - and if the length is null then it's
171:51 - going to say null or and if it's not
171:54 - null it's gonna just output four so now
171:58 - if I run this so this is equivalent to
172:00 - the if that if the the if statement that
172:04 - you had previously so you have four
172:07 - so what if I should and if I assign null
172:10 - so if I type here let's change this to
172:13 - vardy First
172:15 - so if I assign here text equals
172:19 - null
172:23 - we'll simply get null
172:29 - we get null but what if I want to get
172:31 - that null pointer exception for whatever
172:33 - reason what can I do well the compiler
172:36 - or it helping is helping us also there
172:39 - so because if I delete that save call
172:42 - Operator which is just a question mark
172:44 - that and that is basically saying
172:48 - hey if this text is not null then output
172:52 - in the console then get then get the
172:55 - length and then output that in the
172:56 - console if it's null just say no so this
172:59 - is how the save call Operator works but
173:02 - if I delete this as you can see there is
173:04 - another
173:05 - operator and is
173:08 - and is this operator which is uh two
173:11 - exclamation marks and this operator is
173:14 - basically saying
173:16 - hey if this variable has null then throw
173:20 - that exception but if it's not null just
173:23 - output don't just output the length so
173:26 - if I put two exclamation marks here
173:30 - but for whatever reason it's not the our
173:34 - text that length is not getting the
173:35 - length and I think this this is because
173:38 - we assign to our text variable here null
173:42 - it it can't it has a prep it has a pro a
173:45 - problem with inferring what type this
173:48 - variable is even though here is saying
173:50 - that it's a string so we should
173:53 - we should be able to call that length
173:55 - and to avoid this you just put null at
173:58 - uh when you declare the variable so we
174:00 - assign here null
174:02 - so we put here null
174:07 - now if you run this because you have the
174:09 - two inflammation Mark operator now this
174:12 - will throw that null pointer accession
174:14 - that I talked about
174:17 - so we get exception thread main so it
174:21 - doesn't matter what trademark is now I'm
174:23 - gonna you get Javas like the null
174:25 - pointer exception so this is the
174:27 - the null pointer exception but if we
174:31 - assign down here this variable text
174:33 - equals
174:35 - some text
174:38 - and now if we run this code
174:46 - you get nine because this is the length
174:49 - of this so
174:51 - this is how you can use this operator
174:54 - the next operator that you can use is
174:55 - the Elvis operator and to show you how
174:58 - that works I'm going to delete this code
175:04 - now I'm going to declare another
175:06 - variable up here so I'm going to call it
175:08 - text two
175:10 - we put equals and we type text
175:15 - now to use the Elvis operator we put a
175:18 - question mark and the colon
175:21 - and now we need to uh
175:24 - type something on the right of the
175:26 - office operator so we put here some text
175:29 - I'm going to explain immediately how
175:30 - this works so I'm gonna type here
175:35 - some
175:40 - text
175:42 - now what the Elvis operator is doing is
175:46 - saying
175:47 - if this variable text is null then
175:51 - assign what is on the right to this
175:54 - variable text to
175:56 - if this variable text is not null then
176:00 - assign what is to this variable to our
176:03 - variable text to our variable text to
176:07 - and now let's uh
176:10 - let's type here text too
176:13 - and less the little length
176:18 - so now if you run this code
176:22 - let's actually put something more
176:23 - discrete like
176:26 - the variable
176:30 - null
176:31 - so if you run this code now
176:36 - we get a variable is null because
176:39 - it checked to see to to see if this
176:42 - variable on the left is null and if it
176:45 - is if it is now it's gonna it assigned
176:48 - this to to a variable takes two and then
176:50 - I'll put that in the console
176:53 - but if this is not null then it's gonna
176:55 - assign what is on this would what do
176:57 - whatever value this variable has to or
176:59 - variable takes two so if now I put here
177:02 - text equals
177:05 - this variable is not null
177:11 - now if I run this
177:13 - now this well this will evaluate to true
177:16 - so it's gonna
177:18 - assign whatever value is on the left or
177:21 - variable text to a variable text to and
177:23 - we're going to see in the output the
177:26 - variable is not null so we want a
177:28 - variable to X2 has now the value
177:30 - assigned from our for each variable so
177:32 - this is the shorter way of writing let
177:34 - me show you how we will write this in
177:36 - the longer way so you in the longer way
177:38 - you will have something like this so
177:39 - let's delete this quad
177:43 - actually
177:45 - yes let's delete this quad
177:52 - will have a variable called
177:55 - text
177:57 - tool and
177:59 - it's gonna have an empty string
178:02 - so we would what we will have to do
178:04 - without the Elvis operator we have to
178:07 - first check if text
178:10 - not equal to
178:13 - is not equal to null
178:17 - then I'm gonna call our variable a text
178:21 - to
178:23 - and we're gonna assign a text to it
178:27 - else
178:32 - we're going to assign to our text to
178:35 - variable the text
178:38 - this variable is null so this is the
178:42 - longer where we're doing of what we did
178:45 - previously so if I press Ctrl Delta
178:47 - format of code now if you run this
178:53 - you'll see the the same amount of the
178:56 - variable is not null
178:58 - so we get a variables not now and this
179:00 - is the longer way of doing the same
179:02 - thing so if I assign here
179:06 - if I assign actually if I delete this
179:08 - and the variable will have null
179:10 - let's press Ctrl Z
179:19 - if I run this
179:22 - foreign
179:23 - part is executed so our variable takes
179:27 - two it will be it will have the thesis
179:29 - variable this variable is null that
179:31 - takes assigned to it and then it's going
179:33 - to Output that in the console so this is
179:36 - the longer I was doing what was of what
179:38 - we had previously so if I press Ctrl Z
179:40 - to have the Elvis operator back
179:43 - so that was the longer way of doing what
179:46 - of what you're doing here in one simple
179:48 - line of code
179:49 - so this is our discussion about nullable
179:53 - types and uh I hope that you got a lot
179:56 - from this video and see you in the next
179:58 - video
179:59 - right now it's time to start a
180:01 - discussion about functions but first
180:03 - let's create a new project and I'm going
180:04 - to speed up the process now a little bit
180:06 - because we already did this a few times
180:08 - so I'm gonna call it functions should be
180:10 - in Pascal case
180:12 - select IntelliJ click on next and click
180:14 - finish
180:20 - all right let's delete the code inside
180:21 - the curly braces
180:24 - let's hide the project Pane and let's
180:27 - start by saying that until now we have
180:29 - written our code only inside the main
180:31 - function and occasionally we have called
180:34 - The Print line function to Output some
180:36 - code to the console but as I said at the
180:39 - beginning of our videos you can create
180:42 - your own functions in kotlin so let's
180:44 - see how we can do that so go down here
180:47 - at the end of our main function at the
180:49 - end of our enclosing curly brace
180:52 - and to declare the function we type the
180:54 - keyword fun
180:57 - we put space next we need to give a name
181:00 - to our function and the name of the
181:01 - function should say what the function is
181:03 - doing and generally it's a verb I'm
181:05 - going to call this function say hello
181:08 - and it should be in camera case next you
181:10 - put parenthesis because functions can
181:13 - take input to work with it
181:15 - and next you put
181:17 - curly braces because this is what we're
181:20 - going to put our
181:21 - instructions for our statements this is
181:23 - going to put our logic now let's add the
181:26 - print Elena statement here
181:31 - foreign
181:38 - and now let's run this code
181:46 - now
181:47 - as the input we don't see nothing here
181:50 - because if you hover this say hello
181:52 - function it says
181:54 - function say hello is never used because
181:56 - in order for that this in order for this
181:59 - function to be used you need to call it
182:01 - from main function and to call it from a
182:03 - function we type here
182:06 - the name of the function you can type it
182:08 - entirely you or you can type start
182:12 - typing you know IntelliJ is going to be
182:13 - it's going to give you some suggestions
182:15 - so press enter to fill and fill in that
182:17 - video and also press Ctrl alt L to
182:22 - format the code
182:24 - now let's run our code
182:32 - now you're gonna see that it says in the
182:35 - output hello because the main function
182:38 - executes in what's inside the curly
182:40 - braces and uh on the line two it sees
182:44 - that we have a function that we're
182:46 - calling here a function executes it
182:48 - executes the the say hello function the
182:51 - code inside the say hello function in
182:53 - this case it's a simple printl and a
182:55 - statement and then it outputs that to
182:58 - the console and it acts as the
183:01 - the code it finishes the process because
183:05 - you don't have anything else below for
183:07 - say hello but what we can do is put
183:09 - another say hello here to call our
183:11 - function again and now we're gonna see
183:13 - the output
183:16 - hello two times because now we're
183:18 - calling the say hello function
183:20 - first on the line two and second the
183:23 - line three so it will be executed two
183:25 - times so you can see that in this wave
183:28 - functions are reusable
183:30 - and are separate chunks of code okay
183:33 - which can be can be reused and you'll
183:36 - see that they can be used in specific
183:38 - cases now
183:40 - as I said functions can take input and
183:43 - to make a function to receive some input
183:46 - we need to Define what is called the
183:48 - parameter and to define a parameter we
183:50 - type the name of the variable first I'm
183:52 - going to call it name
183:54 - and we need to explicitly provide the
183:57 - type here
183:58 - so for the type I'm going to choose
184:00 - string and we need to explicitly provide
184:02 - a type here because is there there is no
184:04 - way for the type to be inferred here
184:06 - because uh
184:09 - the value that you're gonna pass to this
184:11 - say hello function is going to be here
184:14 - so it's impossible to know to what the
184:17 - kind of value are we going to pass to it
184:20 - so this is why you need to explicitly
184:22 - say what data this parameter or this
184:26 - variable is going to store so let's
184:27 - delete this second say hello
184:30 - now
184:32 - let's change the text that I have here
184:34 - in the println Let's uh
184:37 - let's refer the parameter name so put a
184:40 - dollar sign and start typing name
184:43 - and you can see that has this P4
184:45 - parameter and press enter now what is
184:48 - going to happen now is that this say
184:51 - hello function is going to be called
184:53 - it's going to be executed from our main
184:55 - function
184:56 - and the code inside the say hello
185:00 - functions is also going to be executed
185:01 - and specifically it's going to execute
185:03 - this uh this uh text that we type here
185:07 - to be outputted it's going to execute
185:09 - the hello and then it is going to
185:11 - execute uh what what value if we have
185:15 - passed
185:17 - as an argument for this parameter and uh
185:21 - if you don't know what an argument is
185:24 - the argument is the value that you pass
185:25 - to the
185:27 - um
185:28 - to the function so in this case up here
185:31 - we need to pass
185:33 - some text so I'm going to put the name
185:35 - here
185:36 - not here
185:41 - it should be in a double rotation marks
185:44 - and you see that we have a hint here
185:46 - which says which is which says the name
185:48 - of the very of the name of the parameter
185:50 - which is name now what is going to
185:52 - happen now is this this say hello
185:55 - function is going to be called
185:56 - and this value that we passed here is
186:00 - going to be used in our println
186:03 - statement where where
186:06 - we're referring now which is uh here you
186:10 - here we're using the name and it's going
186:12 - to use that value and that value is
186:14 - going to be outputted down here and
186:15 - let's run the code to say
186:21 - now get Hello Alex because now it's
186:25 - using the value that you pass here as
186:27 - the as an argument to the parameter name
186:30 - and it's using that value down here
186:34 - where a
186:35 - we type the printerland statement or
186:38 - function now functions can take multiple
186:42 - arguments multiple arguments and to do
186:45 - that we need to Define
186:47 - I should say that you can Define more
186:50 - parameters for the function and a
186:52 - function contain multiple arguments and
186:55 - to Define another parameter
186:57 - we put the
187:01 - comma here
187:03 - and we type the name of our parameter is
187:07 - going to be age and we need to provide
187:09 - the type and I'm going to provide the
187:11 - type as anything yet because as an
187:13 - integer because it's going to store
187:15 - whole numbers
187:16 - and
187:17 - you're gonna put an exclamation mark and
187:20 - I'm going to type your
187:25 - age is now we need to refer the
187:28 - parameter age and
187:30 - also need to provide the value for that
187:32 - parameter
187:35 - now if you go up here now it says that
187:37 - you need to provide a value for the
187:40 - parameter has age it says no value pass
187:42 - from for the parameter a so here you
187:45 - need to type on a value for our
187:47 - parameter that we Define so let's say
187:49 - 22. all right now if you run this code
187:54 - now those parameters that we Define here
187:57 - are going to use the values the argument
188:00 - that we type here inside the our
188:04 - curly braces or
188:06 - how it's often called the body of the
188:09 - function or the code block so it's going
188:11 - to use the values here and here
188:15 - now another important thing to know is
188:17 - that you can not change the value of a
188:20 - parameter so if you type here age equals
188:22 - let's say
188:25 - 30.
188:27 - not gonna if you hover over here because
188:29 - you have an underline it says Val cannot
188:31 - be reassigned because those parameters
188:34 - are are declared as valves as variables
188:37 - false so that means that they are
188:39 - immutable we cannot change their values
188:41 - the only way to use the variable which
188:44 - can have is value changes to declare on
188:47 - so if you declare here a variable I'm
188:49 - going to declare it as a VAR to change
188:51 - this value I'm going to call it number
188:54 - and if I
188:57 - assigning healer value of 50 now I
189:01 - as you know you can change now his value
189:03 - to let's say 70.
189:06 - and you can also assign the
189:09 - parameter here
189:11 - to our variable number and now we can
189:13 - change its value because input number
189:17 - and can put another value here
189:19 - all right
189:22 - another important thing to know is that
189:25 - this variable that we Define here also
189:28 - the parameters are scoped inside the
189:32 - function say hello in other words they
189:35 - cannot be referred or accessed outside
189:38 - of the calibration of the say hello
189:40 - function so if I try to access that
189:44 - number variable here
189:47 - is not working
189:49 - if I try to access access here on the
189:51 - main function let's say type number
189:54 - I can because it's scoped inside the say
189:57 - hello function it exists only inside the
190:00 - say hello function the same thing with
190:02 - the parameters age
190:05 - or a name
190:09 - so
190:10 - in this way you can see that functions
190:12 - can be very useful because they are
190:16 - chunks of code which are reusable and
190:21 - flexible and
190:25 - to see an example with this let's
190:27 - declare another function down here let's
190:29 - call it the
190:32 - let's type the fun key or let's call it
190:34 - get data
190:36 - and this function is going to mimic the
190:39 - real function in a real app which can
190:42 - get some data from the internet of
190:43 - course that you're not going to get some
190:44 - other internet but we're gonna uh mimic
190:47 - that behavior so here I'm gonna Define a
190:50 - parameter let's call it data and for the
190:53 - type let's choose string right
190:55 - let's put the curly braces and here
190:58 - let's add the print Ln segments and here
191:03 - you're gonna print
191:06 - your data is
191:09 - and
191:10 - I'm gonna refer the parameter data
191:16 - all right now what I can do up here is
191:19 - to define a Boolean variable it's going
191:22 - to be a Val I'm going to call it has
191:25 - internet
191:28 - connection I'm going to assign a value
191:30 - of true to it
191:32 - now I can put an if statement here now I
191:35 - can check to see if that
191:39 - expression is true so I can put TV
191:42 - equals true or
191:45 - use the shortcut because it's better
191:48 - here I'm going to put the early braces
191:51 - and now I'm gonna call the get data
191:56 - function only if this condition is true
192:00 - so in our case it's true the but in a
192:03 - real lab that can be can be false so in
192:06 - that case you can do something else as
192:07 - you can assume we're gonna let's also
192:09 - other else part here
192:11 - and here we're gonna call another
192:13 - function which can which is going to be
192:15 - called in the case that there is no
192:17 - internet connection all right so
192:20 - above here you can personal logic to get
192:22 - the data from the internet well because
192:23 - this is a simple example gonna type here
192:25 - directly
192:30 - some text let's put some data
192:33 - and uh for the else part in the case
192:36 - that there is no internet connection
192:37 - that variable is false we can declare
192:39 - another function down here
192:41 - to oh and I'm going to call it fun
192:47 - show
192:50 - message
192:52 - and this is not gonna have any
192:55 - parameters it's gonna have only simple
192:57 - println statement
192:59 - and it's going to say that uh
193:02 - there is no
193:04 - internet
193:11 - connection
193:13 - all right so now let's go up here now
193:16 - and now we're gonna call
193:19 - the
193:23 - show message function
193:26 - in the else part
193:28 - now if you run this code
193:38 - you're gonna see
193:39 - Hello Alex which is our first function
193:42 - up here on the line tool your age is 22
193:46 - and next to see your data is some data
193:49 - because it executes the say hello
193:52 - function then it declares this variable
193:54 - and it checks it checks to see if this
193:58 - condition is true and this condition is
194:00 - true and it executes this function get
194:04 - data so this is why you get your data is
194:07 - some data but if for whatever reason the
194:11 - user has no internet connection let's
194:13 - say you assign a value false to it
194:16 - to this
194:19 - now this function is going to be called
194:21 - show message
194:28 - so this function show message now is
194:30 - called and the code inside the show
194:32 - message function is called which is
194:35 - printerland with this sprinterland
194:36 - standard which says there is one
194:38 - technical connection area lab you can
194:39 - have some logic to show a dialogue that
194:43 - there is no internet connection and you
194:45 - can see that in this way with functions
194:47 - you can divide your
194:49 - code in different chunks of
194:52 - different different chunks of code which
194:55 - can be called in very specific cases so
195:00 - in this case
195:01 - we only call our functions only in in
195:05 - the case that we have internet
195:06 - connection or in the case that we don't
195:09 - have internet connection so in this way
195:11 - we have divided our code in different
195:14 - chunks of code which can be called in
195:17 - different uh specific scenarios and in
195:21 - this way
195:22 - we can write a program because if you
195:25 - just put your code all of your code in
195:28 - the main function and you execute that
195:29 - code from top to bottom you you cannot
195:33 - create a program like that so this was
195:36 - an additional discussion with the get
195:39 - data and show message and I hope that
195:41 - I'm not confused you a lot so see in the
195:44 - next video
195:46 - all right so in the last video we've
195:49 - seen how we can create functions how we
195:52 - can call our functions how we can Define
195:54 - parameters to our functions how can send
195:58 - the data to our function as arguments
196:00 - now it's time to see how we can return
196:02 - some data from a function but let's
196:04 - first read the code that we have here
196:07 - to make things more clear
196:10 - and the code inside the function the
196:13 - main function
196:18 - all right now let's
196:20 - Define another function I'm going to
196:22 - type the fan keyword space and it's
196:24 - going to be called get Max
196:27 - and this function is going to return the
196:29 - maximum of uh two integers
196:34 - so I'm gonna Define here a parameter I'm
196:37 - going to call it a in a real aperture
196:39 - those more descriptive names
196:40 - is going to be of type int and the next
196:43 - one is going to be called B and it's
196:45 - going to be also of type int
196:49 - I'm gonna put the
196:52 - curly braces and I'm going to press
196:53 - enter
196:56 - now to get the maximum value between
197:00 - these two numbers we type here we have
197:02 - here Val
197:04 - Max
197:06 - and here we type an if expression so we
197:09 - type if
197:12 - a
197:13 - greater than b
197:16 - then we're going to assign a to our Max
197:20 - variable else
197:22 - I'm going to sign B and in the case that
197:24 - the two numbers are equal B is going to
197:27 - be assigned to our
197:28 - Max
197:30 - variable
197:33 - now in order to return this uh to in
197:36 - order to return this
197:38 - value to our function we need first to
197:43 - to say to the function what kind of data
197:46 - is going to return and to do that go
197:49 - here at the enclosing parenthesis and if
197:52 - you don't have spaces here or you
197:55 - wondering about how to
197:58 - have the proper formatting you just
198:01 - press Ctrl alt L and the code is going
198:04 - to be formatted all right and here we
198:06 - put a colon
198:07 - and here we we Define why what type of
198:11 - data this function is going to return
198:13 - and in this case it's going to be an
198:14 - integer so we put in here
198:17 - and this is similar to The Way We
198:19 - declare a type for a variable now
198:21 - if you could if you go down here now you
198:23 - see that it says
198:24 - a return expression is required in a
198:26 - function to block body so now we need to
198:28 - return this uh
198:31 - now you need to return some data that we
198:33 - Define here in this case we need to
198:35 - return an integer and to return the
198:39 - maximum value to our function we type
198:41 - here return the keyword return
198:44 - and our value which is our variable Max
198:47 - and press enter
198:49 - now if you call this function in our
198:52 - main function
198:54 - get Max and now let's also press Ctrl
198:57 - alt L to format the code
198:59 - and here we let's say that we type two
199:02 - arguments for our parameters let's say
199:05 - that put five
199:07 - and nine now if you run this code
199:21 - now you're gonna see in the output
199:22 - nothing because uh in order to
199:26 - in order to get this value need to
199:28 - retain this value to capture this value
199:30 - in a variable and to do that we Define a
199:32 - variable in front of our get Max
199:34 - function it's also be a Val
199:38 - I'm going to call it Max
199:40 - and we're going to assign the get Max
199:47 - function to our variable and that is
199:49 - going to return
199:50 - or a maximum number
199:53 - now you now you may see that you have
199:56 - two names we have the same name here in
199:59 - the same and that is not a problem
200:01 - because this variable marks that we have
200:03 - inside the
200:04 - the get Max function exists on inside
200:07 - the the get Max function is scoped only
200:09 - here this is why you can use the same
200:12 - name here so if I try to type here also
200:15 - Max to declare variable which is going
200:18 - to be called Max I can't because
200:22 - it says completed declaration because if
200:25 - you
200:25 - because the compiler doesn't know if you
200:28 - assign a value let's say to this it will
200:30 - not know what variable to to to call
200:33 - because you have the same name but uh
200:37 - up here is not a problem because this is
200:39 - in the block of the main function so it
200:42 - exists only here and this exists only
200:44 - here now
200:46 - we have called our get Max function and
200:48 - this function is going to return the
200:49 - maximum of these two values which is
200:52 - nine now we need to print this value not
200:54 - console and to print this value just
200:56 - type here println
200:58 - and we're referring our
201:00 - Max variable
201:02 - now if you run this code
201:10 - you're gonna get nine because uh our get
201:14 - Max function is called the two the two
201:17 - arguments are passed to our function
201:19 - then the code inside the auto get Max
201:22 - function it's executed it Compares these
201:25 - two two numbers and if a is greater than
201:28 - b then it assigns eight or Max
201:31 - a Max variable or it's gonna if that is
201:35 - not true is going to assign the value of
201:38 - B and then it returns that max value to
201:41 - the to the function which is called so
201:44 - if this function returns that value here
201:46 - and and here we retain we capture that
201:50 - value which is returned from the get Max
201:52 - function our Max variable and then we
201:54 - print that Max variable with our println
201:58 - function or a statement and then we see
202:01 - the output in our console 9 right
202:05 - another important thing to know is that
202:07 - after we type the return call or the
202:10 - return keyword the
202:13 - the function is lift the function is
202:16 - stopped there so if we add the
202:19 - other text here let's say we add here a
202:21 - printerland
202:23 - and we type here some text
202:27 - we see that this is highlighted and it
202:29 - says
202:31 - that is this is a reachable code because
202:32 - after we typed our return marks our
202:34 - function is
202:37 - stopped is lived and it's not executing
202:41 - any any code below of of that return
202:45 - color or of that return keyword right
202:52 - another important thing that you can do
202:54 - with the return keyword is that you can
202:56 - return from a function without returning
203:00 - any kind of value and in that case it
203:01 - will have the same effect and that means
203:05 - that it will leave the function right
203:07 - there even though we don't return any
203:09 - kind of value so we I can type here
203:11 - return but let's uh
203:14 - the list here the type
203:16 - because now it's expecting a value to be
203:18 - returned and now this will have the same
203:20 - effect it will leave the function right
203:22 - there and it will not execute any any
203:24 - kind any line of code below of our
203:27 - return keyword so if I type here
203:29 - a println statement
203:32 - and I put some text here
203:40 - as you can see this has the same effect
203:42 - if you type the return keyword in your
203:45 - function it will stop the execution of
203:48 - the function and every line of code
203:50 - below of the return keyword is not going
203:52 - to be executed so it's very good to know
203:56 - this also
203:58 - another important thing to know is that
204:01 - you can we can only return a single
204:03 - value with the return keyword so we
204:05 - cannot return here to two integers let's
204:07 - say and also we cannot have two returns
204:11 - in the same function let's say if I put
204:13 - here also return marks
204:17 - I can't because this is also a reachable
204:19 - code but I I can have two returns
204:23 - two returns calls if they are rich in
204:25 - different branches so if I change this
204:28 - if expression to an if
204:31 - statement so if I type something like
204:34 - this
204:35 - if let's say
204:37 - a greater than b
204:40 - let's add the curly brace now
204:42 - we type here
204:44 - return
204:45 - a
204:50 - else
204:53 - return B
204:56 - so now we have two returns but they are
204:59 - never reached together
205:01 - they are they are always reached
205:04 - separately so this is why you can use
205:06 - here two returns because they said they
205:08 - are rich always separately so if you run
205:11 - this code you're gonna see the same
205:13 - output
205:17 - so you C9 so this is another way to to
205:21 - write the same thing that we had
205:23 - previously that but it's recommended to
205:24 - use a
205:27 - to use uh what we had previously because
205:30 - with uh specifically it's better to have
205:33 - enough expression
205:35 - another way to to write to the same
205:39 - thing but in a more concise way and
205:42 - let's undo the code that we have that
205:44 - you had previously
205:46 - so let's press Ctrl Z
205:54 - so now I have the code that help briefly
205:57 - now if you hover over over this Max it
205:58 - says variable use only in formatting
206:00 - return can be in line so if you click
206:02 - here in line variable
206:04 - now this thing does the same thing that
206:07 - it it was doing previously but this is a
206:11 - shorter way to write the same thing so
206:13 - now it returns a if this condition is
206:17 - true otherwise else part the else part
206:20 - is called and it returns B so we have
206:23 - the same thing but
206:24 - written in a shorter way
206:27 - all right another way to write the same
206:29 - thing that we have here is by using what
206:31 - is called the single expression function
206:33 - and to do that we can remove the curly
206:37 - braces
206:39 - we can put our code up here
206:41 - you can remove the first curly brace and
206:43 - you can also remove the return keyword
206:49 - and here you put equals
206:52 - and this now does the same thing that
206:55 - the code
206:57 - the previous code that was doing but
206:59 - this is a more concise way and it's
207:02 - recommended to use this only if you know
207:05 - that you know you have in your function
207:07 - a single expression or in other words if
207:11 - you know that you have a single line of
207:12 - code and you can also remove the type
207:14 - here because the type can be being
207:17 - inferred
207:18 - and again only use this if you know that
207:21 - you have in your function a single line
207:23 - of code and in that case you can you can
207:27 - skip the return keyword but if you have
207:30 - multiple lines of code you should always
207:33 - use the curly braces and the return
207:35 - color the return keyword
207:38 - all right so this is our discussion
207:40 - about how we can return a value from a
207:42 - function
207:43 - all right so now let's continue a
207:45 - discussion about functions and now it's
207:46 - time to look at what is called function
207:49 - overloading and let's say that I want
207:51 - here to pass not to integer types but
207:54 - two doubles to be compared so let's say
207:56 - that type here 6.5
208:01 - and 9.6
208:04 - now this will not work because it's
208:06 - defined here explicit that the
208:08 - parameters are of type int so we cannot
208:11 - pass here double
208:12 - and a solution to this it may be to
208:16 - create another function the different
208:18 - name and to define the parameters as
208:21 - doubles but that does not make a lot of
208:25 - sense because
208:26 - we we are doing the exact same thing so
208:29 - does not make sense to create a new to
208:32 - create a function with a different name
208:33 - so
208:34 - what you can do instead is to
208:37 - let's change it back to integers
208:40 - is to duplicate this get Max function
208:42 - and do that you can press Ctrl D or
208:44 - command line on Mac some press I'm going
208:46 - to press Ctrl D here
208:48 - now what I can do is change the types of
208:50 - the variables so I can put here instead
208:53 - of integer I put double
208:59 - and here I can put also double
209:05 - let's add the space to make things more
209:07 - clear now if I pass here
209:10 - let's say your 5.6
209:14 - and 9.7 now you see that we have an
209:17 - error
209:18 - so if you run this code
209:25 - all right so we get in the output 9.7
209:28 - and this is called this uh is bigger
209:30 - than 0.5 or 6 but now it's using the
209:33 - second function which is the function
209:35 - which has the parameters as of type
209:37 - double and you can see that this
209:40 - function now which is using the
209:41 - parameters as integers is gray out
209:45 - because the compiler can figure out what
209:48 - function to use by the argument types we
209:52 - pass here so in this case we pass here
209:54 - doubles and it knows that it has to use
209:58 - this function which has the types which
210:01 - has the parameters Define as type of
210:04 - double right
210:06 - another way to overload the function is
210:10 - to best also press Ctrl d
210:15 - is by changing the number of parameters
210:17 - so I can put here let's say
210:21 - also integer
210:29 - also releases so let's pass another the
210:31 - third parameter now and this is also
210:33 - going to be an integer it's going to be
210:35 - called C
210:36 - gonna be of typing
210:40 - all right now let's change this logic to
210:43 - any statement so let's delete the if
210:46 - expression let's put the curly braces
210:59 - all right so let's change this now
211:04 - so you can type it here now if a greater
211:07 - than equal
211:08 - to be
211:10 - and a is greater than equal to to C then
211:16 - I'm going to return a
211:19 - so now we're using the return keyword
211:22 - else if now
211:25 - putting here an lcf
211:29 - B
211:30 - is greater than equal to a and
211:35 - B is greater than equal
211:39 - to C
211:42 - then return B
211:44 - else C is going to be the bigger value
211:48 - so put here return C
211:53 - all right let's press Ctrl
211:56 - alt return B here
212:03 - right so I need to put here the type
212:05 - this will get that error right now
212:07 - everything is okay
212:09 - oh so from here is the problem
212:15 - all right so now
212:17 - if you run this code let's change this
212:19 - to let's say
212:22 - five
212:27 - seven
212:29 - and 10.
212:31 - now if you run this code
212:34 - you see that the two functions above our
212:36 - big gray out
212:37 - and I was going to use the third one
212:39 - which has third parameters
212:43 - all right so when you get to get in the
212:44 - output 10 which is correct so if you
212:46 - change this to test let's say if we put
212:48 - here
212:49 - 100
212:51 - let's put here
212:53 - three and if you run this code
213:05 - now we get 100 and this is correct
213:09 - all right so this is our discussion
213:10 - about function overloading and you can
213:12 - use function overloading every time you
213:14 - know that you will do the same task but
213:18 - with different type of parameters or
213:20 - with a different number of parameters
213:22 - also you may have noticed that we have
213:25 - another line over uh over if over the
213:28 - statement so if you hover over here
213:31 - says that the return can be lifted out
213:32 - if so if you click this
213:35 - you can write it in this way so or we
213:38 - can keep it in the
213:40 - previous way but because this is uh
213:43 - underline that means that kotlin
213:45 - recommends to use it in this way
213:49 - in this way
213:51 - so see you in the next video what we're
213:52 - going to talk about default parameters
213:57 - all right so now it's time to look at
213:59 - another features that you can use with
214:01 - functions and that is called default
214:03 - parameters and let's first declare a
214:06 - function
214:07 - so I'm going to declare it down here at
214:09 - the end of our enclosing curly brace for
214:11 - main fun I'm going to call it send
214:14 - message
214:16 - let's put the parenthesis and inside the
214:18 - parenthesis I'm going to Define two
214:20 - parameters the first is going to be
214:21 - called name it's going to be of type
214:23 - string
214:25 - and this second one is going to be
214:26 - called the
214:28 - message and it's going to be also of
214:31 - type string
214:33 - now let's uh
214:35 - you take the cloud the curly braces
214:37 - press enter and let's print those
214:42 - parameters in our console so let's put
214:45 - the printer line here and inside the
214:48 - also uh while I'm typing while I'm
214:52 - pumping this printable anime since that
214:54 - this println function is a function
214:56 - which is overload referring to our
214:58 - previous video because you can see that
215:00 - it can it has the same name but it can
215:02 - take different types of parameters here
215:05 - so it has in this thing which is any
215:07 - bytes or Char long so the print element
215:10 - 5 function that you've used throughout
215:13 - our videos is overloaded this is why you
215:15 - can pass different uh
215:17 - different types of of data to it now
215:22 - let's type here
215:24 - println
215:28 - quotation marks inside the quotation
215:30 - mark we're going to type name equals
215:32 - dollar sign name
215:39 - so now it's going to print the
215:40 - argument values that are going to pass
215:42 - to this function as parameters now let's
215:45 - call this function here
215:48 - so let's type send
215:50 - message to
215:53 - format our code and here I'm going to
215:55 - pass a name let's say
215:58 - Alexa and
216:01 - the message let's say
216:04 - hello
216:05 - now if you run this code you're going to
216:07 - see in the output
216:08 - um the name here is going to be this
216:11 - argument that we type here which is
216:13 - Alexa and the message is gonna be hello
216:16 - so we have this but let's say that for
216:19 - whatever reason the user doesn't want to
216:22 - to send any kind of message but we still
216:26 - need to use this function what you can
216:28 - do then
216:29 - one way is to remove this parameter all
216:33 - the way but uh that is not the
216:36 - good because you still need to use this
216:38 - function with those two parameters the
216:41 - name and and the message so you know
216:43 - let's say that if the user doesn't pass
216:45 - any message we can Define here what is
216:47 - called the default
216:49 - param a default parameter so what you
216:52 - can assign here a default value for our
216:55 - parameter so I'm going to put here uh
216:57 - just the double quotation marks or
217:02 - or you can put some text here but let's
217:04 - put just the double quotation marks
217:06 - which is just an empty text so if now I
217:09 - don't pass a message here
217:12 - now we're still gonna work because as a
217:15 - value for this parameter is going to use
217:18 - the default value that we defined here
217:21 - all right so let's run this code to see
217:22 - now
217:23 - how it works
217:31 - so now get name Alexa and message equals
217:33 - empty because m double quotation marks
217:36 - without any text is an empty text now if
217:39 - I want to pass here now
217:41 - the message now you can pass here the
217:43 - message
217:46 - and now our default value is going to be
217:48 - replaced with the argument value that we
217:51 - typed here
217:52 - so now I'm going to see name Alexa
217:54 - message hello
217:55 - all right you can do the same thing for
217:57 - uh for the name so here you can Define
218:00 - let's say that the user doesn't want to
218:04 - to type a name and we can define a
218:06 - default name let's say user
218:09 - yes
218:11 - now let's say that I delete both
218:13 - arguments here
218:18 - and I just have an empty
218:21 - function if I run this now it's going to
218:23 - use the default values that you type
218:25 - here respectively user and this empty
218:27 - string so now get name user and message
218:30 - now let's put back what we have so let's
218:33 - put here
218:34 - Alexa
218:36 - let's put our message here again
218:44 - now let's run this code again
218:50 - now what we can also do is use what is
218:54 - called named parameters and let's say
218:57 - that I want to
218:58 - to pass a parameter only for the second
219:01 - second let's let's say that I want to
219:04 - pass the argument type for only for the
219:07 - second parameter that we Define here
219:09 - respectively for our message
219:11 - so if I delete this now I'll say let's
219:14 - say that I delete the
219:15 - the argument for our name
219:19 - and if I want to pass the value only for
219:21 - the message
219:23 - let's put in the quotation mark because
219:25 - the string
219:26 - let's say I put the message hello here
219:29 - now you can see that the hint is named
219:31 - so it's using the first parameter that
219:34 - we Define here another second so what we
219:37 - can do now to pass a value to only to
219:41 - our second parameter because as you can
219:43 - see it's using the it's assigning this
219:46 - value that we type here for this
219:48 - parameter and to solve that you can use
219:50 - what is called the name parameters so
219:52 - with name parameters you can type an
219:55 - argument for our parameter irrespective
219:57 - of the order in which they are defined
220:00 - so in our case we have the name for
220:01 - Define and then the message so to use
220:04 - that you can
220:06 - type the name of the parameter let's say
220:08 - message now you see that you have this P
220:11 - message and it's equals to A String so
220:14 - that means that you need to pass some
220:16 - text here
220:17 - and now we can pass here
220:19 - hello
220:21 - and now this is gonna work because now
220:23 - we can pass a value to our parameter
220:26 - irrespective of the water in which they
220:28 - are defined here
220:31 - right so now I get name is this default
220:35 - user and the message is hello and we can
220:38 - do the same for uh
220:40 - for the second one which is name so I
220:42 - can put now here name
220:44 - and I can type here
220:48 - let's say Alexa
220:49 - and if you run this
220:55 - now get Alexa
220:57 - is the name and the message is hello so
220:59 - with the named parameters this is how
221:01 - they are called a name arguments we can
221:03 - pass the value
221:05 - to our
221:06 - parameters irrespective of the order in
221:09 - which they are defined in the function
221:11 - so in our case name is first defined and
221:14 - you saw that that when I try to use a
221:17 - the message to assign a value only for
221:19 - the message it's what it was using the
221:22 - first parameter because this was the
221:23 - word in which they were defined
221:25 - but with this named parameters you can
221:27 - change you can you can type an argument
221:32 - irrespective of the word in which they
221:33 - are defined and you can put this in a
221:35 - multiple lines to make it more clear
221:39 - like this let's say
221:42 - so this is our discussion about
221:45 - named parameters and the default
221:48 - parameters but before we win the video I
221:51 - should say that to the default
221:53 - parameters we cannot only type literals
221:55 - values like we typed here some values
221:57 - directly we can use variables or you can
222:01 - use a function which can return a value
222:04 - so I can Define here a function let's
222:06 - say fun
222:07 - send the
222:09 - text it's not going to have any
222:11 - parameters it's gonna return a string so
222:15 - I'm going to Define here a string as the
222:17 - type of return and here gonna type
222:19 - return and let's type some
222:23 - text
222:25 - now we can call this function here send
222:29 - text
222:30 - and now this value which is returned for
222:33 - this function send text is going to be
222:35 - assigned to our parameter message so now
222:38 - if you run this code
222:40 - Let's uh increase this a little bit
222:45 - so now if you run this code you're going
222:47 - to see that the Now the default value
222:49 - for the part method message is the
222:52 - return value from our send text function
222:55 - so you can see now that we have
222:58 - okay so let's change it here to no value
223:05 - for our message
223:08 - so now if you run this code because
223:10 - there we have an argument passed so
223:13 - let's not passing on the northwest so
223:15 - now it's using the value that we was was
223:18 - passed as the default
223:20 - value for our parameter which is this
223:23 - return value from this function
223:25 - now because here you have one single
223:27 - line of code we have one single
223:29 - expression we just return some text or
223:32 - function we don't have multiple
223:34 - statements in our function we can write
223:37 - this as a single expression function
223:39 - and you can remove the calibration you
223:42 - can write this as a single expression
223:44 - body like we did in a previous video so
223:46 - you can put it just equals and you can
223:48 - remove the
223:50 - type here also so if you run this code
223:54 - now I'm gonna see it to the output for
223:57 - the parameter message some text which is
224:00 - the value which is returned from this
224:02 - function from the single body expression
224:04 - function right
224:06 - so see in the next video
224:09 - all right now it's time to look at the
224:10 - VAR Arc keyword and how we can use the
224:13 - water keyword with functions but first
224:15 - let's declare the function below of our
224:17 - enclosing
224:18 - calibrase of our main function so I'm
224:21 - going to type here the
224:23 - fun keyword to declare a function
224:26 - I'm going to call it sum because it's
224:28 - going to return the sum of all the
224:30 - parameter that we're going to Define so
224:32 - I'm going to Define here some parameters
224:34 - for it's going to be called a it's going
224:36 - to be of type int
224:38 - a single second is going to be called B
224:41 - also in
224:44 - third is going to be called C
224:46 - also an end
224:50 - the final one is going to be called the
224:52 - alternate
224:54 - and this this function is going to
224:55 - return the sum of all of those
224:58 - parameters so we need to Define here the
225:00 - return type
225:01 - which is going to be an hint
225:04 - a whole number and now we can put the
225:07 - curly braces and here we type return
225:10 - a
225:11 - plus b
225:14 - plus c
225:16 - Plus
225:17 - d
225:19 - and this is going to return the sum of
225:21 - all the parameters that we Define here
225:23 - or the values that is going to be passed
225:26 - as arguments to this function and you
225:29 - can write this as a single expression
225:31 - function if you want so you can write
225:33 - this uh like this if you want
225:37 - this will have the same effect
225:41 - but I will I will write it with the
225:46 - curly braces because it will make things
225:48 - more clear so let's undo this
225:52 - right now let's call this function here
225:55 - sum
225:57 - let's press Ctrl alt L to format the
226:00 - code and let's pass some values here so
226:03 - I'm going to type here five
226:05 - six seven
226:10 - and
226:12 - 10.
226:14 - all right if you press shift Ctrl p on
226:16 - this you're gonna see that the type of
226:19 - this function let's press again
226:22 - the type of this function is an ins so
226:24 - this function returns an integer so it's
226:29 - it's an expression that means that we
226:32 - can put this instead of putting storing
226:35 - um
226:36 - uh the return value in a variable we can
226:40 - put this direction a printerland
226:42 - function so you can type here print
226:46 - area
226:48 - and we can put the function inside here
226:50 - because that function is of type in so
226:52 - it's going to return
226:54 - the sum of all the arguments that we
226:57 - type there
226:58 - so now if you run this code
227:01 - we got we get 28 because 5 plus 6 Plus
227:05 - 7.10 is 28. now if I want to pass
227:09 - another parameter here let's say that I
227:11 - want to pass another number here I can't
227:14 - because I am limited by the number of
227:17 - parameters that we Define here of course
227:19 - that I can Define another parameter here
227:22 - but what if I want to pass 10 numbers
227:25 - for 15 numbers or 100 numbers in that
227:29 - case it will be very tedious to write
227:31 - all of those parameters and and to solve
227:34 - that you need to use what is called a
227:35 - varg varag keyword and Avada keyword
227:39 - allows us to pass more than one
227:41 - parameter actually more than one
227:43 - argument to our
227:45 - parameters so to declare a Vari keyword
227:48 - we type here
227:51 - we type here far ARG so this is the
227:55 - keyword varag it stands for variable
227:58 - arguments
227:59 - now we need to define a name for this
228:02 - bar Arc I'm going to call it numbers
228:06 - and we also need to specify a type what
228:10 - kind of values this varag is going to
228:13 - store
228:14 - now this return keyword is this
228:18 - variables here are red because they
228:20 - don't exist
228:23 - now if I want to
228:27 - but first let's say that I want to type
228:29 - here another parameter now now you see
228:32 - that we have no problem so I can type
228:34 - here whatever
228:36 - number of numbers I want and there is no
228:40 - problem as you can see now
228:44 - to to
228:47 - sum the values which are stored in these
228:51 - viral numbers we need to use something
228:52 - which we didn't cover yet but we have a
228:55 - separate section which I show you how to
228:58 - we need to explain this thing that I'm
229:01 - going to use now and that is Loops
229:03 - because now we need to Loop through our
229:07 - numbers and to add our numbers to a
229:10 - variable so we need to use what is
229:12 - called a for Loop so to do that first we
229:15 - declare a variable
229:16 - I'm gonna call it um
229:21 - let's say uh result
229:27 - I'm gonna assign a value of zero
229:30 - now to use a for Loop we Type 4
229:35 - and again I'm gonna go into more detail
229:37 - about this in uh the separate section
229:40 - but now we need to use this because
229:42 - there's not another way to to sum up the
229:45 - values inside the varag numbers
229:49 - and here we need to define a name for
229:53 - our variable so it's going to be called
229:55 - number
229:56 - and now we use the keyword in
230:00 - and now we're referring the
230:02 - parameter the varag parameter which is
230:06 - defined up called numbers
230:09 - all right
230:11 - now we here you can put the curly braces
230:15 - and inside the cutter blazes we're going
230:17 - to type
230:19 - numbers
230:23 - result
230:25 - and now we're going to use that
230:26 - abbreviation which is plus n equals
230:30 - plus equals
230:33 - number n
230:36 - now here gonna return
230:38 - the result return
230:42 - result
230:45 - all right so let's explain what we have
230:48 - here so first we declare a variable we
230:50 - assign a value of 0 to it so it's just
230:52 - type int
230:54 - next what this for Loop is doing so this
230:58 - for Loop is doing what is doing is
231:01 - executing
231:02 - um a line of code multiple times so it
231:06 - executing is executing uh uh what's
231:10 - inside the curly braces until the it
231:14 - finishes to it finishes the to Loop
231:17 - through all these numbers which are
231:19 - stored in the varark number so it first
231:24 - assigns uh the first the first number or
231:30 - number here
231:31 - and it loops and it has that it adds
231:35 - that number to a result then it does
231:37 - that again and again and again until it
231:41 - finishes so then it reaches uh the final
231:43 - number five and in that case also gonna
231:46 - sign
231:47 - from our numbers uh the number five to
231:50 - our number and then that number is going
231:54 - to be added to our result variable and
231:57 - when it finishes uh that looping when it
232:01 - finishes that thing is gonna return the
232:05 - result it's gonna return all the values
232:07 - which are which were been added to our
232:11 - result variable
232:12 - so now if you print this
232:17 - now I get 85 and probably this is the
232:20 - result of this calculation so this is
232:24 - how you can use varag numbers what are
232:27 - the keyword to store more than one
232:29 - single more than a limited number of
232:33 - parameters defined
232:35 - bio and another short shortcut to to
232:40 - Loop through this is using a for each
232:42 - Loop so we can do something like this
232:46 - but this time let's say that I want I
232:49 - don't want to return something
232:52 - so let's see that I delete this
232:59 - and I I can type here actually numbers
233:04 - four
233:05 - dot here to put that
233:08 - four
233:10 - each
233:12 - and here we type print Ln
233:16 - again this is a more complex subject
233:20 - which is going to be covered in the next
233:22 - videos so here we type print Ln
233:27 - and we type it
233:30 - all right now let's uh
233:33 - let's call our sum
233:36 - let's define some numbers here let's say
233:38 - that I type here
233:40 - one
233:42 - four
233:50 - all right so if you run this code
233:54 - now you can see that every number in
233:56 - that
233:58 - that we defined here is printed one by
234:00 - one so this number this for each which
234:03 - is also a loop it goes through all of
234:06 - these numbers it and it prints them one
234:09 - by one and again we're gonna look at uh
234:12 - for the for Loop and the four each in
234:14 - the next videos but I had no other way
234:18 - to show you this example without using
234:21 - them but if you feel confused by for the
234:23 - for each or the for Loop don't worry we
234:26 - have a separate
234:27 - section which in which you talk about in
234:30 - detail about this for now we need to
234:32 - only the only thing you need to know is
234:34 - that you can
234:36 - pass an indefinite number of parameters
234:40 - of actually you can pass it an
234:42 - indefinite number of arguments to our
234:45 - varag numbers because this allows us to
234:49 - to power to to pass uh
234:53 - an indefinite number of values so here
234:57 - you see that we have one four five six
234:59 - seven eight nine five seven and six
235:04 - numbers that we have here so this for
235:07 - each is going through all of them and it
235:09 - prints
235:10 - them one by one so
235:13 - see you in the next video
235:18 - all right now it's time to start our
235:19 - discussion about loops but first let's
235:21 - create a new project
235:24 - I'm going to call it loops
235:29 - select IntelliJ click on next and finish
235:35 - right a project is created let's delete
235:37 - the code inside the color braces
235:40 - let's hide the project pane
235:42 - and let's start by explaining what Loops
235:46 - are and why you need to use them
235:48 - so Loops allows us to execute a piece of
235:53 - code multiple times without
235:56 - you writing down every line of code
236:00 - manually so
236:04 - let's say that I want to print
236:06 - 10 numbers in the console or 20 or 50.
236:10 - instead of printing instead of typing
236:13 - that code manually move line by line
236:16 - which will be very tedious you can use a
236:19 - loop and you can put that code in a loop
236:21 - and in that code in the loop it will be
236:23 - executed repeatedly until
236:29 - a certain number is reached so let's see
236:34 - how we can define a loop to define a
236:36 - loop we type here
236:38 - four this is the first Loop that we're
236:41 - gonna look at because there are other
236:43 - loops
236:45 - so this is the for Loop we press enter
236:49 - inside the parenthesis we type I this is
236:51 - convention you can put whatever name you
236:53 - wonder
236:54 - now we put here in this is the keyword
236:57 - in and now let's say that I want to loop
236:59 - from
237:00 - one
237:02 - and from 1 to 10 and to do that to type
237:05 - 1 dot dot this is a range
237:10 - one to ten now
237:12 - I put a curly braces
237:15 - and inside the pre the curly braces and
237:17 - I'm gonna put the code that I want to be
237:19 - executed
237:21 - 10 times so I'm gonna type here println
237:24 - and I'm gonna type the value of I at
237:26 - each iteration and uh
237:30 - we can put it like this you can type
237:33 - here uh
237:35 - you can put in the quotation marks and
237:37 - you can do the placeholder
237:41 - you can put I
237:42 - so now if you run this
237:47 - so now I get
237:50 - is one two
237:52 - until 10. so it what is doing is is
237:57 - looping through this range until it
238:01 - reaches 10 then it stops
238:03 - now uh you can write this I like I did
238:07 - here using a placeholder where you can
238:09 - write it like this
238:13 - I've run this code it will have the same
238:15 - effect but will not have the taste
238:17 - before here
238:23 - so now you get
238:24 - one
238:25 - until 10.
238:29 - now there are other other very
238:31 - variations to use this range and one of
238:35 - them is to use until so let's uh command
238:40 - this code
238:41 - so let's press Ctrl slash
238:49 - right now let's type 4 again
238:52 - and now I'm gonna
238:55 - I'm gonna call it also I here you can
238:57 - put whatever name you want
238:59 - and instead of now I'm going to put also
239:02 - again the in keyword and instead of
239:05 - putting the dot dot to Loop to arrange
239:09 - I'm gonna put
239:10 - one until
239:13 - 10.
239:15 - all right
239:17 - now I'm gonna add the printerliner
239:20 - statement
239:23 - and here I'm going to type I
239:26 - and
239:27 - this will have the same effect with the
239:30 - thing with a single difference that 1
239:33 - until 10 is is gonna exclude ten and one
239:37 - uh
239:39 - using the range.10 it will include 10.
239:43 - so if you run this code
239:46 - we're gonna see that you will not have
239:49 - 10 here because 10 it is excluded when
239:52 - you're using the until
239:54 - so now as you can see we have one until
239:57 - nine and then it's excluded because now
239:59 - we're using the until
240:01 - so if you if you're using the range
240:04 - which is uh dot the last number is going
240:08 - to be included but if you use the
240:10 - until the last number is going to be
240:13 - excluded so it's important to know that
240:15 - this two respectively the until and the
240:20 - range can only count upwards
240:25 - so we cannot put here 10 until 1 because
240:29 - the first number the number of on the
240:32 - left needs to be smaller than the number
240:34 - on the right so we cannot put 10 until
240:37 - 1. we can only count upwards you can
240:40 - only put one until 10 or
240:43 - 1.10 so
240:46 - to Loop backwards we need to use
240:49 - another thing so let's comment this code
240:52 - also
240:56 - now to Loop backwards we Type 4
241:00 - again in the paradise you put the I here
241:03 - you can put
241:07 - whatever if you want
241:09 - in
241:10 - so here you can put whatever name but
241:13 - the convention is I issues now I'm going
241:16 - to put in and now I'm going to put down
241:19 - first let's put uh
241:21 - 10
241:23 - down
241:25 - down to
241:29 - one
241:31 - let's add the curly braces
241:35 - the printerland
241:37 - and let's put I here
241:40 - now this is gonna this is gonna count
241:42 - downwards now it's gonna it's gonna
241:45 - count from ten to one so if you run this
241:47 - code
241:57 - now get 10 9 so it's counting it's it's
242:00 - counting backwards right another thing
242:03 - that you can do is that you can
242:04 - introduce an arbitrary step so let's uh
242:09 - let's comment this code also
242:14 - let's add below another call
242:17 - another for Loop so here I'm gonna type
242:20 - four
242:21 - parenthesis
242:23 - let's put I
242:25 - and let's use uh done TL
242:29 - so in
242:30 - one
242:32 - until
242:36 - 10. so now I can put a
242:38 - an arbitrary step so at uh at this
242:43 - arbitrary step that number which
242:47 - is that is that is at dotted arbitrary
242:50 - step is going to be skip so I can put
242:52 - here step
242:54 - to let's say
242:57 - so now I'm gonna put the quarter Blazers
242:59 - to have the some code executed I'm going
243:02 - to put println
243:03 - and let's put here I
243:06 - so now if you run the squad
243:12 - I get one three five seven and nine so
243:15 - you can see that uh
243:17 - at the second iteration the number is
243:21 - Skip so we have one two is skipped now
243:23 - we have then we have three four three
243:26 - and four skips and so on so you can put
243:29 - this arbitrary step if you want so let's
243:31 - comment this code also
243:39 - and let's add the first code that we had
243:41 - here
243:42 - to
243:44 - to talk a little bit more so let's put I
243:47 - in
243:48 - one
243:51 - let's put the range Dot 10.
243:54 - and curly braces
243:57 - you're gonna type println
244:04 - hi
244:08 - now if run this code
244:18 - we'll get the same output that as at the
244:21 - beginning of the video so get one
244:25 - until 10 inclusive now again what this
244:29 - uh loop is doing is going through this
244:34 - is going to this to this range from 1 to
244:37 - 10 and it's executing the code inside
244:41 - the curly braces 10 times and when it
244:44 - reaches 10 it stops and it executes the
244:47 - next line of code below here that
244:49 - because here we don't have any line of
244:50 - code our
244:53 - program X is exited and is finished so
244:57 - this is our discussion about for Loop
244:59 - there are other Loops which can Loop
245:03 - which can loop as long as a certain
245:05 - condition is true not as long as a
245:09 - certain number is reached so we're going
245:12 - to look at the next Loops in the next
245:15 - video
245:16 - see you next
245:18 - all right now it's time to look at the
245:20 - next two Loops that you can use in
245:21 - quadrant and those are the while and the
245:23 - Dual Loop
245:24 - but first let's open our previous
245:26 - project called Loops because I'm going
245:28 - to type my code there so open your
245:30 - previous project and here I already have
245:33 - deleted the code that we had previously
245:34 - here but if you have the code delete it
245:38 - and let's start our discussion about the
245:40 - while loop
245:41 - so first I'm going to type
245:44 - while
245:46 - this is this is how you declare the
245:48 - while loop
245:49 - and here you can press enter to fill in
245:52 - the the wallykid on the parenthesis for
245:55 - you or you can type manually the while
245:57 - and the parenthesis so I'm going to
245:58 - press enter to fill that for you fill in
246:00 - that for me
246:02 - and next you put a space and you put
246:04 - curly brace here so I'm going to put the
246:06 - left curly brace and press enter and the
246:08 - radical base is going to be added
246:09 - automatically as you can see on the line
246:11 - five now
246:14 - a while loop Loops as long as a certain
246:17 - condition is true in contrast to the for
246:20 - Loop which Loops for a specific number
246:23 - of time while a loop Loops as long as a
246:26 - condition or an expression is true so
246:29 - this gives us more flexibility in a
246:34 - circumstances or you don't know for what
246:38 - specific number of times we want our
246:40 - code to be repeated so
246:43 - we put our condition inside the
246:45 - parenthesis here
246:47 - and as long as this condition is true
246:49 - the code inside the current base is
246:51 - going to be executed repeatedly so let's
246:54 - see how we can do that so first let's
246:56 - discard a variable here
246:58 - I'm going to call it number and I'm
247:00 - going to sign a value of 0 to it
247:02 - and here I'm gonna type while number
247:05 - is less than 10
247:09 - inside the calibration I'm going to type
247:11 - the println function
247:14 - and we're going to Output the value of
247:17 - our number and then we're going to
247:19 - increment the value of a number so I'm
247:21 - going to put number I'm going to use the
247:23 - increment operator plus plus
247:26 - let's put a space here to have things
247:28 - more clear now if you run this code
247:37 - you're going to see the numbers from 0
247:39 - to 9.
247:41 - so what is happening how this works
247:44 - first
247:45 - with the color variable with a sine of
247:47 - value of 0 to it next we Loop using the
247:50 - while loop and first the while loop is
247:53 - checking to see if this condition inside
247:54 - the parenthesis is true so it checks to
247:57 - see if the value of our variable number
247:59 - is less than 10 and it's true because we
248:01 - have zero then it executes the code
248:03 - inside the curly braces and it outputs
248:07 - the value of our number in the console
248:09 - using the printerland function then it
248:12 - increments the value of our number
248:14 - and then it Loops again but now the
248:16 - value of our number is one so now it
248:19 - will compare again if
248:21 - the value for number is less than 10
248:24 - which is true it will loop again it will
248:26 - output its value it will increment this
248:28 - value so now we have two and so on until
248:30 - it reaches nine when it reaches 9 it
248:33 - will increment the value it will it will
248:36 - print it will output the value in the
248:37 - console it will increment this value
248:40 - then it will check again to see if this
248:42 - condition is true but now the value is
248:44 - going to be
248:45 - 10 because not it was incremented when
248:48 - it was nine
248:49 - and this condition is going to be ever
248:51 - it's going to evaluate to false and the
248:53 - code inside the cutter base is not going
248:55 - to be executed this way we don't have 10
248:57 - here and it executes the code that comes
249:00 - below of our while loop but because you
249:01 - don't have any code
249:03 - the program is terminated
249:06 - and you can write this thing in one
249:08 - single line but it's recommended to use
249:11 - this form only if you know that you have
249:14 - one single statement in our Loop so if I
249:18 - can delete this
249:21 - this tool
249:24 - and I can put here directly number plus
249:27 - plus and because this Returns the value
249:31 - it increments the value and it Returns
249:33 - the values and expression I can
249:36 - I can run this code and it will have the
249:38 - same output
249:41 - but if I delete the increment operator
249:43 - out after the
249:46 - variable and if I put it before
249:50 - now I'm gonna see a different output
249:52 - here because this increments the value
249:54 - of
249:55 - of our number then it decrements the
249:58 - value of our number and this is called
250:00 - prefix in increment increment so this is
250:04 - called prefix incrementing and the the
250:07 - previous one let's press Ctrl G
250:11 - this is called postfix increment so this
250:14 - is postfix because it's the end of our
250:17 - variable and uh if you put the
250:20 - incremental operator at the beginning of
250:23 - our variable is called prefix oh
250:25 - increment anyway
250:26 - let's press Ctrl Z to have the code that
250:29 - I had previously and the curly braces
250:34 - now look what happens if I delete the
250:36 - increment
250:37 - if I don't increment all variable now
250:39 - now uh let's just talk what is happening
250:43 - because we don't increment the variable
250:45 - and the variable always has the value of
250:48 - zero this will always be true and it
250:50 - will execute the code inside the current
250:51 - places forever so we'll have what is
250:54 - called an infinite Loop so if you run
250:55 - this code
251:01 - now you can see that it prints 0 forever
251:04 - because this condition never ever has to
251:07 - to to false so let's stop this by
251:10 - pressing on this uh
251:12 - Red Square so now the process the
251:16 - program is terminated so this is why you
251:19 - need to increment the value of our
251:20 - number because we want that condition to
251:23 - be false at some point in the in the in
251:27 - the in the future
251:29 - next
251:31 - let's say that I assign here 10.
251:35 - so if I run this code now this condition
251:37 - is going to be false because 10 is not
251:39 - less than 10. and the code inside the
251:41 - curly brace is not going to be executive
251:43 - so now we have no output here because
251:45 - this condition is evaluates to false and
251:47 - is not executing the code inside the
251:49 - calibration but there are certain
251:50 - situations where you'll want to have
251:52 - your code executed at least once even
251:55 - though the initial condition the initial
251:57 - uh condition or there is expression is
251:59 - false so if I delete the curly braces
252:02 - and the code inside the curly braces
252:03 - here
252:05 - now to to do what I said if to execute
252:10 - the the code even though the condition
252:12 - is initially set to false to execute the
252:15 - code at least once you need to use a do
252:17 - while loop and to use a do while loop
252:19 - you put here at do press enter to add
252:21 - the calibrases and we put our while at
252:24 - the end of of our enclosing curly brace
252:27 - of Urdu and here inside the calibration
252:30 - or I'm going to put our printerland
252:32 - function
252:34 - and I'm gonna output the value of our
252:37 - variable number
252:42 - so now if you run this
252:48 - now get 10 because this executes the
252:52 - code inside the curly braces until at
252:54 - least once and after that it comes down
252:58 - here and it checks to see if this
253:00 - condition is true or false and if this
253:02 - condition is true it will repeat the
253:05 - code
253:06 - but if the condition is false it uh it
253:09 - will not repeat the code but the
253:11 - important aspect here is that it will
253:13 - execute the code inside the curly braces
253:16 - at least once irrespective of our
253:19 - condition if the condition is true of
253:22 - order false in our case is false
253:24 - so these are the three Loops that you
253:26 - can use in a kotlin the for Loop the
253:29 - while loop and the do while loop now
253:30 - it's time to see how we can use the
253:33 - continue and the break keywords with
253:36 - those Loops so let's press Ctrl Z to
253:39 - undo the code have the while loop back
253:42 - because I'm going to start the while
253:44 - loop and to see how we can use the but
253:46 - you can continue cured with the while
253:48 - loop
253:50 - let's bring this up a little bit
253:53 - so let's first look at the continue
253:55 - keyword and the continue keyword can be
253:57 - used to bypass a section of code so
254:00 - let's say that I want to skip the number
254:03 - seven in our Loop so I can type here if
254:08 - our variable number
254:10 - equals 2 so 2 equals seven let's put
254:14 - curly braces press enter toward the
254:16 - right calibrase continue
254:19 - so now what this is gonna do is when it
254:22 - is gonna reach the number seven and this
254:25 - condition is going to be true it's gonna
254:26 - call continue and it's going to bypass
254:28 - the code that comes below of our if
254:30 - statement so if you run this code
254:34 - look uh what happens
254:39 - it happens nothing because uh here our
254:43 - number has a value of 10 so this
254:45 - condition is false so the code is not
254:46 - executed so let's put here zero
254:49 - now if you run this code
254:56 - so we get 0 1 2 3 4 5 and 6 but uh
255:01 - and you see that I save at seven it uh
255:03 - it skips the code but why I don't have
255:05 - the next numbers this is because uh
255:08 - unintentionally we created here an
255:10 - infinite look so let's stop this and uh
255:12 - to explain
255:15 - so what happens here is that because
255:18 - um we said we say here explicit to
255:20 - you to check here explicit we check here
255:23 - to see if our number is equal to seven
255:25 - then we're gonna continue and in other
255:26 - words you're gonna skip the code which
255:28 - comes below of our
255:30 - of order is the then statement then this
255:34 - code is never called so this code is
255:37 - never called the printerland and more
255:39 - importantly the increment operator is
255:42 - now never called on our number variable
255:45 - and because of that
255:47 - because our variable is not incremented
255:49 - here either when it's gonna loop again
255:51 - it will have again the value 7. so this
255:56 - condition or the in the if is going to
255:59 - evaluate again to true and it's going to
256:02 - call continue again and because this
256:04 - code again is never reached Discord and
256:07 - the values no not not incremented it
256:10 - will still have the value seven so this
256:13 - is gonna evaluate again to true so it
256:15 - does this forever and to change that we
256:18 - need to put our
256:20 - number
256:22 - and which is incremented before our reef
256:25 - and that is going to solve the problem
256:27 - so now if I
256:29 - Let's uh
256:32 - now
256:37 - if I run the code let's increase this
256:51 - now get one two three four five
256:53 - and seven is skipped then 8 9 and 10.
256:58 - because now when this condition level is
257:00 - to true it will continue it's not going
257:02 - to print the code it's not going to be
257:04 - executed below of our if and it will
257:07 - come back to Loop and now it's going to
257:10 - increment the value and the value is
257:11 - going to be
257:12 - 8 instead of 7 this is going to evaluate
257:15 - to false and the continue is not going
257:17 - to be called it will print the number
257:19 - eight and it will do the same for it it
257:22 - will increment the value again and then
257:24 - we'll have 9 and so on so this is how
257:27 - you can use the continue keyword and you
257:29 - have to be careful where you put your in
257:31 - uh your whatever incremental variable
257:34 - because I you saw you can easily get
257:36 - intro infinite Loop
257:38 - now you can have a more complex
257:40 - expression here so you can put here if
257:43 - number is greater than let's say 2 and
257:48 - number
257:49 - is less than eight
257:52 - now if you run this
257:54 - look what happens
257:57 - now get one two and then we get 8 9 and
258:00 - 10 because what this condition now
258:03 - checks is is if our number is greater
258:07 - than 10 and less than 8 then continue
258:10 - then skip that number so this is why the
258:13 - numbers between 2 and 8 are skipped
258:16 - because we call continue on on them and
258:20 - if you hover over here you see that it
258:22 - says the two comparison should be
258:24 - converted to a rain check so you can
258:26 - write the same condition that have here
258:28 - using a range but this is different from
258:32 - a range that you you've used in a for
258:35 - Loop in the sense that this is now
258:37 - checking to see if our number is in the
258:40 - range 3
258:42 - from 3 to 7 so if you run the squad
258:50 - now I have the exact same output but now
258:52 - we are using the range to check to see
258:56 - if our number is in the other engine if
258:58 - this is the underage we call continue to
259:01 - skip that
259:02 - um
259:03 - the next thing that you can do is you
259:05 - can
259:06 - break the loop you can stop the loop
259:09 - using the break here so I can say here
259:12 - again if number
259:14 - equals equals let's say seven
259:16 - call break
259:18 - so I'm going to type here break
259:20 - now when this condition is going to vary
259:22 - to true it's gonna call break and the
259:25 - loop is going to stop it's not going to
259:26 - execute any line of code after that it's
259:28 - gonna stop it's gonna leave and it's
259:30 - going to execute the code which comes
259:31 - below here but in our case we don't
259:33 - don't have any code
259:35 - so you see that we have one two three
259:37 - four five and six and when it reaches
259:40 - seven it breaks and it nuts is stopping
259:44 - the loop it's not printing the value and
259:46 - it executes the loop so it terminates so
259:49 - foreign
259:53 - and we can do the same thing with the
259:55 - for Loop so we can use the four we can
259:57 - use the continue and
259:59 - and break with a for Loop so you can
260:01 - type here four
260:03 - let's say I in let's create the
260:07 - let's say
260:09 - zero
260:12 - to 10 let's create this range
260:16 - let's add the curly braces
260:18 - now I can say here if
260:23 - I
260:28 - in
260:29 - let's say three
260:32 - to eight
260:37 - then continue
260:40 - let's put in the volume
260:42 - let's type here println
260:46 - let's print the value of I here
260:51 - so now if you run this code
261:01 - so we have our first Loop which Loops a
261:05 - to six and then it breaks because you
261:08 - call break there then it's using the for
261:11 - Loop it Loops it loops
261:14 - from 0 to 10 but because here we're
261:18 - checking to see if our number is in the
261:21 - range three to eight and skip it you get
261:24 - 0 1 2 and then the numbers uh the three
261:29 - and uh the numbers between the three and
261:33 - the numbers between 3 and 8 inclusive
261:35 - are skipped here so we have 0 1 2 and
261:40 - then the numbers between two and nine
261:42 - are skipped and we have nine and ten
261:45 - and we can use also the brake keyword
261:48 - with the four I can put here if I equals
261:50 - equals seven
261:56 - break
261:57 - [Music]
261:59 - so now if you run this code
262:06 - now you get 0 1 2 3 4 5 6 and when it
262:09 - reaches seven it breaks similar to our
262:12 - while loop so this is how you can use
262:15 - the break and continue cured with the
262:17 - while and for Loop and you can use the
262:21 - brake and continue cured also with the
262:23 - Dual Loop
262:25 - next we're gonna look at how you can
262:27 - Nest Loops within each others and we're
262:29 - going to look at an example using the
262:30 - while loop so I'm going to delete the
262:32 - code of the for Loop and the printable
262:34 - statement there
262:35 - I'm going to delete the if then
262:37 - statement the break yard and I'm going
262:39 - to bring the printerland function up
262:41 - there
262:43 - down here I'm going to declare a
262:44 - variable it's going to be a VAR I'm
262:46 - going to call it I and I'm gonna assign
262:48 - a value of 0 to it now in inside the
262:51 - while loop I'm going to type another
262:53 - while loop here I'm going to put a
262:55 - conditional while I is less than 5
262:59 - we're gonna increment I and we're gonna
263:02 - print and output the value of I in the
263:04 - console but let's put some text here to
263:07 - make uh clear what Loops what Loop is
263:11 - looping so I'm going to put three
263:13 - asterisk signs here
263:15 - I'm gonna type the dollar sign and I
263:20 - so now if you run this code let's also
263:23 - change this condition too
263:24 - less than five
263:28 - so if you run this code
263:39 - now we get first you get one then we get
263:42 - our code inside of our inner while loop
263:46 - which is the three asterisks and get one
263:49 - two three four five then it Loops again
263:51 - but let's take this chord line by line
263:54 - to explain what is happening here
263:56 - so first decade is variable call number
263:58 - assign a value of zero to it then we
264:00 - Loop using the while loop the outer loop
264:02 - and it checks to see this condition
264:04 - issue and is true zero is less than five
264:06 - so it executes the code inside the curly
264:09 - braces and it increments the value of a
264:12 - number by one then it outputs the value
264:14 - of our number in the console so you get
264:16 - here one
264:17 - then it declared this variable called I
264:19 - and then it starts looping inside our
264:23 - outer loop while using the inner loop
264:25 - while so it Loops here five times
264:28 - so when it finishes it goes back
264:31 - and now the value was incremented by one
264:34 - it will check again if the condition is
264:35 - true it will uh execute the code inside
264:39 - the calibration to increment the value
264:40 - now so the it will have two it will
264:44 - output that value so now we have two
264:46 - here
264:47 - and then it will loop again five star
264:50 - five times using the inner loop and it
264:53 - will do the same thing for the next
264:55 - round and the next round until you get
264:57 - to
264:58 - 5. when
265:00 - we'll get to five five will be not be
265:03 - less than five and this condition will
265:05 - evaluate to to false and the code inside
265:07 - the caliber is not going to be executed
265:10 - right
265:12 - and you can use the break keyword inside
265:15 - the inner loop so I can say here if
265:19 - you can put it above here so you can say
265:21 - if
265:23 - I equals equals zero
265:28 - then break and now you can put the break
265:30 - and continue cures in one single line if
265:32 - you want you can avoid the curly braces
265:36 - so now if you run this code
265:46 - now get one two three four five because
265:49 - now uh when it reaches the inner loop it
265:53 - breaks immediately what every at every
265:56 - iteration in the outer loop so when it
266:00 - comes down here it will check to see if
266:02 - the conditions through is going to be
266:03 - true but when it gets to the if
266:05 - statement it will break it will stop the
266:07 - loop so it will execute only the Outer
266:11 - Loop
266:12 - and with a break keyword you can
266:15 - not not Target only the loop so with
266:19 - with this break keyword we stop you stop
266:21 - only this while loop that uh
266:25 - that we are currently that is currently
266:29 - the nearest Loop but there is something
266:31 - which which is called labels and with
266:33 - labels you can Target an outer loop so
266:35 - it can break the outer loop here so you
266:38 - can break the while loop which is here
266:40 - and to do that we we give to our while
266:43 - loop a label so we type here a name I'm
266:46 - going to call it outer and we put at
266:50 - now here you can put break and now I'm
266:54 - gonna type
266:55 - add
266:57 - and you put outer and this this should
267:00 - be a single word
267:01 - now if you run this look what happens
267:11 - now get one because it breaks the outer
267:14 - loop so it first evolves this condition
267:16 - it increments the value of our number it
267:19 - prints the value of a number and then it
267:22 - goes in the Inner Loop it checks to see
267:24 - if this condition is true it's true then
267:26 - it's checked to see if I is equal to 0
267:28 - which is uh true then it breaks but now
267:31 - it's not breaking this Loop this inner
267:34 - loop
267:35 - it's breaking the Outer Loop so it's
267:38 - breaking this Loop so this is why you
267:40 - get only one and the code is not
267:42 - executed because it breaks the outer
267:43 - loop and the code our program or code
267:47 - it's terminated because about down here
267:50 - we don't have any code so this is how
267:52 - you can use labels with the break
267:54 - keyboard to Target an outer loop and the
267:57 - labels can be used also with the
267:59 - continue keyword and in other Loops that
268:03 - we've looked at so this is our
268:05 - discussion about loops what you can do I
268:08 - should say is that you cannot Target
268:09 - with the labels and inner loop from an
268:12 - outer loop so you cannot
268:15 - we can give here a name to a label to
268:17 - our inner loop but you cannot Target our
268:19 - inner from our outer loop so this is our
268:22 - discussion about loops and the next
268:25 - video we're going to do a challenge
268:27 - all right so now it's time to do a
268:29 - challenge using all the knowledge that
268:31 - we have accumulated so far and I'm gonna
268:33 - use the previous project to put my code
268:35 - there but if you don't have the previous
268:37 - project you can create a new project and
268:39 - give it whatever name you want and type
268:41 - your code there so I'm going to open my
268:43 - previous project
268:44 - I'm going to delete the code inside the
268:47 - main function
268:49 - now what is the challenge
268:53 - the challenge is to
268:55 - create an arbitrary range of numbers
268:57 - then we need to find a way to go to that
269:00 - arbitrary range of numbers
269:02 - and to determine if a number is an even
269:06 - number or if a number is another number
269:09 - and based on that if the number is an
269:12 - odd number skip that number
269:14 - but if the number is an even number then
269:16 - output a number in the console
269:18 - additionally should create a way to
269:21 - count all the even numbers that you
269:24 - found in your range and display the
269:27 - total number so if neither numbers
269:30 - um at the end of your program
269:32 - so try to do this solution and after
269:35 - that you can watch my solution to this
269:39 - so first I'm going to decide I'm going
269:40 - to declare a variable call number
269:43 - I'm going to assign a value of 1 to it
269:46 - next I'm going to declare another
269:47 - variable but this is going to be a Val
269:49 - it's going to be called last number
269:51 - and it's going to have a value of 20.
269:54 - now I'm gonna Loop using the while loop
269:57 - and in the parantes you're going to type
269:59 - while number
270:00 - is less than equal to last number
270:04 - then you're going to put curly braces
270:06 - now I'm going to increment our number
270:11 - now here you need to add the logic to
270:13 - determine if a number is an even number
270:15 - or not and to do that I'm going to add
270:16 - the function at the end of our enclosing
270:19 - curly brace of our many functions so I'm
270:21 - going to type here the fun keyword
270:24 - now you need to give a name to our
270:25 - function it's going to be called is even
270:30 - number
270:32 - I'm gonna put parenthesis and it's going
270:34 - to take a parameter called number of
270:36 - type int
270:37 - this function and it's gonna return a
270:40 - Boolean value true or false this
270:42 - function so you put colon and we type
270:45 - Boolean then you put curly braces and
270:48 - now we'll add the logic to determine if
270:49 - any number is even or not so you type
270:51 - here if
270:54 - and now inside the parenthesis we put
270:56 - another set of parentheses
270:59 - and here we refer our parameter number
271:01 - that we have defined above and here we
271:04 - put the modulus operator because the
271:07 - modulus operator gives us the reminder
271:09 - of a division so we put a modulus
271:11 - operator 2.
271:13 - now outside our inner parenthesis we put
271:16 - equals equals zero then we put curly
271:20 - braces
271:21 - and return true
271:25 - else we're gonna return
271:30 - false now how this logic works
271:33 - so
271:34 - our num our number parameter which is
271:38 - defined here it's going to take an
271:39 - argument let's say that it's going to
271:41 - take an arbitrary number
271:44 - then he's gonna check to see if that
271:46 - number divided by 2 has no reminder if
271:49 - it's and if it has no reminder then that
271:51 - number is an even number because the
271:53 - because even numbers when they are
271:55 - divided by two they have no reminder
271:58 - and if that is the case if the reminder
272:01 - equals equals to zero our number is an
272:04 - even number and it's gonna return true
272:06 - and their spot is not going to be
272:07 - executed
272:08 - now let's add the logic here
272:12 - list user function here because as you
272:15 - can see now it's uh gray out it's not
272:17 - used so let's type here if
272:20 - and in the parenthesis you're gonna type
272:22 - is even number our functions we're going
272:24 - to call our function here and we're
272:26 - going to pass a parameter to it called
272:29 - now I'm going to pass the parameter
272:33 - we're going to pass an argument and the
272:35 - argument is going to be the variable
272:36 - that we Define above as you can see you
272:38 - have the V there so press enter to fill
272:41 - on that for you let's press Ctrl alt L
272:43 - to format the code
272:45 - now
272:47 - if we press shift Ctrl p on this you're
272:49 - going to see that this is a Boolean
272:51 - expression because this returns true or
272:53 - false so we can put the logical not
272:55 - operator in front of it to change its
272:57 - value to switch his value from True to
272:59 - false and from and from false to true
273:02 - so let's put curly braces
273:05 - and here we're gonna call our continue
273:07 - quick keyword down here I'm gonna add
273:11 - a printerland
273:12 - which is going to Output the the number
273:15 - in our console
273:18 - next we need to add the logic to to
273:21 - count the total uh the total even
273:24 - numbers which are found so I'm gonna
273:26 - declare a VAR it's going to be
273:29 - even numbers
273:34 - counter and I'm going to assign a value
273:37 - 0 to it and here we're gonna increment
273:39 - our even numbers counter
273:43 - so now if you run this code
273:52 - we get 2 4 6 8 10 12 14 16 18 and 20. so
273:57 - these are the even numbers that they are
273:59 - that they found that the our program
274:01 - found in is correct but let's add a
274:03 - print line at the end of our Loop to
274:05 - print the total number of numbers of
274:08 - even numbers found so let's put println
274:11 - here and let's put let's refer our even
274:13 - numbers count here
274:18 - you have a numbers counter so if you run
274:20 - this
274:26 - let's put some text actually let's put
274:28 - this in curly braces so let's type here
274:31 - total
274:32 - number of even
274:36 - numbers found
274:39 - equals
274:41 - dollar sign
274:47 - now if you run this
274:55 - now you get total numbers of you know
274:57 - when even numbers found this 10 and this
274:59 - is correct so in an output correctly or
275:03 - even numbers and it show that the total
275:05 - number two newer numbers found this 10.
275:08 - so let's now think about how this logic
275:11 - works here
275:13 - so let's look at the if statement that
275:16 - we have here so what is doing in this
275:18 - thing here so let's take an um an um
275:21 - specific example a specific number to
275:24 - store to see how this works so let's see
275:26 - that here we pass four and it's gonna
275:29 - use the logic to determine if this
275:31 - number is an even number and if that
275:33 - number is any of a number is going to
275:34 - return true so this
275:38 - this function which is a Boolean
275:41 - expression is going to return true and
275:44 - then we're gonna negate this value gonna
275:46 - change this value from True to false and
275:48 - continuously not gonna be called and the
275:52 - code which comes below which is uh our
275:54 - variable which uh counts how many even
275:58 - numbers uh we have then it it increments
276:03 - then it outputs that number in the
276:04 - console so we have our even number four
276:07 - output output it in the console
276:10 - but if you pass here 3 that the number
276:14 - is not going to be an even number
276:16 - because has a reminder and this is going
276:18 - to return uh false and because of here
276:22 - you put the logical not operator that is
276:23 - going to be switched to true
276:25 - and the continue that's going to
276:27 - continue keyword is going to be called
276:29 - and our code Channel which comes below
276:32 - here which is uh our variable even
276:34 - number counter is not going to be
276:36 - incremented
276:37 - and our number respect to our number
276:40 - three now it's not going to be outputted
276:43 - in the console so this is how this works
276:46 - so this is our solution to our
276:50 - to our challenge of course you can
276:52 - simplify this so if you hover over here
276:54 - because you have all of those underlines
276:56 - you can see that says remove redundancy
276:58 - if statement
277:00 - so this can be simplified to this this
277:02 - does the exact same thing it is going to
277:05 - return true if this uh divided by 2 has
277:08 - no reminder otherwise it's going to
277:10 - return false and this can can be
277:12 - simplified even further because if here
277:15 - we have a single expression and we know
277:17 - when we have a single expression we can
277:19 - write our function as a single
277:21 - expression function so I can remove the
277:23 - curly braces here
277:25 - you can remove
277:27 - the bully return type you can remove the
277:30 - return keyword
277:32 - I'm gonna put the equal zero and this
277:34 - now if you run this code
277:37 - this will work
277:40 - the same
277:43 - so we have the same output here
277:46 - now I use the function here because
277:48 - we've talked about functions in our
277:51 - previous videos but you can remove the
277:53 - function completely and add the logic to
277:56 - determine if a new number is even or not
277:59 - directly in the if statement so you can
278:01 - put here
278:03 - if
278:06 - let's put parenthesis our number
278:10 - now we're going to use the modulus
278:12 - operator tool
278:15 - not equal
278:17 - to zero
278:19 - then continue and this will have the
278:21 - same effect so if you run this code
278:23 - this will work in the same way
278:27 - so we have the same code here because
278:30 - this does the exact that the function
278:33 - did previously it will check to see if
278:34 - this is a new number if this is any of a
278:37 - number
278:38 - the
278:39 - this is not going to be true because
278:41 - hero checking to see if this is not
278:43 - equal to zero and our number is equal to
278:47 - zero so this condition inside the
278:48 - parenthesis is going to be false the
278:51 - continue is not going to be called and
278:53 - the our code below is going to be called
278:55 - our even number counter is going to be
278:57 - incremented and our number is going to
278:59 - be output in the console so this does
279:02 - the same thing as previously
279:04 - and we can do this challenge also in the
279:06 - first of the four Loop if you want
279:10 - so you can type here four
279:13 - I in one
279:16 - to 20 then execute the code inside the
279:19 - curly braces and here you can
279:25 - check if
279:30 - parenthesis again if I present
279:35 - 2 not equal to
279:40 - zero
279:42 - then call continue
279:44 - then
279:46 - else is gonna execute the code which
279:49 - comes below here
279:52 - which is let's first
279:56 - assign a value for your to a even number
279:59 - counter to zero
280:01 - because where when we're gonna enter in
280:03 - the for Loop we should have a zero to
280:07 - not have the previous value which was
280:09 - 20.
280:10 - so let's put 0 here and here you can
280:12 - increment or even number counter
280:16 - plus plus and we're gonna print our even
280:20 - number so I'm going to print I here
280:23 - so if you run this code
280:25 - let's run it from here
280:33 - but let's add the printerland to make
280:35 - things more clear so I'm going to add
280:37 - here print
280:44 - let's put
280:46 - quotation marks and here I'm gonna type
280:50 - total
280:52 - number
280:57 - phone
281:01 - using four
281:04 - Loop
281:07 - r
281:12 - let's put the dollar sign now let's
281:14 - refer our even number variable
281:16 - now if you run this
281:24 - now I have the exact same output but now
281:27 - we're using the
281:28 - first you're using the while loop then
281:31 - you're using the photo clip so let's
281:33 - let's add the printerline statement
281:34 - between our
281:37 - Loops to make clear which Loop is
281:39 - looping so let's draw the print line
281:40 - here
281:42 - and let's type here
281:45 - now
281:47 - we
281:52 - so we are
281:55 - looping
281:57 - using the
282:01 - four
282:02 - Loop so now if you run this
282:05 - to make more clear which Loop is looping
282:12 - so now as you can see first the while
282:14 - loop Loops then we have our printerland
282:18 - which
282:19 - says that now our while loop our for
282:22 - Loop starts looping then we loop with
282:24 - the for Loop
282:25 - then at the end
282:29 - we output the total number total number
282:31 - of even only fever numbers found with
282:33 - the while loop we have 10 then we output
282:37 - the total number found the total number
282:40 - of even numbers found using the for Loop
282:42 - and r10 so our code works perfectly well
282:46 - and
282:48 - uh this do not does not represent the
282:51 - the best
282:56 - the best way to solve this challenge of
282:58 - course that you can
283:00 - find a totally different way a better
283:03 - way to solve this so
283:05 - this was my this was just my way of
283:08 - solving the problem
283:09 - so see you in the next video and how I
283:12 - hope that you enjoy this challenge so
283:14 - now it's time to start a discussion
283:15 - about the race but first let's create a
283:17 - new project I'm going to call it a race
283:20 - for the language select kotlin for the
283:22 - build system IntelliJ make sure to have
283:24 - the jdk selected and check this little
283:26 - box at sample code to have the main
283:29 - function Auto generator for us and click
283:31 - on create
283:34 - all right now let's delete the code
283:36 - inside the calibrases of the main
283:37 - function
283:41 - let's hide the project Pane and let's
283:43 - start our discussion about arrays and so
283:46 - far in our videos we've only looked at
283:47 - how we can store only one single value
283:49 - in a variable and that is very useful
283:52 - but what if you have a large amount of
283:56 - values that you want to store in our
283:58 - variables let's say that you want to
283:59 - store
284:01 - 30 or 40 different
284:03 - values in our variable of a certain type
284:06 - of course that you can declare a
284:08 - variable for each of one of those
284:11 - values then and then assign it to the
284:14 - variables but what happens if you have a
284:16 - 1000 or 10 20
284:19 - 000
284:19 - values in that case uh it will not be
284:22 - practically possible to write each one
284:25 - of those variables and then assign a
284:26 - value to it in a colon help us here
284:30 - because it provides us arrays and an
284:33 - array allows us to store more than one
284:36 - single element in a variable name so it
284:39 - allows us to store more more elements in
284:42 - one single variable name
284:44 - now to declare an array we type Val
284:49 - hero type
284:51 - names
284:52 - next we need to provide the type and the
284:54 - type is going to be an array
284:57 - and IntelliJ is giving us some
285:00 - suggestion there so press enter to fill
285:01 - it in that for you and now we put angle
285:04 - brackets and inside the angle brackets
285:06 - we're going to put what kind of data
285:07 - this array is going to store so it's
285:09 - going to store string or text or
285:12 - sequence of characters
285:14 - then you put equals and here we don't
285:17 - type political value here we have a hero
285:19 - type of function call and here we type
285:21 - array of
285:24 - and now we put our elements inside the
285:27 - the parenthesis of the function called
285:31 - separated by comma so I'm going to put
285:33 - three names here so I'm going to put
285:35 - John
285:37 - Steven
285:39 - and Megan
285:41 - now let's uh let's see what we have here
285:44 - so first we have the Val keyword next we
285:46 - have a name for our variable and the
285:49 - name is names then we have the type and
285:52 - the type is an array which means that
285:55 - you can store multiple values in our
285:57 - variable and next we have angle brackets
285:59 - and string and this means that this area
286:01 - is going to store text or a sequence of
286:05 - characters it's gonna store only strings
286:07 - and then you put equals we have the
286:09 - function called array of and then we put
286:11 - our elements of type string which is
286:14 - those names separated by comma but
286:17 - because cotton has Type inference here
286:20 - you can delete the type
286:22 - and the type is going to be inferred in
286:25 - the same way it was it was inferred
286:26 - previously when I when you just declare
286:29 - a simple variable so now the type is
286:31 - still inferred as an array of strings
286:32 - and now it's a good moment to introduce
286:36 - type hints but we need to activate the
286:39 - typings from settings and to do that you
286:42 - can go to file
286:44 - and click on settings or you can press
286:46 - the the shortcut that you have here for
286:49 - our particular system and for Windows is
286:52 - Ctrl alt s so I'm going to press Ctrl
286:54 - this
286:57 - and here we go to if you have something
287:00 - like this you go to editor click on this
287:02 - greater arrow in front of editor
287:04 - and then you go down here where it says
287:07 - what it says inline hints click on on
287:10 - this Creator are in front of inline
287:12 - hints and from
287:14 - those options select kotlin
287:16 - and here you go to types and select
287:18 - select local variable types then click
287:22 - apply
287:25 - and okay
287:27 - now what you have here on the right of
287:29 - our variable name is a hint so it's not
287:33 - real text this is just there to remind
287:35 - us what kind of type this variable has
287:38 - and in our case is an array of string
287:40 - and my suggestion for this to keep those
287:43 - scenes activated because in this way
287:44 - you'll always see what type of variable
287:47 - is without explicitly declaring the type
287:50 - so this is not uh this is this is just
287:53 - there to help us to remind us what kind
287:56 - of type a variable is
287:58 - now let's say that I want to Output a
288:01 - certain element in the array in the
288:02 - console
288:03 - to do that we cannot just type here
288:05 - println and pass names because you need
288:08 - more to be more specific than that we
288:10 - cannot pass the array here and to get a
288:14 - specific element in the array you need
288:16 - to know that the elements in the array
288:18 - are stored at indexes and the index of
288:22 - an array always starts at zero so the
288:26 - first element is stored at the index 0
288:28 - and to get the first element we tab we
288:30 - type here
288:31 - square brackets and you put 0 and that
288:35 - if you press Ctrl
288:37 - if you press shift Ctrl p on it
288:40 - it's a string because that is going to
288:43 - return as the first value in the array
288:45 - which is uh John so if you run this code
288:49 - we get John but let's put some text here
288:52 - to make it more
288:53 - clear that this is the first element so
288:55 - let's type first
288:57 - element now let's choose the dollar sign
288:59 - because this now is a placeholder and
289:03 - let's put the curly braces around our
289:07 - our element
289:10 - and the quotation mark here now if you
289:13 - run this code
289:18 - you get first element John let's put
289:20 - here some
289:25 - so get the first element John because uh
289:27 - John is stored at the index 0. and in
289:31 - the same way
289:32 - John is stored at the index 0 Steven is
289:36 - stored at the index one and Megan is
289:38 - stored at the index two so our index
289:41 - starts at zero the index of an array
289:44 - always starts at zero and you can
289:47 - replace
289:48 - a specific in an element in the array
289:51 - also using the index operator so you can
289:54 - type here
289:56 - names again
289:58 - square brackets zero
290:01 - equals so now I'm going to assign a new
290:03 - value to our element stored at index 0
290:06 - which is now put here
290:08 - the value
290:10 - Alex so now if you run this code
290:18 - now get first elementalics because
290:21 - John was John which is at index 0 was
290:25 - replaced with the value Alex so now we
290:28 - have Alex Steven and Megan but what you
290:32 - can't do is you cannot get an uh element
290:35 - at neither and an index that doesn't
290:38 - exist so we cannot get here let's say an
290:42 - element of the index 4. because if you
290:44 - run this look what happens
290:51 - we get
290:53 - an error which says array index out of
290:56 - bond extension index 4 out of bonds
290:59 - bonds for length 3. that is because the
291:01 - index 4 doesn't exist and here we try to
291:05 - access that value and that value at that
291:08 - value and that index doesn't exist and
291:10 - this is called the runtime error because
291:13 - this error is is called only one while
291:18 - our app is still running so you don't
291:21 - have here an error like we have for uh
291:24 - here we don't have a compile error which
291:27 - you saw in our previous videos that is
291:30 - because
291:32 - the size of an array is not known we
291:35 - tell our compile time also it's very
291:37 - important to know here that the size of
291:40 - an array is fixed so this will always
291:43 - have the size three and uh the only way
291:47 - to add new elements to it is to put the
291:50 - elements directly here but there is not
291:52 - another way to let's say that I want I
291:55 - can put another element in the array
291:57 - down here we can only replace elements
292:00 - and then in the next videos you're gonna
292:03 - see that there are other arrays
292:06 - which are more flexible in the sense
292:08 - that they can grow and Shrink we can add
292:10 - the or remove elements from those arrays
292:15 - but for now uh we're gonna look just at
292:18 - the for this array
292:20 - so let's change this back to zero to
292:21 - don't have that error
292:23 - and um
292:24 - to avoid this kind of Errors you can
292:27 - check to see what is the size of the
292:29 - array in other words to see what is the
292:31 - number of elements stored in Array using
292:34 - the size variable so let's do that so
292:36 - I'm going to add the printer lens
292:38 - statement below for first one so I'm
292:39 - going to type here println
292:45 - and here I'm going to put the text the
292:46 - size of the array is
292:48 - and here I'm going to put the dollar
292:49 - sign curly braces now I'm going to use
292:52 - our names array
292:54 - and you're going to put that
292:57 - size
292:58 - and this is gonna give us the size of
293:00 - the array or or it's going to give us
293:03 - the another words the number of elements
293:05 - which are stored in this particular
293:07 - array so if you run this code
293:10 - you're going to see first output the
293:12 - first element is Alex
293:13 - and then you're going to see the size of
293:15 - the array is 3.
293:19 - so we get first element Alex and the
293:22 - size of the array is three and this is
293:24 - very important to note that the size of
293:26 - the array is always one times greater
293:30 - than the last index in the array so we
293:32 - have an array which starts as index 0
293:35 - and and ends at index two
293:38 - which has a size of three so very
293:41 - important to remember this to avoid the
293:44 - crashes and your programming and of
293:47 - course that you can put other data types
293:49 - in our array so I can declare another
293:51 - array here also Val
293:53 - called
293:55 - numbers
293:58 - and we can use the array of again
294:01 - and here I can pass some numbers
294:06 - and now you see the type is an array of
294:08 - Fint or an array of integers or whole
294:11 - numbers and you can also mix types here
294:14 - so you can put here
294:16 - numbers and strings
294:20 - so now we have another and this which is
294:23 - between our angle brackets you don't
294:25 - know you don't need to understand this
294:26 - for now but this allows us to have array
294:29 - of two types respectively of type int
294:32 - and of type string and you can post also
294:35 - a chart here if you want
294:39 - let's say a so we can create an array of
294:42 - any type if you want
294:44 - so this allows us to
294:47 - to put to mix our types in in the array
294:52 - and because we've looked at loops and
294:54 - how you can use loops
294:56 - you can use Loops to Loop to this array
294:59 - so I can put here
295:01 - let's say that I want to use the first
295:03 - array so I can put here four
295:07 - name
295:09 - in names now I'm going to refer our
295:11 - array of strings
295:16 - then
295:19 - print
295:20 - print A lender name
295:24 - so now you see that we have this type
295:26 - hint for our name variable that we have
295:29 - here of course this can have whatever
295:31 - name you want now if you run this you're
295:33 - gonna see our three names outputted down
295:36 - here in the console
295:41 - so now we have Alex Stefan Steven and
295:44 - Megan because uh now you're we're using
295:48 - the for Loop to Loop through our array
295:53 - names
295:54 - and uh
295:56 - this is interesting but what if you want
295:58 - to Loop through our array numbers which
296:00 - is a mixed array we have numbers and
296:03 - strings and charts we can refer it here
296:11 - let's call it
296:14 - I
296:15 - in
296:21 - and now you see the type that was
296:24 - inferred for the eye is this comparable
296:26 - that we have here
296:28 - so this
296:30 - is going to Loop through our mixed array
296:32 - so we put here I
296:33 - now if you run this
296:35 - you're gonna see our
296:38 - numbers and in our name one and our
296:40 - chart output down here
296:45 - so now we get
296:48 - first element Alex which is a
296:49 - printerland statement then the next
296:51 - print line statement the size of the red
296:53 - then you have our
296:55 - numbers in our numbers array
296:58 - and then we have our name one and our
297:00 - and then we have our chart
297:02 - so this allows us to to Loop through our
297:04 - mix arrays but what if I want to
297:07 - to Output
297:09 - only if I want to Output in the console
297:12 - only the integers in this mixed are
297:15 - equal numbers to to do that and this is
297:18 - a
297:19 - good good
297:21 - way to introduce this keyword and with
297:25 - this keyword we can check to see if
297:28 - a literal or a variable is supposed
297:31 - certain type so I can put here if
297:36 - I
297:38 - is let's say an INT
297:41 - then and only then I'm gonna output this
297:43 - value in the console then I'm going to
297:45 - call our printerland and I'm gonna post
297:47 - our password I variable to our println
297:50 - function
297:51 - now if you run this you gonna you
297:54 - gonna see in our Loop only
297:57 - the numbers here only the integers
298:00 - because
298:01 - this is keyword is checking to see if
298:05 - our right is of type integer and this is
298:07 - going to return true or false in our
298:10 - case it's going to return true for our
298:11 - for all of our numbers that we have here
298:13 - so we have four five six seven and four
298:15 - again
298:16 - and you can check to see if this is a HR
298:20 - I'm gonna see in the console only our
298:25 - single element a I'll put it down here
298:32 - so we have a or you can check to see if
298:34 - this is a string
298:37 - this element that We're looping at this
298:40 - particular iteration let's say so if you
298:42 - run this you're gonna see in the console
298:44 - only name one because only name one is
298:47 - of type string
298:50 - so I get name one so this is very
298:53 - important to know that with the is
298:55 - keyword you can check to see if a
298:57 - variable or a literally is of a certain
298:59 - type or if it's not and based on that
299:02 - too to just to do some
299:06 - in our case you output that value in the
299:09 - console if that condition is true
299:12 - so this is how you can use the is
299:14 - keyword and the for Loop to
299:17 - to the for Loop to Loop through our
299:19 - array and these keyword to check to see
299:22 - if an element in our arrays of a certain
299:25 - type or if it's not and let's change our
299:29 - array numbers to a different name
299:31 - because numbers is very specific it
299:33 - implies that we only have numbers in
299:35 - this array
299:36 - but we have a mixed type so we have
299:41 - multiple types in uh our array don't
299:43 - have only numbers
299:45 - and to do that instead of changing our
299:47 - numbers array and everywhere in our code
299:50 - where you're using the this variable we
299:53 - can right click on it
299:55 - go to refactor and click on rename or
299:58 - you can click shift F6
300:03 - now if I change the name of our array
300:06 - numbers it will be change everywhere
300:08 - where you call this variable so look if
300:11 - I delete now the name the name is also
300:14 - changed in our line of Code 9 we're
300:17 - using in the loop so now if I change
300:20 - this to let's call it mixed
300:27 - elements
300:31 - if I press enter now this will be also
300:34 - changed everywhere or we call our our
300:37 - variable respectively on the line 9 here
300:41 - so now we have our our
300:44 - array numbers change to mixed Elements
300:47 - which is more uh descriptive because it
300:50 - implies that we have an array of mixed
300:52 - elements
300:53 - so now it's time to do a challenge using
300:55 - the knowledge that we have about arrays
300:57 - but first of all I'm going to delete the
300:58 - code inside the curry base of the main
301:00 - function because I have the previous
301:02 - project opened
301:04 - now the challenge is to create a
301:07 - function which is going to take as an
301:08 - argument an array of integers then you
301:12 - need to figure out a way to determine
301:15 - which number is the biggest number in
301:17 - that array then we need to return that
301:20 - number to the function
301:23 - and you need to create another function
301:25 - which is going to do the same thing but
301:27 - it's gonna figure out what is the
301:29 - minimum number stored in that array and
301:32 - then it's going to return that value
301:34 - and third you need to find a way to
301:36 - combine those two function in just one
301:39 - function which is gonna
301:40 - return the maximum value stored in that
301:43 - array if you want or if you don't want
301:46 - it to return the minimum value so try to
301:50 - solve this Challenge and then watch my
301:53 - solution
301:54 - now let's solve this challenge
301:57 - so first I'm going to create a function
301:59 - which is going to be called the find
302:01 - marks this function is going to return
302:03 - the maximum value
302:05 - and it's going to take us and I'm going
302:07 - to Define here parameter and an array so
302:10 - here I'm going to type a name for our
302:13 - array is going to be called numbers
302:15 - n is going to have the type array
302:20 - of int of integers and it's going to
302:24 - return an integer
302:36 - now here I'm going to declare a variable
302:38 - it's going to be a VAR and it's going to
302:40 - be called Max
302:44 - and in this Max variable I'm going to
302:46 - store the first value in the which is uh
302:50 - which is past which is in the which is
302:52 - in the array so I'm gonna type here
302:54 - numbers
302:56 - square brackets
302:58 - and I'm going to use the index 0 to get
303:00 - the first value in the array then
303:04 - I'm gonna Loop through this array
303:06 - so
303:08 - for number in numbers
303:19 - then here you're going to check to see
303:20 - if our
303:23 - number
303:26 - is greater than our first value which
303:29 - was stored in the array or max value and
303:31 - if that is true then I'm gonna store
303:34 - this value which is now
303:36 - greater than our than our maximum value
303:39 - in our Max variable so here I'm going to
303:42 - put Max now it's going to be equal to
303:44 - this number which is found to be greater
303:46 - than our previous max value
303:49 - and at the end of this loop we're gonna
303:51 - return
303:52 - the maximum value
303:56 - and we're going to do the same for the
303:58 - finding the minimum value so I'm going
304:00 - to copy this code
304:05 - and this is going to be called find mean
304:13 - but uh here gonna change a little bit
304:15 - the logic let's call this variable mean
304:24 - and you're going to change the condition
304:25 - to less than min
304:28 - [Music]
304:44 - now let's call those function in our
304:46 - main function and let's pass summaries
304:48 - to see how it works
304:51 - so first I'm going to declare a variable
304:54 - it's going to be a Val and it's going to
304:55 - be called Max
304:58 - and now I'm going to call our find Max
305:01 - function and here I'm going to pass an
305:03 - array and I'm gonna I'm gonna pass the
305:05 - array directly here so I'm going to type
305:07 - array off and I'm going to pass some
305:09 - arbitrary numbers like
305:18 - then I'm going to create another valve
305:20 - this is going to be called mean
305:23 - now I'm going to call find
305:25 - Min and here I'm going to also
305:29 - call our array of function and here I'm
305:31 - going to Define some
305:34 - arbitrary numbers again
305:44 - now I'm going to Output those value in
305:46 - the consoles so I'm going to add
305:48 - printerland here
305:55 - I'm going to type max value is dollar
305:57 - sign
305:58 - and I'm going to refer our Max variable
306:00 - defined above
306:06 - another println
306:19 - now let's run this code it's
306:32 - get max value 7 which is correct this is
306:36 - the biggest number then we get the
306:38 - minimum value is 4 and this is also
306:40 - correct so our code Works uh perfectly
306:44 - well now the next thing is to combine
306:46 - those two functions that we have here
306:49 - let's
306:51 - increase this now we need to find a way
306:54 - to combine those function in one single
306:56 - function which is going to also return
306:58 - the maximum and minimum value but only
307:00 - if I want to return to be returned so I
307:04 - can determine if I want the minimum
307:06 - value to be returned by that function or
307:09 - if I want the maximum value to be
307:11 - returned by that function so I need to
307:13 - find a way to combine those two
307:18 - and to do that I'm going to delete our
307:20 - second function
307:27 - I'm gonna delete the code inside the
307:29 - this function
307:32 - and I'm going to change the name of this
307:34 - function to
307:36 - find mean and Max and now here I'm going
307:41 - to define a parameter which is going to
307:43 - be a Boolean uh which is going to have a
307:46 - Boolean type so I'm gonna call it
307:49 - I'm going to call it search
307:54 - Max
307:56 - and it's going to be
308:01 - a Boolean
308:03 - all right
308:06 - now
308:08 - based on that Boolean value if is true
308:11 - if I want to search the maximum value
308:14 - here I'm going to type an if statement
308:16 - so I'm going to put if search marks then
308:19 - I'm gonna
308:21 - add here the code to search for the
308:24 - maximum value the first let's define um
308:26 - a variable here is going to be also VAR
308:29 - let's be called gonna be called
308:31 - Max and uh it's also going to have the
308:36 - first value in the array
308:39 - which is also adding the zero now if our
308:42 - search marks is true then we want our
308:45 - maximum value to be search and return so
308:48 - I'm gonna add here to the code to to do
308:51 - that so I'm going to type here a for
308:52 - Loop
308:54 - which is going to go through our numbers
308:56 - array
309:05 - and here I'm gonna add the
309:07 - the if statement which I'm gonna check
309:09 - to see if our number
309:11 - is greater than our Max then I'm gonna
309:13 - assign our
309:17 - our
309:18 - number Tower Max
309:22 - now I'm gonna go down here and and here
309:26 - I'm going to add the else part so if
309:27 - this uh
309:29 - argument which is passed to our
309:31 - parameter search Max is false so I don't
309:34 - want to search for the maximum value
309:36 - then that means that I want to search
309:38 - for the minimum value so I'm going to
309:39 - put here else now I'm going to add the
309:42 - code to search for the minimum value and
309:44 - for this you need to Define also
309:46 - variable here
309:47 - it's going to be called mean and it's
309:49 - going to have the value of Max I'm going
309:52 - to explain a minute how this works
309:54 - now
309:56 - here we're going to gonna also Loop
309:59 - in our
310:03 - numbers draw numbers array
310:07 - and you're going to check if we
310:09 - essentially we have the same code that
310:11 - we have in our find the mean function so
310:14 - here we're going to search if our number
310:17 - is less than our mean
310:20 - then gonna sign
310:23 - our number to our mean
310:33 - also I need to return this value
310:36 - at the end of our Loop so here we need
310:39 - to return
310:40 - Max
310:42 - and here you need to return mean
310:48 - now let's press Ctrl alt L to format the
310:51 - code
310:53 - now let's delete the
310:56 - those the code that you have here
310:59 - let's delete also this code now
311:02 - here now I'm going to put our fine Min
311:05 - and Max function directly in the
311:07 - printerland statement so I'm gonna type
311:09 - here uh or to put in a variable for so
311:12 - let's put in a variable first
311:14 - so I'm gonna
311:16 - Define a variable he's going to be also
311:18 - a map it's going to be Auto Max and here
311:21 - you're gonna type find
311:23 - Min and Max
311:26 - now here you need to pass an array first
311:28 - so I need to pass
311:30 - we need to call our array off we need to
311:33 - Define some numbers here let's say uh
311:37 - 20
311:41 - 40.
311:43 - 50.
311:48 - now we need to pass
311:50 - an argument to our parameter search maps
311:53 - which is going to be either true or
311:55 - false so first I'm going to pass through
311:57 - here
312:00 - now if we print this value if you output
312:04 - this value in the console
312:07 - let's say that we type here
312:11 - the marks
312:14 - equals to dollar sign I'm going to refer
312:16 - our variable
312:22 - now if you're around the squad
312:28 - we get the maximum value is 100 which is
312:31 - correct now let's duplicate this code
312:32 - that we have here and let's try it for
312:34 - Dominion value
312:40 - let's call it mean
312:45 - and let's add the printerland uh
312:48 - statement down here
312:55 - let's type
312:58 - domain
313:00 - values
313:05 - dollar sign mean
313:10 - now if you run this code
313:13 - and let's pass here to false
313:19 - let's run this code again
313:29 - now get the maximum value is 100 which
313:32 - is correct
313:33 - and the minimum value is 20 and we did
313:36 - this with our find Min and Max function
313:39 - by combining our two previous functions
313:42 - and the our code on the networks okay
313:47 - now it's time to
313:49 - have a discussion about how this code
313:52 - how this code how this solution to my
313:55 - challenge works
313:58 - so now let's see how our logic inside
314:00 - our find Min and Max function works so
314:03 - firstly we declare our function find the
314:05 - minion marks then we declare two
314:07 - parameters which is one is numbers and
314:09 - is of type array of integers so here
314:12 - we're gonna pass only an array of
314:13 - integers
314:14 - and the second parameter is called
314:17 - search marks and it's a Boolean so you
314:19 - can pass here only true or false then
314:21 - we're going to say to the then we say
314:23 - here that this function is going to
314:24 - return a value
314:25 - next on the line 9 we declare a variable
314:29 - which is called Max
314:31 - and we assign using the index operator
314:34 - the first
314:36 - element in the array in our Max so in
314:39 - this case we're sine 20 in our Max
314:42 - variable and then we declare another
314:44 - variable called mean and we assign our
314:47 - marks in our mean but our Max has the
314:50 - value of 20 because we assigned it here
314:52 - so this variable mean is also is also
314:56 - also having the value 20. so both have
314:59 - have the have the value 20 at the start
315:03 - then we check to see if our search marks
315:06 - parameter is true or false and if it's
315:10 - true then I'm gonna execute the If part
315:13 - and if part works in the following way
315:17 - first we Loop using the for Loop through
315:20 - our numbers array
315:22 - then we check at each iteration if our
315:26 - number let's say if 20 is greater than
315:29 - our Max so if 20 is greater than 20
315:31 - which is going to be false so the code
315:33 - inside the calibration if it's not going
315:35 - to be executed
315:37 - then go for the next iteration so here
315:40 - now we're gonna see it gonna check to
315:42 - see if our number respectively 40 is
315:45 - greater than our Max which is 20. and
315:48 - this is going to be true and because of
315:50 - that the code inside the calibration is
315:52 - going to be executed so now we're going
315:54 - to assign to our marks which is now is
315:56 - 20. our number which is 40. so now our
315:59 - Max variable has a value of 40. and
316:02 - we're going to we're going to do the
316:03 - setting for the next for the 50. so this
316:05 - condition is also going to be true so
316:06 - we're going to assign it to our Max 50
316:08 - and so on and so on
316:09 - until it reaches 100 which is uh which
316:13 - is going to be also true this condition
316:15 - is going to repeat true and I'm going to
316:16 - be assigning
316:18 - 100 to our Max
316:20 - value of course that if we had another
316:25 - number here let's say two is going to
316:27 - Loop for that number also and this
316:29 - condition is going to be false for that
316:30 - because our number two is not going to
316:32 - be greater than Max and it's going to
316:34 - exit it's going to exit the loop it's
316:36 - going to tell it's terminate and it's
316:38 - gonna return the maximum value which is
316:40 - 100 like we saw in our
316:43 - output in our console and at this point
316:46 - when we return our max value the
316:49 - function is left so it's not executing
316:52 - any line of code
316:55 - besides our
316:57 - return Max is not going to execute the
317:01 - subsequent code which comes below but if
317:04 - our search marks is false it's going to
317:06 - execute the else part so in this case
317:08 - it's gonna search
317:09 - for the minimum value so here we have
317:12 - the same for Loop we search you go
317:14 - through the
317:15 - through all the numbers but here not
317:18 - checking to see if our number is greater
317:20 - then marks you're checking to see if our
317:23 - number is less than our minimum number
317:26 - so you check to see if our let's say uh
317:29 - let's say let's take 20 30 40
317:32 - is less than our minimum value which is
317:34 - 20. and that is going to be false so
317:36 - this code is not going to be going to be
317:38 - executed inside the calibration of the
317:40 - if and it's gonna loop again and now
317:42 - it's gonna check for the fourth and
317:44 - that's also going to be gonna be
317:47 - um
317:48 - false so and so on so and so on until it
317:51 - reaches 100 which is also going to be
317:53 - false the loop is going to execute and
317:55 - it's going to return 20. of course that
317:57 - if we put here two
318:01 - let's say now the minimum value is going
318:03 - to be 2 because it's going to Loop for
318:06 - another iteration and now one is going
318:08 - to compare C4 number
318:10 - respectively two
318:12 - is less than our mean which our mean
318:14 - previously was 20 that is going to be
318:16 - true and it's going to assign our 2 to
318:19 - our mean so if you run this code now
318:22 - now you're going to see that the minimum
318:23 - value is not 20 but it's but it's two
318:26 - and after that we return this value to
318:28 - the function which is called
318:32 - so now get the minion values 2 which is
318:34 - correct so this is how this uh code
318:36 - works
318:38 - and see you in the next video so now
318:42 - it's time to start a discussion about
318:43 - object orientated programming and
318:45 - particularly in this video we're gonna
318:46 - look at classes and objects but first
318:49 - i'm going to create a new project
318:51 - I'm going to call it op
318:53 - for the language select Catalin and for
318:55 - the build system IntelliJ make sure to
318:57 - have the jdk selected and also I'm gonna
318:59 - check this little box because this ad
319:03 - sample code is going to add the main
319:04 - function and that code for us
319:07 - so I'm going to click on create to
319:08 - create the project
319:13 - now I'm going to delete this code
319:18 - and I'm going to hide the project pane
319:21 - now what is object oriented programming
319:23 - object orientated programming is a way
319:26 - of writing code in a sense in the way
319:30 - you think about the real world so in the
319:32 - real world we have objects
319:35 - which can interact with it with each
319:38 - other and which can do stuff but the
319:40 - objects in the real world
319:43 - have two major characteristics first is
319:46 - the state so another the state of an
319:49 - object in real life is represented let's
319:52 - say that we think about of a car
319:55 - the state is represented by the color of
319:57 - that car by the number
319:59 - of Gears that car has by uh by the brand
320:03 - name of that car so this is the state of
320:06 - a car the next thing that real life
320:08 - objects have is functionality
320:10 - so objects can do stuff so let's take
320:13 - again the example of a car
320:15 - a car can move a car can stop a car can
320:18 - switch gears so
320:21 - objects in real life have this uh though
320:24 - this those two characteristics is those
320:27 - two major character characteristics
320:28 - represented by the state and the
320:32 - functionality and the aim of object
320:35 - orientative programming is to construct
320:38 - objects using code in the way they are
320:43 - they in the way they are in the real
320:45 - life
320:46 - but uh to do that let's say that you
320:49 - want to build an object an actual object
320:51 - in real life what you first need to do
320:53 - the first thing that you need to do you
320:55 - need to create a template or a
320:57 - construction plan for creating that
321:00 - object in which you're gonna Define the
321:02 - generic things that a car has
321:05 - and in programming you will do the same
321:09 - thing but instead of using a piece of
321:11 - paper or uh or a something
321:16 - on on your PC to draw that that template
321:20 - in programming you're going to use a
321:22 - class so the class is used to create the
321:25 - template which then is going to be used
321:28 - to create an actual object an object
321:30 - which is going to have a specific State
321:33 - and a specific functionality
321:36 - so um
321:37 - in a way you can think that
321:41 - the real world serves here as a model
321:44 - for us to write code
321:46 - and in this way in by combining uh the
321:51 - state and the functionality in one
321:52 - entity and have an object and as you can
321:56 - see you can also have
321:58 - like in the real life objects
322:00 - communicating with each other you're
322:02 - gonna see that this is really powerful
322:03 - because you can you can model your code
322:08 - in a more dynamic in a more you know
322:11 - more create creative way so this is what
322:14 - we're gonna do next so first let's say
322:17 - that I want to create an object of type
322:20 - car
322:21 - and to do that we go down here and we
322:25 - need to Define as I said the
322:27 - construction plan the template for
322:29 - building an object and in this case
322:31 - we're going to build the car object so
322:33 - we're going to Define what is called a
322:35 - class and type the keyword class
322:39 - now we need to name our class I'm going
322:41 - to call it car and the name of the of
322:43 - the
322:44 - class should start with the capital
322:46 - letter and if it has multiple words it
322:47 - should be in Pascal case
322:49 - curly braces
322:51 - and press enter now inside the color
322:53 - braces we need to define the state and
322:56 - the functionality as I said for the
322:59 - objects that are going to be built with
323:01 - this template
323:02 - and to do that we need to use variables
323:06 - first for the state or
323:09 - or in the context of object orientated
323:11 - programming and more specifically in the
323:12 - context of
323:14 - classes they are called the classes and
323:17 - objects they are called properties
323:19 - and we Define them like we Define a
323:22 - simple variable we Type R and the next
323:24 - the first thing that that a car has is a
323:28 - name or brand name so we're gonna type
323:29 - name
323:30 - but we cannot keep this variable
323:32 - uninitialized we need to provide the
323:34 - value to it and I'm going to put an
323:35 - empty string
323:37 - for uh for now so it's gonna have the
323:39 - default value an empty string
323:42 - the next thing is the model what kind of
323:44 - model this car is so it's going to be
323:47 - also a string I'm gonna assign an empty
323:49 - string
323:50 - the next property is going to be called
323:52 - the color it's going to be also an empty
323:55 - string
323:57 - and the next property is going to be
323:58 - called doors so this is going to store
323:59 - the number of doors that a specific
324:02 - object which is going to be built with
324:03 - this template is going to have and we're
324:05 - gonna put zero I'm gonna put zero now
324:08 - we need to Define some functionality for
324:11 - this class and for the objects for an
324:14 - implicit for the objects that are going
324:15 - to be built with this class
324:17 - and um I'm gonna add two functions first
324:21 - one is going to be called move
324:27 - it's not going to take any parameters
324:29 - it's gonna just output some text to the
324:31 - console which is going to say that the
324:33 - car is moving so we put quotation marks
324:36 - the card is moving
324:39 - now I'm gonna Define another function
324:42 - call stop
324:47 - also it's not going to take any
324:49 - parameters it's gonna just outpost on
324:52 - this the console it's gonna it's gonna
324:53 - say that the car has stopped
325:00 - now
325:02 - we have the template we defined what our
325:06 - car is gonna
325:08 - have now we need to create an actual or
325:13 - object an actual and specific object
325:16 - using this template and to do that to
325:18 - firstly declare a variable
325:20 - and it's going to be a Val and I'm going
325:23 - to call it car one so so our object is
325:25 - going to be stored in this variable car
325:27 - one
325:28 - then you put equals and we type car and
325:32 - now we have some suggestions and we have
325:34 - our car that we Define below our car
325:38 - class so we press enter then we put
325:40 - parenthesis
325:42 - so now we have created an actual object
325:46 - a real object real in the programming
325:48 - sense
325:49 - and
325:52 - which but now this actual object was
325:55 - also this is called the instantiation
325:58 - because we created an actual instance
326:01 - but we don't need to bother with these
326:03 - names for now
326:05 - so we created an actual object using
326:08 - this template that we have below but the
326:11 - the properties of these specific objects
326:14 - are those properties that we Define here
326:17 - those default properties and to Define
326:20 - some specific profit some specific
326:24 - values to these properties that this car
326:28 - object that created has we need to type
326:31 - car one
326:32 - dot so this is called informally dot
326:35 - notation
326:37 - and now we have some suggestions so we
326:38 - have our properties that we defined for
326:40 - a car
326:42 - and now we type car one dot and we
326:44 - choose the name
326:45 - and now I'm going to assign a value to
326:47 - this name I'm going to be called Tesla
326:49 - so now our car one
326:53 - object that was created has the property
326:57 - name
326:58 - Tesla now we do the same thing for the
327:01 - next property for the model car one dot
327:04 - model
327:08 - press enter
327:11 - and you put we put here s blade so the
327:15 - model
327:16 - next we also type car one
327:19 - Dot now we're gonna assign a value to
327:23 - the property caller
327:24 - it's going to be red
327:27 - next we type also car one and we Define
327:31 - for the property names for the property
327:36 - doors also value so we're gonna put here
327:39 - four
327:41 - so now our object R1
327:43 - has for its property for for its
327:47 - properties some specific values
327:49 - respectively have for the name Tesla for
327:51 - the model as played for the car for the
327:53 - color red and for the doors 4.
327:56 - so now let's output the property values
327:59 - of this object that we created in the
328:01 - console and to do that we put our
328:03 - println function down here we put
328:05 - quotation marks inside the parenthesis
328:07 - because I'm gonna add some text here so
328:09 - I'm going to type name
328:12 - equals we put dollar sign then input
328:16 - curly braces and inside the calibration
328:17 - type
328:18 - car one dot
328:21 - name
328:22 - and this is going to return the
328:25 - the value of the property name for the
328:28 - car one object that we created
328:30 - respectively is going to return Tesla
328:32 - let's press Ctrl d three times to do the
328:35 - same thing for the next properties and
328:36 - here we put car one dot model so this is
328:40 - gonna return the
328:41 - value of the model property
328:45 - you're gonna put color
328:47 - and here
328:49 - I'm gonna type doors
328:52 - now if you run this code
328:58 - we get name Tesla
329:01 - actually let's change the text here to
329:05 - model to match the property name
329:09 - model
329:13 - color
329:16 - endorse
329:22 - so now if you're on this
329:26 - we get the name Tesla Model is played
329:28 - color red and doors 4 and those are the
329:32 - values of the properties of this object
329:36 - that we created here with our
329:38 - template car
329:41 - next what you can also do because in the
329:43 - class we Define the two function we can
329:46 - call those functions on this object that
329:49 - we created
329:50 - and to do that we also use the dot
329:53 - notation we type car one
329:55 - dot move and this is going to call the
329:58 - move function
330:00 - which is inside the car one
330:03 - object
330:04 - let's also
330:06 - type car one dot stop to call the store
330:09 - function so now if you run this code
330:12 - we get uh
330:14 - the values of our to our properties and
330:16 - then we get the car is moving and the
330:19 - car has stopped so the car one dot move
330:21 - and car one the stop is calling the
330:23 - functions
330:25 - on this object that we created here now
330:29 - let's uh
330:31 - also add inside the functions
330:34 - the name of the card that is moving so
330:38 - he to do that with here dollar sign
330:40 - inside the class
330:42 - and we type name
330:44 - and this is gonna reference this
330:47 - property name that is defined here
330:51 - let's also do the same thing for the
330:53 - stop function let's type name
330:56 - and now what this is gonna do because
330:58 - those functions are in they are they're
331:02 - living inside this object that we
331:04 - created here car one and this object has
331:07 - the name Tesla when those functions are
331:11 - going to be called
331:12 - they they gonna they're gonna say that
331:15 - the car
331:17 - and the name of the car which is in our
331:20 - case for our objectives Tesla is moving
331:23 - and then it's gonna say
331:25 - the car again Tesla has stopped because
331:28 - they are calling this uh specific object
331:31 - that we created which has uh those
331:35 - specific values for its properties
331:38 - all right so now if you run this quad
331:43 - we get as expected the car Tesla is
331:46 - moving and the car Tesla has stopped so
331:48 - the functions are called on this object
331:51 - that we Define here and it's using the
331:54 - property values that we Define for this
331:55 - object
331:56 - but as I said with uh you can create as
332:00 - many objects as you want using the same
332:03 - template and let's do that let's create
332:05 - another object so I'm going to type here
332:07 - Val
332:08 - Car Tool
332:10 - let's put equals we type car and then we
332:13 - put parenthesis
332:15 - and this create is now another object
332:17 - but we need to Define some values to its
332:19 - properties because now the values for
332:21 - the properties are the default values
332:23 - that we Define inside the class
332:24 - respectively the empty string and the
332:26 - zero
332:28 - and to do that we type here car2
332:31 - dot name
332:33 - so now we are calling the properties
332:36 - for the car 2 object and now we Define
332:39 - some values to the cut to the properties
332:41 - of the car 2 object so they are
332:44 - this here is not overending
332:46 - the value that we have here because
332:48 - this
332:50 - thing that we have here it's a distinct
332:52 - object in memory uh from this object
332:55 - they are this thing distinct objects and
332:57 - they have their own properties with
332:59 - their own values and their own functions
333:01 - and now let's put here Ford
333:07 - let's put the car to that model
333:13 - let's put Mustang
333:17 - let's put
333:19 - car to that
333:22 - color
333:25 - blue
333:27 - and for the doors let's put two
333:30 - car two that doors
333:32 - equals to two and let's output those
333:36 - values in the console so let's output
333:39 - the values of the properties for this
333:41 - second object that we created in the
333:43 - console and to that to do that I'm going
333:46 - to copy this code
333:48 - I'm gonna paste the paste it below here
333:51 - and now I'm just gonna change
333:53 - the
333:56 - the variable to car two to to call to
334:00 - call the properties on the cartoon
334:01 - object so we put here car2
334:09 - so now we're calling the properties
334:11 - values on our car to object
334:15 - and now if
334:16 - I run this code
334:20 - now we get name Ford Model Mustang color
334:24 - blue endorseful and the first part is
334:26 - from the our SEC for from our first
334:28 - object which is named Tesla Model let's
334:30 - play The Red Doors 4 and the Carter
334:32 - slice movie and the cards has stopped
334:34 - but let's add a space here
334:37 - to make a clear uh to make a clear which
334:40 - to make uh clear that this is the output
334:44 - for the second object to make things
334:46 - more clear and to add the space we put
334:48 - here a printerland
334:52 - statement we put quotation marks and we
334:55 - put a backslash
334:59 - n and this is going to add a space
335:00 - between our println statements so it's
335:03 - going to add a space between those
335:05 - statements and we uh and those so now if
335:09 - you run this code
335:14 - let's increase this
335:17 - we get the name Tesla so this is our
335:19 - first object model let's play it called
335:20 - Red Doors 4 The Carter size moving
335:22 - because we're calling the functions on
335:24 - the first object and the character has
335:27 - stopped and then we get name Ford Model
335:30 - Mustang color blue Doors 2 and we have
335:32 - our space because you put here this
335:34 - backflash and which adds that space for
335:37 - us
335:38 - let's um decrease this
335:42 - and let's also call the functions the
335:45 - move install functions on the second
335:48 - object so I'm going to type here car2
335:49 - that move
335:52 - and card two dot stop
335:56 - so now if you run this
335:58 - let's
335:59 - right click and just click on run
336:02 - main.kt
336:07 - now get
336:09 - our first object which is with this uh
336:13 - value for the value of the value for its
336:16 - properties and then we get the two
336:18 - functions called on our first object and
336:21 - um
336:21 - we get in our second object which is
336:24 - values for its properties and then we
336:25 - get the card for this moving and the car
336:28 - Ford has stopped because now
336:31 - um
336:32 - we're calling the functions on the this
336:34 - second object and this second object has
336:37 - the value for the properties has has
336:39 - different values for its properties so
336:42 - this is why you get the card for this
336:44 - movie and the car four has stopped again
336:46 - they are different
336:48 - objects they are distinct objects
336:51 - created using the same template the same
336:54 - construction plan
336:56 - and
336:58 - I'm gonna end this video now and see you
337:00 - in the next video
337:01 - so in the last video we saw how we can
337:03 - create a class and then how we can
337:05 - Define some properties and some
337:08 - functionality to that class then we use
337:10 - that class to create two objects and
337:13 - then we defined for those objects for
337:15 - the property of those objects some
337:17 - values but the way we we Define values
337:21 - to the properties of the object is to
337:23 - call the the object and then the
337:26 - property of logic and then we assign a
337:27 - value and this is okay but if you have
337:30 - more than than four properties let's say
337:34 - you have 20 or 100 properties that will
337:36 - be very tedious to write each one of
337:38 - them and then assign a value
337:40 - and a better way is to use what is
337:43 - called a Constructor and as the name
337:45 - implied The Constructor is used to
337:46 - construct the object and the Constructor
337:48 - is called at the time when we create a
337:51 - new object so at the time of line we we
337:53 - type this line of code when you finish
337:55 - to type this line of code The
337:57 - Constructor is called immediately so
338:00 - that is the
338:02 - the time where we need to pass the
338:05 - values to our properties and to do that
338:07 - we go down here where we Define our
338:09 - class
338:11 - we put
338:12 - at the at the end of our
338:16 - end of the name of the class we put
338:18 - parenthesis and here we Define some
338:20 - parameters the way we Define parameters
338:21 - for functions
338:23 - and the first one is going to be called
338:24 - name it's going to be a string
338:27 - the second one is going to be model
338:30 - also string
338:35 - the next one
338:37 - color also string
338:40 - and the last one is going to be doors
338:42 - and this is going to be an integer
338:45 - no we need to
338:47 - assign whatever value values pass to
338:50 - those parameters to the properties of
338:52 - the class here and to do that just
338:54 - delete the empty string here and type
338:57 - name
338:59 - and as I'm typing you see that we have
339:01 - name and it has this p and this P stands
339:04 - for prop for a parameter so you're
339:07 - saying do you mean this parameter that
339:09 - we Define up here and then we press
339:12 - enter to fill that for us
339:15 - then put we type here model
339:20 - color
339:22 - and then
339:24 - doors
339:26 - now if you go up here we have some
339:27 - errors because now the the
339:31 - when you create the object the objects
339:33 - is expecting for its Constructor some
339:37 - values so if you hover over here inside
339:39 - the parenthesis it says no value fast
339:42 - for parameter color Doors Model and name
339:45 - so if you and if you look down here you
339:47 - see that it has this public Constructor
339:50 - so now what we need to do is to pass the
339:52 - value that you passed down here to to
339:54 - the properties by calling the
339:57 - calling them on the object is to pass
339:59 - them directly in the Constructor and
340:01 - then the values the arguments if you
340:04 - want are going to be assigned to the
340:05 - properties so I'm going to put here
340:09 - and you have this hint name Tesla
340:13 - then we put a comma
340:17 - so we have the again the hint which is
340:20 - very helpful so for the model we put a
340:23 - splade
340:27 - and then for the color
340:30 - we put red
340:32 - and for the number of doors four
340:36 - all right so now this is more concise
340:39 - and now this is doing the exact thing
340:42 - that we did previously but this is more
340:44 - concise and we're using the Constructor
340:47 - to pass the those values to the
340:51 - parameters that we Define here and then
340:54 - those parameters going to be assigned to
340:55 - the properties respectively with those
340:57 - properties name model core and doors
340:59 - you're gonna see what is the difference
341:01 - between the properties and parameters in
341:05 - uh in the next video now we have also an
341:09 - error here because
341:10 - this also express some values to its
341:13 - Constructor so instead of putting those
341:15 - values here we put up here
341:18 - Ford
341:24 - Mustang
341:29 - blue
341:32 - and
341:34 - two
341:35 - now we can delete this
341:37 - because we already passed the values for
341:40 - this second object for its properties
341:43 - now if you look at the codes the code is
341:45 - more concise and more and easier to read
341:50 - now if you run this code
341:52 - you will have the same output
341:55 - because the code
341:57 - works well
342:02 - so now if you look at the console let's
342:07 - increase this a little bit
342:09 - let's scroll up you have the name Tesla
342:11 - Model let's Place color red doors4 the
342:13 - cartridge lights moving the cut Isla has
342:15 - stopped so you have the same output as
342:17 - previously and down for the second
342:19 - object we have
342:22 - we have a
342:24 - the name Ford the model Mustang the
342:26 - color blue Doors 2 and the Carphone is
342:28 - moving in a car 4 has stopped so our
342:30 - code works well now let's close the
342:34 - console but if you go down here you'll
342:37 - see that you have this um
342:39 - this uh the properties colored so if you
342:41 - hover over them it says the property is
342:43 - excretely assigned to parameter name so
342:45 - it can be declared directly in
342:47 - Constructor
342:48 - now what is saying here in other words
342:51 - is that we can put the properties
342:54 - directly in the Constructor so you don't
342:56 - need to define the properties down here
342:58 - and then assign the value that is passed
343:01 - to the parameter to the property and
343:05 - the difference between the properties
343:07 - and parameters parameters is that the
343:10 - properties respectively those that we
343:12 - Define in the in the header of the class
343:14 - inside the parentheses 0
343:16 - in the Constructor
343:19 - is that
343:20 - the properties are not uh storing the
343:24 - state of of the class they are mastering
343:28 - the state of the object there they are
343:29 - only here to to get whatever value we
343:32 - pass here
343:34 - so whatever value you pass here
343:36 - and his job is to only get that value
343:39 - and assign it to the property name so
343:41 - only the the variables which are
343:44 - declared declared inside the class are
343:47 - storing ultimately the the state of that
343:51 - object so uh if I delete let's say if I
343:54 - delete this here
343:57 - now we have an error here because the
344:01 - property name um it says on our result
344:03 - reference name create member property
344:06 - card.name and that is because the
344:09 - property name is not declared it's not
344:12 - exit it's not it's not a it's not uh
344:16 - it's not a characteristic of a car we
344:20 - didn't Define a property name because
344:23 - here the parameters the parameter name
344:26 - is only there to get the value and then
344:29 - pass the value to the property
344:31 - but we can let's press Ctrl Z to put the
344:36 - code
344:37 - back
344:39 - now the error disappeared because we
344:40 - have the property declared but because
344:43 - the only thing that we do here is to to
344:46 - to get the value that is passed to the
344:48 - property as an argument here and for the
344:51 - next ones and then assign it to the
344:54 - property we can put those directly in
344:57 - the Constructor so to do that we just we
345:00 - can hover over here and
345:04 - let's hover over
345:06 - and click on this light bulb and click
345:09 - move to Constructor so now you have this
345:11 - you have the same
345:13 - the same thing the same thing but the
345:16 - only difference is that we have this VAR
345:18 - keyword in front and that is responsible
345:20 - for changing the
345:23 - changing the parameter into a property
345:26 - so
345:27 - let's do the same thing for the next
345:29 - ones
345:30 - move to Constructor
345:33 - and now we don't have that error that we
345:35 - don't have a property for our class
345:37 - because never because they have the VAR
345:40 - so if you put the VAR or the VAR keyword
345:42 - before declaring the the the parameter
345:46 - it is going to be converted into a
345:48 - property
345:49 - so now those are properties of our class
345:53 - car so they are storing actually they
345:55 - are storing the the value that you pass
345:57 - to to them
346:00 - for the project that we create so uh
346:03 - it's not like previously where you have
346:05 - the property the parameter and then the
346:08 - value is passed to the property inside
346:10 - the class
346:11 - so now if you run this code
346:24 - foreign
346:25 - we have the exact same output
346:27 - the only difference now this that this
346:30 - is uh more concise we have the
346:32 - properties declared the right directly
346:33 - in the Constructor so we don't have
346:35 - declare the parameters and then we
346:37 - assign the value that is passed to those
346:39 - parameters to properties so you can
346:41 - declare the The Constructor like this if
346:44 - you want so the question may arise when
346:46 - to use properties and when to use
346:49 - parameters and to to
346:53 - to answer that question
346:55 - um you have you need to have in mind
346:56 - that if you want to do some if you want
347:00 - to do some work before you assign the
347:01 - value to the property
347:03 - because in our case uh the value that is
347:06 - passed here to the to the
347:09 - property in this case is directly stored
347:12 - in the property so we cannot add some
347:14 - validation to check to see if uh I don't
347:18 - know if this name is if it starts to a
347:21 - specific letter or if it's if it's an
347:24 - uppercase or because the value that is
347:26 - passed
347:27 - that is passed as an argument to the
347:30 - property there I say property because
347:32 - they are there there are no declared as
347:34 - properties it is directly stored as uh
347:38 - as a the state of the object so
347:42 - if you want to to do some work before
347:46 - you assign the value of the property you
347:47 - need to declare it let's say let's say
347:50 - that you want to Let's actually delete
347:52 - this and I'm going to declare it as a
347:56 - parameter so let's say that you want to
348:00 - to to trim the space that is passed so
348:02 - let's say that I put some spaces here
348:09 - let's actually press Ctrl G to see what
348:12 - is happening if I don't do that
348:19 - all right
348:22 - I press Ctrl Z too many times so
348:26 - let's let's again Paul let's put some
348:29 - spaces here so now if you run this code
348:37 - let's run it again
348:44 - [Music]
348:46 - now because the value that is passed
348:51 - as an argument here to the object car
348:53 - one
348:55 - is passed directly to the property so
348:58 - it's stored in the property and we we
349:00 - don't do nothing with it we have also
349:03 - the space but if you want to to delete
349:05 - that space currently we can do that
349:08 - because the values pass directly to the
349:10 - property and there is nothing that we
349:12 - can do from that point
349:14 - and to to change that we can declare the
349:18 - the property that is defined here the
349:21 - property name as a parameter first
349:24 - and we can declare it down here
349:27 - we can declare down here now the
349:29 - property
349:31 - and we can put equals and now we we pass
349:35 - the the
349:38 - parameter to the property so it's a sign
349:41 - name here
349:42 - but before before that value is assigned
349:45 - to the property name we put that
349:48 - stream
349:50 - and that is going to remove the spaces
349:52 - so that Rim is a function which is part
349:54 - of the string class because the the data
349:59 - the all the data size that we looked at
350:01 - are also classes so you can call
350:04 - functions on them the way we called
350:06 - functions so not our on our objects
350:10 - so name that trim removes the space so
350:13 - in this case it removes the space that
350:16 - we have here
350:17 - and after that it's assigning the value
350:21 - to the name property so now if you run
350:24 - this code now now we have the space but
350:26 - if you run the code
350:27 - so let's go up
350:30 - run the code
350:39 - now as you can see the space is removed
350:41 - because
350:42 - we pass the value to the
350:46 - parameter now name then the parameter
350:49 - name trims.space and after that it's
350:52 - assign the value to the property name so
350:54 - in this case so in this can be a
350:57 - scenario where you can uh where you can
351:00 - declare the instead of declaring
351:02 - directly here the property can declare
351:03 - as a parameter but what do what what you
351:07 - can do if you want to add more code than
351:09 - just one line of code in that case we'll
351:11 - need to use what is called the
351:13 - initializer blocks but
351:16 - um we're going to look at the
351:17 - initializer blocks and uh other things
351:20 - in the next video because this video is
351:22 - long enough so see you in the next video
351:25 - so in the last video we looked at
351:28 - Constructors and how you can use
351:30 - Constructors to construct your objects
351:33 - and it was an alternative to defining
351:35 - the values to the properties of the for
351:39 - particular object
351:40 - and we've also looked at how we can
351:43 - Define the this Source I should say it's
351:46 - also called the primary Constructor that
351:48 - we have here the parenthesis and then
351:50 - the parameters or the properties
351:52 - and we've also talked about how we can
351:55 - Define parameters or Constructor and
351:57 - then how we can convert those parameters
352:00 - directly into properties and I've also
352:03 - talked a little bit about how and when
352:06 - to use
352:07 - parameters and properties but in this
352:11 - video we'll continue our discussion
352:12 - about parameters and properties and
352:14 - specifically going to look at how we can
352:17 - execute more than one line of code when
352:20 - the object is created because
352:23 - now when the object is created and we in
352:28 - the last video we trimmed this space
352:29 - that we have here
352:31 - you can execute only this line of course
352:34 - so if you want to add more line of
352:35 - course here to do some
352:38 - um to do a more complex validation we
352:42 - can't because here we can put just one
352:44 - line of code
352:45 - and to add more than one line of code of
352:48 - code they need to use what is called
352:50 - initializer blocks and the initializer
352:53 - blocks are as you'll see some blocks
352:56 - where we can put our code and you can
353:00 - put more than online so forth you can
353:02 - put as many lines of code you want and
353:04 - that code is going to be executed when
353:06 - an object is created on an instance of
353:08 - our car of our of your class is going to
353:12 - be created
353:13 - so um this is what we're gonna do in
353:16 - this video also I should say that you
353:18 - can declare the class in another file
353:20 - not just in this file like we did here
353:23 - so we can open now the project pane
353:26 - you can go to SRC go domain
353:29 - go to kotlin
353:31 - and here on kotlin you can right click
353:36 - select kotlin class file
353:39 - and from here make sure to select file
353:41 - and I'm going to call this file classes
353:43 - because you're going to put our classes
353:45 - respect we're going to put our card
353:47 - class but you can put more classes there
353:50 - and uh
353:52 - we're just going to copy this class that
353:54 - we defined here
353:56 - Ctrl C
353:57 - and paste it here
353:59 - now I have an error because this is
354:01 - declared two times here and here and we
354:05 - just delete it from here
354:07 - and now the arrow disappears
354:10 - and if you run this code
354:18 - we get the same output because our code
354:21 - works
354:23 - perfectly well now the only difference
354:25 - is that now we will put we put our class
354:28 - in a different file and my suggestion is
354:30 - for you is to put the class if you want
354:32 - in a different fly file
354:35 - because in this way you have the code in
354:37 - when I'm going to organize the way
354:39 - because here you have your class here we
354:42 - have the code the objects that we
354:45 - created with that class
354:46 - and so on
354:49 - no
354:50 - for this video I'm gonna use I'm gonna
354:52 - create a different class and
354:55 - to do to do that I'm gonna declare
354:57 - another class but I'm going to declare
354:59 - it down here and I'm going to delete the
355:02 - code that we have here
355:04 - because we're going to use a different
355:05 - class
355:08 - and the class is going to be called user
355:10 - so it's gonna represent the
355:14 - the use and end user object so we type
355:17 - here class
355:18 - user now we create the Constructor the
355:22 - primary Constructor we put parenthesis
355:24 - we Define the parameters or the
355:26 - properties for uh now I'm going to
355:29 - Define directly the properties here so
355:31 - we type here
355:33 - keyword to have the property declared
355:36 - VAR name
355:39 - string so it's going to be we're going
355:41 - to be store stacks
355:43 - VAR
355:47 - last name also string
355:52 - and uh
355:54 - VAR age this is going to be an integer
355:58 - so this with this class we're going to
356:00 - create some user objects I'm going to
356:03 - put curly braces
356:05 - and for now we're not gonna put any code
356:08 - here so let's create a user so let's
356:10 - type here Val
356:13 - or let's call it user you can give it
356:15 - whatever you want
356:17 - so let's create a new object now so we
356:20 - put
356:21 - you type your user and then for the
356:23 - parenthesis because I'm going to put
356:25 - we're going to pass the values to the
356:27 - Constructor here Sony to pass a name I'm
356:29 - gonna type Alex
356:31 - last name
356:33 - no binka
356:36 - and for the age 23
356:40 - so now we created a new instance a new
356:43 - object using the using the cluster to
356:46 - Define below
356:48 - but what if I want to to pass to to the
356:53 - to the name
356:55 - to the name name property only the the
356:57 - names which starts with the letter A
357:02 - in that case we need to declare this
357:04 - property as a parameter first we need to
357:08 - declare here the parameter and then to
357:09 - declare the property below and before
357:13 - before we assign the value that is
357:16 - passed to to the property we need to do
357:18 - some validation and if that argument
357:22 - that is passed to the
357:24 - parameter is starting with the ale
357:28 - letter then you're going to assign the
357:30 - value to the property name otherwise we
357:32 - don't do that so to do that we need to
357:34 - use initializer blocks because we're
357:37 - gonna type more than one line of code
357:40 - and the initializer blocks are used in
357:42 - conjunction with the primary Constructor
357:44 - so when we create a new object like we
357:47 - did here the initializer blocks or the
357:49 - initializer block is going to be called
357:51 - immediately when the object is created
357:54 - and to use an initial initializer block
357:57 - we just but first let's declare let's
358:00 - change this to to a parameter so let's
358:03 - delete the VAR keyword in front of
358:06 - the variable so now we have only a
358:09 - parameter here now let's declare the
358:11 - property down here
358:13 - and now here we need to Define an
358:15 - explicit type declaration so we need to
358:17 - put here the type string because as I
358:20 - said
358:21 - um we're not going to assign the value
358:23 - to the property directly here in one
358:26 - line of code we're going to assign the
358:29 - value to the property inside the
358:31 - initializer blocked after we do the
358:33 - validation respectively after we check
358:36 - to see if the name that is passed to the
358:40 - objects that we're going to create with
358:42 - the class
358:43 - starts with the letter a and if the the
358:46 - name if the argument doesn't start with
358:49 - the letter A then we're going to assign
358:50 - an empty string and we're gonna output
358:52 - something to the console so this is why
358:53 - we need to provide here the type because
358:55 - I'm not gonna
358:57 - assign the value directly here so it
358:59 - cannot infer what kind of data is going
359:02 - to store
359:02 - then you press enter
359:04 - we type init
359:06 - and here we have a suggestion we have
359:08 - the unique keyword and then we have the
359:10 - curly braces press enter
359:12 - and now here we're gonna add our
359:15 - validation and here we type if
359:18 - parenthesis
359:20 - now type name so now we're referring the
359:23 - name parameter defined above here so if
359:26 - name or the value that is passed to the
359:29 - name parameter
359:31 - first we're gonna
359:34 - um
359:34 - lowercase dot name
359:37 - and to do that we type here name dot
359:40 - lowercase because I want to have both
359:43 - cases so if
359:45 - if the user passes let's say a name of
359:48 - the lowercase letter then we're gonna
359:52 - check to see if it starts with OTA but
359:54 - if the user passes the the name of the
359:57 - an uppercase later we also want to check
360:00 - to see if if that letter starts with a
360:03 - and to cover both cases we lowercase the
360:05 - input we lowercase the name so all the
360:08 - lowercase all the letters then we put
360:11 - here another Dot
360:13 - starts with an input here
360:17 - a
360:18 - and if that is true
360:21 - then we're gonna assign whatever value
360:24 - was passed to the name parameter to the
360:25 - name property
360:27 - and we cannot type here name equals name
360:31 - because now it's referring the
360:33 - parameter here and to refer the property
360:36 - that we Define here we need to use what
360:38 - is called the disk keyword so the disk
360:40 - keyword is used to refer them
360:42 - properties of the class so it are here
360:45 - this
360:47 - so we're saying this name so now we have
360:50 - this name and we have a different we
360:52 - have this V variable here
360:54 - then put equals
360:56 - name so now we assign the value that is
360:59 - passed to parameter only if that
361:02 - valuable only if that value pass to the
361:05 - parameter starts with the letter A then
361:07 - we're gonna assign the name to the
361:09 - property name
361:11 - else if that is not true
361:13 - put curly braces
361:15 - and now we need to cover the else part
361:17 - because if this is not true we also need
361:20 - to pass a value to to the name proper
361:22 - the name property cannot stay without a
361:25 - value so we need to pass those over here
361:26 - else we're going to put this
361:28 - dot name
361:30 - and I'm going to put
361:33 - user so I'm going to put the user
361:37 - text if the if the the name doesn't
361:41 - start with the with the letter A
361:43 - and we can also output some text.com so
361:45 - we put println here
361:48 - and we'll type the name
361:51 - doesn't
361:53 - start
361:55 - with
361:57 - the letter
362:01 - a or
362:04 - capital a
362:07 - so now if you create a new object here
362:10 - so we type here Val let's say for friend
362:15 - we create a new object so we type user
362:17 - now we need to pass the values to the
362:19 - Constructor so you put here a let's say
362:22 - uh
362:24 - John
362:29 - let's put
362:30 - Smith
362:32 - let's put
362:34 - 30. now because the the value that you
362:37 - pass here to the parameter name doesn't
362:39 - start with a letter a and start the
362:43 - letter j
362:45 - this value validation inside the
362:47 - initializer block is going to be false
362:50 - and then it's gonna it's gonna execute
362:52 - the else part and it's going to assign
362:53 - to the property name the user text and
362:57 - it's going to Output the name doesn't
362:58 - start with the letter A or a but if that
363:01 - is not uh if but if it's true if it
363:03 - starts with the letter A then this line
363:05 - of code is going to basically the base
363:06 - part n is going to be a sign it's going
363:10 - to assign the value to the property
363:12 - so now if you run the squad
363:21 - we get the name doesn't start with the
363:22 - letter A or a and it's correct our name
363:25 - starts with the letter j
363:26 - so if I put here let's say
363:31 - Andhra
363:35 - let's change this to
363:40 - oh let's see here also
363:43 - Smith
363:46 - now if I run this
363:50 - now we have no output because the this
363:53 - the initializer block is is called
363:56 - and the If part is evalu is to true and
363:59 - it's assigning the the name
364:02 - Andra to our name property so let's add
364:06 - the print and then down here to see that
364:08 - that is correct so print
364:10 - let's print the value of
364:12 - of the property name for our friend
364:14 - object and we put here
364:18 - and here we type
364:21 - dollar sign
364:25 - you put curly braces and you type friend
364:33 - Dot
364:35 - name
364:37 - so now if you run this let's close
364:45 - get name under let's put comma here
364:48 - let's put
364:49 - colon here
364:53 - so our initializer blocked is called the
364:57 - code inside the initializer block this
364:59 - execute it and then this if check
365:02 - average to true and then and then it
365:04 - assigns the name Andra to our property
365:07 - name but if we I put here John
365:17 - let's type it like this let's say to see
365:19 - that it's working because we lowercase
365:21 - the letters
365:28 - okay the name doesn't start with the
365:30 - letter A or a name user so the
365:32 - initializer block is executed
365:34 - immediately when the object is created
365:36 - and
365:38 - the code incidential log is called it
365:42 - checks to see if it starts at the lower
365:43 - it starts with the with the letter A
365:46 - and if not then it is assigned to the
365:49 - property name user so we have this we
365:51 - have user here
365:52 - and then it outputs uh
365:54 - this
365:56 - text to the console so this is how we
365:58 - can use the initializer blocks in
366:00 - conjunction with the primary Constructor
366:02 - and you can also put more initializer
366:05 - blocks and the order in which you put
366:07 - the initializer blocks matters in the
366:10 - sense that the word in which you define
366:13 - the initializer blocked is is going to
366:15 - be the word in which they are executed
366:17 - so the word in which you define them
366:19 - it's important but most of the time I
366:22 - think you'll you use only one
366:24 - initializer block to put your code so
366:28 - this is our discussion about initializer
366:30 - blocks and in the next video we're going
366:32 - to look at um
366:33 - because
366:34 - we talked about the primary Constructors
366:36 - there is a another type of Constructor
366:40 - which is called the secondary
366:42 - Constructor of this secondary
366:44 - Constructors
366:45 - and we can also look at the default
366:48 - parameters because you can put you can
366:51 - we can Define default values to the
366:55 - properties also the parameters of the
366:57 - Constructor so we're gonna do that we're
366:59 - going to do that in the next video
367:02 - I'm gonna end this video a little now
367:04 - so now it's time to start a discussion
367:06 - about secondary Constructors because
367:08 - besides our primary Constructor that we
367:11 - Define and that we talked about in
367:13 - Cotton you can Define multiple
367:15 - Constructors and those are called the
367:18 - secondary Constructors
367:19 - now you may be wondering why you will
367:21 - need secondary Constructors
367:23 - and to answer that question we need to
367:26 - consider the user class and those user
367:30 - objects that you can create so let's say
367:32 - that an user
367:33 - only provides its first name and for the
367:37 - property is last name and the age
367:39 - doesn't provide any value in that case
367:42 - you will need the you need a way to to
367:44 - Define some default values for those
367:46 - properties in case the user only
367:49 - provides the first name
367:51 - and uh
367:53 - if let's say the next user does provide
367:57 - the the first name and the last name and
367:59 - the age in that case you're gonna use uh
368:02 - the the primary Constructor but if it
368:05 - doesn't provide those uh those values
368:07 - then you're gonna use the secondary
368:08 - Constructor but to make this more clear
368:11 - lists uh let's add the code and we talk
368:14 - we talk about was while I am writing the
368:17 - code so let's delete the initializer
368:19 - blocks that we have here because you
368:21 - don't need this code
368:23 - and let's also put the property now
368:25 - let's define the property in the primary
368:27 - Constructor so let's just put here a
368:30 - VAR the work here in front of the
368:32 - variable
368:34 - let's also delete this printalian
368:39 - and um
368:41 - let's delete the values here
368:47 - for the last name and the age so now as
368:49 - you can see we have an error because
368:51 - it's expecting here the
368:53 - um it's expecting an argument a value
368:55 - for the last name and for the age and to
368:59 - solve that problem we just go down here
369:01 - and we type Constructor so this is the
369:05 - keyword for declaring the secondary
369:07 - Constructor
369:10 - and we press enter to fill in that for
369:12 - us and we put parentheses and now here
369:15 - in the parenthesis we Define the
369:17 - parameters and I am specifically saying
369:21 - parameters because as you will see the
369:23 - secondary Constructors cannot declare
369:26 - properties they can only declare
369:28 - parameters because
369:30 - anyway Let's uh so let's define here the
369:33 - parameter so I'm gonna type here name
369:37 - let's put here the type of this variable
369:40 - is going to be a string
369:42 - now if you hover over here
369:45 - it says primary Constructor called
369:47 - aspect insert this call so what all the
369:52 - secondary Constructors need to do is
369:55 - they need to call the primary
369:57 - Constructor because ultimately the
370:00 - primary Constructor is the one which
370:02 - declares the property the properties for
370:04 - the class and stores the values for uh
370:09 - of that Pro of that property and to do
370:13 - that to put here
370:15 - colon
370:17 - we type this
370:20 - so we put colon this type that this
370:23 - keyword then you put parenthesis
370:26 - and
370:27 - to the disc call we pass the name so
370:31 - this name that we defined here
370:34 - and for the next two values we're going
370:37 - to pass some default values so here I'm
370:39 - going to put user because let's say that
370:42 - because as I said in the beginning this
370:45 - user is gonna not it's not gonna provide
370:48 - the last name so let's put your last
370:50 - name not user last
370:53 - name
370:55 - and for the age let's put
370:59 - let's put let's say zero
371:01 - all right now
371:04 - what this is going to do is now if you
371:06 - look up here don't have an error so
371:09 - let's uh so now we don't have that error
371:11 - because now it's using the secondary
371:14 - Constructor is passing the value here
371:17 - Alex to the secondary Constructor that
371:20 - we Define here and here we Define only
371:22 - the parameter and the value that is
371:24 - passed as parameter then
371:27 - is passed to this to the primary
371:30 - Constructor because by putting colon and
371:33 - these and parenthesis we're calling now
371:35 - the primary Constructor
371:37 - and is the primary Constructor the one
371:40 - which
371:41 - ultimately declares the property and
371:43 - stores whatever value we send to him in
371:47 - this case we send
371:48 - the value Alex and for the last name we
371:52 - uh we just send the last the text last
371:56 - name and for the age you put 0 because
371:58 - this is our way to saying that this user
372:02 - doesn't want to provide its age so this
372:05 - is why you need to call the the primary
372:08 - Constructor from the secondary
372:10 - Constructor because again the secondary
372:14 - the primary Constructor is the one which
372:17 - ultimately declares the properties of
372:19 - the classes the one which stores the the
372:22 - the properties of the class the
372:25 - secondary Constructor only
372:28 - only takes parameters and then calls the
372:30 - primary Constructor so in fact if you
372:33 - put here the VAR keyword
372:35 - you have an arrow which says
372:37 - Varon secondary Constructor parameter is
372:40 - not allowed that is because the
372:41 - secondary Constructor cannot call it
372:43 - cannot declare properties
372:45 - only the primary Constructor
372:47 - and because as I said you can declare
372:50 - multiple second Constructors we can type
372:52 - here
372:53 - Constructor so we can declare another
372:55 - secondary Constructor and here you can
372:58 - put
372:58 - name
373:02 - here we put string
373:05 - then we type last name also string so
373:07 - this secondary Constructor is only going
373:09 - to take
373:10 - the
373:12 - name and the last name as arguments the
373:16 - age is not gonna this uh is gonna not
373:20 - gonna take any value for the age now we
373:22 - need to put colon
373:25 - we type this parenthesis because now
373:28 - we're calling the
373:30 - primary Constructor and here we we pass
373:33 - the name that is passed to this
373:35 - secondary Constructor this that we
373:37 - Define here
373:39 - the last name
373:43 - and for the age we're going to put 0
373:45 - because this uh
373:48 - this second secondary Constructor
373:50 - doesn't
373:52 - take any value any arguments for its uh
373:56 - for its age
373:58 - but because as I said ultimately the
374:01 - primary Constructor is the one which
374:03 - defines the properties we cannot we
374:07 - cannot call the prime Constructor and
374:08 - not pass any value so we pass this
374:10 - default value here
374:12 - and uh
374:14 - so now if you go up here and let's say
374:16 - that I delete the age
374:20 - now our code works fine because now what
374:23 - is happening here is this the the value
374:26 - for the
374:28 - for the name and the last name is passed
374:31 - to this secondary Constructor this one
374:34 - here
374:35 - and the secondary Constructor then calls
374:39 - this primary Constructor and it's
374:41 - passing the two values to the Primal
374:43 - structure name respectively this name
374:45 - John and last name Smith and for the age
374:50 - it passes the default volume zero so
374:54 - this is how you can this is why we can
374:56 - pass here uh
374:59 - this this is why you can avoid here to
375:01 - pass let's say uh you can avoid to pass
375:04 - the last name and the age for the first
375:07 - because it is using the first secondary
375:09 - Constructor
375:11 - and this object that we created here
375:13 - it's using this secondary Constructor
375:16 - because here we're passing only the
375:18 - first name for the value for the first
375:21 - name property and the value for the last
375:23 - name property so it's passing them to
375:26 - this secondary Constructor which then in
375:28 - turn calls the primary Constructor it
375:32 - passes them to the primary Constructor
375:33 - so it passes the
375:35 - the values for the two properties and
375:39 - the last one is defaulted because
375:42 - okay because you don't provide the value
375:44 - for the age
375:45 - with Pro with secondary Constructors you
375:47 - can also put you can at the end of the
375:49 - call of the primary consultor you can
375:51 - put curly braces
375:54 - to have some code executed when you
375:56 - create an object with that specific uh
375:58 - secondary Constructor so you can put
376:01 - here curly braces and inside the color
376:03 - blades you can have some code which is
376:06 - going to be executed you want to create
376:07 - an object with this let's say secondary
376:10 - Constructor
376:12 - an object with this secondary
376:13 - Constructor
376:14 - so it's up to you what the code you put
376:17 - there but to illustrate this let's put a
376:19 - println statement here in the
376:24 - in this secondary Constructor so let's
376:25 - type here println and here I'm going to
376:27 - type
376:28 - second and I'm going to type second
376:31 - because uh
376:34 - this is the first Constructor this is
376:36 - the primary Constructor and this is the
376:38 - one which ultimately does all the work
376:41 - is the one which stores the value for uh
376:43 - the properties
376:45 - and this is the third
376:48 - Constructor so let's copy this
376:50 - let's put here to Third
376:55 - just for illustration
376:58 - Also let's output in the console the
377:01 - value of the the property values for
377:06 - these objects so let's type here
377:08 - printerland
377:10 - and just type here name
377:14 - equals let's put dollar sign
377:19 - let's put curly braces
377:22 - let's use our user
377:25 - variable now let's call the properties
377:29 - on this public so let's type name
377:32 - now let's press Ctrl d
377:34 - two times and let's put here now
377:40 - last name
377:42 - and the age
377:45 - and let's also other space between
377:50 - the information about the two objects to
377:52 - make things more clear so let's put the
377:54 - printer and heroes and put a backslash
377:56 - in here
377:59 - and let's copy the code that we have
378:02 - here let's paste it below
378:05 - let's change this
378:08 - object to our friend object that we
378:11 - created just like your friend
378:14 - and I'm gonna speed this now a little
378:16 - bit because
378:18 - it will take some
378:22 - now let's output this information in the
378:24 - console
378:29 - so now what we have is we have
378:32 - we have
378:34 - second and then third because this first
378:37 - object is using the
378:41 - the second Constructor
378:43 - so this is why we have here a
378:45 - second
378:47 - and then the next line of code is called
378:49 - and we have third because this one this
378:52 - object that you have here the front
378:54 - object it's using the third Constructor
378:58 - this secondary Constructor so this I
379:00 - have here third
379:02 - then we have the values for the
379:04 - properties for the I didn't have the
379:06 - values for the properties of the user
379:08 - object so you have
379:10 - here the output
379:12 - down here
379:13 - and
379:15 - then we scroll down and have name John
379:18 - last name Smith age
379:20 - zero because we have a
379:23 - the property values for the second
379:25 - object for this object
379:27 - and this is okay this works completely
379:30 - fine the thing to have in mind is that
379:35 - now we're using the secondary
379:36 - Constructors and the secondary
379:38 - Constructor then calls the primary
379:40 - Constructor and the primary Constructor
379:42 - is the one which ultimately stores the
379:44 - value source which ultimately declares
379:46 - the properties and stored the values
379:49 - but one thing to notice in the output is
379:53 - that the first object has the name
379:56 - Alex and the last name last name and age
380:00 - zero that is because the first object is
380:03 - only
380:04 - taking a value for the first name
380:07 - property or for the name property
380:09 - and for the last name and the age
380:14 - because it's using this secondary
380:16 - Constructor is only passing in the first
380:19 - name which is Alex that we have here
380:21 - and then it's using the default values
380:23 - last name and a zero it's passing those
380:26 - default default values to the primary
380:28 - Constructor so it's calling the primary
380:30 - Constructor is passing the value Alex
380:32 - and then the default value last name and
380:35 - zero this is why I have last name and 0
380:37 - here and for the next one we have
380:40 - name John and last name Smith this is
380:44 - because now this is using um the next
380:47 - secondary Constructor and that takes as
380:51 - arguments the name and the last name and
380:54 - then it's calling the primary
380:55 - Constructor it passes the
380:57 - first name and the last name and the
380:59 - aegi is defaulty so you have zero so
381:01 - this way you have here John and Smith
381:03 - and then zero so it's important to
381:06 - to notice this and to think about how
381:09 - this uh to think about this thing
381:13 - so this is our discussion about multiple
381:15 - Constructors respectively about
381:17 - secondary Constructors in this video you
381:20 - saw how you can
381:21 - pass a different number of values to our
381:27 - properties ultimately you pass all the
381:30 - values to the properties by calling the
381:32 - primary Constructor and providing
381:34 - default values because in this way you
381:37 - can satisfy all the possible cases so if
381:42 - in our case one user only provides the
381:45 - name and the last name is not provided
381:46 - and the age is going to use the this
381:49 - secondary Constructor and it's going to
381:50 - pass the last name as default and the
381:52 - zero and this is uh in a way
381:57 - similar to overloading functions but is
382:00 - not the same because what you're doing
382:03 - here is overloading the constructors and
382:07 - this in this way you can you can think
382:10 - about
382:11 - why why we're overloading the
382:14 - constructors and that is because
382:17 - if we didn't have secondary Constructors
382:20 - we would have to create another class
382:24 - with a different number of parameters
382:27 - or the different number of
382:30 - properties and we will need to to create
382:33 - each object with that specific class
382:37 - let's say that we create this object
382:41 - which only takes a value for its
382:43 - parameter name then we have to create a
382:45 - class which we're going to Define only
382:47 - the name property and it's gonna then
382:50 - we're gonna create that obviously with
382:52 - that class
382:53 - and if an object if an object
382:58 - let's say if an user creates uh if your
383:01 - user doesn't
383:03 - providing the the name and the last name
383:06 - but now the age you have to create
383:08 - another class with only the name and the
383:10 - last name defined as its properties and
383:14 - you can see that this this uh is uh this
383:17 - will generate uh duplicated code and so
383:20 - on and we can solve all of this by using
383:22 - secondary Constructors and
383:25 - calling the
383:27 - primary Constructor so see you on the
383:30 - next video and because quoting is about
383:33 - conciseness in the next video we're
383:35 - going to look at how we can do the same
383:37 - thing that we have here with default
383:39 - parameters because
383:41 - um
383:42 - kotlin supports for its properties for
383:45 - its parameters in the constructed
383:47 - default values so the same thing that we
383:49 - have here can be achieved by providing
383:51 - default values to the properties so see
383:54 - in the next video
383:56 - so now it's time to look at default
383:57 - values for our properties and first
384:00 - let's delete the secondary Constructors
384:07 - and now I have a
384:09 - error series because it expects the
384:12 - value
384:13 - expecting the values for the next
384:15 - properties here
384:16 - and um
384:18 - let's also change this to
384:21 - to first name because I refer to it to
384:23 - the first name but it was called This is
384:26 - it is called name so let's call it first
384:28 - name so go right click on it
384:31 - go to rename and then to refactor
384:34 - to change it in all the places and let's
384:37 - call it
384:39 - first name and as you can see now let's
384:41 - change it in all the place then press
384:42 - enter
384:45 - so now we have the first name and the
384:47 - default properties are default values to
384:51 - our properties are basically they are
384:54 - similar to default values that we
384:55 - provide to our parameters when we talked
384:59 - about functions
385:01 - then what we do is uh
385:04 - let's say that I wanted to provide the
385:06 - default value for the last name we just
385:08 - put equals so inside the primary
385:11 - Constructor we put equals and here we
385:13 - put let's say
385:16 - last name so now this has the last name
385:20 - as a default value if a value is not
385:22 - provided for the last name and here you
385:25 - can put also equals
385:29 - n equals zero and now the error as you
385:32 - can see disappeared from both of our
385:35 - objects because now
385:37 - what is doing is when we don't provide
385:39 - the value for the
385:41 - last name and for the age then the
385:44 - default values that we provide here is
385:46 - going to be are going to be used as the
385:48 - values for the properties so this is a
385:51 - way of achieving the same thing that we
385:54 - achieved previously with the secondary
385:56 - Constructor but this is more concise
385:59 - and the question is when to use one on
386:01 - one or the other is
386:04 - the um the answer may be if you want to
386:06 - execute some code when an object is
386:09 - created let's say
386:11 - with one of the
386:14 - let's say if you wanted to if you want
386:16 - to exit some code when you create an
386:18 - object then you can use secondary
386:20 - Constructor because as I said secondary
386:22 - Constructors can have a block of code
386:24 - when uh which can be executed but the
386:28 - this uh the default because primary
386:31 - Constructor does not don't don't have a
386:33 - don't have a block of code they you
386:36 - cannot do that maybe you could use a
386:38 - initializer blocks
386:40 - but that is uh open to discussion
386:46 - so this is how you can provide the four
386:48 - values to
386:49 - to the primary Constructor
386:52 - in our code was fine it's
386:54 - In This Very concise very beautiful and
386:58 - the next thing that you can do is that
387:00 - you can also use named arguments so you
387:04 - can use the because here you use the
387:06 - first name and the last name and if I um
387:09 - because those are those are both strings
387:13 - here you cannot see the distinction but
387:16 - if I put here uh now I can use the name
387:20 - argument so I can put your first name
387:27 - equals so it's similar to the way we
387:30 - have name arguments in our function and
387:32 - here you can put the text
387:35 - John
387:36 - also here and this uh
387:40 - with this thing you can you can change
387:42 - the order in which you need to define
387:44 - the values for the parameter so let's
387:46 - put your last name
387:49 - but we'll say this better let's create
387:51 - another object
387:53 - is
387:54 - user 2
387:56 - let's type user
388:00 - and let's put here you wanna
388:05 - but let's use the name arrowman so let's
388:08 - put first the age so we're going to
388:11 - provide the value for the age let's say
388:13 - um
388:14 - 19.
388:16 - and um
388:18 - Let's uh let's type first name so here
388:21 - let's put um
388:24 - IWANNA because it's a string
388:28 - quotation marks
388:32 - and for the last name let's say
388:39 - let's type also the name argument last
388:41 - name and for the last name let's put
388:43 - here um
388:45 - Dobby
388:47 - let's say
388:50 - right so what we did here is that
388:54 - in the primary Constructor the order for
388:58 - for the properties very specific we have
389:01 - the first name and the last name and
389:03 - then we have the age but with the name
389:04 - arguments we first provided the age
389:07 - so we provided a value for the age
389:11 - product which is the last one so and
389:13 - then you provide the value for the first
389:15 - name and with the name arguments similar
389:19 - to the way used in our functions you can
389:23 - pass the values to the properties in
389:25 - which order you want irrespective of the
389:27 - word in which they defined here so this
389:30 - is very powerful if you
389:33 - if you ask me it's very interesting
389:36 - because you can pass the values to the
389:39 - properties irrespective of the world in
389:41 - which they are defined
389:43 - so this is our discussion about default
389:46 - parameters and the name argument in
389:51 - with the primary Constructor and you
389:53 - cannot use default parameters name
389:55 - arguments with the secondary
389:57 - Constructors they can only be used the
389:59 - primary Constructor
390:00 - so see you in the next video
390:05 - but uh before I end the video Let's
390:08 - actually run this code to see that it
390:10 - works in the same way it was working in
390:14 - previously when we use the secondary
390:17 - Constructors
390:18 - so let's run this code
390:23 - so you have name Alex last name last
390:26 - name because it's using this default
390:28 - value that defined here then we have h0
390:31 - because it's using this value of defined
390:33 - here so this is
390:34 - this object
390:36 - and then we have name John last name
390:40 - Smith a0 because now it's using this
390:42 - default value so the same thing can be
390:44 - achieved using um
390:46 - default parameters and we didn't
390:49 - output the values for the
390:52 - for the second for the third object that
390:55 - you created here in user 2 but you can
390:58 - do that as a
390:59 - as a challenge for if you want you can
391:03 - output the values for this object so see
391:07 - you in the next video
391:08 - so now it's time to start a discussion
391:10 - about Getters and Setters because so far
391:14 - enough videos even though we didn't see
391:16 - explicitly the Getters and Setters here
391:20 - we've used the Getters and Setters every
391:23 - time we got the value of a property and
391:25 - every time we assign a new value to a
391:28 - property
391:29 - and um
391:31 - the getter and Setter in kotlin are
391:33 - implicit so they they are declared they
391:35 - are Auto auto generated by default by
391:38 - color by cutling for you so every time
391:41 - you and let's say you get the value of
391:44 - an object let's say let's get the value
391:46 - of the user that's first name what
391:48 - actually happens here is not that we're
391:51 - getting the value of the first name
391:53 - directly even though if you look at the
391:55 - code this what it seems to be what has
391:58 - happened is that every time we get the
392:00 - value of of a property that value is
392:04 - returned by the getter so you never
392:06 - access the property directly and you
392:09 - never never does change the the property
392:13 - of uh the value of a property directly
392:16 - you every you every time you you are
392:18 - using the Getters and setters
392:20 - and now this discussion is touching on
392:22 - on a very important Concept in quadrant
392:25 - programming and that is encapsulation so
392:27 - encapsulation basically means to
392:31 - to protect to hide the inner workings of
392:35 - the class from being accessed outside
392:39 - and if you look at this syntax that we
392:41 - have here it seems that we actually
392:43 - accessing the values the properties
392:47 - directly but as I said that is not the
392:49 - case because we're always using the
392:51 - getter and the setter and because we
392:55 - always use use the Getters and the
392:58 - Setters the getter to get the value and
393:00 - the set to to change the value of
393:02 - property
393:03 - that means that your data your
393:07 - properties are never accessed directly
393:10 - thus the laws of encapsulation are not
393:15 - broken the the in other words you you
393:19 - never allow somebody outside of the
393:21 - class to access directly that property
393:24 - so this is why uh
393:26 - this is why we have Getters and Setters
393:29 - and this is why the Getters and Setters
393:32 - in Kathleen are implicit so they are not
393:35 - even declared explicitly here we don't
393:37 - see any
393:38 - code which it will imply that we have a
393:41 - get a Setter here because they are
393:44 - automatically and by default generated
393:46 - every time you define a property so
393:48 - every time you define a property either
393:51 - in the primary Constructor or
393:53 - inside the class the
393:55 - Getters and the get the getter and
393:58 - Setters automatically generated for you
394:01 - but uh let's say that you want to
394:04 - override the getter and Setter to
394:07 - provide some additional
394:10 - additional code to the code that is by
394:12 - the by default provided you can do that
394:14 - by changing let's say
394:16 - this property to a parameter
394:20 - and to override the getter in Setter and
394:22 - to see how the Getters and Setters
394:25 - actually look under the covers
394:27 - just type here VAR
394:30 - we Define the property first name
394:33 - we assign the first name parameter
394:35 - property now the Getters and Setter need
394:38 - to need to be overrated
394:41 - immediately after the with after we
394:44 - Define the property so we cannot have
394:46 - some code here and then to override you
394:48 - can to override the getter and Setter so
394:51 - we need to
394:53 - we need we need to Define them
394:54 - immediately after we we Define the
394:57 - property so we type here get
395:00 - and as an attempting you see that I have
395:03 - some suggestions then you go down here
395:04 - you and you can choose you choose this
395:06 - one
395:07 - so you have parentheses curl braces and
395:10 - inside the curly braces you press enter
395:14 - here you type return
395:17 - field I'm going to explain immediately
395:19 - what is this
395:20 - and now we need to override the setter
395:23 - and to do that to just type set and I
395:25 - have some suggestions
395:27 - we also go down here we choose this one
395:30 - press enter and hero type
395:33 - field again this
395:36 - under this identifier and input equals
395:39 - to value
395:40 - so this is the implicit code that is
395:44 - generated that is auto-generated by
395:46 - kotlin for you every time you you you
395:49 - define a property in your class either
395:51 - in the as I said in the primary sector
395:53 - or inside the class
395:55 - so because in fact if you look here we
395:59 - have some underlines and if you hover
396:00 - over here it says redundant getter
396:02 - remove redundant getter because uh and
396:06 - also for the set it under setup because
396:08 - they are redundant because they are
396:10 - implicitly again Auto generated by
396:13 - cotton for you so this quad is redundant
396:16 - here you don't need this code because
396:17 - Scotland already provides this code
396:19 - under the covers for you but if you're
396:21 - not such satisfied with this quad with
396:24 - this implicit code that is uh Auto
396:26 - generated by cotton can you can um you
396:29 - can override them like we did here and
396:31 - provide some additional code so we can
396:33 - put here let's say some text
396:36 - so so that every time we get the value
396:38 - of our
396:40 - we get the value of our first name
396:43 - property you're gonna have a pretty
396:45 - pretty prefix and let's put here a first
396:47 - name
396:48 - let's put the colon dollar sign
396:51 - and field we're gonna play I'm gonna
396:53 - explain immediately what this field is
396:55 - but let's say first however
396:57 - how this works and here let's put a
397:00 - printerland to print a value that is
397:02 - passed to the setter and then assigned
397:04 - to the first name property so let's put
397:06 - here dollar sign
397:11 - value was
397:13 - assigned
397:15 - to First
397:21 - foreign
397:30 - now I have name so we have our text that
397:33 - we have here name and then have first
397:36 - name Alex let's actually delete this
397:38 - text to make things more clear
397:40 - let's delete this text
397:43 - let's delete this
397:50 - now let's run this code again
397:56 - so what we have now is that every time
397:59 - we get the value of our property name we
398:01 - have we have that prefix first name that
398:03 - we have uh overwritten here in the in
398:07 - the getter so the getter is called as I
398:09 - said the value is returned by the getter
398:12 - so together is called it Returns the
398:14 - value of the first name property so this
398:16 - field is is the first name property but
398:19 - is uh it has this identifier field
398:22 - because of uh of an important reason
398:24 - which I'm gonna explain immediately so
398:28 - it Returns the value of the first name
398:30 - property
398:31 - with the prefix first name and we have
398:34 - first name the text that we have here
398:37 - then I have the value of the first name
398:39 - property we have Alex in our case
398:42 - because our object has the name Alex as
398:45 - the property name Alex
398:48 - then for the
398:50 - for the setter we don't have any code
398:52 - here also we have the first name prefix
398:55 - for John so our our every time we get uh
398:58 - we get the first name property by
399:02 - of our objects created by by using the
399:06 - user class it gets that value it returns
399:09 - that value through the getter and the
399:11 - setter we don't have value was assigned
399:14 - to first name property because the
399:15 - setter is called only one we change the
399:19 - value of uh of uh of our properties and
399:22 - to do that we type user like we did in
399:25 - our first video about objects or another
399:27 - programming
399:28 - DOT first name
399:31 - equals let's say
399:34 - oh
399:36 - let's put here
399:39 - Vlad
399:42 - so now if I run this code
399:44 - now the setter is going to be called
399:46 - because the setter is called as I said
399:47 - only when it we change the value of our
399:50 - of our of of our property
399:54 - so we get uh
399:56 - get Vlad was assigned to first name
399:59 - property so the code inside the setter
400:01 - was called
400:02 - because this code that we type here is
400:07 - calling the setter so our code only only
400:10 - always goes to the setter and the code
400:12 - that we have here user that first name
400:15 - Vlad what it's actually doing is
400:18 - passing that value Vlad to
400:21 - here so this for this uh this parameter
400:25 - it that we have here is receiving the
400:28 - value of Vlad and then that value is
400:31 - assigned to first name property again we
400:34 - have this field the identifier for a
400:36 - reason and the reason is going to be
400:37 - explained immediately
400:39 - so uh
400:42 - the Getters and Setters are working well
400:46 - and they are as they said again the use
400:49 - always when we get or
400:52 - assign a new value to our properties
400:55 - now what is this field identifier why I
400:58 - didn't
401:00 - type here uh
401:02 - first name and here I didn't put uh
401:07 - first name equals to Value so whatever
401:09 - value is passed to the setter then that
401:11 - value is assigned to the first name
401:13 - property so why
401:15 - why don't we don't do that
401:18 - and um the reason uh for that is that
401:22 - because
401:26 - this syntax user.first name user first
401:30 - name
401:31 - user.first name equals Vlad is calling
401:33 - the setter
401:35 - if we put here first name equals value
401:38 - so first name equals Alex it will be
401:41 - equivalent to to call the setter again
401:45 - so this line of code that we have here
401:47 - it will call the setter again it will
401:49 - pass the value to the center and then it
401:51 - will assign the value again to the first
401:53 - name so it will call the Center inside
401:56 - the setter forever it will be it will
401:59 - generate an error and to avoid the that
402:01 - recursive call that infinite call we
402:04 - need to use this field identifier so the
402:07 - field in an identifier is the first name
402:09 - property but it has this
402:12 - special
402:15 - use that it bypasses that error that it
402:19 - will be generated if you use the first
402:21 - name here
402:22 - so in fact let's um
402:27 - let's put here a first name to see
402:31 - so if we put here first name
402:34 - instead of field
402:36 - and we have an error here
402:38 - let's put here a
402:41 - field
402:42 - because
402:44 - I want uh I want the error from the
402:47 - setter to to get in the console not
402:49 - there or from this thing here so now if
402:51 - you run the squad
402:52 - as I said that will generate a recursive
402:55 - call it will call the getter over and
402:57 - over
403:00 - so get the error
403:04 - so you see we have Vlad was assigned to
403:07 - first name property Vlad was assigned to
403:08 - first name property vad and so on that
403:11 - is because
403:12 - the setter
403:14 - it's calling the setter forever
403:18 - it's a recourse of call because this
403:20 - line of code here it's calling the
403:22 - setter it's it's a assigning the value
403:25 - to the sending the value to the seta
403:28 - then it's that values assigned again to
403:30 - the first name property which in turn
403:33 - close again the setter and so on so this
403:35 - field the identifier is used because it
403:38 - has this characteristic of
403:40 - bypassing that error this is why we're
403:43 - using the field instead of the first
403:45 - name
403:46 - property here and it's basically the
403:50 - first name property but it has this
403:52 - specific characteristics which
403:54 - characteristics which bypasses the
403:57 - recursive call which we got when we've
404:01 - used the first name property
404:03 - now if you run the code
404:10 - now I have no error because the recourse
404:12 - of call is not happening because you're
404:14 - using the field which bypasses that
404:15 - error
404:16 - so this is why we're using uh and we're
404:18 - having an encodone has this thing filled
404:21 - and this the field can only be used
404:23 - inside the getter or the setter not uh
404:26 - not anywhere else also either getter or
404:29 - the setter
404:30 - and the same is true about the getter
404:33 - this is why you need to use the field
404:34 - identifier inside the getter also
404:36 - because it will generate the recursive
404:39 - call again
404:41 - now to to illustrate better because you
404:45 - maybe find the
404:47 - confusing this discussion about Getters
404:49 - and Setters what they really
404:52 - are they are equivalent to having two
404:56 - functions which
404:58 - update the first name property and
405:01 - return the first name property so they
405:02 - they are equivalent to having
405:04 - a function called Set uh
405:07 - first name
405:09 - and this function defines a parameter
405:11 - called let's call it new value
405:14 - is going to be of type string
405:18 - let's put curly braces and here we type
405:21 - this DOT first name
405:24 - equals
405:26 - new value
405:28 - and the geta equivalent to having a
405:32 - function
405:33 - called
405:34 - get
405:36 - first name
405:38 - and this is not going to take any
405:39 - parameter is going is we're going to say
405:42 - say explicit here that it's going to
405:44 - return a string because it's gonna only
405:46 - return a value
405:48 - and this is going to return the first
405:51 - name property
405:54 - so we put here this
405:57 - that first name so the getter and Setter
406:02 - that we have here are similar this is uh
406:05 - illustrative for you to have in mind to
406:09 - having two functions which are setting
406:12 - the first name property or updating the
406:14 - first name property and are returning
406:16 - let's change this to First
406:20 - and are returning the first uh the value
406:23 - of the first name property but because
406:25 - constantly and it's about conciseness it
406:28 - has this special syntax and they are
406:32 - automatically generated for you because
406:35 - uh as I said accordingly it's about
406:37 - conciseness so you don't need to declare
406:40 - those things every time you create a
406:42 - class so let's delete this so have in
406:46 - mind that under the covers is we have
406:49 - something like this so let's delete this
406:52 - now the arrow disappears
406:54 - also you can have a shorter way of
406:57 - writing the centering letter if you
406:58 - don't provide some additional code so if
407:01 - I delete this
407:03 - and this
407:06 - I can put here get equals field
407:11 - and um
407:16 - yes this is this okay because this is
407:19 - like having a single line a single
407:22 - function a single line expression
407:24 - function because we're returning the
407:26 - value to the function get so you can
407:30 - write it like this because or I I show
407:33 - you this photo because maybe you'll see
407:35 - a written in this way and you may be
407:38 - wondering why that's because this is
407:40 - like having a a single body expression
407:44 - function
407:46 - so you can write it like this if you
407:47 - want but again if you hover over this is
407:50 - still already done let's so let's press
407:51 - Ctrl G to have the previous code
407:54 - so this is our discussion about Getters
407:56 - and Setters and see you on the next
407:59 - video
408:00 - so now it's time to start a discussion
408:02 - about the late init keyword and how we
408:04 - can use the latent keyword with the our
408:07 - properties but first let's delete the
408:10 - code that we have from the previous
408:11 - video because don't need this code let's
408:13 - also delete this code
408:15 - let's delete those two objects
408:18 - that's
408:19 - and lazil is property let's declare it
408:22 - here so let's put the VAR keyword
408:25 - and let's also delete the default values
408:27 - here
408:34 - and let's press Ctrl alt form on the
408:36 - code
408:37 - now we need to provide the values here
408:39 - because we don't have default values for
408:41 - the last name property and the age so
408:43 - I'm going to type here
408:45 - dobbyn let's say
408:48 - age 23.
408:50 - now
408:52 - as you already know if you declare
408:54 - inside the class
408:57 - a property let's say that that property
408:59 - is called favorite movie and it's going
409:01 - to store the favorite movie of the user
409:05 - you cannot let this variable
409:07 - uninitialize so let's say that is going
409:09 - to be of type string
409:11 - so you cannot let this variable
409:12 - uninitialize you need to provide a value
409:14 - either by assigning directly
409:17 - a literal value here or by receiving the
409:21 - value through through a parameter
409:25 - defined in the Constructor
409:26 - but um that is not completely true
409:29 - because
409:31 - sometimes you'll want to to have a
409:35 - property declared inside the class but
409:37 - you don't have to assign a Twitter
409:40 - valued uh right away so you want to
409:42 - assign the value to the property later
409:45 - and to be able to do that you need to
409:47 - use the late init keyword and to use the
409:50 - late neat keyword you just type here
409:52 - late it and you have a suggestion later
409:54 - need
409:55 - and later need search for initialize
409:58 - letter later so what we're saying here
410:01 - is
410:02 - initialize let later this property
410:06 - favorite movies so you say in the to the
410:09 - compiler hey I'm gonna
410:11 - initialize this uh property favorite
410:13 - movie but I'm gonna initialize it later
410:16 - so believe me and uh
410:19 - to do that you just
410:21 - type user
410:23 - that so you whatever object you create
410:27 - with this class and you have a defined
410:29 - latent property
410:31 - favorite movie
410:33 - and you put equals and then you put
410:35 - let's say Interstellar here
410:42 - so now we've initialized our favorite
410:45 - movie property but we initialize the its
410:47 - value later so we didn't provide the
410:49 - value here directly inside the class
410:51 - either by as I said by providing a
410:54 - literal value or by
410:56 - providing a value through the parameter
410:59 - defined in the primary Constructor so
411:02 - this is how you can use the
411:04 - latent keyword if you want to
411:08 - assign a value to a property later so
411:11 - you don't want to assign the value
411:12 - directly or or you don't want to cite
411:14 - the the value more correctly said
411:17 - right away so you want to assign the
411:19 - value later you just put the latest
411:22 - keyword in front of the property and
411:23 - then you declare the property as
411:26 - you the way you declare a simple
411:28 - variable
411:29 - right and if you don't initialize this
411:32 - this property and you want a new output
411:36 - the value in the console so let's say
411:38 - that I put here a printerland
411:41 - and I type user that
411:43 - favorite movie
411:45 - and I don't initialize it
411:52 - and if I run this code now this
411:55 - favorite movie property is not
411:58 - initialized doesn't have a value
412:00 - we're gonna have an error
412:04 - and the error is uh
412:06 - it's very specific
412:12 - so you have exception thread main
412:14 - kotlin unofficialized projects access
412:16 - exception we have and then it says later
412:19 - need property favorite movie has not
412:21 - been initialized so it's very specific
412:23 - in saying that hey you didn't you said
412:25 - that you're going to initialize that
412:27 - property but you didn't and uh down here
412:30 - you try to to Output in the console the
412:33 - value of the favorite movie but we don't
412:35 - have provided a value and it's better to
412:38 - have this uh this is called an exception
412:41 - so it's better to have this energy Pro
412:43 - and initialize property access exception
412:46 - then having a null pointer pointer
412:49 - exception because
412:52 - this is why kotlin actually enforces
412:54 - this behavior of uh
412:58 - assigning values to the variable to the
413:02 - variables so it Cotillion forces to
413:04 - assign values to the variables and not
413:07 - let them uninitialize because if you
413:10 - don't initialize
413:12 - uh you don't provide the value to a bear
413:16 - to a variable or two property then when
413:18 - you try to access that variable or that
413:21 - property and let's say that you have an
413:23 - app
413:24 - that is gonna throw which is going to
413:28 - throw what is called the null pointer
413:30 - exception and that is very bad because
413:32 - those kind of excursions are called only
413:35 - at runtime and not at compile time so
413:38 - your app can work let's say completely
413:42 - well and when you press a button I don't
413:46 - know to to see the the favorite movie of
413:52 - a user then you get an error and adopt
413:55 - crashes so this is why you need to avoid
413:58 - those null pointer exceptions and kotlin
414:02 - as I said enforces this behavior of
414:04 - providing um
414:05 - values always to the variables to the
414:08 - end to the properties
414:09 - and if you don't want to provide the
414:12 - value to the
414:14 - property then you can use this late on
414:16 - it and it will show this uh different uh
414:20 - exception called latent property
414:22 - favorite movie has not finished so it's
414:24 - it's a different exception than the null
414:28 - pointer exception but with the latent
414:30 - keyword we can still have as I said that
414:33 - behavior of not initializing the
414:34 - variable but you still need to
414:37 - initialize it later because this one is
414:39 - called late init
414:41 - but this is not uh saying that the
414:45 - latent
414:46 - error that is shown here is not also uh
414:51 - having the same behavior like the null
414:53 - pointer exception that I talked about
414:54 - because the late init error that is that
414:58 - we have here
414:59 - if you have an app it will uh also
415:02 - Crusher up but the later neat keyword
415:05 - allows us to not provide as I said the
415:08 - value literally a little value here or a
415:11 - value through the
415:12 - constructed by the by assigning the
415:15 - parameter here with the value pass of
415:16 - the parameter
415:18 - and the
415:20 - is uh is our
415:24 - responsibility to initialize that
415:26 - variable later so that you don't get
415:28 - into the same problems that we talked
415:31 - about so we don't get this error so it's
415:34 - up to you to
415:36 - to declare a a property as late and
415:40 - eaten then provide a value later because
415:44 - if you don't it will also Crush you up
415:47 - when you try to access uh by uh I don't
415:51 - know in Europe somehow you want to
415:54 - access the value of that property
415:57 - so I always have a have a decent mind
415:59 - that you need to initialize that
416:01 - variable later
416:04 - also I should say that the latent
416:06 - keyword only works with
416:08 - classes
416:09 - and it does not work with primitive type
416:12 - so even though the as I said the
416:15 - integers and all the data types that we
416:17 - looked at and also the
416:19 - Boolean and Char are classes
416:22 - we cannot use latent adhered with them
416:25 - because if I put here in you can see
416:27 - that I have an error
416:29 - that it says latony modifiers not
416:31 - allowed on properties of primitive types
416:33 - because uh I'm not gonna get into much
416:37 - of details but all we need to know to
416:40 - know is that
416:41 - when
416:43 - the int class and all the Primitive
416:46 - types which are classes uh at least
416:52 - at the surface when they are compiled I
416:55 - think they are compiled into primitive
416:58 - types so they are not compiled into
416:59 - classes so this I think is the reason
417:02 - that you don't you can't use this latent
417:06 - in the keyword but for other classes
417:09 - because a string is is a data type but
417:12 - it's a special data type as I said you
417:14 - know in a previous previous video and
417:18 - because of that you can use the latent
417:20 - keyword and you can use the latent
417:21 - latent keyword
417:23 - with other classes so I can put here
417:25 - user if you want
417:27 - and it works because users is also class
417:29 - is this class that we Define here
417:32 - so it's good to to to remember this
417:37 - now I'm going to end the video and see
417:39 - you in the next video but first let's uh
417:41 - press Ctrl G to have the code that you
417:44 - had previously
417:47 - so uh now I'm gonna end in the video and
417:51 - see you in the next video
417:52 - so now it's time to start a discussion
417:54 - about companion object but to do that
417:56 - I'm gonna delete the class that we have
417:59 - here
418:01 - and I'm going to paste it inside our
418:03 - classes file because we're gonna need
418:05 - this class later in our videos
418:07 - and I'm gonna also delete this code
418:09 - because you don't need this code
418:11 - and let's say that
418:13 - let's create the class called calculator
418:20 - is not going to Define any properties
418:24 - you know it's going to have a simple
418:26 - function called sum which is going to
418:28 - sum two numbers
418:30 - so we're going to Define two parameters
418:32 - here a
418:34 - it's going to be an INT a b
418:38 - also on it
418:40 - n is going to return the sound so we put
418:42 - colon at the end of our
418:45 - parenthesis or function we put int
418:47 - because this is what you're going to
418:49 - return
418:50 - and we put calibration type return a
418:54 - plus b or you can put this in a single
418:57 - body expression function so you can put
419:00 - the code like this if you want
419:05 - so we can put here uh you can also
419:07 - delete a type you can put here equals
419:08 - and this will work but I'm gonna
419:11 - keep it like this
419:13 - now if you want to use this sum function
419:17 - that is defined in this uh
419:19 - class calculator first you need to
419:22 - create an object without class so we
419:24 - type here Val I'm going to call it
419:26 - calculator
419:29 - and I'm gonna create here a new object
419:32 - calculator
419:35 - Constructor doesn't have any properties
419:37 - any parameters and if you want to
419:41 - to call that some function we need to
419:43 - use our calculator
419:46 - variable or I'll confrater object or
419:49 - reference and we put dot like we did in
419:53 - our research so use the dot notation so
419:55 - now we're calling the sum function on
419:57 - our calculator object that we created
419:59 - online too let me put when we call our
420:02 - function sum inside the buttons you pass
420:04 - two numbers let's say 5 and 10.
420:08 - and uh
420:09 - let's capture this value that is
420:11 - returned by the
420:13 - by the function in a variable so let's
420:15 - put here
420:17 - Val result
420:26 - because that is going to return the sum
420:28 - of 5 and 10. of course that you can put
420:30 - that in a printerland
420:32 - statement if one but I put it in this
420:35 - elaborate way to to make
420:39 - more clear what you're doing and here
420:41 - I'm going to type println
420:44 - result
420:46 - so now if I run the squad
420:49 - you're gonna see 15 in output line in
420:52 - the console
420:55 - so let's increase this
420:57 - so we have 15. and the way we did it is
421:00 - we created an object like we did so many
421:02 - times then we want that object use the
421:05 - dot notation to curl that function on
421:07 - that specific object on this object and
421:10 - that function takes as arguments as easy
421:13 - as
421:14 - values to its parameters to integers we
421:18 - pass 5 and 10 and then it returns as
421:20 - well and we retain we
421:23 - we capture that value in the result
421:24 - variable and then we want to put that
421:26 - value in the console and get 15. but um
421:30 - if you think about the way we did this
421:32 - thing is that the only way we can call
421:36 - the sum function is by creating an
421:38 - object and then calling the function on
421:40 - that object but it doesn't make a lot of
421:43 - sense if you have a calculator class
421:47 - to call
421:48 - to create every time through our code
421:51 - every time you need to use the sound
421:53 - function to create an object throughout
421:54 - your code a better way it would be if
421:57 - you could call that sum function
422:00 - somehow without declaring uh without
422:03 - creating an object and then using the
422:05 - the object to call the function and to
422:08 - you to do that we need to use what is
422:10 - called a companion object and to use a
422:12 - component object we go inside our class
422:14 - we type companion object so we can press
422:18 - enter to fill in a component object for
422:21 - us or you can type that then we put
422:23 - curly braces and inside the curl brace
422:25 - you put our codes and in this case we're
422:27 - going to put our sum function
422:31 - now
422:34 - you you're going to see something now we
422:36 - have an error here
422:38 - now this
422:40 - function this sum function doesn't
422:43 - belong to an object to an instance that
422:46 - is created with the class calculator
422:49 - instead it belongs to the class itself
422:53 - and not to the not to any object that we
422:56 - create
422:56 - those the variables and the functions
423:00 - that are the functions that are declared
423:02 - inside the component object are also
423:05 - called
423:06 - class variables or
423:09 - class functions because they don't
423:11 - belong to they don't belong to a
423:14 - specific object that you create with
423:15 - that with that class instead they belong
423:19 - to the class itself so you don't need an
423:21 - instance to call that function and uh
423:24 - that uh
423:26 - implies that we can't use it with an
423:30 - object because it belongs only to the
423:32 - class and let's see how you can use it
423:34 - using the class without creating an
423:36 - object we just type calculator
423:40 - dot sum and here you pass again
423:44 - 5 and 10. so
423:47 - we just use our name or the name of our
423:50 - class we put dot sum and now we can use
423:54 - the function without uh then without us
423:57 - needing to create an object and then
423:59 - calling the function on that object so
424:01 - this is a very powerful because uh
424:05 - you will need this in your code
424:06 - sometimes when you don't uh it it
424:09 - actually doesn't make sense to create an
424:12 - object every time you you call let's say
424:14 - a sum function for a calculator
424:17 - now we can also retain that value that
424:20 - is written in a variable also result
424:25 - put equals
424:28 - now we can print this in the console
424:41 - so we get also 15 but this time we
424:43 - didn't create an object we didn't create
424:46 - a new instance and we call that we call
424:48 - the sum function on that object we just
424:50 - type the calculator class and call that
424:53 - function on directly on the class
424:56 - all right so this is how you can use the
424:57 - companion object
425:00 - and this is also true for a variable so
425:02 - if you put a variable here let's say Max
425:05 - and you put an arbitrary number here
425:06 - let's say 100
425:08 - we can call this variable
425:10 - also by typing calculator the name of
425:14 - the class Dot and have our Max variable
425:17 - uh like in contrast with how we did the
425:21 - how you call the the properties in the
425:25 - past by creating an object and using
425:28 - that object to curl that property on
425:30 - that object in this case you just use
425:33 - the class and call the the variable and
425:35 - this also can be can be useful if you
425:37 - have some
425:38 - constants to which you want to use in
425:42 - our throughout your quad so let's delete
425:45 - this so you can use also with variables
425:48 - and if you think about uh
425:50 - uh at our
425:52 - one of our first lessons about the data
425:56 - ties when you look at the minimum and
425:58 - maximum value I I type something like
426:01 - this Val Max
426:03 - and I
426:05 - to get the maximum volume I type int
426:07 - that
426:09 - max volume and this is using also a
426:12 - companion object because as you can see
426:13 - the integer class because the Primitive
426:16 - types are also classes at least on the
426:18 - surface
426:19 - not when they are compiled on the jvm
426:21 - they also use companion objects like we
426:25 - have here to to get to to get the
426:29 - properties and to get the functions
426:32 - because you don't we didn't create an
426:34 - instance of our integer of with our
426:37 - integer class and then call that max
426:40 - value on the object in fact if you hold
426:42 - control on this integer class and if you
426:45 - actually hover over it and after you
426:48 - hold Ctrl it says
426:50 - public companion object of int so if you
426:53 - hold Ctrl and if you press and if you
426:55 - press click now
426:57 - it will open this primitives.kt file
427:03 - and inside
427:05 - primitive.gt if I have our end class and
427:08 - we have a companion object inside the
427:10 - companion you have this public constant
427:13 - value we're going to look at the
427:14 - constants in the negative but the point
427:16 - here is that it's using the companion
427:19 - object to to declare is declaring the
427:22 - the this minimum value the maximum value
427:24 - inside The Company audio so that you
427:26 - don't need to create an instance an
427:27 - object every time you need to use them
427:30 - so
427:32 - this is our discussion about compounding
427:34 - object and see you on the next video I'm
427:36 - going to close this file now
427:37 - and if you if you want you can look you
427:39 - can look in that Primitives file if you
427:41 - want just take a look look what is there
427:45 - so see in the next video
427:47 - so now it's time to start a discussion
427:49 - about Singleton but first i'm going to
427:51 - copy this code I'm going to copy this
427:52 - class with the companion object and I'm
427:54 - going to paste it inside the classes
427:56 - file
427:57 - and if you don't have this code Discord
427:59 - because you create a new project just
428:01 - type the code that I'm going to type in
428:02 - a second so let's delete the code inside
428:04 - the main function
428:06 - now what is a single then
428:09 - a Singleton is a design pattern in
428:11 - kotlin with which you want to have
428:14 - only one instance of a particular web
428:17 - object so you want to have only one
428:19 - instance of a particular object and you
428:21 - want to have that instance available
428:23 - globally tutorial program so you don't
428:26 - need to create an instance every time
428:28 - you need to use that
428:30 - that object in a different part of your
428:33 - code
428:34 - and there are
428:36 - project practical reason for having only
428:39 - one instance of a class let's say that
428:40 - you have a database
428:42 - you want to you want to have only one
428:44 - instance of that database which creates
428:46 - the database which gives the data and so
428:49 - on because if you have multiple
428:51 - instances if you able you are able to
428:53 - create multiple objects with that class
428:56 - then you'll have multiple databases in
428:59 - your
429:00 - phone or on our PC and that is not good
429:03 - because you're using more memory than
429:07 - you should and you have a duplicate
429:10 - duplicated
429:12 - duplicated and unnecessary code
429:16 - so to solve that what we need to do is
429:19 - to create only one instance of a
429:21 - particular class and uh
429:24 - having this example in mind this is what
429:27 - we're gonna do next and first I'm going
429:30 - to show you how we we did the
429:33 - in the past how we created a Singleton
429:36 - without having the object keyword so you
429:40 - go down here
429:41 - and first we're going to create a
429:43 - Singleton in the world wave so we type
429:45 - here class you're going to use our
429:46 - example database not going to create a
429:48 - real database we're gonna just use this
429:50 - as an example
429:52 - and to make to restrict the creation of
429:55 - instances with this database class we
429:57 - need to make the Constructor private so
429:59 - we type private and uh when you use an
430:03 - access modifier with the primary
430:04 - Constructor you need to use the
430:06 - Constructor keyword other otherwise will
430:09 - have an error so if I delete the
430:11 - Constructor keyword here
430:14 - I have an error which says
430:19 - after modifiers or Pro of primary
430:23 - Constructors so we put Constructor
430:28 - and inside the
430:31 - inside the glass
430:34 - now because we cannot create instances
430:37 - of this class that means that we cannot
430:39 - uh access any of the properties or the
430:43 - functions of this class and to to to
430:45 - have access to a function which is going
430:47 - to return an instance of this class we
430:51 - need to use a companion object because
430:53 - with companion like this you can have
430:56 - properties and functions being allowed
431:00 - to being to be accessed outside of the
431:01 - class without creating an instance
431:04 - and here we type again
431:07 - the private access modifier we call this
431:10 - instance and it's going to be a database
431:13 - a nullable database
431:15 - should be valid there
431:19 - instance
431:22 - database and as I said nullable so we
431:26 - can assign null to it
431:29 - then we Define a function called get
431:32 - instance
431:34 - and this function is going to return an
431:35 - instance so for instance of our database
431:37 - class
431:39 - only one instance one one single
431:42 - instance not multiple instances
431:43 - and to do that first to check to see if
431:45 - the instance is null so if this is the
431:47 - first time that we want to access
431:51 - this uh
431:52 - instance then it's gonna return true if
431:55 - not it's going to return false so it
431:57 - checks if it's equal to null if it's
431:59 - equal to null so our instance hasn't
432:01 - been initialized
432:02 - you know type instance equals to
432:05 - database
432:10 - right so if the instance is equal to
432:12 - nulled that means that the instance has
432:14 - been initialized we initialize the
432:16 - database so we can initialize the class
432:19 - inside the class we cannot initialize it
432:21 - outside
432:22 - else
432:23 - so if this condition fails the the code
432:27 - below is going to be red else you're
432:30 - gonna return the instance so if the
432:32 - instance is not null and this uh this
432:36 - code is not going to be a
432:39 - this condition is going to be false and
432:41 - the code will not be as a good inside
432:42 - the if it's gonna we're gonna return the
432:43 - instance but here you go you should
432:45 - return the database
432:48 - and it should be a knowledgeable
432:50 - database
432:51 - what is our Arrow disappeared let's
432:53 - delete this
432:55 - let's press Ctrl alt there
432:59 - all right now how we're gonna use this
433:02 - first
433:04 - we type here
433:05 - Val instance
433:09 - input equals and type database Dot and
433:13 - I'm going to use our function get
433:14 - instance
433:17 - and uh if we we print this instance in
433:22 - the console so we type here instance
433:26 - if you run the squad
433:30 - so now we're calling the
433:32 - fan gets instance inside the company of
433:34 - object
433:37 - we get this code that this code
433:39 - represents the
433:42 - location memory of the instance so we
433:44 - have this code here and if we try to
433:48 - instantiate this class so we put here
433:50 - the Constructor if we do that then we
433:53 - get an error because the Constructor is
433:55 - private so we cannot create an instance
433:56 - and
433:58 - when you call the get instance function
434:01 - so when we did this
434:08 - first check to see if the instance was
434:11 - equal to null and it was equal so now
434:13 - then created the instance and then it
434:15 - returned the instance
434:16 - but if you call this
434:19 - function again so let's call it
434:21 - instance2
434:24 - because database that
434:26 - get instance now this will evaluate to
434:29 - false because the instance is not equal
434:32 - to null we have an instance and it's
434:34 - going to come down here and it's going
434:36 - to return the instance they're already
434:37 - creating instance so if I
434:40 - put a printerland here
434:44 - and I'm gonna output the instance tool
434:47 - you're gonna see that there is no
434:49 - instance to you have the same instance
434:52 - because it's you it's returning already
434:55 - creating created the instance so we have
434:57 - the same code here meaning
435:00 - this translates to that you have the
435:04 - same instance so no matter how many
435:06 - times you use database I get instance if
435:08 - it's the first time then it's going to
435:10 - create the instance and it's going to
435:11 - return in essence if you call that again
435:14 - like we do for instance 2 then it's
435:16 - gonna return the already created users
435:19 - so in this way you have the same
435:21 - instance no matter how many times you
435:23 - you call the get instance function
435:26 - because it will always return the same
435:28 - instance because we
435:30 - because of our logic that we created
435:33 - here but there is a shorter way to
435:35 - achieve the same thing by using the
435:37 - object keyword and this is what we're
435:40 - gonna do next
435:43 - so let's close this
435:45 - now let's see how we can create a
435:47 - Singleton and which is going to have the
435:50 - same behavior that we created here so
435:53 - it's gonna be only one instance using
435:55 - the object keyword so I'm going to type
435:57 - down here object
436:03 - I'm going to call it database
436:06 - now let's delete this code because we
436:08 - cannot have a
436:10 - two objects which have the same name
436:16 - and we cannot have a Constructor here
436:18 - because it's a Singleton so you put only
436:21 - curly braces
436:23 - you can have properties and functions
436:25 - inside the Singleton created with you
436:28 - with the
436:29 - object kios leslie.com inside Dimension
436:32 - frame function too
436:33 - so uh
436:35 - Now by just typing object database now
436:39 - we have the same thing that we had
436:41 - previously just by typing object and
436:43 - database so this will always return the
436:46 - same
436:46 - instance and we have only this code
436:50 - object and the name of the object so the
436:53 - in the instance of the object is going
436:56 - to be created the first time you call it
436:58 - and we can put an initializer block to
437:01 - have some code to be executed here so
437:02 - let's put a printerland
437:04 - let's say yo
437:10 - this is a database created
437:14 - and to you to use this just type let's
437:17 - put a printerland
437:19 - and type database
437:23 - and now if you run this
437:28 - and the first time you call the
437:30 - Singleton that time the Singleton is
437:33 - going to be
437:34 - it's going to be created so I have
437:37 - database created then we have this code
437:39 - which represents the
437:40 - or Stringer is the string representation
437:43 - of the object and if you press Ctrl D
437:46 - here look what happens
437:49 - we have
437:51 - database created so because this is only
437:54 - one instance this object is a single
437:57 - turn it calls the initializer block only
438:01 - once when it initializes itself so when
438:03 - we call the database for the first time
438:05 - it is initialized and it calls the code
438:08 - inside the init block and after that it
438:10 - only
438:11 - it output this thing representation the
438:14 - second time we call the database we
438:16 - don't have database created because the
438:18 - instance was already created and the
438:20 - initializer block is not called again
438:22 - because we have the same instance so if
438:24 - you can press Ctrl D here multiple times
438:26 - and we're gonna see that we have the
438:28 - database created with only one
438:31 - one uh once because
438:34 - that is called only when the
438:39 - only when the object is created for the
438:41 - first time so on this line in the next
438:43 - slide we have the same uh the same
438:46 - objects we have here this
438:48 - this is why I have the same code because
438:50 - it's basically the same instance so as
438:52 - you can see this is a lot simpler and um
438:56 - more concise than the code that had
438:58 - previously so this is how you can create
438:59 - a Singleton in kotlin this is why this
439:03 - is how we should do it
439:05 - so see in the next video
439:09 - so now it's time to start a discussion
439:10 - about lazy initialization but first i'm
439:13 - going to copy this Singleton and solid
439:15 - hour classes file
439:18 - and if you don't have this file because
439:20 - you created a new project again just
439:22 - type the code that I'm going to type in
439:24 - a second so I'm going to delete this
439:26 - now what is lazy initialization
439:29 - lazy initialization is used when
439:33 - creating an instance when creating an
439:35 - object is expensive and the expensive in
439:38 - the programming context means that it
439:40 - will take some time
439:41 - it will use some memory and in that case
439:44 - it's recommended to use lazy
439:46 - initialization and to illustrate the
439:49 - lazy initialization I'm going to use our
439:51 - user class so I'm going to compare user
439:53 - class inside order
439:55 - main file not because I can create here
439:57 - an object by having the file here but
440:01 - because
440:02 - I want to
440:04 - put the code here to make clear what I'm
440:07 - doing so I'm gonna delete the code from
440:09 - here
440:11 - and if you don't have the file just
440:12 - create a new class called user Define
440:15 - the properties for its name last name
440:17 - and age I'm gonna delete this because
440:19 - you don't need this
440:21 - and inside our user class I'm going to
440:24 - put initialize an initializer block
440:25 - which is going to be called every time
440:27 - you create a new object and here we're
440:29 - gonna put a printer printer print line
440:32 - statement
440:34 - which is gonna say
440:37 - user
440:39 - when I call the first name property so
440:42 - the value that Sparks the first name
440:43 - property
440:50 - was created
440:53 - so let's create a new object here
440:57 - let's call it user1
441:00 - equals user
441:01 - now let's put some values to the
441:04 - properties of the Constructor let's say
441:05 - Alex
441:14 - now if you run the squad
441:25 - we get in the output user and the value
441:28 - for the first name property Alex was
441:30 - created
441:31 - if I press Ctrl d
441:33 - and I change this to user 2.
441:37 - and let's change this to a generic name
441:39 - user
441:41 - for the last nameless
441:44 - pass just the last name text
441:48 - and let's skip that age so if I run this
441:51 - code now
441:52 - because now on the line 3 you create a
441:55 - new object the initializer block is
441:57 - going to be called again because we
441:59 - create a new object which is user
442:02 - user was created
442:04 - now to initialize our user 2 with the
442:07 - lazy initializer we just delete this
442:11 - and to illustrate how the initializer
442:13 - block works we delete this and we put
442:16 - after user to buy so we put the keyword
442:19 - by
442:21 - and we type lazy and as I'm typing you
442:24 - see that I have that black lace press
442:26 - enter and put the curly braces and
442:30 - inside the calibration we create our
442:31 - object so user
442:35 - and here to pass the values to the
442:37 - properties so let's put
442:40 - user one
442:46 - let's pass last name
442:51 - and for the age let's put
442:53 - zero
442:55 - now
442:57 - previously when the
442:59 - user was initialized
443:02 - in the world way
443:04 - I found out the user user was created so
443:07 - the initializer block was called when he
443:09 - created the second level but now
443:11 - if I run this code
443:13 - look what happens
443:18 - we get only our first object we get the
443:21 - initializer black only called for our
443:23 - first object and for our second object
443:25 - initialize using the lazy initialization
443:28 - we don't have the initialize of law
443:31 - because the object is not initialized is
443:34 - the object is only going to be
443:36 - initialized
443:37 - when you use that um
443:41 - object in your code so if you use that
443:43 - object somewhere in a code the object
443:46 - then is going to be initialized and it's
443:48 - going to be used so if I type here a
443:50 - println
443:51 - which says
443:53 - user DOT first name user tool
444:03 - now if I run this
444:05 - now because I know I'm I am using the
444:08 - user 2 object now the user to object
444:11 - instance is going to be created and then
444:13 - I'm gonna see user 2. first name so now
444:15 - we see user let's see user 1 was created
444:18 - so the initializer block was called
444:21 - because when we called the
444:24 - the print line user to that first name
444:26 - then in that at that moment it created
444:30 - the instance and then it outputted the
444:33 - user one so this is why now we see here
444:36 - user one one was created and previously
444:38 - we didn't because
444:40 - now we're using the user to object in
444:44 - our code so unless you are not using the
444:48 - the instance the object that have
444:51 - created using the lazy initializer it is
444:54 - not going to be initialized so this is
444:56 - initializer this is initialization by
444:59 - lazy
445:00 - so see in the next video
445:02 - so now it's time to start a discussion
445:04 - about enum classes but first i'm going
445:06 - to copy our user class inside our
445:08 - classes file
445:12 - now I'm going to delete this class and
445:15 - also I'm going to delete the code inside
445:16 - the main function
445:18 - now what are the num classes
445:21 - in on classes are used when we want to
445:24 - represent a fixed set of values so when
445:27 - you want to represent we want to create
445:29 - some constants you should use genomes
445:31 - because
445:32 - enums are like constants but they are
445:35 - more powerful because you can they can
445:37 - have properties and they can also have
445:40 - functions
445:41 - and you know I'm sorry
445:43 - usually used in um if conditioners or if
445:48 - statements or in in the when statement
445:50 - or if I want to call it the if statement
445:54 - expression or when statement expression
445:56 - now let's see how I can create any
445:57 - number class
446:00 - and to create any num class just type
446:02 - here enum the keyword enum
446:05 - and as I'm typing I have some
446:07 - suggestions
446:08 - then we put class and let's call this uh
446:12 - you know class directions
446:14 - Direction actually
446:17 - then you put curly braces
446:19 - and inside the enumclass direction we
446:22 - Define our enum values so here we Define
446:25 - North
446:27 - put comma enter
446:30 - South
446:31 - you can put them in one line just to
446:33 - have comma between them
446:36 - East
446:39 - and west
446:42 - right so we have our
446:44 - enums values defined inside our
446:47 - Direction enum class and those enums
446:51 - values that we have here here they are
446:53 - instances of our enum
446:55 - class Direction so they are an instance
446:58 - there an object created inside the
447:00 - enumclass direction just that they have
447:03 - this different name and as you can see
447:05 - the name of the you know values should
447:07 - be all the names should be in uppercase
447:09 - letters now let's see how we can access
447:11 - those you know values
447:13 - to access the you know values we can
447:16 - let's put the printer line here
447:23 - we type Direction
447:25 - then we press Dot
447:27 - and we have some some suggestions here
447:29 - we have west east north and south so we
447:32 - have our enum values suggested so let's
447:35 - choose West let's output this in the
447:37 - console
447:42 - so we get West so this is the
447:45 - enum value
447:46 - West and um
447:49 - let's press Ctrl d
447:51 - let's change this to East
447:56 - so let's change this to East
448:03 - let's change this to North
448:08 - and South
448:11 - now if you run this code
448:14 - we get our enum values West is north and
448:17 - south
448:18 - so this is how you can get the you know
448:20 - the how you can get the genome values
448:23 - that you define inside your genome class
448:25 - now we can also
448:27 - you can also pass
448:29 - you can define a Constructor here for
448:31 - our enumclass and Define some properties
448:34 - like VAR let's call it Direction
448:41 - of type string
448:46 - and VAR
448:49 - distance
448:51 - and this is going to be an integer
448:55 - now if you hover over here you have some
448:57 - underlines and the underlines if you
448:59 - have always says that you Nam has not
449:01 - the full Constructor so now because as I
449:04 - said those elements values are instances
449:06 - they are objects created inside the
449:09 - original class now we need to pass some
449:11 - values to
449:13 - the properties that we Define here so
449:15 - let's pass some values here so let's
449:16 - press let's type here first
449:19 - North again I'm gonna speed up this now
449:22 - a little bit
449:24 - all right so now what we did here we
449:26 - passed some values to the
449:28 - you know values Constructors because in
449:30 - in up here in our enumclass direction we
449:34 - Define some properties and those
449:36 - properties because the enum values are
449:40 - objects they are instances for a number
449:42 - directions even though they have those
449:44 - different names you need to pass to the
449:47 - constructors then some value so we pass
449:49 - here north south east west and password
449:51 - for for the densest distance 10 20 50
449:54 - and 40.
449:56 - now
449:57 - let's see how we can Loop through our
449:59 - enum's values and to do that we just
450:05 - delete this code
450:07 - and what if and here we add the four
450:09 - groups so we type four
450:12 - let's call it the
450:15 - Direction
450:17 - in and here we type
450:20 - Direction our enorm class
450:23 - dot values and this is going to return
450:26 - an array with all the enum values that
450:29 - are defined in our class
450:30 - now let's put calibrases
450:33 - and let's draw the printerland
450:37 - and let's put in the direction
450:39 - so now if you run this
450:41 - you'll see the same output
450:47 - but in the order that they are defined
450:49 - inside the class
450:54 - so we see the same not the same output
450:57 - because they are outputted in the order
450:59 - in which they are defined in the class
451:00 - so we have north south east and west and
451:03 - this is how we can Loop through an enum
451:06 - to through the enum values of a num
451:09 - class so this is how you do it so now
451:12 - let's delete this code
451:15 - now if you want to access the arguments
451:18 - that are passed to our enum values
451:20 - Constructors
451:22 - we just first put a printerland to
451:25 - Output the values on the console
451:28 - and type Direction so our rename class
451:31 - Dot
451:33 - and we choose our in our value let's
451:35 - choose North and from here and here now
451:38 - we type also that and now we have some
451:41 - suggestions we have Direction distance
451:44 - and we also have a name
451:47 - and name is uh
451:49 - is a variable which is not defined by us
451:52 - so we've only defined those properties
451:55 - direction and distance but name is
451:58 - variable which is built in in the
452:00 - enumclass similar to the the the
452:05 - direction that values which return the
452:08 - array is the the direction that values
452:11 - values was also uh property which
452:15 - actually it was an array property which
452:18 - was built into the enumclass so we
452:20 - didn't create that it's provided by the
452:22 - enumclass so this is why we have that
452:25 - name there so let's put Direction
452:27 - let's press Ctrl d
452:30 - uplicate this code and let's change this
452:34 - to the instance
452:36 - let's press Ctrl D again and let's also
452:38 - print that name
452:40 - which is the built-in variable which is
452:44 - the built-in variable provided by the NM
452:46 - class so let's put here name
452:49 - now if we run this code
452:54 - get North so this is the value that you
452:57 - pass here we get 10 and then we get
452:58 - North with capital letter so
453:02 - so we get the value that we passed here
453:04 - for direction and distance which are
453:07 - defined in Direction class so we get the
453:10 - value spots for this specific
453:12 - you know more volume and then we get the
453:15 - North and this is the built-in um
453:18 - variable which is uh provided by you by
453:21 - Dynam class
453:22 - but as I said you can also have
453:24 - functions so let's have a function which
453:26 - Returns the direction and distance so
453:29 - let's type here fun
453:31 - we call it print data because it's gonna
453:33 - print the data of a specific in our
453:35 - value
453:37 - it's not going to take any input put
453:40 - curly braces
453:41 - but now we have an error here that is
453:44 - because uh when you declare a function
453:46 - inside the nenum class you need to
453:48 - provide a semicolon for the last in um
453:52 - defined in our class so I need to put
453:53 - here a semicolon and there will
453:55 - disappear and let's print the data here
453:58 - let's add the println
454:03 - let's put quotation marks
454:06 - as for Direction
454:11 - equals
454:13 - dollar sign
454:16 - Direction
454:20 - and
454:25 - distance
454:27 - equals dollar sign
454:29 - distance
454:33 - now if you call this wanna
454:35 - our
454:36 - wanna enam valueless type direction that
454:41 - let's say West
454:43 - Dot and now we have our function print
454:46 - data
454:48 - so this print data function is going to
454:51 - put in the data of the West enum that is
454:54 - defined here so it's going to Output
454:56 - West and 40 in the console so you know
454:58 - if you run this code
455:05 - we get direction West and distance 40.
455:09 - so this is how you can use functions
455:11 - inside the noun classes
455:15 - next let's see how we can use our enum
455:18 - Direction and generally how we can use
455:19 - enums with the when statement expression
455:22 - so I'm going to close the console
455:25 - I'm going to delete this code and the
455:26 - print data function works for all of our
455:30 - Renown values
455:31 - so let's delete this
455:34 - and here I'm going to Define a variable
455:37 - it's going to be a Val it's going to be
455:38 - called Direction
455:40 - we're going to put equals and hero type
455:42 - Direction our enumclass let's choose
455:46 - East
455:48 - so now the enum
455:51 - actually is the west east so now our
455:54 - Direction enum is is going to be stored
455:57 - in our Direction variable let's use the
456:00 - when statement expression
456:03 - and we type here when
456:05 - Direction
456:07 - then you put curly braces and here we
456:09 - type
456:11 - Direction
456:13 - Dot
456:16 - East I'm gonna put
456:21 - Auto
456:23 - execute this course so print the Len
456:31 - the direction is
456:35 - yes and we'll do the same thing for the
456:37 - next one so let's press Ctrl d
456:40 - let's change this to
456:42 - West
456:51 - North
456:56 - and South
456:59 - so this is how you can use the enorms
457:02 - with the one statement now if I run this
457:06 - actually I should change the text there
457:09 - but I'm going to change it
457:11 - so let's close this to change the text
457:13 - here
457:16 - now if you run this you're gonna see
457:19 - the direction it sees because this
457:21 - condition is true
457:24 - our Direction argument here is going to
457:27 - match with this Branch so it's going to
457:30 - evaluate true and then it's going to
457:31 - execute this code you can pull
457:32 - calibrations if you want but as I said
457:35 - in our discussion about the when
457:37 - statement expression
457:39 - you should do scary braces if you have
457:41 - multiple lines of code in our case we
457:43 - have one single line of code but you can
457:45 - put curly braces if you want and of
457:47 - course that this Branch will always
457:48 - evaluate to true because here we type
457:51 - direction that is
457:52 - into our Direction variable literally
457:55 - directly and this value doesn't change
457:57 - but in real up this value could come
457:59 - from a database or from the user input
458:01 - and in that case you need to use the
458:02 - function which is also built into the
458:05 - enorma class and that function
458:09 - is called value of so we type Direction
458:11 - dot value of and this value function
458:15 - check his checks to see if our value
458:18 - that we pass here exists inside our
458:21 - enumclass so it checks to see if is
458:24 - defined here and it all it also returns
458:27 - that value so if I type here
458:30 - yeast
458:32 - now if I run this code
458:37 - we get an error which has no num
458:39 - constant direction that is because
458:42 - all of our enum values have they are
458:45 - defined in uppercase letters
458:47 - but if I put here that
458:49 - uppercase
458:52 - and if I run this code
458:58 - now we get the direction assist and uh
459:02 - this value that we have here is this
459:04 - value as I said could come from a
459:06 - database or from the user input and the
459:09 - direction that value of is going to
459:11 - check to see if this
459:14 - you know value exists in our rename
459:16 - class and it's going to return that
459:17 - value
459:18 - in our variable so it's going to assign
459:21 - that value to our variable
459:23 - so see you in the next video
459:27 - so now it's time to start a discussion
459:29 - about inner classes so what are inner
459:31 - classes in our classes are classes which
459:33 - are declared inside another class and
459:35 - they are generally used when you know
459:37 - that there is a very close relationship
459:38 - between two classes so when it doesn't
459:41 - make sense to put two classes separated
459:43 - then you should use inner classes and
459:46 - let's look at an example and we're going
459:48 - to imagine here that we have a list View
459:50 - and this list video list view is gonna
459:53 - display some items in a list in on the
459:57 - screen and here we're going to use inner
460:00 - classes because for displaying the each
460:03 - individual item we're gonna create a
460:06 - list view item so first you create a
460:08 - class called list View
460:20 - foreign
460:26 - we Define a property called
460:30 - items and it's going to be an array of
460:32 - strings
460:42 - now we put curly braces and inside the
460:45 - class we type the keyword inner
460:48 - then class and now we create a class
460:51 - which is going to represent the
460:53 - individual items in the list view so we
460:56 - put type here list view item
461:05 - put the
461:07 - the primary Constructor but we put not
461:09 - we don't Define any properties and then
461:11 - we put curly braces
461:13 - and this inner class let's use gonna
461:15 - have a function called display
461:18 - item and it's going to display the value
461:20 - the values of an item of other specific
461:23 - position so we put here position let's
461:26 - say
461:27 - Define a parameter to our function
461:30 - it's going to be an end
461:35 - and we're just gonna type here print
461:37 - line
461:39 - and the inner classes are have access to
461:43 - the properties of the outer class so
461:45 - inside our inner classes that we have
461:48 - here we can have we can access the
461:50 - properties that are defined inside the
461:52 - outer class list view in this case we
461:54 - have a single property called items and
461:55 - here we can type
461:57 - items and notice that I can use the
461:59 - items property which is defined in our
462:01 - outer class list view we type position
462:04 - and this is going to return
462:05 - an item at this position which is passed
462:08 - as an argument here to to do our
462:10 - parameter position
462:12 - and we go up here and we type Val
462:16 - list View
462:18 - because we're going to create an
462:19 - instance for this View
462:23 - type list View
462:30 - now we need to pass an array to our
462:32 - primary Constructor to the property item
462:35 - so we type here array off and we Define
462:38 - some generic names here let's say uh
462:40 - name
462:42 - one
462:47 - and name four now how can we access the
462:51 - display item function which is inside
462:53 - our inner class
462:56 - list item list view items this this
462:59 - should be list view item not items so
463:02 - let's change this go right click on it
463:04 - and go to refactor and rename
463:07 - let's call it the items
463:16 - press enter
463:19 - now to access the display item function
463:21 - which is inside the original class list
463:23 - view item
463:27 - we type list View
463:29 - so our instance our object list view Dot
463:34 - list view item and then again that and
463:37 - now we have our function display item
463:39 - and we can pass here let's say yo
463:44 - let's say uh two
463:48 - now if you run this code
463:52 - so get in the output name tree and this
463:55 - is correct because it entries the other
463:57 - index too
463:59 - and this is how you can access the
464:01 - display how this how you can access
464:03 - generally a function inside then uh in
464:05 - inside an inner class you just create an
464:08 - instance of the outer class then you
464:10 - call a
464:11 - you call the name of the class of the
464:13 - name of the inner class and then you
464:15 - call the function Auto so see you in the
464:19 - next video
464:20 - so now it's time to do a challenge using
464:22 - the knowledge that we have about object
464:23 - oriented programming
464:25 - and the challenge is to create a class
464:26 - which is going to represent a bank
464:28 - account of a person and this class is
464:32 - going to have three properties the first
464:34 - one is going to be called the account
464:36 - name the second one is going to be
464:38 - called the balance and the third one is
464:41 - going to be called transactions and it
464:43 - should be a multiple list
464:46 - also you should create functions for
464:49 - deposit and withdraw and also function
464:52 - for calculating the balance and you also
464:55 - you also should add the
464:58 - the checks for checking to see if the
465:00 - amount is uh when you deposit the amount
465:04 - is greater than zero and all of that
465:06 - stuff so do this Challenge and then
465:09 - watch my solution
465:12 - so
465:13 - my solution is this I'm going to create
465:16 - the class
465:18 - and for this challenge you should also
465:20 - have in mind the discussion that you had
465:22 - about access modifiers so I'm gonna call
465:26 - it account
465:29 - and I'm going to Define here a property
465:31 - called the
465:33 - we're gonna be called the Val is going
465:36 - to be called the count uh
465:37 - name
465:40 - and it's going to be of type string
465:47 - of type string
465:50 - and we put curly braces and inside the
465:53 - class I'm gonna declare the next two
465:56 - properties and those one uh first I'm
465:59 - going to declare it without the access
466:00 - modifiers because IntelliJ probably is
466:03 - gonna figure out that we need to put
466:05 - access modifiers on them so I'm gonna
466:07 - type VAR balance
466:11 - and I'm gonna assign 0 so this is the
466:14 - default value and
466:17 - VAR transactions
466:26 - and this is going to be equals to a
466:29 - multiple
466:33 - or Multiple List
466:38 - of int because this this is going to
466:41 - store the transactions
466:43 - so these are the three properties of our
466:46 - class now I'm gonna create the first
466:48 - function which is going to be called
466:50 - deposit and this function is going to be
466:51 - used to deposit
466:54 - money inside our bank account and it's
466:56 - going to have a parameter called the
466:58 - mount
467:00 - it's going to be of type
467:02 - end
467:05 - and first we need to check if this
467:07 - amount is greater than zero because you
467:09 - don't want to deposit uh negative value
467:12 - so if amount is greater than zero
467:15 - and we choose greater than zero because
467:17 - we also don't want to deposit zero so
467:20 - this is why I put greater than zero then
467:22 - if it is greater than zero then I'm
467:24 - gonna add that to our transaction
467:26 - list that add
467:29 - amount
467:31 - and then I'm gonna say balance
467:35 - I'm gonna update our balance I'm gonna
467:37 - put plus equals
467:39 - amount then we're gonna add the print
467:41 - line which is gonna say
467:44 - I'm going to put the quotation marks
467:46 - dollar sign
467:48 - I'm gonna type amount
467:52 - I'm gonna put dollar sign this dot
467:55 - balance
467:57 - so I'm gonna output in the console what
467:59 - is the balance but if the amount that is
468:01 - passed to this function is
468:04 - a negative sum I'm gonna go in the else
468:07 - part and we're gonna say
468:08 - another print line here
468:11 - which is going to say cannot deposit
468:12 - negative sums so we're gonna put here
468:15 - okay cannot
468:18 - deposit
468:21 - negative sums
468:24 - so this is our deposit function next I'm
468:27 - going to create another function and
468:30 - this is going to be called withdraw and
468:32 - this is going to be used for withdraw
468:34 - withdrawing mine so we type fun with
468:36 - draw
468:38 - and we put parenthesis and this is gonna
468:41 - take a parameter called with draw wool
468:45 - so uh
468:50 - it should be like this
468:52 - and it's going to be an integer we put
468:55 - curly braces
468:56 - now
468:59 - it should be with
469:01 - with here with
469:04 - with
469:06 - draw
469:08 - now we need to convert this into
469:10 - negative sum because now we're uh
469:12 - withdrawing money from autocon so first
469:15 - we need to check if
469:18 - and we're going to put minus because I'm
469:20 - gonna convert this into a negative sum
469:22 - withdrawal is less than zero
469:25 - so if this is a negative
469:28 - sum which is going to be withdrawal
469:30 - you're gonna
469:34 - I'm gonna add to our transactions is
469:37 - transactions that add and you also put
469:39 - the minus sign so you put minus with
469:41 - drawal because now we're adding now
469:44 - we're uh we're taking money off the of
469:47 - our account then I'm gonna put this that
469:49 - balance
469:53 - my uh Plus
469:57 - equals minus
470:01 - withdrawal because now we're taking
470:03 - money
470:04 - and then we're going to add again a
470:06 - print line it's going to be this one so
470:08 - I'm going to copy this
470:14 - but now this is going to be the
470:16 - withdrawal
470:22 - else if
470:25 - this is not
470:27 - a negative sum so
470:30 - I'm gonna put else
470:35 - I'm gonna type put in the line
470:42 - cannot
470:45 - wait
470:47 - draw
470:51 - negative sums so if he tries to withdraw
470:55 - a negative sum then we're going to say
470:57 - cannot withdraw a negative sum here we
470:59 - put the minus because we we're taking
471:01 - money out of our account so we need to
471:04 - check for uh that's why we're checking
471:06 - here if this is less than zero
471:15 - shouldn't be negative here
471:18 - and we're going to create another
471:19 - function and this is going to be called
471:21 - calculate balance so we type here fun
471:25 - Let's uh
471:27 - bring this
471:29 - fun calculate
471:32 - calculate
471:34 - balance
471:39 - this is not going to take any parameters
471:41 - and it's going to return an INT
471:46 - put curly braces
471:52 - and I'm gonna put this that balance to
471:56 - zero because
471:57 - I want to calculate the balance I'm
471:59 - going to add the transactions to this
472:01 - property balance so here we're gonna say
472:04 - and here we're gonna loop we're gonna
472:06 - type four
472:08 - turn suction
472:12 - in our list of transactions
472:16 - so
472:18 - for transaction in our list of
472:20 - transaction I'm gonna type this Dot
472:23 - balance
472:25 - plus and equals transaction
472:29 - so our transaction and then we're going
472:31 - to return the balance at the end of our
472:34 - Loop when we end we ended looping so
472:37 - return this Dot
472:40 - balance so this is our solution to the
472:43 - challenge and let's um let's create an
472:46 - account and let's pass some values here
472:48 - so I'm going to type here
472:50 - Val
472:51 - Alex account
472:55 - I'm gonna put equals
472:57 - account
473:00 - I'm gonna put now I'm gonna call the
473:01 - primary Constructor so I'm going to type
473:03 - here Alex
473:06 - and we still use I'm still using my name
473:10 - here but
473:11 - so I'm going to type here Alex account
473:13 - Dot
473:15 - deposit so I'm going to deposit let's
473:17 - say one thousand
473:20 - and uh
473:22 - I'm gonna type OLX account that withdraw
473:26 - I'm gonna withdraw
473:29 - 500 then I'm gonna put Alex account
473:33 - and I'm gonna put uh
473:35 - deposit the negative sign let's say
473:38 - minus 20.
473:41 - and Alex account Dot
473:45 - that we draw also negative sign let's
473:48 - say minus
473:50 - 100.
473:52 - now if you're on this code
473:56 - foreign
474:06 - deposit balance is now 1000 so we have
474:09 - our call card called from our deposit
474:12 - function
474:13 - then we have
474:19 - so I should I didn't change the text
474:22 - here so that's why it's saying uh
474:25 - this should say with uh withdrawn so uh
474:30 - sorry let's change this to
474:33 - with
474:34 - drone
474:38 - so let's run our code again
474:48 - so get 1000 deposit balance is now one
474:50 - thousand now we get our uh correct
474:53 - output to get the
474:55 - then 500 withdrawn so get our call the
474:59 - call from our withdrawn function we
475:02 - withdrawn balance is now uh 500 then
475:05 - then you get cannot deposit negative
475:07 - sums cannot withdraw negative sounds
475:09 - because we passed the negative numbers
475:11 - to our deposits and withdrawal function
475:13 - and here we're checking to see if those
475:16 - are negative or positive so this is our
475:20 - solution to our
475:24 - to our Challenge and I hope that you
475:26 - enjoyed this and that you solved this
475:28 - and this is not again the best solution
475:32 - this is just
475:34 - my solution probably you'll find you
475:36 - figure out a better solution
475:38 - maybe your concern better and more
475:42 - concise solution than this actually I
475:44 - forgot before we end our video Let's
475:46 - actually called also our calculate
475:48 - balance function so I'm gonna type here
475:51 - uh
475:53 - Alex account
475:56 - dot calculate balance and this is going
475:58 - to return an integer so I'm gonna type
476:00 - here Val because that function returns
476:03 - something so I need to capture that in a
476:04 - variable so I'm going to type here valve
476:06 - balance
476:08 - equals Alex account
476:10 - so no other print line here
476:15 - and there's gonna say
476:17 - balance
476:19 - is dollar sign
476:22 - balance
476:25 - format the code
476:27 - now if we run this code
476:33 - [Music]
476:36 - now get our previous output to 1000
476:40 - deposit balance now one thousand five
476:42 - hundred withdrawn balance is now 500
476:45 - then cannot deposit negative sums and
476:47 - cannot withdraw negative sounds and then
476:49 - get balances now 500 so our code works
476:52 - well
476:53 - so this is our code
476:57 - one more thing that I forgot is that I
476:59 - said at the beginning of the video that
477:00 - you should have in mind the discussion
477:02 - that we had about access modifiers when
477:04 - doing this challenge
477:06 - and I forgot to to add the access
477:09 - modifiers for balance and transactions
477:11 - because now what can I do for balance I
477:14 - can
477:16 - use our Alexa account
477:20 - s and I can type here balance and now
477:23 - because that is uh actually that is not
477:26 - really probably because when I talked
477:28 - about uh get us unsetters we said that
477:31 - that when you access a property you
477:33 - always access access that property
477:34 - through get a run Center so we never
477:36 - access directly the getter and the
477:40 - property but uh
477:42 - still you should not make that that
477:46 - public because by default if you don't
477:49 - provide an access modifier they are they
477:51 - are by default public so if I type here
477:54 - now account balance as you can see I can
477:57 - call that and I can type here 1000 and I
478:00 - can deposit now I can change the balance
478:03 - of the account directly from here and if
478:06 - you hover over here
478:07 - uh IntelliJ figure out that you should
478:11 - make this private so make this private
478:13 - the balance and also the transactions
478:16 - because
478:18 - you don't use them inside the primary
478:20 - Constructor and they are used only
478:22 - through the to the functions that we
478:24 - defined here the because of that you
478:27 - should you should declare them as
478:29 - private because you use them only
478:31 - through the function that you declared
478:33 - inside the class so declare them as
478:36 - private and now you if you hover over
478:38 - here it says you cannot access balance
478:40 - because it's private in account and now
478:42 - we cannot change the balance from
478:44 - outside the class we can only
478:46 - deposit or withdraw uh
478:50 - sums of money from our bank account
478:53 - by interacting only with the functions
478:56 - and not by calling the property directly
478:59 - and assigning a new balance to to the
479:02 - property so make them private and this
479:05 - way you cannot uh you don't uh you don't
479:09 - access the property outside of the class
479:13 - and you change data directly the the
479:15 - value of the property again it's not
479:17 - really direct because the code that you
479:19 - had previously so this code actually is
479:22 - calling the setter here but still you
479:24 - can change the value of
479:26 - the balance but now because we made that
479:28 - private and the the compiler is smart
479:33 - enough to figure out that because they
479:35 - are not declared inside the primary
479:37 - Concepts and they are only used you only
479:39 - interact with them with the deposit and
479:42 - withdraw
479:43 - and uh calculate balance functions so we
479:46 - don't use them outside you don't have
479:48 - them also declaring the primary
479:50 - Constructor it knows that you should
479:52 - make them private because you interact
479:54 - them only with the functions and now we
479:56 - have this underline because it's private
479:58 - so we cannot change this balance now
479:59 - from outside the class we can only
480:02 - interact them again using the functions
480:05 - so I'm gonna delete this and
480:08 - now see you in the next video
480:10 - so let's delete this
480:12 - so actually I'm gonna let it there
480:13 - because
480:15 - it's uh good to see so now it's time to
480:18 - start a discussion about inheritance so
480:20 - what is inheritance inheritance is the
480:23 - concept in the quarterly programming
480:24 - context with which you can create a
480:27 - class using another class so in other
480:29 - words you can get all the functions and
480:31 - properties that have that the class
480:32 - already has in your new class and in
480:35 - addition to the getting all the
480:37 - functions in properties in uh in your
480:40 - new class you can add some new functions
480:42 - some new properties which are specific
480:44 - to this new class but they aren't for
480:46 - the also this the class from which you
480:49 - are inheriting is called The Base Class
480:51 - the parent class or the super class
480:53 - and you might be wondering why is this
480:56 - useful why you want to do this
480:58 - let's say that you have a very big class
481:01 - which performs very hard task and has a
481:05 - lot of functions in coding but you want
481:07 - to create a new class which is slightly
481:10 - different from this class what you can
481:13 - do is you can get all that code copied
481:15 - in the new class and then you can add
481:17 - your new functions or new your new
481:19 - Behavior to this class but dust is not
481:23 - recommended because you have duplicate
481:25 - code what you can do instead is you can
481:28 - inherit all the functions and properties
481:30 - which this big class already has and in
481:33 - your new class you can add the new
481:35 - functionality the new Behavior which is
481:38 - specific to this new class but it's not
481:40 - for the base class so in this way you
481:42 - can uh you you avoid the duplicated code
481:45 - and you increase the code reusability
481:47 - and for that I'm going to show you in an
481:50 - example and I'm going to create two
481:52 - classes one is going to be called car
481:54 - and one is going to be plain so we
481:57 - create here a class we go down here
482:00 - we type class
482:02 - I'm going to call it car
482:04 - is going to have some properties the
482:06 - first one is going to be called name
482:07 - this is going to be the brand name of
482:08 - the car
482:11 - the second one is going to be color also
482:13 - string
482:20 - engines the number of engines that this
482:23 - car has
482:25 - gonna be an integer
482:27 - and Val
482:28 - this is going to be
482:31 - doors so we're gonna store the number of
482:34 - doors
482:35 - all right
482:36 - we put curly braces because I'm gonna
482:38 - add some functions to this class
482:41 - to function actually fun
482:44 - move
482:48 - and uh
482:52 - fun
482:54 - stop
482:59 - and here you're gonna say
483:03 - print line
483:08 - quotation marks dollar sign
483:11 - the name of the car
483:13 - is moving
483:16 - similarly
483:18 - down here in the stop we're going to say
483:20 - the car has stopped
483:23 - car
483:25 - has
483:31 - and we're gonna create a another class
483:33 - called plane
483:37 - which is going to have also Val
483:40 - name
483:42 - we're gonna be a string a vowel color
483:46 - also string
483:48 - Val engines an integer and the valve
483:52 - doors
483:55 - unint
483:58 - put curly braces and we Define those two
484:00 - function we're going to copy those
484:02 - I'm gonna paste it here
484:04 - so now what we did here is that we
484:06 - created two classes
484:09 - they both both have
484:11 - uh properties for the primary
484:13 - Constructors and but as you probably
484:16 - already noticed we have the same
484:18 - properties we have the name here we have
484:21 - the name there we have the color there
484:22 - we have the color here the color there
484:24 - the engines also we have here and there
484:26 - and we also have those functions which
484:29 - are almost actually are the same so we
484:32 - have what I said at the beginning
484:34 - duplicated code so it doesn't make sense
484:37 - to put this code here another
484:40 - another way to do this is to create a
484:42 - base class a generic class called
484:44 - vehicle which is uh and usually
484:49 - you create the generic class when you
484:51 - know that
484:52 - several classes we are gonna share those
484:56 - properties and those behaviors so a car
484:59 - in the plane both are Vehicles so we can
485:02 - put here instead of declaring the the
485:05 - name and the caller inside the our
485:08 - inside our classes car and plane you can
485:10 - put this in a vague vehicle uh
485:14 - class in a base class and we can inherit
485:18 - those properties in our classes instead
485:20 - of declaring them your inside our car
485:23 - and playing class so we can put here Val
485:26 - name
485:29 - it's going to be a string
485:31 - and the Val
485:35 - color also string
485:38 - now I can copy those two
485:42 - let's put curly braces here and I can
485:44 - paste it paste it here so
485:47 - now I can delete those those two
485:51 - functions from our classes
485:54 - and what we can do now is we can inherit
485:57 - those properties so we can delete those
486:00 - properties that we have here
486:02 - we cannot we will as you'll see you'll
486:04 - need to declare them as parameters but
486:06 - uh
486:07 - they are not they're not going to be as
486:09 - properties in any they're not going to
486:12 - be as properties here
486:13 - now
486:15 - what we can do is that we can inherit
486:17 - this shared those share the functions
486:20 - and those shared properties because both
486:23 - the car and the plane
486:25 - have a function to move have a function
486:28 - to stop the baby they both share a name
486:31 - they both share a color so they both
486:34 - share those properties and uh functions
486:37 - but uh
486:39 - as we did previously is to put them
486:42 - inside the the the classes would not
486:44 - it's not good because we have a
486:46 - duplicated code and in this way we put
486:49 - this code here
486:50 - and now we can inherit this code so we
486:52 - can have this code directly you can you
486:56 - can have this code the being uh
486:59 - being accessed inside the car and plane
487:02 - without declaring them in our classes so
487:05 - to inherit from our class first you need
487:07 - to Mark the class from which you want to
487:09 - inherit as open because by default they
487:13 - are they you cannot inherit from a class
487:15 - so if I enter in head from a class we go
487:19 - at the enclosing impurities of our
487:21 - primary Constructor
487:24 - we put colon and we type the name of the
487:27 - class from which we want to inherit and
487:29 - in this case it's going to be vehicle
487:31 - now
487:32 - if you hover over here
487:34 - it says that this type has a Constructor
487:37 - and thus mods B initialized here and and
487:40 - next you say this type is final so it
487:42 - cannot be inherited from and that means
487:45 - that we cannot inherit from this class
487:46 - unless we mark this class with the open
487:49 - keyword in front of it so we need to put
487:52 - here open
487:55 - and now if we hover over here
487:58 - now we don't have that error you only
488:00 - have this here which is this type has a
488:02 - Constructor and dust must be initialized
488:05 - here and that basically means that it
488:08 - says hey I'm trying to use this vehicle
488:11 - class I'm trying to but in order to use
488:14 - it I mean I need to initialize this
488:16 - vehicle class so we need to pass some
488:19 - values to the
488:21 - construct of the primary Constructor
488:23 - that is defined here you need to pass
488:24 - some values to the name and to color
488:26 - and to do that we Define here name we
488:29 - type name
488:31 - actually dot let's press Ctrl Z
488:34 - let's put a space and we type name
488:38 - we put
488:40 - comma then we type
488:43 - color
488:47 - and notice that we don't have the VAR or
488:49 - the Vault keyword in front of them that
488:51 - is because the those
488:54 - parameters that would have here because
488:57 - they are parameters because they don't
488:58 - have the value of our keyword they they
489:01 - uh they they they have to be declared
489:04 - only as parameters because the
489:05 - properties are going to be declared and
489:08 - they are declared by the primary
489:09 - Constructor of the base class from which
489:11 - we are inheriting from
489:14 - and because of that we don't we we don't
489:18 - we don't need to declare the property
489:20 - again here as you can see if I put the
489:22 - VAR keyword we have an error says name
489:24 - hyzer anyway what that means that we
489:27 - cannot have the property declared here
489:29 - because the properties uh already
489:30 - declared inside the Base Class inside
489:32 - the vehicle class from which we are
489:34 - inheriting from what
489:36 - we can do here is Define the parameters
489:39 - and the value that is passed to those
489:41 - parameters so the primary Constructor of
489:43 - the class cards are going to be passed
489:46 - to the to the vehicle primary
489:48 - Constructor so hero put the primary
489:51 - Constructor so you put two parentheses
489:52 - and we type name
489:55 - and this name is this one from here
489:58 - so we type name then we put comma
490:01 - because we need to pass a value for the
490:03 - second one for the color and the type
490:05 - color
490:06 - and this color is this color here
490:08 - so we type color
490:12 - now
490:13 - if you go up here let's say for let's
490:17 - look first as the actually let's also
490:20 - inherit from inherit inherit also one in
490:24 - on the plane class so we put colon also
490:27 - here
490:29 - we type vehicle
490:31 - and now we need to also to Define here
490:33 - the parameters the name and the color
490:37 - so we type name
490:40 - and at the time you can see that
490:41 - IntelliJ has given us some hints so if I
490:43 - type here color it says that color
490:45 - string so it's very helpful
490:48 - put colon we pass those values to
490:50 - primary Constructor of the base class so
490:53 - we type name
490:56 - color
491:02 - and now if I go up here on I create some
491:04 - instances of our car and playing class
491:06 - so we type here Val car let's put equals
491:10 - this type card
491:13 - let's choose for the name BMV
491:18 - and the
491:20 - for the color let's say red
491:28 - for the engines one for the doors four
491:31 - now I'm going to create also an object
491:33 - with our plane so let's press Ctrl alt
491:35 - form on the code
491:37 - valve plane
491:39 - equals plane so our class
491:43 - we type here
491:45 - for the name
491:52 - for the color let's say
491:55 - or white
491:59 - and
492:02 - blue
492:05 - and
492:08 - for the engines for
492:11 - and for the doors let's see
492:14 - also for
492:17 - now if I go down here and I
492:20 - type here car dot
492:24 - if you look here you see that you see
492:26 - that we have the function stop and the
492:28 - function move but we didn't declare them
492:31 - here you deleted them previously but
492:34 - because we are inheriting from the
492:36 - vehicle class because when you are in
492:39 - editing the properties and the functions
492:43 - from the class from which you are
492:44 - inheriting from are part of the new
492:48 - classes so the the the
492:51 - move function in the stop function they
492:53 - are now part of our color class
492:55 - similarly it's the same in the same the
492:58 - same here the the the the move and stop
493:02 - are uh are part of the class plane so if
493:05 - I type here car
493:08 - dot move
493:11 - and car dot stop and then plane dot move
493:16 - and plane so look like then now I can
493:19 - call them like they are declared inside
493:21 - the our current plane but they are not
493:24 - there but because we are inheriting they
493:26 - are part of the class so you can think
493:27 - of
493:29 - you can think of this thing that we have
493:31 - here as a single entity so it acts like
493:35 - a single entity
493:36 - so now if you run the squad
493:43 - we get in the output band there is
493:45 - moving then they have stopped bearing is
493:47 - moving doing has stopped
493:49 - and uh
493:51 - this uh we get this output because as I
493:54 - said those functions are part of our
493:56 - classes and they are using the name
493:59 - so in this case the name that is passed
494:01 - to the car this name that we have here
494:03 - been there
494:04 - is passed to the to the primary
494:07 - Constructor of the base class and then
494:10 - it's used here so it's calling the
494:12 - movement save and there is moving so in
494:14 - the same way for the for the plane we
494:16 - get the same output it gets the value
494:19 - that is passed here viewing and then it
494:22 - outputs the viewing is moving and then
494:25 - it has stopped
494:26 - but we can do even more we can
494:29 - override those functions inside our
494:32 - class so we can create a version which
494:35 - is inside the base class from your
494:37 - inheriting we can create a version of
494:40 - this function which is specific to the
494:42 - car or which is specific to the plane
494:44 - and I'm gonna look at that
494:46 - so now I'm going to override the move
494:48 - function from our Base Class vehicle
494:50 - inside our playing class because I want
494:52 - to make the move function specific to
494:54 - the playing class so I want to provide I
494:56 - want to provide an implementation of the
494:59 - move class which is specific to a plane
495:01 - so how is our plane is moving a plane is
495:03 - moving by flying so I'm not satisfied
495:05 - with only this generic function which
495:07 - says the name of the vehicle is moving
495:11 - and to override the function you first
495:13 - need to Mark Mark the function similarly
495:17 - to
495:18 - to the class we need to mark it with the
495:21 - open keyword so we type open because
495:23 - kotlin wants to make things explicit so
495:25 - we put open and now we can
495:28 - we can
495:30 - we can override that function inside our
495:31 - plane class
495:34 - so we go to to override the function go
495:36 - to code
495:37 - generate and here we have vehicles in
495:40 - harsh code tostring and go to override
495:42 - methods and you you have those equals
495:45 - hash code into string and those are here
495:46 - because every class that you create in
495:48 - Kathleen is implicitly inheriting from
495:51 - the any class but we're gonna look at
495:53 - that on but more more on that later
495:56 - because you look at that in a different
495:58 - video and we have our function move and
496:01 - stop so
496:03 - the the idea is telling us that those
496:08 - are the functions which can be
496:09 - overridden inside our plane class from
496:11 - our vehicle Base Class so we choose move
496:15 - we press ok
496:17 - and you have this super dot move we're
496:21 - gonna see middle what is this and you
496:23 - can also override it
496:24 - by just typing the keyword override and
496:28 - you can override the function so you can
496:30 - type here override
496:32 - and while I type in you see that we have
496:34 - this override fan move stop or and have
496:37 - also those so we choose move
496:39 - and I have the same thing
496:41 - now super dot move means that call the
496:46 - function so super means call something
496:49 - from our base class in this case call
496:52 - the move function from our Base Class so
496:55 - we're gonna let that here but in
496:57 - addition to that we're going to add a
496:58 - new function so we're going to type here
497:00 - fun
497:02 - flying because the plane is flying
497:07 - and we're just gonna have a simple print
497:09 - line
497:12 - which is going to say
497:14 - put quotation marks let's bring this
497:17 - down a little bit
497:25 - a plane is
497:28 - flying so now I'm gonna call this
497:32 - function flying inside our move function
497:35 - which was overridden
497:37 - so we type flying
497:40 - flying
497:43 - now if we run this code look what
497:46 - happens
497:59 - if you look in the output to get when
498:01 - they is moving when they have stopped
498:02 - and then we get the apply the plane is
498:05 - flying and then we get bearing is moving
498:07 - and bearing has stopped so what what has
498:11 - happened here now because we where when
498:14 - this function move is called here on our
498:16 - object plane created
498:18 - now it's using our own implementation of
498:22 - the move function and after that so it's
498:26 - using our own implementation it's
498:27 - calling the flying function that we
498:29 - created here because a plane is moving
498:31 - in a specific way is flying and then
498:34 - it's calling super dot move and super
498:36 - dot move is calling the function from
498:39 - the base class so it's calling the
498:41 - function from here so
498:44 - by doing this we made our function
498:46 - specific you make we make the we made
498:49 - the function move specific make the
498:52 - function move unique to the plane class
498:55 - because a plane is moving in a specific
498:57 - way and we can do the same thing for the
499:00 - the car class so
499:03 - uh now you may be wondering why why I
499:07 - didn't declare the inside our Base Class
499:10 - the engines because they are also
499:11 - present in in both classes because when
499:15 - you create a generic class you should
499:18 - only include the commonly used functions
499:22 - commonly used and shared functions and
499:25 - the properties so uh
499:28 - all all vehicles have a name and the
499:31 - color but not all vehicles have engines
499:33 - so this is why I put the engines here so
499:37 - in addition to the name and the color
499:39 - which all vehicles have we added some
499:42 - new properties which are specific to a
499:44 - car
499:45 - similar here in addition to the name and
499:48 - the color which all vehicles have and
499:50 - we've inherited that from our class we
499:52 - add that also engines and doors which
499:54 - those things are in addition they are
499:57 - specific to a plane and more we also
500:00 - override the move function because we're
500:02 - not satisfied with the with the simple
500:05 - move function from our Base Class to
500:09 - include to provide our own
500:11 - implementation of how a plane is moving
500:13 - so you can see that by using an
500:15 - inheritance and
500:17 - adding new properties are the new
500:19 - function you can create more specific
500:22 - classes you can inherit you can also
500:25 - inherit from the car class to create a
500:28 - more specific class you can create a
500:29 - Tesla
500:31 - class and so on so this is what
500:34 - inheritance is and
500:36 - see you in the next video
500:37 - so I thought that's a good idea to show
500:39 - you another example with inheritance and
500:41 - I'm gonna go down here
500:44 - and I'm going to define a class so I'm
500:46 - going to type the keyword class and I'm
500:48 - going to call it View
500:50 - and this view is going to represent a
500:52 - view in uh which is used in Android and
500:54 - if you want Android is just a
500:56 - rectangular area on the screen and it's
500:58 - responsible for drawing and event
500:59 - handling
501:00 - but you're gonna mimic as I said what
501:03 - the view is and uh you know Android or
501:05 - not going to create a view like the one
501:08 - that is in use like the one that's used
501:10 - in Android
501:11 - and we Define the primary Constructor
501:13 - but we're gonna not Define we're not
501:15 - going to Define any properties the
501:16 - primary Constructor
501:18 - and this view is going to have a simple
501:20 - function called Draw and it's going to
501:23 - be responsible for drawing this view on
501:25 - the screen so we type draw
501:29 - and create a function and we're gonna
501:31 - add the simple a simple print line here
501:33 - which is going to say drawing The View
501:36 - so we put here
501:39 - quotation marks
501:40 - drawing
501:42 - The View
501:44 - and uh we're gonna
501:47 - mark this class as open because I want
501:50 - to inherit it from it
501:51 - and we're also going to Mark the
501:53 - function open because I'm going to
501:54 - override that function in the
501:57 - in the next class and because this is a
502:01 - generic View and it's going to have this
502:03 - draw function only this function what
502:06 - you can do let's say that I want to I
502:08 - don't want to create a simple uh a
502:11 - simple view which is just a rectangular
502:13 - area on the screen but I want to create
502:14 - something more specific let's say that I
502:16 - want to create a button
502:18 - in that case instead of creating the
502:22 - button the button from zero because this
502:25 - View
502:26 - in Android
502:28 - has a lot of functions and properties
502:31 - which are responsible for creating the
502:33 - view for handling the events and so on
502:36 - so
502:37 - um because here we have on your simple
502:39 - function but the real view has hundreds
502:42 - of functions and instead of creating our
502:45 - button from zero we can just inherit
502:48 - from The View and we can inherit all the
502:51 - functionality that the view already
502:52 - provides to create a generic View and we
502:55 - can add some
502:57 - unique characteristics characteristics
503:00 - which are specific to a button and in in
503:02 - this case in this way we increase the
503:06 - quad reusability and it's more easy for
503:08 - us to to create the button than rather
503:11 - than creating the button from zero
503:13 - because the view already provides all
503:16 - the tools that you need to create a
503:17 - generic view only we you're gonna
503:20 - inherit all that behavior all that
503:23 - properties but I'm gonna but we're gonna
503:25 - change it a little bit so this is what
503:27 - we're gonna do with the inheritance so
503:29 - we create a new class called button
503:33 - so we Define the primary Constructor
503:36 - and here you can Define some properties
503:38 - which are specific to a button not not
503:40 - just to a generic view which is a
503:43 - rectangular area on the screen so we put
503:45 - Val text and this is going to be a
503:47 - string so our our button will have a
503:50 - text which can be plugged in or signed
503:52 - up
503:53 - and also it's going to have orientation
503:57 - because it's going to be one on a place
504:00 - on the screen
504:02 - on a specific place on the screen and
504:04 - this is going to be a string
504:07 - of course you just only Mimi only mimic
504:10 - the
504:11 - View and button which are are used in
504:14 - Android this is why we have so many we
504:17 - see we have so little properties and
504:19 - only a simple function function in our
504:22 - view draw and we put uh here colon to
504:25 - inherit from our view because I want to
504:27 - inherit all that functionality all that
504:31 - properties that a view provides but I
504:34 - wonder is just to change it a little bit
504:35 - to make it more specific I want to make
504:37 - a button and of course as I said this is
504:40 - just uh
504:42 - an example we don't have but in a real
504:44 - in a real app this will have a hundreds
504:47 - or thousands of line of code and we can
504:50 - inherit all of that behavior or that
504:51 - functionality in our new
504:54 - New View which is a button but you can
504:58 - override some functions and you can
504:59 - provide some you can create a more
505:02 - specific view than a general review so
505:04 - you don't need to define the primary
505:07 - Constructor
505:08 - and you put the curly braces
505:11 - now I want to override the draw
505:13 - functions so that when the draw when the
505:15 - draw function is called I want to not
505:18 - drawing just a generic view but to draw
505:21 - a button of course as I said this is
505:24 - just an imaginary example so we type
505:27 - overwrite fundra
505:29 - and instead of calling the super
505:33 - function which is inside our
505:36 - our Base Class View or parent Class View
505:39 - I'm gonna type here print line
505:46 - and we're gonna put the text drawing
505:50 - the
505:51 - button
505:53 - of course and now what we did here we
505:56 - created the generic view as I said and
505:58 - again this can have hundreds of maybe
506:02 - thousands of line of code and functions
506:04 - and different functions different
506:05 - properties
506:06 - but we we inherited from The View class
506:09 - and we added some new functionality so
506:12 - instead of just drawing a generic view
506:14 - now of course we just add a simple print
506:16 - line here but here you can have the code
506:18 - which is going to be responsible for
506:20 - drawing a speed a button so it's going
506:22 - to be more specific than a simple
506:24 - generic view so you can put here a here
506:27 - is the code
506:29 - for
506:30 - creating
506:32 - the button so I'm going to put the
506:34 - Commander and let's say that
506:37 - now I want to create a run around button
506:40 - so instead of creating again all that
506:43 - functionality which which is present in
506:46 - the view and then create and then use
506:49 - and then creating all the functionality
506:51 - which is uh inside the button the button
506:54 - class we can make this button uh open
506:57 - and we can inherit all the functionality
507:00 - that the button provides and we're gonna
507:03 - add something new something unique to
507:06 - this class that we're going to create
507:07 - and this class is going to be a round
507:08 - button so we type here round
507:11 - button
507:13 - and here you need to define the text
507:16 - because we're going to inherit from the
507:19 - for the from the class button
507:21 - orientation and notice that I don't use
507:24 - the VAR or the VAR keyword here because
507:26 - they they're going to be only parameters
507:28 - because the properties the actual
507:30 - property is going to be are going to be
507:32 - um
507:33 - ultimately declared
507:35 - in the button class
507:37 - and
507:39 - one thing which is going to be specific
507:41 - to a round button that you're going to
507:42 - create is going to be Corners so we type
507:45 - Val corners
507:49 - it was gonna be an integer because the
507:52 - the corners basically here are going to
507:54 - pass a value which is gonna in our
507:56 - marginal example this is going to
507:58 - receive a value which can be
508:01 - um in degrees so how many degrees do you
508:03 - want to how many degrees you want to
508:04 - make the buttons by how many degrees you
508:07 - want to make the button around so it can
508:09 - pass here 20 or 30 anyway so we put
508:12 - colon here and we inherit now from our
508:14 - button
508:15 - class
508:17 - right and here you need to pass the
508:21 - text
508:24 - the orientation
508:27 - and that's all
508:28 - and you put calibrases now let's
508:30 - override the draw function in our round
508:33 - button because when that function is
508:35 - called now I want to add some specific
508:37 - code some new functionality which is
508:40 - specific to a round button so it's not
508:42 - gonna draw just a button but it's gonna
508:46 - draw a round button so we of course
508:49 - we're just going to add the simple print
508:51 - line there but um
508:53 - in a real app you can put here the
508:55 - actual cottage which is gonna draw the
508:57 - round butter so we put here print line
509:03 - and we put
509:05 - rowing
509:07 - the round
509:09 - button
509:11 - now let's create some instances let's
509:13 - create some objects with those classes
509:15 - and we type here
509:19 - Val view so we're going to create our
509:22 - generic View
509:24 - we Define the battery Constructor we
509:25 - don't have to pass any values there
509:27 - because we didn't Define any properties
509:29 - inside our view
509:31 - then we create a button so we put here
509:35 - Val
509:37 - button
509:39 - equals button
509:44 - and you don't need to pass some value so
509:46 - I'm going to pass here the text let's
509:47 - say login
509:49 - the orientation let's say yo
509:52 - it's going to be a text here so we put
509:54 - here let's say Center
509:58 - next we create a new
510:01 - a new object but this is going to be now
510:02 - a run around the button so we put around
510:06 - button
510:07 - equals round button
510:11 - and you pass the text here round
510:14 - button
510:18 - actually let's pause it takes uh sign up
510:25 - and uh
510:27 - for the orientation let's put
510:33 - Center also
510:36 - lo you need to pass also value from for
510:38 - the colors let's put let's say 30
510:40 - degrees it will be
510:42 - in our imaginary example now let's call
510:45 - the function the function draw on all of
510:49 - our objects that we create so we type
510:50 - view dot draw
510:53 - then we put button
510:57 - dot draw
510:58 - and round button
511:05 - dot draw now if you
511:08 - just press Ctrl Z
511:10 - if you run this code
511:36 - so we get in the output drawing The View
511:39 - then we get drawn in the button drawing
511:41 - The View again drawing the round button
511:43 - and let's uh think about why you have
511:46 - this output so first we see that we have
511:49 - drawing The View which is the function
511:51 - inside our view that you created here so
511:54 - it's from the generic view so it's
511:55 - drawing The View then we have drawing
511:58 - the button so
512:01 - here
512:01 - when this line of code is uh red it says
512:04 - drawing the button so you have
512:07 - we have our we have our code which is
512:09 - you know which is with just a print line
512:12 - but uh so this is drawing the the button
512:16 - then it's calling the super function so
512:18 - it's calling the function inside the
512:19 - view which it says drawing The View
512:22 - next
512:23 - when this line of code is red so round
512:27 - that round button that draw now it's
512:29 - calling the draw
512:31 - function which is inside the round
512:33 - button so instead of just now calling
512:36 - the because now we are inheriting from
512:39 - the button class
512:40 - now uh we override this function here
512:43 - and it's it's uh using our
512:45 - implementation for creating a round
512:47 - button it's uh executing this line of
512:50 - code and then it's calling the super
512:52 - implementation which is drawing the
512:54 - button you can actually remove this if
512:56 - you want because you let's say that
512:58 - calling the code inside from the button
513:02 - is not gonna affect our logic so if I
513:06 - delete this now if you run this code
513:17 - now we have drawing the view drawing the
513:21 - button and we have drawing the view
513:23 - drawing the wrong button so now it's not
513:25 - calling here the super so it's not it's
513:27 - not calling the code which is inside the
513:30 - for the bottom because we are inheriting
513:32 - first from the button but but the button
513:35 - is also inheriting from The View so it's
513:37 - calling first this then it's calling
513:39 - draw which is inside here and we have
513:42 - the round but now we only have drawing
513:44 - the wrong button because here now it's
513:47 - using our own implementation of the draw
513:49 - so we have drawing the round button
513:52 - so buy this just by
513:55 - by making our view because as I said in
513:58 - real app this view is can have hundreds
514:01 - of maybe thousands of line of code of
514:03 - different functions and properties so
514:05 - you don't want to create all of that
514:07 - from zero when I want only to let's say
514:10 - I want to create a button I can't
514:12 - inherit I can inherit from The View
514:14 - which already provides all the functions
514:17 - and properties and logic to create a
514:19 - generic view but I can override some
514:21 - functions which are responsible let's
514:22 - say for like this draw and I can ex I
514:27 - can Define some logic and when all of
514:30 - that functionality is called It's Gonna
514:31 - not draw only a generic view but it's
514:33 - gonna draw a button so by inheriting
514:36 - from The View we increase we increase
514:39 - code the code reusability
514:41 - and this is very very powerful because
514:43 - let's say that uh like in our example
514:47 - you want to you don't you're not
514:49 - satisfied with the simple button which
514:51 - is used in Android and you want to
514:53 - create a draw a round button so instead
514:55 - of creating all of that logic from zero
514:58 - you can just inherit from a simple
515:00 - button you can have override some
515:03 - functions and when when you execute that
515:06 - quad now it's gonna execute the code
515:08 - with the implementation with the
515:10 - additional implementation the with the
515:13 - additional code which is which is gonna
515:15 - generate a round button and it's just
515:17 - not just a simple button so this is our
515:20 - this is our discussion about inheritance
515:23 - I hope that this clarifies some things
515:26 - and see you in the next video
515:31 - so now it's time to start a discussion
515:33 - about seal classes so often you want to
515:36 - represent only a fixed set of
515:37 - possibilities so however case can either
515:40 - success or it can fail a user can be a
515:43 - standard user or a pro user and in those
515:45 - cases you may be thinking now that you
515:47 - can use enum classes but enumclasses
515:49 - have some limitations and let's see why
515:52 - you should use instead seal class so
515:54 - let's type Main
515:55 - I'm going to create a in on class here
515:57 - call it the result
516:01 - and let's put curly braces unless I hear
516:05 - success
516:10 - and the error
516:14 - now the problem with this is that we
516:17 - cannot encode more information here so
516:19 - let's say that I want to to to Define
516:22 - here a non-resolvable resolver error and
516:26 - resolver error and I cannot do that here
516:30 - so if I type here x dot exception I can
516:33 - I cannot do that because
516:36 - um the the the the types that are
516:39 - defined here cannot have properties so
516:41 - you cannot Define this here and for that
516:45 - we need to use seal classes and to use
516:47 - the seal class you just type seal class
516:51 - I'm going to call it result
516:53 - it's going to have a parameter called
516:55 - Val message it's going to be of type
516:58 - string
517:00 - and you can Define your uh
517:03 - classes which are gone inherit from the
517:05 - seal class either outside the seal class
517:08 - so you can Target class let's say
517:10 - success
517:13 - and let's type here
517:16 - meh
517:18 - message of type string and we can
517:20 - inherit from the seal class so you can
517:23 - type here result
517:26 - message
517:30 - or you can copy this and you can Define
517:33 - it inside the enumclass so you can have
517:36 - it as an SSC class so I'm going to type
517:38 - another class here called
517:41 - error
517:45 - foreign
517:51 - the parameter here
517:54 - actually not
517:55 - that is the parameter
517:59 - message
518:18 - foreign
518:25 - the parameter here
518:28 - message I'm gonna hit it from the result
518:31 - you know from the results class
518:34 - I'm gonna pass that parameter here
518:37 - to the parent class
518:41 - now
518:43 - I'm gonna Define a function down here
518:45 - called get data fun get data and it's
518:49 - gonna have
518:51 - a parameter called the result
518:56 - it's going to be of type result
518:59 - and here you're going to define a when
519:01 - statement so we type when
519:04 - the type result and now is the
519:06 - interesting part
519:08 - now if you hover over this underline
519:11 - over when it says when expression must
519:14 - be exhaustive unnecessary is error
519:19 - comma is Success branches or else Branch
519:22 - instead so in other words what is saying
519:25 - here by uh
519:27 - to have the one statement exhaustive
519:30 - it's it's what it's saying another word
519:32 - is that it needs to cover all the
519:35 - possibilities so both possibilities that
519:37 - we have here and you can type yourself
519:40 - this or you can click on here click on
519:43 - this right bulb and you can click here
519:45 - add the remaining branches and as you
519:47 - can see it's added the remaining browser
519:49 - you add is result. error and easy result
519:53 - does success and those are exhausted
519:56 - those are the only two possibilities
519:58 - which are
520:00 - which are possible so here I'm gonna
520:02 - type result
520:04 - let's define a function inside the CL
520:06 - class so I'm going to type here fun
520:09 - show
520:10 - message
520:15 - it's gonna have a print line which is
520:18 - going to say result
520:23 - dollar sign
520:28 - message
520:31 - so and now I'm going to put dot
520:34 - show message and also here result
520:38 - dot show message and now this is
520:43 - uh this is uh exhausted because now we
520:47 - call we covered all the possibilities
520:51 - which which are uh inside the which are
520:56 - as a consequence of the fact that we our
521:00 - classes are uh inheriting from the seal
521:03 - class so if I add here an uh else Branch
521:08 - so if I put here else as you can as you
521:11 - you'll see this is going to be redundant
521:13 - because we covered all the possibilities
521:15 - and the compilers know this and this can
521:18 - be very useful in some scenarios
521:20 - so if I put calibrations as you can see
521:22 - this is gray out because it's redundant
521:25 - because it knows that we covered all the
521:28 - possibilities and the possibilities are
521:30 - only those two result that error and
521:32 - result are success so if I type here now
521:36 - success let's type success
521:41 - equals
521:44 - result
521:46 - bo2s there
521:49 - equals result dot success
521:53 - let's type success here
522:00 - let's press Ctrl D let's call this error
522:08 - result let's change this to error so
522:11 - this is how you create instances of the
522:17 - nested classes let's call this failed
522:24 - now let's type here get data down here
522:28 - get data and let's let's pass success
522:31 - and let's run our code now as you'll see
522:34 - the message
522:35 - result success
522:50 - so we get results success in the output
522:52 - so
522:54 - if I change now this to error you will
522:56 - see that this is the result error
522:58 - because it is executing this branch
523:01 - so if I run this
523:08 - to get result failed
523:10 - now the interesting part here is if I
523:13 - add here another
523:16 - possibilities so
523:19 - if I type here class
523:21 - progress
523:23 - and I type message
523:26 - string inheriting from result
523:29 - let's type let's pass the message
523:31 - parameter to the super class to the
523:33 - parent class
523:35 - now what what we have because our class
523:38 - is a sealed class what we have here is
523:41 - that the when is underlined and is
523:43 - trying to say something to us is saying
523:45 - that when expression must be exhaustive
523:47 - unnecessary is progress so it knows that
523:50 - there is another possibility for uh for
523:54 - our result uh we it can be therefore you
523:59 - need to add that possibility otherwise
524:01 - I'm going to show you this order and if
524:03 - you try to compile this code I'm gonna
524:04 - throw an error so what what you can do
524:08 - here is can we can type here is a result
524:11 - to make it exhaustive so to cover all
524:14 - the possibility result of that progress
524:19 - let's put Arrow
524:22 - result dot show message
524:26 - and now if I create here another Val
524:28 - let's call this uh
524:31 - progress
524:33 - because the result dot progress and
524:37 - let's define for the parameter
524:44 - progress here
524:47 - now if I change this to progress
524:51 - now you'll see the output result
524:53 - progress
524:59 - so we get result progress because
525:02 - now this branch is true but if I let's
525:07 - if I delete all of those look what
525:09 - happens if I click here or is where you
525:13 - have those on this underline it says add
525:15 - else Branch so when expression must be
525:17 - exhausted so it means that it needs to
525:19 - cover all the possibility
525:21 - possibilities are necessary is error is
525:24 - progress and is Success so if we click
525:26 - here on more actions
525:28 - and if you click here on ADD remaining
525:30 - branches it it knows that those are all
525:34 - the possibilities on which our result
525:37 - can be and it automatically generated
525:40 - the
525:41 - the check for us and we we only just
525:45 - need to type here result
525:47 - not show message and that's all and with
525:50 - tnumps you you don't have this
525:53 - auto-generated code for you because uh
525:58 - I'm gonna explain immediately
526:03 - so with with an enum if you add another
526:06 - so if you have a Nemo class I can delete
526:11 - the code now here because
526:13 - but I'm going to keep the code as it is
526:15 - and because all the subclasses of excel
526:18 - class are known by the compiler the
526:20 - compiler can fill all the possible cases
526:23 - automatically for us if I declare this
526:25 - Arrow class as a seal class and I
526:28 - declare two classes inside here called
526:30 - let's say class
526:33 - resolvable error so or recoverable error
526:42 - and it's going to have a parameter
526:43 - called exception it's going to be of
526:46 - type exception
526:48 - this one
526:52 - and we're going to extend from our error
526:55 - seal class
526:57 - not this one
527:00 - this one
527:01 - and we're going to pass the message
527:02 - parameter
527:06 - and I'm going to declare another class
527:09 - non-recoverable
527:15 - and it's going to have an exception
527:19 - so this is more powerful than
527:21 - in arms because you can have all those
527:24 - properties and you can you can have
527:27 - subtypes and and all of this and within
527:30 - arms we cannot do this so let's extend
527:32 - from error
527:35 - let's pass the message
527:38 - and now I need to delete this because we
527:40 - cannot instantiate The Shield
527:43 - class so let's delete this
527:47 - now if I delete this now from here look
527:50 - what happens I have an underline and it
527:52 - says
527:54 - add
527:55 - it says one expression must be
527:57 - exhaustive so it must cover all possible
527:59 - cases that that exists for this cell
528:03 - class unnecessary is not recoverable or
528:07 - is recovered or branches so if I click
528:10 - on this and I click on this bulb I click
528:13 - here add remaining branches as you can
528:16 - see it adds all the possible cases so
528:18 - all the possible cases that we Define
528:20 - inside our seal class for us
528:22 - automatically
528:23 - and we just type your result
528:27 - dot show message
528:30 - again here result
528:32 - message and you cannot have this
528:35 - Behavior with the non-class so this is
528:37 - why still classes are more powerful
528:39 - because they can have subclasses you can
528:42 - have
528:43 - more information on the classes so you
528:45 - can have exceptions passed to them and
528:47 - so on so
528:49 - this is our discussion about seal
528:51 - classes and see you in the next video
528:57 - so now it's time to start a discussion
528:58 - about abstract classes and to show you
529:00 - what abstract classes are I'm going to
529:02 - use the code that you had in our
529:04 - discussion about inheritance but I'm
529:06 - going to change it a little bit so I'm
529:08 - going to delete for this class plane
529:09 - because you don't need this class and
529:13 - I'm gonna
529:16 - I'm gonna delete this instances that we
529:18 - have here
529:22 - and I'm going to declare this as a VAR
529:25 - and this also has a VAR so they're gonna
529:27 - be now properties
529:29 - I'm gonna delete the properties that we
529:31 - have here
529:33 - and uh
529:35 - now we have this here so I'm gonna
529:37 - delete these two
529:39 - let's delete this
529:41 - let's delete this
529:43 - now
529:45 - what are abstract classes
529:47 - um abstract classes are very similar to
529:50 - interfaces the only difference is that
529:52 - in abstract classes you can declare
529:54 - properties which can have a value and
529:57 - you know in interfaces you can't
529:59 - actually you can but you you need to
530:02 - provide an access modifier
530:04 - and to declare an abstract class we go
530:07 - in front of the class that you I want to
530:10 - make it abstract and we type the
530:12 - abstract keyword
530:14 - let's put the class keyword
530:18 - and now our class is abstract and with
530:21 - an abstract class you cannot create
530:22 - instances abstract classes are created
530:25 - only to be inherited from uh by other
530:29 - classes and now if I try to create an
530:31 - instance with this abstract class and I
530:33 - just type Val vehicle
530:37 - and we type vehicle here and we put the
530:40 - parenthesis to call the go to the
530:42 - Constructor
530:43 - you have an error here and says cannot
530:45 - create an instance of an abstract class
530:46 - so you cannot create an object with an
530:48 - abstract class an abstract class can
530:50 - only be inherited by another class and
530:54 - abstract classes usually are used like
530:58 - interfaces when you want to provide
531:00 - what you need what needs to be done but
531:03 - you don't provide how it's going to be
531:05 - done so you can you need abstract
531:07 - classes are used when you define
531:09 - uh functions without the body and the
531:13 - code the body and the code is uh it's uh
531:16 - implemented it's provided by the class
531:18 - by the class which inherits from the
531:21 - abstract class so they are as I say
531:24 - similar very similar to interfaces the
531:25 - only difference that in abstract classes
531:27 - you can have properties so you can have
531:29 - here a Val
531:31 - text
531:33 - and you can assign here some text in uh
531:36 - in an interface you cannot do this let's
531:38 - type some text
531:39 - so this is the difference and uh
531:42 - also
531:44 - um you I should say that um
531:47 - you can Implement many as many
531:50 - interfaces as you want
531:52 - but in a class but you can only inherit
531:55 - from a single class right this I forgot
531:58 - to say when I talked about the
531:59 - interfaces now
532:01 - if I want to make uh if I want to if I
532:05 - to make now our functions abstract you
532:08 - just type the keyword abstract in front
532:10 - of them and now they are abstract and
532:13 - we're gonna do the same for our stop
532:15 - function but now we have this underline
532:18 - because as I said abstract functions
532:21 - like interfaces or the functions which
532:23 - are defined in the interfaces cannot
532:25 - have a body so we need to delete this uh
532:28 - you need to delete the body you need to
532:30 - delete the curly braces Because the
532:31 - actual body the actual logic and the
532:34 - code is going to be provided by the
532:35 - class which uh in head is from the
532:38 - abstract class now
532:39 - to inherit from an abstract class we go
532:42 - here
532:43 - we put colon and we type the name of the
532:46 - abstract class from which you want to
532:47 - inherit vehicle
532:49 - now
532:51 - if you go out here now we have this red
532:54 - bar which says
532:57 - so need to call the Constructor here
533:04 - all right actually I think I can delete
533:06 - this but you still you still need to
533:08 - call this Constructor here even though
533:09 - we don't have any any parameters any
533:13 - even though we didn't even Define The
533:15 - Constructor here now we need because
533:19 - like the interface the abstract class if
533:22 - you inherit from an abstract cluster and
533:24 - if that abstract abstract class has some
533:26 - abstract abstract functions defined in
533:28 - it you need to implement those functions
533:31 - inside your class and you go here when
533:33 - you have this underline if you click on
533:35 - this right red bulb and it says
533:37 - Implement members order make car
533:40 - abstract and we click on Implement
533:43 - members we select our two functions we
533:45 - click ok
533:47 - and now we have our functions
533:49 - implemented inside our class
533:51 - so this is what
533:54 - Astra classes are and they are as I said
533:57 - very similar to interfaces but the only
533:59 - difference is that you can Define in
534:01 - properties inside the an abstract class
534:03 - and you can provide the value to that
534:05 - property and here because we we have
534:10 - inherited from our abstract class here
534:12 - you can provide the actual
534:13 - implementation of the functions so as
534:15 - you can see we have this to do which
534:17 - says not yet implemented so they are
534:20 - they are very similar to interfaces
534:23 - so I'm gonna end this video now and see
534:25 - you in the next video but before I end
534:27 - the video I saw that it's a good idea to
534:30 - to say to you where abstract classes and
534:33 - interfaces are used uh interfaces that
534:36 - are using many many places but um
534:39 - abstract classes are particularly used
534:42 - when uh and also interfaces are used
534:46 - when you have some apis and those apis
534:49 - want to just to define the functions and
534:52 - the API is going to generate the actual
534:54 - code for uh for those function so you
534:57 - can have a let's say a database
534:59 - and you can provide the the name of the
535:02 - functions which are responsible for
535:03 - creating the database for getting
535:06 - getting data from the database but you
535:09 - don't provide the actual code which is
535:11 - gonna select that data from the database
535:13 - and return the data you just you just
535:16 - declare your functions as as the
535:18 - abstract
535:19 - and the API is going to generate all
535:22 - that code which is responsible for uh
535:25 - returning the data and from the in other
535:28 - words the API is going to do all the
535:30 - hard work you just you you just Define
535:32 - the the functions if you have if you
535:36 - let's say if you have a property Define
535:37 - an abstract class in the abstract
535:39 - functions or interfaces and the API is
535:42 - going to do the hard work of uh based on
535:45 - what your function is doing by
535:48 - editing the name of the function is
535:50 - going to generate all that code which
535:52 - you you've you've had to generate if you
535:56 - do if you don't have if you're not
535:58 - before the API to generate that for you
536:00 - so this is where uh interfaces and after
536:04 - classes are sometimes used and the
536:07 - interfaces also are used in event
536:10 - handling and that is one in one um uh
536:14 - the you need to write code to respond to
536:17 - respond to respond to graphical using
536:20 - using your interface uh movements
536:25 - so I'm gonna end the video now see you
536:27 - next
536:29 - so now it's time to start a discussion
536:31 - about data classes but in order to
536:32 - understand what data classes are we
536:34 - first need to understand what is the
536:36 - difference between structure equality
536:37 - versus referential equality
536:39 - and to restart the difference I'm going
536:41 - to create two variables the first one is
536:43 - going to be a Val it's going to be
536:44 - called name one
536:46 - and we're gonna assign the
536:48 - follow Alex three so it's going to be of
536:50 - type string
536:51 - now I'm going to press Ctrl D to
536:53 - duplicate that line of code
536:55 - and to declare the second variable which
536:57 - is going to be called name two and it's
536:59 - also going to have the value RX
537:01 - now I'm going to add the printerland
537:03 - here to output something to the console
537:05 - and here we're gonna type name one
537:07 - equals equals
537:10 - name to
537:11 - so the equals to operator is doing what
537:14 - is called is checking for structural
537:17 - equality because it's checking to see if
537:20 - the content of the variable name 1 is
537:22 - the same with the content of the
537:23 - variable name too so another loss is
537:25 - checking to see if they have the same
537:26 - value and it's they have because both
537:30 - have Alex assigned to them so now if I
537:32 - run this code
537:33 - because this is a Boolean expression
537:35 - this is going to return true or false
537:37 - and we're going to see in the console
537:39 - too
537:40 - but if I change this to Alexandro now
537:43 - the variable name 2 has a different
537:45 - value so this is going to return false
537:47 - because they are not structurally equal
537:50 - their content is different they have
537:52 - different values
537:55 - now get false and this is called the
537:58 - structure equality
537:59 - the next type of equality is called
538:02 - referential equality and the reference
538:04 - equality is used when you want to check
538:06 - if two variables or two objects are the
538:09 - same so what the referential equality
538:13 - operator is doing is checking to see if
538:16 - a tool as I said variables or
538:18 - objects are the same so if I type here
538:20 - name one
538:22 - and to use the the reference we call it
538:25 - operator we put three equal sign here
538:27 - and if I type here name one equals name
538:29 - one so is name one equals to itself that
538:32 - is going to be true
538:34 - so you're gonna see through on the
538:36 - console
538:37 - outputted so we have two but if I change
538:40 - name one equals equals equals to name
538:43 - two that is going to return false
538:46 - because they are distinct objects in
538:48 - memory they are different uh variables
538:51 - they are not the same there is the name
538:55 - one
538:56 - name one variable is not the same
538:57 - variable as name two so we're gonna have
538:59 - false here
539:00 - so we have false so this is the
539:02 - difference between a structural versus
539:04 - referential equality so now I'm going to
539:06 - close this
539:08 - I'm going to close the console
539:10 - and having this in mind we're going to
539:12 - start a discussion about data classes
539:15 - so let's go down here and let's create
539:17 - our user class because I want to compare
539:21 - to user objects to see if they are
539:23 - structure equals so you type user let's
539:25 - define the primary Constructor and let's
539:27 - define three properties for the primary
539:30 - Constructor the
539:31 - first name
539:36 - the last name
539:39 - and the age
539:46 - which is going to be an integer
539:48 - now if I want to check if to
539:51 - user objects are a star vehicle let's
539:53 - first create those objects so let's
539:55 - delete this code
539:59 - let's say Val user1
540:02 - equals now let's create our object and
540:04 - let's pass some values to the
540:06 - properties of the Constructor let's pass
540:08 - here Alex
540:13 - for the last name let's put open
540:16 - and for the age 23.
540:19 - now let's press Ctrl D to duplicate that
540:21 - line of code and to create the second
540:23 - user object let's give a different name
540:26 - to this user too
540:29 - now go down here let's press Ctrl alt
540:33 - alt for mother code
540:35 - we typed our println because I want to
540:37 - check to see if our users objects are
540:39 - equal
540:40 - if they are structurally equal so we
540:42 - type here user1
540:43 - equals equals so the equals to operator
540:46 - user 2.
540:48 - now if you run this code what do you
540:51 - think you're going to see in the output
540:53 - what you're seeing the output is
540:54 - actually that you'll get
540:57 - we get false and you may be wondering
541:00 - why because if you think about the air
541:01 - structurally because they have the same
541:03 - values for the properties but they are a
541:05 - distinct objects but we said previously
541:09 - that the equals
541:11 - equals uh two equals operator is
541:13 - checking for uh structure equality so
541:15 - why get false here
541:17 - this is because previously the equals to
541:20 - operator is
541:22 - it was checking to see if the two
541:25 - strings are structurally equal and the
541:27 - equals to operator is actually
541:30 - a function which is defined inside the
541:33 - any class and the string class what
541:35 - actually was doing when we called the
541:37 - equals to operator
541:38 - it was using its own implementation of
541:42 - the equals method so
541:45 - uh every class that we create in kotlin
541:49 - it's using its implicitly inheriting
541:53 - from the any class and because every
541:54 - class that we created it's implicitly
541:56 - inheriting from the any class
541:58 - every class is also going to use the
542:01 - functions which are inside the any class
542:03 - so if you don't override those functions
542:06 - inside your class to provide your own
542:08 - implementation like the string class did
542:10 - for our strengths then it's going to use
542:12 - the implicit uh the font is going to use
542:16 - the function which inside which are
542:17 - inside the any class and
542:20 - if you type here user1 that and we have
542:24 - equals to string and hashcode those
542:26 - three but those three functions we are
542:28 - particularly interested and the
542:30 - particular one is interested inside the
542:32 - equals they perform when you don't
542:34 - Implement inside your own class those
542:37 - functions
542:38 - again particularly on Bay course class
542:40 - the equals class spin forums only a
542:43 - referential equality so it only checks
542:45 - if those two users
542:46 - are the same users and if they're not
542:49 - that's gonna it's gonna return false so
542:52 - this is why you get false here because
542:53 - it's calling the function the function
542:56 - which is inside any class so what you
542:58 - have implicitly is something like this
543:01 - so for any class that you you use or for
543:03 - any class that you declare
543:05 - you have implicity inherited from the
543:07 - any class and because of that you have
543:10 - those
543:11 - three functions which
543:13 - are defined and if you don't override
543:15 - them to provide your own implementation
543:17 - then it's going to use the code that's
543:19 - inside there so actually if you press
543:21 - Ctrl here
543:23 - and if you
543:24 - click it takes us inside the any class
543:27 - so it's clear that this function
543:30 - the equals function is inside any class
543:33 - so because we don't have any functions
543:36 - here so we need to override that
543:37 - function inside our class and we need to
543:39 - provide our own implementation to Define
543:40 - our own code to determine if two user
543:44 - are one of when two users are slash
543:46 - legal this is what you're going to
543:48 - Define inside our class so let's delete
543:51 - this
543:53 - let's pull the curly braces and actually
543:55 - I'm gonna bring an image to show you how
543:57 - the quarter and hierarchy actually looks
544:00 - so this is the image and at the top as
544:02 - you can see we have the any class and
544:04 - then we have our Boolean class our
544:06 - string class and then we have our user
544:08 - class and all of those classes I have
544:10 - here the Boolean the string the number
544:12 - they are inheriting from the any class
544:14 - they are
544:16 - using the the functions which are
544:18 - defined inside the any class and they
544:21 - override the they are overriding those
544:23 - methods inside them and they are
544:25 - providing their own implementation for
544:27 - those functions and this is what we need
544:29 - to do also here as you can see they will
544:31 - inherit from the any class implicitly so
544:34 - we need to override them to provide our
544:36 - own implementation for the equals and
544:39 - for the next two because we're going to
544:40 - look at also at the
544:42 - as you saw there you are going to look
544:44 - also at hash code because uh equals and
544:46 - hash code are very linked together and
544:49 - also the two string function
544:51 - so we need to override those uh inside
544:53 - our class
544:54 - so this is what we're gonna do
544:57 - so we go inside our user class and here
544:59 - we need to override the equals function
545:01 - when we type overwrite and while I'm
545:03 - dumping you can see that we have three
545:05 - suggestions here and we select the user
545:07 - function because this is the one that we
545:09 - are interested in and as you can see
545:11 - here
545:12 - this function is part of the any class
545:15 - so we press enter we delete the super
545:18 - return
545:19 - and the first thing that we need to
545:20 - check is to see if the current instance
545:23 - the current object that on which this
545:25 - equals function is called it's comparing
545:28 - with its cell so we need to check if the
545:33 - the if the object is the same as the
545:36 - object that we are comparing with and to
545:38 - do that we type here if this
545:41 - so if this current object is current
545:45 - instance equals equals so three equals
545:48 - we check for referential equality to see
545:50 - if they are the same equals
545:53 - other so
545:56 - we type other and if that is the case if
545:59 - we call we are comparing the same object
546:02 - so you have user one equals user one
546:05 - then gonna return true because that
546:08 - means that uh we are comparing uh with
546:11 - the same object if that is not true then
546:15 - the next thing that we need to check we
546:17 - we're gonna go down here so if not we're
546:21 - not comparing with uh it's not comparing
546:23 - with itself then we need to check if the
546:27 - other so the object which is passed as
546:29 - an argument to this function which is
546:31 - called on another object
546:34 - and to check if other so the argument
546:37 - is user because we we can uh we need to
546:42 - check the expressly to see if this
546:44 - object which is passed as an argument to
546:46 - our equals function is an user object
546:49 - because we don't want to check for a
546:51 - different object we need we need to to
546:53 - see if this is a new zero object so only
546:56 - if the object which is passed as an
546:58 - argument to the equals function is an
547:01 - user object then we're gonna
547:04 - return true so here you need to type now
547:07 - we need to determine we need to Define
547:09 - our Logic for what it means for two
547:11 - users to be equal and it's up to you how
547:15 - we Define this implementation I'm going
547:16 - to type here only return so I'm gonna my
547:20 - logic is if they have the same first
547:23 - name the same last name and the same age
547:25 - we're gonna say that they are equal we
547:28 - have the same user of course that in a
547:30 - real app you can have a more complex
547:32 - implementation so we type here return
547:34 - this so This current instance that first
547:37 - name so
547:39 - and then put two equals other so
547:43 - if so the other is because we check here
547:46 - explicit to see if this is another also
547:48 - because this condition is going to only
547:51 - pass if the other
547:54 - argument is unusual so we type other
547:57 - because we have access to the first name
548:00 - and the last name and the age if other
548:02 - DOT first name so this is our first
548:06 - condition and
548:10 - this Dot
548:14 - this dot last name
548:18 - so I'm going to check for the all uh for
548:21 - our three properties
548:23 - equals equals other so other is another
548:25 - object because we determine that here
548:31 - that last name
548:33 - and
548:37 - this dot age equals equals H so this
548:42 - entire expression that is that we have
548:44 - here is gonna return through only or if
548:47 - all the our three conditionals so if
548:49 - this DOT first name is equal to other
548:51 - that first name so with the object that
548:53 - is passed as an argument or equals and
548:55 - if this data last name is equal to other
548:58 - that last name and if this dot h is
549:01 - equal to
549:02 - the other that age let's put here
549:07 - then and only then we're gonna have a
549:10 - true here so it's going to return
549:11 - through otherwise if one of those
549:14 - condition fails it's gonna return false
549:17 - and down here you need to if other let's
549:20 - say doesn't pass so if other reason is
549:23 - not an user we're gonna return false so
549:27 - in that case going to turn false now if
549:30 - I run this code look what happens
549:34 - so previously we had the false and now
549:37 - we have true here and this is because
549:40 - now it's using the equals function which
549:43 - is inside our user class so it's using
549:46 - our own implementation so it's checked
549:49 - here to see if uh our
549:53 - first name is equal to other DOT first
549:55 - name so it's checking uh so it's using
549:58 - our logic inside the the equals function
550:02 - so this is why you get true and you can
550:05 - also you can now if you press if you
550:08 - hold Ctrl here as you can see now it's
550:11 - taking us inside the equals method that
550:13 - we defined here it's not taking it
550:15 - inside the ionic class this is because
550:17 - now it's using our own implementation so
550:19 - first to check to see if we are dealing
550:21 - with the same object then we're going to
550:24 - return true you're not going to go any
550:27 - any we're not going to go down and if
550:30 - this is false you're gonna come up here
550:33 - you're gonna check to see if other the
550:34 - object which is passed or equals
550:36 - function is an user instance it's an
550:39 - user object then I'm gonna check to see
550:41 - if our current object that we are
550:44 - calling on the sqls
550:46 - function is equal which exclusive for
550:49 - the first name there is the same we
550:51 - check to see if the last name is the
550:53 - same and we check to see if the age is
550:54 - also the same then in that case it's
550:56 - going to return true and we're gonna say
550:58 - that they are structurally equal so
551:00 - we're gonna see through in the output
551:01 - else if other is not an user so if you
551:04 - pass
551:06 - to the function argument the different
551:08 - parameter a different argument here
551:10 - let's say you pass an integer then it's
551:12 - going to return false here we're going
551:14 - to come down here so now if you look
551:17 - here you may be wondering how this
551:18 - syntax works so we have those signs but
551:20 - it's calling the equal smart function so
551:23 - you can also put that equals if it makes
551:26 - more sense and if we put that equals
551:29 - user so
551:31 - so uh
551:33 - now you can see that but if you hover
551:36 - over he says replace with the two equals
551:39 - so it's the same thing as having that
551:40 - equals and
551:42 - passing that argument here which is user
551:45 - two so again we are invoking uh the
551:48 - equals method on the user one object
551:51 - let's press Ctrl J
551:53 - and we are passing our user to objects
551:56 - and we are using our logic that we
551:58 - Define here to determine if they are
552:00 - equal
552:04 - and you can replace this back to to
552:06 - equals or if it makes more
552:10 - visual sense to put the to use the
552:12 - equals you can use equals it's the same
552:14 - thing
552:16 - we put user to here
552:20 - so as you can see we are calling the
552:23 - function so this means this object so
552:26 - this object so defined here this if uh
552:30 - when we're saying this that first name
552:32 - it we we mean this object so if this is
552:36 - that first name it's equal with the
552:39 - other other that first name it's then we
552:42 - are calling this object that is passed
552:44 - here as an argument so
552:47 - um next we will look we're going to look
552:49 - at the next two functions because as I
552:52 - said the equals and hash codes are very
552:54 - linked together and we're going to also
552:56 - look at the the two string function and
553:00 - now if I change the first name for the
553:04 - user 2 to join and if I run this code
553:07 - you will get false in the output because
553:09 - when it will come inside this if it will
553:11 - check to see if this does first name
553:13 - equals to other at first name and
553:15 - because we're using the end operator and
553:17 - all the conditions have to be true this
553:19 - is going to return false so I get false
553:20 - in the output
553:22 - and um
553:24 - but if I change it back to Alex
553:28 - we'll have
553:30 - true so the objects are structurally
553:33 - equal based on the logic that we defined
553:35 - here
553:37 - inside our equals function
553:40 - and as I said you also
553:43 - you can also look at equals and hashcode
553:45 - because they are very linked together
553:47 - and uh
553:48 - the rule is whenever you override equals
553:52 - you also need to override the the
553:54 - hashcode and if two objects are
553:56 - comparing equal so if they are equal
553:58 - based on the equals method that you
554:00 - implemented they also have to have the
554:03 - same hash code
554:04 - and I'm not going to go into that but
554:08 - this is because they are
554:11 - the hash code is used for performers
554:13 - reasons in collections but we're not to
554:16 - go now into that we can just type here
554:19 - override
554:23 - and uh
554:24 - here we just type return zero and this
554:27 - uh this is not gonna affect our equality
554:29 - at all as I said this hash code it will
554:32 - make it makes more sense to implement
554:34 - the hash code in a different way in
554:36 - collections because they are used um for
554:39 - performance reasons particularly with
554:41 - hash set and hashmobs
554:43 - but uh for now for our simple class
554:47 - because we don't use this class inside
554:49 - any collections we don't need because uh
554:52 - we don't uh don't have to think about
554:55 - that per the performance reasons to of
554:58 - the hashcode and uh just if you want to
555:01 - just uh just return zero here like I
555:03 - return and yeah because it would work
555:05 - fine it's not it's not going to affect
555:06 - at all our equality but remember that
555:09 - rulebook that if you override the equals
555:13 - you also have to write a hash code and
555:15 - uh if two objects are comparing equal
555:17 - the more must have the same hashcode
555:19 - this is true as I said particularly in
555:22 - collections not now because we're not
555:24 - using this code inside collection
555:27 - and we can also override the tostring
555:29 - method and this two string method is
555:31 - used to return the string representation
555:33 - of the class so we also type here
555:36 - override and we have our two string
555:38 - function I I said method a few times but
555:42 - there are functions not methods methods
555:44 - are different thing in Java
555:46 - and uh
555:48 - let's delete this function let's type it
555:50 - again so if you can see
555:54 - so this is going to return the string
555:55 - representation of the class so I need to
555:57 - to return here the values that that are
556:00 - passed to our to our first name and last
556:02 - name and age and if we don't do that if
556:06 - you add the print line here
556:09 - and you type user1
556:12 - let's press Ctrl D and user 2. you're
556:15 - gonna see just some
556:19 - you're gonna see the user and you're
556:20 - gonna see some numbers but we're not
556:23 - gonna see the string representation of
556:24 - the those two users you're not going to
556:27 - see Alex so the name and the age so you
556:29 - see this
556:31 - dosto but uh
556:33 - to avoid that because this also use
556:36 - useful because previously when we want
556:38 - to
556:40 - um output in the console the values of
556:41 - the properties you have to call those
556:43 - properties and to add multiple Sprint
556:45 - lines but with the two string
556:48 - function we can just type here return
556:52 - and type here
556:54 - user
556:58 - we put parenthesis and here we type
557:03 - first name
557:12 - we put equals we put dollar sign
557:15 - let's put a single quotation mark dollar
557:18 - sign
557:19 - first name
557:23 - let's put the quotation marks here a
557:24 - single quotation marks
557:26 - last name
557:29 - equals dollar sign last name let's put
557:33 - inside the single quotation marks this
557:40 - comma and age we put also equals dollar
557:44 - sign h
557:46 - now if you run this code again now it's
557:49 - going to use it's gonna one
557:52 - when we are typing user one and user two
557:55 - is going to use the tostring function
557:57 - that we defined inside your class and
558:00 - it's gonna return the string
558:01 - representation of that specific object
558:04 - so if you run this code
558:13 - we get user and get first name Alex last
558:17 - name Adobe in h23 and get for the second
558:19 - you use their first name Alex last name
558:21 - domain and H22 so now get the string
558:23 - representation of this class and this is
558:25 - uh more beautiful because you don't have
558:27 - to work to always type that user one
558:31 - user1.a user1. last name the first name
558:34 - and so on and for the second object two
558:37 - because now it's using the
558:40 - two string function with our own
558:42 - implementation inside here so this is
558:44 - how you can use the tostring function
558:46 - and this also how you can use the
558:49 - password but as I said hashcode is it's
558:53 - a different discussion which you're
558:55 - gonna have when we're going to talk
558:56 - about collections for now just type
558:59 - return 0 here and then we could all fine
559:01 - and if you think about there is a lot of
559:04 - code just to compare to two objects we
559:08 - have almost
559:10 - 38 line of hold just to to determine if
559:13 - two objects two user objects are equal
559:16 - and we also have to override this not
559:20 - necessary but it will also variety this
559:22 - hash code and the two strings so there
559:24 - is a lot of code just to do this uh
559:27 - simple thing to compare it is to user
559:29 - objects are equal and because kotlin is
559:32 - a byte it's about conciseness we don't
559:34 - actually need to do all of this stuff
559:36 - but I I thought I thought that it is a
559:39 - okay to explain to you what you'll need
559:42 - to do in the past in order to understand
559:43 - what now questioning is doing better
559:46 - especially with data classes so you
559:49 - don't need to
559:51 - type yourself all of this code that you
559:54 - have here you can just so if I delete
559:56 - all of this code let's copy it first and
559:58 - then delete it
560:00 - so if I delete all of this code also the
560:04 - and now if I run this
560:08 - now we get false and we get those we get
560:13 - user and this tag text because now we
560:15 - don't have an implementation of the
560:16 - equals of the two string of the hashcode
560:19 - and
560:21 - if you think as I said it's a lot of
560:23 - code to implement all of that and in
560:26 - kotlin you can just type the data
560:29 - keyword in front of the class and all of
560:31 - that code not specifically the same
560:34 - logic but all of that code that we typed
560:35 - there is going to be generated
560:37 - automatically for you so the equals
560:40 - method is going to be generated the hash
560:42 - code and the tostring and uh
560:44 - the properties which are going to be
560:46 - included inside the implementation of
560:48 - the equals of the inside the of the hash
560:51 - code and inside of the tostring are
560:53 - gonna beat all the properties defined
560:56 - inside the property Constructor so all
560:59 - the properties defined inside the
561:00 - property inside the primary Constructor
561:03 - they're going to be used inside the
561:04 - implementation of the equals of the
561:06 - hashcode and the tostring so we just by
561:09 - putting here the data keyword all of
561:11 - that code all of that logic is going to
561:14 - be implemented for us so if you run this
561:17 - code now
561:18 - so look at this how concise is compared
561:22 - to what happens just one line of code
561:24 - and if if you run our code with the data
561:27 - keyword
561:28 - now as you can see we have true and we
561:30 - have user first name Alex last name so
561:33 - you have the same output as previously
561:36 - and just by putting data keyword
561:38 - all of that was all of these calls so
561:42 - let's press Ctrl J all of this squad
561:46 - not specifically
561:48 - exactly this code but all of this code
561:51 - all the implementation of the equals of
561:53 - the harsh code entry was generated
561:54 - automatically for us just by uh just by
561:58 - putting the data keyword in front of our
562:00 - class
562:01 - and if you don't want to have a property
562:04 - included in the implementation of the
562:06 - of the equals or of the harsh code or of
562:10 - the the two string you can just omit it
562:13 - from here and you just you declare it
562:15 - inside the
562:16 - inside the class so if I put let's say
562:19 - here so if I delete this because data
562:22 - classes cannot have parameters
562:25 - and I declared it inside the class
562:27 - inside the data class
562:30 - VAR age and it will sign a value because
562:33 - we cannot let
562:35 - the property uninitialized
562:38 - let's delete this now
562:42 - and if you run this now that property is
562:45 - going to be excluded from the
562:47 - implementation of the equals the hash
562:48 - code and of the two string so we have
562:51 - here true but we have a first name Alex
562:54 - last name Domi so now the limitation for
562:56 - the equals only includes those
562:58 - properties the first name and the last
562:59 - name and also for the to string function
563:02 - we have only the first name and the last
563:03 - name the age is excluded but
563:06 - let's put this back
563:11 - so this is what data classes are they
563:13 - are generating
563:15 - Auto automatically for you the
563:17 - implementation of the equals the harsh
563:20 - code the two string also for the copy
563:22 - function and for the component function
563:24 - but we're going to look at the copy of
563:25 - copy function in a separate video and
563:28 - they generate all of that code that we
563:30 - saw previously that we talked about
563:33 - automatically for you by just putting
563:35 - the data keyword you put the properties
563:37 - inside the primary Constructor and all
563:39 - of that implementation is going to be
563:40 - generated for you for all the properties
563:42 - you find inside the primary construction
563:44 - and just that just by one line of code
563:47 - all of that logic is generated
563:49 - automatically so this is what data
563:52 - classes are see you in the next video so
563:54 - now it's time to start a discussion
563:55 - about interfaces so what are interfaces
563:59 - interfaces
564:00 - um are you used when you want to have a
564:03 - commonly used Behavior shared among
564:06 - different classes but you don't
564:10 - want to provide the actual code that
564:12 - goes inside the class which is going to
564:15 - implement that interface but you just
564:17 - want to define the the name of the
564:20 - function and the parameter of the
564:22 - function
564:22 - the actual code that goes inside the the
564:26 - functions that you define in inside the
564:28 - interface
564:30 - they are particular to each object that
564:33 - implements that specific interface
564:35 - so
564:37 - let's say that you have
564:40 - let's say that we have some classes
564:43 - let's say that you have a class car a
564:45 - class which is uh which represents a
564:47 - truck and you have a class which
564:49 - represents
564:50 - represents a plane you know that all of
564:54 - those three objects have in common the
564:57 - same behavior of starting the engine
565:00 - let's say and you don't know how each
565:03 - particular class is going to start the
565:05 - engine but you know that each class is
565:08 - gonna have in common this function which
565:11 - is
565:11 - I'm gonna start the engine again you
565:14 - don't care about the particular how each
565:16 - particular object is gonna uh what code
565:19 - goes inside the or what uh logic goes
565:23 - inside The Stand start engine function
565:25 - for each of those particular objects but
565:28 - to care only about the fact that they
565:31 - they share the same behavior they they
565:34 - all start the engine but how they start
565:37 - the engine is uh particular to
565:40 - each class and this is what we do with
565:43 - interfaces we only Define the what so
565:46 - what what we Define in the interface
565:48 - only the
565:50 - the the what and the what represents the
565:54 - what those classes are gonna have in
565:58 - common so you know that they uh gonna
566:01 - have a function called start engine but
566:03 - you don't
566:04 - don't know how each object how each
566:08 - class is gonna Implement that logic and
566:12 - to that to to for that I'm gonna use an
566:15 - interface so we Define what needs to be
566:18 - done but we don't Define how it's going
566:20 - to be done so to declare an interface we
566:22 - go down here at the enclosing calibrates
566:24 - of the main function and we type
566:26 - interface and while I'm typing you see
566:29 - that we have this suggestion we type we
566:31 - press enter we can type the entire word
566:34 - if you want so interface and I'm going
566:37 - to call this internal phase engine and
566:39 - the name of the interface should be with
566:41 - a capital letter to start a capital
566:43 - letter it should be in Pascal case if it
566:45 - has multiple words
566:46 - and the interfaces cannot have
566:49 - Constructors because they cannot be
566:51 - instantiated you cannot create you
566:54 - cannot create an object with an
566:56 - interface interfaces are used only they
566:59 - are created only to be implemented by
567:01 - classes they cannot be instantiated so
567:05 - we need to put curly braces and inside
567:07 - the
567:08 - the body inside the curly braces we
567:10 - Define what needs to be done so we
567:12 - Define only
567:14 - the function we Define we type the name
567:17 - of the function I'm going to call it
567:18 - start engine
567:19 - but we don't Define the actual code for
567:22 - the function so we put parenthesis here
567:24 - you can Define parameters if you want
567:25 - but we don't put curly braces and we
567:28 - Define our logic here because we only
567:31 - care what about what needs to be done so
567:34 - we only care that each class needs to
567:37 - start the engine how it's going to start
567:39 - the engine it's up to each particular
567:41 - class
567:42 - so we go down here we type class and I'm
567:46 - going to create a class called car and
567:48 - it's going to have a
567:49 - a vowel name which is going to be a
567:52 - string
567:53 - and a vaal color which is also going to
567:56 - be a string
567:58 - and now to implement the interface we
568:00 - put colon and we type engine
568:04 - and as you can see we have this engine
568:06 - we have this eye for interface here so
568:09 - you press enter then we put curly braces
568:11 - to define the body of the class and now
568:13 - we have this underline here and this
568:16 - underline is here to tell us that we
568:18 - need to in now we need to implement the
568:21 - we need to implement this function
568:23 - because the the interface and the class
568:27 - have a contract is like a contract and
568:29 - the contract says that if you implement
568:32 - an interface you need to you must
568:34 - Implement you must override the the the
568:37 - function so you need to implement the
568:39 - function you still will this is why we
568:42 - have here here an underline so if I
568:44 - click on this underline what if I hover
568:46 - over there and I click
568:48 - on the light on the red bulb you see
568:50 - that it says Implement members so click
568:52 - on Implement and have our
568:54 - start engine function we click OK and
568:57 - now our functions was overrided here and
569:00 - we have this to do which is not yet
569:02 - implemented and this is there to to tell
569:05 - us that this method this function is not
569:07 - Yeti implemented so we need to define
569:09 - the actual logic here
569:11 - and let's create two other classes let's
569:15 - um
569:15 - call this class track
569:21 - and it's also going to have a name a Val
569:24 - going to be a string
569:26 - and the color also string
569:35 - and we're gonna also
569:37 - implement the interface so I'm going to
569:40 - put colon engine then we put curabase
569:43 - now we need to implement because I said
569:45 - there is a contact between the interface
569:47 - and the class and the contract says that
569:49 - you need to implement the function
569:52 - so we Implement a function here and we
569:54 - create another class
569:56 - call plane
569:59 - and it's also going to have a Val name
570:05 - it's going to be a string
570:07 - and the eval color also string
570:12 - and here we put colon and we're gonna
570:14 - also implement the interface interface
570:16 - inside the plane class
570:19 - and we put call on engine our interface
570:22 - then curly braces and now we have the
570:24 - underline because again we there is the
570:26 - contract now between the interface and
570:28 - the class and that says that we need to
570:30 - implement this function inside our plane
570:32 - class
570:34 - and we have those to do and those to do
570:36 - are here to tell us that we need to
570:39 - we need to imple we need to provide some
570:41 - logic to the to the actual function so
570:44 - let's delete those and let's put some
570:46 - code here
570:47 - so let's delete this
570:56 - and let's add the print line here which
570:58 - is gonna output some text to the console
571:08 - and we're gonna have the text the car
571:10 - you
571:11 - starting
571:13 - the engine
571:18 - and I'm gonna copy this because now I'm
571:21 - gonna put here some text
571:24 - I'm gonna say the
571:27 - track is starting the engine
571:30 - and here is going to say the plane
571:32 - starting the engine
571:39 - now what what we have done here and what
571:43 - we did here is that
571:45 - we know that each class respectively our
571:48 - car our tracking and our plane they all
571:51 - gonna start the engine so they all gonna
571:54 - share this start engine Behavior the one
571:58 - all all gonna have this functionality
572:00 - what we don't know is how each class how
572:05 - each how each object is gonna start the
572:08 - engine because they uh they start the
572:11 - engine in a different way the engine of
572:14 - of a car is different from an engine of
572:17 - a truck or form of Lane so we know that
572:20 - each each is gonna
572:23 - not that each class or each object is
572:26 - gonna start the engine but we don't know
572:29 - how they're gonna start the engine so
572:31 - here we go inside the actual uh feelings
572:34 - inside the the function which we type
572:36 - the text the car is starting the engine
572:38 - the truck is starting the engine and the
572:40 - plane is starting the engine so they
572:43 - differed in how they start the engine
572:45 - but you know that they all gonna they
572:48 - all gonna start the engine so this is
572:50 - what interfaces allows us to do
572:52 - you can define an interface if you know
572:55 - that uh multiple uh related or unrelated
573:00 - classes or objects are gonna have a
573:03 - function shared between them but you
573:06 - don't know how each particular class or
573:08 - object is gonna em is gonna uh how is
573:12 - gonna how it's gonna have the actual
573:14 - quad uh how it's gonna write the actual
573:16 - code for that uh that behavior so you
573:19 - don't you don't care about the how you
573:22 - want to care about the what so we know
573:24 - that in this case they will start the
573:26 - engine but they they start the engine in
573:28 - a different way and you can have here
573:31 - another class let's say
573:34 - that a person which creates another
573:38 - another class and the class is gonna be
573:41 - called Tesla and in that case again you
573:44 - can implement the interface because you
573:46 - know that uh the Tesla is also going to
573:48 - start the engine you don't know how it's
573:51 - going to start the engine but you know
573:52 - that uh is going to start the engine and
573:55 - how it's going to start the engine is
573:57 - specific to a Tesla car so this is what
574:00 - interfaces allow us to do we can Define
574:02 - uh some shared Behavior between
574:05 - unrelated or related classes and that
574:09 - the actual code you don't Define any
574:10 - code inside the interface you can put
574:13 - you actually can Define here a property
574:15 - but uh uh usually you just Define uh the
574:20 - the function the function name some
574:22 - parameters and the actual code goes
574:25 - inside the class which implements that
574:27 - interface let's let's actually create
574:29 - here a class Tesla so we put here
574:34 - let's put this a little bit up
574:37 - so we put here class Tesla is gonna have
574:41 - also a Val name
574:43 - it's going to be a string
574:46 - Naval color
574:48 - and this is also going to be a string so
574:51 - now we can Implement our engine
574:53 - interface so we don't know how Tesla is
574:56 - going to start the engine but we know
574:58 - that it's going to start the engine so
574:59 - we we Implement our interface put call
575:02 - on the name of the interface and now we
575:05 - need to implement the start engine so we
575:07 - click on that
575:09 - and we have not yet implemented let's
575:11 - put our print line here I'm going to
575:13 - press Ctrl V
575:15 - and here's gonna say that's like
575:18 - starting the engine
575:19 - so this is what interfaces are and
575:24 - see you in the next video
575:26 - because I'm going to end the video now
575:29 - so here you should say a Tesla is
575:31 - starting the engine not the Tesla
575:34 - so I collected that
575:38 - so I thought it's a good idea to show
575:40 - you a practical example using Android
575:42 - studio where interfaces are used because
575:45 - the when I first learned about
575:48 - interfaces and after classes I found
575:50 - them very confusing because they are
575:52 - very very abstract and you don't see
575:56 - when when you somebody teaches you those
575:59 - Concepts you don't see how where and
576:01 - where you're gonna use those uh those
576:04 - Concepts interfaces and Abstract classes
576:07 - and for that I'm going to open Android
576:09 - Studio
576:10 - to show you a practical example using
576:13 - interfaces and also organize Android
576:16 - Studio to show you a practical example
576:18 - where we're going to use
576:21 - abstract classes so I opened Android
576:23 - Studio you don't need to it looks
576:26 - similar to our IntelliJ because this
576:28 - IntelliJ IDEA just that is it's Android
576:31 - Studio so we will click on my
576:34 - application
576:42 - and here we have this thing called main
576:45 - activity we don't need to worry about
576:47 - this because as I said I just want to
576:51 - show you where interfaces are used in
576:53 - Android Studio to get to get an idea
576:56 - about where they are used because I said
576:59 - they are very abstract
577:01 - foreign
577:10 - this thing called activity.main This is
577:14 - where we put our
577:16 - UI this is where we put our buttons this
577:19 - is where we put our list views uh this
577:22 - is where we put generally our UI so as
577:26 - you can see we have two buttons here and
577:27 - they have an ID
577:29 - again I'm not gonna go into this but if
577:32 - you click here on design you see that we
577:34 - have a login button and a sign up button
577:38 - so this is the UI part of our app now
577:42 - I'm gonna click on this main activity
577:43 - and this is the part where you're gonna
577:45 - put our code and now I'm gonna link
577:48 - those UI buttons so let's go to quad so
577:51 - this is the code for creating those
577:53 - buttons
577:55 - and I'm gonna link those buttons because
577:57 - they have this ID here login button so
578:00 - you have here Android ID
578:02 - and if you come from Android Studio you
578:04 - already know all of this I'm gonna link
578:06 - those UI buttons with some objects
578:09 - buttons by typing some code so I'm gonna
578:12 - Define up here
578:15 - foreign
578:19 - called the login button
578:24 - and it's going to be of type button so
578:26 - this is a class button
578:29 - then I'm gonna Define another later need
578:31 - because I'm not gonna initialize it
578:33 - right there so Laten it again
578:37 - sign up button
578:42 - and it's gonna be also of type button so
578:45 - types like we have types for uh for our
578:48 - numbers or for our just that this is a
578:50 - class and this rep this class is a
578:53 - button objectives and now we need to
578:55 - link those those objects that we created
578:58 - here
578:59 - with those buttons that we have here
579:02 - those UI buttons so to link those login
579:05 - button and sign up button
579:07 - and to do that to go down here
579:09 - and I'm gonna I'm gonna go I'm gonna do
579:12 - this in the longer way and here we type
579:14 - login button again you don't need to
579:16 - understand all of this this is just to
579:18 - illustrate how interfaces work I'm gonna
579:21 - put equals
579:22 - and now I'm going to type find view by D
579:25 - and this function find view by ID is
579:27 - gonna link our button object that we
579:30 - created here with our UI button
579:33 - that we have
579:35 - that we have created here and it's going
579:38 - to be linked by its ID by this ID that
579:40 - we have here login button so if you go
579:43 - here hero Type R so R is this thing
579:46 - which uh
579:48 - again don't need to understand all of
579:50 - these arrays is used to to get that ID
579:53 - to link our button object with our
579:55 - button UI so if you put r dot ID that
579:59 - and we have our uh our two IDs so we
580:03 - choose login button
580:05 - so now we have linked our UI button with
580:10 - our button object so we linked the UI in
580:14 - other words with the code now let's link
580:18 - also the setting up button so we type
580:20 - here saying a button
580:22 - equals find view by ID you you also type
580:25 - r dot ID Dot
580:28 - sign up button again you don't need to
580:31 - type this code because probably you
580:32 - don't even have Android Studio this is
580:34 - just to illustrate something
580:36 - now
580:38 - to illustrate how interfaces work let's
580:40 - say that I want to
580:43 - let's say that I want to
580:45 - to do something when this login button
580:48 - is clicked and I want to do also
580:50 - something when design up button is
580:51 - clicked and it and here interface is
580:53 - coming to action
580:55 - what you can do is you can say login
580:57 - button
580:59 - Dot and there is a function called set
581:02 - on click listener and this function what
581:05 - is doing is
581:07 - basically setting a listener on our UI
581:11 - button so that when you click on that
581:13 - button the function called on click is
581:16 - going to be executed and the code that
581:20 - is going to be in that function is
581:22 - particular to each to each button so
581:27 - you you you're gonna set the interface
581:31 - so you types don't click listener and
581:33 - hero type also this illustrates uh the
581:36 - object also this by by this example we
581:40 - also illustrate how the Anonymous
581:42 - classes work so you type object
581:44 - and now I'm gonna inherit actually gonna
581:47 - Implement our interface on click
581:50 - listener and this only listener
581:52 - interface has a function called on click
581:56 - and here to put curly braces and press
581:58 - enter and now here we have this
582:00 - underline
582:02 - and if you click on it you have this red
582:05 - bulb because it wants us to implement
582:08 - to implement that on click function so
582:11 - we're going to implement that
582:13 - and it says to do not get implemented
582:15 - I'm not going to do the same thing for
582:17 - the
582:18 - for the sign up button so I'm gonna copy
582:22 - this
582:25 - I'm gonna paste it down here
582:28 - and I'm going to change this to sign up
582:31 - button so now each individual each
582:34 - individual button has us on has its own
582:37 - on click listener interface and the code
582:41 - which is going to be executed inside the
582:43 - one click method because this function
582:44 - is going to be triggered when you click
582:46 - on the button is particular to each
582:48 - button so this button is going to log in
582:50 - the user this button you're gonna put
582:53 - here the code to sign up the user but
582:55 - you're not going to do that we're just
582:56 - gonna
582:57 - we're gonna uh show some text on our
583:01 - emulator so we type here to show the
583:03 - text toast
583:05 - dot make text here you need to pass the
583:09 - context so don't worry about all of this
583:12 - main.activity here you need to pass uh
583:16 - how how long this is gonna show on the
583:19 - screen so we choose a short
583:24 - and we put that show to show this on the
583:33 - actually here we need to pass the text
583:36 - so what text is going to be shown on the
583:37 - screen so here we're gonna say
583:39 - login button
583:42 - clicked
583:44 - and now here we need to pass how long
583:47 - it's going to slow so you type those Dot
583:50 - short so if it's going to be shown for a
583:54 - short time and then we need to call the
583:57 - show functions to show this on the
583:59 - screen and I'm going to press Ctrl uh C
584:03 - to copy this and I'm gonna paste inside
584:05 - our on click function in our interface
584:09 - that we have here for the sign up button
584:11 - and this is gonna say
584:13 - that
584:16 - sign up button was click so sign up
584:22 - button
584:24 - clicked
584:26 - now in Android Studio we have what is
584:28 - called an emulator and this is basically
584:30 - a virtual phone and we can run you can
584:35 - run our code and we can test our code
584:37 - and we're gonna see when
584:39 - on that emulator those buttons and when
584:43 - you're going to click on those buttons
584:44 - this code that we Define here for for
584:48 - those buttons because we linked them so
584:50 - we linked
584:52 - those two buttons that have the login
584:54 - button the sign up button so this is
584:56 - their UI code this is their XML code
585:00 - you we've linked them through code here
585:03 - and when we click on them the Code in
585:06 - each particular object is going to be
585:08 - executed so now if you run our code go
585:11 - up here and I'm gonna create now the
585:15 - virtual font to see our buttons and I'm
585:17 - going to click on them to see how it
585:18 - works
585:20 - I'm going to close those
585:23 - now it's connecting to the emulator
585:27 - and this is our virtual virtual phone so
585:31 - this is the virtual phones and here we
585:34 - have our UI that we created here
585:38 - so this is what the users see so this
585:42 - the what the user say and this is what
585:45 - we see it's the this is what happens
585:47 - under the covers and now if I click on
585:49 - this login button look what happens
585:54 - it says login button click so it
585:57 - executes this on click function inside
585:59 - the login button if I click on the
586:03 - sign up button it says sign up button
586:06 - click because it's executing the one
586:08 - click function and the code inside the
586:11 - one click function for the sign up
586:13 - button
586:13 - and they are as I said linked by the by
586:17 - the ID so this is what happens under the
586:20 - covers this is what the user see
586:22 - now
586:23 - this is where interfaces can be used
586:26 - because if you think about you can have
586:29 - multiple uis different uis text views
586:33 - lists or
586:35 - items into the items in a list which can
586:38 - be clicked and for all of those you know
586:41 - that always go all of them are gonna
586:44 - have on click function all all all have
586:48 - this shared functionality to respond to
586:51 - a click you don't know how that is gonna
586:56 - how that that one click function is
586:59 - gonna
587:00 - execute or what code that on click
587:04 - function is going to have for each
587:05 - particular UI uh UI but you know that
587:10 - each each one is gonna have one click
587:13 - function what is going to go inside the
587:16 - one click function for you for each
587:18 - particular
587:19 - UI it's up to that specific UI so it's
587:23 - up to a button it's up to a text views
587:26 - and so on so this is a over interfaces
587:29 - are used because we know that they're
587:32 - going to have a shared functionality of
587:34 - one click but you don't know how that
587:36 - functionality is going to be implemented
587:38 - by each particular uis in our case we do
587:40 - we know that login button and sign up
587:43 - button
587:45 - both both are going to have a one click
587:47 - both we're gonna are gonna respond to
587:49 - click events but you don't know what
587:51 - they're gonna do so this is why you
587:54 - define the interface and the developers
587:57 - who write code gonna Implement that
587:59 - interface and you're gonna write the
588:02 - actual implementation for that function
588:04 - which is specific to that object so this
588:08 - is our discussion and if you find this
588:10 - confusing
588:11 - particularly if I'm confusing the uh if
588:15 - because I touch a little bit on Android
588:17 - Studio in our discussion don't be
588:19 - because I just wanted to show you a
588:22 - practical example where interfaces are
588:25 - used using Android studio so let's click
588:28 - again on login button
588:30 - we get our toast login button clicked
588:33 - slang a button click I can create
588:34 - another button which can be used for a
588:38 - I don't know if you forgot the password
588:40 - and you you're gonna implement the on
588:42 - click listener you're gonna override the
588:45 - you're gonna override the one click
588:46 - function I'm gonna write some code to
588:49 - to send uh to send to help help the user
588:53 - to recover its uh puzzle and so on so we
588:56 - can see how interfaces can be used
588:58 - practically in this with this example
589:01 - so this is our discussion see you in the
589:03 - next video so now it's time to start a
589:05 - discussion about object expression but
589:07 - first let's go down here and let's
589:09 - create a class to see why you'll need to
589:11 - use object expression in the first place
589:13 - so you type here class
589:14 - and now and our class is going to be
589:16 - called button
589:17 - we put the parenthesis to create the
589:20 - primary Constructor we Define some
589:21 - properties here the first one is going
589:23 - to be text is going to be of type string
589:31 - the second one is going to be also
589:33 - available it's going to be called ID
589:35 - it's gonna be an integer
589:37 - and the last one is going to be called
589:39 - One Click listener
589:42 - it's going to be of type on click
589:44 - listener so this is an interface that
589:46 - we're gonna create
589:53 - so let's go down here to create the
589:54 - interface we type interface on and while
589:58 - I'm jumping you see that you have this
590:00 - suggestion one click listener
590:02 - to create the interface press enter
590:04 - put curly braces and let's define a
590:06 - function fun
590:09 - on click
590:11 - let's put parenthesis
590:14 - now let's create some objects with our
590:15 - class button to see why you'll need to
590:18 - use a
590:19 - object expression in the first place so
590:22 - let's go here
590:23 - and here we type Val let's call it login
590:28 - button
590:31 - put equal and now let's create our
590:32 - object type button
590:35 - with parenthesis now let's pass some
590:37 - values to the properties of the primary
590:39 - Constructor
590:41 - and this is gonna have the text to login
590:45 - for the ID we type some arbitrary
590:48 - numbers here one two one three
590:50 - two
590:52 - and um
590:53 - now here you need to pass the one click
590:56 - listener interface but do not we cannot
590:59 - type here one click listener because
591:01 - we cannot instantiate the interface so
591:04 - what can we do to solve this problem
591:08 - one solution to this would be to create
591:10 - a separate class here
591:13 - let's put it actually above the
591:14 - interface
591:17 - let's call it click listener this class
591:19 - class
591:21 - click listener and this class is going
591:23 - to implement the interface
591:25 - so we put here colon and we call our on
591:29 - click listener interface put curly
591:32 - braces
591:33 - and now we need to implement that one
591:35 - click method that one click function
591:37 - that we defined actually
591:39 - inside our own click listen interface so
591:41 - press ok to override to add on click
591:44 - function
591:46 - and we have that
591:48 - to do we have this to do which says to
591:50 - do not yet implemented so this is there
591:52 - to tell us that it's not implemented yet
591:55 - so let's delete this
591:59 - all right so what we could do is you can
592:01 - create here an instance of the
592:04 - click listener so we type here Val
592:09 - click listener
592:12 - equals create the instance we'll create
592:15 - an object
592:16 - and now you can pass here the click
592:18 - listener
592:21 - so now the arrow disappeared but if I
592:24 - create a second object let's call it the
592:31 - sign up button
592:34 - equals button
592:38 - let's pause the text so
592:40 - sign up
592:44 - for the ID was an arbitrary number
592:48 - now
592:50 - in our imaginary or
592:54 - example that we have here
592:57 - actually if you think for real scenario
592:59 - with this button and the one click
593:02 - listen what we want to achieve here is
593:03 - that if you have a graphical user
593:05 - interface
593:06 - you want that you want to detect that
593:10 - click so you want to declare detect one
593:12 - that specific button let's see that this
593:14 - button object that we have here is
593:16 - linked to an uh graphical button which
593:20 - on which you click
593:22 - because they are linked when you click
593:24 - on that you want to
593:26 - call that one click function that is
593:30 - defined inside our interface inside here
593:32 - but you want to
593:34 - make that one click interface we want
593:38 - you want to make that one click function
593:40 - particular to particular to that button
593:43 - which was clicked so we we want to to
593:46 - implement that uh one click function to
593:51 - that particular button which was clicked
593:52 - and the code that goes inside that
593:55 - particular button so let's say that you
593:56 - click on the login button it's
593:58 - particular to that button so that in the
594:01 - next
594:02 - when the next button is clicked so when
594:04 - if the user clicks for when the sign up
594:07 - button then you know you need to also
594:10 - have the one click
594:12 - method called but that one click that
594:16 - one click function actually I I keep
594:18 - saying method but the one click function
594:21 - should should have its own
594:23 - implementation a particular to the sign
594:25 - up button so what can we do in that case
594:27 - we cannot pass the same instance here to
594:30 - click listener because even if it
594:31 - creates here another instance of the
594:33 - click listener it will still have the
594:35 - same code which is here so if you put
594:38 - here some code this is code blue it will
594:40 - be shared among all the objects that are
594:42 - created so what you can do in this case
594:45 - is to use an object expression
594:49 - or also called anonymous
594:52 - anonymous anonymous classes so what you
594:54 - can do here we can type object
594:58 - we put colon and now we
595:01 - are inheriting from our we are actually
595:04 - implementing our own click listener
595:08 - interface so we type object colon on
595:11 - click listener and we put curly braces
595:13 - because here we declare and we also
595:17 - instantiate the the anonymous class so
595:21 - we need to implement that right there
595:25 - so by doing this now we where we made
595:28 - the one click function particular to
595:33 - each object Which object button so we
595:36 - can do the same thing here we type
595:38 - object
595:43 - and we Implement our on click listener
595:46 - interface we put curly braces now we
595:48 - need to implement
595:50 - for this particular object for the sign
595:52 - up
595:55 - or button objects we need to implement
595:58 - that function so if we type we click we
596:01 - click on this object
596:03 - we go to the red light bulb and we type
596:06 - we press here where it says Implement
596:07 - members so implement the one click
596:09 - function and now what we did here is we
596:13 - made the one click
596:16 - function particular to each object so
596:19 - each object now we can put here some
596:21 - code
596:22 - code
596:25 - or we can type here this sign
596:33 - in
596:35 - actually let's type login
596:38 - that was it so now we can have code here
596:41 - which actually log logs in if you have a
596:44 - real graphical user interface which logs
596:46 - logs in the user and here you can also
596:49 - code to sign up the user when that
596:51 - specific button is clicked
596:56 - so by doing by using the object
596:58 - expression also called Anonymous class
597:00 - because you don't have
597:03 - reference you don't have a name for the
597:06 - class here you just it's just Anonymous
597:08 - for this
597:10 - is anonymous so we cannot it does not
597:13 - have a name so we cannot call it later
597:15 - or do something because it's created and
597:18 - also instantiating right there this is
597:20 - why I need to implement the one click
597:21 - function and now we made the one click
597:23 - function particular to each button and
597:26 - you have more
597:27 - objects more objects of created with the
597:30 - class
597:31 - button they'll have their own
597:33 - implementation of the one click
597:36 - function which comes from the interface
597:38 - on click listener
597:40 - so this is why you need to use the
597:42 - anonymous
597:44 - class or also called object expression
597:46 - and it's an expression because the value
597:49 - that the because the object is always
597:52 - it's created and instantiate it is
597:56 - actually declared and instantiated at
597:58 - the same time it's also assigned to the
598:01 - property that we Define here so this is
598:03 - why it's called an expression
598:06 - so see you in the next video
598:09 - all right so now it's time to start a
598:10 - discussion about delegation but first
598:12 - I'm going to add the main function here
598:14 - now what is delegation delegation means
598:17 - giving power given Authority from one
598:20 - instance from one class to another class
598:22 - and delegation is usually used in in
598:26 - scenarios where inheritance starts to
598:29 - break so when inheritance starts to
598:32 - break when you want let's say it for
598:34 - whatever reason to inherit from two
598:36 - classes in that case you can't use
598:39 - inheritance because with inheritance you
598:41 - can you inherit just from only one class
598:44 - but with delegation you can plug in
598:47 - multiple
598:49 - implementation of classes in your own
598:51 - class and let's see how we can do that
598:54 - so I'm going to create first an
598:55 - interface called a and it's going to
598:58 - have a function called print
599:02 - then I'm going to create another
599:03 - interface called B and it's going to
599:06 - have a function print though
599:11 - then I'm going to create a class so I'm
599:13 - going to type here class and it's going
599:15 - to be called first delegate and it's
599:17 - going to implement the fun the interface
599:19 - a here
599:21 - and I'm gonna press Ctrl o to override
599:23 - the function print here
599:25 - and I'm going to create another class
599:27 - called second delegate
599:30 - and this is going to implement the
599:32 - interface B
599:33 - so I'm going to place Ctrl to override
599:35 - the
599:36 - function print tool
599:39 - now I'm going to create up here a class
599:41 - called up
599:43 - so class up
599:46 - now let's say that I want here to
599:48 - inherit from the first delegate and from
599:51 - the second regulator so I'm going to
599:52 - inform the single delegate and if I type
599:54 - here first delegate
599:57 - I put parenthesis opening parentheses
599:59 - closing parentheses
600:01 - if I put curly braces now I have another
600:04 - line because I should Mark this as open
600:07 - so mark this as open and also this as
600:11 - open because I want to show you that so
600:15 - now if I want to inherit from the second
600:17 - class called from the second delegate
600:19 - because let's say that I want to use the
600:21 - the print to function in my class for
600:24 - whatever reason
600:25 - I can't because I can't only inherit
600:28 - from one class so if I hover over here
600:31 - over this underline it says only only
600:34 - one class may appear in a super type
600:36 - list so in other words saying that you
600:37 - can only inherit from one class and that
600:40 - is all we cannot inherit from multiple
600:43 - classes now with delegation we can plug
600:46 - in multiple implementations in our own
600:49 - class so what I can do here I can say
600:52 - hey
600:54 - implement the interface a so I'm going
600:56 - to inherit it from the interface a but
600:58 - you're gonna say use for the interface a
601:01 - the implementation of the first delegate
601:04 - class so this is what we're saying here
601:05 - a and the keyword by first delegate
601:09 - we're saying hey use for the interface a
601:12 - the implementation which is provided by
601:15 - the first delegate class and that will
601:17 - work
601:18 - then I'm going to put a comma here and
601:19 - I'm going to say use also for the class
601:22 - B so I'm going to type for the interface
601:25 - B so we're gonna type B and we're gonna
601:28 - use the by key you're also going to type
601:30 - here by
601:31 - second delegate so you're saying use for
601:34 - the interface B the second delegate
601:37 - implementation and it's gonna use that
601:40 - and it's gonna be him
601:42 - happy with that so you're gonna see that
601:43 - we get no error and now I can override
601:47 - here both the print function and also
601:50 - the print to function so if I press Ctrl
601:52 - o now I can override also the print too
601:55 - and this is inherently very powerful
601:58 - because we can plug in here multiple as
602:00 - many implementations as you want in your
602:03 - class so this is in the if you think
602:07 - about in contrast with the inheritance
602:10 - this is very powerful because here you
602:12 - can plug in as many implementations as
602:15 - you want and this is very powerful so
602:18 - this is how you can use the delegation
602:20 - in kotlin and next we're going to see
602:21 - how you can use delegation with
602:23 - properties
602:24 - so to use delegation on properties first
602:26 - I'm going to paste some code here so I'm
602:28 - going to paste this code here and what
602:30 - we are having here is a class format
602:31 - delegate which is inheriting from the
602:33 - read and write property
602:35 - and it's overriding the get value and
602:38 - the set value so we are overriding the
602:40 - setter and the getter inside our class
602:42 - and we provide our own implementation so
602:44 - whenever you
602:46 - you use the setter to set a value or to
602:48 - get as a get a value we we are
602:51 - overriding those functions and we
602:52 - provide our own implementation next I'm
602:54 - going to create here up here a class but
602:56 - first I'm going to delete the code and
602:58 - the interface that we have here because
603:00 - we don't need this code
603:01 - so I'm gonna delete this code and I'm
603:03 - going to create another class
603:05 - and this class is going to be called
603:07 - user I'm going to put curly braces and
603:10 - I'm going to define the properties
603:11 - inside the class so I'm going to type
603:12 - here VAR
603:14 - first name so what we are doing now is
603:17 - we're creating a property first it's
603:19 - called first name and I'm going to use
603:21 - the by queue we're just going to say buy
603:23 - format delegate so what we are saying
603:25 - now is use the
603:28 - use the the we use the code which is
603:31 - inside the format delegate Whenever you
603:33 - set the value or get the value of the
603:35 - first name I'm going to put the
603:36 - parenthesis here next I'm going to type
603:39 - another VAR last name and I'm going to
603:42 - type here again bye and I'm going to
603:44 - type format delegate so format delegate
603:47 - and we put parentheses
603:49 - so not now what is going to happen is
603:51 - that whenever you set the first name
603:54 - properly or we get the name the first
603:55 - name property is going to use our
603:57 - implementation that we provided here
603:59 - this is what you're gonna do and the
604:00 - same it will be true for the last name
604:02 - because we are using the
604:04 - delegation here on properties so I'm
604:07 - going to create here a user so I'm going
604:08 - to type here Val
604:09 - user want to type equals to user
604:14 - and I'm gonna type here with
604:17 - I'm gonna type user this is the
604:20 - scope function I'm going to put curly
604:22 - curly braces and I'm going to type here
604:24 - first name
604:27 - equals Alex
604:29 - and the last name
604:32 - equals uh
604:34 - dominga
604:36 - now if I output those values in the
604:37 - console look what happens so if I tap it
604:39 - here print line
604:42 - user that first name
604:45 - and print line let's actually use again
604:48 - with the scope function type here with
604:53 - just pass here user curly braces
604:57 - print line
605:00 - first name
605:01 - and print line
605:03 - last name
605:05 - now if you run this code you're gonna
605:06 - see
605:07 - that it's using the overriding functions
605:11 - that we provide in our format delegate
605:13 - so we have in uppercase letters like we
605:15 - defined here we're gonna wanna whenever
605:17 - we set about is going to be set it with
605:20 - the it's going to change the value to
605:21 - lowercase letter so get Alex and obinka
605:24 - in lowercase letters so this is how you
605:27 - can use the delegation on properties and
605:30 - see you in the next video
605:37 - so now it's time to start a discussion
605:39 - about collections but first i'm going to
605:41 - create a new project I'm going to call
605:43 - it collections
605:46 - for the language select link for the
605:48 - build system IntelliJ make sure to have
605:50 - the jdk selected and also check this box
605:52 - to have the main function Auto generated
605:54 - for us so I'm going to click on create
605:56 - to create the project
606:01 - now I'm going to delete this code
606:02 - because you don't need this code
606:04 - and also I'm going to hide the project
606:05 - pane
606:06 - now what are collections collections are
606:09 - a group of objects stored together in a
606:12 - single variable they are similar to
606:14 - array but there are there are different
606:16 - in some sense and
606:19 - they are mainly three collections that
606:21 - we're gonna look at and this those are
606:23 - the list the set and the map and the and
606:28 - those among those
606:29 - collections they are separated in two
606:32 - groups so there are multiple multiple
606:36 - lists and set air maps and immutable
606:40 - lists set and map and in the motable
606:44 - means that you can write to that
606:48 - collection so you can add or or remove
606:51 - elements to it so the that collection
606:53 - can grow or Shrink as you add or remove
606:56 - elements to it and immutable means that
606:59 - you can only add elements when it when
607:03 - you instantiate that or we're going to
607:05 - create that collection you cannot add
607:07 - later elements to it the size is fixed
607:10 - so we cannot add or remove element so
607:12 - this is the difference between immutable
607:14 - and multiple and we're gonna look at all
607:16 - of those in this video so we're gonna
607:19 - look at the list collection first and
607:21 - we're gonna look at an immutable list so
607:23 - we type Val I'm going to create a
607:25 - variable names and here we're gonna type
607:28 - to create an immutable list type list of
607:32 - and here we need to specify the type
607:34 - what kind of data I'm going to put here
607:37 - and do type name one
607:41 - name two
607:46 - and name three now we cannot add or
607:49 - remove elements from this list because
607:51 - it's an immutable list but we can get on
607:53 - Elemental output in the console and to
607:55 - do that to type it in the line
607:57 - we type names we put square brackets and
608:00 - we get the element by its index and the
608:02 - index also starts at zero so let's get
608:04 - the first element
608:06 - so if you're on this code you'll see
608:08 - name one I'll put it in a new console
608:13 - so you get name one so this is an
608:16 - immutable list we cannot add or remove
608:17 - elements from it after we
608:20 - instantiate it here what now now let's
608:23 - look at an mutably so a list which can
608:27 - within which you can add and remove
608:29 - elements to it so to do that we just
608:31 - change this from a list of to a mutable
608:34 - list of
608:35 - so we type here multiple
608:37 - list of
608:40 - we can also remove the explicit type
608:43 - here the explicit type declaration
608:46 - because it's gray out
608:48 - so remove that because it can be
608:49 - inferred and to this mutable list now we
608:53 - can add or remove the elements so I can
608:56 - type here names
608:58 - and we have this add function so you can
609:00 - type add
609:02 - and here we can
609:05 - you can pass a new element so we pass
609:07 - here let's say name
609:10 - 4. now if I uh let's type here names
609:14 - that for each
609:17 - print line
609:21 - not in this footage
609:24 - name start
609:26 - for each this for each
609:29 - opening the line
609:34 - now if you run this
609:38 - now you see you have name one name two
609:40 - name three and name four so name four
609:42 - was added to our Multiple List because
609:44 - our list is multiple we can add or
609:46 - remove new elements so down here I can
609:50 - I can type names dot remove
609:54 - and we can remove an element and we can
609:56 - remove the element I think by
609:59 - you can remove you can use this function
610:00 - remove art so we can remove the element
610:02 - by its index so we can type here the
610:05 - index
610:06 - and that is going to remove the first
610:07 - element so if you run this code
610:12 - name one is not going to be showed
610:17 - so as you can see name one was removed
610:19 - because you can you will remove it by
610:21 - its index and we can also remove an
610:23 - element
610:24 - using this function by typing uh
610:27 - the elements so we type here let's say
610:30 - name
610:32 - two
610:34 - name two elements and now it's going to
610:35 - be removed so now if you run this
610:41 - name two was removed so those are two
610:43 - functions with which you can remove
610:45 - elements from the Multiple List so this
610:47 - is a multiple list you can add and
610:49 - remove elements to it and the list is
610:51 - gonna grow and Shrink as you add or
610:54 - remove elements to it so this is the
610:56 - Multiple List
610:57 - now
610:59 - we're gonna look at a set and I set this
611:01 - a collection which can store only unique
611:04 - unique elements so you cannot have
611:06 - duplicates so if I delete this
611:10 - so in our
611:13 - in our Multiple List you can put an
611:16 - element which is the same
611:20 - so we can have two elements which are
611:22 - the same so if you run this
611:26 - we have two elements which are the same
611:28 - going to see name one at the end I have
611:31 - name one name two name three and name
611:32 - one again so you can have uh duplicates
611:35 - in our collection on our multiple list
611:37 - but in a set you can't so but first
611:41 - we're gonna look at uh first we're gonna
611:43 - look at the immutable set and then add
611:45 - automotive ball set so we type here uh
611:51 - let's delete this
611:53 - we type here set off
611:57 - and here you need to buy string
612:01 - now if you run this
612:05 - you will see that name one is not shown
612:08 - two times here it's going to be shown
612:09 - only one time so you have name one name
612:11 - two and name three this is because the
612:13 - set Seto the set is not allowing
612:17 - duplicates in its uh in its list so
612:21 - and this is a new multiple set set off
612:24 - so if I type here names dot add we
612:28 - cannot add or remove new elements but
612:30 - you can also use
612:32 - a multiple set of so we type here
612:35 - Moto motable
612:40 - set off
612:42 - and now we can add and remove new
612:44 - elements so you can type names that add
612:47 - so here you can add a new element let's
612:49 - say
612:50 - name
612:56 - so now if you run this
613:03 - I'm going to name one name two name
613:05 - three name four
613:07 - and our duplicate is not strong because
613:10 - I said a set can only
613:13 - can only store unique elements not
613:15 - duplicates but if I add objects that we
613:18 - create look what happens so let's create
613:19 - some user objects but first let's create
613:21 - the class user
613:24 - and it's gonna have a
613:26 - Val name is going to be of type string
613:30 - no let's create some user objects here
613:32 - and we're gonna add to our multiple set
613:35 - so we type here
613:36 - wall user one
613:39 - I'm gonna type here
613:42 - user
613:44 - I'm going to pass some generic names
613:46 - like
613:51 - name one and let's control the a few
613:53 - times
613:55 - let's change this to name two
613:58 - five
613:59 - and let's add here a Val
614:05 - user
614:07 - six
614:08 - equals user
614:11 - and let's type here Alex
614:14 - let's press Ctrl d
614:16 - and let's change this to
614:18 - user 7.
614:20 - now let's add those to our
614:23 - multiple cells so let's change now the
614:25 - type
614:28 - so it's gonna store user objects
614:36 - so we're gonna pass here
614:42 - user one I'm going to speed up now this
614:44 - a little bit
614:46 - I'm gonna press Ctrl tilde format the
614:49 - code
614:51 - now we can add this we cannot add here a
614:53 - name for because now the type is user
614:57 - now if you're on this let's actually
614:59 - change this print to it dot name
615:04 - and let's let's run our code now
615:08 - and we have name one name two name three
615:10 - name four Nerf name five and have Alex
615:13 - two times so why you have duplicates
615:15 - even though I said that sets can only
615:18 - store unique elements this is because
615:19 - previously the set actually what is
615:23 - doing to determine to if to if it has
615:26 - duplicates is using the equals to
615:28 - function that we talked about in our
615:30 - video about data classes so when we
615:32 - typed only strings then it was using the
615:36 - equals to function which was overridden
615:39 - inside the string class to determine if
615:42 - there are uh if there are equal strings
615:46 - but now because our class doesn't have
615:48 - the equals to function over it then it's
615:50 - in its class it's not it's using the
615:54 - equals to function which is inside the
615:56 - ending class so you cannot determine if
615:58 - two users are are equal and to change
616:02 - that just let's hide the console
616:05 - and just put the data keyword here
616:08 - because now this will generate the
616:10 - equals to function the the the two
616:13 - string and
616:14 - the harsh code so now if you run this
616:24 - now we have Alex only one time because
616:26 - now it's using the equals to function
616:27 - which was uh Auto generated by by uh by
616:32 - the class user because you put here the
616:34 - data key or so this is a good thing to
616:38 - have in mind that
616:39 - this model set is using the equals to
616:42 - function to determine if the object that
616:44 - you add to to yourself are equal so
616:48 - having this in mind now let's look at
616:51 - Maps so I'm going to close this
616:55 - I'm gonna delete this
616:59 - let's delete this
617:01 - let's delete this also
617:09 - now let's look at the next collection
617:10 - that you can use in kotlin and that is
617:12 - the map collection and use collection
617:13 - when you want to store key value pairs
617:16 - so I'm going to create a variable it's
617:18 - going to be called users
617:20 - and I'm going to put equals and I'm
617:22 - going to create first animated bottom up
617:24 - so we type map off
617:27 - map
617:28 - of and here you need to specify what
617:32 - kind of type is going to be the key so
617:34 - the key is going to be an integer but
617:35 - you can put any class you want here
617:37 - and the value is going to be a string so
617:39 - I'm going to store the ID and the name
617:42 - of an user
617:43 - and to Define our element in pairs here
617:47 - we type first the key and then we use
617:49 - the to keyword to map our kit to its
617:54 - element so 2 is value actually so type 1
617:57 - 2 and now the value let's first type
618:00 - Maria so
618:02 - now we have one element stored in paired
618:07 - and the key is one the value is Maria
618:09 - next I'm gonna do the same for the next
618:12 - one so I'm gonna type here
618:14 - two
618:16 - two
618:17 - the keyword tool
618:19 - Alex
618:21 - and then
618:23 - I'm gonna type three
618:26 - the keyword tool
618:28 - so inside you need to type the value now
618:30 - now type John
618:35 - now to get one element from this map
618:39 - with I print line
618:41 - we type here users
618:43 - square brackets
618:47 - and we type we get the element by its
618:50 - key as you can see by this hint key so
618:53 - we get let's say the element one
618:57 - so now if you run this code
619:04 - we get Maria because Maria has because
619:07 - this key code is for the for the key one
619:11 - the value mapped the value which is
619:13 - corresponding to this key is Maria and
619:16 - if you change this to two
619:18 - gonna get Alex if you run this
619:26 - so this is an immutable map in this map
619:29 - you cannot add or remove elements but if
619:31 - I declare this as
619:33 - a multiple map so let's change this to a
619:35 - multiple map
619:36 - so we type here mutable
619:39 - map off
619:42 - let's delete this from here
619:47 - and let's pass here and
619:52 - and string
619:54 - now here now
619:58 - so you need to put this in parenthesis
620:03 - here we can add new elements so we can
620:05 - type users
620:09 - actually first let's Loop through our
620:11 - mob to see
620:13 - our elements and I'm going to use the
620:16 - for each function to Loop so we type
620:17 - here users dot for each
620:21 - and we choose this one
620:25 - and inside our Rook without we are the
620:28 - print line
620:29 - and
620:31 - I'm going to put quotation marks and
620:32 - here we're going to put dollar sign I'm
620:34 - going to type T and T is the key and
620:39 - dollar sign U and U is the value so now
620:42 - if you're on this
620:50 - you get one and Maria to and Alex Three
620:52 - Angels so we have the key and we have
620:55 - the corresponding values and you cannot
620:57 - have duplicated keys and this is very
620:59 - important to know you can also add or
621:01 - remove elements
621:03 - from this map so to add an element you
621:06 - just type users
621:08 - and we need to specify the key
621:11 - so we put square brackets so we type
621:14 - user square brackets and then put a key
621:15 - let's say five
621:17 - and we put here equals to and here we
621:21 - need to pass a value so the value is
621:23 - going to be let's say
621:25 - Vlog now if you run this
621:34 - we get one and Maria two and Alex three
621:37 - and John N5 and the corresponding value
621:40 - Vlad so Vlad has the Kiwi the key value
621:43 - five
621:45 - so you can also remove an element from
621:47 - our map so we type users dot remove
621:51 - you know you you here for this remove
621:54 - function you pass the key of the of the
621:57 - element that you want to be removed and
621:59 - let's say that I remove two so I remove
622:01 - Alex from our map so if I run this quad
622:04 - now Alex you know it's not going to be
622:06 - shown here
622:08 - because it was removed on the line for
622:10 - so Alex was removed so this is how you
622:13 - can use the immutable and multiple Maps
622:16 - this is how you can add and remove
622:18 - elements and this is how you can Loop
622:21 - through our map and this is our
622:23 - discussion about Collections and see you
622:25 - in the next video now it's time to start
622:27 - a discussion about collections
622:29 - operations and we're going to look at
622:30 - the first operation and that is
622:32 - Transformations and we're going to start
622:34 - with the first one called mapping so I'm
622:36 - going to create a new project
622:39 - I'm going to call it
622:41 - collections
622:44 - operations
622:47 - IntelliJ then click on create
622:54 - we go on the left hand side
622:57 - click on kotlin right click new I'm
623:00 - going to create a new file I'm going to
623:01 - call it Main
623:03 - I'm going to create the main function
623:05 - now
623:08 - what are transformations as the name
623:11 - implies Transformations are some
623:14 - functions which which you can change a
623:18 - specific collection
623:20 - and we're going to look at the first one
623:22 - which is called mapping so I'm going to
623:24 - create first
623:26 - a collection so I'm going to type Val
623:29 - numbers and it's going to be a set so
623:31 - I'm going to type numbers you're gonna
623:33 - equals to set off
623:36 - and here we're gonna Define some values
623:38 - like one two
623:41 - three four five
623:45 - let's press Ctrl alt format the code
623:48 - now I'm gonna add the print line here
623:51 - now to use the mapping collection
623:55 - transformation we just type numbers
623:58 - and one important thing to know here is
624:01 - that those
624:03 - transformation functions are Lambda
624:06 - functions so if you don't know what
624:08 - Lambda functions are I suggest you to
624:11 - watch the section which is called Lambda
624:13 - function to First understand what our
624:14 - Lambda functions because it will be it
624:17 - will be very hard for you to understand
624:19 - how this how those Transformations work
624:21 - without understanding how Lambda
624:23 - functions work
624:24 - now
624:26 - here we're gonna call our our
624:29 - transformation function which is the
624:32 - first one which as I said is mapping and
624:34 - the function is called map I'm going to
624:37 - explain immediately what it's doing and
624:38 - as you can see it's a Lambda function so
624:40 - we're going to press enter
624:42 - and we we are inside the curly braces
624:44 - and here we're gonna Define our
624:46 - transformation so what we are saying
624:48 - basically here is
624:50 - do whatever I I type here in this those
624:55 - uh
624:56 - curly braces apply to every element of
625:00 - the of this cell of this collection so
625:03 - if I if uh now to refer to to refer to
625:07 - the parameter uh uh to the specific
625:10 - parameter from the numbers uh uh set we
625:14 - type it
625:16 - and I'm gonna type it times
625:19 - 10. so what we are saying here is
625:24 - do this transformation so change this uh
625:29 - change this uh this set by uh more
625:34 - multiplying every element inside the
625:37 - this uh this collection inside this set
625:40 - by 10. so if you run this now every
625:44 - number is going to be multiplied by 10.
625:46 - so if I run this
625:56 - now we get instead of one two three four
626:00 - and five we get 10 20 30 45 so what this
626:03 - map function and what this uh it times
626:07 - 10 did is is it transformed it changed
626:10 - our set into into what it it was changed
626:15 - by the expression that we defined here
626:18 - so we said that I want every element we
626:21 - said here to be multiplied by 10 and
626:23 - then we display them here
626:26 - we can go even further we can put here
626:28 - an if statement so we can type here if
626:32 - let's say it so it refers to the to a
626:35 - specific element in that list in that
626:38 - set so if it equals equals so if equals
626:42 - three I'm gonna say
626:46 - we're gonna say here
626:48 - it
626:50 - times
626:51 - 100.
626:53 - so what we're saying here if one of
626:57 - those elements inside these numbers set
627:00 - is equal to 3 then multiply it change it
627:04 - so change it by by the by this
627:08 - expression so multiply it by 100 and you
627:11 - can also put the else part so we put
627:13 - else you want to put it times
627:17 - so if the else part is true if the else
627:21 - part is executed we're saying if the
627:23 - number is not equal to 3 from this list
627:25 - then multiply the number multiply the
627:30 - number by uh by 10. so now if I run this
627:36 - look what we have here
627:41 - so we have 10 20 and we have 300 here
627:45 - this is because this transformation now
627:47 - is using the if and else statements that
627:51 - you define here so this is what the map
627:53 - Transformations allows you to do you can
627:57 - change you can transform a specific
627:59 - collection by an expression that we
628:01 - defined inside the curly braces of the
628:03 - map function
628:05 - all right
628:06 - now let's look at how we can can use the
628:10 - map transformation to with another
628:12 - collection unless you'll see how can you
628:14 - can use the map transformation with a
628:17 - map so with uh with the with the map
628:20 - which has a key and a value so to do
628:23 - that we just type here
628:26 - Val
628:27 - numbers map so I'm going to type file
628:31 - numbers
628:32 - equals I'm going to type map off
628:35 - and here I'm gonna type
628:38 - key
628:40 - one
628:42 - two
628:43 - one
628:45 - then
628:47 - key
628:48 - tool
628:50 - two two then
628:53 - key three
628:55 - two
628:57 - three
628:58 - and
629:00 - finally key
629:01 - for
629:03 - two
629:04 - four
629:05 - now if you wanna use the map map
629:09 - transfer transformation function on the
629:13 - map map collection you you you can use
629:17 - it either on the keys so you can use it
629:21 - on the keys or on the values so we can
629:24 - type here print line
629:27 - number map
629:29 - number map so we choose here
629:33 - Dot and we choose map Keys now so choose
629:37 - this one map key Lambda expression so
629:40 - map keys that one and here to type eat
629:45 - dot key so get the key Dot uppercase so
629:50 - that is going to upper case all the keys
629:52 - inside our map then I'm gonna add an
629:55 - another print line here
629:57 - I'm gonna type number map
630:01 - Dot
630:03 - map
630:04 - now choose
630:05 - map values
630:08 - and we type here it dot value
630:12 - so the Value Plus
630:16 - it dot key dot length
630:21 - now if you run this though this
630:24 - expression is going to be applied to all
630:26 - of our keys inside our numbers map that
630:28 - we Define above and the second
630:30 - transformation is going to be applied to
630:32 - all the values that we defined inside
630:33 - our numbers map so if you run this code
630:36 - now I'm going to see the
630:38 - the keys being first uppercase and then
630:40 - we're going to see the keys plus plus
630:42 - the length so you see
630:45 - first I get 10 20 300 for 40 and 50 for
630:50 - our first transformation that we have
630:53 - here
630:54 - then we have our second then we have our
630:58 - transformation on the map on the map
631:00 - keys so we have we have the key and then
631:02 - we have the value we have he and the the
631:04 - key is uppercase because we said uh to
631:07 - to do that by using this expression it
631:10 - so it uppercase all the keys as you can
631:12 - see here and then you see the
631:13 - corresponding value for the key
631:16 - after that you see
631:18 - you have numbers map map that value so
631:20 - you have it that Value Plus e dot key
631:23 - dot length so we have key
631:25 - and I have one and we have six we have
631:29 - key two and half seven so the key the
631:32 - value of the key is uh is uh to the
631:36 - value of the key it's added the length
631:38 - of the
631:40 - so to the value that we have here we we
631:44 - have added the the value length of the
631:49 - string key that we defined here so this
631:51 - way I have uh we have uh two then we
631:55 - have seven then we have eight and then
631:57 - we have nine
631:58 - so this is our and you can also
632:02 - you can also do for the uh map for the
632:05 - map transformation and we type here
632:07 - numbers
632:09 - Dot map
632:12 - and we choose this one index not node
632:14 - and here we choose we have two
632:17 - parameters first is the index and second
632:20 - is the value so I'm gonna choose the
632:22 - name for the first one index and for the
632:24 - second one let's call it uh
632:26 - value then you have the auto and here we
632:29 - have we're going to Define our
632:31 - transformation of our expression which
632:33 - is going to be applied on our numbers so
632:36 - here I can use the index so again I'm
632:38 - going to type here an effects if a
632:40 - statement so if
632:42 - index
632:46 - equals equals zero then I'm gonna
632:50 - assign so I'm going to transform to the
632:53 - to that we're going to put the value
632:55 - null
632:57 - to the index 0 else
633:01 - I'm gonna type index
633:05 - times value
633:07 - so else you're gonna uh multiply the
633:10 - index time times the value so if you run
633:13 - this
633:19 - we get 2 6 12 and 20. so for for the
633:24 - first one we get nothing because we for
633:26 - the first index we signed null
633:29 - and then uh it's using the else part to
633:31 - to transform our numbers list and it's
633:35 - multiplying the index by the value so we
633:38 - we first uh
633:40 - we first have this indexed uh
633:43 - zero multiply the here we have null for
633:47 - this because we checked here so we have
633:48 - not so at the index two we have one
633:51 - times two and uh we have two then here
633:54 - we have add indexed two we have two
633:57 - times three so the index is two the
634:00 - value is three and uh we we get uh we
634:04 - get six here and so on so this is how we
634:07 - can use also the index if you want in
634:09 - your transformation now we're going to
634:11 - look at the next transformation that you
634:13 - can do in our collection and that is
634:14 - zipping
634:17 - now it's time to look at the
634:19 - transformation function called zipping
634:21 - so I'm going to add a comment here
634:23 - called the
634:25 - zipping
634:27 - and I'm going to declared to list I'm
634:30 - gonna call the first one colors
634:34 - no particles
634:37 - I'm gonna type please stop
634:42 - I'm gonna type red
634:46 - Brown
634:49 - and
634:52 - Gray
634:55 - and I'm going to create another list
634:57 - called the animals
635:00 - stuff
635:04 - I'm gonna type here Fox
635:08 - beer
635:10 - quotation marks
635:12 - and uh
635:14 - wolf
635:17 - now
635:19 - what does the zipping or the zip
635:23 - functions allow us to do is to create
635:27 - pairs of elements with the same position
635:30 - in both collections so we can create
635:33 - pairs with red we can create a pair of
635:36 - fox and red a pair of bear and brown and
635:40 - a pair of wolf and gray
635:42 - and you can do that just by typing here
635:45 - print line
635:46 - and we have you can do this in two ways
635:48 - to type colors
635:51 - and you can type Dot
635:54 - dot zip and you type here animals
636:00 - and
636:01 - if you run this
636:04 - you'll see them in pairs so you're gonna
636:06 - see Fox thread
636:08 - bear brown and so on so you see here red
636:12 - fox brown bear gray also the zip and the
636:18 - zipping is used to create Pairs and the
636:20 - pairs are at the same position in both
636:24 - on both collections
636:27 - or if you don't want to use this Z
636:30 - function with parenthesis you can type
636:32 - here colors zip and animals
636:37 - and type here any models
636:39 - now if you run this code you're going to
636:40 - see the same output
636:51 - now if you want to use a transformation
636:54 - with the Z function you can type here
636:56 - print line
636:57 - you can type colors dot zip
637:02 - and I'm going to use the parenthesis
637:04 - animals
637:07 - and animals and now I'm going to put
637:10 - curly braces so the Lambda function here
637:13 - I'm going to type
637:14 - animal
637:18 - for a let's put for scholar
637:22 - and animal I'm gonna put the arrow sign
637:26 - and here I'm gonna type day I'm gonna
637:29 - but I'm gonna put first
637:32 - quotation marks and quite the
637:35 - and I'm gonna put dollar sign
637:38 - and we're going to refer our animal uh
637:41 - parameter that we defined here so we
637:44 - type here there
637:45 - animal
637:47 - Dot and we call the replace first chart
637:51 - function so type replace first chart and
637:53 - as you can see this also has uh I think
637:56 - along the
637:57 - function and inside of this we type it
638:03 - dot uppercase
638:06 - uppercase and this is gonna uppercase
638:08 - the first letter of the animal
638:13 - uh
638:14 - with the animal that is defined here and
638:17 - I'm going to type yes
638:20 - dollar sign
638:22 - color
638:23 - right now if you run this
638:27 - you're gonna see the force and the f is
638:30 - uppercase because it's uppercase by this
638:34 - expression that we have here
638:36 - it replaces and this it refers to the
638:39 - animal uh an animal uh variable animal
638:43 - variable that is defined here and it
638:45 - refers to the first letter so it says
638:48 - eat that uppercase so uppercase the
638:50 - first letter
638:51 - then uh then uh return that to the to
638:55 - the animal uh any more variable and we
638:58 - have the fox is red so I have the color
639:01 - and then we have the bear is brown the
639:04 - wolf is gray and all the animals start
639:06 - the capital letter like we Define here
639:08 - in this
639:11 - in this expression
639:13 - so this is the zip function so this is
639:15 - how you can use the Z function to create
639:16 - Pairs and also you can use the unzip
639:20 - function to unzip a list of pairs so
639:24 - first let's create a list of pairs so
639:26 - I'm going to type Val
639:28 - number pairs
639:34 - equals
639:36 - I'm gonna type list of
639:41 - and here we're going to put
639:44 - one
639:48 - two
639:50 - one
639:53 - two
639:55 - two
639:59 - three
640:01 - two
640:04 - three
640:07 - four
640:09 - two
640:10 - four now if you want to unzip those
640:13 - pairs that we created you can just type
640:15 - here print line
640:19 - number pairs let's first display them as
640:23 - pairs
640:24 - and the necklace print line and so let's
640:27 - type number pairs
640:30 - dot unzip
640:33 - now if you run this you're gonna see
640:34 - them first in pairs and then you're
640:36 - gonna see them unpaired because we use
640:39 - here the anzi function so as you can see
640:41 - here you have first one and you have one
640:44 - two two three three four four so you
640:46 - have in pairs first
640:48 - and then we have them separated so we
640:50 - have first one two three four
640:52 - and then we have the numbers one two
640:54 - three four so did you we unzip them we
640:57 - separated them they're not pairs now
640:58 - anymore with this unzip function this so
641:00 - this is how you can use the NZ function
641:04 - now it's time to look at the next
641:05 - transformation that we can use and that
641:07 - is Association now what is association
641:10 - association Transformations allows you
641:12 - to build maps from The Collection
641:14 - elements and certain values associated
641:16 - with them
641:18 - and different Association types the
641:21 - elements can be either keys or values in
641:23 - the association map I'm going to see
641:25 - what this means and the basic
641:27 - Association function is the association
641:30 - associated with which creates a mob on
641:34 - which the elements of the original
641:35 - collection are keys and the values are
641:39 - produced from them by the given
641:41 - transformation function so let's see an
641:43 - example with uh with this so I'm going
641:46 - to delete this code because
641:48 - it will make a doubt but hard to
641:50 - understand we could have so many things
641:52 - here
641:53 - and I'm going to type Val
641:56 - numbers you know put equals
641:59 - I'm gonna type really stuff
642:03 - nanotype here
642:06 - one
642:13 - two
642:16 - three
642:18 - and four
642:21 - now I'm going to type here print line
642:24 - numbers and we are going to use the
642:27 - association associate with the function
642:30 - so we type associated with
642:34 - and this is going to produce as I said
642:36 - previously it's going to produce a map
642:39 - in which the elements of the original
642:41 - collection are keys so the keys of this
642:45 - map are going to be those elements and
642:48 - the
642:49 - values are going to maybe are going to
642:52 - be produced by what expression we Define
642:54 - here inside the parenthesis so I'm going
642:56 - to Define here
642:57 - it so I'm going to type it
643:01 - dot length
643:03 - so now if you run this you're gonna see
643:05 - the keys being one and then I'm gonna
643:07 - see the value being the length of that
643:10 - specific element so if you run this
643:18 - we get the key one the value three the
643:21 - key two the value three then you get
643:23 - three the value is five then you get
643:26 - four and the value is four so what has
643:30 - happened now is that the associate with
643:32 - function created the map in which the
643:35 - elements the key the key are the
643:39 - elements of the collections so those are
643:42 - the keys inside our map and the values
643:45 - of uh those uh with the association with
643:49 - the associated with those keys are
643:52 - produced by the expression that we
643:55 - Define here by its dot length so
643:56 - basically gonna use the length of that
643:59 - specific element and it's going to be
644:01 - the value so this is why I have one
644:04 - three two three three five and so on now
644:09 - for
644:10 - building maps with collection elements
644:13 - as values there is a function called
644:16 - associate by it takes a function that
644:19 - returns a key based on an element's
644:21 - value and if two elements keys are equal
644:24 - only that last one remains in the map so
644:28 - let's look at this one so I'm going to
644:30 - type here
644:31 - print line
644:36 - I'm going to put here numbers
644:41 - so we type numbers
644:43 - dot associate by
644:46 - and now here going to define the
644:48 - expression which is going to build the
644:50 - key because now the the associate by
644:54 - function is going to build a correlation
644:56 - which the elements now are not Keys like
644:58 - we had previously but they are values so
645:01 - here in the expression need now to
645:02 - Define how the key for those respective
645:05 - values that we have here is going to be
645:07 - created so we type here it
645:10 - DOT first
645:13 - dot uppercase
645:15 - so this is what what is this is gonna do
645:17 - it's gonna create a key
645:20 - it's gonna use one let's say that we
645:22 - have element one
645:23 - and it's gonna take your element one
645:27 - it's gonna take the first letter of the
645:29 - element one and it's gonna uppercase it
645:31 - and you're gonna have o and as the key
645:34 - we're gonna have o and as the value
645:37 - we're gonna have one and uh for the next
645:40 - ones uh it will be the same so now if I
645:43 - run this quad
645:46 - foreign
645:56 - elements are the values here so they are
645:59 - the values previously The Collection
646:00 - elements what the key is and the the
646:03 - keys were builded by the expression that
646:06 - we defined here by this so we have o and
646:09 - we have t and we have four and we we
646:12 - have uh t uh only one time and we don't
646:17 - have two entry because uh you cannot
646:20 - have duplicated keys in a map so this is
646:22 - why you only have one only one t here
646:25 - so uh
646:27 - this is associated so this is
646:30 - Association now associate by can also be
646:34 - called with a value transformation
646:36 - function and to do to do that you just
646:39 - type here print line
646:41 - numbers
646:44 - that associate by
646:48 - now we need to
646:51 - apply a transformation now on the key
646:54 - and on the value and how gonna how gonna
646:57 - do that
646:58 - we can type here actually let's delete
647:01 - this because we don't need curly braces
647:03 - we put parentheses and we type here key
647:07 - and we have a suggestion key selector so
647:09 - we're gonna apply the First
647:11 - Transformation on the key so we type key
647:14 - selector that named argument and we put
647:17 - curly braces
647:18 - and here we type it so the key DOT first
647:25 - dot uppercase
647:27 - so now what we're saying here apply this
647:30 - transformation
647:31 - for every key
647:34 - in in in the map that is going to be
647:37 - built so apply this transformation for
647:39 - every key that is in the map that is
647:41 - going to be built so we're saying to
647:44 - uppercase uh to take the first letter
647:46 - and uppercase it then we also need to
647:50 - apply transformation for the value we
647:52 - put
647:52 - comma here at the end of our curly brace
647:57 - and we type here
647:59 - value
648:00 - you also have a name argument you put
648:03 - again curly braces
648:06 - and here we're gonna type it dot length
648:10 - so this is the transformation that is
648:11 - going to be applied
648:12 - to all the values in the map that is
648:15 - going to be built so this is the
648:17 - transformation so this is how all the
648:20 - keys and the the in the map that is
648:23 - going to be built are gonna be uh change
648:26 - so the first letter is going to take
648:28 - this thing is going to take the first
648:30 - letter of the keys and it's going to
648:32 - uppercase it
648:34 - this will uh
648:36 - we'll take the length of the the all the
648:40 - values in the in the the in the in the
648:43 - map that is going to be built and it's
648:45 - gonna display the the length of that
648:47 - element so if you run this
648:51 - we get 0 3 T 5 F4 so we have the first
648:58 - letter uppercase and then we have the
649:01 - length three then we have t we have the
649:04 - letter upper case and we have the value
649:05 - five the length of that uh uh element
649:08 - then we have F so we have a four and we
649:13 - have the the the transformation apply on
649:16 - that element on this element on on four
649:21 - and we have the length and we have four
649:22 - so this is how we can use transformation
649:25 - Transformations with the associate by
649:27 - function and the next we're going to
649:30 - look at the next transformation fact
649:33 - function and that is flattened now it's
649:35 - time to look at the next transformation
649:36 - function that you can use and that is
649:38 - the flattened function but first let's
649:40 - see why you'll need to use this
649:41 - flattened function in the first place
649:43 - so I'm gonna add the comment here called
649:45 - flatten
649:50 - and I'm going to create a variable here
649:52 - so I'm going to die Val it's going to be
649:53 - called numbers
649:55 - sets and this is going to be a list with
649:58 - list so I'm gonna type here
650:01 - list of
650:04 - and inside the list I'm gonna Pro I'm
650:06 - gonna type set off so we have a list
650:09 - inside the inside of our list
650:12 - and I'm going to provide some values to
650:13 - our set of like one two three
650:17 - then another set of
650:22 - four five and six
650:25 - then another set of
650:32 - seven
650:34 - eight and nine so
650:38 - what we are having now is we have a list
650:41 - within a list where the index of this
650:44 - list is it's its own list so we have a
650:48 - list of sets of ins
650:51 - now if you want to Loop through this
650:53 - list if you want to display the elements
650:55 - in this list uh it is not that easy
650:57 - because you will first need to Loop
651:00 - because let's say that because what we
651:04 - have here
651:05 - is what is called a multi-dimensional
651:08 - array so more specifically what we have
651:11 - here is a two-dimensional array and at
651:14 - the index 0 we have a list at the index
651:17 - one we have another list and at the
651:19 - index two we have another list
651:21 - and to navigate to this list we need to
651:24 - first get inside that list that is at
651:28 - that other specific index to Loop to
651:30 - that list and then we need to move to
651:32 - the next index and to to look to that
651:35 - list to that next list which is that
651:38 - index
651:39 - but now let's see first how we can
651:41 - access one individual element from our
651:43 - two-dimensional array so from our array
651:45 - of arrays and to do that to type here
651:48 - print line
651:49 - gonna put numbers set
651:52 - and if we we put square brackets and we
651:56 - Define the index from uh which from
652:00 - which list we want to access the element
652:01 - and now I want to access the element
652:03 - nine and the element 9 is stored at the
652:06 - index two so we put two
652:09 - and let's say that I want and I want to
652:12 - access as I said the the element 9 now
652:15 - to access the element line I need to go
652:17 - within this list and use the index to
652:19 - get the element I and element 9 is
652:22 - stored at the index two so I'm going to
652:23 - put square brackets two
652:25 - but this for whatever reason doesn't
652:27 - work with a list of sets and we need to
652:29 - change this to array of
652:31 - array of also those
652:35 - also change it to array of
652:40 - array of also array of an hour
652:43 - everything will work fine
652:45 - so array of
652:47 - so if you run this so now we are
652:50 - accessing the
652:51 - index tool where the array is stored
652:56 - where our number is stored and we get
652:58 - the element two we get element nine so
653:01 - now if I run this we're gonna see nine
653:03 - autopilot in the console
653:08 - so we get nine so this is how you can
653:10 - access one individual element from our
653:13 - multi-dimensional array so I'm going to
653:15 - delete this I'm going to change it back
653:16 - to
653:17 - to a list of and to set off
653:20 - so let's type a list of
653:26 - set off
653:33 - set off
653:37 - and set off
653:44 - and now let's see how we can Loop
653:45 - through this type to the dimensional
653:48 - array and to do that to type here four
653:52 - and type numbers I type specific numbers
653:55 - because this is gonna as as you can see
654:00 - um gonna hold on hold the numbers the
654:02 - set of numbers four numbers in number
654:05 - sets
654:08 - so now you we are you we are getting the
654:10 - as you can see here this is of type is
654:12 - the the type set of ins so this uh
654:16 - basically gets the element of the number
654:19 - set index let's say zero and it gets the
654:22 - first set and now we need to Loop
654:24 - through that set so another four
654:27 - number
654:29 - in numbers so now we are looping
654:32 - through the list through the set which
654:36 - is inside the list of the index zero I
654:38 - didn't zero
654:40 - and you can add the print line to add to
654:43 - do output that number I'm going to type
654:45 - here number and also I'm gonna add the
654:47 - space here so I'm gonna add the print
654:48 - line here and I'm gonna type here four
654:50 - or slash
654:52 - n
654:53 - now if you run this
655:00 - as you can see you have on the output
655:03 - one two three then we have a space four
655:06 - five seven six then seven eight and nine
655:10 - but uh we achieved this by using a loop
655:13 - and then we use another loop so we have
655:16 - a loop inside the loop we have a nested
655:17 - Loop in order to get to the
655:21 - to this uh two dimensional array because
655:23 - as I said the in the index of this array
655:28 - is its own list so it contains the list
655:31 - now with the flattened uh with the
655:34 - flattened function what you can do is
655:36 - that we can convert this two-dimensional
655:39 - array in one dimensional array so you
655:42 - don't need to use this nested for Loops
655:44 - in order to Loop through to them it will
655:47 - return the nested the nested
655:50 - uh is it to private it will provide
655:52 - access to the nasty collection elements
655:55 - without you needing to Loop through this
655:59 - two-dimensional Ray it will it will
656:02 - basically
656:03 - take that two-dimensional array and it
656:06 - will convert it in one dimensionally and
656:08 - you will not need to create to have this
656:11 - nested Loop inside you have to have this
656:13 - Loop inside the loop in order to to
656:15 - display the number so to do that to type
656:18 - here uh Val
656:20 - numbers let's say flatten
656:24 - equals to
656:26 - number sales so our our list to it list
656:30 - that
656:32 - flatten
656:34 - now if you look at the type here now
656:37 - this is a list of fins you no longer
656:39 - have a list of sets of ins so this is a
656:44 - very very uh informative because it
656:47 - tells us that this now is just simply a
656:49 - list of ins is not a list with the set
656:52 - which is which is uh which itself is
656:56 - also or a list of events so
657:01 - this converts that two-dimensional array
657:03 - in one dimensional array and because of
657:06 - that now it's much easier to get one
657:07 - element from our list because now our
657:09 - list is not a two-dimensional array and
657:11 - it's just one dimensional array so if I
657:14 - type here print line
657:16 - and the
657:17 - let's say that I want to get the element
657:20 - nine I'm going to type here uh
657:23 - numbers flatten
657:26 - square brackets and I'm going to type
657:28 - here eight because it's stored at the
657:30 - index 8. so now if I run this
657:36 - so we get 9 here and as you can see this
657:39 - is much easier than uh with the the two
657:43 - that dimensional array so this is what
657:45 - the flattening function is doing is
657:46 - converting the
657:48 - the two dimensional array or if a
657:51 - multi-dimensional array in into one
657:53 - dimensional array so now let's look how
657:55 - we can Loop through our uh one dimension
657:58 - array
657:59 - so let's delete this
658:04 - and if you want to to Loop through this
658:06 - you just type 4
658:09 - number
658:10 - in
658:12 - numbers flatten
658:15 - and we either here a print line
658:19 - number
658:22 - and
658:24 - let's comment this code
658:30 - and if you run this code
658:37 - now get the number displayed one after
658:41 - another so get one two three four five
658:43 - six seven nine and we got this because
658:46 - our function our flattened function our
658:49 - transformation function is transforming
658:52 - it's converting our two-dimensional
658:55 - array in one dimensional array so it's
658:57 - easier for us to get the elements into
658:59 - loop loop through them so this is what
659:01 - the flatten function is doing and next
659:04 - we're going to look at the
659:07 - string representation and the functions
659:10 - that you can use uh what we for the for
659:13 - the string representation
659:15 - I'm going to close the console
659:17 - now it's time to start a discussion
659:19 - about string representation so if you
659:21 - need to retrieve the collection content
659:23 - in a readable format you can use
659:25 - functions that transform the collections
659:27 - to Strings and there are two functions
659:29 - to do that the join to string and the
659:31 - join two The Joint to string build a
659:34 - single string from the Collision
659:36 - elements based on the provided arguments
659:38 - the join 2 does the same but appends the
659:42 - result of the given appendable object
659:43 - and what that means is that it's gonna
659:45 - add the text to the object on which that
659:49 - function The Joint function is called
659:51 - you're going to see an example with this
659:52 - immediately
659:54 - and now I'm going to create a variable
659:57 - called numbers while numbers
660:00 - I'm going to put equals I'm going to
660:02 - call it actually numbers strings
660:05 - equal
660:06 - and I'm gonna type here list off
660:12 - and I'm gonna put here
660:14 - the text one
660:17 - two
660:21 - three
660:25 - and four
660:26 - now if you want to retrieve the
660:28 - this if you want to get the string
660:31 - representation of this list
660:32 - if you just type here print line
660:35 - and type you put your numbers strings
660:38 - and if you run this
660:44 - we get one two three and four but this I
660:48 - I think is calling the two string
660:49 - function it's not because we're not
660:51 - using the joint to string function and I
660:54 - don't like those
660:56 - square brackets I want them to be
660:59 - separated by comma with spaces to get
661:02 - the to get data just type here
661:04 - print line
661:08 - so let's
661:10 - put here print line
661:16 - and to type numbers to string
661:20 - Dot
661:23 - joint to string
661:25 - and uh we don't we delete this and put
661:28 - parenthesis
661:31 - now you throw on this
661:34 - you'll see now the single presentation
661:36 - of our list they are going to be
661:38 - separated by comma when we do is going
661:42 - to have a it's going to have
661:44 - spaces now let's look at the Joint 2
661:46 - function and for that
661:49 - I'm gonna Define another list down here
661:52 - so I'm going to type here let's press
661:54 - Ctrl alt for model code
661:58 - so I'm going to type here uh
662:01 - Val
662:02 - is going to be called list string
662:06 - and now I'm going to use something
662:07 - called
662:09 - a string buffer and this is like the
662:12 - string type is a little bit different
662:14 - but it's gonna allow us to do
662:18 - is going to allow us to present how the
662:21 - joint function over so string buffer and
662:24 - we put parenthesis and here we Define
662:26 - our text and we're gonna type the list
662:29 - of numbers I'm going to put colon so the
662:31 - type here the list
662:34 - of numbers
662:37 - colon
662:39 - now to use the join 2 function just type
662:43 - here another print line
662:46 - we we type number string
662:50 - number strings dot join tool
662:54 - and as you can see this receives a
662:56 - buffer and this is the buffer that we
662:58 - have created here so I'm gonna
663:01 - press enter and we're going to type I'm
663:03 - gonna give us the argument the listing
663:06 - that we created
663:08 - and what is this this is gonna do is
663:10 - gonna append this text that we have here
663:14 - in front of all of our elements that we
663:17 - have in our list number strings so now
663:19 - if you run the squad
663:26 - as you can see it added the text the
663:29 - list of numbers that we have here to our
663:32 - number strings in front so we have the
663:34 - list of numbers one two three and four
663:36 - now
663:38 - if you want to build the
663:40 - custom string representation you can
663:43 - specify its parameters in a function
663:46 - arguments which are the separator prefix
663:49 - and postfix and the result will start
663:52 - with the prefix and end with the with
663:55 - the postfix and the separator will come
663:57 - will come after each element except the
664:00 - last so let's see how we can do that
664:02 - so
664:03 - um I'm gonna use
664:08 - I'm going to use the number numbers to
664:10 - string so I'm going to type here print
664:12 - line
664:14 - numbers to string
664:17 - and we type join
664:20 - join to string and we select this one
664:23 - with the you select this one with the
664:25 - which with the separator parameter
664:27 - and the type is separator so now we
664:30 - Define the what is going to be the S the
664:33 - separator here and we're gonna put
664:36 - quotation marks
664:37 - and we're going to put
664:39 - this so this is going to be our
664:41 - separator between our elements next
664:44 - we're going to define the prefix so we
664:46 - put we put here
664:48 - comma type prefix and now I'm going to
664:51 - put the prefix and the prefix is going
664:53 - to be the text start and colon so I put
664:56 - quotation marks start
664:59 - and colon
665:01 - and we also need to provide the post fix
665:04 - and to do that we put another comma here
665:08 - so those are named the arguments which
665:11 - are
665:12 - defined in this files and join the
665:14 - string so we type here
665:16 - postfix
665:19 - and we put
665:22 - colon
665:23 - and
665:25 - now if you run this you're going to see
665:27 - them separated by this separator that we
665:29 - Define here is going to have the prefix
665:31 - start and it's going to have at the end
665:33 - this post fix which is comma and N so
665:35 - now if you run this quad
665:42 - as you can see we have start and we have
665:44 - one then it's separated by the sign that
665:46 - we defined here then we have 2 3 4 and
665:50 - we have the end so we have our post fix
665:53 - that had defined here now
665:56 - for bigger Coalition you may want to
665:58 - specify
665:59 - limit so a number of elements that will
666:03 - be included into the result and if the
666:05 - collection exists that size with that
666:08 - limit all the other elements will be
666:10 - replaced with a single value called the
666:13 - truncated argument so let's see what all
666:15 - of this means so let's say that I have a
666:18 - list called the
666:19 - numbers let's type here Val numbers and
666:23 - I'm going to create a range from one
666:26 - to 100 so what we have here is 100
666:29 - numbers
666:30 - and let's say that I type here print
666:32 - line
666:33 - but first let's convert this to a list
666:36 - so I'm going to put this in parentheses
666:38 - so you put this in parenthesis
666:41 - and you put at the end that to list
666:45 - and this is going to convert now our
666:47 - range into a list and as you can see the
666:49 - the type is a list of ins and now if I
666:53 - type here numbers
666:55 - and if I run this code
666:58 - when I get all of our numbers displayed
667:07 - now with as I said with the join join
667:11 - tostring function we can specify a limit
667:13 - and also a truncated this is going to be
667:17 - the thing which is going to be sold out
667:19 - after our number limits so what I can
667:22 - type here is I can type join to string
667:27 - and uh which is also
667:31 - one with parenthesis so hero type limit
667:34 - the named argument limit and let's say
667:37 - that I don't want to get all the numbers
667:39 - as you can see here from to 100 and I
667:43 - want to get only the first 15 elements
667:46 - to do this you just type here limit 15.
667:50 - then we type truncated and that is going
667:53 - to be that this trunky thing is going to
667:57 - be showed after our limit number so I'm
668:00 - gonna put here uh quotation marks
668:03 - less than um sine dot dot and uh
668:08 - greater than PSI so now if you run this
668:11 - look at what we have in the output
668:16 - now we get we only have the first 15
668:20 - elements and then for the next elements
668:23 - we only have this uh
668:25 - string that we typed here this is this
668:28 - expression that we have here and we can
668:30 - change this if you can change this let's
668:31 - say to 25 so if you run this now you'll
668:35 - see only the first 25 elements displays
668:39 - foreign
668:41 - to string with the limit name argument
668:44 - and the truncated now let's say that you
668:48 - want to customize the representation of
668:50 - elements of the elements themselves you
668:53 - need to in that case you need to provide
668:55 - the transform function so what we can do
668:58 - is that we can type here print line
669:02 - let's say
669:04 - and I'm going to type number strings
669:08 - put dot join to string and choose this
669:12 - one with curly braces
669:13 - and here I'm gonna Define how this uh
669:16 - this uh
669:18 - list is going to be transform so how's
669:21 - going to be changed so I'm going to type
669:22 - here
669:24 - quotation marks element
669:27 - and I'm gonna put
669:29 - colon
669:31 - we're going to put the dollar sign
669:34 - and put it
669:36 - dot uppercase so we're gonna uppercase
669:39 - all the elements
669:42 - so if I run the code now
669:51 - get element and get one
669:54 - so you can get one uppercase an element
669:57 - to get two uppercase element three
670:00 - uppercase element four uppercase so this
670:03 - is how you can use the transformation uh
670:06 - we can this I can transform your list we
670:09 - using the joint to string function
670:11 - so this is our discussion about the
670:13 - string representation and now I'm going
670:15 - to move to the next sections so I'm
670:19 - gonna end the video now now it's time to
670:21 - start a discussion about filtering so
670:23 - what is filtering filtering is one of
670:26 - the most popular tasks in collection
670:28 - processing in kotlin filtering
670:31 - conditions are defined by predicates and
670:33 - that is Lambda function that take a
670:36 - collection element and return a Boolean
670:39 - value true means that the given element
670:41 - matches the predicate false means the
670:44 - opposite
670:45 - the standard Library contains a group of
670:47 - extension functions that lets you filter
670:49 - collection in a single call those
670:51 - functions leave the original collection
670:53 - unchanged so they are available for both
670:56 - multiple and read-only collections to
670:59 - operate the filtering result you should
671:01 - assign it to a variable or change the
671:04 - function after filtering
671:06 - now the basic filtering function is
671:09 - filter when called with a predicate
671:12 - filter Returns the collection elements
671:14 - that match it for both list and set the
671:18 - resulting Collision is a list for map
671:20 - it's a map as well
671:22 - now let's Define a variable here call
671:25 - number so let's type in val numbers I'm
671:28 - going to put equals to list of
671:33 - and I'm gonna type here
671:37 - one
671:40 - two
671:45 - three
671:47 - and four
671:53 - now if you want to filter this list what
671:56 - you need to do is let's create another
671:57 - variable here called
672:00 - longer
672:02 - then
672:06 - three
672:08 - I'm going to put equals I'm going to
672:10 - type numbers
672:11 - Dot and we type filter
672:15 - so filter
672:18 - and we choose this one
672:20 - and here we defined how our list so we
672:23 - will Define the expression which is
672:25 - gonna determine how our list is going to
672:28 - be is gonna be filtered so I'm gonna
672:31 - type here it so the element dot length
672:36 - let's say greater than
672:39 - 3.
672:40 - now if we I add the print line down here
672:43 - print line
672:46 - now this list is going to contain all
672:49 - the elements from our numbers list which
672:54 - are longer than three so if I put here
672:57 - longer than three and if I run this
673:01 - we get 3 and 4 because those are the
673:04 - only string numbers which have a length
673:07 - longer than three so I'm going to close
673:09 - the console next let's see how we can
673:11 - filter them up and for that I'm going to
673:13 - create another variable called numbers
673:15 - map
673:17 - foreign
673:22 - here the key is going to be a string key
673:24 - one
673:26 - the value is going to be one
673:28 - comma then
673:31 - key to
673:33 - to
673:37 - then
673:39 - key three
673:41 - two three
673:43 - and now I'm gonna put key 101
673:48 - two
673:49 - 101 the value
673:52 - now if you want to filter now this map
673:54 - I'm going to create another variable
673:55 - called filtered
673:59 - mop and it's going to be equal to our
674:01 - numbers map but it's going to be filter
674:04 - so I'm going to type DOT number snap
674:06 - that filter
674:08 - and now I'm going to filter filter the
674:10 - map both by the key and by the value so
674:14 - we type here it dot key
674:17 - dot ends with so we we want to filter it
674:21 - first by the key and the one that key to
674:23 - ends with a specific character and that
674:26 - character is going to be one
674:28 - and so we put the operator and we want
674:33 - the the value to be greater than 100 so
674:37 - we put here it
674:38 - dot value
674:42 - greater than 100 and the only key which
674:46 - satisfy this condition that we find here
674:50 - it's only is this key so now if I add
674:53 - the print line here
674:55 - and if I type filter map so the map
674:58 - which was filtered using the expression
675:00 - that we defined here
675:01 - now if you run this you're gonna see
675:04 - gonna see
675:06 - this in the output because this is the
675:08 - only one which satisfy the condition so
675:09 - you get key 101 and we get the value 101
675:13 - so this is how you can filter them up
675:15 - using the both the key and the value now
675:19 - the predicates in filter can only check
675:22 - the values of the elements if you want
675:24 - to use element position in the filter
675:27 - use filter indexed it takes a predicate
675:31 - with two arguments the index and the
675:33 - value of an element
675:35 - to filter correction by a negative
675:37 - condition use filter not it's written as
675:40 - a list of the elements for which the
675:41 - predicate yields false so let's see how
675:44 - we can do this so I'm gonna declare two
675:46 - variables down here
675:48 - file
675:50 - filtered
675:52 - index
675:54 - is going to be equal to numbers
675:57 - or a variable that is defined above
676:01 - that
676:03 - filter index
676:09 - and this is gonna take
676:11 - two parameters index and the value so
676:15 - I'm going to type here
676:18 - actually you need to put curly braces
676:24 - index
676:29 - let's change this to value
676:32 - actually let's keep it as s
676:36 - Ctrl Z
676:39 - and
676:40 - here we're gonna Define
676:42 - our expression by a by which our list is
676:49 - going to be filtered so I'm going to
676:50 - type here that first I want the
676:55 - index
676:57 - to not be equal to zero
677:04 - and
677:08 - I I also want
677:11 - that
677:14 - the value of the element so actually
677:17 - let's change this to valid to make more
677:19 - sense so let's type here to value
677:21 - because we're talking about those ones
677:24 - so I want the value of that string so
677:27 - the value dot length I want I want it to
677:31 - be less than a 5.
677:34 - all right so this is the transformation
677:36 - if you want this is not a transformation
677:40 - this is how we want to filter our
677:43 - numbers list that we defined above I
677:45 - want to
677:46 - filter both by the index so this is why
677:49 - we use the filter index and also by the
677:51 - value
677:52 - and I want the index to not be equal to
677:55 - zero this is the first condition for the
677:57 - filtering and I also want so use the end
678:01 - operator that the valued of the element
678:04 - the length to be less than five now if I
678:07 - print this if I added here a print line
678:11 - but first let's Also let's also use the
678:15 - uh filter not so I'm going to type here
678:18 - Val
678:20 - foreign
678:24 - filtered nut
678:26 - and I'm going to type equals numbers
678:30 - dot filter not
678:35 - curly braces
678:38 - and we type here it dot
678:41 - length
678:42 - so the value of the element
678:45 - is to be less than equal to 3.
678:49 - now if we output those two in the
678:52 - console so if I add here print line and
678:54 - I'm going to Output filter
679:00 - Index this should be filtered in the
679:02 - solicit Factor this
679:09 - so let's type here in the index
679:15 - I type it already
679:17 - so let's type here
679:19 - edex actually
679:22 - it will make more sense
679:26 - but I have Elixir so why anyway so I'm
679:31 - gonna output that first then I'm gonna
679:34 - hear a print line
679:35 - and I'm gonna type filtered not
679:39 - and filter not as I said is gonna return
679:42 - a list of the elements for which the
679:44 - predicate yields false
679:46 - now if you run those two look what
679:49 - you're gonna have on the output
679:54 - so this is the output for our first for
679:58 - this print line and for this print line
680:00 - so let's think about what we have here
680:02 - first we have two and four
680:05 - and we Define the filter here first the
680:08 - index which should not be equal to zero
680:10 - so the one is first excluded and we also
680:15 - want to that to the value that length to
680:17 - be less than five so the only ones which
680:20 - uh for which the value is less than five
680:22 - is the 2 and 4 because the length of the
680:27 - three is bigger than 5 because it has a
680:29 - length of 0 1 2 3
680:34 - 4 and
680:37 - the length is 5 but I want the length to
680:40 - be less than five not less than equal
680:42 - than five so this is why this is not
680:44 - included and you only have two and four
680:47 - next
680:49 - uh now use the filter nut and it's gonna
680:51 - as I said it's gonna return a list of
680:54 - elements for which the predicate for
680:56 - each this expression is gonna yield
680:58 - false so it's gonna go through all of
681:02 - our elements and it's gonna return the
681:05 - elements for which this is false so we
681:08 - get three
681:10 - N4 because those are the only ones which
681:13 - are not less than equal to three they
681:17 - are greater than equal to three so this
681:19 - is why we have here three and four
681:20 - because this returns if Returns the
681:23 - elements if the uh the the length of the
681:27 - element is less than equal to 3 so this
681:29 - is why you get here 3 and 4.
681:32 - and
681:33 - there are also functions that narrow the
681:35 - element type by filtering elements of a
681:38 - given type so there is a function called
681:40 - filter is instance which returns a
681:44 - collection of filaments of a given type
681:46 - being called so let's see how you can
681:50 - use that but first let's create a
681:52 - Val mixed
681:54 - let's call it mixed
681:57 - list
681:59 - I'm gonna put equals another card type
682:01 - list off
682:03 - and I'm gonna Define some mixed elements
682:05 - here so I'm going to type here let's say
682:07 - one
682:08 - two three then some charts like
682:14 - a
682:18 - B
682:21 - C
682:23 - now so on strings let's type here
682:26 - hello
682:28 - World another string
682:31 - Alex and let's also type
682:37 - a Boolean so let's type here let's say
682:39 - false
682:41 - now there is a function as I said which
682:45 - which Narrows the element type by
682:48 - filtering the elements of a given type
682:51 - so we can use this function called
682:52 - filter is instance so what you can do
682:56 - here is we can we can type
683:00 - mixed list
683:03 - Dot
683:04 - filter
683:06 - is instance
683:11 - so we choose I think this one not this
683:17 - one
683:18 - filter is instance
683:22 - of Y so mixture is that
683:26 - filter
683:29 - is instance
683:35 - and here with inside the angle brackets
683:39 - we Define the generic type for which
683:41 - this list is going to be filtered so
683:42 - let's first choose the chart Char then
683:46 - I'm going to put that for each so I'm
683:49 - going to use the for each Loop
683:51 - and I'm gonna add print line
683:54 - and I'm going to type it here so I'm
683:56 - going to type the parameter
683:58 - which is the each chart so now if I run
684:00 - this we will get only the charts being
684:04 - displayed here because it is filtering
684:06 - by using the instance of charge so you
684:08 - get the charge if I change this to
684:12 - to in now I'll get the integers from our
684:15 - mixed list so if I run this
684:22 - now get the integers one two three that
684:24 - we have defined here
684:25 - and if I change this to let's say a
684:28 - string I will get the strings inside our
684:31 - mixed list because filter is instance
684:34 - it's gonna take the specific title that
684:37 - you type here and then it's gonna Loop
684:39 - through all of those types which are of
684:41 - this type in this list so if I run this
684:44 - I'm gonna see Hello World Analytics
684:50 - so we get hello world and Alex also I
684:54 - can filter for Boolean values if I type
684:57 - here Boolean is gonna
684:59 - it's gonna output in the closet or the
685:02 - one Boolean value that we have here
685:03 - which is false so if I run this
685:10 - I get false so this is how you can use
685:12 - the filter is instant function on types
685:15 - to filter the mixed list and you can
685:19 - also put that because this Returns the
685:21 - list this entire thing a filter at least
685:24 - you can put that for each to call the
685:27 - the this the for this for each Lambda
685:30 - function and then we output them in the
685:33 - console
685:34 - uh the next thing that you can look and
685:38 - that we're gonna look at is called
685:40 - Partition so I'm going to add a comment
685:42 - here but I'm going to hide the console
685:44 - first so I'm going to put here a comment
685:46 - I'm going to type here partition part
685:51 - T1 so partition
685:54 - and this is an alter another filtering
685:57 - function called Partition and it filters
686:00 - a collection by a predicate and it keeps
686:03 - the elements that don't match in a
686:05 - separate list
686:07 - so you have a pair of lists as a return
686:10 - value the first list is containing the
686:13 - element that match the predicate the
686:15 - predicate and the second one is
686:17 - containing everything else from the
686:19 - original collection so I'm gonna take
686:21 - again our numbers that have defined the
686:25 - path so I'm going to type here
686:27 - uh
686:29 - file and to to get this partition we put
686:33 - we put parentheses and here to type
686:36 - match so this is going to be the values
686:38 - which are going to be
686:40 - matched by the predicate and
686:44 - I'm gonna type here rest and you're
686:46 - gonna be stored the rest of the value
686:47 - which which don't match the expression
686:50 - the predicate that's going to be defined
686:52 - and I put here equals
686:55 - numbers
686:57 - dot partition
687:00 - and we type here it
687:03 - Dot
687:07 - length
687:10 - greater
687:11 - than 3.
687:13 - now if I
687:15 - other print line here
687:18 - I can print first the match
687:21 - let's press Ctrl D and now I can print
687:24 - the rest of the elements which don't
687:26 - match this this condition this
687:29 - expression that is defined here so if I
687:31 - run this code
687:32 - you will see first all the elements
687:34 - which are greater than 3 and then we're
687:36 - gonna see the rest of the elements which
687:37 - are not greater than 3. but let's add
687:41 - the space here to make things more
687:43 - clearly so we're going to add a hero
687:44 - print line
687:46 - quotation marks for recession so let's
687:50 - run this again
687:57 - so we get three and four so those are
688:00 - the elements which are coming from our
688:04 - match list which is defined here uh
688:09 - which is uh which satisfy this condition
688:11 - which is greater than 3 so we have three
688:14 - and four so the length is greater than
688:16 - three
688:17 - and then we have one and two so those
688:19 - are the rest of the elements which are
688:21 - not satisfying this condition that is
688:24 - defined here so we have one and two so
688:27 - this is how you can use the partition
688:28 - function to
688:30 - to get the
688:34 - basically to get a pair in which the
688:37 - return of value the first is the first
688:39 - is the list containing the elements that
688:41 - match the predicate and the same code is
688:43 - the one containing everything else from
688:44 - the original collection
688:46 - so this is how you can use the the
688:48 - partition function so
688:50 - now I'm gonna end the video and see you
688:52 - in the next video now it's time to look
688:54 - at testing predicates and those are
688:57 - functions that simply test the predicate
688:59 - against the collection elements and we
689:01 - have three functions any
689:03 - which returns true if at least one of
689:05 - the element matches the given predicate
689:07 - then we have none which returns true if
689:09 - none of the elements match the given
689:11 - predicate and then we have all which
689:14 - returns true if all of the elements
689:15 - match the given predicate so let's test
689:18 - all of them so I'm gonna type here print
689:20 - line
689:22 - numbers
689:25 - that let's start with any so we put any
689:31 - so here we type it dot ends
689:37 - with
689:38 - and let's put let's say
689:41 - e
689:45 - then out of another print line
689:49 - numbers
689:51 - dot none
689:54 - it should be
689:57 - curly braces
689:58 - eat
690:00 - Dot and sweet
690:03 - let's say w
690:05 - and print line
690:10 - numbers
690:12 - dot all
690:14 - let's say it dot length
690:17 - so if if the length of all the elements
690:20 - is greater than one
690:23 - so now if you run this
690:25 - all of those gonna return either true or
690:28 - false
690:33 - so get true true and true this is
690:35 - because first testing any and then this
690:39 - returns true with at least one of the
690:40 - elements much in the given predicate so
690:42 - it is true we have
690:45 - two elements which ends with the E we
690:48 - have three and one so that's why you
690:51 - return true there
690:52 - then we check to see if uh none of the
690:56 - elements ends with W so we're checking
690:58 - to see if none of the elements uh in our
691:01 - numbers ends with w n is true not only
691:04 - for elements will end through double so
691:06 - we have two in the output
691:09 - then we check numbers.org so we check
691:11 - into if all the elements the line the
691:14 - length of all the elements the element
691:16 - strings that we have here one two and
691:18 - three are greater than one and this row
691:20 - all of them are greater than one so this
691:22 - one have true true intro
691:24 - so this is how you can use the test
691:26 - predicates uh on your collections
691:30 - first time to look at the plus and minus
691:32 - operators so in Catherine plus and minus
691:35 - operators are defined for collections
691:38 - they take a collection as the first
691:40 - operand and the second operand can be
691:42 - either an element or another collection
691:44 - the return value is a new read-only
691:46 - collection and let's look at an example
691:48 - on this I'm going to type here Val
691:51 - numbers
691:53 - you want to put equals two so now I'm
691:55 - going to type your Multiple List off
691:58 - Multiple List at least with we to which
692:01 - you can add and remove elements and I'm
692:03 - gonna type here
692:05 - one
692:08 - two
692:11 - three
692:13 - and four now if you want to add an
692:16 - element to this list you need to type
692:18 - here numbers dot add
692:21 - and here you need to specify let's say
692:23 - five and now this new element is going
692:26 - to be added to the list but with the
692:28 - plus and minus operator you can do we
692:30 - can do this in an another way so you can
692:33 - type here
692:34 - uh
692:36 - but I'm gonna put this in another list
692:38 - so you can type here Val
692:41 - plus list
692:44 - so we put equals to and type numbers
692:48 - Plus
692:49 - and to type five and now this element is
692:52 - going to be added to our list that we
692:55 - have here it's going to be added to the
692:57 - the string five and it's going to be
693:00 - stored in this plus list now let's look
693:02 - at the minus operator here Val I'm going
693:05 - to call this minus list
693:09 - and put equals 2 and I'm going to type
693:11 - numbers so now I'm going to use the
693:14 - minus operator so I put minus
693:16 - and we type minus
693:19 - multiple list of
693:21 - and we put here
693:23 - let's say three and four so we type here
693:27 - three
693:29 - and four
693:33 - I have an underline let's see what it
693:35 - says
693:37 - now anyway let's run our code to see
693:40 - what to get in the output
693:44 - but we need to add some print lines
693:45 - together so
693:48 - I'm gonna add here a print line
693:50 - plus list
693:57 - and another print line
694:02 - minus list now if I run this again
694:11 - we get one two three four and our
694:15 - Five Element added to our numbers list
694:18 - from our class list which is outputted
694:20 - here
694:21 - and then we get 1 and 2 because 3 and 4
694:25 - were removed using the minus operator so
694:27 - this is how you can use the minus and
694:29 - plus operators with the collections
694:31 - so this is our discussion about the plus
694:34 - and minus operators and I'm going to
694:36 - look at we're gonna
694:38 - uh
694:39 - move to the next section so I'm going to
694:42 - close the console and I'm going to end
694:43 - the video
694:45 - now it's time to start a discussion
694:47 - about grouping so the kotlin standard
694:49 - Library provides extension functions for
694:51 - grouping collection elements the basic
694:54 - function Group by takes a Lambda
694:56 - function and returns them up in this map
694:59 - each key is the Lambda result so the
695:01 - result of that expression inside the
695:03 - Lambda function
695:05 - and the corresponding values is the list
695:07 - of filaments on which this result is
695:09 - returned this function can be used for
695:12 - example to group a list of strings by
695:14 - the first letter
695:16 - you can also call Group by with a second
695:19 - Lambda argument a value transformation
695:21 - function in the result map of group y
695:24 - with two lambdas the key is produced by
695:28 - key produced by key selector function
695:30 - are mapped to the result of the value
695:33 - transformation function instead of the
695:35 - original elements
695:37 - so let's see what all of this means by
695:39 - looking at an example so if I type here
695:41 - Val
695:46 - numbers
695:48 - and I'm going to put
695:50 - list of
695:55 - again one
695:58 - two
696:03 - three
696:05 - four
696:08 - and five
696:12 - now we I can add here a print line
696:15 - I can type numbers
696:19 - and I can type here dot Group by
696:25 - and I'm gonna group it by
696:28 - it dot first so the first letter in in
696:32 - one of our elements that
696:36 - uppercase
696:38 - and now we're going to look at the next
696:40 - the next Group by with the key selector
696:43 - and with the transformation function so
696:47 - I'm going to type here print line
696:51 - numbers Dot
696:55 - group y
697:00 - so we have this one key selector so you
697:02 - type here key selector
697:04 - equals
697:05 - and here we put
697:09 - curly braces and we type eat that first
697:13 - so the first letter in our element so
697:16 - first it should be here
697:19 - we put a comma
697:24 - and we type value so the how the value
697:27 - of the the value of this list is going
697:30 - to are going to be transformed and here
697:32 - we also put curly braces and we put it
697:35 - that uppercase so put it curly braces it
697:38 - should be
697:39 - it dot uppercase
697:43 - let's press Ctrl alt L to format code
697:46 - and now let's run our code to see what
697:49 - we get in the output
697:57 - so we get
697:59 - for the first one number the numbers are
698:02 - grouped by for uh and we have this
698:04 - Lambda it that first.apper case it takes
698:06 - the first letter in Upper cases so it
698:08 - gets whoa whoa so then you get one
698:11 - we get T we get to we get F we get four
698:15 - we get uh then we use this one which on
698:19 - which we we uh you we we group uh
698:22 - elements with a second Lambda argument
698:25 - with the value transformation function
698:27 - and the result uh map of group y with
698:30 - two lambdas are the keys produced by the
698:32 - key selector and the function are the
698:34 - function are mapped to the result of the
698:36 - value transformation function so the
698:39 - results are mapped to this
698:41 - transformation that is defined here so
698:43 - this this is what creates the keys this
698:47 - is what creates the key this uh Lambda
698:49 - function and this is what creates the
698:52 - the the the the values so we get all
698:56 - because you get in that first so the
698:58 - first letter and get one because this is
699:00 - the value so the value is uppercased we
699:02 - get one so we get one here then we get
699:05 - again eat that first for the for all men
699:08 - so you get T then you get two and I get
699:10 - uppercased and get F lowercase f and get
699:14 - four and uh and five
699:18 - so this is our discussion about grouping
699:20 - and uh my suggestion for you is to play
699:23 - with the code try different values for
699:26 - the key selector for the value transform
699:29 - for uh try to group The Elements by
699:32 - different expressions and just play with
699:35 - the code until you get uh get uh until
699:39 - you get comfortable with the code now
699:42 - it's time to start a discussion about
699:43 - the driven collection parts and the
699:45 - quoting standard Library contest
699:47 - accession functions for retrieving parts
699:49 - of a collection
699:50 - these functions provide a variety of
699:52 - ways to select elements for the result
699:54 - collection listing their position
699:56 - explicitly specifying the result size
699:59 - and others I'm going to start with the
700:00 - first function called slice
700:02 - which Returns the list of collection
700:04 - elements with given integers the indices
700:07 - may be based either as a range or as a
700:10 - collection of integer values so I'm
700:12 - gonna create first domain function
700:14 - I'm going to type Val numbers I'm going
700:18 - to create a list of
700:21 - and I'm going to type here one
700:25 - to
700:28 - three
700:31 - four
700:34 - five
700:37 - and six
700:39 - now to use the slice function we simply
700:41 - add here a print line
700:44 - and we'll type your numbers
700:46 - dot slice
700:49 - and we create here arrange so we type 1
700:52 - dot dot
700:54 - 3
700:56 - and next we're going to add another
700:59 - print line and I'm going to type numbers
701:03 - dot slice
701:07 - and I'm going to put here now zero dot
701:10 - dot
701:12 - four
701:13 - and
701:16 - I'm gonna type step
701:20 - two
701:31 - foreign
701:38 - list so slice here
701:41 - slice
701:45 - and I'm gonna add another print line
701:47 - here
701:49 - numbers
701:52 - dot slice
701:56 - and I'm gonna add now a set here so I'm
701:59 - going to type set off
702:02 - and I'm gonna type
702:04 - three
702:07 - five
702:10 - and zero so let's press Ctrl R till the
702:13 - format the code
702:14 - now if you run this code look at the
702:17 - output
702:36 - so you first get the first three
702:39 - elements we get to
702:41 - two three and four because uh we're
702:45 - starting from the index one so we get
702:47 - two three and four
702:49 - then we get from 0 to 4 so you get one
702:53 - but you don't get the two because you
702:55 - have this step two which steps the
702:58 - second element and then we have three
703:01 - and five because it's stepping for the
703:03 - four so this is what step two is doing
703:05 - here
703:06 - and next we have numbers slice and get
703:10 - four
703:12 - six and uh one but we get them as the
703:16 - string representation we don't get them
703:18 - as
703:20 - as a integers so
703:24 - all right
703:27 - now
703:28 - let's look at the next functions and
703:30 - those are the take and drop
703:33 - and to get the specified numbers of
703:35 - elements starting from the first you can
703:38 - use the take function for getting the
703:41 - last elements use the take last when
703:44 - call when when called with a number
703:46 - larger than the collection size both
703:48 - functions return the whole collection to
703:50 - take all the elements except a given
703:52 - number of first or last elements called
703:55 - the drop or the and the drop loss
703:58 - function respectively
703:59 - so I'm gonna
704:04 - add some print lines here I'm gonna add
704:07 - print line
704:08 - and I'm going to type numbers
704:12 - dot take
704:18 - three
704:20 - Another Printer line
704:24 - numbers
704:27 - dot take last
704:30 - hmm
704:34 - also three then another print line
704:39 - numbers
704:40 - Dot
704:42 - drop
704:45 - one
704:47 - and another print line
704:54 - numbers
704:56 - dot drop last
705:01 - five now if you run this code
705:06 - look what you get in the output
705:12 - but let's add a space here so on another
705:15 - print line
705:17 - quotation marks photosyn now let's run
705:20 - this code again
705:27 - so we get uh
705:29 - for you get numbers take three and this
705:32 - function basically takes only three
705:36 - um
705:36 - three elements from our list
705:39 - then numbers take last three is gonna
705:42 - take the last three elements from hourly
705:44 - so I have four five and six
705:47 - then we have a print print line numbers
705:50 - drop one so you have two three four five
705:53 - and six and the first element is dropped
705:56 - so this this is what this function is
705:58 - doing
705:59 - next we have numbers dot drop plus five
706:02 - and this function is basically dropping
706:05 - all the uh file the last five elements
706:08 - and you have only the one so this is
706:11 - what those functions are doing
706:14 - you can also use predicates to define
706:16 - the number of elements for taking or
706:18 - dropping and there are four functions
706:21 - similar to the ones described above
706:23 - and those are take while take last while
706:27 - drop while and drop drop last while and
706:30 - let's look at all of them but I'm gonna
706:33 - put a space between uh
706:35 - our code that we have here so I'm gonna
706:37 - have the print line here
706:41 - quotation marks photo session
706:46 - print line
706:51 - so I'm going to type here numbers
706:53 - dot take
706:55 - while
707:00 - and here we Define the predicate I'm
707:03 - going to type
707:04 - not
707:05 - eat dot starts
707:08 - with
707:11 - f
707:13 - in quotation marks
707:16 - now another print line
707:21 - numbers
707:23 - dot take
707:26 - last
707:30 - while
707:33 - and we Define here the predicate it
707:37 - not equal to 3. not equal
707:42 - two three
707:45 - another print line
707:48 - we type numbers
707:54 - dot drop while
708:01 - and we Define the expression the
708:03 - predicate which is going to be applied
708:05 - for our drop last while
708:08 - so it should be
708:10 - drop while here
708:16 - and type it
708:19 - dot length
708:23 - equals equals to 3.
708:25 - and what another print line
708:29 - numbers
708:33 - Dot
708:35 - drop last while
708:38 - and we type here it contains
708:42 - it dot
708:44 - contains
708:50 - quotation marks I
708:53 - no
708:55 - if you run this code
709:04 - we first get one
709:07 - two and three so because here we check
709:10 - in we're uh because using the logical
709:13 - not operated we want all the elements
709:15 - which don't start with f so we don't
709:18 - have four and a five we have only one
709:20 - two and three
709:22 - next we have
709:23 - numbers that take last while and we
709:26 - Define the expression for which is going
709:29 - to be
709:30 - returned the elements by it not equal to
709:33 - three so you only have four
709:36 - five and six and uh the the the three
709:42 - the three is is missing and we don't
709:44 - have one because take last value only
709:46 - takes the uh last elements so this is
709:49 - why we have only
709:52 - and six when you don't have three so it
709:56 - doesn't care about the first element or
709:58 - uh about uh the second element
710:02 - next we have numbers drop while eat that
710:06 - length equals to 3 and here we have
710:10 - we have
710:12 - so it at the lines equals to three and
710:14 - we have
710:17 - three four five and six so
710:21 - this condition is satisfied so it
710:24 - basically it drops all the elements
710:27 - which are equal to three so we have
710:30 - three four five and six and all of those
710:32 - are bigger than three and the ones which
710:36 - are equal to three respectively one
710:39 - uh uh two and uh let's see and six
710:47 - actually six is appearing here
710:51 - so
710:54 - one
710:56 - two
711:02 - I don't know why six supreme but this
711:04 - basically saying that it should drop
711:06 - while if that length equals uh to three
711:10 - so it basically drops all the elements
711:12 - which are equal to with the length three
711:15 - so we have this is what we have here um
711:20 - three four
711:22 - five and six six should not be but I
711:24 - don't know why it's here now
711:26 - the next that we have here is numbers
711:29 - dropped last while so again this is uh
711:32 - Focus specifically about the last
711:34 - element so it contains I so get uh
711:38 - uh one two three and four so because
711:41 - this drop last while is basically
711:43 - basically dropping all the elements all
711:46 - the last Elements which contain uh which
711:49 - contains I so we have
711:53 - six five
711:56 - so we have a
712:01 - drop last while so we have it that
712:03 - contains I
712:08 - so it drops all the elements which
712:11 - contains I so sorry for what I said
712:13 - previously so this way I have here one
712:15 - two three and four and uh the five and
712:18 - the six are missing because it basically
712:20 - drops the old Elements which contains
712:22 - the letter i so this is how you can use
712:25 - the take and drop the next function that
712:27 - you can use is called chunked
712:31 - and
712:33 - if you want to break a collection
712:35 - through parts of a given size then you
712:37 - can use the chunked function chunks take
712:40 - a single argument the size of the chunk
712:42 - and Returns the list of
712:45 - [Music]
712:46 - list of the given size the first chunk
712:49 - starts from the first element and
712:51 - contains the size of the elements and
712:53 - the second chunk holds the next size
712:55 - elements and so on the last chunk maybe
712:58 - may have a similar size so if I have
713:01 - here let's change this to numbers
713:06 - strings and let's type here
713:11 - Val
713:13 - numbers
713:16 - while I was changing that I should use
713:18 - refactor so
713:23 - let's use a refactor
713:27 - rename
713:29 - numbers strings so it will be changed in
713:32 - all the places we're using that
713:35 - and here have numbers and I'm gonna put
713:39 - equals and I'll put parentheses
713:42 - zero dot dot 13. and I'm gonna put that
713:47 - to list to convert this to a list
713:50 - and we add a print line to see how this
713:53 - chunk function is working so we got the
713:56 - print right let's close the console
713:58 - and we type here numbers Dot
714:03 - Dot chunked
714:09 - and would put three so it's gonna chunk
714:12 - our elements into three into
714:17 - um
714:19 - basically elements of three so we have
714:23 - zero one two three four five six seven
714:27 - eight and they're both on on chunks of
714:31 - three elements so this is what this
714:33 - chunks is doing
714:34 - so this is why I have here this result
714:37 - and
714:41 - the next function that you're going to
714:43 - look at is called windowed and
714:47 - and we we can also use a transformation
714:50 - on our chunked element so I cannot hear
714:53 - a print line
714:54 - we type numbers
714:59 - Dot chunked
715:08 - chunked which we also choose the size
715:10 - three
715:12 - then you put curly braces and here I'm
715:16 - gonna Define how our chunked elements
715:19 - are going to be transformed so we put it
715:22 - dot
715:24 - sum so it's going to sum the chunked
715:27 - elements so if I press Ctrl I'll tell
715:30 - the format the code and now if I run
715:31 - this look what we're going to see in the
715:33 - output
715:39 - so we get uh you get first the chunked
715:44 - elements here
715:45 - in entry in three elements and then we
715:50 - have our chunked elements but they are
715:53 - summed up so we have first three because
715:55 - zero plus one plus two is three then we
715:58 - have three four five because that is
716:00 - twelve don't have seven eight uh seven
716:03 - uh
716:04 - six seven eight and they have twenty one
716:06 - then we have
716:08 - uh 10 11 and 9 and we have 30 and so on
716:12 - so this is uh how uh you can use the
716:17 - chunked function to chunk the elements
716:19 - together by a given size and you can
716:21 - also use the transformation function to
716:23 - do a transformation on them like adding
716:26 - them so as you can see we have adding
716:29 - them here
716:30 - next we're going to look at the next
716:32 - function function that you can use and
716:34 - that is called the windowed function and
716:37 - we can retrieve all possible ranges of
716:39 - the collection elements of a given size
716:41 - with the window function the function of
716:43 - getting them is called windowed it
716:46 - returns a list of element ranges that
716:49 - you would see if you are looking at the
716:50 - collation through a slightly wind off of
716:53 - the given size unlike chunked window
716:56 - returns element ranges Windows starting
716:59 - from each collection element all the all
717:01 - the windows are returned as an element
717:04 - of a single list so if I have here
717:11 - the
717:13 - let's create another
717:16 - variable here let's call it
717:20 - Val numbers
717:25 - string
717:27 - two
717:28 - and we're gonna type here let's say
717:33 - or I can assign
717:36 - I can assign the number of strings here
717:39 - so I'm going to type here number strings
717:42 - now what I can do here I I can add a
717:45 - print line
717:46 - and like I can type numbers string store
717:52 - Dot
717:54 - windowed and we choose let's say three
717:57 - and let's see what we have on the output
717:59 - so now if you run this code
718:02 - I should have added here a space so
718:05 - let's add the print line here
718:08 - backslash
718:11 - photo selection
718:16 - foreign
718:24 - so we have one two three then we have
718:26 - two three four you have three four five
718:29 - and four five six so this is similar to
718:32 - junk but window provides more
718:34 - flexibility because uh you can
718:38 - specify a step which defines a distance
718:41 - between the first element and and to a
718:44 - DH and windows by default the value is
718:47 - one so the result contains Windows
718:48 - starting from all elements if you
718:50 - increase the step to two you'll receive
718:52 - only Windows 30 from the other element
718:55 - first third and so on and finally you
718:59 - can apply transformation to the return
719:00 - ranges right away to do this you provide
719:03 - the transformation as a Lambda function
719:05 - when calling windows so it is similar to
719:08 - chunked
719:09 - and um
719:12 - so with this I think we end our
719:15 - discussion about the thieving collection
719:16 - parts and see you in the next video and
719:20 - if you find this confusing don't worry
719:22 - because it's so confusing for uh for me
719:26 - for me and for probably other people
719:29 - because it takes time to to get used to
719:33 - this and my suggestion for you just play
719:36 - with the code change the the parameters
719:39 - play with the functions try different uh
719:42 - values and so on so see you in the next
719:45 - video
719:47 - now we're going to look at some
719:48 - functions with which you can retrieve
719:50 - single elements from our Collections and
719:52 - the first one is one which retrieves an
719:55 - element by its position so I'm gonna
719:58 - create the Val numbers again
720:02 - numbers equals to
720:06 - list of
720:10 - and
720:12 - we type here
720:15 - one
720:17 - two
720:20 - three
720:23 - and four and also five
720:30 - and let's say that I want to get the
720:32 - element at position three to do that
720:34 - just add here a print line and we type
720:37 - numbers
720:43 - dot element
720:46 - and here you specify the position three
720:49 - so zero one two three so we're going to
720:52 - get four outputted in the console
720:57 - so we get in the output as expected for
720:59 - now there are there are also two
721:01 - functions for retrieving the first and
721:03 - last element and to do that just add
721:05 - another print line here
721:08 - and type numbers that first
721:11 - so this is gonna retrieve the first
721:13 - element and Ctrl d
721:15 - numbers Dot
721:18 - last so
721:20 - this is gonna receive the first element
721:22 - one and last is gonna retrieve the last
721:25 - element five so if you run this
721:29 - we get first four from our
721:33 - disappearance line then we get first one
721:35 - and again the last five
721:37 - and we can also edit three
721:39 - elements by condition so I can type here
721:43 - uh I can type down here or
721:46 - or I will type it here
721:49 - actually I'm going to type it down here
721:50 - it's going to add here a print line
721:53 - numbers let's say
721:56 - DOT first now I'm going to retrieve by a
722:00 - condition so once I first I'm going to
722:01 - choose this one with curly braces and
722:03 - the condition is that I want to leave
722:05 - the first element for which the length
722:08 - is greater than 3 so I'm going to type
722:09 - here it dot length
722:12 - greater than 3. and I'm gonna add I'm
722:15 - gonna press Ctrl D because I'm gonna do
722:17 - the same thing for the
722:20 - by condition so I'm going to type here
722:23 - numbers that last but I'm gonna change
722:25 - the condition I'm gonna change it to
722:28 - eat that starts with the it that starts
722:33 - with
722:35 - the letter f
722:37 - so now we're retrieving the first
722:39 - element which is greater than three and
722:42 - next retrieving the last element which
722:44 - starts with the letter f
722:46 - so now if you run this
722:51 - we get 3 and 5 because 3 is the first
722:53 - element which is has a length greater
722:56 - than three and can get five because this
722:58 - is the one the last element which starts
723:01 - with the letter F and if you can other
723:05 - space here if you want to make things
723:08 - more clear so we're gonna add the print
723:09 - line quotation marks
723:12 - backslashing
723:13 - actually
723:15 - forward selection
723:17 - so if you run this
723:26 - we get three and five output today in
723:28 - the console
723:30 - and we can also retrieve a random
723:32 - element from our numbers so I can type
723:34 - here print line
723:36 - numbers
723:37 - dot random and this is going to return a
723:40 - random number from our list of numbers
723:42 - so if I run this
723:49 - we get one and if I run this again
723:55 - get four so every time you run this
723:57 - you'll get a random number
723:59 - and you can also check if the list is
724:01 - empty so you can type here print line
724:04 - numbers
724:08 - that is empty then that is going to
724:10 - return true if the list is empty and if
724:14 - the list is not empty it's going to
724:15 - return false so if you run this
724:22 - we get false so this is our discussion
724:25 - about how to retrieve single elements
724:27 - see in the next video now it's time to
724:29 - start a discussion about aggregate
724:31 - operations so kotlin collections
724:33 - contains functions for commonly used
724:35 - aggregate operations
724:37 - and those are operations that return a
724:39 - single value based on the collection
724:41 - content most of them are well known and
724:44 - work in the same way as they do in other
724:45 - programming languages
724:47 - and we have minor null and Max ornal
724:51 - which return the smallest and the
724:52 - largest element respectively and on
724:54 - empty collections the return null then
724:57 - we have average which Returns the
724:58 - average value of elements in the
725:00 - collection then we have sum which
725:01 - Returns the sum of elements in the
725:03 - collection of numbers
725:04 - and have count which Returns the number
725:06 - of elements in our collections so please
725:09 - declare a list numbers
725:13 - list of
725:19 - let's put so let's put some numbers here
725:22 - like let's say six
725:26 - then
725:28 - 14
725:30 - 4
725:33 - let's say
725:35 - 100
725:37 - now let's press Ctrl format the code and
725:40 - let's add the print line here let's put
725:42 - quotation marks and let's type the sum
725:45 - is
725:47 - dollar sign
725:55 - and the type here numbers
725:59 - dot sum
726:02 - numbers
726:04 - that's sum
726:07 - all right and uh
726:10 - I'll add another print line and now this
726:13 - is gonna say
726:16 - the
726:17 - count is
726:20 - again dollar sign
726:23 - numbers
726:26 - dot count
726:28 - another print line
726:34 - the average
726:38 - is
726:40 - again dollar sign
726:43 - numbers that average
726:46 - another print line
726:51 - and now I'm going to say the
726:54 - max value is
726:58 - again dollar sign numbers
727:02 - dot marks
727:05 - numbers Dot
727:10 - marks
727:13 - or null
727:16 - and I'll print line
727:20 - the mean value is
727:25 - dollar sign numbers that mean
727:30 - or null
727:33 - now if you run this code you're gonna
727:36 - see in the output the corresponding
727:38 - values for those expressions that we
727:40 - have here so again the sum is 134 the
727:43 - count is 5 because we have five elements
727:45 - here the average is 26.28 the maximum
727:50 - value is 100 and the minimum value is 4.
727:53 - so this is how you can use those
727:54 - aggregate operations and agree and those
727:58 - aggregate um
728:00 - functions and beside the regular sum
728:04 - there is an advantage so much summation
728:06 - function called sum of that takes a
728:09 - selected function and Returns the sum
728:11 - sum of its application to all collection
728:13 - elements and let me show you how this
728:15 - works so you just type here
728:18 - so we type here print line
728:23 - the sum is
728:28 - dollar sign
728:30 - numbers
728:32 - dot sum of
728:35 - we select this one
728:37 - and here we type it
728:39 - times two
728:42 - now if you run this what it's going to
728:43 - do is it's gonna sum all the numbers
728:46 - like the first function that we have
728:48 - here so it's going to sum 134 and it's
728:51 - multi is going to multiply that that
728:53 - number by two so if you run this
729:00 - we get 260 which is 132 times
729:05 - 134 times 2. so this is how you can use
729:07 - the sum off with this uh
729:10 - transformation which is gonna basically
729:12 - multiply the list with a number with the
729:16 - with the sum of the list with the number
729:18 - so this is our discussion about
729:20 - aggregate operations and see you in the
729:22 - next video now it's time to start a
729:24 - discussion about ordering and in this
729:26 - video we're going to look at comparable
729:27 - and add comparator interfaces
729:30 - so first I'm going to create a list of
729:33 - numbers
729:36 - and
729:37 - I'm not gonna
729:39 - I'm gonna get a multiple list so
729:41 - Multiple List off and I'm gonna
729:44 - Define some numbers here not in a
729:46 - specific order
729:48 - so we type two let's say five
729:52 - one
729:54 - let's say
729:56 - 40.
729:58 - 20.
730:00 - 100 let's say
730:04 - 60. now what if I want to
730:08 - order the numbers that I have inside our
730:12 - list numbers to do that you just need
730:14 - you type numbers
730:17 - Dot
730:19 - and there is a function called sorted so
730:21 - if I type number that's sorted now our
730:25 - number on our numbers are going to be
730:27 - sorted so if you type here for each
730:30 - put in the line
730:33 - it
730:36 - so now if you run this
730:38 - even though we didn't type our numbers
730:42 - in ascending order there will be sorted
730:45 - and as you can see they are sorted we
730:47 - have one two
730:48 - five twenty forty six three and one
730:51 - hundred so they are sorted by this
730:54 - function called sorted and why this is
730:56 - working
730:57 - it's working because if you click on
730:59 - this sorted function
731:02 - what a
731:03 - actually if you type here let's say
731:07 - let's say that I put the type here
731:11 - and
731:12 - if I click on the type
731:17 - this tie this type integer this class is
731:21 - implementing this thing called
731:22 - comparable and this comparable has a
731:25 - function called compare to so when we
731:28 - actually type numbers that are sorted
731:30 - what what internally was happening is
731:33 - that the integer class was using the
731:36 - compared to function which is which is a
731:39 - function which you want to you need to
731:43 - implement if you implement the
731:44 - comparable interface to compare if
731:48 - to compare our numbers and to based on
731:51 - that to to sub them to to sort them
731:54 - and now let's say that I have or let's
731:59 - say that I have a data class
732:03 - called laptop
732:05 - and it's gonna have a
732:07 - variable called brand it's going to be
732:10 - of type string
732:13 - another variable called here this could
732:16 - be the the year one one this specific
732:19 - version was released on int
732:24 - also need
732:26 - and the wall
732:28 - let's say um
732:31 - price also an integer
732:33 - right now if I create here a list of
732:38 - laptops laptops
732:43 - equals to Multiple List of
732:46 - and I type here laptop
732:50 - let's say that I type here Dell
732:54 - and I put the year let's say 2021
732:58 - the ram let's say that is four gigabytes
733:01 - RAM and the price will say that is
733:04 - 600 okay
733:06 - comma I'm going to create another laptop
733:08 - here
733:09 - so another object I'm gonna type here
733:11 - let's call it
733:13 - Acer
733:15 - is going to be let's say the year um
733:19 - let's put 20
733:22 - 20.
733:24 - the para is let's say the ram let's say
733:27 - that is eight gigabytes Ram
733:30 - and the prices say that it's 100 dollars
733:34 - comma and let's create another laptop
733:37 - object so we type laptop
733:39 - and create an Apple laptop which is
733:42 - which you're gonna for which you're
733:44 - gonna choose the
733:45 - the year let's say
733:47 - um
733:51 - Tony
733:54 - 2020
733:56 - 2022
733:57 - and
734:00 - for the ram let's say they're choose 16
734:02 - gigabytes RAM and 1 000 for the price
734:06 - now if I type here laptops
734:10 - that sorted let's say that I want to
734:12 - sort the laptops as if you can see while
734:15 - on time pink the IntelliJ is not giving
734:18 - me any hints to have this function
734:21 - sorted
734:23 - as a true fill in that function because
734:26 - that function is not working on our
734:30 - laptops list and why why is happening
734:32 - that
734:34 - that is happening because the IntelliJ
734:36 - doesn't know
734:38 - how we want to sort this laptop list
734:41 - that we have here because you want you
734:44 - can sort it in many ways you can sort it
734:45 - by the name you can sort it by the year
734:48 - you can sort it by Dynamic and sort it
734:49 - by the price so when you say laptops are
734:52 - sorted the IntelliJ is not it's not
734:56 - annoying
734:58 - what do you mean because previously it
735:00 - was working with our integers or and
735:03 - without integer class because the
735:05 - integer class if you type if you put the
735:09 - type here
735:10 - back integer
735:12 - the integer class or the int class what
735:15 - I was doing actually it was inheriting
735:17 - from this comparable interface and it
735:20 - was implementing the compared to
735:22 - function which is used when you call the
735:26 - sorted function and inside this
735:29 - comparative function it has defined its
735:32 - own Logic for comparing integers for
735:35 - comparing whole numbers and what we need
735:38 - to do in order to be able to
735:40 - sort our list of laptops is we need to
735:43 - implement the comparable interface and
735:45 - you need to Define our own logic which
735:48 - is going to determine
735:50 - how our list is going to be awarded by
735:53 - by which uh property by the Year by the
735:56 - ram by the price so this is what you
735:58 - need to do and to do that just put here
736:00 - a colon and we'll implement the
736:03 - interface comparable so we type it
736:05 - comparable and we have a suggestion you
736:07 - should choose this one
736:09 - we put angle brackets and here we type
736:12 - laptop because you want to implement
736:14 - this we want to compare laptops so
736:17 - laptops so this swipe water level there
736:19 - then you put curly braces and now we
736:21 - need to implement the function so click
736:24 - on that it says Implement members you
736:27 - have the compare to function now
736:30 - you don't need to Define our logic which
736:32 - is gonna determine what makes uh uh zero
736:38 - the final logic which is going to
736:40 - determine how our elements is going to
736:42 - be watered by what criteria and I'm
736:44 - gonna order the the laptops first by the
736:47 - price and to do that to do that just
736:50 - type if and to type this and we type in
736:55 - this because this is going to be called
736:56 - on an inst an instance of our laptop
737:00 - left of class is going to call the
737:03 - compared to function and it's going to
737:05 - compare with another argument so if this
737:08 - dot price we say here
737:10 - is greater than other
737:13 - that price
737:15 - we we return as positive number so we
737:18 - type return one and a positive Value
737:22 - Plus simply shows that the receiver
737:25 - object so the objects
737:28 - this object is greater than the the uh
737:32 - the object which was passed so this is
737:35 - what this means this one else lcf is the
737:39 - receiver object is not so if this dot
737:42 - price is less than other that price
737:45 - let's say then gonna return
737:48 - -1 a negative number so I'm going to put
737:51 - here minus one and what this basically
737:53 - logic is I'm just going to swap them so
737:55 - it's going to swap the elements based on
737:56 - this logic else I'm going to return 0
738:00 - and that is going to mean that they are
738:01 - equal so if you type here return 0. and
738:05 - if you click here it says that you can
738:07 - write this in a different way so if you
738:09 - click on this
738:11 - and let's add the print line to see that
738:13 - our if if uh are called so if I type
738:17 - here print line
738:19 - I'm gonna say
738:24 - in if statement
738:29 - dollar sign
738:33 - actually let's type swapping
738:36 - dollar sign
738:39 - this dot brand name
738:45 - with
738:46 - dollar sign
738:48 - other
738:50 - dot brand
738:53 - so let's add this print line also in our
738:55 - lcf
738:58 - and I'm not gonna add in inside the ears
739:00 - because our we don't have Elements which
739:02 - are equal but
739:03 - you can add that if you want now if I
739:06 - type laptops that's sorted now I have a
739:09 - suggestion and if I type for each
739:14 - print line it so print the element
739:18 - now if you run this look you're gonna
739:21 - see the elements sorted and uh ascending
739:25 - order by their uh their price so you see
739:28 - that we have first the brand the brand
739:31 - name Dell and we have price 600 then we
739:35 - have
739:36 - the price uh you have laptop Acer and we
739:39 - have eight hundred dollars and have left
739:41 - to apoll the brand and you have the
739:44 - price one thousand dollars so the
739:45 - nearest so now they are sorted using our
739:49 - own logic which was defined inside this
739:51 - comparable interface and which was
739:55 - defined inside the which was defined by
739:58 - this comparable interface and which was
740:00 - defined inside this function compared to
740:02 - that we've overrided inside our client
740:05 - and as you can see
740:07 - if uh you look you see here that he says
740:11 - if an if statement swapping Acer window
740:13 - so the elements are swapped based on our
740:16 - road in if statements it says swapping
740:19 - apple with Acer so they are they are
740:21 - swapped based on our logic
740:24 - so this is how you can use the
740:25 - comparable uh interface but what if I
740:28 - want now to compare by the
740:30 - let's say uh RAM what can I do I can't
740:34 - implement the comparable interface again
740:37 - here and I can't uh
740:40 - I I can I can add the that property here
740:43 - but that is gonna conflict with my logic
740:45 - with for the price so what can we do and
740:49 - here comes into action comparator
740:51 - with comparator you can compare your uh
740:54 - your list you can you can uh com you can
740:58 - order actually I should say you can sort
741:00 - your list using multiple properties so
741:04 - you can order it by the uh brand name
741:07 - you can order by the year we can already
741:09 - buy the ram you can already buy the
741:11 - price and with compare because with the
741:14 - comparable interface
741:15 - we can do that just only by one property
741:19 - and that is pretty uh inflexible and
741:23 - it's not what you want and how how to
741:26 - use this comparator to use the
741:30 - comparator we just type here
741:32 - class
741:34 - I'm gonna call it
741:36 - comparator let's say Ram
741:41 - and it's gonna extend
741:45 - from comparator so type comparator and
741:48 - you have the type and for the type here
741:50 - we want to compare laptop so you type
741:52 - laptop here
741:54 - angle brackets curly braces and press
741:56 - enter
742:00 - and now we need to override
742:02 - the
742:05 - compare function inside our class so you
742:07 - override that function and here again
742:09 - let's change those to laptop one
742:15 - so no now we have laptop one and laptop
742:18 - two
742:20 - and we Define
742:24 - the same logic so we type here uh
742:28 - return
742:30 - if because you need to return an integer
742:32 - if
742:34 - this dot Ram
742:36 - actually not this that ram laptop
742:40 - laptop1.com
742:43 - is greater than laptop 2.
742:46 - Ram
742:48 - and we need to delete this nullables
742:51 - because you need to
742:52 - have some errors there
742:55 - and put curly braces return one else if
743:03 - else if laptop
743:06 - one dot Ram
743:09 - is less than laptop 2.
743:13 - laptop two dot Ram then gonna return I'm
743:19 - gonna put curly braces I'm gonna type
743:21 - return
743:22 - minus one else
743:25 - we're gonna return
743:28 - zero now if I want to now to compare our
743:33 - let's add the space here now I want to
743:35 - sort our elements based on the RAM and
743:38 - another print line here to add a space
743:41 - so I'm gonna have the biggest photos in
743:44 - also here one
743:47 - so go quickly space it here
743:50 - should be print
743:55 - and now what we can do is we type
743:58 - laptops Dot
744:01 - and we type here
744:02 - sorted with and which is we choose this
744:06 - one which has the parameter Define a
744:08 - comparator and we're going to pass our
744:10 - comparator that we defined here with the
744:12 - comparative function so I'm gonna pause
744:14 - I'm going to type sorted with and we
744:17 - type comparator
744:20 - foreign
744:22 - our class
744:24 - and
744:28 - create an instance and within the type
744:30 - dot for each now this one
744:34 - for each print line
744:37 - it
744:38 - so now if you run this you're gonna see
744:40 - them sorted by their border Ram
744:44 - so if you run this
744:47 - as you can see uh if you look at the
744:52 - if you look at the first there are they
744:55 - are First Source did by their price we
744:57 - have 68 800 and 1000 dollars and then we
745:03 - have them sorted by the ram so we have
745:05 - four for the four which is the dell and
745:08 - then we have the Acer which is uh eight
745:10 - gigabytes around and you have the Apple
745:12 - which is 16 and uh if you look uh
745:15 - actually they are in this order in the
745:18 - list so let's change this to to let's
745:20 - say to 16 and these two to wait
745:24 - to
745:25 - to make it more clear so let's run this
745:27 - again
745:31 - so as you can see they are still started
745:33 - so we have first the Dell which has four
745:36 - gigabytes of RAM then we have the Apple
745:39 - which is eight then we have the Acer
745:40 - which is 16. so this is why so now it's
745:43 - sorting our list this sorted width using
745:47 - comparator Ram that we defined we
745:49 - created and then we Loop through all our
745:52 - all elements because that Returns the
745:53 - list so this is how you can use
745:55 - comparator and if you want to uh to to
745:59 - sort of let's say now the list by the
746:00 - year you just create another comparator
746:02 - so you type class
746:04 - comparator let's say here
746:07 - and it's also going to extend comparator
746:10 - comparator
746:12 - is going to have for the type laptops
746:15 - because it's gonna Source laptops curly
746:18 - braces we implement the function compare
746:21 - and to define the logic for comparing
746:23 - elements using uh using the ear so let's
746:27 - delete this nullables
746:29 - let's type here laptop one
746:32 - and here laptop too
746:36 - and I'm gonna copy this chord
746:43 - I'm gonna paste it here
746:47 - but I'm going to change this from Ram to
746:50 - here
746:51 - so here
746:54 - here
746:59 - also here
747:05 - again
747:07 - and we have an error here
747:11 - missing so let's add the curly brace
747:13 - here
747:16 - all right so now if I want to to have
747:19 - the element sorted by the year we just
747:21 - type here
747:22 - let's put a space Also print line
747:26 - quotation marks for us this run and
747:29 - found the laptops to be sorted by the by
747:31 - the by the year I just like laptops that
747:33 - sorted with
747:35 - and this expects a comparator so I'm
747:37 - gonna call our comparator that we
747:39 - created comparator here comparator
747:43 - here
747:44 - an instance of that then for each
747:47 - now this one again for each
747:51 - print line
747:53 - it
747:54 - so if you run this
747:57 - now we're gonna see the last element
747:59 - sorted by their ear I have as you can
748:03 - see
748:04 - you have uh we have them sorted by the
748:06 - ram so this is from this one
748:10 - and now it's using comparator here so
748:12 - you're sorting the embodies we have 20
748:13 - 20 21 and 2022 so this is just not like
748:17 - the order that they are defined in uh in
748:20 - the list so this is how you can use
748:22 - comparable and comparable but if you
748:24 - think about there is a lot of code here
748:26 - to just have to have our
748:29 - our list so that you have to we found
748:33 - to
748:35 - you have to you can use the compare the
748:38 - comparable and with the comparable you
748:40 - can use it with just one property and if
748:43 - you want to use it with another property
748:44 - you have to create those comparators
748:46 - which gives you some flexibility but
748:48 - still you have a lot of code and we can
748:51 - remove all of this code
748:54 - and use Lambda
748:56 - functions
748:58 - so I can delete all of this
749:01 - all of this comparable that we have here
749:04 - and instead of using those comparators
749:07 - and all of this stuff what I can do is I
749:09 - can delete all of this
749:12 - I can little or this also
749:16 - now what I can do is I can add here
749:18 - laptops dot sorted
749:22 - with and here
749:25 - so we choose this one sorted with which
749:27 - has this parameter comparator press
749:30 - enter and here we type
749:34 - compare
749:36 - by
749:37 - and here we type and this line of code
749:40 - that we have here we it what it actually
749:43 - is doing is creating a comparator but is
749:46 - creating a comparator using a Lambda
749:48 - expression so here you can type it dot
749:52 - it's dot let's say uh price
749:55 - right and then for each print line
750:00 - it so this is equivalent to creating
750:03 - that comparator here and inheriting from
750:07 - the comparator interface and defining
750:09 - the logic for uh uh or ordering for
750:13 - sorting them so now if you if you run
750:16 - this this will have the same effect like
750:18 - the comparator price that we have
750:21 - implemented previous as you can see they
750:23 - are ordered now by the price and I can
750:25 - do
750:25 - now on another line of code Source dot
750:29 - laptop dot sorted weight
750:32 - and we type here compare by we type it
750:35 - dot let's say uh
750:40 - Ram
750:43 - dot for each
750:46 - print line
750:48 - and it
750:50 - now if you run this I'm gonna have the
750:52 - same output let's add the space between
750:53 - them print line
750:59 - so let's add the space to see them to
751:01 - see the code more clearly
751:04 - and now as the as you can see the first
751:06 - they are sorted by their price and then
751:08 - they are sorted by their uh their RAM
751:11 - memory so this code is equivalent to
751:14 - creating what we had previously with the
751:16 - comparator and implementing the dotting
751:19 - interface and the function and actually
751:21 - there is a shorter way even to do this
751:24 - we can delete this let's say so the
751:28 - sorted with and compare bear compare by
751:31 - and we can just type here sort by
751:36 - so this this will create internally the
751:40 - same thing that we had previously so if
751:43 - I type it dot ROM
751:46 - and I can do the same thing here I can
751:48 - delete all of this and I just
751:50 - could type here selector the sort by
751:54 - eat that price now this will have the
751:57 - same effect like all the code that we
751:59 - had previously but now it's extremely
752:03 - concise and easier to read you just say
752:05 - laptop sorted by sorted them by their
752:07 - price so the elliptos by the ram so if
752:10 - you run this code
752:12 - you'll see the exact output in the
752:14 - console because what this function is
752:17 - doing uh actually we should Loop through
752:20 - them so let's add the print line here
752:23 - print line it
752:25 - so let's put here for each
752:28 - put into line
752:29 - it
752:31 - so now if you run this you will see the
752:33 - exact same output we just this simple
752:36 - line of code
752:37 - so as you can see you have the same
752:39 - output we have them sorted divide their
752:41 - price first and then they are sorted by
752:44 - their RAM memory and if you hold Ctrl on
752:47 - this sorted by function
752:54 - as you can see this actually internally
752:56 - calls the sorted width which receives
752:58 - the comparator and is calling the
753:00 - compound the compare buy so this is like
753:02 - a syntactical sugar for us which makes
753:05 - the code more concise but internally
753:07 - it's using using that sorted weight and
753:11 - uh if you want to use the salt to do it
753:13 - one advance for using a sorted with
753:15 - let's say that I type here another print
753:17 - line to add a space
753:18 - let's put photos lesson
753:21 - should be in quotation marks
753:24 - forward slash n one
753:28 - good thing about the sorted width so
753:30 - let's type laptops
753:32 - Dot
753:34 - sorted weight
753:37 - and here we type
753:39 - compare by
753:42 - let's say it dot year one thing that you
753:47 - can do with the sorted with if you call
753:49 - specific restorative function you can
753:51 - put that and then buy so it will sort by
753:55 - year and then by I know let's say uh it
753:59 - dot price so this is what you would get
754:02 - what you can do with the sorted with you
754:04 - can sorted by year first and then by uh
754:07 - by the price so if you run this
754:13 - as you can see they are sorted first by
754:16 - the year so
754:18 - and then buy their uh their price so
754:21 - this way we get this in the output
754:23 - now I'm gonna end this video and uh you
754:28 - should you should use this uh this one
754:31 - always because it's
754:32 - concise monitable yeah very easy to to
754:36 - to read and to and to type is
754:40 - in contrast with what we had previously
754:43 - with the or creating that comparators
754:47 - and implementing the comparator
754:48 - interface or the comparable
754:50 - this is a lot a lot more concise and
754:52 - easier to read so this is our discussion
754:55 - about the comparable and comparator
754:57 - interface so this line of code I repeat
754:58 - this line of code that we have here
755:02 - this sorted by it does RAM is creating
755:04 - internally that comparator that we
755:06 - talked about
755:07 - the node we're just using this Lambda
755:11 - function
755:13 - so I'm going to end the video now and
755:16 - see you in the next video so there is
755:18 - one mistake that I did previously so if
755:20 - I press Ctrl Z to have this code uh when
755:24 - I run this code you you didn't sound
755:26 - output then the list sorted by the year
755:29 - and then by the price and that is
755:30 - because I forgot to add the four each
755:33 - to Loop through our elements so if I add
755:35 - the four each and now if I run this now
755:38 - we're gonna see them
755:39 - sorted first by the year and then buy
755:41 - the price because previously it wasn't
755:43 - so this is why it wasn't now if you look
755:46 - they are sorted by the first by the year
755:48 - so we have 2020 2021 and 22 and then buy
755:52 - uh by their price so this is why
755:54 - previously you saw this one this output
755:58 - and also I saw this output that but uh
756:01 - some way I uh I didn't uh didn't saw
756:05 - that I forgot to add the foliage here so
756:09 - this is how you can also sort the sorted
756:13 - width you can um sort it by more
756:15 - elements you can put here I think
756:17 - another
756:18 - then buy
756:20 - not here
756:22 - we can put another so
756:26 - dot then by you can put another then by
756:29 - here if you want so eat that so let's
756:33 - say your RAM
756:35 - so you can add more more than buy if you
756:39 - want so
756:40 - now I'm gonna end with the video see you
756:42 - and see you in the next video now it's
756:43 - time to start a discussion about binding
756:45 - the search but before you look at binary
756:47 - search you're going to first look at
756:48 - linear search to see why a binary search
756:51 - works better so I'm gonna type a
756:53 - function here I'm going to type private
756:56 - fun it's going to be called search
756:59 - element
757:01 - and you're going to type search elements
757:03 - so this parameter is going to be the
757:05 - element that we are searching for
757:12 - and it's gonna then another parameter is
757:15 - going to be a list
757:18 - of numbers so it's going to be a
757:19 - multiple list
757:21 - of ins
757:24 - and it's going to return a number the
757:27 - search element or minus one if you don't
757:29 - find the search element
757:31 - and here we're going to Loop through our
757:32 - release so I'm going to type for number
757:35 - in our list of numbers
757:38 - if
757:41 - at a particular iteration or number
757:46 - it's equal to the search
757:48 - element that means that we found the
757:50 - element that we found the number so
757:51 - we're going to return number
757:54 - else if you come down here and after we
757:57 - Loop and we did our if checks we didn't
757:59 - return the number that means we didn't
758:01 - find a number we're going to return
758:02 - minus on here
758:05 - now I'm gonna add the print line here
758:08 - and I'm gonna type search
758:11 - element because this is going to return
758:14 - an element and then you're gonna output
758:15 - with the print line dot in the console
758:17 - and I'm going to type here 27
758:21 - and for the next parameter I'm going to
758:22 - define a list of numbers one time
758:24 - Multiple List off
758:26 - and here I'm going to define a number
758:28 - from 1 to 30 so I'm going to type here
758:31 - the numbers one
758:38 - and our last element 30.
758:42 - now if you run this code you're gonna
758:44 - see in the output 27
758:50 - so we get as expected 27 but let's
758:54 - declare a variable here I
758:56 - to number the number of iteration it
758:59 - took it took to find the elements I'm
759:01 - going to assign 0 to it
759:05 - I'm going to increment it every time you
759:06 - Loop so I'm going to type Val I'm going
759:09 - to type I sorry plus plus
759:11 - and I'm gonna print line here
759:14 - and I'm gonna it's gonna say search
759:20 - number
759:21 - colon
759:22 - dollar sign I
759:25 - so now if you run this we're gonna see
759:28 - how many iteration it took to found our
759:31 - element
759:34 - and if you look at the console as you
759:36 - can see it took 27
759:38 - 27 iteration before we found our element
759:42 - because the way the linear search is
759:46 - working is it's going through all of the
759:49 - elements is checking out each iteration
759:51 - if the number of that particular
759:54 - iteration is equal to the search element
759:56 - if not it's going to loop again and
759:58 - again again until it reaches 27 then it
760:01 - found that element and it Returns the
760:03 - element and you get that element
760:04 - outputted here in the console
760:06 - so this is what we call a linear search
760:09 - and this is not particularly good
760:12 - because imagine if you have 1 billion
760:15 - elements or 10 billion elements and you
760:17 - need to find I don't know
760:19 - maybe the 7th billion element in the in
760:24 - that array that is going to be very hard
760:26 - and it's going to take a
760:28 - time and memory and because of that we
760:31 - have another
760:33 - data structure for a searching element
760:37 - and that is called binary search and I'm
760:39 - going to type the code for binary search
760:40 - here and also you're going to see the
760:42 - number of iteration it tooks to
760:44 - find element and also I'm going to
760:46 - explain how binary search works so I'm
760:48 - going to delete this
760:53 - I'm going to type here VAR low I'm going
760:56 - to put equals to zero
760:58 - VAR
761:00 - High equals to
761:02 - numbers that size minus one I'm going to
761:06 - explain the code immediately
761:09 - here I'm going to type while
761:11 - low is less than equal
761:14 - to high
761:17 - here I'm gonna type Val mid so now we're
761:20 - going to get the middle element so I'm
761:22 - going to put parenthesis slow
761:25 - plus High divided by 2 and that's going
761:29 - to give us the middle element 15.
761:31 - then
761:33 - I'm going to type Val comparison so I'm
761:35 - going to type CMP
761:37 - equals to numbers
761:41 - dot get the middle element compared to
761:44 - we're going to compare the middle
761:45 - element with the search element
761:50 - then I'm going to type here if
762:02 - now I'm going to type if
762:05 - comparison is less than zero
762:08 - then I'm going to type here low
762:11 - equals to
762:13 - mid
762:15 - plus one
762:17 - lcf
762:19 - if comparison is not less than zero
762:22 - so it's greater than zero
762:25 - I'm going to type here that
762:27 - low
762:29 - is equal to
762:31 - High
762:33 - sorry
762:35 - is equal to my mid
762:37 - -1
762:40 - else
762:42 - when I type here return
762:44 - numbers
762:46 - dot get meet and that is going to give
762:48 - us the middle element
762:49 - now if I declare here a variable
762:52 - VAR
762:53 - I and if I assign 0 to 8
762:56 - and if I increment that I at each
763:00 - iteration
763:01 - and if I add a print line here
763:05 - search
763:08 - number
763:11 - dollar sign I
763:13 - now if you run this you're gonna see uh
763:16 - you're gonna actually I should return
763:18 - minus on here
763:19 - because uh if at the end of our looping
763:22 - and after we checked our all of our list
763:27 - and we didn't find the number then we
763:29 - determine this one meaning that we
763:30 - didn't find the element
763:32 - so now if you run this again
763:41 - we get
763:43 - search number one two three and then we
763:47 - get 27 and as you can see this is
763:49 - significantly different from our linear
763:52 - search because now we only took three
763:54 - searched and then I found the he found
763:57 - our element previously we had to search
764:00 - through all of our elements
764:02 - through our elements until uh the number
764:06 - 27 to to get the number seven but now we
764:09 - only get the
764:10 - three iteration and we get the number 27
764:13 - and how is that possible this is because
764:16 - now we're using what is called the
764:17 - binary search and how this binary search
764:20 - works I'm going to explain it now so now
764:23 - let's see how the code works
764:25 - so first we have a variable declare code
764:27 - load which assign a value of 0. then we
764:30 - have another variable called height
764:31 - which assign number the PSI minus one so
764:34 - we assign the size of the array to our
764:36 - high
764:37 - then we have a variable called I to
764:39 - which you assign 0. then we have a while
764:42 - loop and we start looping by this
764:44 - condition while low is less than equal
764:46 - to high
764:47 - then we increment our I to keep track of
764:50 - how many iteration it takes before we
764:52 - find the element and without any console
764:55 - search element and the number at that
764:57 - iteration
764:58 - then we have a variable called mid and
765:01 - this is going to give us the middle
765:02 - element and to get the middle element we
765:05 - add the lower lowest element plus the
765:08 - highest element so yeah we'll add here 0
765:10 - plus 30 divided by 2 which is 15. so
765:13 - this is the
765:14 - middle element
765:16 - then we declare another variable called
765:19 - comparison and we type here numbers that
765:22 - get the middle element which is 15
765:24 - compared to search element and if the
765:28 - middle element is less than the search
765:32 - element that means that the search
765:35 - element is on the right of the numbers
765:38 - which come after the 15 and because of
765:41 - that this is gonna return because our
765:43 - middle element is less than the search
765:46 - element is going to return a negative
765:47 - number so this is going to be true
765:50 - comparison is going to be less than zero
765:52 - and then I'm gonna assign low equals to
765:55 - Mid Plus on so now
765:58 - the low variable has the value 16 all
766:04 - right now it will loop again it will uh
766:07 - it will uh do it will have the I
766:10 - incrementally it will
766:13 - do the while loop it will increment the
766:15 - I again and it will output into I in the
766:17 - console now here now it will calculate
766:21 - again the middle element and it will it
766:25 - will add now 16.
766:27 - Plus
766:28 - 30 divided by 2 and that is going to
766:32 - give give us 23.
766:34 - all right
766:35 - now that is the middle element now and
766:38 - what we do now here is we again uh I
766:42 - have our variable comparison and we get
766:44 - numbers that get 23 so we get the 23
766:48 - element and we compile with our search
766:50 - element which is 27.
766:53 - and again because our middle element
766:57 - is less than the search element this is
767:00 - going to return on any negative number
767:02 - so this shift check is going to be true
767:04 - again now what is gonna
767:08 - happen is that now low
767:11 - is going to be equal to Mid
767:15 - plus 1 and the low previously was equal
767:18 - to 23 so now I'm going to have 23 plus 1
767:21 - which is 24 all right
767:24 - now this will loop again
767:27 - or loop again so
767:29 - as you can see this basically breaks the
767:32 - the list in half at each iteration and
767:36 - now this will loop again it will
767:38 - increment the eye to Output I and now it
767:40 - will calculate again the middle element
767:42 - now the middle element is 24.
767:45 - and the high element is 30 and we have
767:47 - 24 plus 30
767:49 - divided by 2. and that is 27 the exact
767:54 - number that we are searching for so this
767:57 - is how binary search works it will
767:59 - compare the middle element with the
768:01 - search element if the middle element is
768:04 - less than the search element that means
768:05 - that your element is on the right side
768:08 - of the element which come after the
768:10 - middle element so all the elements from
768:12 - the left are going to be excluded and
768:14 - it's going to search only on the on the
768:16 - right side
768:17 - then it will split the list again in
768:20 - half if the middle element again is less
768:22 - than the search element it will go to
768:24 - the right again it will speed the least
768:26 - in half I need to sooner or later it
768:29 - will find the element to to to the right
768:32 - or to the left
768:33 - so this is how one research version is
768:35 - very powerful because for a very big uh
768:42 - list you can use binary search and it's
768:45 - more effective that uh only the linear
768:48 - search
768:49 - and uh this is the code that I type but
768:53 - it doesn't you don't need to use this
768:54 - code because uh I only type this code to
768:57 - show you how the binary search works but
768:58 - usually you'll use the binary search
769:01 - function provided by The Collection so
769:03 - you will just type here return
769:07 - numbers
769:08 - we're gonna put square brackets and I'm
769:11 - gonna type binary I'm going to type here
769:13 - numbers again binary dot binary search
769:17 - because the binary search function
769:20 - provided by The Collection only return
769:22 - the returns the index so if I
769:26 - search for the 27 element
769:31 - that is going to return the index 26th
769:34 - and the index 26 then it's gonna be the
769:38 - number 27 from our numbers list so now
769:41 - if you run this you'll see 27 output in
769:43 - the console
769:47 - so get 27 and we did this one with one
769:51 - line of code you can even remove this
769:53 - and just have a
769:56 - single expression function so we can put
769:58 - here
769:59 - equals
770:02 - so just by that it will do the same
770:04 - thing that we did previously with all
770:06 - the code that I typed
770:08 - so this is our discussion about binary
770:11 - search and see you in the next video but
770:14 - before I end the video I should say that
770:16 - binary search only works with the order
770:19 - collection of elements so your elements
770:21 - need to be sorted in order to for the
770:24 - binary search to work and in our case we
770:27 - look we used integer numbers and it was
770:32 - easy because we typed elements in a in a
770:35 - sorted order
770:36 - but uh if the elements are not sorted by
770:39 - by research is not going to work also if
770:42 - you have your own class so you have your
770:44 - own objects and you search with using
770:46 - one research uh through a list for a
770:51 - specific element in that case your class
770:54 - has to implement the comparable
770:56 - interface or it has to to to to use the
771:01 - comparator interface and I'm going to
771:03 - show you how to do that in the next
771:04 - video so see you in the next video
771:06 - so now it's time to start a discussion
771:08 - about genetics so what are genetics
771:10 - genetics allows us to give to the
771:13 - compiler some hints about what kind of
771:15 - objects you are dealing with and this
771:18 - helps the compiler to figure out some
771:20 - errors at compile time and it also helps
771:23 - us to write more consistent and better
771:26 - code and we already use genetics when we
771:29 - look at collections so every time you
771:32 - use an array and you you specified in
771:34 - the angle brackets an INT or a double or
771:38 - a class that you created an object what
771:42 - you actually did there is that you use
771:44 - generic you set the compiler that that
771:47 - is the kind of data that specific
771:50 - collection is gonna store so if you have
771:52 - something like this while let's say
771:56 - numbers
771:58 - and
772:01 - we put equals is equals here and type
772:03 - array of
772:10 - here you can put angle brackets
772:17 - and you can specify a type here let's
772:19 - say in because
772:21 - I'm going to put numbers here and now
772:23 - this helps the compiler to figure out if
772:27 - let's say we want to add here let's say
772:30 - a string so if I type here numbers
772:34 - equals let's say your
772:37 - some text let's put in quotation marks
772:41 - some text as you can see you have those
772:43 - underlines red which says if you hover
772:46 - over here
772:47 - first it says that Val cannot be resent
772:49 - so let's change this to VAR to get the
772:52 - error that I want so let's put VAR here
772:55 - so we get here type mismatch required
772:58 - and found string so here we are using a
773:02 - generic type and the generic type is an
773:04 - integer and because we said explicitly
773:08 - here that this array is only going to
773:10 - store integers we cannot go down here
773:13 - and assign some string but
773:18 - as I said at the beginning
773:20 - genetics are only a compile timing
773:23 - feature they don't make it through the
773:24 - runtime and again we're going to come
773:26 - back to this later because this has some
773:28 - implications
773:30 - now let's uh delete this and let's
773:33 - create our own generic class to see how
773:36 - it works because here we're passing in
773:40 - but if you click on this array of
773:44 - you see that you don't have here any an
773:48 - intest the type that we SP we
773:50 - specifically decided to pass to this
773:53 - array but if you look here inside this
773:56 - library.kt and if you go to array here
773:59 - you see you see that we have VAR Arc
774:01 - elements and we have this t
774:03 - and T is a genetic type and the specific
774:07 - type that is going to be passed here is
774:10 - the type that we pass when we create an
774:13 - arrays when we want to store some
774:14 - numbers or some strings and now now
774:18 - let's see how we can create a similar
774:21 - thing that we have here with our with
774:23 - our own code so I'm gonna delete this so
774:26 - again generics are there to
774:29 - to to help the compiler to figure out
774:31 - errors and it also they are there for
774:35 - helping us to write better and
774:37 - consistent calls so that you you don't
774:39 - add let's say uh strings to to an array
774:44 - which is meant to store only numbers so
774:47 - first I'm going to create a class and
774:50 - it's going to be an Open Class
774:53 - and it's going to be called player
774:56 - and it's going to have a property called
774:58 - name so it's going to be a Val name
775:00 - we're going to Define this in the
775:02 - primary Constructor it's going to be a
775:03 - string
775:05 - now I'm gonna create
775:08 - open class here
775:14 - and down here I'm going to create two
775:16 - classes first is going to be called
775:18 - football player so football
775:24 - player
775:26 - and this is gonna have a name and it's
775:28 - gonna be a property because you're gonna
775:30 - gonna extend from our player class we're
775:34 - gonna derive from our operator class I'm
775:35 - gonna pass this property to the dot
775:37 - parameter name to our property name from
775:41 - the superclass so if we type here player
775:43 - because we were in inheriting from it
775:46 - and here first name
775:49 - so you pass your name
775:52 - next I'm going to create another class
775:54 - called baseball player so we type here
775:56 - baseball
775:58 - player
776:00 - and this is also going to have a name
776:03 - also only a parameter because the
776:06 - property is going to be ultimately
776:07 - defined by the
776:09 - superclass by the class from which we
776:11 - are inheriting from so here we're gonna
776:13 - inherit put the colon to inherit from
776:15 - our player player class and here we pass
776:19 - our name parameter that we defined here
776:22 - we pass it here to the primary
776:24 - Constructor of the base class from which
776:26 - we are inheriting from
776:28 - all right so now I'm gonna go up here
776:32 - and now I'm gonna create a class called
776:36 - team
776:37 - and this class is going to represent a
776:39 - team and this thing can be a football
776:41 - team or a baseball team and here we're
776:43 - going to create the class called team so
776:45 - we type the keyword class I'm gonna call
776:47 - it team
776:48 - and now here we put angle brackets and
776:51 - inside the angle brackets we're gonna
776:53 - Define the generic type t
776:55 - and you can use a different letter here
776:57 - if you want but usually and generally
777:00 - use the T because it stands for the for
777:03 - type parameter
777:05 - next to put parenthesis to define the
777:08 - primary Constructor and for the primary
777:09 - Constructor I'm going to define
777:11 - a Val name and this is going to
777:14 - represent the name of the theme and it's
777:16 - going to be a string and next I'm going
777:18 - to Define also valuable this is going to
777:20 - be called players and it's going to be a
777:22 - multiple list
777:24 - of also of type T so we type here
777:28 - Multiple List
777:30 - and we put here t
777:32 - right
777:34 - now I'm going to put curly braces
777:36 - because I'm going to define a function
777:38 - inside our class team so here we type
777:41 - fun and I'm going to call this function
777:44 - add
777:45 - players so this function is going to add
777:47 - players to the team
777:49 - we put parentheses and here we Define a
777:51 - parameter called called player and it's
777:54 - going to be of type T so it's going to
777:56 - be
777:58 - should put
778:00 - a colon here
778:02 - and we put curly braces
778:06 - and this is going to receive a parameter
778:08 - of type T and this type T that we Define
778:10 - here and here and here is going to be
778:13 - the type the specific type that we gonna
778:16 - pass when we create an instance with our
778:18 - class team so
778:21 - first here we're gonna check if
778:24 - the
778:26 - players
778:27 - so our list of players contains this
778:31 - player that is passed our ad player
778:33 - function because if or you already have
778:36 - that player in our list We're Not Gonna
778:39 - add it to our list so if player and to
778:41 - check if that player is in the list we
778:44 - call the contains function on our uh on
778:48 - on our uh
778:50 - Multiple List so here we we type players
778:54 - that contains player the argument
778:58 - and if that is true I'm gonna put curly
779:01 - braces
779:03 - and here we're gonna output something
779:04 - because to the console so we type here
779:06 - print line
779:08 - quotation marks and we type player
779:12 - colon and then we put dollar sign curly
779:16 - braces
779:17 - and here we need to do something which
779:20 - is called casting and casting casting is
779:24 - used when you want a variable to be
779:28 - treated as a certain type of variable so
779:32 - when you want a variable to be treated
779:35 - by the component by the compiler as a
779:37 - certain type of object or or a class so
779:42 - we type here player
779:45 - because let's let's let me show you why
779:48 - we need to do that because if I type
779:50 - here player now I want to get the name
779:53 - and if I put here dot name as you can
779:56 - see we don't have any name here because
780:00 - because this type because this T and
780:03 - this T that we have here is generic the
780:06 - compiler has no idea if this T that is
780:09 - going to be passed here so this piece so
780:11 - if you pass here
780:12 - a baseball player or football player it
780:15 - has no idea if at this moment now if
780:18 - that is gonna have uh is gonna have a
780:21 - name property on it this is why when you
780:24 - type here that's name we don't get
780:25 - nothing and to solve that we can say to
780:29 - the compiler for them to the compiler to
780:31 - treat this parameter here so this is
780:34 - going to be a value pass to this
780:36 - parameter as a player and in that sense
780:41 - in that in that way you can get access
780:43 - to the name property so we type here
780:45 - player and
780:47 - to cast to cast a variable to a certain
780:51 - type we put as so we put
780:54 - the keyword as and the type player
780:58 - and we put this in parentheses so we
781:01 - surround our expression in parentheses
781:04 - inside the curly braces
781:08 - and now here at the end of of the of the
781:11 - end of the enclosing parentheses you put
781:13 - that and now we have access to name
781:16 - because we settle the compiler hey treat
781:19 - this player variable I don't know
781:21 - because I don't know if this is going to
781:23 - be it's going to be a player
781:27 - a player object passed here or a
781:29 - baseball player or or a football player
781:32 - treat this player variable that is
781:34 - passed here as because here we have
781:37 - teeth so we don't know what it is three
781:39 - display to display a variable as a
781:41 - player so you can use the name of a
781:43 - variable and we're gonna say is already
781:48 - in the TM and we can put here
781:52 - the team and we can type here dollar
781:55 - sign this Dot name so the name of the TM
782:00 - else if if our player is not in the team
782:04 - we put else
782:06 - we're going to press enter to add the
782:08 - right curly brace we're gonna add this
782:11 - player to the list because if the if
782:14 - fails that means that the player is not
782:16 - present in our list so we type here
782:19 - players
782:21 - our
782:22 - Multiple List dot add this player that
782:26 - is passed player and we're also going to
782:30 - output something to go to the console so
782:32 - you add here print line
782:34 - and uh
782:36 - I'm gonna copy this because I'm just
782:38 - gonna change the text a little bit
782:41 - so let's delete this
782:44 - player and so here is we're gonna say
782:50 - instead of it's already
782:52 - I'm gonna say it was
782:53 - added
782:55 - in the team
783:01 - now let's create some objects with those
783:04 - classes that we have here so first I'm
783:06 - going to create some some players so I'm
783:09 - going to create first the football
783:10 - player so type here
783:12 - Val for the ball player equals football
783:16 - player
783:18 - and
783:20 - for the name I'm going to use a generic
783:22 - name I'm gonna type just football
783:36 - player
783:39 - one
783:41 - and I'm gonna press Ctrl D to create
783:43 - another football player so football
783:46 - player two is going to be called
783:50 - and I'm gonna create two baseball
783:52 - players so we type here Val
783:54 - baseball player equals
783:57 - baseball player
784:00 - and we type here
784:03 - baseball
784:06 - player one and I'm gonna call Press Ctrl
784:10 - D here also I'm gonna
784:15 - call this baseball player 2 and I'm
784:17 - gonna change this to 2.
784:21 - now I'm going to create an instance of
784:24 - our team class so we cut we type here
784:26 - Vault team and this is going to be a
784:29 - team of football players so we type Val
784:31 - team
784:32 - equals
784:33 - and hero type team
784:37 - and we put now because as you can see
784:39 - it's expecting a type here and the type
784:42 - is going to be
784:44 - football player so it's gonna be a team
784:47 - with what it's gonna be a team with the
784:50 - football players and you're gonna Define
784:52 - a name
784:54 - also generic name football
784:58 - team is going to be called
785:01 - and they also need to pass an array
785:03 - there
785:04 - and for this array I'm gonna type just
785:07 - uh
785:08 - mod multiple array of
785:13 - we can't
785:15 - foreign
785:22 - list of
785:25 - and here I'm gonna pass our
785:29 - football player I'm gonna pass only our
785:32 - first football player here
785:37 - now I'm going to create another team Val
785:41 - team uh let's actually call this first
785:45 - team football team so let's type here
785:50 - food bowl
785:58 - football team
786:00 - now if you run this code
786:10 - we don't get it on any output because
786:12 - our ad player's function wasn't called
786:15 - but if I
786:17 - type here a football team
786:26 - foreign
786:26 - actually here football team
786:30 - that
786:32 - add players and I'm gonna add football
786:34 - player too
786:39 - now if I run this code
786:47 - we get football player two was actually
786:50 - here should be added
786:56 - football player 2 was added in the team
786:58 - football team so our code works well and
787:01 - we use generic types for our classes
787:04 - here we specified only the T and this T
787:07 - that we have here was replaced with
787:10 - football player that we Define here and
787:13 - um
787:14 - uh we're gonna do the same thing we're
787:16 - gonna create another theme for the
787:18 - baseball player and we're also going to
787:21 - look at
787:22 - how we can restrict the types that are
787:25 - going to be passed to our generic type
787:27 - here
787:29 - so now I'm going to create a baseball
787:30 - team so I'm going to type here Val
787:32 - baseball team
787:37 - put equals then you put Here theme
787:44 - and here we type for the generic type T
787:47 - baseball player because this is gonna
787:49 - store baseball players and we Define a
787:52 - name here the name is going to be
787:53 - baseball team or generic name
787:58 - and uh also you need to type to pass a
788:02 - multiple list so type Multiple List
788:06 - and we pass here a baseball player
788:13 - but as you can see
788:15 - here for the type
788:18 - the type here is great oh that is
788:20 - because
788:21 - here we pass the football player
788:25 - uh object that we create then here we
788:28 - pass the baseball player
788:29 - because kotlin has Type inference it can
788:32 - infer the type as being a team of
788:36 - football players so we don't need to put
788:37 - here for the player we can delete this
788:40 - you can delete all of this
788:44 - and now our code still works and you can
788:46 - see we have this type here which says
788:48 - team football player so it's a team of
788:50 - football players and it's uh inferred
788:53 - it's inferred automatically by quoting
788:55 - for us and you can do the same thing if
788:58 - here for a baseball player so I'm gonna
789:00 - delete this
789:01 - as you can see now we also have the hint
789:03 - team baseball player now let's add to
789:07 - the baseball player
789:09 - let's call the baseball player function
789:12 - let's put here a
789:15 - so we type here base bullet
789:19 - team let's call the function dot add
789:22 - players and hero type baseball player 2
789:25 - because first one was added there
789:28 - so now if you run the squad
789:30 - not debug so run this code
789:37 - let's increase this
789:41 - we get let's actually decrease this so
789:44 - let's put here we get player football
789:46 - player 2 was added to the team football
789:49 - team so we have this code here
789:52 - which is called and it says that the
789:56 - the football player was added to the
789:58 - team and the name of the football team
790:00 - and then we have player and we have
790:02 - baseball player player two
790:05 - so this
790:06 - this one
790:08 - that we have here
790:10 - that we pass here
790:12 - baseball team that was this to the
790:14 - baseball team as you can see it says
790:16 - player baseball player 2 was added to
790:18 - the baseball team
790:19 - and what generics helps out to do
790:22 - because I said they can help the
790:24 - compiler to figure out errors if you try
790:27 - to
790:28 - pass here baseball TM Dot
790:32 - add football player so we type here
790:35 - football player
790:37 - now you get an error because
790:40 - the generic type enforces the type on
790:45 - the the
790:48 - on the class because here we said
790:50 - explicitly that this is because this was
790:53 - inferred to be as a baseball player if
790:55 - you cannot pass here a football player
790:56 - in our baseball team because this is in
791:00 - first because you said Siri here
791:02 - explicitly explicitly because first
791:05 - because this was inferred from here so
791:07 - we have team baseball player so we
791:10 - cannot add here a football brain inside
791:11 - our team football player and this is
791:13 - very very
791:15 - powerful for us because in this way we
791:18 - don't do things which doesn't make sense
791:21 - and the the same is true about our
791:24 - football team so if on our football team
791:28 - so if enough of working with a football
791:30 - team
791:32 - dot add
791:34 - and here to put baseball player
791:39 - we get an error because we specified we
791:42 - specified that because the generic type
791:45 - was
791:46 - in fair to be a football player so we
791:49 - cannot put a baseball player in our team
791:51 - of football players so this is what
791:54 - generics is doing is figure out those
791:57 - errors for us at compile time and this
792:00 - is very powerful because we cannot we
792:02 - can run our code and we don't get in
792:04 - those some
792:06 - scenarios where we have a bay of
792:09 - baseball player added to a baseball team
792:12 - or maybe other examples there so I'm
792:15 - gonna delete this
792:17 - next we're gonna look at upper bounds
792:19 - because
792:21 - our upper bounds basically allows us to
792:25 - restrict what kind of type is passed to
792:29 - our generic type here so
792:31 - and particularly gonna see how this is
792:34 - gonna affect this code that we use here
792:36 - to cast so to to add an upper bound so
792:41 - to restrict what kind of type is passed
792:43 - to this type we can put
792:46 - colon so extends and here you can we can
792:51 - type player
792:52 - so what we are saying here is that
792:56 - every
792:58 - type that is going to be passed here
793:00 - when you create an instance like
793:03 - we did here so but only that this was in
793:07 - Fair here this type that is going to be
793:10 - passed here needs needs to inherit from
793:13 - the player class otherwise this type is
793:16 - not going to work so because of that
793:19 - because the compiler now knows that and
793:22 - enforces this that this type that is
793:25 - going to be passed here is is going to
793:27 - be is going to inherit from the player
793:29 - class we we can't delete this cast
793:34 - because now it knows that that type is
793:37 - gonna have uh it's gonna be it's gonna
793:40 - inherit from the player class so it's
793:41 - gonna have the property name so if I
793:43 - delete this
793:46 - and if I delete this so let's put name
793:49 - here
793:53 - now
793:57 - so let's delete these two
794:02 - should be player here
794:04 - player
794:06 - so now we have player the name because
794:08 - it knows that this type so this type
794:11 - that is going to be passed series is
794:12 - going to inherit from the player cards
794:14 - from the player class so it's gonna have
794:16 - the property name so you don't need to
794:19 - do this the weird this word cast is
794:24 - overcasting so I'm gonna delete this
794:27 - and now as you can see we don't have uh
794:29 - any arrows so now we have the name here
794:32 - because now it knows that whatever type
794:34 - you pass here it has to inherit from the
794:37 - player class so if I go down here and I
794:40 - create another class called gamer
794:43 - player so
794:46 - we type here class
794:50 - let's call it games player
794:54 - and it's gonna have a Val
794:57 - is going to be
794:59 - actually let's define a parameter only
795:01 - name
795:03 - is going to be a string
795:05 - and we will not inherit from our player
795:08 - class let's see what happens so
795:12 - if I um
795:14 - if I uh create here another theme let's
795:17 - call it Val
795:19 - let's call it the game Steam
795:25 - so I'm gonna
795:27 - type here team and we're gonna specify
795:32 - here
795:33 - games player
795:35 - now if if I put now the primary
795:38 - Constructor here here we need to define
795:40 - a name
795:42 - let's call it
795:44 - games
795:46 - team
795:48 - and
795:50 - multiple list of
795:56 - now
795:58 - here we have an error and if you look it
796:00 - says
796:01 - expected player found games player and
796:05 - this happens because our games player
796:09 - that we have here is not inheriting from
796:11 - the player class and because we said
796:14 - here that the upper bound is this T that
796:16 - is passed here so this T is this here
796:19 - has to inherit from the player class
796:23 - otherwise if you if you don't uh inherit
796:26 - from the player class it will not work
796:29 - because you said here that it it must
796:32 - inherit from the player class now if I
796:35 - change this to
796:36 - if I change this down here to inherit
796:38 - from the player class so it I hear
796:40 - player
796:43 - we type here name
796:46 - now as you can see the error disappears
796:48 - because now it's respecting the upper
796:51 - bound that we set we set up here which
796:54 - is T
796:56 - meaning games player has to inherit from
796:59 - the player class and down here it's
797:01 - inheriting so this is our discussion
797:05 - about how we can use generics and how we
797:08 - can use how you can Define upper bounds
797:10 - and in the next videos you're gonna look
797:13 - at
797:13 - um
797:14 - type erasures and you're going to lose
797:19 - what reified
797:21 - a keyword and how you can inline our
797:24 - function with because you need to inline
797:26 - your function when the use refine the
797:29 - keyword so see you in the next video
797:32 - well actually before I end the video I
797:34 - should say why this uh genetics is
797:36 - important why
797:38 - because if you think about because here
797:42 - you can type we can define a generic
797:44 - type we don't need to create
797:46 - um a separate class for for every team
797:51 - that that we want to use so we don't
797:54 - need to create a football team we don't
797:57 - need to create a separate baseball team
798:00 - we don't need to create a
798:02 - separate games team we we just create a
798:07 - team we Define the generic type T and
798:10 - here we pass our we pass our
798:14 - our type and in this way we can use only
798:17 - one class
798:18 - and we can we can have all of those uh
798:22 - those uh baseball team we can have the
798:26 - football team we can have just by having
798:28 - the the type here which is generic
798:31 - otherwise we'll have to create separate
798:33 - classes for each of those
798:35 - teams so
798:38 - see you in the next video and next video
798:39 - as I said we're gonna look at type
798:41 - erasers and refine the verified the
798:44 - keyword and the inline functions and in
798:48 - the next videos we're going to look also
798:50 - at covariance and counter variance so
798:52 - see in the next video

Cleaned transcript:

kotlin is the most popular programming language for building Android apps and it can also do a lot of other things in this beginner's course Alex will teach you kotlin from the ground up Alex is an experienced developer who has created multiple Android apps in this course I'll cover everything you need to know in order to be able to create another programs or move to build apps on Android I will start from zero by downloading the software that we need to write code to creating our first program and then we're gonna move to more advanced topics we'll cover things like variables operators Loops arrays object orientated programming generics Lambda functions core routines everything will be covered in depth with great detail additionally I'll use beautiful animation while talking about a concept for who is this course this course is for complete beginners who have no experience with programming and also for experience programmers kotlin is perfect for beginners because it's very intuitive and concise and if you already have a background in other programming languages then this course would be easy for you so let's get started now it's time to download the installing ID and throughout this course I'm going to use an ID called IntelliJ ID which is an ID made by a company called jetbrains now you may be wondering what is an idea an IDs stands for an integrated development environment and it's basically the tool that you're going to use writer code in and intelligent it's like a text editor but a very sophisticated one because it has a lot of features like highlighting our code showing realtime errors and suggestions you can run and compiler coaches by a few clicks in other words it's making the process of writing code easier and better therefore let's download IntelliJ IDEA so I'm going to open my browser and in the search bar to type IntelliJ IDEA press enter and we click on this download link and on the downloading page you're going to see two options ultimate which is paid so you need to pay in order to download it and Community which is free and the difference is that the ultimate has more features and Community has less features but Community is not for our purposes also pay attention on the left hand side when I'm currently recording this video the latest version is 2021.1.2 which was released on the 1st June of 2022. and if you look at the system requirements here if you click on that you will see that this IntelliJ ID only works for a 64bit version of Windows so if you have a 32bit version of Windows this will not work for you now if you have macro X or Linux you should download the particular version for your system and if you don't know how it just tell me in the comments and I've made two separate video and shall show you how to do now I'm gonna download the community version for Windows so click to download the community now our downloading is starting on the right hand side on the top and if you have a different browser you'll see this in an infrared place so once the downloading is finished just open this file I'm going to close the browser now because I don't need the browser and the installation will start immediately now it's asking us if you allow this app to make changes to a device click yes you need to click on next this is the for the location or IntelliJ is going to be installed you can keep the default location or you can change it if you want I'm going to keep the default location so I'm going to click on next and here I'm going to check this box to have a desktop shortcut I'm going to click on next now I'm going to click on install and IntelliJ is going to be installed on my computer as you can see on the left hand side IntelliJ already appeared now let's wait until the installation finishes when the installation finishes just check this run Intel GID Community Edition and click on finish now intelligently IntelliJ is going to open now it's asking us if you want to import IntelliJ settings so if you have the previous version of IntelliJ ID you can import the settings here but I'm going to click the not import settings and click on OK now IntelliJ ID is going to open and this is the welcome window of IntelliJ IDEA and here on the left hand side click on customize go here to where it says color theme so you can change this theme because the default team is this dark team I'm Gonna Change it to light because the IntelliJ team is better for tutorials but you can keep the dark team if you want and in a separate video I'm going to show you how to add more themes not just the ones provided by IntelliJ ID now click back on projects click on this plus button where it says a new project because we need to configure the jdk now and now here we have jdk and we have in red and angle brackets we have no JD no SDK and now here we need to add the jdk and jdk stands for Java development kit SDK stands for software development so software developer Kint is the Java development kit no matter how you call it this thing contains the tools that IntelliJ ADN needs in order to be able to compile and run our programs because without them IntelliJ edits like an empty text editor so it needs those tools in order to be able to work with our particular programming language which is kotlin now to download the jdk and we use the Java developing kit because code and Java are interoperable and that means that you can use the existing Tools in library which Java already has in our kotlin project so quickly here on this no SDK and click here where it says download jdk now on this window we select version 17 not version 18 because this is the latest version 18. this change version 17 because this is the version which has the longterm support and that means that it will receive bug fixes and updates for several lists to come without you needing to switch to any new version when that new version is released for the average vendor we choose Amazon Creator and I'm gonna let the default location so I'm gonna click download to download the jdk now the jdk is going to be downloaded now the jdk has been installed and is installed on our IntelliJ IDEA and now we can create our projects but I'm not going to create a project so I'm not going to click on create I'm going to click on cancel and in the next video we're going to create our first project and we're also going to talk about a little bit the jdk and the jvm so see you in the next video now it's time to create our first project and there is a traditional programming that our first program should be to Output the text tail over to the console and this is what we're gonna do in this video therefore I'm going to open IntelliJ ID you should open your IntelliJ IDEA on the left hand side make sure to have project selected then click on this plus button to create a new project and here we have a few options the first is the name and here you need to name our project we need to give a name to our project and the name of the project should start with the capital letter and if it has multiple words every word should start to the capital letter so I'm gonna call this uh on on this the way of naming is called the Pascal case so I'm going to call this uh this project hello world and also you should not have y spaces in your name next we have the location and this is where the approach is going to be created you can change this location if you want but I'm going to keep the default location next we have language and here you can here you need to select the language which this project is going to be created so we select Catalan if you Java is selected just select other B system we select IntelliJ and next we have the jdk the Java development kit and if for a terrible reason it says here in angle brackets no LDK just click on that and go down here off down off to afternoon it should say detected as jdks and you will see the jdk down there you're going to see Amazon correct or version 17. just click on that and it's going to be added here next we have this add sample code and what this is going to do as the naming price is gonna generate some code for us but I don't want to have that code generated uh now because I want to that type that code myself and I want to explain that code then in the next video we're gonna check that to generate the code for us so I'm gonna click on create Now to create the project and here we have the tips you can keep the tips activated because it's uh useful information but I'm gonna check this actually I'm gonna just close it here we have those windows which says there is a that is a plugin update installed I'm going to close this so what we have now on the left hand side is called the project Pane and here we have some folders which IntelliJ IDEA generated for us but now I want to I want to show you how to check for IntelliJ updates because in this way we'll have the latest features throughout this course and to check for IntelliJ updates you go to help and to go down here where it says check for updates and here you can check for IntelliJ updates and you'll see a window down here and if there is an update it's gonna say that that there is an update and you can install that that update but now it's saying that that you already have the latest version of IntelliJ ID and plugins installed because we have the latest updates but it's good to check for this because in this way we'll have the latest updates so throughout this course next just check if you want to check for kotlin updates so for the programming language you kotlin you go to tools kotlin and go here it says configure custom plugin updates and if there is a new update you will see it here and click on install and that update is going to be installed on IntelliJ IDEA so there is no update because we have the latest update I'm going to click on OK now let's focus on the left hand side and if you don't see if you see something like this and you don't see this in this expanded form just click on this greater sign sign in front of his SRC SRC stands for Source this is where our source code is gonna go then click on this greater sign in front of Main and make sure to have the folder kotlin selected on this folder kotlin this is working out our code but first we need to create a file and the file is the thing where we're going to put our code so we right click on this go to new and here we select on the right hand side we select quoting class file now we need to give a name to our file and I'm going to call this file main you'll see the reason for this later so I'm going to call this file Main and then also you should be in Pascal case so if you start with the capital letter and if it has multiple words every words result the capital letter and for the from these options that we have here we select file because we're going to create a setup file now press enter now the file was created for us as you can see in the folder uh kotlin now we have main.at have the file and also to open the file for us let's uh click there now if you don't have the file open then if you have something like this just double click on the file and the file is going to be open for you now here now we're gonna type some code now you need to type exactly what I type so type fun so while I am typing as you can see IntelliJ is trying to help us and is giving us some suggestions so he's saying do you mean fun that and if you want to fill in that photo you just press enter Because I want to to to type that fun keyword fun and it also added the space so fun space then you type Main and next we need to put parenthesis and as you can see display button now appeared I'm going to explain immediately why and we put the left parenthes and when we put the left parenthes the right parenthesis is going to be added automatically so you put less parenthes and the right parenthesis was added automatically then we get outside of the parenthesis we press space now we're going to add curly braces and again we put the left calibrates and the record library is going to be added automatically because IntelliJ is helping us now we would inside the curly braces and now we press enter and it uh added the curly brace on the third line and also indented this line for us now let's talk about what we have here now what we have here is what is called the main function and the main function is the entry point of our program so every program that you create it if it first needs this entry point in order to be able to compile your code but let's take each part of this main function individually to talk about so first to have this fun and fun is the key word for creating a function and uh you can use fun keyword to create your own functions but you're gonna see that in uh in future videos next we have Main and Main is the name of this function functions can have different names but main is a special one as I said because main is the entry point of our program every program that you create needs and needs a main function in order to be able to run your code and in fact if I change the name of this function to fun main let's say a the play path button immediately disappear because now we don't have an entry point and our program can run so this is a special function and functions can have different names as I said and as you'll see we're gonna create your own functions that you can create you can give different names to your functions now next we have parenthesis and you have parentheses because um functions can take parameters and can do some work with that with those parameters but our function doesn't take any parameter but we still need to provide the parentheses because they are part of the syntax and we can think of the syntax like the grammar rules that you need to to to respect in a specific language in order to be to be a to under to be understood to be understood and in the same way this is the syntax in the programming it's like the grammar rules in which the compiler as you will see what is the compiler later the compiler needs enforces you to respect those syntactical rules which is uh to have parenthesis for a function in order to be able to understand your code because if I delete the parenthesis here now we have an underline which says uh expecting parentheses so it's it's it it you need to respect the syntactical rules in order for your code to be to be understood next we have curly braces and we have left curly brace and right curl base and this is called the body of the function so this is where our code goes so this is also called the code block because because it's the block of code this is what our logic our uh our these are our logic our lines of code go they are we Define them inside the the the curly braces so this represents the body of the function and let's add some code and I'm going to type print line here so because when we need to output something in the console so we type here print line so we type print and while I'm dumping you associate suggested and we have the suggestion print line and we select the first one to fill in for us and now we go inside the parenthesis of the print line and we put double quotation marks and inside the double quotation marks we type hello world now we need to we need to run this code in order to run this code to compile this code we can do it in uh two ways first you can click on display button that we have here or you can right click and you can go here where it says runmen.kt and the code is going to be compiled and let's do it from here first so I'm going to click on display button to run our code and I'm going to see the console opening down and you're going to see the text hello old hello world outputted so the console opened and we have hello world we have the text that we type inside this uh thing that we have here this also function and we have this code output now in the console the console opened now I'm gonna I'm gonna close the console to explain what this print line is this print line that we have here is a function also but is that the function which takes some which takes input and the input is this text and this function the its job is to take whatever you pass as the input and to Output that in the console so this is what this print line is doing and this is a function that we didn't create we didn't type free fun print line and then you call it this is a function which is uh build into quantity this is a function which is already built by the kotlin programmers so we just call that function inside our code and we can use you need you don't need to create this function so this is the this is what this print line is doing so it's taking whatever you pass inside the parentheses and it's outputting that in the console so this is our discussion uh about uh the first program which is to Output some text in the console hello world and uh now I'm gonna show you that I know I'm going to show you an illustration to understand what is uh what is the jdk the jvm and the how kotlin and Java achieves this interoperability because Kathleen and Java are fully interoperable and that means that you can have a Java project which you can add kotlin code and you can compile that code and everything to work fine and also I'm going to explain what the what the word compile means and for that I'm going to bring an illustration here so this is the illustration and uh let's talk about what we have here first we have kotlin source code and kotlin source code is the code that we wrote is this squad that is meant to be human readable so this code is the code that we as humans can understand we can write this code we can read this quad but the computer does understand this high level uh high level uh quote that we wrote it needs something it need it needs machine code it needs binary code in order to be able to understand and this is where the jdk comes into action so our continent source code again this quad which is meant to be human readable then it's when when we press on that play button on that and when you press on that play button on this button and the code is compiled what happens under the hood is that that quoting source code is is uh taken by the Java development kit the jdk and through the kotlin compiler so the controlling compiler acts like a translator it takes that high level human readable and writable code it converts that code then into what is called Java byte code and this is not the final step as you can see in this illustration this this is just the intermediary step this is not uh converted into machine code then this Java byte code it's uh taken by the jvn so it's sent to the jvm and the jvm then takes that Java by code and convert the jbox.java by code into something which a machine which a specific machine can understand but let's let's first explain why why kotlin uh why the jdk takes this kotlin source code and then it converts this kotlin source code into Java byte code and this is doing this because different processors and if different operating systems need different instructions in order to understand your code so if we are not will not to have this Java byte code so if we had we'll uh compile our code on a specific platform that code can run only on that specific platform but because our quadrant source code is taken by the jdk and through the quarterly compiler and is converted into Java byte code and the Java byte code then it's it's uh it it's send it to the jvm and jvm stands for Java virtual machine and the jvm then because different platforms and different operating uh different platform and different processors need different instructions the jvm is the one which is doing the hard work of figure out figuring out what kind of instruction that specific platform needs so it converts that Java by code into machine code let's say which a Windows platform can understand then the same thing happens to Linux the J the jvm receives the same Java byte code and then it converts that Java by according to machine code which a Linux platform can understand and then is doing the same thing to a Mac OS so the make waves the jvm is gonna is gonna receive the same Java byte quad and it's going to convert that Java by code into machine code which Macos can understand so this is how uh kotlin and Java can achieve this call this thing called Write once and run everywhere this is because the the work of converting that machine code which which a specific platform Cananda said has shifted from the programmer to the platform which has the which implements that jvm so we just wrote Our quad we run our code through the jdk the jdk converted that code in Java byte code and then the platform which has the jvm installed uh it's doing the work of converting that Java by code that we wrote into something which that platform that specific platform can understand so and this is why uh Java and Kathleen are fully interoperable so you can add you can add Java code to an existing kotlin program and vice versa you cannot uh you can add the Java you can add the quota link code to an existing Java program and that is uh that is possible because uh the jdk is gonna is gonna convert through the compiler all of that code into the same Java by code and then that code is going to be run on the jvm and the jvm is going to convert that into machine code and that code is going to run on a specific platform so this is how Java and kotlin and this is why Java and collecting and are fully interoperable because they uh their core they are ultimately converted into the same Java by code and you can also achieve this right once run everywhere because that code then runs on the jvm Java virtual machine which is doing the hard work or figure out what kind of instructions uh specific platform needs in order to understand that code that we wrote and in this way that hard working has shifted from us to the people who implement the jvm so this is how the jdk and The jvm Works under the hood and if you find this confusing don't be just this is just a relaxed discussion about uh how the jdk what is the jdk and what is the kotlin compiler because I said our cotton I said previously that our code is compiled when I said that this actually what was happening our code was taken by the jdkn through the jdk was covered in Java bytecode then it was sent to the jvm of uh which is on my windows and then that is converted into machine code and then we see in the output hello world so this is our discussion about the first program how to create the first program hello world and this is the additional discussion about how the jdk how the quartering compiler and how the jvm works so see you in the next video so in the previous video we created our first program and even though it was a simple program you should celebrate because you created your first program but if you want to make your program to do something useful you need to store data and in order to store data we need to use variables and this is what we're gonna talk about in this video therefore I'm going to open IntelliJ IDEA I'm gonna create a new project so make sure to that on the left hand side you have project selected click on this plus button to create a new project I'm going to call it variables it should be in Pascal case if it has multiple words language we have already constantly selected for the build system IntelliJ and also make sure to have the jdk selected here and now I'm gonna check this out sample code because this is going to generate the code that we typed previously respectively the main function and the print line to and the hello world text is going to be now Auto generated for us by because we check this box add sample code and it's going to add the code automatically for us so I'm going to click on create now our project is ready to go and as you can see here it generated some code for us and this is similar to what we've did in the previous video where we created our we'll create our code ourselves but we have some additional code and uh I'm gonna delete this additional record because it will make things confusing so I'm going to delete this part sorry I'm gonna delete this part and also uh you have may have noticed that uh here in inside this parenthesis we now we have this args array and string we can delete this too because it will make I think things confusing and we're going to talk about what are the arrays and all of that in the next videos now I'm gonna all right now ready now let's run this code to see to see what is happening it's gonna output that text like it did in the previous video you should open the console in a short moment and indeed it opened the console and it output the text hello world like it did in the previous video so I'm going to close the console now also let's expand this SRC to see the file that it was created automatically for us this time and um let's change this hello world text to print another text let's say let's print the type your name there in my case is Alex so I'm going to run this quad and it will output my name in the console all right so it outputted Hello Alex like we typed here but um it's what we have here is pretty pretty inflexible it's a better way to be to to do that it will be to have something to store this name and then refer that that thing here to call that thing here and this will be a bit more more dynamic and to do that we need to use variables and variables are are like some containers which can hold data values and let's see how to create a variable okay Let's uh put the the the code below above our print Ln statement and if you don't know what a statement is a statement is of complete instruction of execution Now to create a variable we just type the keyword far which stands for variable all right next we need to give a name to our very a variable to be able to refer it later to call it later and I'm going to end the naming convention around the naming variable is called is called camel case and that means that the first letter in the name if it has multiple words so start with the lowercase letter so I'm going to type user and the next word name with the capital letter all right next we need to provide the type of the variable and that means what kind of data this variable is going to hold it's going to store to do that we need to put colon and next we need to say what type of data is going to store what what data is going to store and we want to store text and to store text we need to type here string and string means that this variable is going to store a single a sequence of characters or text now we need to assign a value to this variable and to do that we'll put we put here equals space and because we express the cells here that we're going to put text text or string we put a double pair of quotation marks and we type Alex all right so now we create our variable we give it a name a type and with with also sine of value to this variable next we need to refer this variable down here and to to to refer that variable I'm going to delete this text first and to refer the variable we put dollar sign and after the dollar sign we start typing the name of the variable user and as I'm typing the IntelliJ is giving us some suggestions and it said do you mean this username variable and it also has this V here for variable so I'm going to press enter to fill in that for me and if I run this code you'll see the exact singer Happening Here It outputted the text Hello Alex but this time we didn't type the text directly here which we we stored the text in a variable and we call that variable in uh in our printerland I'm going to add a space here to make things more clear now what we can do is to change the value of this variable by adding below of our variable typing the name of the variable again user name equals and now we can assign a new value to this variable and let's put let's put John here all right let's run this code to see what happens now now this time when this uh this instruction is going to be called it's going to print then the new value of the variable which is John so as you can see down here it output the text hello John so we can change the value of the variable after we assign a value to it but what you can't do is to is to type here username equals 5. and if you hover over here it says integer literature does not conform to the specific type string and in other words it's saying that we said explicit explicitly up here that is gonna store only text and down here we try to put a whole number an integer and that is not going to work because kotlin is a link language which is uh which is called statically typed and that means that it it will check the types of the variable at compile time not at run time and that means it does it you cannot run your code if you assign um a value to to a variable which has a different type that done done the type that you specify specified when you record the variable this is why we get this warning here and if I delete this now let's delete this all right okay the next type of variable that also actually not the next type the word over the next way of declaring a variable is using the keyword file so if you declare if you declare a variable as Val Val means that we cannot change its value after we assign a value to it so if you try if you try to assign a new value to our variable like we did here up here it will not work so let's actually let's actually just change here let's put Val okay and and after I did that you it immediately underlying red username and it says Val cannot be reassigned and that is because if you declare if you declare a variable as Val you cannot change its value later it will you can put a value to that variable only once and that's all we cannot change the very the value of the variable later so let's change this back to VAR to have the ability to change the value now let's look at another type of variable so I'm gonna type VAR again I'm going to call it age I'm going to put colon to specify a type here and now we're going to use another type which is int and int stands for integer or for whole numbers now we need to assign a value to it I'm going to call I'm going to put you know 10 or you know 20 22 all right so what we have now is a different type up here we have string and that means that we're going to we're going to store sequence of characters and down here we have integers and that means that we can store um only only numbers only whole numbers and there are different type of numbers which you're gonna look in the next video and if I try here to change this uh to change this so first first let's let's actually let's actually print this uh Hello Alex let's type your age is and here you put dollar sign and we call uh the name of the variable without the name of the variable age so we press enter to fill in that for us and if you run this code now says hello John your age is 22. so now it's using the value the values of this variable in our printerland and we can change for the variable also the its value because it's declared as a VAR not a Val so we can put here age equals let's say 25 and if you run this code the change is reflected immediately in our code so now we see hello John your age is 25. what we can't do like in the previous example with the username Here We cannot put a string We cannot put hit Alex because we said explicitly here that this is gonna is gonna hold only integers only whole numbers so I'm gonna delete this let's put it again to 25 and the arrow error disappeared all right now let's look at what we have here because we have this underlines this uh uh great light out of our types and every time you see something like this that means that IntelliJ is trying to say something to you and if you hover over here actually let's hover over over the type it says explicitly given type it's redundant here and that means that uh it does not need to we we don't know we don't need to say explicitly here that is gonna hold of um sequence of characters it's going to hold string because it knows this you can because it quoting has something which is called type inference and that means that it can infer the type of the variable by the value we assigned to it in our case we assign some text so if I delete the type here now is still working and if I as you can see if I if I put here let's say if I try to put your username sorry username equals to tree is still treated as a string because it inferior it it inferred the type by the value assigned to it and similarly this uh this thing applies to to our int type so if I delete this is still working it's tilt it and it is still treating this as a as an end so if you try to put here age equals to a text I don't know again we have this yellow arrow unifarable it says type mismatch required int and found string and that means that it's still uh is still treating this uh variable as an in because as I said it has something which is called type inference and it can infer the type of the variable by the value assigned to it all right this is uh our discussion about variables there are more types of variables and we're going to look at that other types in the next videos and collectively they are called data types okay you can remove the space if you want so I'm going to end this video now and see you in the next video so while I was recording this course jetbrains have released a new version of IntelliJ IDEA and you will see in the course when you when I create a new project you will see a different window it's not that different it's slightly different than this window than the window that you will see when you download IntelliJ ID which is this version now which has this window and when you see this window here you just need to specify a name here you specify the location for the language selecting here you select for the build system IntelliJ and you make sure to have the jdk here and you also check this out sample code and that is going to generate the main function for you and you click on Create and the project is going to be created for you so I thought that it's good to tell you about this and uh if you'll see this window and if this window changes in the future I'm gonna release a new video and so I'm gonna show you how to if they changed specifically the window of creating a new project how to create a new project with that window but for now this is the window of the latest version all right so in the last video we talked about variables and we seen there that you can store different data in our variables and we looked at two different data types or types in short and that was the string type and that in type and the string type was used for storing sequence of characters or text and the intype was used for storing whole numbers and in this video we're going to take take a deeper look at the integer data type and we're also going to extend our understanding to more types for storing whole numbers and that is the byte the short and the long data types for storing whole numbers you only gonna see what is the difference between this uh these types now let's open IntelliJ ID I'm going to open my IntelliJ ID on the left side make sure that project is created selected click on new project on the left hand side measure the cotton is selected and you don't need to give a name to a project again it should be in Pascal case I'm going to type bite short and long oh now go down here and it's going to select IntelliJ and make sure that the jdk is selected click on next to create a new project and click on finish now our project is going to be created and down here again a setting IntelliJ is setting up our project on the left hand side we have our project pane I can expand this SRC to see our file our main file that we created first now it was generated for us automatically I'm gonna delete this code and here we have something which is called the comments or a comment but they're going to look at comments in a separate video so I'm going to delete this sorry okay I'm gonna add this space here I'm gonna delete this you can keep the RX there it's not gonna affect your code in any way but I want to make it consistent with my previous videos but you can keep the arcs there it will make no difference in uh the way your code is compiled now let's add the code that you had previously and previously we had the we had a variable of type string for storing uh text specifically we store our name there so I'm gonna type the VAR keyword because uh in the last video we we established that you want to change this value later VAR and uh he didn't give a name to our value I'm going to call it name like in the previous video for the type I'm going to choose string and uh I'm gonna put equals and now Center sign of value to it I'm going to put again our text all right and down here I'm going to declare a variable but this time I'm going to declare it as a Val I'm gonna type I'm gonna type for the name H and for the type I'm gonna put int for storing the whole numbers I'm going to put 22. and we see in there that we can delete the type here because cotton has something which is called type inference and that means that it can infer the type of the variable by the value assigned to it so we can delete this type here and our code is going to still be valid and if I hover over here if you look at here is still treating this variable as type of string so but uh in this video I'm Gonna Leave the string type I'm gonna delete this because we're gonna look at the integer more closely and here let's uh let's change this value let's change its name to number and it's also going to be an INT and then let's take a deeper look first let's see what is an integer we know that it's a whole number so you can store whole numbers but what is it's uh it has a range you can put whatever value you want actually there is a range there is a minimum and maximum value that you can put in a in an integer data type so and to get that minimum and maximum value we type I'm going to put a space here to make what the code Mercury I'm going to type Val I'm gonna type Max integer value and for the type I'm going to choose int or you can let it infer the type you can I'm gonna actually put the type here but you can let it infer the type if you want equals and now we type int Dot and Intel J is giving us some suggestions here I'm gonna choose max value and Discord on the right here is gonna give us actually the entire code is going to give us the maximum value in a integer and if you don't if this seems confusing in that and this uppercase so uh you know you don't need to worry about that for now you just need to know that in this way you can get the maximum value to out to be out with in our console and for the minimum value we're going to type Val mean integer value for the type I'm going to choose int now I'm going to type again int Dot and again I'm going to choose from here mean value now to print these two values I'm gonna just delete this text here and I'm going to type int eger or in maximum value is I'm gonna put dollar sign to get the value Max integer value right and below this code we're going to type another println and here you're gonna put two pair of quotation marks again and I'm going to type int minimum value is dollar sign again IntelliJ is giving us suggestions you're going to choose minimum integer value now let's print this uh let's output this code to see what is the minimum maximum value which can be stored in an integer data type and if you want you can add a space here to make things more clear all right and as you can see down here when the console opened that the maximum value is 2 billion and 147 millions and so on and the minimum values to billion 147 millions and so on and these are the minimum and maximum values which can be stored in an INT so that means that you cannot put a value which is which is bigger than this maximum value or the watch or value which is uh uh which is bigger than the minimal values and so if you try to assign and to confirm that if you try to assign here a value which is bigger than the maximum integer value so let's uh type number and now we may be spotted the problem here if I try to put here equals it says Val cannot be reassigned so let's declare this as a bar because I want to change this value now I'm going to put equals and I'm just going to copy this I'm gonna put it here now if I increase this number by one let's say that I put 8 here now it immediately shows an awning and if I hover over here it says that the integer literally does not conform to the expected type int and you may be wondering how this makes any sense because here up here we said explicit that this variable is going to store integers or whole numbers and down here we have a whole number but the problem now is that this whole number is bigger than the maximum integer value which can be stored in an end which is 2 billion one four seven million and forty thousand forty three three thousand six hundred forty seven but now we have a bigger number and um to to store this number need to use a different data type or a different type and gonna see in the next videos precisely what type we need to use and what type we gonna use for storing a bigger number than the integer on the integer maximum value all right also it's important to know because he said he says here now the integer liter so you may be wonder what is this leader the liter is the value that you assign to our variable and it's called the literal because you assign we assign the value directly here so we don't have a what is called a symbolic name here and we're going to see what is a symbolic name in the next videos now I'm gonna edit this video now I'm gonna change it back to seven and also you can delete the types here the code is going to still work the code is going to still be valid and if you delete the type up here also because the type can be inferred like we talked about now I'm gonna add this video now and see you in the next video alright so in the last video we looked at the integer data type and we saw there that you can store a minimum and a maximum value in an integer and uh in this video we're going to look at the next three data types or types for storing whole numbers and those are the byte the short and the long and let's start with the buy to see what is the minimum and maximum value which can be stored in a in a byte so I'm going to type Val my marks byte value for the type I'm going to choose byte equals byte that max value below I'm going to type again Val this time I'm gonna I'm gonna call it my mean my um byte value for the type I'm going to choose byte we're gonna put equals I'm gonna type bite that mean value and now to print this to print the value of those variables I'm gonna copy this to printerland statements I'm going to paste it below here I'm going to change the text to byte and here we need to call our variables to refer all variables so I'm going to type my Max byte value just press enter to fill that for you and below here I'm gonna type my mean byte value now let's print this uh two varus the console to see what is the minimum and maximum value which can be stored in a byte data type so I'm gonna run this code now the console should open in a short moment all right as you can see the byte maximum value is 127 and the byte minimum value is minus 128 and in contrast with those minimum maximum values for the integer type you can see that these two are very very small compared to that now let's look at the next the next type which is the short and I'm gonna do the same the same I'm gonna type the same code AS sorry the same code that you had previously but uh so I'm going to put a space to make it more clear I'm going to close the console so let's see the short type right so I'm going to type Val my marks short value I'm going to put x equals choose short here for the type equals short Dot max value right I'm going to press enter I'm going to type again Val my mean short short value and for the type again short equals short that mean value now let's copy this actually we have already copied that so I'm going to paste that here to print the print our minimum maximum values so I'm gonna change this to short this text I'm gonna change it here to and now we need to call those variables because as you can see right now they are gray out and if you hover over this is the variable my Max short value is never used and that's a clever way to see when a variable is used or not all right let's change it let's change the name here because we want to refer those variables my Max short value and here you're gonna type my mean short value right let's print this to see now what is the minimum and maximum you can be stored in a short all right as you can see down here it output that the short maximum values minus 32 000 70 167 and for uh the short minimum value is minus 32 770 168 right and if you look at the the previous data types you can see that the integers the the biggest is the is the type which can store the biggest number but uh there is one actually which is bigger than the integer so I'm gonna type now the next dot that I put you gonna look at and that is the long which is um much bigger than the in integer so I'm going to close the console I'm going to type the same code I'm going to type Val my Max long value for the type I'm going to choose long and we're going to put equals long I'm going to put that marks value again Val my mean long value for the type I'm going to choose long equals again I'm going to choose now I'm going to type again long Dot minimum volume now I'm going to paste that code below here to Output our variables to Output the minimum maximum bar which can be stored in a long data type so I'm gonna so I'm gonna change this to Long I'm going to change this text also to Long now I need to refer this those two variables up here from up here so I'm gonna delete this I'm going to type my marks long value so I'm going to choose that press enter and here you're going to choose uh I'm going to type my mean long value let's output this uh code to see let's run actually our code to see what is the minimum marketing what you can be stored in a long data type and as you can see the range for the longest much bigger contrast that with the the integer data type you can see that it's a lot a lot bigger this number so the longest has a more is has a range which is much bigger than the integer and I'm going to end this video now and in the next video we're going to look at how we can use those types and um what are the relationships between between them right so I'm going to end this video now and see you in the next all right now it's time to use those for uh data types for storing whole numbers in our code so I'm gonna type some code below of those prison Talent statements I'm going to type Val because I want this very well to be immutable I don't want to change this value later I'm going to call it my number it should be in camel case like our last names and for the type I'm not Define explicit data type here I'm going to put equals I'm going to put the literal value 28. and if I hover over my number you can see that the type which was inferred is an INT now I might be wondering how this makes any sense because this 28 can easily fit in a byte or in a short on a long and that is because the default data type which is automatically inferred is the integer so actually let's confirm that this can fit easily in other data types by running our code to see what at the menu and you can see that that number can easily fit in any of those data types from this list and that is not happening because the automatically as I said the default type which is in third is the integer and if you want this type to be a byte we need to explicitly say explicitly say here buy it now if I hover over here you can see that now it's a byte and if I want to be a short we need to type explicitly here short so if I hover over here now this is a short and if I want to be I want this to be along I just type again here long and for the long there are two ways this is the first way to type the the type explicitly here sorry hover over here it's long or we can put IL suffix at the end of our number but if I put a lowercase letter you eat it immediately show this warning which says use an uppercase L instead of fail and that is because this can easily be confused with one so I'm gonna put a napper KSL and if I hover over here now this is a long even though this can be can be easy can easily fit in any other data type and if I delete this cell and if I exceed the maximum value which can be stored in an integer let's say I put 28 or something here and if I hover over here you can see that now it inferred the type to be as long because now this number that I have here exceeds the maximum value which can be stored in an INT and um you may be wondering now when to use one or the other want to use the byte I want to use the short when to use the long and you will find the the answer with the practice where with the working with them but if I run this code the byte and the short will be used in very specific cases and most of the time you'll be working with the integer data type right now I'm gonna end this video and see you on the next video we're gonna talk about the next data types which are the floating data types and those are types which you can hold the numbers which have a fractional part or decimals so see you in the next video all right before we start our discussion about the floating Point numbers respectively about the float and double data type it's important to know what are the difference between the data types for storing whole numbers under the hood because we know now that there is a minimum maximum value which can be stored in those data types and also we need to know what amount of space they occupy under the hood and let's start with a byte and our byte occupy eight bits right so abide occupy bits and we say that a byte has a width of 8. and a short can store La J range of numbers and occupy 16 bits and has a width of 16. an end has a much larger range as you know an occupies 32 bits and has a width of 32. the point here that each data type occupies a different amount of memory we can see that an internet is the four times the amount of space that abide does for example it's not particularly relevant to you to know these numbers but it come up as an interview question and it's useful to know that a certain type takes up more space than others all right now let's close our project because I'm going to create a new project now I'm going to click here on new project because we have our previous project here all right on the left hand side again kotlin should be selected for the name I'm going to call it um it should be in Pascal case float and double all right here is Eric for the best system IntelliJ and for the produce jdk select the indicator I'm going to click on next and I'm going to click on finish now approach is going to be created right let's delete this code we can keep the arcs and the array string here I'm going to keep it to see that there is no but there's not it's not making any difference in our code I'm going to drain the I'm gonna delete the print again statement and I'm gonna expand this to the left because we don't really need the project pane actually I'm going to expand it full then click here to hide the project pane all right um floating Point numbers are used for storing numbers which have a fractional part which have decimals so floating Point numbers are used when you need more Precision in your calculations and you'll as you'll see in the next video this uh has a practicality now to declare a floating Point number just type Val because I want this variable to be multiple I'm going to call it my number again should be in camera case now first letter first word starts the color case later and the following Awards should start with capital letters and for for the type I'm going to choose let's actually not choose any type let's just put equals and try to try here to assign a value let's put 2.5 okay now if you hover over here and if you look at what type this value has what type this variable has you can see that the type which was inferred is the double so if we want to change the type we can put here float let's say to be a float but look what happens when we do this it says that the floating Point literally does not Comfort the safety type float and that is because like you know in our example with the integer the type which is inferred which is automatically assumed by kotlin is double in this case so even though it is set here explicit that you're going to store a float because it types here a literal value it considers this to be a double so to solve this you need to delete this from here and put here at the end of our number and F now if I hover over here now the variable has the type float so this is how you declare a float variable into put if at the end of the number of suffix and the for the for declaring a double you can just uh type Val let's call it my second number equals and if I put 2.5 here 0.5 now if I hover hover over here like in uh like I said previously it automatically infer the type to be a double so if you don't specific I if you don't specify a type the automatically inferred type will it will be a double because this is the type which is uh inferred for the floating Point numbers and this is similar to the integer type because there we've seen that the type which is automatically enforcedent so here we have the same thing so this is how you can declare a floating Point number and this is how we can declare a double now what is the difference between this the different in the Precision in which depression with a half and we'll see in the next example in the next video we're going to be talking about operators and operations what is the what is the Precision of a float and what is the position of a double and the float comes from a floating Precision number and double comes for double Precision number and as the name implies the the double data type has a more has more Precision in our calculation and you're going to see an example of this in the next video because you need to First learn about operators and operations before we we introduce any kind of operator here even though we we've already used an operator which is the assignment operator which is this operator here but we're going to talk about this in the next video so I'm gonna end this video now and see you in the next video we're going to start our discussion about operators and also in that video you're going to see uh that the float has a smaller Precision than a double and the double is assumed to be it's assumed to be the default ibicos has a bigger procedure so I'm gonna end this video now see you in the next video but before we end our video actually let's uh print let's output those values in our console let's output the values of the variables in our console so I'm going to type println statement below for code below the creation of our variables and inside the parenthesis I'm going to put the double pair of quotation marks I'm going to type my number equals dollar sign to get a value the content of my number and my second number we put equals again dollar sign not here my second number now let's finish those values in our console and as you can see output is 2.5 and 2.5 but if I hover over here you can see that the type for uh because it's explicitly given here is the float if I hover over here this is the double but let's see what happens if I delete the fractional part and I just actually you can uh you can put a lowercase if lowercase f here or an uppercase F like this if you run this code again you'll have the same output again now let's uh delete the fractional part and just let an F there and here let's also delete the fractional part and it's let's run our code and you may be know what is going to happen now printed 2.0 for uh my number because we said exclusively here that this is a flow so it prints the fractional part but uh okay in the case of my number you only output is the 2 because now this is inferred if you hover over here as an INT so one solution to this maybe to type here double and try to see what happens and if I hover over this hover over here says the interior in the integer literally does not conform the expected to tie double and it's correct because this is assumed to be a need so you cannot uh you cannot even though it said exclusive here that this is going to store doubles here we put an INT an integer value so if I delete the type here let's say if I try to put a d here actually there is no D for the double there is no like in the case of the float you know if even if I try to put the uppercase there is no uh way to add the suffix to our variables the only way is to put directly here to point zero and now this is inferred as a double as you can see here and if I run this now it output the 2.0 and 2.0 in both four variables all right I'm gonna end this video now and uh see on the next video all right so far in our course you've only dealt with data types which can store numbers but there are two different data types which you're gonna look at in this video which you can use for storing a different type of data and we're going to see what kind of data we can store but those data types are called the Char data type and the Boolean data type but first let's create our project let's create a new project I'm gonna give it a name I'm going to call it char and Boolean again it should be in Pascal case make sure for the build system that you select IntelliJ and measure that have the produce jdk selected so I'm going to click on next to create our project I'm going to click on finish now project is going to be created on the left hand side we have the project pane we have our code Auto generated for us even though this code is gonna we're gonna delete this code which is inside the curly braces because you don't need a squad so I'm going to delete this code and let's also hide the project pane because you don't need a project pay and let's see how we can declare a chart data type and after that we're gonna talk about how where you can use the shutter type in a specific case and what specific cases you can use so I'm going to type Val because I want this variable to be mutable I don't want to change valid value later I'm going to call it my Char value again it should be in camel case and for the type I'm going to put colon I'm going to choose char press enter let's put equals and let's now assign a value to this variable so this time I'm gonna type a single pair of quotation marks not a double pair of quotation marks like we did in our string data type and in a chart data type we can store only a single sum symbol and that symbol can be a letter a number or an exclamation point on the mark so I'm gonna put here a d a single letter D and uh you may be wondering now what is this what is a specific case when you where you can use a charter value a specific case can be let's say if you want to store the last key press the bio user so this is a specific case where you can use the charter data type now let's print this value in our console to see that it should be in a lowercase letters pinterland and uh you can print it by the usual or you put here a double pair of quotation marks and we type a dollar sign and hero we type the name of our variable match our value press enter I messed up the code let's delete this now if I run this the console will start in a short moment and you're gonna see the output of the letter d right so the console opened and now we have output down here the letter d so this is the usual way how one of uh referring a variable that but you can refer the variable even like this by not putting the dollar sign deleted the dollar sign and also the the quotation mark at the beginning now if I run this it's going to still output the battery so we will see that we have now most of the letter A so this is another way of printing the value even in a variable but this uh it's not really the usual way to do it now um let's take a look at the next data type and that is the Boolean data type and to declare a boolean.type we type again Val because again I want this to be multiple and and I'm going to call it my in camel case it should be Boolean value for the type choose Boolean and a Boolean a Boolean data type Can Only Store a true or a false or a false value so you can only assign here true or false so if you type now let's put in those values but this time I'm going to put the parenthesis and I'm going to put the quotation marks I'm going to type my char let's my char value equals dollar sign my chart value and my let's type the name here Boolean value equals and let's put the dollar sign my Boolean value now if we run this code now you can see that my chart value which is this text here has this value which is the content of this variable that we're referring here and uh my Boolean value which is our variable the name of our variable has the content of false so it printed here false now Boolean data types the Boolean Atlas are going to be used in our code a lot because the Boolean data types can be used for controlling the flow of the program so you can in you're gonna see that in combination with the if statement without which you're going to look at in the next video on the next videos uh you can control you can actually control the flow of the program because usually the flow the program is from top to bottom and with the for with the the Boolean data type and with an if statement as you'll see you can control uh actually what you can control to you can control what parts of the code are uh compiled or not based on a certain condition if that function is false or if that condition is true so Boolean dial types are going to be used as you'll see a lot in our code in your coding career as you'll see so these are the two data ties that can be used for storing either a single character or a or a character and this is the data type which can be used for storing true or false which is called the Boolean type also you May so already that you can delete the types yet because as we talked about kotlin has what is called the type inference so can it infer the type by looking at what value assigned to it so in this case you know it knows that this is a type of chart so here you know you can see that the type is a Boolean all right but before we end our video let's do a little recap about the eight data types that we looked at into throughout these videos and the eight data types are the byte short int and along those are for storing the whole numbers and the next two data types are the float and double for storing floating Point numbers for numbers which have a fractional part decimals and the next two ones are the ones that we looked at in do this video and those are the Char and the Boolean and those data types are also called the primitive data types because it has to do with their call like that because it has to do with how they are stored in memory and a string data type is not really A Primitive Delta because the store is stored a little differently also as you can see the string data type has a special language support so you can consider this eight primitive data types as the building blocks for data manipulation and in the next video we're gonna look at those this data manipulation but by looking specifically at what operations we we can do with the those data types because in uh throughout this this video we only looked at how we can store values and how we can output this those values but in uh in a real real app you'll need to to manipulate that data to other to subtract something and we're going to look at all of this in the next video see you next all right so far in our videos we've only looked at how we can store different values in our variables how to Output them to the console but in a real app you'll need to do some mathematical calculations so in this video I'm going to learn about that we're going to look at operators so first let's create a new project I'm going to click on new project I'm going to speed up the process now a little bit because we did this already a few times so I'm going to call it operators I'm going to select IntelliJ click on X and click on finish now our project is going to be created in a short moment again on the left hand side you have the project Pane and we have the main effect function and the code Auto generator for us now we're going to delete the code inside the curly braces inside the calibrations of main function because it only Discord and also I'm going to hide the project pane because I don't need the previous Pane and first let's declare two variables I'm going to declare the first variable as a VAR because I want to reassign this value later I'm going to call it um uh let's say um X and in a real app you should use more descriptiveness because the name of the variable should say what the variable is doing anyway I'm gonna put equals I'm going to assign a value of five and the next variable I'm going to declare it as a Val because I don't want to change its value later I'm going to call it I I'm going to put a value of 3 here and next I'm going to decode another variable this is going to be also or Val I'm going to call it result and we're going to store the sum of 5 and 3 here and to do that type here x and this is the first operator that we're going to looked at look at and that is the add or the plus operator so I'm going to put here X Plus I now let's print this result I'm going to type println I'm gonna put the double pair of quotation marks I'm gonna type result the text equals dollar sign to get the value of the variable here I'm going to press enter to fill that suggestion for me and now let's run this code to see what is going to Output you're gonna see the output 8 here because five plus three is eight the console should open in a short moment right so it output the result equals to eight because five plus three is eight now what we have differently here and we didn't uh we didn't have we didn't had previously is that now we're using a variable the variables here and we're not using liters like we have here five and three type directly and um it's important to to clarify some names here and first is the name operand and open an operand is any object which which isn't affected by an operator in our case the operands are X and I because those those variables are affected by the operator plus because it sums their values and then it puts these values in the variable result so those two variables X and I are called operand also the if you had here little revolves if we put it here let's say 5 and 3. directly these two all are also called operands so literals or variables are called the operands any any objects which is affected by an operator is called an operand because if you now if you now you're gonna see also eight here but let's change it back to to I and X and there is another way to to output the value of x plus I by using a placeholder what is called the placeholder and to do that let's first delete this line of code and this now is red because we don't have the variable declared I'm gonna delete what is inside the quotation marks I'm gonna I'm gonna type here X plus I the text equals and now I'm gonna put here I'm going to put here dollar sign and I'm gonna put curly braces and inside the color braces I'm going to type Let's uh click here to make it clear X plus I so this is called the placeholder and you can use this and in a placeholder we can only put expressions and an expression is a construct which evaluates to a single value so in our case X plus I evaluates to a single value because it Returns the value 8 so this is why we can put here uh X plus I and uh even though if you if you if if you put something which you will not uh be an expression here IntelliJ is going to warn you and I'm gonna see uh in the following minutes um an example of that now let's out for this and you're going to see the same result but now we have the different text here we're gonna have we're going to have X plus I so now I have X Plus PSI equals eight which is the correct result now let's copy this four times and to do to make that easier we can press Ctrl D or command D on Mac so I'm gonna press Ctrl D four times now let's change this to minus because we're going to look at the subtraction now here we're gonna look at I'm gonna look at the multiplication operator which is an Asterix operator so I need to put here inside the curly braces the Asterix because these were the expression is evaluated and the next is the division so we're going to put here a photo forward slash so I'm going to put here also forward slash forward slash right and you know this uh this operators for a month class this one but the one that is not so well known outside the programming uh it's uh it's called the modulus operator and the modulus operator is operator which um gives us the reminder of a division so the models operator is a percent sign so put per second sign here and percenter sign here right now if you run this code all right so now we have the output down here and we have X plus I see eight because five plus three is eight x minus I is 2 because 5 minus uh 3 is 2 x times Y is 15 because 5 times 3 is 15 x divided by Y and this is interesting is 1 but because those variables are of typing they're inferred automatically to be of type in it dropped completely the fractional part here so we don't have here 1.6 or something you have only the integer part which is one and here we have the the modulus operator and this gives us the remainder of 5 divided by 3 which is 1 and has a reminder of two now if you want to to have here the fractional part you need to declare uh one of the variable uh as a type as a floating Point number and that can be or or either a float or a double so then I'm going to declare the the I variable as a double so I'm going to put 3.0 Here and Now all the variables all the results here are going to be are going to be are going to be of type double so if you run this you're gonna see the fractional part for all the variables here now you can see now we have wipe one 8.0 2.0 15.0 and here we have 1.6666 and 7. now it shows also the fractional part and uh for the reminder all we've we've also have the fractional part here so um now the type of the if you want the type of the expression it's a double because we declare here as a double this variable I as a double and the next one is wide then automatically you don't need to declare also the ex as a double it will be um so if you want widen automatically by the fact that it required the I variable as a double all right and let's continue and often in programming you'll want to increase a variable by a certain number and to do that let's first let's declare again the variable result down here let's declare it as a VAR because I want to resign it let's call it result and let's put again X plus I here now if you want to increase let's say the the value of the variable by 2 we can type something like a result equals result let's say that I want to increase this variable by 2. I'm going to put result equals result Plus 2. and this equals operator is different from a mathematical equals because this equal separate operator is not saying that result equals result plus 2 because I think it's incorrect what this equals operator is is also called it's an assignment operator and what is doing is that it assigns first it adds to to our variable result and then it store stores that that result that result of the that expression in our variable result all right so let's print this value to see what we have here so if I print this you should see 10 here not print I'm and I'm going to put here result equals dollar sign result and in front this code you're going to see 10. right so you have 10 but let's uh let's delete the the fractional part here to have the type of the variable as integers so let's run this code again so now we have 10 here result equals 10 and let's copy this called the again four times let's add a space so now I messed up the code and if you mess up the code like I did here you can do you can undo this thing by going to edit and click on undo paste or the shortcut is Ctrl Z and you'll see the corresponding shortcut in a Mac here on the right so please press here and now our code is restored here as you can see so let's copy this again foreign and let's space this down so one two three four all right now let's change this this one to minus let's change this to multiplication which is the Aesthetics operator let's change this to division which is the follow slash and let's change this to modulus which is the percent sign now if you run this code let's run it from the top right right hand side now what you're going to see is that first we have 10 because of now the result has a value of 8 because X plus sign is 5 plus 3 we have eight and now here we we're adding 2 to our result and then we print that value in that variable in our in our console and that is gonna output 10. the next we decrement that variable by 2 and we have eight next we multiply that that uh variable by tools so we have 8 times 2 which is 16 which is the result here next we have a result divided by two and uh 16 divided by 2 is 8 so you have eight eight here now now we have result modulus 2 and 8 modulus 2 is 0 because 8 divided by by 2 has no reminder right next you can see that we have all of those underlines here and if you hover over one of them it's gonna say replaceable with operator assignments so there is a shorter wave to write the same thing that we have here or there is an abbreviation to write the same thing that we have here and here and here and here because they are so often used in programming they are there is a abbreviation for all of them so let's click on replace with plus and equals replace with minus n equals replace with the multiplication and equals with division and equals and with modulus n equals here all right so this is the abbreviation of what we had previously or a short way a shorter way to write the same thing so if you run this code now you're going to see that it's going to Output the exact uh values that you had previously so we have 10 8 16 8 again and zero so this is a shorter way of abbreviating uh oh actually this is a way of abbreviating what we had previously because as I said they are very very often used in programming what is all right now another important thing to know is operator precedence so first let's type again a println statement and I'm going to put the worker recognition marks and inside the quotation marks I'm going to put the text to three so this is the text three plus three times let's say um four now also inside the quotation marks let's put a dollar let's put equals here the text and let's put a dollar sign here and now let's put curly braces and inside the curly braces I'm going to put three plus three times four let's click here to make it clear times 4. now if you run this code now you see that it outputed 15 because multiplication has precedence over addition so it first multiplies 3 times 4 which is 12 and then it adds 3 to our results so we have 15. but like in a math class you can control which expression is evaluated first by putting parentheses so if I put parenthesis here now this will be evaluated first three plus three and then it will multiply the result by four so if you run this code you're gonna see three plus three is six times four is 24. so you're going to see 24 right now so you can see that operators have precedence but can control that precedence using parentheses like you did here so multiplication and division have precedence over additional and subtraction all right there are two other operators which can be used for increasing or decreasing the value of a variable exactly by one and let's look at this operator but first let's uh use our variable X that we declare above and let's assign a value of 0 to it and to use the increment and decrement operator this is how they are called let's use the printerland statement first to let's put a double pair of quotation marks here and let's type x equals and let's put dollar sign and let's type here X and to use the increment operator we type plus plus right and what this is gonna do is going to increment the value of our variable which now is 0 by 1. and there is another way to increment the value for a variable by putting the increment upper operator or the plus plus operator in front of our variable not at the end of our variable so we can type again a println down here let's put the quotation marks and I'm going to put x equals and now I'm going to put dollar sign plus plus X but this now is not working because dollar sign only works if you refer a variable so to do solve that you're going to put this in a parenthesis actually in curly braces so let's put this in color braces and let's put the above one also in curly braces not here all right and uh both of both of these increment increment value of x by one they differ in what value they return so the first first Returns the value of x which is zero and then it increments and the next increment operator which is before the name of the before the variable it increments the variable and then returns its value so what you're gonna see if you output this code is going to be interesting so if what if you output this code let's bring it down you're gonna see Zero and two and maybe wondering how this makes any sense because you have incremented the value here and uh that's that does this happens because this first Returns the value of x so it returns varices and then it prints the value of 6 which is zero and then it increments so now the X has the value of 1. when the next printerland statement is executed now it with the variable x is incremented by one so it has a value of one and now it will be incremented again but it will also be returned not like in the previous uh increment operator which is the other end so now it will have the value of 2. okay and there is uh the same operator is available available for uh decrementing so if uh if you want to decrement a variable exactly by one I can put here x let's put equals let's put the curly braces actually the dollar sign curly braces and can put x minus minus and let's print just call the printerland function again I'm going to put x equals dollar sign again curly braces and let's put now the decrement operator which is the minus minus in front of our variable now you're going to see something similar but in the inverse way so now we have now we have two and zero and let's explain uh this also so again this printerland statements executed now the X has the value 2 and it returns to and then it decrements so it prints the value of 2 and then it decrements the value of our variable X by one so now we have one when the next printerland statement is executive or function is called now the value is 1 so and it first decrements the value and then it Returns the the the the value of the variable so now we have zero because it was decremented this is why you have uh 0 and 2 and 2 and 0 here all right so you see above here that I declare the variable as a VAR so I can reassign this value down here to zero right this is our discussion about operators there are more operators but in order to talk about the next operators we need to first talk about an if statement so now it's time to look at comments and comments are nodes that you can add your code and they are ignored by the compiler and usually they are they are used when you want to add some description about the code so what you want to indicate what the code is doing because you may roll some code and you come to that code a few weeks later and forgot what it's doing and by putting comments you can you can see specifically what that code is doing and when in kotlin we have two types of comments the first is socalled endofline comment and to add an end offline comment we put two slices and here we put our comma let's say here we are doing ope operations so this is another End of Line comment and this is a text which you simply says here we are doing operations and this is uh as I said an end of flying comment the next comment that you can use is so called The Block comment and to use a block comment we put slash Aesthetics and now you can press enter or you can put Asterix and slash to add to to add the the next uh to close this comment and you press enter and as you can see it added automatically this Aesthetics and slash or you can type this yourself and here you can put some text which can be some it can be something which is going to say what the code is doing so so those are the two types of comments that you can use in kotlin The End of Line comment and the block the block comment and you can also use comments to disable some code so if I put two slices here now that line of code is going to be ignored by the compiler so this is our discussion about comments see you in the next video alright before we continue discussion about operators let's first introduce the if then else statement and uh let's first start talking about how usually our code is executed and usually our code is executed from top to bottom and that means that our code is executed line by line and that is the flow of the program but with an if then else statement you can break the flow of the program by imposing a condition and you can say to the computer to execute a particular section of quad only if a condition is true so let's see how we can do that so let's first create a variable I'm going to type Val this is going to be multiple I'm not going to reassign this value I'm going to call it it's active and I'm gonna put equals and I'm going to sign a value of Truth way so it's going to be of type Boolean on the next line I'm going to type the if keyword and now IntelliJ is giving us some hints here I'm going to press enter and inside the parenthesis we put our condition so here I'm going to type is active the variable and now I'm going to type equals equals notice that here now we have two equals and here we type true next we put a left curly brace and now we can add the right curly brace or you can press you can press enter and the right curly brace is going to be added automatically by IntelliJ for you so if I press enter now you can see that on the line 40 we the right calibrase was added automatically now let's type here a println statement so I'm going to type println press enter and quotation marks and here we're going to type the text the user is active right and uh if you run this code let's see what happens and we get the output the user is active which is the text that we typed here and let's first talk let's first talk about what we have here and uh the if statement checks to see as I said to see if this condition inside the parenthesis is true this if this expression returns true and it does that by checking to see if the operands are identical or if they are the same so it checks to see if the content of the variable it's acted which is uh true it's equal to true and that is that sounds convenient but it's true because uh our variable it's active has a value of true and here we're checking to see if our uh if those two are equal or if they are the same and that is true and this expression returns true and in effect the code inside the curly braces is executed but if I change this to false so if I change this value and if I run this code now this condition inside the parenthesis is going to be false and the code is not going to be executed so you can see now that you don't see any output because this condition is false and because the condition is false the code inside the curly braces is not going to be executed but uh if you want to cover the part where the condition is false so if you want to execute some code even though the condition is false you can type here else and here you also need to put the calibrases so I'm going to put the left curly brace I'm going to press enter and the right calibrate so that added automatically for me now I'm gonna type println and inside the parenthesis I'm going to put the user is not active so now what is going to happen is that this condition is going to fail it's gonna be false because the two operands are not equal respectively is active and true and is going to be executed the else part in this case it's going to be executed the code which is inside the curly braces of the else so if you run this code you're going to see the output the user is not active so as you can see now it says the user is not active because this condition is false this returns this Boolean expression return false and it jumps to the else part so this is how you can use the else part now what we can also do is to add another if statement below of our if statement to chain more if statements to check for more conditions but to do that we need to use another operator which is the called the greater than operator which is an operator which you may know from your math class and through that let's change for the variable so I'm going to type here a value of 100 to make it an integer and also I'm gonna change its name and to change the name of the variable go right click on the variable go to rename to refactor and go to rename and now if you change the name of the variable here is going to be change every where where the variable is called so if I look what happens if I delete the name here it's changed also on the line 38 we're referring the variable and now I'm going to call the variable my number and I'm going to press enter now the name of the variable it's updated and now this condition is not correct you don't need to put a greater than sign so I'm going to put the greater than sign and let's check for uh let's say if my number is greater than 150 and this is false now because my number has a value of 100 so this is going to evaluate to false this condition this expression now let's add here another if state if statement so we're going to put here else if and inside the bottom test you're going to put the condition and now I'm going to type again my number my variable or variable now you're going to put let's say or greater than 90. now this condition is true so let's add Also the curly braces because we need the we need the to put our code inside there let's put here open until then also let's type here greater than 90. and here let's also change the test to greater than 150 and here you can put all the conditions here you can put all the condition failed because the else part is going to be executed only if all the condition that we have here which is uh for that my number is greater than 150 and this is false my number is has a value of 100 and if our lcf condition also evaluates to False only then the else part is going to be executed so let's run our code to see what what if statement is going to be executed what part so you can see that we now get we get greater than 90 and that means that this condition is true because it's true that my number has a value of 100 and it checks to see if my number is greater than 90 which is true so it executes the code which is inside the else if part right now the next operator that you can use is greater than or equal to so you can put here greater than or equal now what is gonna check to see is to is that what is going to check is to see if the number that we're comparing to respectively my number is greater than 100 or equal to greater than 150 or equal to 150 so let's change this to let's say um um 100 and uh 49 so look what happens now so now it's executed the this part the lc4 because this is greater the number greater than 90. but if I put here greater let's change the value of my number to um 150 to see what happens and now we get the output greater than 150 and this is correct because now this condition is true my number is greater than equals to 150 and uh my number has the value of 150 it's not greater than 150 but it's greater than or equal to so it's equal to 100 150 so now this condition is uh satisfied and the code inside this curly braces is executed which is greater than 150. all right now I'm gonna end this video and in the next video video we're going to continue our discussion about um those operators right so now let's continue our discussion about the next operators that you can use in kotlin and let's start with the less than operator and to do that let's first change the value of the variable my number to 100. and to use the less than operator you we put here a less than sign which you probably know from your math class now if you run this code I should change here the text to make it consistent let's type here so now if you run this now get the output less than 150 and this is true because the value of the variable my number is less than 150 so this condition now evaluates to true the next operator that you can use is less than or equal to similar to greater than or equal to operator and to use the less than or equal to operator we put here a less sign and the equal sign right and let's change the value here to 150 to make it clear now let's change also the value of the variable to 150 and let's also change the text here now if you run this code you're going to see the output less than or equal to 150 because now the else if part and the condition of the else if statement evalues to true because now the the value of my number it's not the it's not less than 150 because it's 150 but it's less than or equal to 150 so this condition evolves to true right the next operator that you can use is called The Logical not equal operator and that operator is used to check if two operands respectively to if my number let's say or and 150 are not the same let's see how we can do that and to do that to type here an exclamation mark and an equal sign and this operator here which is going to make a mark is gonna check to see if those two operands respectively my number and 150 are not the same and only then the condition is going to evaluate true so let's run this code to see what happens so now we get the output less than or equal to 150 because we still have the volume 150 so it jumps to the lcf part but if I change this to let's say 100 now look what happens now it execute the if now this condition evolves to true because now this operator is checking to see if the two operands if the value of my number the value of my number is not equal to 150 and that is true they are not equal and this is why you get here the output but let's change the output to make it clear let's type here they are not tickle so if you run this code you're going to see the output I are not equal because that condition now Evolution so this is how you can use the logical not equal operator also with the logical not operator we can change the value for Boolean expression from True to false and from a false to true in other words you can negate its value and to do that let's first declare the code that we had previously so I'm going to cut again the Val variable it's active I'm going to assign a value of true I'm going to type the if statement again I'm going to put the same condition equals equals true here you can put the left curly brace and press enter we can add the right color base if you want but it will be added automatically for you I'm going to type else also the left curl base press enter I'm going to put the text that you had previously all right now if you run this code you're going to see the output the user is active because this is going to evaluate to show their are equal they're the same let's expand this so you see the output user is active because this condition average to show and before you look at The Logical not operator how we can get the value let's first see how we can write the same expression that we have here in a shorter way by abbreviating so because you have noticed probably that we have another underline here and if you hover over here it says that the Boolean expression can be simplified so let's click here simplify Boolean expression to see what happens so now we get if it's active and then print then execute the code inside the curly braces so this thing now does the exact same thing that we did previously it's so it checks to see if the value of its active is equal to true so it's a short way of writing the same thing and uh now get the output the user exactly but with the equal not operator you can put the exclamation mark in front of our its active exp expression and it's now now it's going to negate this value now it's going to change its value from True to false so now if you run this code not going to see the output the user is not active because now this logical not operator switch is switching its value to false so now this is going to be this will evaluate to false it and it's going to execute the else part that we have with the user is not active and you can do the same for a false so if you put here false now let's actually execute this without the logical not operator to see what happens now this will not execute so it will execute the else part so you see the user is not active but if I put the logical not operator in front of its active now it's going to change its value from false to true and now this will evaluate to true and it will execute the oh code inside the calibration of the if so now you see that it says the user is active so this is how you can use the logical not operator to flip a value from false to true or from True to false and you can do this for for every Boolean expression that you use so you can put the logical note operator in front of this actually not in front of this um you can put the logical not operator generally speaking in front of any Boolean expression right so this is our discussion about operators so in the next video we're going to look how we can combine multiple Expressions to create a bigger expression which you sell for returns uh true or false value see you in the next alright so I deleted the code that we had previously you can keep the code that you have to use if you want but I deleted to make things more clear and in this video we're going to look at how we can combine multiple Expressions which in essence can return a Boolean value which can be either true or false and uh let's start with the first operator which is called The Logical end operator but less vertical two variables I'm going to declare a Val variable I'm going to call it it's playing I'm going to sign a value of true sweet so it's going to be of type Boolean and on the next line I'm gonna declare another variable also of all and it's going to be called score and it's going to have a value of 80. now down here we'll type if and inside the parenthesis to type is playing equals equals true so this is the equals to operator I didn't then talk really a lot about the equals operator but equals to operator checks to see if the two operands are the same so it in contrast to the one equal operator the one equal operator assigns what's on the right to do our variable which is on the left so in this case assign truth or variable is playing so or it's a sign 80 to a variable score the equals the two equals or the request operator is different because it checks to see if uh what we have on the left or what have on the left in and on the right are the same or are identical next and we know from the previous video that you can abbreviate this you can write this in a shorter way by putting just is playing this will be this is going to be equivalent to what you had producer because as you can see it says that you can simplify the Boon expression and now gonna you use the logical end operator and use the logic logical end operator with type 2 Ampersand science and here we type score now I'm going to use again the equals equals operator this time we need to use it there is not a shorter way to check for a new type if score equals to 100. all right so this expression inside the pattern this is going to evaluate to True only if both Expressions respective is playing and score equals equals to 100 evaluates to true so only if those two conditions are true only then the code inside the parenthesis inside the curly braces actually is going to be executed so let's say that in a real app here you can add the logic to open the next level but here we go just gonna output some text so I'm going to type here next level opened right and also I'm gonna add the else part here and we're gonna put also printerland statement and inside the part of this is going to type steel art the same level now if you run this code you're going to see the output still at the same level because not those conditions are not both true is playing is true but it's playing is equal to true but our score is not equal to 100 so this is going to evaluate to false and the entire expression inside the pattern is going to turn false so it's going to execute Tails part now if we change the order the value of our variable score to 100 now both expressions are true is playing equal to true and score and the score is equal to 100. so now both of our expression are true and gonna see the text Next Level opened and I will see that it output the next level opened so this is The Logical end operator and you're going to be using uh The Logical and operator a lot in your code all right so now it's time to continue our discussion about operators and going to look at the next operator which can be used to combine multiple expression and that is the logical or operator and the logological or operator evaluates an expression or multiple expression in this case to true if one of the condition is true or if both conditions are true so let's see an example of this but first let's comment the code that we have here because to make things confusing so go to code and select comment.light command with line comment or you can press the shortcut Ctrl slash now let's equal to variables down here the first the first is going to be a Val I'm going to call it num1 I'm going to sign a value of 5 to it second is going to be also Val it's going to be called num2 and I'm going to send a value of 3 to it or four now I'm going to type the if Dental statement I'm going to type the if keyword inside the parenthesis I'm going to put the condition first is if num1 is greater than zero and now to use the logical or operator we type two vertical bars here now we put our next condition or our next expression and that is num2 is also greater than zero and we put a curly brace press enter two to add the right color base and put also the else part and inside the calibrases of the if let's print some text let's say the condition is true all right now if you run this code you're going to see the output the condition is true because now both conditions are true and The Logical operator returns true if both conditions are true or if one of the condition is true so let's see if we change this to 3 and now our second condition num2 greater than zero is false so now this is also going to evaluate to true because The Logical operator returns through if one actually with one of the conditioners or if both Constructor so now get conditional show but if you change this to also to 5 now our both both conditions are false now you're gonna see that it's gonna be executed the daily spot because this condition is going to be false because both conditions both Expressions num one greater than zero and num two greater than zero are false all right so let's change it back to five now if you're on this code you're gonna see the condition is true because at least one of the condition is true which is this one normal and greater than zero even though the number two condition is false all right and this is how you can use the logical or operator all right now it's time to see how we can use the if Daniel statement as an expression and that means that the if Daniel statement can return a value which can be stored in a variable so let's see how you can do that but first actually skip this code that we have here and uh to use the if Daniel statement as an expression we declare of um a variable first so I'm going to create a Val and let's give it a name I'm going to call it let's say text and to use the if then else statement as an expression we put equals and after the equals we put our if then else statement now we need to assign a value to our variable text to use it as an expression and the value is going to be the last expression in the in the curly braces so here if I type the text let's say uh this is text one and down here if I type quotation marks this is text tool now if I add a print Ln here at the end and if I print the value of the variable text that we declare above let's put a dollar sign and if I type text here now you can see our variable it says it's of type string so if I run this code now you're gonna see first this println inside the curly braces which says the condition is true and after that you're gonna see this text being assigned to our variable text and it will be output out output it down here by the printerline statement so you see this is text two actually I was wrong that condition is false because it will have minus five and minus three and this condition but it's the false and the last the last expression in the in the curly braces is assigned as a value to our variable now uh what you can also do is to remove the curly braces but it's recommended to use to not use the curly braces if you have one only one statement uh in your if Dental statement so let's delete the printerland here let's delete the curly brace here let's also delete the calibrase here let's delete the printerland statement here and let's also delete the curly berries here so now this will work the same to work like previously but uh so now you'll see the same output without the condition without this take the control result because now we don't have the printerline statement so now get this text too because this condition evaluates to false and it assigns this value to our variable text then down here it prints so also you see that this uh they are not aligned here this our variable and two format your code you just go to code and click reform reformat code or place Ctrl alt L on Windows or you can um use another shot you can use the corresponding shortcut on Linux or Mac so click on code and now we're gonna see that our code is formatted if you run this now see this is text too but let's change this to five now this conditional overlay to true and this expression is going to be is going to be assigned or variable text so if we run this hmm you're gonna see this now our variable text is assigned the value of this is text one because this condition is true and inside this value to make things more clear clear you can use a you can you can type your code something like this now this does there's everything is the exact same thing as previously so if you run this code now you're gonna see that now this it says the same thing this is text one now you may be wondering what type this variable is so if you hover over it this is the it is of type string but look what can I do I can put here a number so if this condition evaluates to false this is going to be assigned or variable test so if I run this now now get this text one and let's uh put here 5 for the condition to be false and if you run this code now now I'm going to see five and you may be wondering how this makes any sense because previously our variable was of type string but if you have hover over here now it says Vault text and the type is this thing comparable anyway but what is uh simply doing here is looking at the condition it's looking first at the if statement and if this condition is true then it assigns our text or variable and then it infers the type to be a string right if this condition is false then this part is skipped and then it assigns this value of 5 to our variable text and not and then our variable is going to be of type int so there is no case in which both value is going to be assigned to our variable so this is why you can use here text and here an integer even though but if you declare explicit here that this variable is going to store only strings only sequence of characters or text now he'll get an earning because it says the integral transforms the expected stream so in other words we cannot put here but a number because we said that explains here that is going to store only strings but if you omit the type that is gonna work so you can decide not to depending on the context what to choose so this way of writing the internal statement in one single line like we have here it's okay as long as we use the if the general statement as an expression or in other words if you're assigning a value to a variable like in our case but if you have multiple instruction you know also if you have a single single instruction you can also omit the curly braces but most of the time it's recommended to use the curly braces because that allows the those allows us to execute more than on uh instruction on the statement in your code and it also makes the code more clear so let's change this code from an expression to just a new general statement to see why so I'm going to change this I'm going to add the curly braces from other code press Ctrl alt l all right and low solution it is let's delete this text let's add to print Elena statements here foreign now if you run this code you're gonna see this part executed else part because this condition is false fault of our condition respectively num1 great is not greater than zero and also num2 is also not greater than zero so this is going to return false and it's going to execute the else part all right but now if you change this to five and now one of the conditions is going to be true and as you know this entire expression is going to wait is going to evaluate to true now because at least one of the the expression is true so if you run this code now I see this condition is true and also we see all our second printerland statement this condition is running some text but look what happens uh if I uh let's say if I delete the else part right and if I delete the curly braces here all right and now if I run this code you see the now both statements are executed but as I said if you don't use curly braces you want just only one of the uh statements in is going to be executive so why you have both of these because the first is if you executed as part of the if statement because this one is true and the next one is executed because it's part of the code because it's red from top to bottom but if I change this to false and now I want both condition both statements respectively with this one and this one to not be executed look what happens now get this condition experience on text so the first instruction in our if the next element is omitted because it's part of the if the statement but the second one it's executed because it's part of the code so it's going to be red anyway so this is why you need to always use curly braces in this way the entire code is also is gonna be either executed or omitted so this is our discussion about the external statement and you should always use the curly braces and for this part you also you should use the curly braces and um only omit the calibrations if you have only single one single statement or one single expression if you want to use uh leave the statement as an exception to assign a value to a variable but if you have just one single statement let's say you have something like this economy the curly braces like this so now you can see that everything works fine so you can use it like this if you have one single statement like we have here you just print some text to our console or if you use it as an expression so if you sort of value in a variable so see you in the next video all right now it's time to look at the next control flow statement that you can use in kotlin besides the the if Daniel statement and that is the when statement or the one expression but first let's create a new project I'm going to call it Ctrl flow it should be in Pascal case select IntelliJ click on next and finish right now let's delete the code inside the curly braces let's hide the project Pane and let's first declare a variable it's going to be a Val it's going to be called alarm and I'm gonna assign a value of 12 to it now to to declare when statement we type here when we put parenthesis and inside the parentheses we put our argument in this case is our variable alarm next put space and we put the curly braces press enter and now we put the expression here so here I'm going to put the value let's say 12. now I'm going to put a minus sign and a greater than sign so I have this Arrow and here I'm gonna type print Ln this is the code that is going to be executed so and I'm gonna type the time is dollar sign alarm let's press Ctrl D to duplicate this two times or three times and let's change the last one to one else all right let's change those values here to 7 and 14. now let's run this code to see what to get in the output and after that we're going to discuss our code so getting the output the time is 12 and we get that because what is what the when statement is doing it's using this argument that we passed here in this case it's our variable called alarm and it's comparing this uh the value of this argument with all the branches that we have here respectively it's going to compare it with the expression that we have on the left because on the left we have the expression the this Arrow sign is gonna is is uh saying execute execute this code on the right if this expression on the left is true in this case if our Allah alarm equals equals 12 and it's true we have a value of 12 so this branch is executed and it executes the code on the right which is this this the alarm is 12 but if I change this to 7 now and if I run this code I'm going to see the time is seven and if I change this to let's say 13. and here we have no 13 Dallas part is going to be executed similar to our if Daniel statement you know get the time is 13. so it was it was executed the else part now now and we can combine those uh Expressions by putting a colon and and we can combine them and putting them on on one single line so I can put here colon I can type here seven and fourteen now I'm gonna delete those two now it will check to see if our alarm argument has the value either 12 or 7 or 14. so um let's change it to 14 to see so now if you run this code you're gonna see that this will evaluate to true and this code on the right is going to be executed so again the time is 14. and if I change this to 7 again this level is true because one of those expressions show so yeah the time is seven all right what you can do next is we can check to see if a number is in a certain range so we can put another another expression here and and here I can type in the in keyword is used to check to see if numbers is to see if a number is in a certain range and to declare a range we type the range let's say that I want to check from let's say uh one from one to ten we put two dots dot dot 10. now what this is gonna do is gonna check to see if our alarm argument in the in this in this case our alarm variable is in the range from 1 to 10. now I'm gonna put a minus sign and a gray and a greater than sign to have the arrow and here I'm going to type the code that I want to be executing in this case it's just a printerland statement and I'm gonna type the number is in the range 1.7 now if you run this is only from here we get the time is seven because uh the first branch is checked and this branch is true and uh in effect it executes the code on the right and the next branches are left offs are not executed to and to change that let's put this first so let's copy this now if you run this code now get the number is in range one two ten and it's true our seven is in the range from 1 to 10. what you can do is also you can use the logical not operator so I can put here The Logical not operator which is an uh exclamation mark and this now will negate this value so if you run this code now you'll get the output 7. the time is seven so now we get the output the time is seven because this this switch is this value from True to false and execute this uh part now let's delete this what I can also do is that we can put curly braces so I can put curly braces press enter the same here and here also and it's recommended to use the calibrases only if you have multiple statements in your code in our case we have one one single statement which is this printerland which outputs some text to the console and the the when statement as I said can be used as an expression so I can type here a Val let's say your text and I can assign the when expression to our text variable now we need to give back a value to our text so instead of printing this text I can delete this let's put it like this now the last expression in our block of code which is now we have a single expression but you have multiple Expressions say that we have here another print Ln let's say some text so similar to our if then else expression the last line of code the last expression is going to be assigned to our variable text now let's print this down here torque console so let's type println and let's put director here text now if you run this code now I'm gonna see the text the number is in the range you want to 10 because it checks to see if this expression on the left is true then it executes the car the code inside the curly braces which is this expression and because now we're using the one as an expression it assigns this expression this text or variable text then it outputs that value with the print line down here in our console so you get the number is in the range one two 10. all right now but what if I want to put here a less than sign so you what if I want to put here if is less than seven our alarm argument I can do that the only way to do that is by uh let's delete this now let's put seven not here let's press Ctrl alt L to format the code all right now the only way to put a greater than sign or less than sine or greater than equal or greater or less than equal sign is to delete the argument here but let's first delete the curly braces to make things more clear so let's delete the curly braces let's delete this now because here we have two lines of course so we need to use curly braces this is why I deleted the penalion there and again you should always use curly braces if you have multiple lines of code but in our case we have a simple line of code which is the text on the right which is going to be assigned to our variable text and it's going to be output in the console so always use highly braces if you have multiple lines of code all right all right now this is more concise and more clear and let's say that I want to check to see if our alarm is less than say 10. um to do that we need to delete the argument here all right and now what can I do is I can put here our alarm variable and here I can put less than or equal to 10. so now here we have a Boolean expression on the left sorry so now we have a Boolean expression here on the left and this will check to see if our alarm or variable alarm alarm has a value Which is less than or equal to 10 which is true we have a 7 here so now if you run this call but let's delete this because we need to have now Boolean expression here because here we cannot uh here we have just literal types so here I need to put let's say if let's type alarm equals equals 8 or two vertical bars alarm equals equals seven so now if you run this code now you get the output the numbers in the range 1 to 10. because now this on the this expression on the left is true and it executes this text uh it assigns this expression to our variable text and it prints down here the that value so you get here the number is already one to ten but uh this condition is also true so if I swap those two so if I put this one below because as I said if one uh one of the expression evolution true the next ones the the one which are below so this in this case this one is true or not be are not going to be executed are skipped it only executes this code and the subsequent ones are omitted so let's put this below it's good to remember this so now if you run this code now get the time is seven because now this level is true even though this below is also true because our alarm is less than seven because this available is too true it executes the code which is on the right which is assigning this expression to our text and then it leaves the one expression it's not going uh down to execute the next one so it breaks uh like there and it stops it actually stops right there and it's not executing the next branch so this is our discussion about the when statement statement and the one expression see you in the next video now it's time to start a discussion about null ability in kotlin but first i'm going to create a new project I'm going to call it null make sure to have the language culturally select it and for the build system IntelliJ also make sure to have the jdk selected here and I'm gonna check this little box to generate the main function for us and that code that comes with the main function so I'm going to click on create to create a new project now our project is going to be great in a short moment so we got our project created and we get a log you get our main function Auto generated here for us because we check that box so I'm gonna delete this because I don't need this code and I'm going to hide the project pane so what is a null value a null value is basically when you assign to a variable nothing synthetically speaking you assign null to it but what that means is that you have a variable which has no value which has no memory reference and if you try to do some other arithmetic operation with that variable you're getting an impossible scenario where you have nothing try to do some work and that will throw a null pointer exception and this is particularly bad because the null pointer exceptions are only thrown at runtime and not at compile time so you could have your program working well and having no problems and at some point you try to I don't know press a button and somehow somehow that pressing of the button is using that variable which has another value and then it's going to throw an old normal pointer exception and your app will crash and kotlin aims to avoid the and to eliminate the null pointer exceptions and null values that is not to say that we can't have a null value in a kotlin but is very hard to have one so let's see why so what cotton has done to make null values and implicitlyn all pointerizations very hard to get it first made all its styles by default nonnullable and that means that you cannot assign null to it so if I declare here a variable called text I'm going to declare the type explicitly so it's going to be a string and if I assign null so to assign Alto where we'll just type the null and we have the null cured we can't because this variable by default and all the variables by default are nonnullable and that means that you cannot assign a value so if you hover over this underline it says null cannot be a value of a non null type string but what if I want to assign null to it what you if I want to have null for some reason in that case you go at the end of the type and you put question mark and that means that now you have a nullable type that means that you can assign null to this variable so if I put question mark here now I can assign null to this variable so this is how we can assign an altar variable by putting the question mark at the end of the type because that is saying to the compiler hey I'm gonna let I'm gonna let me to assign now to this variable so to avoid that underwriting red now if I try to print this so if I put here print line and I put here text what do you think we're getting the output and output to get null you know you don't get null pointer exception so now if I hide this and let's say that I want to get the length of let's say of the text so let's say that I assign here some text well actually let's put the name here name unless and if I try to get the length here so if I put here dot length I have an underline which says only save and we have this question mark that or not or asserted and have this this operator Cults are allowed on a nullable receiver of type string so it's saying that we can we can only get because you this this variable can have a null value but we know that it doesn't but the compiler is saying to us because we said that this can have null is saying to check first that this variable is not equal to null and then try to get its length and let's do that in the Long Way first so let's delete this so Alex actually just copy this and we type if we put parenthesis if text not equal to null then I'm gonna output this one we're then going to get its length so we're gonna type here text not the length so now that the compiler is happy because it's it's uh it's ensure that is not gonna have no because we checked here especially that this variable uh should have you should not have null in order to get the length so now if I run this I get four so this is the length so we have four letters here and I go I can also add the else part which is which is gonna say the very well it's not so if the variable is not the else part is going to be called so now if you run this will get also four but I'm gonna assign I'm gonna reassign this variable so I'm gonna change it to VAR first so we put here VAR and put here text equals null so now our variable is null and this check is going to fail and it's gonna execute the else part so if I run this code so we get the variable is null because now on the on the third line we assign nullity so this if fails and is executed there spot but as you can see it's a lot of code just to check to to check and imagine if you have multiple variables to check to always check for this that the variable is not normal then print its length and there is a shorter way in kotlin to do that and we saw as a suggestion how to do that previously so if I press Ctrl Z2 um undo our code so if I press still pressing now if I hover over this error that we had previously which says only save call so and you have this operator and this is called the safe call operator and if I put here just a question mark this is equivalent to having if which is checking to see if the length is null if and if the length is null then it's going to say null or and if it's not null it's gonna just output four so now if I run this so this is equivalent to the if that if the the if statement that you had previously so you have four so what if I should and if I assign null so if I type here let's change this to vardy First so if I assign here text equals null we'll simply get null we get null but what if I want to get that null pointer exception for whatever reason what can I do well the compiler or it helping is helping us also there so because if I delete that save call Operator which is just a question mark that and that is basically saying hey if this text is not null then output in the console then get then get the length and then output that in the console if it's null just say no so this is how the save call Operator works but if I delete this as you can see there is another operator and is and is this operator which is uh two exclamation marks and this operator is basically saying hey if this variable has null then throw that exception but if it's not null just output don't just output the length so if I put two exclamation marks here but for whatever reason it's not the our text that length is not getting the length and I think this this is because we assign to our text variable here null it it can't it has a prep it has a pro a problem with inferring what type this variable is even though here is saying that it's a string so we should we should be able to call that length and to avoid this you just put null at uh when you declare the variable so we assign here null so we put here null now if you run this because you have the two inflammation Mark operator now this will throw that null pointer accession that I talked about so we get exception thread main so it doesn't matter what trademark is now I'm gonna you get Javas like the null pointer exception so this is the the null pointer exception but if we assign down here this variable text equals some text and now if we run this code you get nine because this is the length of this so this is how you can use this operator the next operator that you can use is the Elvis operator and to show you how that works I'm going to delete this code now I'm going to declare another variable up here so I'm going to call it text two we put equals and we type text now to use the Elvis operator we put a question mark and the colon and now we need to uh type something on the right of the office operator so we put here some text I'm going to explain immediately how this works so I'm gonna type here some text now what the Elvis operator is doing is saying if this variable text is null then assign what is on the right to this variable text to if this variable text is not null then assign what is to this variable to our variable text to our variable text to and now let's uh let's type here text too and less the little length so now if you run this code let's actually put something more discrete like the variable null so if you run this code now we get a variable is null because it checked to see to to see if this variable on the left is null and if it is if it is now it's gonna it assigned this to to a variable takes two and then I'll put that in the console but if this is not null then it's gonna assign what is on this would what do whatever value this variable has to or variable takes two so if now I put here text equals this variable is not null now if I run this now this well this will evaluate to true so it's gonna assign whatever value is on the left or variable text to a variable text to and we're going to see in the output the variable is not null so we want a variable to X2 has now the value assigned from our for each variable so this is the shorter way of writing let me show you how we will write this in the longer way so you in the longer way you will have something like this so let's delete this quad actually yes let's delete this quad will have a variable called text tool and it's gonna have an empty string so we would what we will have to do without the Elvis operator we have to first check if text not equal to is not equal to null then I'm gonna call our variable a text to and we're gonna assign a text to it else we're going to assign to our text to variable the text this variable is null so this is the longer where we're doing of what we did previously so if I press Ctrl Delta format of code now if you run this you'll see the the same amount of the variable is not null so we get a variables not now and this is the longer way of doing the same thing so if I assign here if I assign actually if I delete this and the variable will have null let's press Ctrl Z if I run this foreign part is executed so our variable takes two it will be it will have the thesis variable this variable is null that takes assigned to it and then it's going to Output that in the console so this is the longer I was doing what was of what we had previously so if I press Ctrl Z to have the Elvis operator back so that was the longer way of doing what of what you're doing here in one simple line of code so this is our discussion about nullable types and uh I hope that you got a lot from this video and see you in the next video right now it's time to start a discussion about functions but first let's create a new project and I'm going to speed up the process now a little bit because we already did this a few times so I'm gonna call it functions should be in Pascal case select IntelliJ click on next and click finish all right let's delete the code inside the curly braces let's hide the project Pane and let's start by saying that until now we have written our code only inside the main function and occasionally we have called The Print line function to Output some code to the console but as I said at the beginning of our videos you can create your own functions in kotlin so let's see how we can do that so go down here at the end of our main function at the end of our enclosing curly brace and to declare the function we type the keyword fun we put space next we need to give a name to our function and the name of the function should say what the function is doing and generally it's a verb I'm going to call this function say hello and it should be in camera case next you put parenthesis because functions can take input to work with it and next you put curly braces because this is what we're going to put our instructions for our statements this is going to put our logic now let's add the print Elena statement here foreign and now let's run this code now as the input we don't see nothing here because if you hover this say hello function it says function say hello is never used because in order for that this in order for this function to be used you need to call it from main function and to call it from a function we type here the name of the function you can type it entirely you or you can type start typing you know IntelliJ is going to be it's going to give you some suggestions so press enter to fill and fill in that video and also press Ctrl alt L to format the code now let's run our code now you're gonna see that it says in the output hello because the main function executes in what's inside the curly braces and uh on the line two it sees that we have a function that we're calling here a function executes it executes the the say hello function the code inside the say hello function in this case it's a simple printl and a statement and then it outputs that to the console and it acts as the the code it finishes the process because you don't have anything else below for say hello but what we can do is put another say hello here to call our function again and now we're gonna see the output hello two times because now we're calling the say hello function first on the line two and second the line three so it will be executed two times so you can see that in this wave functions are reusable and are separate chunks of code okay which can be can be reused and you'll see that they can be used in specific cases now as I said functions can take input and to make a function to receive some input we need to Define what is called the parameter and to define a parameter we type the name of the variable first I'm going to call it name and we need to explicitly provide the type here so for the type I'm going to choose string and we need to explicitly provide a type here because is there there is no way for the type to be inferred here because uh the value that you're gonna pass to this say hello function is going to be here so it's impossible to know to what the kind of value are we going to pass to it so this is why you need to explicitly say what data this parameter or this variable is going to store so let's delete this second say hello now let's change the text that I have here in the println Let's uh let's refer the parameter name so put a dollar sign and start typing name and you can see that has this P4 parameter and press enter now what is going to happen now is that this say hello function is going to be called it's going to be executed from our main function and the code inside the say hello functions is also going to be executed and specifically it's going to execute this uh this uh text that we type here to be outputted it's going to execute the hello and then it is going to execute uh what what value if we have passed as an argument for this parameter and uh if you don't know what an argument is the argument is the value that you pass to the um to the function so in this case up here we need to pass some text so I'm going to put the name here not here it should be in a double rotation marks and you see that we have a hint here which says which is which says the name of the very of the name of the parameter which is name now what is going to happen now is this this say hello function is going to be called and this value that we passed here is going to be used in our println statement where where we're referring now which is uh here you here we're using the name and it's going to use that value and that value is going to be outputted down here and let's run the code to say now get Hello Alex because now it's using the value that you pass here as the as an argument to the parameter name and it's using that value down here where a we type the printerland statement or function now functions can take multiple arguments multiple arguments and to do that we need to Define I should say that you can Define more parameters for the function and a function contain multiple arguments and to Define another parameter we put the comma here and we type the name of our parameter is going to be age and we need to provide the type and I'm going to provide the type as anything yet because as an integer because it's going to store whole numbers and you're gonna put an exclamation mark and I'm going to type your age is now we need to refer the parameter age and also need to provide the value for that parameter now if you go up here now it says that you need to provide a value for the parameter has age it says no value pass from for the parameter a so here you need to type on a value for our parameter that we Define so let's say 22. all right now if you run this code now those parameters that we Define here are going to use the values the argument that we type here inside the our curly braces or how it's often called the body of the function or the code block so it's going to use the values here and here now another important thing to know is that you can not change the value of a parameter so if you type here age equals let's say 30. not gonna if you hover over here because you have an underline it says Val cannot be reassigned because those parameters are are declared as valves as variables false so that means that they are immutable we cannot change their values the only way to use the variable which can have is value changes to declare on so if you declare here a variable I'm going to declare it as a VAR to change this value I'm going to call it number and if I assigning healer value of 50 now I as you know you can change now his value to let's say 70. and you can also assign the parameter here to our variable number and now we can change its value because input number and can put another value here all right another important thing to know is that this variable that we Define here also the parameters are scoped inside the function say hello in other words they cannot be referred or accessed outside of the calibration of the say hello function so if I try to access that number variable here is not working if I try to access access here on the main function let's say type number I can because it's scoped inside the say hello function it exists only inside the say hello function the same thing with the parameters age or a name so in this way you can see that functions can be very useful because they are chunks of code which are reusable and flexible and to see an example with this let's declare another function down here let's call it the let's type the fun key or let's call it get data and this function is going to mimic the real function in a real app which can get some data from the internet of course that you're not going to get some other internet but we're gonna uh mimic that behavior so here I'm gonna Define a parameter let's call it data and for the type let's choose string right let's put the curly braces and here let's add the print Ln segments and here you're gonna print your data is and I'm gonna refer the parameter data all right now what I can do up here is to define a Boolean variable it's going to be a Val I'm going to call it has internet connection I'm going to assign a value of true to it now I can put an if statement here now I can check to see if that expression is true so I can put TV equals true or use the shortcut because it's better here I'm going to put the early braces and now I'm gonna call the get data function only if this condition is true so in our case it's true the but in a real lab that can be can be false so in that case you can do something else as you can assume we're gonna let's also other else part here and here we're gonna call another function which can which is going to be called in the case that there is no internet connection all right so above here you can personal logic to get the data from the internet well because this is a simple example gonna type here directly some text let's put some data and uh for the else part in the case that there is no internet connection that variable is false we can declare another function down here to oh and I'm going to call it fun show message and this is not gonna have any parameters it's gonna have only simple println statement and it's going to say that uh there is no internet connection all right so now let's go up here now and now we're gonna call the show message function in the else part now if you run this code you're gonna see Hello Alex which is our first function up here on the line tool your age is 22 and next to see your data is some data because it executes the say hello function then it declares this variable and it checks it checks to see if this condition is true and this condition is true and it executes this function get data so this is why you get your data is some data but if for whatever reason the user has no internet connection let's say you assign a value false to it to this now this function is going to be called show message so this function show message now is called and the code inside the show message function is called which is printerland with this sprinterland standard which says there is one technical connection area lab you can have some logic to show a dialogue that there is no internet connection and you can see that in this way with functions you can divide your code in different chunks of different different chunks of code which can be called in very specific cases so in this case we only call our functions only in in the case that we have internet connection or in the case that we don't have internet connection so in this way we have divided our code in different chunks of code which can be called in different uh specific scenarios and in this way we can write a program because if you just put your code all of your code in the main function and you execute that code from top to bottom you you cannot create a program like that so this was an additional discussion with the get data and show message and I hope that I'm not confused you a lot so see in the next video all right so in the last video we've seen how we can create functions how we can call our functions how we can Define parameters to our functions how can send the data to our function as arguments now it's time to see how we can return some data from a function but let's first read the code that we have here to make things more clear and the code inside the function the main function all right now let's Define another function I'm going to type the fan keyword space and it's going to be called get Max and this function is going to return the maximum of uh two integers so I'm gonna Define here a parameter I'm going to call it a in a real aperture those more descriptive names is going to be of type int and the next one is going to be called B and it's going to be also of type int I'm gonna put the curly braces and I'm going to press enter now to get the maximum value between these two numbers we type here we have here Val Max and here we type an if expression so we type if a greater than b then we're going to assign a to our Max variable else I'm going to sign B and in the case that the two numbers are equal B is going to be assigned to our Max variable now in order to return this uh to in order to return this value to our function we need first to to say to the function what kind of data is going to return and to do that go here at the enclosing parenthesis and if you don't have spaces here or you wondering about how to have the proper formatting you just press Ctrl alt L and the code is going to be formatted all right and here we put a colon and here we we Define why what type of data this function is going to return and in this case it's going to be an integer so we put in here and this is similar to The Way We declare a type for a variable now if you could if you go down here now you see that it says a return expression is required in a function to block body so now we need to return this uh now you need to return some data that we Define here in this case we need to return an integer and to return the maximum value to our function we type here return the keyword return and our value which is our variable Max and press enter now if you call this function in our main function get Max and now let's also press Ctrl alt L to format the code and here we let's say that we type two arguments for our parameters let's say that put five and nine now if you run this code now you're gonna see in the output nothing because uh in order to in order to get this value need to retain this value to capture this value in a variable and to do that we Define a variable in front of our get Max function it's also be a Val I'm going to call it Max and we're going to assign the get Max function to our variable and that is going to return or a maximum number now you now you may see that you have two names we have the same name here in the same and that is not a problem because this variable marks that we have inside the the get Max function exists on inside the the get Max function is scoped only here this is why you can use the same name here so if I try to type here also Max to declare variable which is going to be called Max I can't because it says completed declaration because if you because the compiler doesn't know if you assign a value let's say to this it will not know what variable to to to call because you have the same name but uh up here is not a problem because this is in the block of the main function so it exists only here and this exists only here now we have called our get Max function and this function is going to return the maximum of these two values which is nine now we need to print this value not console and to print this value just type here println and we're referring our Max variable now if you run this code you're gonna get nine because uh our get Max function is called the two the two arguments are passed to our function then the code inside the auto get Max function it's executed it Compares these two two numbers and if a is greater than b then it assigns eight or Max a Max variable or it's gonna if that is not true is going to assign the value of B and then it returns that max value to the to the function which is called so if this function returns that value here and and here we retain we capture that value which is returned from the get Max function our Max variable and then we print that Max variable with our println function or a statement and then we see the output in our console 9 right another important thing to know is that after we type the return call or the return keyword the the function is lift the function is stopped there so if we add the other text here let's say we add here a printerland and we type here some text we see that this is highlighted and it says that is this is a reachable code because after we typed our return marks our function is stopped is lived and it's not executing any any code below of of that return color or of that return keyword right another important thing that you can do with the return keyword is that you can return from a function without returning any kind of value and in that case it will have the same effect and that means that it will leave the function right there even though we don't return any kind of value so we I can type here return but let's uh the list here the type because now it's expecting a value to be returned and now this will have the same effect it will leave the function right there and it will not execute any any kind any line of code below of our return keyword so if I type here a println statement and I put some text here as you can see this has the same effect if you type the return keyword in your function it will stop the execution of the function and every line of code below of the return keyword is not going to be executed so it's very good to know this also another important thing to know is that you can we can only return a single value with the return keyword so we cannot return here to two integers let's say and also we cannot have two returns in the same function let's say if I put here also return marks I can't because this is also a reachable code but I I can have two returns two returns calls if they are rich in different branches so if I change this if expression to an if statement so if I type something like this if let's say a greater than b let's add the curly brace now we type here return a else return B so now we have two returns but they are never reached together they are they are always reached separately so this is why you can use here two returns because they said they are rich always separately so if you run this code you're gonna see the same output so you C9 so this is another way to to write the same thing that we had previously that but it's recommended to use a to use uh what we had previously because with uh specifically it's better to have enough expression another way to to write to the same thing but in a more concise way and let's undo the code that we have that you had previously so let's press Ctrl Z so now I have the code that help briefly now if you hover over over this Max it says variable use only in formatting return can be in line so if you click here in line variable now this thing does the same thing that it it was doing previously but this is a shorter way to write the same thing so now it returns a if this condition is true otherwise else part the else part is called and it returns B so we have the same thing but written in a shorter way all right another way to write the same thing that we have here is by using what is called the single expression function and to do that we can remove the curly braces we can put our code up here you can remove the first curly brace and you can also remove the return keyword and here you put equals and this now does the same thing that the code the previous code that was doing but this is a more concise way and it's recommended to use this only if you know that you know you have in your function a single expression or in other words if you know that you have a single line of code and you can also remove the type here because the type can be being inferred and again only use this if you know that you have in your function a single line of code and in that case you can you can skip the return keyword but if you have multiple lines of code you should always use the curly braces and the return color the return keyword all right so this is our discussion about how we can return a value from a function all right so now let's continue a discussion about functions and now it's time to look at what is called function overloading and let's say that I want here to pass not to integer types but two doubles to be compared so let's say that type here 6.5 and 9.6 now this will not work because it's defined here explicit that the parameters are of type int so we cannot pass here double and a solution to this it may be to create another function the different name and to define the parameters as doubles but that does not make a lot of sense because we we are doing the exact same thing so does not make sense to create a new to create a function with a different name so what you can do instead is to let's change it back to integers is to duplicate this get Max function and do that you can press Ctrl D or command line on Mac some press I'm going to press Ctrl D here now what I can do is change the types of the variables so I can put here instead of integer I put double and here I can put also double let's add the space to make things more clear now if I pass here let's say your 5.6 and 9.7 now you see that we have an error so if you run this code all right so we get in the output 9.7 and this is called this uh is bigger than 0.5 or 6 but now it's using the second function which is the function which has the parameters as of type double and you can see that this function now which is using the parameters as integers is gray out because the compiler can figure out what function to use by the argument types we pass here so in this case we pass here doubles and it knows that it has to use this function which has the types which has the parameters Define as type of double right another way to overload the function is to best also press Ctrl d is by changing the number of parameters so I can put here let's say also integer also releases so let's pass another the third parameter now and this is also going to be an integer it's going to be called C gonna be of typing all right now let's change this logic to any statement so let's delete the if expression let's put the curly braces all right so let's change this now so you can type it here now if a greater than equal to be and a is greater than equal to to C then I'm going to return a so now we're using the return keyword else if now putting here an lcf B is greater than equal to a and B is greater than equal to C then return B else C is going to be the bigger value so put here return C all right let's press Ctrl alt return B here right so I need to put here the type this will get that error right now everything is okay oh so from here is the problem all right so now if you run this code let's change this to let's say five seven and 10. now if you run this code you see that the two functions above our big gray out and I was going to use the third one which has third parameters all right so when you get to get in the output 10 which is correct so if you change this to test let's say if we put here 100 let's put here three and if you run this code now we get 100 and this is correct all right so this is our discussion about function overloading and you can use function overloading every time you know that you will do the same task but with different type of parameters or with a different number of parameters also you may have noticed that we have another line over uh over if over the statement so if you hover over here says that the return can be lifted out if so if you click this you can write it in this way so or we can keep it in the previous way but because this is uh underline that means that kotlin recommends to use it in this way in this way so see you in the next video what we're going to talk about default parameters all right so now it's time to look at another features that you can use with functions and that is called default parameters and let's first declare a function so I'm going to declare it down here at the end of our enclosing curly brace for main fun I'm going to call it send message let's put the parenthesis and inside the parenthesis I'm going to Define two parameters the first is going to be called name it's going to be of type string and this second one is going to be called the message and it's going to be also of type string now let's uh you take the cloud the curly braces press enter and let's print those parameters in our console so let's put the printer line here and inside the also uh while I'm typing while I'm pumping this printable anime since that this println function is a function which is overload referring to our previous video because you can see that it can it has the same name but it can take different types of parameters here so it has in this thing which is any bytes or Char long so the print element 5 function that you've used throughout our videos is overloaded this is why you can pass different uh different types of of data to it now let's type here println quotation marks inside the quotation mark we're going to type name equals dollar sign name so now it's going to print the argument values that are going to pass to this function as parameters now let's call this function here so let's type send message to format our code and here I'm going to pass a name let's say Alexa and the message let's say hello now if you run this code you're going to see in the output um the name here is going to be this argument that we type here which is Alexa and the message is gonna be hello so we have this but let's say that for whatever reason the user doesn't want to to send any kind of message but we still need to use this function what you can do then one way is to remove this parameter all the way but uh that is not the good because you still need to use this function with those two parameters the name and and the message so you know let's say that if the user doesn't pass any message we can Define here what is called the default param a default parameter so what you can assign here a default value for our parameter so I'm going to put here uh just the double quotation marks or or you can put some text here but let's put just the double quotation marks which is just an empty text so if now I don't pass a message here now we're still gonna work because as a value for this parameter is going to use the default value that we defined here all right so let's run this code to see now how it works so now get name Alexa and message equals empty because m double quotation marks without any text is an empty text now if I want to pass here now the message now you can pass here the message and now our default value is going to be replaced with the argument value that we typed here so now I'm going to see name Alexa message hello all right you can do the same thing for uh for the name so here you can Define let's say that the user doesn't want to to type a name and we can define a default name let's say user yes now let's say that I delete both arguments here and I just have an empty function if I run this now it's going to use the default values that you type here respectively user and this empty string so now get name user and message now let's put back what we have so let's put here Alexa let's put our message here again now let's run this code again now what we can also do is use what is called named parameters and let's say that I want to to pass a parameter only for the second second let's let's say that I want to pass the argument type for only for the second parameter that we Define here respectively for our message so if I delete this now I'll say let's say that I delete the the argument for our name and if I want to pass the value only for the message let's put in the quotation mark because the string let's say I put the message hello here now you can see that the hint is named so it's using the first parameter that we Define here another second so what we can do now to pass a value to only to our second parameter because as you can see it's using the it's assigning this value that we type here for this parameter and to solve that you can use what is called the name parameters so with name parameters you can type an argument for our parameter irrespective of the order in which they are defined so in our case we have the name for Define and then the message so to use that you can type the name of the parameter let's say message now you see that you have this P message and it's equals to A String so that means that you need to pass some text here and now we can pass here hello and now this is gonna work because now we can pass a value to our parameter irrespective of the water in which they are defined here right so now I get name is this default user and the message is hello and we can do the same for uh for the second one which is name so I can put now here name and I can type here let's say Alexa and if you run this now get Alexa is the name and the message is hello so with the named parameters this is how they are called a name arguments we can pass the value to our parameters irrespective of the order in which they are defined in the function so in our case name is first defined and you saw that that when I try to use a the message to assign a value only for the message it's what it was using the first parameter because this was the word in which they were defined but with this named parameters you can change you can you can type an argument irrespective of the word in which they are defined and you can put this in a multiple lines to make it more clear like this let's say so this is our discussion about named parameters and the default parameters but before we win the video I should say that to the default parameters we cannot only type literals values like we typed here some values directly we can use variables or you can use a function which can return a value so I can Define here a function let's say fun send the text it's not going to have any parameters it's gonna return a string so I'm going to Define here a string as the type of return and here gonna type return and let's type some text now we can call this function here send text and now this value which is returned for this function send text is going to be assigned to our parameter message so now if you run this code Let's uh increase this a little bit so now if you run this code you're going to see that the Now the default value for the part method message is the return value from our send text function so you can see now that we have okay so let's change it here to no value for our message so now if you run this code because there we have an argument passed so let's not passing on the northwest so now it's using the value that we was was passed as the default value for our parameter which is this return value from this function now because here you have one single line of code we have one single expression we just return some text or function we don't have multiple statements in our function we can write this as a single expression function and you can remove the calibration you can write this as a single expression body like we did in a previous video so you can put it just equals and you can remove the type here also so if you run this code now I'm gonna see it to the output for the parameter message some text which is the value which is returned from this function from the single body expression function right so see in the next video all right now it's time to look at the VAR Arc keyword and how we can use the water keyword with functions but first let's declare the function below of our enclosing calibrase of our main function so I'm going to type here the fun keyword to declare a function I'm going to call it sum because it's going to return the sum of all the parameter that we're going to Define so I'm going to Define here some parameters for it's going to be called a it's going to be of type int a single second is going to be called B also in third is going to be called C also an end the final one is going to be called the alternate and this this function is going to return the sum of all of those parameters so we need to Define here the return type which is going to be an hint a whole number and now we can put the curly braces and here we type return a plus b plus c Plus d and this is going to return the sum of all the parameters that we Define here or the values that is going to be passed as arguments to this function and you can write this as a single expression function if you want so you can write this uh like this if you want this will have the same effect but I will I will write it with the curly braces because it will make things more clear so let's undo this right now let's call this function here sum let's press Ctrl alt L to format the code and let's pass some values here so I'm going to type here five six seven and 10. all right if you press shift Ctrl p on this you're gonna see that the type of this function let's press again the type of this function is an ins so this function returns an integer so it's it's an expression that means that we can put this instead of putting storing um uh the return value in a variable we can put this direction a printerland function so you can type here print area and we can put the function inside here because that function is of type in so it's going to return the sum of all the arguments that we type there so now if you run this code we got we get 28 because 5 plus 6 Plus 7.10 is 28. now if I want to pass another parameter here let's say that I want to pass another number here I can't because I am limited by the number of parameters that we Define here of course that I can Define another parameter here but what if I want to pass 10 numbers for 15 numbers or 100 numbers in that case it will be very tedious to write all of those parameters and and to solve that you need to use what is called a varg varag keyword and Avada keyword allows us to pass more than one parameter actually more than one argument to our parameters so to declare a Vari keyword we type here we type here far ARG so this is the keyword varag it stands for variable arguments now we need to define a name for this bar Arc I'm going to call it numbers and we also need to specify a type what kind of values this varag is going to store now this return keyword is this variables here are red because they don't exist now if I want to but first let's say that I want to type here another parameter now now you see that we have no problem so I can type here whatever number of numbers I want and there is no problem as you can see now to to sum the values which are stored in these viral numbers we need to use something which we didn't cover yet but we have a separate section which I show you how to we need to explain this thing that I'm going to use now and that is Loops because now we need to Loop through our numbers and to add our numbers to a variable so we need to use what is called a for Loop so to do that first we declare a variable I'm gonna call it um let's say uh result I'm gonna assign a value of zero now to use a for Loop we Type 4 and again I'm gonna go into more detail about this in uh the separate section but now we need to use this because there's not another way to to sum up the values inside the varag numbers and here we need to define a name for our variable so it's going to be called number and now we use the keyword in and now we're referring the parameter the varag parameter which is defined up called numbers all right now we here you can put the curly braces and inside the cutter blazes we're going to type numbers result and now we're going to use that abbreviation which is plus n equals plus equals number n now here gonna return the result return result all right so let's explain what we have here so first we declare a variable we assign a value of 0 to it so it's just type int next what this for Loop is doing so this for Loop is doing what is doing is executing um a line of code multiple times so it executing is executing uh uh what's inside the curly braces until the it finishes to it finishes the to Loop through all these numbers which are stored in the varark number so it first assigns uh the first the first number or number here and it loops and it has that it adds that number to a result then it does that again and again and again until it finishes so then it reaches uh the final number five and in that case also gonna sign from our numbers uh the number five to our number and then that number is going to be added to our result variable and when it finishes uh that looping when it finishes that thing is gonna return the result it's gonna return all the values which are which were been added to our result variable so now if you print this now I get 85 and probably this is the result of this calculation so this is how you can use varag numbers what are the keyword to store more than one single more than a limited number of parameters defined bio and another short shortcut to to Loop through this is using a for each Loop so we can do something like this but this time let's say that I want I don't want to return something so let's see that I delete this and I I can type here actually numbers four dot here to put that four each and here we type print Ln again this is a more complex subject which is going to be covered in the next videos so here we type print Ln and we type it all right now let's uh let's call our sum let's define some numbers here let's say that I type here one four all right so if you run this code now you can see that every number in that that we defined here is printed one by one so this number this for each which is also a loop it goes through all of these numbers it and it prints them one by one and again we're gonna look at uh for the for Loop and the four each in the next videos but I had no other way to show you this example without using them but if you feel confused by for the for each or the for Loop don't worry we have a separate section which in which you talk about in detail about this for now we need to only the only thing you need to know is that you can pass an indefinite number of parameters of actually you can pass it an indefinite number of arguments to our varag numbers because this allows us to to power to to pass uh an indefinite number of values so here you see that we have one four five six seven eight nine five seven and six numbers that we have here so this for each is going through all of them and it prints them one by one so see you in the next video all right now it's time to start our discussion about loops but first let's create a new project I'm going to call it loops select IntelliJ click on next and finish right a project is created let's delete the code inside the color braces let's hide the project pane and let's start by explaining what Loops are and why you need to use them so Loops allows us to execute a piece of code multiple times without you writing down every line of code manually so let's say that I want to print 10 numbers in the console or 20 or 50. instead of printing instead of typing that code manually move line by line which will be very tedious you can use a loop and you can put that code in a loop and in that code in the loop it will be executed repeatedly until a certain number is reached so let's see how we can define a loop to define a loop we type here four this is the first Loop that we're gonna look at because there are other loops so this is the for Loop we press enter inside the parenthesis we type I this is convention you can put whatever name you wonder now we put here in this is the keyword in and now let's say that I want to loop from one and from 1 to 10 and to do that to type 1 dot dot this is a range one to ten now I put a curly braces and inside the pre the curly braces and I'm gonna put the code that I want to be executed 10 times so I'm gonna type here println and I'm gonna type the value of I at each iteration and uh we can put it like this you can type here uh you can put in the quotation marks and you can do the placeholder you can put I so now if you run this so now I get is one two until 10. so it what is doing is is looping through this range until it reaches 10 then it stops now uh you can write this I like I did here using a placeholder where you can write it like this I've run this code it will have the same effect but will not have the taste before here so now you get one until 10. now there are other other very variations to use this range and one of them is to use until so let's uh command this code so let's press Ctrl slash right now let's type 4 again and now I'm gonna I'm gonna call it also I here you can put whatever name you want and instead of now I'm going to put also again the in keyword and instead of putting the dot dot to Loop to arrange I'm gonna put one until 10. all right now I'm gonna add the printerliner statement and here I'm going to type I and this will have the same effect with the thing with a single difference that 1 until 10 is is gonna exclude ten and one uh using the range.10 it will include 10. so if you run this code we're gonna see that you will not have 10 here because 10 it is excluded when you're using the until so now as you can see we have one until nine and then it's excluded because now we're using the until so if you if you're using the range which is uh dot the last number is going to be included but if you use the until the last number is going to be excluded so it's important to know that this two respectively the until and the range can only count upwards so we cannot put here 10 until 1 because the first number the number of on the left needs to be smaller than the number on the right so we cannot put 10 until 1. we can only count upwards you can only put one until 10 or 1.10 so to Loop backwards we need to use another thing so let's comment this code also now to Loop backwards we Type 4 again in the paradise you put the I here you can put whatever if you want in so here you can put whatever name but the convention is I issues now I'm going to put in and now I'm going to put down first let's put uh 10 down down to one let's add the curly braces the printerland and let's put I here now this is gonna this is gonna count downwards now it's gonna it's gonna count from ten to one so if you run this code now get 10 9 so it's counting it's it's counting backwards right another thing that you can do is that you can introduce an arbitrary step so let's uh let's comment this code also let's add below another call another for Loop so here I'm gonna type four parenthesis let's put I and let's use uh done TL so in one until 10. so now I can put a an arbitrary step so at uh at this arbitrary step that number which is that is that is at dotted arbitrary step is going to be skip so I can put here step to let's say so now I'm gonna put the quarter Blazers to have the some code executed I'm going to put println and let's put here I so now if you run the squad I get one three five seven and nine so you can see that uh at the second iteration the number is Skip so we have one two is skipped now we have then we have three four three and four skips and so on so you can put this arbitrary step if you want so let's comment this code also and let's add the first code that we had here to to talk a little bit more so let's put I in one let's put the range Dot 10. and curly braces you're gonna type println hi now if run this code we'll get the same output that as at the beginning of the video so get one until 10 inclusive now again what this uh loop is doing is going through this is going to this to this range from 1 to 10 and it's executing the code inside the curly braces 10 times and when it reaches 10 it stops and it executes the next line of code below here that because here we don't have any line of code our program X is exited and is finished so this is our discussion about for Loop there are other Loops which can Loop which can loop as long as a certain condition is true not as long as a certain number is reached so we're going to look at the next Loops in the next video see you next all right now it's time to look at the next two Loops that you can use in quadrant and those are the while and the Dual Loop but first let's open our previous project called Loops because I'm going to type my code there so open your previous project and here I already have deleted the code that we had previously here but if you have the code delete it and let's start our discussion about the while loop so first I'm going to type while this is this is how you declare the while loop and here you can press enter to fill in the the wallykid on the parenthesis for you or you can type manually the while and the parenthesis so I'm going to press enter to fill that for you fill in that for me and next you put a space and you put curly brace here so I'm going to put the left curly brace and press enter and the radical base is going to be added automatically as you can see on the line five now a while loop Loops as long as a certain condition is true in contrast to the for Loop which Loops for a specific number of time while a loop Loops as long as a condition or an expression is true so this gives us more flexibility in a circumstances or you don't know for what specific number of times we want our code to be repeated so we put our condition inside the parenthesis here and as long as this condition is true the code inside the current base is going to be executed repeatedly so let's see how we can do that so first let's discard a variable here I'm going to call it number and I'm going to sign a value of 0 to it and here I'm gonna type while number is less than 10 inside the calibration I'm going to type the println function and we're going to Output the value of our number and then we're going to increment the value of a number so I'm going to put number I'm going to use the increment operator plus plus let's put a space here to have things more clear now if you run this code you're going to see the numbers from 0 to 9. so what is happening how this works first with the color variable with a sine of value of 0 to it next we Loop using the while loop and first the while loop is checking to see if this condition inside the parenthesis is true so it checks to see if the value of our variable number is less than 10 and it's true because we have zero then it executes the code inside the curly braces and it outputs the value of our number in the console using the printerland function then it increments the value of our number and then it Loops again but now the value of our number is one so now it will compare again if the value for number is less than 10 which is true it will loop again it will output its value it will increment this value so now we have two and so on until it reaches nine when it reaches 9 it will increment the value it will it will print it will output the value in the console it will increment this value then it will check again to see if this condition is true but now the value is going to be 10 because not it was incremented when it was nine and this condition is going to be ever it's going to evaluate to false and the code inside the cutter base is not going to be executed this way we don't have 10 here and it executes the code that comes below of our while loop but because you don't have any code the program is terminated and you can write this thing in one single line but it's recommended to use this form only if you know that you have one single statement in our Loop so if I can delete this this tool and I can put here directly number plus plus and because this Returns the value it increments the value and it Returns the values and expression I can I can run this code and it will have the same output but if I delete the increment operator out after the variable and if I put it before now I'm gonna see a different output here because this increments the value of of our number then it decrements the value of our number and this is called prefix in increment increment so this is called prefix incrementing and the the previous one let's press Ctrl G this is called postfix increment so this is postfix because it's the end of our variable and uh if you put the incremental operator at the beginning of our variable is called prefix oh increment anyway let's press Ctrl Z to have the code that I had previously and the curly braces now look what happens if I delete the increment if I don't increment all variable now now uh let's just talk what is happening because we don't increment the variable and the variable always has the value of zero this will always be true and it will execute the code inside the current places forever so we'll have what is called an infinite Loop so if you run this code now you can see that it prints 0 forever because this condition never ever has to to to false so let's stop this by pressing on this uh Red Square so now the process the program is terminated so this is why you need to increment the value of our number because we want that condition to be false at some point in the in the in the in the future next let's say that I assign here 10. so if I run this code now this condition is going to be false because 10 is not less than 10. and the code inside the curly brace is not going to be executive so now we have no output here because this condition is evaluates to false and is not executing the code inside the calibration but there are certain situations where you'll want to have your code executed at least once even though the initial condition the initial uh condition or there is expression is false so if I delete the curly braces and the code inside the curly braces here now to to do what I said if to execute the the code even though the condition is initially set to false to execute the code at least once you need to use a do while loop and to use a do while loop you put here at do press enter to add the calibrases and we put our while at the end of of our enclosing curly brace of Urdu and here inside the calibration or I'm going to put our printerland function and I'm gonna output the value of our variable number so now if you run this now get 10 because this executes the code inside the curly braces until at least once and after that it comes down here and it checks to see if this condition is true or false and if this condition is true it will repeat the code but if the condition is false it uh it will not repeat the code but the important aspect here is that it will execute the code inside the curly braces at least once irrespective of our condition if the condition is true of order false in our case is false so these are the three Loops that you can use in a kotlin the for Loop the while loop and the do while loop now it's time to see how we can use the continue and the break keywords with those Loops so let's press Ctrl Z to undo the code have the while loop back because I'm going to start the while loop and to see how we can use the but you can continue cured with the while loop let's bring this up a little bit so let's first look at the continue keyword and the continue keyword can be used to bypass a section of code so let's say that I want to skip the number seven in our Loop so I can type here if our variable number equals 2 so 2 equals seven let's put curly braces press enter toward the right calibrase continue so now what this is gonna do is when it is gonna reach the number seven and this condition is going to be true it's gonna call continue and it's going to bypass the code that comes below of our if statement so if you run this code look uh what happens it happens nothing because uh here our number has a value of 10 so this condition is false so the code is not executed so let's put here zero now if you run this code so we get 0 1 2 3 4 5 and 6 but uh and you see that I save at seven it uh it skips the code but why I don't have the next numbers this is because uh unintentionally we created here an infinite look so let's stop this and uh to explain so what happens here is that because um we said we say here explicit to you to check here explicit we check here to see if our number is equal to seven then we're gonna continue and in other words you're gonna skip the code which comes below of our of order is the then statement then this code is never called so this code is never called the printerland and more importantly the increment operator is now never called on our number variable and because of that because our variable is not incremented here either when it's gonna loop again it will have again the value 7. so this condition or the in the if is going to evaluate again to true and it's going to call continue again and because this code again is never reached Discord and the values no not not incremented it will still have the value seven so this is gonna evaluate again to true so it does this forever and to change that we need to put our number and which is incremented before our reef and that is going to solve the problem so now if I Let's uh now if I run the code let's increase this now get one two three four five and seven is skipped then 8 9 and 10. because now when this condition level is to true it will continue it's not going to print the code it's not going to be executed below of our if and it will come back to Loop and now it's going to increment the value and the value is going to be 8 instead of 7 this is going to evaluate to false and the continue is not going to be called it will print the number eight and it will do the same for it it will increment the value again and then we'll have 9 and so on so this is how you can use the continue keyword and you have to be careful where you put your in uh your whatever incremental variable because I you saw you can easily get intro infinite Loop now you can have a more complex expression here so you can put here if number is greater than let's say 2 and number is less than eight now if you run this look what happens now get one two and then we get 8 9 and 10 because what this condition now checks is is if our number is greater than 10 and less than 8 then continue then skip that number so this is why the numbers between 2 and 8 are skipped because we call continue on on them and if you hover over here you see that it says the two comparison should be converted to a rain check so you can write the same condition that have here using a range but this is different from a range that you you've used in a for Loop in the sense that this is now checking to see if our number is in the range 3 from 3 to 7 so if you run the squad now I have the exact same output but now we are using the range to check to see if our number is in the other engine if this is the underage we call continue to skip that um the next thing that you can do is you can break the loop you can stop the loop using the break here so I can say here again if number equals equals let's say seven call break so I'm going to type here break now when this condition is going to vary to true it's gonna call break and the loop is going to stop it's not going to execute any line of code after that it's gonna stop it's gonna leave and it's going to execute the code which comes below here but in our case we don't don't have any code so you see that we have one two three four five and six and when it reaches seven it breaks and it nuts is stopping the loop it's not printing the value and it executes the loop so it terminates so foreign and we can do the same thing with the for Loop so we can use the four we can use the continue and and break with a for Loop so you can type here four let's say I in let's create the let's say zero to 10 let's create this range let's add the curly braces now I can say here if I in let's say three to eight then continue let's put in the volume let's type here println let's print the value of I here so now if you run this code so we have our first Loop which Loops a to six and then it breaks because you call break there then it's using the for Loop it Loops it loops from 0 to 10 but because here we're checking to see if our number is in the range three to eight and skip it you get 0 1 2 and then the numbers uh the three and uh the numbers between the three and the numbers between 3 and 8 inclusive are skipped here so we have 0 1 2 and then the numbers between two and nine are skipped and we have nine and ten and we can use also the brake keyword with the four I can put here if I equals equals seven break so now if you run this code now you get 0 1 2 3 4 5 6 and when it reaches seven it breaks similar to our while loop so this is how you can use the break and continue cured with the while and for Loop and you can use the brake and continue cured also with the Dual Loop next we're gonna look at how you can Nest Loops within each others and we're going to look at an example using the while loop so I'm going to delete the code of the for Loop and the printable statement there I'm going to delete the if then statement the break yard and I'm going to bring the printerland function up there down here I'm going to declare a variable it's going to be a VAR I'm going to call it I and I'm gonna assign a value of 0 to it now in inside the while loop I'm going to type another while loop here I'm going to put a conditional while I is less than 5 we're gonna increment I and we're gonna print and output the value of I in the console but let's put some text here to make uh clear what Loops what Loop is looping so I'm going to put three asterisk signs here I'm gonna type the dollar sign and I so now if you run this code let's also change this condition too less than five so if you run this code now we get first you get one then we get our code inside of our inner while loop which is the three asterisks and get one two three four five then it Loops again but let's take this chord line by line to explain what is happening here so first decade is variable call number assign a value of zero to it then we Loop using the while loop the outer loop and it checks to see this condition issue and is true zero is less than five so it executes the code inside the curly braces and it increments the value of a number by one then it outputs the value of our number in the console so you get here one then it declared this variable called I and then it starts looping inside our outer loop while using the inner loop while so it Loops here five times so when it finishes it goes back and now the value was incremented by one it will check again if the condition is true it will uh execute the code inside the calibration to increment the value now so the it will have two it will output that value so now we have two here and then it will loop again five star five times using the inner loop and it will do the same thing for the next round and the next round until you get to 5. when we'll get to five five will be not be less than five and this condition will evaluate to to false and the code inside the caliber is not going to be executed right and you can use the break keyword inside the inner loop so I can say here if you can put it above here so you can say if I equals equals zero then break and now you can put the break and continue cures in one single line if you want you can avoid the curly braces so now if you run this code now get one two three four five because now uh when it reaches the inner loop it breaks immediately what every at every iteration in the outer loop so when it comes down here it will check to see if the conditions through is going to be true but when it gets to the if statement it will break it will stop the loop so it will execute only the Outer Loop and with a break keyword you can not not Target only the loop so with with this break keyword we stop you stop only this while loop that uh that we are currently that is currently the nearest Loop but there is something which which is called labels and with labels you can Target an outer loop so it can break the outer loop here so you can break the while loop which is here and to do that we we give to our while loop a label so we type here a name I'm going to call it outer and we put at now here you can put break and now I'm gonna type add and you put outer and this this should be a single word now if you run this look what happens now get one because it breaks the outer loop so it first evolves this condition it increments the value of our number it prints the value of a number and then it goes in the Inner Loop it checks to see if this condition is true it's true then it's checked to see if I is equal to 0 which is uh true then it breaks but now it's not breaking this Loop this inner loop it's breaking the Outer Loop so it's breaking this Loop so this is why you get only one and the code is not executed because it breaks the outer loop and the code our program or code it's terminated because about down here we don't have any code so this is how you can use labels with the break keyboard to Target an outer loop and the labels can be used also with the continue keyword and in other Loops that we've looked at so this is our discussion about loops what you can do I should say is that you cannot Target with the labels and inner loop from an outer loop so you cannot we can give here a name to a label to our inner loop but you cannot Target our inner from our outer loop so this is our discussion about loops and the next video we're going to do a challenge all right so now it's time to do a challenge using all the knowledge that we have accumulated so far and I'm gonna use the previous project to put my code there but if you don't have the previous project you can create a new project and give it whatever name you want and type your code there so I'm going to open my previous project I'm going to delete the code inside the main function now what is the challenge the challenge is to create an arbitrary range of numbers then we need to find a way to go to that arbitrary range of numbers and to determine if a number is an even number or if a number is another number and based on that if the number is an odd number skip that number but if the number is an even number then output a number in the console additionally should create a way to count all the even numbers that you found in your range and display the total number so if neither numbers um at the end of your program so try to do this solution and after that you can watch my solution to this so first I'm going to decide I'm going to declare a variable call number I'm going to assign a value of 1 to it next I'm going to declare another variable but this is going to be a Val it's going to be called last number and it's going to have a value of 20. now I'm gonna Loop using the while loop and in the parantes you're going to type while number is less than equal to last number then you're going to put curly braces now I'm going to increment our number now here you need to add the logic to determine if a number is an even number or not and to do that I'm going to add the function at the end of our enclosing curly brace of our many functions so I'm going to type here the fun keyword now you need to give a name to our function it's going to be called is even number I'm gonna put parenthesis and it's going to take a parameter called number of type int this function and it's gonna return a Boolean value true or false this function so you put colon and we type Boolean then you put curly braces and now we'll add the logic to determine if any number is even or not so you type here if and now inside the parenthesis we put another set of parentheses and here we refer our parameter number that we have defined above and here we put the modulus operator because the modulus operator gives us the reminder of a division so we put a modulus operator 2. now outside our inner parenthesis we put equals equals zero then we put curly braces and return true else we're gonna return false now how this logic works so our num our number parameter which is defined here it's going to take an argument let's say that it's going to take an arbitrary number then he's gonna check to see if that number divided by 2 has no reminder if it's and if it has no reminder then that number is an even number because the because even numbers when they are divided by two they have no reminder and if that is the case if the reminder equals equals to zero our number is an even number and it's gonna return true and their spot is not going to be executed now let's add the logic here list user function here because as you can see now it's uh gray out it's not used so let's type here if and in the parenthesis you're gonna type is even number our functions we're going to call our function here and we're going to pass a parameter to it called now I'm going to pass the parameter we're going to pass an argument and the argument is going to be the variable that we Define above as you can see you have the V there so press enter to fill on that for you let's press Ctrl alt L to format the code now if we press shift Ctrl p on this you're going to see that this is a Boolean expression because this returns true or false so we can put the logical not operator in front of it to change its value to switch his value from True to false and from and from false to true so let's put curly braces and here we're gonna call our continue quick keyword down here I'm gonna add a printerland which is going to Output the the number in our console next we need to add the logic to to count the total uh the total even numbers which are found so I'm gonna declare a VAR it's going to be even numbers counter and I'm going to assign a value 0 to it and here we're gonna increment our even numbers counter so now if you run this code we get 2 4 6 8 10 12 14 16 18 and 20. so these are the even numbers that they are that they found that the our program found in is correct but let's add a print line at the end of our Loop to print the total number of numbers of even numbers found so let's put println here and let's put let's refer our even numbers count here you have a numbers counter so if you run this let's put some text actually let's put this in curly braces so let's type here total number of even numbers found equals dollar sign now if you run this now you get total numbers of you know when even numbers found this 10 and this is correct so in an output correctly or even numbers and it show that the total number two newer numbers found this 10. so let's now think about how this logic works here so let's look at the if statement that we have here so what is doing in this thing here so let's take an um an um specific example a specific number to store to see how this works so let's see that here we pass four and it's gonna use the logic to determine if this number is an even number and if that number is any of a number is going to return true so this this function which is a Boolean expression is going to return true and then we're gonna negate this value gonna change this value from True to false and continuously not gonna be called and the code which comes below which is uh our variable which uh counts how many even numbers uh we have then it it increments then it outputs that number in the console so we have our even number four output output it in the console but if you pass here 3 that the number is not going to be an even number because has a reminder and this is going to return uh false and because of here you put the logical not operator that is going to be switched to true and the continue that's going to continue keyword is going to be called and our code Channel which comes below here which is uh our variable even number counter is not going to be incremented and our number respect to our number three now it's not going to be outputted in the console so this is how this works so this is our solution to our to our challenge of course you can simplify this so if you hover over here because you have all of those underlines you can see that says remove redundancy if statement so this can be simplified to this this does the exact same thing it is going to return true if this uh divided by 2 has no reminder otherwise it's going to return false and this can can be simplified even further because if here we have a single expression and we know when we have a single expression we can write our function as a single expression function so I can remove the curly braces here you can remove the bully return type you can remove the return keyword I'm gonna put the equal zero and this now if you run this code this will work the same so we have the same output here now I use the function here because we've talked about functions in our previous videos but you can remove the function completely and add the logic to determine if a new number is even or not directly in the if statement so you can put here if let's put parenthesis our number now we're going to use the modulus operator tool not equal to zero then continue and this will have the same effect so if you run this code this will work in the same way so we have the same code here because this does the exact that the function did previously it will check to see if this is a new number if this is any of a number the this is not going to be true because hero checking to see if this is not equal to zero and our number is equal to zero so this condition inside the parenthesis is going to be false the continue is not going to be called and the our code below is going to be called our even number counter is going to be incremented and our number is going to be output in the console so this does the same thing as previously and we can do this challenge also in the first of the four Loop if you want so you can type here four I in one to 20 then execute the code inside the curly braces and here you can check if parenthesis again if I present 2 not equal to zero then call continue then else is gonna execute the code which comes below here which is let's first assign a value for your to a even number counter to zero because where when we're gonna enter in the for Loop we should have a zero to not have the previous value which was 20. so let's put 0 here and here you can increment or even number counter plus plus and we're gonna print our even number so I'm going to print I here so if you run this code let's run it from here but let's add the printerland to make things more clear so I'm going to add here print let's put quotation marks and here I'm gonna type total number phone using four Loop r let's put the dollar sign now let's refer our even number variable now if you run this now I have the exact same output but now we're using the first you're using the while loop then you're using the photo clip so let's let's add the printerline statement between our Loops to make clear which Loop is looping so let's draw the print line here and let's type here now we so we are looping using the four Loop so now if you run this to make more clear which Loop is looping so now as you can see first the while loop Loops then we have our printerland which says that now our while loop our for Loop starts looping then we loop with the for Loop then at the end we output the total number total number of even only fever numbers found with the while loop we have 10 then we output the total number found the total number of even numbers found using the for Loop and r10 so our code works perfectly well and uh this do not does not represent the the best the best way to solve this challenge of course that you can find a totally different way a better way to solve this so this was my this was just my way of solving the problem so see you in the next video and how I hope that you enjoy this challenge so now it's time to start a discussion about the race but first let's create a new project I'm going to call it a race for the language select kotlin for the build system IntelliJ make sure to have the jdk selected and check this little box at sample code to have the main function Auto generator for us and click on create all right now let's delete the code inside the calibrases of the main function let's hide the project Pane and let's start our discussion about arrays and so far in our videos we've only looked at how we can store only one single value in a variable and that is very useful but what if you have a large amount of values that you want to store in our variables let's say that you want to store 30 or 40 different values in our variable of a certain type of course that you can declare a variable for each of one of those values then and then assign it to the variables but what happens if you have a 1000 or 10 20 000 values in that case uh it will not be practically possible to write each one of those variables and then assign a value to it in a colon help us here because it provides us arrays and an array allows us to store more than one single element in a variable name so it allows us to store more more elements in one single variable name now to declare an array we type Val hero type names next we need to provide the type and the type is going to be an array and IntelliJ is giving us some suggestion there so press enter to fill it in that for you and now we put angle brackets and inside the angle brackets we're going to put what kind of data this array is going to store so it's going to store string or text or sequence of characters then you put equals and here we don't type political value here we have a hero type of function call and here we type array of and now we put our elements inside the the parenthesis of the function called separated by comma so I'm going to put three names here so I'm going to put John Steven and Megan now let's uh let's see what we have here so first we have the Val keyword next we have a name for our variable and the name is names then we have the type and the type is an array which means that you can store multiple values in our variable and next we have angle brackets and string and this means that this area is going to store text or a sequence of characters it's gonna store only strings and then you put equals we have the function called array of and then we put our elements of type string which is those names separated by comma but because cotton has Type inference here you can delete the type and the type is going to be inferred in the same way it was it was inferred previously when I when you just declare a simple variable so now the type is still inferred as an array of strings and now it's a good moment to introduce type hints but we need to activate the typings from settings and to do that you can go to file and click on settings or you can press the the shortcut that you have here for our particular system and for Windows is Ctrl alt s so I'm going to press Ctrl this and here we go to if you have something like this you go to editor click on this greater arrow in front of editor and then you go down here where it says what it says inline hints click on on this Creator are in front of inline hints and from those options select kotlin and here you go to types and select select local variable types then click apply and okay now what you have here on the right of our variable name is a hint so it's not real text this is just there to remind us what kind of type this variable has and in our case is an array of string and my suggestion for this to keep those scenes activated because in this way you'll always see what type of variable is without explicitly declaring the type so this is not uh this is this is just there to help us to remind us what kind of type a variable is now let's say that I want to Output a certain element in the array in the console to do that we cannot just type here println and pass names because you need more to be more specific than that we cannot pass the array here and to get a specific element in the array you need to know that the elements in the array are stored at indexes and the index of an array always starts at zero so the first element is stored at the index 0 and to get the first element we tab we type here square brackets and you put 0 and that if you press Ctrl if you press shift Ctrl p on it it's a string because that is going to return as the first value in the array which is uh John so if you run this code we get John but let's put some text here to make it more clear that this is the first element so let's type first element now let's choose the dollar sign because this now is a placeholder and let's put the curly braces around our our element and the quotation mark here now if you run this code you get first element John let's put here some so get the first element John because uh John is stored at the index 0. and in the same way John is stored at the index 0 Steven is stored at the index one and Megan is stored at the index two so our index starts at zero the index of an array always starts at zero and you can replace a specific in an element in the array also using the index operator so you can type here names again square brackets zero equals so now I'm going to assign a new value to our element stored at index 0 which is now put here the value Alex so now if you run this code now get first elementalics because John was John which is at index 0 was replaced with the value Alex so now we have Alex Steven and Megan but what you can't do is you cannot get an uh element at neither and an index that doesn't exist so we cannot get here let's say an element of the index 4. because if you run this look what happens we get an error which says array index out of bond extension index 4 out of bonds bonds for length 3. that is because the index 4 doesn't exist and here we try to access that value and that value at that value and that index doesn't exist and this is called the runtime error because this error is is called only one while our app is still running so you don't have here an error like we have for uh here we don't have a compile error which you saw in our previous videos that is because the size of an array is not known we tell our compile time also it's very important to know here that the size of an array is fixed so this will always have the size three and uh the only way to add new elements to it is to put the elements directly here but there is not another way to let's say that I want I can put another element in the array down here we can only replace elements and then in the next videos you're gonna see that there are other arrays which are more flexible in the sense that they can grow and Shrink we can add the or remove elements from those arrays but for now uh we're gonna look just at the for this array so let's change this back to zero to don't have that error and um to avoid this kind of Errors you can check to see what is the size of the array in other words to see what is the number of elements stored in Array using the size variable so let's do that so I'm going to add the printer lens statement below for first one so I'm going to type here println and here I'm going to put the text the size of the array is and here I'm going to put the dollar sign curly braces now I'm going to use our names array and you're going to put that size and this is gonna give us the size of the array or or it's going to give us the another words the number of elements which are stored in this particular array so if you run this code you're going to see first output the first element is Alex and then you're going to see the size of the array is 3. so we get first element Alex and the size of the array is three and this is very important to note that the size of the array is always one times greater than the last index in the array so we have an array which starts as index 0 and and ends at index two which has a size of three so very important to remember this to avoid the crashes and your programming and of course that you can put other data types in our array so I can declare another array here also Val called numbers and we can use the array of again and here I can pass some numbers and now you see the type is an array of Fint or an array of integers or whole numbers and you can also mix types here so you can put here numbers and strings so now we have another and this which is between our angle brackets you don't know you don't need to understand this for now but this allows us to have array of two types respectively of type int and of type string and you can post also a chart here if you want let's say a so we can create an array of any type if you want so this allows us to to put to mix our types in in the array and because we've looked at loops and how you can use loops you can use Loops to Loop to this array so I can put here let's say that I want to use the first array so I can put here four name in names now I'm going to refer our array of strings then print print A lender name so now you see that we have this type hint for our name variable that we have here of course this can have whatever name you want now if you run this you're gonna see our three names outputted down here in the console so now we have Alex Stefan Steven and Megan because uh now you're we're using the for Loop to Loop through our array names and uh this is interesting but what if you want to Loop through our array numbers which is a mixed array we have numbers and strings and charts we can refer it here let's call it I in and now you see the type that was inferred for the eye is this comparable that we have here so this is going to Loop through our mixed array so we put here I now if you run this you're gonna see our numbers and in our name one and our chart output down here so now we get first element Alex which is a printerland statement then the next print line statement the size of the red then you have our numbers in our numbers array and then we have our name one and our and then we have our chart so this allows us to to Loop through our mix arrays but what if I want to to Output only if I want to Output in the console only the integers in this mixed are equal numbers to to do that and this is a good good way to introduce this keyword and with this keyword we can check to see if a literal or a variable is supposed certain type so I can put here if I is let's say an INT then and only then I'm gonna output this value in the console then I'm going to call our printerland and I'm gonna post our password I variable to our println function now if you run this you gonna you gonna see in our Loop only the numbers here only the integers because this is keyword is checking to see if our right is of type integer and this is going to return true or false in our case it's going to return true for our for all of our numbers that we have here so we have four five six seven and four again and you can check to see if this is a HR I'm gonna see in the console only our single element a I'll put it down here so we have a or you can check to see if this is a string this element that We're looping at this particular iteration let's say so if you run this you're gonna see in the console only name one because only name one is of type string so I get name one so this is very important to know that with the is keyword you can check to see if a variable or a literally is of a certain type or if it's not and based on that too to just to do some in our case you output that value in the console if that condition is true so this is how you can use the is keyword and the for Loop to to the for Loop to Loop through our array and these keyword to check to see if an element in our arrays of a certain type or if it's not and let's change our array numbers to a different name because numbers is very specific it implies that we only have numbers in this array but we have a mixed type so we have multiple types in uh our array don't have only numbers and to do that instead of changing our numbers array and everywhere in our code where you're using the this variable we can right click on it go to refactor and click on rename or you can click shift F6 now if I change the name of our array numbers it will be change everywhere where you call this variable so look if I delete now the name the name is also changed in our line of Code 9 we're using in the loop so now if I change this to let's call it mixed elements if I press enter now this will be also changed everywhere or we call our our variable respectively on the line 9 here so now we have our our array numbers change to mixed Elements which is more uh descriptive because it implies that we have an array of mixed elements so now it's time to do a challenge using the knowledge that we have about arrays but first of all I'm going to delete the code inside the curry base of the main function because I have the previous project opened now the challenge is to create a function which is going to take as an argument an array of integers then you need to figure out a way to determine which number is the biggest number in that array then we need to return that number to the function and you need to create another function which is going to do the same thing but it's gonna figure out what is the minimum number stored in that array and then it's going to return that value and third you need to find a way to combine those two function in just one function which is gonna return the maximum value stored in that array if you want or if you don't want it to return the minimum value so try to solve this Challenge and then watch my solution now let's solve this challenge so first I'm going to create a function which is going to be called the find marks this function is going to return the maximum value and it's going to take us and I'm going to Define here parameter and an array so here I'm going to type a name for our array is going to be called numbers n is going to have the type array of int of integers and it's going to return an integer now here I'm going to declare a variable it's going to be a VAR and it's going to be called Max and in this Max variable I'm going to store the first value in the which is uh which is past which is in the which is in the array so I'm gonna type here numbers square brackets and I'm going to use the index 0 to get the first value in the array then I'm gonna Loop through this array so for number in numbers then here you're going to check to see if our number is greater than our first value which was stored in the array or max value and if that is true then I'm gonna store this value which is now greater than our than our maximum value in our Max variable so here I'm going to put Max now it's going to be equal to this number which is found to be greater than our previous max value and at the end of this loop we're gonna return the maximum value and we're going to do the same for the finding the minimum value so I'm going to copy this code and this is going to be called find mean but uh here gonna change a little bit the logic let's call this variable mean and you're going to change the condition to less than min now let's call those function in our main function and let's pass summaries to see how it works so first I'm going to declare a variable it's going to be a Val and it's going to be called Max and now I'm going to call our find Max function and here I'm going to pass an array and I'm gonna I'm gonna pass the array directly here so I'm going to type array off and I'm going to pass some arbitrary numbers like then I'm going to create another valve this is going to be called mean now I'm going to call find Min and here I'm going to also call our array of function and here I'm going to Define some arbitrary numbers again now I'm going to Output those value in the consoles so I'm going to add printerland here I'm going to type max value is dollar sign and I'm going to refer our Max variable defined above another println now let's run this code it's get max value 7 which is correct this is the biggest number then we get the minimum value is 4 and this is also correct so our code Works uh perfectly well now the next thing is to combine those two functions that we have here let's increase this now we need to find a way to combine those function in one single function which is going to also return the maximum and minimum value but only if I want to return to be returned so I can determine if I want the minimum value to be returned by that function or if I want the maximum value to be returned by that function so I need to find a way to combine those two and to do that I'm going to delete our second function I'm gonna delete the code inside the this function and I'm going to change the name of this function to find mean and Max and now here I'm going to define a parameter which is going to be a Boolean uh which is going to have a Boolean type so I'm gonna call it I'm going to call it search Max and it's going to be a Boolean all right now based on that Boolean value if is true if I want to search the maximum value here I'm going to type an if statement so I'm going to put if search marks then I'm gonna add here the code to search for the maximum value the first let's define um a variable here is going to be also VAR let's be called gonna be called Max and uh it's also going to have the first value in the array which is also adding the zero now if our search marks is true then we want our maximum value to be search and return so I'm gonna add here to the code to to do that so I'm going to type here a for Loop which is going to go through our numbers array and here I'm gonna add the the if statement which I'm gonna check to see if our number is greater than our Max then I'm gonna assign our our number Tower Max now I'm gonna go down here and and here I'm going to add the else part so if this uh argument which is passed to our parameter search Max is false so I don't want to search for the maximum value then that means that I want to search for the minimum value so I'm going to put here else now I'm going to add the code to search for the minimum value and for this you need to Define also variable here it's going to be called mean and it's going to have the value of Max I'm going to explain a minute how this works now here we're going to gonna also Loop in our numbers draw numbers array and you're going to check if we essentially we have the same code that we have in our find the mean function so here we're going to search if our number is less than our mean then gonna sign our number to our mean also I need to return this value at the end of our Loop so here we need to return Max and here you need to return mean now let's press Ctrl alt L to format the code now let's delete the those the code that you have here let's delete also this code now here now I'm going to put our fine Min and Max function directly in the printerland statement so I'm gonna type here uh or to put in a variable for so let's put in a variable first so I'm gonna Define a variable he's going to be also a map it's going to be Auto Max and here you're gonna type find Min and Max now here you need to pass an array first so I need to pass we need to call our array off we need to Define some numbers here let's say uh 20 40. 50. now we need to pass an argument to our parameter search maps which is going to be either true or false so first I'm going to pass through here now if we print this value if you output this value in the console let's say that we type here the marks equals to dollar sign I'm going to refer our variable now if you're around the squad we get the maximum value is 100 which is correct now let's duplicate this code that we have here and let's try it for Dominion value let's call it mean and let's add the printerland uh statement down here let's type domain values dollar sign mean now if you run this code and let's pass here to false let's run this code again now get the maximum value is 100 which is correct and the minimum value is 20 and we did this with our find Min and Max function by combining our two previous functions and the our code on the networks okay now it's time to have a discussion about how this code how this code how this solution to my challenge works so now let's see how our logic inside our find Min and Max function works so firstly we declare our function find the minion marks then we declare two parameters which is one is numbers and is of type array of integers so here we're gonna pass only an array of integers and the second parameter is called search marks and it's a Boolean so you can pass here only true or false then we're going to say to the then we say here that this function is going to return a value next on the line 9 we declare a variable which is called Max and we assign using the index operator the first element in the array in our Max so in this case we're sine 20 in our Max variable and then we declare another variable called mean and we assign our marks in our mean but our Max has the value of 20 because we assigned it here so this variable mean is also is also also having the value 20. so both have have the have the value 20 at the start then we check to see if our search marks parameter is true or false and if it's true then I'm gonna execute the If part and if part works in the following way first we Loop using the for Loop through our numbers array then we check at each iteration if our number let's say if 20 is greater than our Max so if 20 is greater than 20 which is going to be false so the code inside the calibration if it's not going to be executed then go for the next iteration so here now we're gonna see it gonna check to see if our number respectively 40 is greater than our Max which is 20. and this is going to be true and because of that the code inside the calibration is going to be executed so now we're going to assign to our marks which is now is 20. our number which is 40. so now our Max variable has a value of 40. and we're going to we're going to do the setting for the next for the 50. so this condition is also going to be true so we're going to assign it to our Max 50 and so on and so on until it reaches 100 which is uh which is going to be also true this condition is going to repeat true and I'm going to be assigning 100 to our Max value of course that if we had another number here let's say two is going to Loop for that number also and this condition is going to be false for that because our number two is not going to be greater than Max and it's going to exit it's going to exit the loop it's going to tell it's terminate and it's gonna return the maximum value which is 100 like we saw in our output in our console and at this point when we return our max value the function is left so it's not executing any line of code besides our return Max is not going to execute the subsequent code which comes below but if our search marks is false it's going to execute the else part so in this case it's gonna search for the minimum value so here we have the same for Loop we search you go through the through all the numbers but here not checking to see if our number is greater then marks you're checking to see if our number is less than our minimum number so you check to see if our let's say uh let's say let's take 20 30 40 is less than our minimum value which is 20. and that is going to be false so this code is not going to be going to be executed inside the calibration of the if and it's gonna loop again and now it's gonna check for the fourth and that's also going to be gonna be um false so and so on so and so on until it reaches 100 which is also going to be false the loop is going to execute and it's going to return 20. of course that if we put here two let's say now the minimum value is going to be 2 because it's going to Loop for another iteration and now one is going to compare C4 number respectively two is less than our mean which our mean previously was 20 that is going to be true and it's going to assign our 2 to our mean so if you run this code now now you're going to see that the minimum value is not 20 but it's but it's two and after that we return this value to the function which is called so now get the minion values 2 which is correct so this is how this uh code works and see you in the next video so now it's time to start a discussion about object orientated programming and particularly in this video we're gonna look at classes and objects but first i'm going to create a new project I'm going to call it op for the language select Catalin and for the build system IntelliJ make sure to have the jdk selected and also I'm gonna check this little box because this ad sample code is going to add the main function and that code for us so I'm going to click on create to create the project now I'm going to delete this code and I'm going to hide the project pane now what is object oriented programming object orientated programming is a way of writing code in a sense in the way you think about the real world so in the real world we have objects which can interact with it with each other and which can do stuff but the objects in the real world have two major characteristics first is the state so another the state of an object in real life is represented let's say that we think about of a car the state is represented by the color of that car by the number of Gears that car has by uh by the brand name of that car so this is the state of a car the next thing that real life objects have is functionality so objects can do stuff so let's take again the example of a car a car can move a car can stop a car can switch gears so objects in real life have this uh though this those two characteristics is those two major character characteristics represented by the state and the functionality and the aim of object orientative programming is to construct objects using code in the way they are they in the way they are in the real life but uh to do that let's say that you want to build an object an actual object in real life what you first need to do the first thing that you need to do you need to create a template or a construction plan for creating that object in which you're gonna Define the generic things that a car has and in programming you will do the same thing but instead of using a piece of paper or uh or a something on on your PC to draw that that template in programming you're going to use a class so the class is used to create the template which then is going to be used to create an actual object an object which is going to have a specific State and a specific functionality so um in a way you can think that the real world serves here as a model for us to write code and in this way in by combining uh the state and the functionality in one entity and have an object and as you can see you can also have like in the real life objects communicating with each other you're gonna see that this is really powerful because you can you can model your code in a more dynamic in a more you know more create creative way so this is what we're gonna do next so first let's say that I want to create an object of type car and to do that we go down here and we need to Define as I said the construction plan the template for building an object and in this case we're going to build the car object so we're going to Define what is called a class and type the keyword class now we need to name our class I'm going to call it car and the name of the of the class should start with the capital letter and if it has multiple words it should be in Pascal case curly braces and press enter now inside the color braces we need to define the state and the functionality as I said for the objects that are going to be built with this template and to do that we need to use variables first for the state or or in the context of object orientated programming and more specifically in the context of classes they are called the classes and objects they are called properties and we Define them like we Define a simple variable we Type R and the next the first thing that that a car has is a name or brand name so we're gonna type name but we cannot keep this variable uninitialized we need to provide the value to it and I'm going to put an empty string for uh for now so it's gonna have the default value an empty string the next thing is the model what kind of model this car is so it's going to be also a string I'm gonna assign an empty string the next property is going to be called the color it's going to be also an empty string and the next property is going to be called doors so this is going to store the number of doors that a specific object which is going to be built with this template is going to have and we're gonna put zero I'm gonna put zero now we need to Define some functionality for this class and for the objects for an implicit for the objects that are going to be built with this class and um I'm gonna add two functions first one is going to be called move it's not going to take any parameters it's gonna just output some text to the console which is going to say that the car is moving so we put quotation marks the card is moving now I'm gonna Define another function call stop also it's not going to take any parameters it's gonna just outpost on this the console it's gonna it's gonna say that the car has stopped now we have the template we defined what our car is gonna have now we need to create an actual or object an actual and specific object using this template and to do that to firstly declare a variable and it's going to be a Val and I'm going to call it car one so so our object is going to be stored in this variable car one then you put equals and we type car and now we have some suggestions and we have our car that we Define below our car class so we press enter then we put parenthesis so now we have created an actual object a real object real in the programming sense and which but now this actual object was also this is called the instantiation because we created an actual instance but we don't need to bother with these names for now so we created an actual object using this template that we have below but the the properties of these specific objects are those properties that we Define here those default properties and to Define some specific profit some specific values to these properties that this car object that created has we need to type car one dot so this is called informally dot notation and now we have some suggestions so we have our properties that we defined for a car and now we type car one dot and we choose the name and now I'm going to assign a value to this name I'm going to be called Tesla so now our car one object that was created has the property name Tesla now we do the same thing for the next property for the model car one dot model press enter and you put we put here s blade so the model next we also type car one Dot now we're gonna assign a value to the property caller it's going to be red next we type also car one and we Define for the property names for the property doors also value so we're gonna put here four so now our object R1 has for its property for for its properties some specific values respectively have for the name Tesla for the model as played for the car for the color red and for the doors 4. so now let's output the property values of this object that we created in the console and to do that we put our println function down here we put quotation marks inside the parenthesis because I'm gonna add some text here so I'm going to type name equals we put dollar sign then input curly braces and inside the calibration type car one dot name and this is going to return the the value of the property name for the car one object that we created respectively is going to return Tesla let's press Ctrl d three times to do the same thing for the next properties and here we put car one dot model so this is gonna return the value of the model property you're gonna put color and here I'm gonna type doors now if you run this code we get name Tesla actually let's change the text here to model to match the property name model color endorse so now if you're on this we get the name Tesla Model is played color red and doors 4 and those are the values of the properties of this object that we created here with our template car next what you can also do because in the class we Define the two function we can call those functions on this object that we created and to do that we also use the dot notation we type car one dot move and this is going to call the move function which is inside the car one object let's also type car one dot stop to call the store function so now if you run this code we get uh the values of our to our properties and then we get the car is moving and the car has stopped so the car one dot move and car one the stop is calling the functions on this object that we created here now let's uh also add inside the functions the name of the card that is moving so he to do that with here dollar sign inside the class and we type name and this is gonna reference this property name that is defined here let's also do the same thing for the stop function let's type name and now what this is gonna do because those functions are in they are they're living inside this object that we created here car one and this object has the name Tesla when those functions are going to be called they they gonna they're gonna say that the car and the name of the car which is in our case for our objectives Tesla is moving and then it's gonna say the car again Tesla has stopped because they are calling this uh specific object that we created which has uh those specific values for its properties all right so now if you run this quad we get as expected the car Tesla is moving and the car Tesla has stopped so the functions are called on this object that we Define here and it's using the property values that we Define for this object but as I said with uh you can create as many objects as you want using the same template and let's do that let's create another object so I'm going to type here Val Car Tool let's put equals we type car and then we put parenthesis and this create is now another object but we need to Define some values to its properties because now the values for the properties are the default values that we Define inside the class respectively the empty string and the zero and to do that we type here car2 dot name so now we are calling the properties for the car 2 object and now we Define some values to the cut to the properties of the car 2 object so they are this here is not overending the value that we have here because this thing that we have here it's a distinct object in memory uh from this object they are this thing distinct objects and they have their own properties with their own values and their own functions and now let's put here Ford let's put the car to that model let's put Mustang let's put car to that color blue and for the doors let's put two car two that doors equals to two and let's output those values in the console so let's output the values of the properties for this second object that we created in the console and to that to do that I'm going to copy this code I'm gonna paste the paste it below here and now I'm just gonna change the the variable to car two to to call to call the properties on the cartoon object so we put here car2 so now we're calling the properties values on our car to object and now if I run this code now we get name Ford Model Mustang color blue endorseful and the first part is from the our SEC for from our first object which is named Tesla Model let's play The Red Doors 4 and the Carter slice movie and the cards has stopped but let's add a space here to make a clear uh to make a clear which to make uh clear that this is the output for the second object to make things more clear and to add the space we put here a printerland statement we put quotation marks and we put a backslash n and this is going to add a space between our println statements so it's going to add a space between those statements and we uh and those so now if you run this code let's increase this we get the name Tesla so this is our first object model let's play it called Red Doors 4 The Carter size moving because we're calling the functions on the first object and the character has stopped and then we get name Ford Model Mustang color blue Doors 2 and we have our space because you put here this backflash and which adds that space for us let's um decrease this and let's also call the functions the move install functions on the second object so I'm going to type here car2 that move and card two dot stop so now if you run this let's right click and just click on run main.kt now get our first object which is with this uh value for the value of the value for its properties and then we get the two functions called on our first object and um we get in our second object which is values for its properties and then we get the card for this moving and the car Ford has stopped because now um we're calling the functions on the this second object and this second object has the value for the properties has has different values for its properties so this is why you get the card for this movie and the car four has stopped again they are different objects they are distinct objects created using the same template the same construction plan and I'm gonna end this video now and see you in the next video so in the last video we saw how we can create a class and then how we can Define some properties and some functionality to that class then we use that class to create two objects and then we defined for those objects for the property of those objects some values but the way we we Define values to the properties of the object is to call the the object and then the property of logic and then we assign a value and this is okay but if you have more than than four properties let's say you have 20 or 100 properties that will be very tedious to write each one of them and then assign a value and a better way is to use what is called a Constructor and as the name implied The Constructor is used to construct the object and the Constructor is called at the time when we create a new object so at the time of line we we type this line of code when you finish to type this line of code The Constructor is called immediately so that is the the time where we need to pass the values to our properties and to do that we go down here where we Define our class we put at the at the end of our end of the name of the class we put parenthesis and here we Define some parameters the way we Define parameters for functions and the first one is going to be called name it's going to be a string the second one is going to be model also string the next one color also string and the last one is going to be doors and this is going to be an integer no we need to assign whatever value values pass to those parameters to the properties of the class here and to do that just delete the empty string here and type name and as I'm typing you see that we have name and it has this p and this P stands for prop for a parameter so you're saying do you mean this parameter that we Define up here and then we press enter to fill that for us then put we type here model color and then doors now if you go up here we have some errors because now the the when you create the object the objects is expecting for its Constructor some values so if you hover over here inside the parenthesis it says no value fast for parameter color Doors Model and name so if you and if you look down here you see that it has this public Constructor so now what we need to do is to pass the value that you passed down here to to the properties by calling the calling them on the object is to pass them directly in the Constructor and then the values the arguments if you want are going to be assigned to the properties so I'm going to put here and you have this hint name Tesla then we put a comma so we have the again the hint which is very helpful so for the model we put a splade and then for the color we put red and for the number of doors four all right so now this is more concise and now this is doing the exact thing that we did previously but this is more concise and we're using the Constructor to pass the those values to the parameters that we Define here and then those parameters going to be assigned to the properties respectively with those properties name model core and doors you're gonna see what is the difference between the properties and parameters in uh in the next video now we have also an error here because this also express some values to its Constructor so instead of putting those values here we put up here Ford Mustang blue and two now we can delete this because we already passed the values for this second object for its properties now if you look at the codes the code is more concise and more and easier to read now if you run this code you will have the same output because the code works well so now if you look at the console let's increase this a little bit let's scroll up you have the name Tesla Model let's Place color red doors4 the cartridge lights moving the cut Isla has stopped so you have the same output as previously and down for the second object we have we have a the name Ford the model Mustang the color blue Doors 2 and the Carphone is moving in a car 4 has stopped so our code works well now let's close the console but if you go down here you'll see that you have this um this uh the properties colored so if you hover over them it says the property is excretely assigned to parameter name so it can be declared directly in Constructor now what is saying here in other words is that we can put the properties directly in the Constructor so you don't need to define the properties down here and then assign the value that is passed to the parameter to the property and the difference between the properties and parameters parameters is that the properties respectively those that we Define in the in the header of the class inside the parentheses 0 in the Constructor is that the properties are not uh storing the state of of the class they are mastering the state of the object there they are only here to to get whatever value we pass here so whatever value you pass here and his job is to only get that value and assign it to the property name so only the the variables which are declared declared inside the class are storing ultimately the the state of that object so uh if I delete let's say if I delete this here now we have an error here because the property name um it says on our result reference name create member property card.name and that is because the property name is not declared it's not exit it's not it's not a it's not uh it's not a characteristic of a car we didn't Define a property name because here the parameters the parameter name is only there to get the value and then pass the value to the property but we can let's press Ctrl Z to put the code back now the error disappeared because we have the property declared but because the only thing that we do here is to to to get the value that is passed to the property as an argument here and for the next ones and then assign it to the property we can put those directly in the Constructor so to do that we just we can hover over here and let's hover over and click on this light bulb and click move to Constructor so now you have this you have the same the same thing the same thing but the only difference is that we have this VAR keyword in front and that is responsible for changing the changing the parameter into a property so let's do the same thing for the next ones move to Constructor and now we don't have that error that we don't have a property for our class because never because they have the VAR so if you put the VAR or the VAR keyword before declaring the the the parameter it is going to be converted into a property so now those are properties of our class car so they are storing actually they are storing the the value that you pass to to them for the project that we create so uh it's not like previously where you have the property the parameter and then the value is passed to the property inside the class so now if you run this code foreign we have the exact same output the only difference now this that this is uh more concise we have the properties declared the right directly in the Constructor so we don't have declare the parameters and then we assign the value that is passed to those parameters to properties so you can declare the The Constructor like this if you want so the question may arise when to use properties and when to use parameters and to to to answer that question um you have you need to have in mind that if you want to do some if you want to do some work before you assign the value to the property because in our case uh the value that is passed here to the to the property in this case is directly stored in the property so we cannot add some validation to check to see if uh I don't know if this name is if it starts to a specific letter or if it's if it's an uppercase or because the value that is passed that is passed as an argument to the property there I say property because they are there there are no declared as properties it is directly stored as uh as a the state of the object so if you want to to do some work before you assign the value of the property you need to declare it let's say let's say that you want to Let's actually delete this and I'm going to declare it as a parameter so let's say that you want to to to trim the space that is passed so let's say that I put some spaces here let's actually press Ctrl G to see what is happening if I don't do that all right I press Ctrl Z too many times so let's let's again Paul let's put some spaces here so now if you run this code let's run it again now because the value that is passed as an argument here to the object car one is passed directly to the property so it's stored in the property and we we don't do nothing with it we have also the space but if you want to to delete that space currently we can do that because the values pass directly to the property and there is nothing that we can do from that point and to to change that we can declare the the property that is defined here the property name as a parameter first and we can declare it down here we can declare down here now the property and we can put equals and now we we pass the the parameter to the property so it's a sign name here but before before that value is assigned to the property name we put that stream and that is going to remove the spaces so that Rim is a function which is part of the string class because the the data the all the data size that we looked at are also classes so you can call functions on them the way we called functions so not our on our objects so name that trim removes the space so in this case it removes the space that we have here and after that it's assigning the value to the name property so now if you run this code now now we have the space but if you run the code so let's go up run the code now as you can see the space is removed because we pass the value to the parameter now name then the parameter name trims.space and after that it's assign the value to the property name so in this case so in this can be a scenario where you can uh where you can declare the instead of declaring directly here the property can declare as a parameter but what do what what you can do if you want to add more code than just one line of code in that case we'll need to use what is called the initializer blocks but um we're going to look at the initializer blocks and uh other things in the next video because this video is long enough so see you in the next video so in the last video we looked at Constructors and how you can use Constructors to construct your objects and it was an alternative to defining the values to the properties of the for particular object and we've also looked at how we can Define the this Source I should say it's also called the primary Constructor that we have here the parenthesis and then the parameters or the properties and we've also talked about how we can Define parameters or Constructor and then how we can convert those parameters directly into properties and I've also talked a little bit about how and when to use parameters and properties but in this video we'll continue our discussion about parameters and properties and specifically going to look at how we can execute more than one line of code when the object is created because now when the object is created and we in the last video we trimmed this space that we have here you can execute only this line of course so if you want to add more line of course here to do some um to do a more complex validation we can't because here we can put just one line of code and to add more than one line of code of code they need to use what is called initializer blocks and the initializer blocks are as you'll see some blocks where we can put our code and you can put more than online so forth you can put as many lines of code you want and that code is going to be executed when an object is created on an instance of our car of our of your class is going to be created so um this is what we're gonna do in this video also I should say that you can declare the class in another file not just in this file like we did here so we can open now the project pane you can go to SRC go domain go to kotlin and here on kotlin you can right click select kotlin class file and from here make sure to select file and I'm going to call this file classes because you're going to put our classes respect we're going to put our card class but you can put more classes there and uh we're just going to copy this class that we defined here Ctrl C and paste it here now I have an error because this is declared two times here and here and we just delete it from here and now the arrow disappears and if you run this code we get the same output because our code works perfectly well now the only difference is that now we will put we put our class in a different file and my suggestion is for you is to put the class if you want in a different fly file because in this way you have the code in when I'm going to organize the way because here you have your class here we have the code the objects that we created with that class and so on no for this video I'm gonna use I'm gonna create a different class and to do to do that I'm gonna declare another class but I'm going to declare it down here and I'm going to delete the code that we have here because we're going to use a different class and the class is going to be called user so it's gonna represent the the use and end user object so we type here class user now we create the Constructor the primary Constructor we put parenthesis we Define the parameters or the properties for uh now I'm going to Define directly the properties here so we type here keyword to have the property declared VAR name string so it's going to be we're going to be store stacks VAR last name also string and uh VAR age this is going to be an integer so this with this class we're going to create some user objects I'm going to put curly braces and for now we're not gonna put any code here so let's create a user so let's type here Val or let's call it user you can give it whatever you want so let's create a new object now so we put you type your user and then for the parenthesis because I'm going to put we're going to pass the values to the Constructor here Sony to pass a name I'm gonna type Alex last name no binka and for the age 23 so now we created a new instance a new object using the using the cluster to Define below but what if I want to to pass to to the to the name to the name name property only the the names which starts with the letter A in that case we need to declare this property as a parameter first we need to declare here the parameter and then to declare the property below and before before we assign the value that is passed to to the property we need to do some validation and if that argument that is passed to the parameter is starting with the ale letter then you're going to assign the value to the property name otherwise we don't do that so to do that we need to use initializer blocks because we're gonna type more than one line of code and the initializer blocks are used in conjunction with the primary Constructor so when we create a new object like we did here the initializer blocks or the initializer block is going to be called immediately when the object is created and to use an initial initializer block we just but first let's declare let's change this to to a parameter so let's delete the VAR keyword in front of the variable so now we have only a parameter here now let's declare the property down here and now here we need to Define an explicit type declaration so we need to put here the type string because as I said um we're not going to assign the value to the property directly here in one line of code we're going to assign the value to the property inside the initializer blocked after we do the validation respectively after we check to see if the name that is passed to the objects that we're going to create with the class starts with the letter a and if the the name if the argument doesn't start with the letter A then we're going to assign an empty string and we're gonna output something to the console so this is why we need to provide here the type because I'm not gonna assign the value directly here so it cannot infer what kind of data is going to store then you press enter we type init and here we have a suggestion we have the unique keyword and then we have the curly braces press enter and now here we're gonna add our validation and here we type if parenthesis now type name so now we're referring the name parameter defined above here so if name or the value that is passed to the name parameter first we're gonna um lowercase dot name and to do that we type here name dot lowercase because I want to have both cases so if if the user passes let's say a name of the lowercase letter then we're gonna check to see if it starts with OTA but if the user passes the the name of the an uppercase later we also want to check to see if if that letter starts with a and to cover both cases we lowercase the input we lowercase the name so all the lowercase all the letters then we put here another Dot starts with an input here a and if that is true then we're gonna assign whatever value was passed to the name parameter to the name property and we cannot type here name equals name because now it's referring the parameter here and to refer the property that we Define here we need to use what is called the disk keyword so the disk keyword is used to refer them properties of the class so it are here this so we're saying this name so now we have this name and we have a different we have this V variable here then put equals name so now we assign the value that is passed to parameter only if that valuable only if that value pass to the parameter starts with the letter A then we're gonna assign the name to the property name else if that is not true put curly braces and now we need to cover the else part because if this is not true we also need to pass a value to to the name proper the name property cannot stay without a value so we need to pass those over here else we're going to put this dot name and I'm going to put user so I'm going to put the user text if the if the the name doesn't start with the with the letter A and we can also output some text.com so we put println here and we'll type the name doesn't start with the letter a or capital a so now if you create a new object here so we type here Val let's say for friend we create a new object so we type user now we need to pass the values to the Constructor so you put here a let's say uh John let's put Smith let's put 30. now because the the value that you pass here to the parameter name doesn't start with a letter a and start the letter j this value validation inside the initializer block is going to be false and then it's gonna it's gonna execute the else part and it's going to assign to the property name the user text and it's going to Output the name doesn't start with the letter A or a but if that is not uh if but if it's true if it starts with the letter A then this line of code is going to basically the base part n is going to be a sign it's going to assign the value to the property so now if you run the squad we get the name doesn't start with the letter A or a and it's correct our name starts with the letter j so if I put here let's say Andhra let's change this to oh let's see here also Smith now if I run this now we have no output because the this the initializer block is is called and the If part is evalu is to true and it's assigning the the name Andra to our name property so let's add the print and then down here to see that that is correct so print let's print the value of of the property name for our friend object and we put here and here we type dollar sign you put curly braces and you type friend Dot name so now if you run this let's close get name under let's put comma here let's put colon here so our initializer blocked is called the code inside the initializer block this execute it and then this if check average to true and then and then it assigns the name Andra to our property name but if we I put here John let's type it like this let's say to see that it's working because we lowercase the letters okay the name doesn't start with the letter A or a name user so the initializer block is executed immediately when the object is created and the code incidential log is called it checks to see if it starts at the lower it starts with the with the letter A and if not then it is assigned to the property name user so we have this we have user here and then it outputs uh this text to the console so this is how we can use the initializer blocks in conjunction with the primary Constructor and you can also put more initializer blocks and the order in which you put the initializer blocks matters in the sense that the word in which you define the initializer blocked is is going to be the word in which they are executed so the word in which you define them it's important but most of the time I think you'll you use only one initializer block to put your code so this is our discussion about initializer blocks and in the next video we're going to look at um because we talked about the primary Constructors there is a another type of Constructor which is called the secondary Constructor of this secondary Constructors and we can also look at the default parameters because you can put you can we can Define default values to the properties also the parameters of the Constructor so we're gonna do that we're going to do that in the next video I'm gonna end this video a little now so now it's time to start a discussion about secondary Constructors because besides our primary Constructor that we Define and that we talked about in Cotton you can Define multiple Constructors and those are called the secondary Constructors now you may be wondering why you will need secondary Constructors and to answer that question we need to consider the user class and those user objects that you can create so let's say that an user only provides its first name and for the property is last name and the age doesn't provide any value in that case you will need the you need a way to to Define some default values for those properties in case the user only provides the first name and uh if let's say the next user does provide the the first name and the last name and the age in that case you're gonna use uh the the primary Constructor but if it doesn't provide those uh those values then you're gonna use the secondary Constructor but to make this more clear lists uh let's add the code and we talk we talk about was while I am writing the code so let's delete the initializer blocks that we have here because you don't need this code and let's also put the property now let's define the property in the primary Constructor so let's just put here a VAR the work here in front of the variable let's also delete this printalian and um let's delete the values here for the last name and the age so now as you can see we have an error because it's expecting here the um it's expecting an argument a value for the last name and for the age and to solve that problem we just go down here and we type Constructor so this is the keyword for declaring the secondary Constructor and we press enter to fill in that for us and we put parentheses and now here in the parenthesis we Define the parameters and I am specifically saying parameters because as you will see the secondary Constructors cannot declare properties they can only declare parameters because anyway Let's uh so let's define here the parameter so I'm gonna type here name let's put here the type of this variable is going to be a string now if you hover over here it says primary Constructor called aspect insert this call so what all the secondary Constructors need to do is they need to call the primary Constructor because ultimately the primary Constructor is the one which declares the property the properties for the class and stores the values for uh of that Pro of that property and to do that to put here colon we type this so we put colon this type that this keyword then you put parenthesis and to the disc call we pass the name so this name that we defined here and for the next two values we're going to pass some default values so here I'm going to put user because let's say that because as I said in the beginning this user is gonna not it's not gonna provide the last name so let's put your last name not user last name and for the age let's put let's put let's say zero all right now what this is going to do is now if you look up here don't have an error so let's uh so now we don't have that error because now it's using the secondary Constructor is passing the value here Alex to the secondary Constructor that we Define here and here we Define only the parameter and the value that is passed as parameter then is passed to this to the primary Constructor because by putting colon and these and parenthesis we're calling now the primary Constructor and is the primary Constructor the one which ultimately declares the property and stores whatever value we send to him in this case we send the value Alex and for the last name we uh we just send the last the text last name and for the age you put 0 because this is our way to saying that this user doesn't want to provide its age so this is why you need to call the the primary Constructor from the secondary Constructor because again the secondary the primary Constructor is the one which ultimately declares the properties of the classes the one which stores the the the properties of the class the secondary Constructor only only takes parameters and then calls the primary Constructor so in fact if you put here the VAR keyword you have an arrow which says Varon secondary Constructor parameter is not allowed that is because the secondary Constructor cannot call it cannot declare properties only the primary Constructor and because as I said you can declare multiple second Constructors we can type here Constructor so we can declare another secondary Constructor and here you can put name here we put string then we type last name also string so this secondary Constructor is only going to take the name and the last name as arguments the age is not gonna this uh is gonna not gonna take any value for the age now we need to put colon we type this parenthesis because now we're calling the primary Constructor and here we we pass the name that is passed to this secondary Constructor this that we Define here the last name and for the age we're going to put 0 because this uh this second secondary Constructor doesn't take any value any arguments for its uh for its age but because as I said ultimately the primary Constructor is the one which defines the properties we cannot we cannot call the prime Constructor and not pass any value so we pass this default value here and uh so now if you go up here and let's say that I delete the age now our code works fine because now what is happening here is this the the value for the for the name and the last name is passed to this secondary Constructor this one here and the secondary Constructor then calls this primary Constructor and it's passing the two values to the Primal structure name respectively this name John and last name Smith and for the age it passes the default volume zero so this is how you can this is why we can pass here uh this this is why you can avoid here to pass let's say uh you can avoid to pass the last name and the age for the first because it is using the first secondary Constructor and this object that we created here it's using this secondary Constructor because here we're passing only the first name for the value for the first name property and the value for the last name property so it's passing them to this secondary Constructor which then in turn calls the primary Constructor it passes them to the primary Constructor so it passes the the values for the two properties and the last one is defaulted because okay because you don't provide the value for the age with Pro with secondary Constructors you can also put you can at the end of the call of the primary consultor you can put curly braces to have some code executed when you create an object with that specific uh secondary Constructor so you can put here curly braces and inside the color blades you can have some code which is going to be executed you want to create an object with this let's say secondary Constructor an object with this secondary Constructor so it's up to you what the code you put there but to illustrate this let's put a println statement here in the in this secondary Constructor so let's type here println and here I'm going to type second and I'm going to type second because uh this is the first Constructor this is the primary Constructor and this is the one which ultimately does all the work is the one which stores the value for uh the properties and this is the third Constructor so let's copy this let's put here to Third just for illustration Also let's output in the console the value of the the property values for these objects so let's type here printerland and just type here name equals let's put dollar sign let's put curly braces let's use our user variable now let's call the properties on this public so let's type name now let's press Ctrl d two times and let's put here now last name and the age and let's also other space between the information about the two objects to make things more clear so let's put the printer and heroes and put a backslash in here and let's copy the code that we have here let's paste it below let's change this object to our friend object that we created just like your friend and I'm gonna speed this now a little bit because it will take some now let's output this information in the console so now what we have is we have we have second and then third because this first object is using the the second Constructor so this is why we have here a second and then the next line of code is called and we have third because this one this object that you have here the front object it's using the third Constructor this secondary Constructor so this I have here third then we have the values for the properties for the I didn't have the values for the properties of the user object so you have here the output down here and then we scroll down and have name John last name Smith age zero because we have a the property values for the second object for this object and this is okay this works completely fine the thing to have in mind is that now we're using the secondary Constructors and the secondary Constructor then calls the primary Constructor and the primary Constructor is the one which ultimately stores the value source which ultimately declares the properties and stored the values but one thing to notice in the output is that the first object has the name Alex and the last name last name and age zero that is because the first object is only taking a value for the first name property or for the name property and for the last name and the age because it's using this secondary Constructor is only passing in the first name which is Alex that we have here and then it's using the default values last name and a zero it's passing those default default values to the primary Constructor so it's calling the primary Constructor is passing the value Alex and then the default value last name and zero this is why I have last name and 0 here and for the next one we have name John and last name Smith this is because now this is using um the next secondary Constructor and that takes as arguments the name and the last name and then it's calling the primary Constructor it passes the first name and the last name and the aegi is defaulty so you have zero so this way you have here John and Smith and then zero so it's important to to notice this and to think about how this uh to think about this thing so this is our discussion about multiple Constructors respectively about secondary Constructors in this video you saw how you can pass a different number of values to our properties ultimately you pass all the values to the properties by calling the primary Constructor and providing default values because in this way you can satisfy all the possible cases so if in our case one user only provides the name and the last name is not provided and the age is going to use the this secondary Constructor and it's going to pass the last name as default and the zero and this is uh in a way similar to overloading functions but is not the same because what you're doing here is overloading the constructors and this in this way you can you can think about why why we're overloading the constructors and that is because if we didn't have secondary Constructors we would have to create another class with a different number of parameters or the different number of properties and we will need to to create each object with that specific class let's say that we create this object which only takes a value for its parameter name then we have to create a class which we're going to Define only the name property and it's gonna then we're gonna create that obviously with that class and if an object if an object let's say if an user creates uh if your user doesn't providing the the name and the last name but now the age you have to create another class with only the name and the last name defined as its properties and you can see that this this uh is uh this will generate uh duplicated code and so on and we can solve all of this by using secondary Constructors and calling the primary Constructor so see you on the next video and because quoting is about conciseness in the next video we're going to look at how we can do the same thing that we have here with default parameters because um kotlin supports for its properties for its parameters in the constructed default values so the same thing that we have here can be achieved by providing default values to the properties so see in the next video so now it's time to look at default values for our properties and first let's delete the secondary Constructors and now I have a error series because it expects the value expecting the values for the next properties here and um let's also change this to to first name because I refer to it to the first name but it was called This is it is called name so let's call it first name so go right click on it go to rename and then to refactor to change it in all the places and let's call it first name and as you can see now let's change it in all the place then press enter so now we have the first name and the default properties are default values to our properties are basically they are similar to default values that we provide to our parameters when we talked about functions then what we do is uh let's say that I wanted to provide the default value for the last name we just put equals so inside the primary Constructor we put equals and here we put let's say last name so now this has the last name as a default value if a value is not provided for the last name and here you can put also equals n equals zero and now the error as you can see disappeared from both of our objects because now what is doing is when we don't provide the value for the last name and for the age then the default values that we provide here is going to be are going to be used as the values for the properties so this is a way of achieving the same thing that we achieved previously with the secondary Constructor but this is more concise and the question is when to use one on one or the other is the um the answer may be if you want to execute some code when an object is created let's say with one of the let's say if you wanted to if you want to exit some code when you create an object then you can use secondary Constructor because as I said secondary Constructors can have a block of code when uh which can be executed but the this uh the default because primary Constructor does not don't don't have a don't have a block of code they you cannot do that maybe you could use a initializer blocks but that is uh open to discussion so this is how you can provide the four values to to the primary Constructor in our code was fine it's In This Very concise very beautiful and the next thing that you can do is that you can also use named arguments so you can use the because here you use the first name and the last name and if I um because those are those are both strings here you cannot see the distinction but if I put here uh now I can use the name argument so I can put your first name equals so it's similar to the way we have name arguments in our function and here you can put the text John also here and this uh with this thing you can you can change the order in which you need to define the values for the parameter so let's put your last name but we'll say this better let's create another object is user 2 let's type user and let's put here you wanna but let's use the name arrowman so let's put first the age so we're going to provide the value for the age let's say um 19. and um Let's uh let's type first name so here let's put um IWANNA because it's a string quotation marks and for the last name let's say let's type also the name argument last name and for the last name let's put here um Dobby let's say right so what we did here is that in the primary Constructor the order for for the properties very specific we have the first name and the last name and then we have the age but with the name arguments we first provided the age so we provided a value for the age product which is the last one so and then you provide the value for the first name and with the name arguments similar to the way used in our functions you can pass the values to the properties in which order you want irrespective of the word in which they defined here so this is very powerful if you if you ask me it's very interesting because you can pass the values to the properties irrespective of the world in which they are defined so this is our discussion about default parameters and the name argument in with the primary Constructor and you cannot use default parameters name arguments with the secondary Constructors they can only be used the primary Constructor so see you in the next video but uh before I end the video Let's actually run this code to see that it works in the same way it was working in previously when we use the secondary Constructors so let's run this code so you have name Alex last name last name because it's using this default value that defined here then we have h0 because it's using this value of defined here so this is this object and then we have name John last name Smith a0 because now it's using this default value so the same thing can be achieved using um default parameters and we didn't output the values for the for the second for the third object that you created here in user 2 but you can do that as a as a challenge for if you want you can output the values for this object so see you in the next video so now it's time to start a discussion about Getters and Setters because so far enough videos even though we didn't see explicitly the Getters and Setters here we've used the Getters and Setters every time we got the value of a property and every time we assign a new value to a property and um the getter and Setter in kotlin are implicit so they they are declared they are Auto auto generated by default by color by cutling for you so every time you and let's say you get the value of an object let's say let's get the value of the user that's first name what actually happens here is not that we're getting the value of the first name directly even though if you look at the code this what it seems to be what has happened is that every time we get the value of of a property that value is returned by the getter so you never access the property directly and you never never does change the the property of uh the value of a property directly you every you every time you you are using the Getters and setters and now this discussion is touching on on a very important Concept in quadrant programming and that is encapsulation so encapsulation basically means to to protect to hide the inner workings of the class from being accessed outside and if you look at this syntax that we have here it seems that we actually accessing the values the properties directly but as I said that is not the case because we're always using the getter and the setter and because we always use use the Getters and the Setters the getter to get the value and the set to to change the value of property that means that your data your properties are never accessed directly thus the laws of encapsulation are not broken the the in other words you you never allow somebody outside of the class to access directly that property so this is why uh this is why we have Getters and Setters and this is why the Getters and Setters in Kathleen are implicit so they are not even declared explicitly here we don't see any code which it will imply that we have a get a Setter here because they are automatically and by default generated every time you define a property so every time you define a property either in the primary Constructor or inside the class the Getters and the get the getter and Setters automatically generated for you but uh let's say that you want to override the getter and Setter to provide some additional additional code to the code that is by the by default provided you can do that by changing let's say this property to a parameter and to override the getter in Setter and to see how the Getters and Setters actually look under the covers just type here VAR we Define the property first name we assign the first name parameter property now the Getters and Setter need to need to be overrated immediately after the with after we Define the property so we cannot have some code here and then to override you can to override the getter and Setter so we need to we need we need to Define them immediately after we we Define the property so we type here get and as an attempting you see that I have some suggestions then you go down here you and you can choose you choose this one so you have parentheses curl braces and inside the curly braces you press enter here you type return field I'm going to explain immediately what is this and now we need to override the setter and to do that to just type set and I have some suggestions we also go down here we choose this one press enter and hero type field again this under this identifier and input equals to value so this is the implicit code that is generated that is autogenerated by kotlin for you every time you you you define a property in your class either in the as I said in the primary sector or inside the class so because in fact if you look here we have some underlines and if you hover over here it says redundant getter remove redundant getter because uh and also for the set it under setup because they are redundant because they are implicitly again Auto generated by cotton for you so this quad is redundant here you don't need this code because Scotland already provides this code under the covers for you but if you're not such satisfied with this quad with this implicit code that is uh Auto generated by cotton can you can um you can override them like we did here and provide some additional code so we can put here let's say some text so so that every time we get the value of our we get the value of our first name property you're gonna have a pretty pretty prefix and let's put here a first name let's put the colon dollar sign and field we're gonna play I'm gonna explain immediately what this field is but let's say first however how this works and here let's put a printerland to print a value that is passed to the setter and then assigned to the first name property so let's put here dollar sign value was assigned to First foreign now I have name so we have our text that we have here name and then have first name Alex let's actually delete this text to make things more clear let's delete this text let's delete this now let's run this code again so what we have now is that every time we get the value of our property name we have we have that prefix first name that we have uh overwritten here in the in the getter so the getter is called as I said the value is returned by the getter so together is called it Returns the value of the first name property so this field is is the first name property but is uh it has this identifier field because of uh of an important reason which I'm gonna explain immediately so it Returns the value of the first name property with the prefix first name and we have first name the text that we have here then I have the value of the first name property we have Alex in our case because our object has the name Alex as the property name Alex then for the for the setter we don't have any code here also we have the first name prefix for John so our our every time we get uh we get the first name property by of our objects created by by using the user class it gets that value it returns that value through the getter and the setter we don't have value was assigned to first name property because the setter is called only one we change the value of uh of uh of our properties and to do that we type user like we did in our first video about objects or another programming DOT first name equals let's say oh let's put here Vlad so now if I run this code now the setter is going to be called because the setter is called as I said only when it we change the value of our of our of of our property so we get uh get Vlad was assigned to first name property so the code inside the setter was called because this code that we type here is calling the setter so our code only only always goes to the setter and the code that we have here user that first name Vlad what it's actually doing is passing that value Vlad to here so this for this uh this parameter it that we have here is receiving the value of Vlad and then that value is assigned to first name property again we have this field the identifier for a reason and the reason is going to be explained immediately so uh the Getters and Setters are working well and they are as they said again the use always when we get or assign a new value to our properties now what is this field identifier why I didn't type here uh first name and here I didn't put uh first name equals to Value so whatever value is passed to the setter then that value is assigned to the first name property so why why don't we don't do that and um the reason uh for that is that because this syntax user.first name user first name user.first name equals Vlad is calling the setter if we put here first name equals value so first name equals Alex it will be equivalent to to call the setter again so this line of code that we have here it will call the setter again it will pass the value to the center and then it will assign the value again to the first name so it will call the Center inside the setter forever it will be it will generate an error and to avoid the that recursive call that infinite call we need to use this field identifier so the field in an identifier is the first name property but it has this special use that it bypasses that error that it will be generated if you use the first name here so in fact let's um let's put here a first name to see so if we put here first name instead of field and we have an error here let's put here a field because I want uh I want the error from the setter to to get in the console not there or from this thing here so now if you run the squad as I said that will generate a recursive call it will call the getter over and over so get the error so you see we have Vlad was assigned to first name property Vlad was assigned to first name property vad and so on that is because the setter it's calling the setter forever it's a recourse of call because this line of code here it's calling the setter it's it's a assigning the value to the sending the value to the seta then it's that values assigned again to the first name property which in turn close again the setter and so on so this field the identifier is used because it has this characteristic of bypassing that error this is why we're using the field instead of the first name property here and it's basically the first name property but it has this specific characteristics which characteristics which bypasses the recursive call which we got when we've used the first name property now if you run the code now I have no error because the recourse of call is not happening because you're using the field which bypasses that error so this is why we're using uh and we're having an encodone has this thing filled and this the field can only be used inside the getter or the setter not uh not anywhere else also either getter or the setter and the same is true about the getter this is why you need to use the field identifier inside the getter also because it will generate the recursive call again now to to illustrate better because you maybe find the confusing this discussion about Getters and Setters what they really are they are equivalent to having two functions which update the first name property and return the first name property so they they are equivalent to having a function called Set uh first name and this function defines a parameter called let's call it new value is going to be of type string let's put curly braces and here we type this DOT first name equals new value and the geta equivalent to having a function called get first name and this is not going to take any parameter is going is we're going to say say explicit here that it's going to return a string because it's gonna only return a value and this is going to return the first name property so we put here this that first name so the getter and Setter that we have here are similar this is uh illustrative for you to have in mind to having two functions which are setting the first name property or updating the first name property and are returning let's change this to First and are returning the first uh the value of the first name property but because constantly and it's about conciseness it has this special syntax and they are automatically generated for you because uh as I said accordingly it's about conciseness so you don't need to declare those things every time you create a class so let's delete this so have in mind that under the covers is we have something like this so let's delete this now the arrow disappears also you can have a shorter way of writing the centering letter if you don't provide some additional code so if I delete this and this I can put here get equals field and um yes this is this okay because this is like having a single line a single function a single line expression function because we're returning the value to the function get so you can write it like this because or I I show you this photo because maybe you'll see a written in this way and you may be wondering why that's because this is like having a a single body expression function so you can write it like this if you want but again if you hover over this is still already done let's so let's press Ctrl G to have the previous code so this is our discussion about Getters and Setters and see you on the next video so now it's time to start a discussion about the late init keyword and how we can use the latent keyword with the our properties but first let's delete the code that we have from the previous video because don't need this code let's also delete this code let's delete those two objects that's and lazil is property let's declare it here so let's put the VAR keyword and let's also delete the default values here and let's press Ctrl alt form on the code now we need to provide the values here because we don't have default values for the last name property and the age so I'm going to type here dobbyn let's say age 23. now as you already know if you declare inside the class a property let's say that that property is called favorite movie and it's going to store the favorite movie of the user you cannot let this variable uninitialize so let's say that is going to be of type string so you cannot let this variable uninitialize you need to provide a value either by assigning directly a literal value here or by receiving the value through through a parameter defined in the Constructor but um that is not completely true because sometimes you'll want to to have a property declared inside the class but you don't have to assign a Twitter valued uh right away so you want to assign the value to the property later and to be able to do that you need to use the late init keyword and to use the late neat keyword you just type here late it and you have a suggestion later need and later need search for initialize letter later so what we're saying here is initialize let later this property favorite movies so you say in the to the compiler hey I'm gonna initialize this uh property favorite movie but I'm gonna initialize it later so believe me and uh to do that you just type user that so you whatever object you create with this class and you have a defined latent property favorite movie and you put equals and then you put let's say Interstellar here so now we've initialized our favorite movie property but we initialize the its value later so we didn't provide the value here directly inside the class either by as I said by providing a literal value or by providing a value through the parameter defined in the primary Constructor so this is how you can use the latent keyword if you want to assign a value to a property later so you don't want to assign the value directly or or you don't want to cite the the value more correctly said right away so you want to assign the value later you just put the latest keyword in front of the property and then you declare the property as you the way you declare a simple variable right and if you don't initialize this this property and you want a new output the value in the console so let's say that I put here a printerland and I type user that favorite movie and I don't initialize it and if I run this code now this favorite movie property is not initialized doesn't have a value we're gonna have an error and the error is uh it's very specific so you have exception thread main kotlin unofficialized projects access exception we have and then it says later need property favorite movie has not been initialized so it's very specific in saying that hey you didn't you said that you're going to initialize that property but you didn't and uh down here you try to to Output in the console the value of the favorite movie but we don't have provided a value and it's better to have this uh this is called an exception so it's better to have this energy Pro and initialize property access exception then having a null pointer pointer exception because this is why kotlin actually enforces this behavior of uh assigning values to the variable to the variables so it Cotillion forces to assign values to the variables and not let them uninitialize because if you don't initialize uh you don't provide the value to a bear to a variable or two property then when you try to access that variable or that property and let's say that you have an app that is gonna throw which is going to throw what is called the null pointer exception and that is very bad because those kind of excursions are called only at runtime and not at compile time so your app can work let's say completely well and when you press a button I don't know to to see the the favorite movie of a user then you get an error and adopt crashes so this is why you need to avoid those null pointer exceptions and kotlin as I said enforces this behavior of providing um values always to the variables to the end to the properties and if you don't want to provide the value to the property then you can use this late on it and it will show this uh different uh exception called latent property favorite movie has not finished so it's it's a different exception than the null pointer exception but with the latent keyword we can still have as I said that behavior of not initializing the variable but you still need to initialize it later because this one is called late init but this is not uh saying that the latent error that is shown here is not also uh having the same behavior like the null pointer exception that I talked about because the late init error that is that we have here if you have an app it will uh also Crusher up but the later neat keyword allows us to not provide as I said the value literally a little value here or a value through the constructed by the by assigning the parameter here with the value pass of the parameter and the is uh is our responsibility to initialize that variable later so that you don't get into the same problems that we talked about so we don't get this error so it's up to you to to declare a a property as late and eaten then provide a value later because if you don't it will also Crush you up when you try to access uh by uh I don't know in Europe somehow you want to access the value of that property so I always have a have a decent mind that you need to initialize that variable later also I should say that the latent keyword only works with classes and it does not work with primitive type so even though the as I said the integers and all the data types that we looked at and also the Boolean and Char are classes we cannot use latent adhered with them because if I put here in you can see that I have an error that it says latony modifiers not allowed on properties of primitive types because uh I'm not gonna get into much of details but all we need to know to know is that when the int class and all the Primitive types which are classes uh at least at the surface when they are compiled I think they are compiled into primitive types so they are not compiled into classes so this I think is the reason that you don't you can't use this latent in the keyword but for other classes because a string is is a data type but it's a special data type as I said you know in a previous previous video and because of that you can use the latent keyword and you can use the latent latent keyword with other classes so I can put here user if you want and it works because users is also class is this class that we Define here so it's good to to to remember this now I'm going to end the video and see you in the next video but first let's uh press Ctrl G to have the code that you had previously so uh now I'm gonna end in the video and see you in the next video so now it's time to start a discussion about companion object but to do that I'm gonna delete the class that we have here and I'm going to paste it inside our classes file because we're gonna need this class later in our videos and I'm gonna also delete this code because you don't need this code and let's say that let's create the class called calculator is not going to Define any properties you know it's going to have a simple function called sum which is going to sum two numbers so we're going to Define two parameters here a it's going to be an INT a b also on it n is going to return the sound so we put colon at the end of our parenthesis or function we put int because this is what you're going to return and we put calibration type return a plus b or you can put this in a single body expression function so you can put the code like this if you want so we can put here uh you can also delete a type you can put here equals and this will work but I'm gonna keep it like this now if you want to use this sum function that is defined in this uh class calculator first you need to create an object without class so we type here Val I'm going to call it calculator and I'm gonna create here a new object calculator Constructor doesn't have any properties any parameters and if you want to to call that some function we need to use our calculator variable or I'll confrater object or reference and we put dot like we did in our research so use the dot notation so now we're calling the sum function on our calculator object that we created online too let me put when we call our function sum inside the buttons you pass two numbers let's say 5 and 10. and uh let's capture this value that is returned by the by the function in a variable so let's put here Val result because that is going to return the sum of 5 and 10. of course that you can put that in a printerland statement if one but I put it in this elaborate way to to make more clear what you're doing and here I'm going to type println result so now if I run the squad you're gonna see 15 in output line in the console so let's increase this so we have 15. and the way we did it is we created an object like we did so many times then we want that object use the dot notation to curl that function on that specific object on this object and that function takes as arguments as easy as values to its parameters to integers we pass 5 and 10 and then it returns as well and we retain we we capture that value in the result variable and then we want to put that value in the console and get 15. but um if you think about the way we did this thing is that the only way we can call the sum function is by creating an object and then calling the function on that object but it doesn't make a lot of sense if you have a calculator class to call to create every time through our code every time you need to use the sound function to create an object throughout your code a better way it would be if you could call that sum function somehow without declaring uh without creating an object and then using the the object to call the function and to you to do that we need to use what is called a companion object and to use a component object we go inside our class we type companion object so we can press enter to fill in a component object for us or you can type that then we put curly braces and inside the curl brace you put our codes and in this case we're going to put our sum function now you you're going to see something now we have an error here now this function this sum function doesn't belong to an object to an instance that is created with the class calculator instead it belongs to the class itself and not to the not to any object that we create those the variables and the functions that are the functions that are declared inside the component object are also called class variables or class functions because they don't belong to they don't belong to a specific object that you create with that with that class instead they belong to the class itself so you don't need an instance to call that function and uh that uh implies that we can't use it with an object because it belongs only to the class and let's see how you can use it using the class without creating an object we just type calculator dot sum and here you pass again 5 and 10. so we just use our name or the name of our class we put dot sum and now we can use the function without uh then without us needing to create an object and then calling the function on that object so this is a very powerful because uh you will need this in your code sometimes when you don't uh it it actually doesn't make sense to create an object every time you you call let's say a sum function for a calculator now we can also retain that value that is written in a variable also result put equals now we can print this in the console so we get also 15 but this time we didn't create an object we didn't create a new instance and we call that we call the sum function on that object we just type the calculator class and call that function on directly on the class all right so this is how you can use the companion object and this is also true for a variable so if you put a variable here let's say Max and you put an arbitrary number here let's say 100 we can call this variable also by typing calculator the name of the class Dot and have our Max variable uh like in contrast with how we did the how you call the the properties in the past by creating an object and using that object to curl that property on that object in this case you just use the class and call the the variable and this also can be can be useful if you have some constants to which you want to use in our throughout your quad so let's delete this so you can use also with variables and if you think about uh uh at our one of our first lessons about the data ties when you look at the minimum and maximum value I I type something like this Val Max and I to get the maximum volume I type int that max volume and this is using also a companion object because as you can see the integer class because the Primitive types are also classes at least on the surface not when they are compiled on the jvm they also use companion objects like we have here to to get to to get the properties and to get the functions because you don't we didn't create an instance of our integer of with our integer class and then call that max value on the object in fact if you hold control on this integer class and if you actually hover over it and after you hold Ctrl it says public companion object of int so if you hold Ctrl and if you press and if you press click now it will open this primitives.kt file and inside primitive.gt if I have our end class and we have a companion object inside the companion you have this public constant value we're going to look at the constants in the negative but the point here is that it's using the companion object to to declare is declaring the the this minimum value the maximum value inside The Company audio so that you don't need to create an instance an object every time you need to use them so this is our discussion about compounding object and see you on the next video I'm going to close this file now and if you if you want you can look you can look in that Primitives file if you want just take a look look what is there so see in the next video so now it's time to start a discussion about Singleton but first i'm going to copy this code I'm going to copy this class with the companion object and I'm going to paste it inside the classes file and if you don't have this code Discord because you create a new project just type the code that I'm going to type in a second so let's delete the code inside the main function now what is a single then a Singleton is a design pattern in kotlin with which you want to have only one instance of a particular web object so you want to have only one instance of a particular object and you want to have that instance available globally tutorial program so you don't need to create an instance every time you need to use that that object in a different part of your code and there are project practical reason for having only one instance of a class let's say that you have a database you want to you want to have only one instance of that database which creates the database which gives the data and so on because if you have multiple instances if you able you are able to create multiple objects with that class then you'll have multiple databases in your phone or on our PC and that is not good because you're using more memory than you should and you have a duplicate duplicated duplicated and unnecessary code so to solve that what we need to do is to create only one instance of a particular class and uh having this example in mind this is what we're gonna do next and first I'm going to show you how we we did the in the past how we created a Singleton without having the object keyword so you go down here and first we're going to create a Singleton in the world wave so we type here class you're going to use our example database not going to create a real database we're gonna just use this as an example and to make to restrict the creation of instances with this database class we need to make the Constructor private so we type private and uh when you use an access modifier with the primary Constructor you need to use the Constructor keyword other otherwise will have an error so if I delete the Constructor keyword here I have an error which says after modifiers or Pro of primary Constructors so we put Constructor and inside the inside the glass now because we cannot create instances of this class that means that we cannot uh access any of the properties or the functions of this class and to to to have access to a function which is going to return an instance of this class we need to use a companion object because with companion like this you can have properties and functions being allowed to being to be accessed outside of the class without creating an instance and here we type again the private access modifier we call this instance and it's going to be a database a nullable database should be valid there instance database and as I said nullable so we can assign null to it then we Define a function called get instance and this function is going to return an instance so for instance of our database class only one instance one one single instance not multiple instances and to do that first to check to see if the instance is null so if this is the first time that we want to access this uh instance then it's gonna return true if not it's going to return false so it checks if it's equal to null if it's equal to null so our instance hasn't been initialized you know type instance equals to database right so if the instance is equal to nulled that means that the instance has been initialized we initialize the database so we can initialize the class inside the class we cannot initialize it outside else so if this condition fails the the code below is going to be red else you're gonna return the instance so if the instance is not null and this uh this code is not going to be a this condition is going to be false and the code will not be as a good inside the if it's gonna we're gonna return the instance but here you go you should return the database and it should be a knowledgeable database what is our Arrow disappeared let's delete this let's press Ctrl alt there all right now how we're gonna use this first we type here Val instance input equals and type database Dot and I'm going to use our function get instance and uh if we we print this instance in the console so we type here instance if you run the squad so now we're calling the fan gets instance inside the company of object we get this code that this code represents the location memory of the instance so we have this code here and if we try to instantiate this class so we put here the Constructor if we do that then we get an error because the Constructor is private so we cannot create an instance and when you call the get instance function so when we did this first check to see if the instance was equal to null and it was equal so now then created the instance and then it returned the instance but if you call this function again so let's call it instance2 because database that get instance now this will evaluate to false because the instance is not equal to null we have an instance and it's going to come down here and it's going to return the instance they're already creating instance so if I put a printerland here and I'm gonna output the instance tool you're gonna see that there is no instance to you have the same instance because it's you it's returning already creating created the instance so we have the same code here meaning this translates to that you have the same instance so no matter how many times you use database I get instance if it's the first time then it's going to create the instance and it's going to return in essence if you call that again like we do for instance 2 then it's gonna return the already created users so in this way you have the same instance no matter how many times you you call the get instance function because it will always return the same instance because we because of our logic that we created here but there is a shorter way to achieve the same thing by using the object keyword and this is what we're gonna do next so let's close this now let's see how we can create a Singleton and which is going to have the same behavior that we created here so it's gonna be only one instance using the object keyword so I'm going to type down here object I'm going to call it database now let's delete this code because we cannot have a two objects which have the same name and we cannot have a Constructor here because it's a Singleton so you put only curly braces you can have properties and functions inside the Singleton created with you with the object kios leslie.com inside Dimension frame function too so uh Now by just typing object database now we have the same thing that we had previously just by typing object and database so this will always return the same instance and we have only this code object and the name of the object so the in the instance of the object is going to be created the first time you call it and we can put an initializer block to have some code to be executed here so let's put a printerland let's say yo this is a database created and to you to use this just type let's put a printerland and type database and now if you run this and the first time you call the Singleton that time the Singleton is going to be it's going to be created so I have database created then we have this code which represents the or Stringer is the string representation of the object and if you press Ctrl D here look what happens we have database created so because this is only one instance this object is a single turn it calls the initializer block only once when it initializes itself so when we call the database for the first time it is initialized and it calls the code inside the init block and after that it only it output this thing representation the second time we call the database we don't have database created because the instance was already created and the initializer block is not called again because we have the same instance so if you can press Ctrl D here multiple times and we're gonna see that we have the database created with only one one uh once because that is called only when the only when the object is created for the first time so on this line in the next slide we have the same uh the same objects we have here this this is why I have the same code because it's basically the same instance so as you can see this is a lot simpler and um more concise than the code that had previously so this is how you can create a Singleton in kotlin this is why this is how we should do it so see in the next video so now it's time to start a discussion about lazy initialization but first i'm going to copy this Singleton and solid hour classes file and if you don't have this file because you created a new project again just type the code that I'm going to type in a second so I'm going to delete this now what is lazy initialization lazy initialization is used when creating an instance when creating an object is expensive and the expensive in the programming context means that it will take some time it will use some memory and in that case it's recommended to use lazy initialization and to illustrate the lazy initialization I'm going to use our user class so I'm going to compare user class inside order main file not because I can create here an object by having the file here but because I want to put the code here to make clear what I'm doing so I'm gonna delete the code from here and if you don't have the file just create a new class called user Define the properties for its name last name and age I'm gonna delete this because you don't need this and inside our user class I'm going to put initialize an initializer block which is going to be called every time you create a new object and here we're gonna put a printer printer print line statement which is gonna say user when I call the first name property so the value that Sparks the first name property was created so let's create a new object here let's call it user1 equals user now let's put some values to the properties of the Constructor let's say Alex now if you run the squad we get in the output user and the value for the first name property Alex was created if I press Ctrl d and I change this to user 2. and let's change this to a generic name user for the last nameless pass just the last name text and let's skip that age so if I run this code now because now on the line 3 you create a new object the initializer block is going to be called again because we create a new object which is user user was created now to initialize our user 2 with the lazy initializer we just delete this and to illustrate how the initializer block works we delete this and we put after user to buy so we put the keyword by and we type lazy and as I'm typing you see that I have that black lace press enter and put the curly braces and inside the calibration we create our object so user and here to pass the values to the properties so let's put user one let's pass last name and for the age let's put zero now previously when the user was initialized in the world way I found out the user user was created so the initializer block was called when he created the second level but now if I run this code look what happens we get only our first object we get the initializer black only called for our first object and for our second object initialize using the lazy initialization we don't have the initialize of law because the object is not initialized is the object is only going to be initialized when you use that um object in your code so if you use that object somewhere in a code the object then is going to be initialized and it's going to be used so if I type here a println which says user DOT first name user tool now if I run this now because I know I'm I am using the user 2 object now the user to object instance is going to be created and then I'm gonna see user 2. first name so now we see user let's see user 1 was created so the initializer block was called because when we called the the print line user to that first name then in that at that moment it created the instance and then it outputted the user one so this is why now we see here user one one was created and previously we didn't because now we're using the user to object in our code so unless you are not using the the instance the object that have created using the lazy initializer it is not going to be initialized so this is initializer this is initialization by lazy so see in the next video so now it's time to start a discussion about enum classes but first i'm going to copy our user class inside our classes file now I'm going to delete this class and also I'm going to delete the code inside the main function now what are the num classes in on classes are used when we want to represent a fixed set of values so when you want to represent we want to create some constants you should use genomes because enums are like constants but they are more powerful because you can they can have properties and they can also have functions and you know I'm sorry usually used in um if conditioners or if statements or in in the when statement or if I want to call it the if statement expression or when statement expression now let's see how I can create any number class and to create any num class just type here enum the keyword enum and as I'm typing I have some suggestions then we put class and let's call this uh you know class directions Direction actually then you put curly braces and inside the enumclass direction we Define our enum values so here we Define North put comma enter South you can put them in one line just to have comma between them East and west right so we have our enums values defined inside our Direction enum class and those enums values that we have here here they are instances of our enum class Direction so they are an instance there an object created inside the enumclass direction just that they have this different name and as you can see the name of the you know values should be all the names should be in uppercase letters now let's see how we can access those you know values to access the you know values we can let's put the printer line here we type Direction then we press Dot and we have some some suggestions here we have west east north and south so we have our enum values suggested so let's choose West let's output this in the console so we get West so this is the enum value West and um let's press Ctrl d let's change this to East so let's change this to East let's change this to North and South now if you run this code we get our enum values West is north and south so this is how you can get the you know the how you can get the genome values that you define inside your genome class now we can also you can also pass you can define a Constructor here for our enumclass and Define some properties like VAR let's call it Direction of type string and VAR distance and this is going to be an integer now if you hover over here you have some underlines and the underlines if you have always says that you Nam has not the full Constructor so now because as I said those elements values are instances they are objects created inside the original class now we need to pass some values to the properties that we Define here so let's pass some values here so let's press let's type here first North again I'm gonna speed up this now a little bit all right so now what we did here we passed some values to the you know values Constructors because in in up here in our enumclass direction we Define some properties and those properties because the enum values are objects they are instances for a number directions even though they have those different names you need to pass to the constructors then some value so we pass here north south east west and password for for the densest distance 10 20 50 and 40. now let's see how we can Loop through our enum's values and to do that we just delete this code and what if and here we add the four groups so we type four let's call it the Direction in and here we type Direction our enorm class dot values and this is going to return an array with all the enum values that are defined in our class now let's put calibrases and let's draw the printerland and let's put in the direction so now if you run this you'll see the same output but in the order that they are defined inside the class so we see the same not the same output because they are outputted in the order in which they are defined in the class so we have north south east and west and this is how we can Loop through an enum to through the enum values of a num class so this is how you do it so now let's delete this code now if you want to access the arguments that are passed to our enum values Constructors we just first put a printerland to Output the values on the console and type Direction so our rename class Dot and we choose our in our value let's choose North and from here and here now we type also that and now we have some suggestions we have Direction distance and we also have a name and name is uh is a variable which is not defined by us so we've only defined those properties direction and distance but name is variable which is built in in the enumclass similar to the the the direction that values which return the array is the the direction that values values was also uh property which actually it was an array property which was built into the enumclass so we didn't create that it's provided by the enumclass so this is why we have that name there so let's put Direction let's press Ctrl d uplicate this code and let's change this to the instance let's press Ctrl D again and let's also print that name which is the builtin variable which is the builtin variable provided by the NM class so let's put here name now if we run this code get North so this is the value that you pass here we get 10 and then we get North with capital letter so so we get the value that we passed here for direction and distance which are defined in Direction class so we get the value spots for this specific you know more volume and then we get the North and this is the builtin um variable which is uh provided by you by Dynam class but as I said you can also have functions so let's have a function which Returns the direction and distance so let's type here fun we call it print data because it's gonna print the data of a specific in our value it's not going to take any input put curly braces but now we have an error here that is because uh when you declare a function inside the nenum class you need to provide a semicolon for the last in um defined in our class so I need to put here a semicolon and there will disappear and let's print the data here let's add the println let's put quotation marks as for Direction equals dollar sign Direction and distance equals dollar sign distance now if you call this wanna our wanna enam valueless type direction that let's say West Dot and now we have our function print data so this print data function is going to put in the data of the West enum that is defined here so it's going to Output West and 40 in the console so you know if you run this code we get direction West and distance 40. so this is how you can use functions inside the noun classes next let's see how we can use our enum Direction and generally how we can use enums with the when statement expression so I'm going to close the console I'm going to delete this code and the print data function works for all of our Renown values so let's delete this and here I'm going to Define a variable it's going to be a Val it's going to be called Direction we're going to put equals and hero type Direction our enumclass let's choose East so now the enum actually is the west east so now our Direction enum is is going to be stored in our Direction variable let's use the when statement expression and we type here when Direction then you put curly braces and here we type Direction Dot East I'm gonna put Auto execute this course so print the Len the direction is yes and we'll do the same thing for the next one so let's press Ctrl d let's change this to West North and South so this is how you can use the enorms with the one statement now if I run this actually I should change the text there but I'm going to change it so let's close this to change the text here now if you run this you're gonna see the direction it sees because this condition is true our Direction argument here is going to match with this Branch so it's going to evaluate true and then it's going to execute this code you can pull calibrations if you want but as I said in our discussion about the when statement expression you should do scary braces if you have multiple lines of code in our case we have one single line of code but you can put curly braces if you want and of course that this Branch will always evaluate to true because here we type direction that is into our Direction variable literally directly and this value doesn't change but in real up this value could come from a database or from the user input and in that case you need to use the function which is also built into the enorma class and that function is called value of so we type Direction dot value of and this value function check his checks to see if our value that we pass here exists inside our enumclass so it checks to see if is defined here and it all it also returns that value so if I type here yeast now if I run this code we get an error which has no num constant direction that is because all of our enum values have they are defined in uppercase letters but if I put here that uppercase and if I run this code now we get the direction assist and uh this value that we have here is this value as I said could come from a database or from the user input and the direction that value of is going to check to see if this you know value exists in our rename class and it's going to return that value in our variable so it's going to assign that value to our variable so see you in the next video so now it's time to start a discussion about inner classes so what are inner classes in our classes are classes which are declared inside another class and they are generally used when you know that there is a very close relationship between two classes so when it doesn't make sense to put two classes separated then you should use inner classes and let's look at an example and we're going to imagine here that we have a list View and this list video list view is gonna display some items in a list in on the screen and here we're going to use inner classes because for displaying the each individual item we're gonna create a list view item so first you create a class called list View foreign we Define a property called items and it's going to be an array of strings now we put curly braces and inside the class we type the keyword inner then class and now we create a class which is going to represent the individual items in the list view so we put type here list view item put the the primary Constructor but we put not we don't Define any properties and then we put curly braces and this inner class let's use gonna have a function called display item and it's going to display the value the values of an item of other specific position so we put here position let's say Define a parameter to our function it's going to be an end and we're just gonna type here print line and the inner classes are have access to the properties of the outer class so inside our inner classes that we have here we can have we can access the properties that are defined inside the outer class list view in this case we have a single property called items and here we can type items and notice that I can use the items property which is defined in our outer class list view we type position and this is going to return an item at this position which is passed as an argument here to to do our parameter position and we go up here and we type Val list View because we're going to create an instance for this View type list View now we need to pass an array to our primary Constructor to the property item so we type here array off and we Define some generic names here let's say uh name one and name four now how can we access the display item function which is inside our inner class list item list view items this this should be list view item not items so let's change this go right click on it and go to refactor and rename let's call it the items press enter now to access the display item function which is inside the original class list view item we type list View so our instance our object list view Dot list view item and then again that and now we have our function display item and we can pass here let's say yo let's say uh two now if you run this code so get in the output name tree and this is correct because it entries the other index too and this is how you can access the display how this how you can access generally a function inside then uh in inside an inner class you just create an instance of the outer class then you call a you call the name of the class of the name of the inner class and then you call the function Auto so see you in the next video so now it's time to do a challenge using the knowledge that we have about object oriented programming and the challenge is to create a class which is going to represent a bank account of a person and this class is going to have three properties the first one is going to be called the account name the second one is going to be called the balance and the third one is going to be called transactions and it should be a multiple list also you should create functions for deposit and withdraw and also function for calculating the balance and you also you also should add the the checks for checking to see if the amount is uh when you deposit the amount is greater than zero and all of that stuff so do this Challenge and then watch my solution so my solution is this I'm going to create the class and for this challenge you should also have in mind the discussion that you had about access modifiers so I'm gonna call it account and I'm going to Define here a property called the we're gonna be called the Val is going to be called the count uh name and it's going to be of type string of type string and we put curly braces and inside the class I'm gonna declare the next two properties and those one uh first I'm going to declare it without the access modifiers because IntelliJ probably is gonna figure out that we need to put access modifiers on them so I'm gonna type VAR balance and I'm gonna assign 0 so this is the default value and VAR transactions and this is going to be equals to a multiple or Multiple List of int because this this is going to store the transactions so these are the three properties of our class now I'm gonna create the first function which is going to be called deposit and this function is going to be used to deposit money inside our bank account and it's going to have a parameter called the mount it's going to be of type end and first we need to check if this amount is greater than zero because you don't want to deposit uh negative value so if amount is greater than zero and we choose greater than zero because we also don't want to deposit zero so this is why I put greater than zero then if it is greater than zero then I'm gonna add that to our transaction list that add amount and then I'm gonna say balance I'm gonna update our balance I'm gonna put plus equals amount then we're gonna add the print line which is gonna say I'm going to put the quotation marks dollar sign I'm gonna type amount I'm gonna put dollar sign this dot balance so I'm gonna output in the console what is the balance but if the amount that is passed to this function is a negative sum I'm gonna go in the else part and we're gonna say another print line here which is going to say cannot deposit negative sums so we're gonna put here okay cannot deposit negative sums so this is our deposit function next I'm going to create another function and this is going to be called withdraw and this is going to be used for withdraw withdrawing mine so we type fun with draw and we put parenthesis and this is gonna take a parameter called with draw wool so uh it should be like this and it's going to be an integer we put curly braces now it should be with with here with with draw now we need to convert this into negative sum because now we're uh withdrawing money from autocon so first we need to check if and we're going to put minus because I'm gonna convert this into a negative sum withdrawal is less than zero so if this is a negative sum which is going to be withdrawal you're gonna I'm gonna add to our transactions is transactions that add and you also put the minus sign so you put minus with drawal because now we're adding now we're uh we're taking money off the of our account then I'm gonna put this that balance my uh Plus equals minus withdrawal because now we're taking money and then we're going to add again a print line it's going to be this one so I'm going to copy this but now this is going to be the withdrawal else if this is not a negative sum so I'm gonna put else I'm gonna type put in the line cannot wait draw negative sums so if he tries to withdraw a negative sum then we're going to say cannot withdraw a negative sum here we put the minus because we we're taking money out of our account so we need to check for uh that's why we're checking here if this is less than zero shouldn't be negative here and we're going to create another function and this is going to be called calculate balance so we type here fun Let's uh bring this fun calculate calculate balance this is not going to take any parameters and it's going to return an INT put curly braces and I'm gonna put this that balance to zero because I want to calculate the balance I'm going to add the transactions to this property balance so here we're gonna say and here we're gonna loop we're gonna type four turn suction in our list of transactions so for transaction in our list of transaction I'm gonna type this Dot balance plus and equals transaction so our transaction and then we're going to return the balance at the end of our Loop when we end we ended looping so return this Dot balance so this is our solution to the challenge and let's um let's create an account and let's pass some values here so I'm going to type here Val Alex account I'm gonna put equals account I'm gonna put now I'm gonna call the primary Constructor so I'm going to type here Alex and we still use I'm still using my name here but so I'm going to type here Alex account Dot deposit so I'm going to deposit let's say one thousand and uh I'm gonna type OLX account that withdraw I'm gonna withdraw 500 then I'm gonna put Alex account and I'm gonna put uh deposit the negative sign let's say minus 20. and Alex account Dot that we draw also negative sign let's say minus 100. now if you're on this code foreign deposit balance is now 1000 so we have our call card called from our deposit function then we have so I should I didn't change the text here so that's why it's saying uh this should say with uh withdrawn so uh sorry let's change this to with drone so let's run our code again so get 1000 deposit balance is now one thousand now we get our uh correct output to get the then 500 withdrawn so get our call the call from our withdrawn function we withdrawn balance is now uh 500 then then you get cannot deposit negative sums cannot withdraw negative sounds because we passed the negative numbers to our deposits and withdrawal function and here we're checking to see if those are negative or positive so this is our solution to our to our Challenge and I hope that you enjoyed this and that you solved this and this is not again the best solution this is just my solution probably you'll find you figure out a better solution maybe your concern better and more concise solution than this actually I forgot before we end our video Let's actually called also our calculate balance function so I'm gonna type here uh Alex account dot calculate balance and this is going to return an integer so I'm gonna type here Val because that function returns something so I need to capture that in a variable so I'm going to type here valve balance equals Alex account so no other print line here and there's gonna say balance is dollar sign balance format the code now if we run this code now get our previous output to 1000 deposit balance now one thousand five hundred withdrawn balance is now 500 then cannot deposit negative sums and cannot withdraw negative sounds and then get balances now 500 so our code works well so this is our code one more thing that I forgot is that I said at the beginning of the video that you should have in mind the discussion that we had about access modifiers when doing this challenge and I forgot to to add the access modifiers for balance and transactions because now what can I do for balance I can use our Alexa account s and I can type here balance and now because that is uh actually that is not really probably because when I talked about uh get us unsetters we said that that when you access a property you always access access that property through get a run Center so we never access directly the getter and the property but uh still you should not make that that public because by default if you don't provide an access modifier they are they are by default public so if I type here now account balance as you can see I can call that and I can type here 1000 and I can deposit now I can change the balance of the account directly from here and if you hover over here uh IntelliJ figure out that you should make this private so make this private the balance and also the transactions because you don't use them inside the primary Constructor and they are used only through the to the functions that we defined here the because of that you should you should declare them as private because you use them only through the function that you declared inside the class so declare them as private and now you if you hover over here it says you cannot access balance because it's private in account and now we cannot change the balance from outside the class we can only deposit or withdraw uh sums of money from our bank account by interacting only with the functions and not by calling the property directly and assigning a new balance to to the property so make them private and this way you cannot uh you don't uh you don't access the property outside of the class and you change data directly the the value of the property again it's not really direct because the code that you had previously so this code actually is calling the setter here but still you can change the value of the balance but now because we made that private and the the compiler is smart enough to figure out that because they are not declared inside the primary Concepts and they are only used you only interact with them with the deposit and withdraw and uh calculate balance functions so we don't use them outside you don't have them also declaring the primary Constructor it knows that you should make them private because you interact them only with the functions and now we have this underline because it's private so we cannot change this balance now from outside the class we can only interact them again using the functions so I'm gonna delete this and now see you in the next video so let's delete this so actually I'm gonna let it there because it's uh good to see so now it's time to start a discussion about inheritance so what is inheritance inheritance is the concept in the quarterly programming context with which you can create a class using another class so in other words you can get all the functions and properties that have that the class already has in your new class and in addition to the getting all the functions in properties in uh in your new class you can add some new functions some new properties which are specific to this new class but they aren't for the also this the class from which you are inheriting is called The Base Class the parent class or the super class and you might be wondering why is this useful why you want to do this let's say that you have a very big class which performs very hard task and has a lot of functions in coding but you want to create a new class which is slightly different from this class what you can do is you can get all that code copied in the new class and then you can add your new functions or new your new Behavior to this class but dust is not recommended because you have duplicate code what you can do instead is you can inherit all the functions and properties which this big class already has and in your new class you can add the new functionality the new Behavior which is specific to this new class but it's not for the base class so in this way you can uh you you avoid the duplicated code and you increase the code reusability and for that I'm going to show you in an example and I'm going to create two classes one is going to be called car and one is going to be plain so we create here a class we go down here we type class I'm going to call it car is going to have some properties the first one is going to be called name this is going to be the brand name of the car the second one is going to be color also string engines the number of engines that this car has gonna be an integer and Val this is going to be doors so we're gonna store the number of doors all right we put curly braces because I'm gonna add some functions to this class to function actually fun move and uh fun stop and here you're gonna say print line quotation marks dollar sign the name of the car is moving similarly down here in the stop we're going to say the car has stopped car has and we're gonna create a another class called plane which is going to have also Val name we're gonna be a string a vowel color also string Val engines an integer and the valve doors unint put curly braces and we Define those two function we're going to copy those I'm gonna paste it here so now what we did here is that we created two classes they both both have uh properties for the primary Constructors and but as you probably already noticed we have the same properties we have the name here we have the name there we have the color there we have the color here the color there the engines also we have here and there and we also have those functions which are almost actually are the same so we have what I said at the beginning duplicated code so it doesn't make sense to put this code here another another way to do this is to create a base class a generic class called vehicle which is uh and usually you create the generic class when you know that several classes we are gonna share those properties and those behaviors so a car in the plane both are Vehicles so we can put here instead of declaring the the name and the caller inside the our inside our classes car and plane you can put this in a vague vehicle uh class in a base class and we can inherit those properties in our classes instead of declaring them your inside our car and playing class so we can put here Val name it's going to be a string and the Val color also string now I can copy those two let's put curly braces here and I can paste it paste it here so now I can delete those those two functions from our classes and what we can do now is we can inherit those properties so we can delete those properties that we have here we cannot we will as you'll see you'll need to declare them as parameters but uh they are not they're not going to be as properties in any they're not going to be as properties here now what we can do is that we can inherit this shared those share the functions and those shared properties because both the car and the plane have a function to move have a function to stop the baby they both share a name they both share a color so they both share those properties and uh functions but uh as we did previously is to put them inside the the the classes would not it's not good because we have a duplicated code and in this way we put this code here and now we can inherit this code so we can have this code directly you can you can have this code the being uh being accessed inside the car and plane without declaring them in our classes so to inherit from our class first you need to Mark the class from which you want to inherit as open because by default they are they you cannot inherit from a class so if I enter in head from a class we go at the enclosing impurities of our primary Constructor we put colon and we type the name of the class from which we want to inherit and in this case it's going to be vehicle now if you hover over here it says that this type has a Constructor and thus mods B initialized here and and next you say this type is final so it cannot be inherited from and that means that we cannot inherit from this class unless we mark this class with the open keyword in front of it so we need to put here open and now if we hover over here now we don't have that error you only have this here which is this type has a Constructor and dust must be initialized here and that basically means that it says hey I'm trying to use this vehicle class I'm trying to but in order to use it I mean I need to initialize this vehicle class so we need to pass some values to the construct of the primary Constructor that is defined here you need to pass some values to the name and to color and to do that we Define here name we type name actually dot let's press Ctrl Z let's put a space and we type name we put comma then we type color and notice that we don't have the VAR or the Vault keyword in front of them that is because the those parameters that would have here because they are parameters because they don't have the value of our keyword they they uh they they they have to be declared only as parameters because the properties are going to be declared and they are declared by the primary Constructor of the base class from which we are inheriting from and because of that we don't we we don't we don't need to declare the property again here as you can see if I put the VAR keyword we have an error says name hyzer anyway what that means that we cannot have the property declared here because the properties uh already declared inside the Base Class inside the vehicle class from which we are inheriting from what we can do here is Define the parameters and the value that is passed to those parameters so the primary Constructor of the class cards are going to be passed to the to the vehicle primary Constructor so hero put the primary Constructor so you put two parentheses and we type name and this name is this one from here so we type name then we put comma because we need to pass a value for the second one for the color and the type color and this color is this color here so we type color now if you go up here let's say for let's look first as the actually let's also inherit from inherit inherit also one in on the plane class so we put colon also here we type vehicle and now we need to also to Define here the parameters the name and the color so we type name and at the time you can see that IntelliJ has given us some hints so if I type here color it says that color string so it's very helpful put colon we pass those values to primary Constructor of the base class so we type name color and now if I go up here on I create some instances of our car and playing class so we type here Val car let's put equals this type card let's choose for the name BMV and the for the color let's say red for the engines one for the doors four now I'm going to create also an object with our plane so let's press Ctrl alt form on the code valve plane equals plane so our class we type here for the name for the color let's say or white and blue and for the engines for and for the doors let's see also for now if I go down here and I type here car dot if you look here you see that you see that we have the function stop and the function move but we didn't declare them here you deleted them previously but because we are inheriting from the vehicle class because when you are in editing the properties and the functions from the class from which you are inheriting from are part of the new classes so the the the move function in the stop function they are now part of our color class similarly it's the same in the same the same here the the the the move and stop are uh are part of the class plane so if I type here car dot move and car dot stop and then plane dot move and plane so look like then now I can call them like they are declared inside the our current plane but they are not there but because we are inheriting they are part of the class so you can think of you can think of this thing that we have here as a single entity so it acts like a single entity so now if you run the squad we get in the output band there is moving then they have stopped bearing is moving doing has stopped and uh this uh we get this output because as I said those functions are part of our classes and they are using the name so in this case the name that is passed to the car this name that we have here been there is passed to the to the primary Constructor of the base class and then it's used here so it's calling the movement save and there is moving so in the same way for the for the plane we get the same output it gets the value that is passed here viewing and then it outputs the viewing is moving and then it has stopped but we can do even more we can override those functions inside our class so we can create a version which is inside the base class from your inheriting we can create a version of this function which is specific to the car or which is specific to the plane and I'm gonna look at that so now I'm going to override the move function from our Base Class vehicle inside our playing class because I want to make the move function specific to the playing class so I want to provide I want to provide an implementation of the move class which is specific to a plane so how is our plane is moving a plane is moving by flying so I'm not satisfied with only this generic function which says the name of the vehicle is moving and to override the function you first need to Mark Mark the function similarly to to the class we need to mark it with the open keyword so we type open because kotlin wants to make things explicit so we put open and now we can we can we can override that function inside our plane class so we go to to override the function go to code generate and here we have vehicles in harsh code tostring and go to override methods and you you have those equals hash code into string and those are here because every class that you create in Kathleen is implicitly inheriting from the any class but we're gonna look at that on but more more on that later because you look at that in a different video and we have our function move and stop so the the idea is telling us that those are the functions which can be overridden inside our plane class from our vehicle Base Class so we choose move we press ok and you have this super dot move we're gonna see middle what is this and you can also override it by just typing the keyword override and you can override the function so you can type here override and while I type in you see that we have this override fan move stop or and have also those so we choose move and I have the same thing now super dot move means that call the function so super means call something from our base class in this case call the move function from our Base Class so we're gonna let that here but in addition to that we're going to add a new function so we're going to type here fun flying because the plane is flying and we're just gonna have a simple print line which is going to say put quotation marks let's bring this down a little bit a plane is flying so now I'm gonna call this function flying inside our move function which was overridden so we type flying flying now if we run this code look what happens if you look in the output to get when they is moving when they have stopped and then we get the apply the plane is flying and then we get bearing is moving and bearing has stopped so what what has happened here now because we where when this function move is called here on our object plane created now it's using our own implementation of the move function and after that so it's using our own implementation it's calling the flying function that we created here because a plane is moving in a specific way is flying and then it's calling super dot move and super dot move is calling the function from the base class so it's calling the function from here so by doing this we made our function specific you make we make the we made the function move specific make the function move unique to the plane class because a plane is moving in a specific way and we can do the same thing for the the car class so uh now you may be wondering why why I didn't declare the inside our Base Class the engines because they are also present in in both classes because when you create a generic class you should only include the commonly used functions commonly used and shared functions and the properties so uh all all vehicles have a name and the color but not all vehicles have engines so this is why I put the engines here so in addition to the name and the color which all vehicles have we added some new properties which are specific to a car similar here in addition to the name and the color which all vehicles have and we've inherited that from our class we add that also engines and doors which those things are in addition they are specific to a plane and more we also override the move function because we're not satisfied with the with the simple move function from our Base Class to include to provide our own implementation of how a plane is moving so you can see that by using an inheritance and adding new properties are the new function you can create more specific classes you can inherit you can also inherit from the car class to create a more specific class you can create a Tesla class and so on so this is what inheritance is and see you in the next video so I thought that's a good idea to show you another example with inheritance and I'm gonna go down here and I'm going to define a class so I'm going to type the keyword class and I'm going to call it View and this view is going to represent a view in uh which is used in Android and if you want Android is just a rectangular area on the screen and it's responsible for drawing and event handling but you're gonna mimic as I said what the view is and uh you know Android or not going to create a view like the one that is in use like the one that's used in Android and we Define the primary Constructor but we're gonna not Define we're not going to Define any properties the primary Constructor and this view is going to have a simple function called Draw and it's going to be responsible for drawing this view on the screen so we type draw and create a function and we're gonna add the simple a simple print line here which is going to say drawing The View so we put here quotation marks drawing The View and uh we're gonna mark this class as open because I want to inherit it from it and we're also going to Mark the function open because I'm going to override that function in the in the next class and because this is a generic View and it's going to have this draw function only this function what you can do let's say that I want to I don't want to create a simple uh a simple view which is just a rectangular area on the screen but I want to create something more specific let's say that I want to create a button in that case instead of creating the button the button from zero because this View in Android has a lot of functions and properties which are responsible for creating the view for handling the events and so on so um because here we have on your simple function but the real view has hundreds of functions and instead of creating our button from zero we can just inherit from The View and we can inherit all the functionality that the view already provides to create a generic View and we can add some unique characteristics characteristics which are specific to a button and in in this case in this way we increase the quad reusability and it's more easy for us to to create the button than rather than creating the button from zero because the view already provides all the tools that you need to create a generic view only we you're gonna inherit all that behavior all that properties but I'm gonna but we're gonna change it a little bit so this is what we're gonna do with the inheritance so we create a new class called button so we Define the primary Constructor and here you can Define some properties which are specific to a button not not just to a generic view which is a rectangular area on the screen so we put Val text and this is going to be a string so our our button will have a text which can be plugged in or signed up and also it's going to have orientation because it's going to be one on a place on the screen on a specific place on the screen and this is going to be a string of course you just only Mimi only mimic the View and button which are are used in Android this is why we have so many we see we have so little properties and only a simple function function in our view draw and we put uh here colon to inherit from our view because I want to inherit all that functionality all that properties that a view provides but I wonder is just to change it a little bit to make it more specific I want to make a button and of course as I said this is just uh an example we don't have but in a real in a real app this will have a hundreds or thousands of line of code and we can inherit all of that behavior or that functionality in our new New View which is a button but you can override some functions and you can provide some you can create a more specific view than a general review so you don't need to define the primary Constructor and you put the curly braces now I want to override the draw functions so that when the draw when the draw function is called I want to not drawing just a generic view but to draw a button of course as I said this is just an imaginary example so we type overwrite fundra and instead of calling the super function which is inside our our Base Class View or parent Class View I'm gonna type here print line and we're gonna put the text drawing the button of course and now what we did here we created the generic view as I said and again this can have hundreds of maybe thousands of line of code and functions and different functions different properties but we we inherited from The View class and we added some new functionality so instead of just drawing a generic view now of course we just add a simple print line here but here you can have the code which is going to be responsible for drawing a speed a button so it's going to be more specific than a simple generic view so you can put here a here is the code for creating the button so I'm going to put the Commander and let's say that now I want to create a run around button so instead of creating again all that functionality which which is present in the view and then create and then use and then creating all the functionality which is uh inside the button the button class we can make this button uh open and we can inherit all the functionality that the button provides and we're gonna add something new something unique to this class that we're going to create and this class is going to be a round button so we type here round button and here you need to define the text because we're going to inherit from the for the from the class button orientation and notice that I don't use the VAR or the VAR keyword here because they they're going to be only parameters because the properties the actual property is going to be are going to be um ultimately declared in the button class and one thing which is going to be specific to a round button that you're going to create is going to be Corners so we type Val corners it was gonna be an integer because the the corners basically here are going to pass a value which is gonna in our marginal example this is going to receive a value which can be um in degrees so how many degrees do you want to how many degrees you want to make the buttons by how many degrees you want to make the button around so it can pass here 20 or 30 anyway so we put colon here and we inherit now from our button class right and here you need to pass the text the orientation and that's all and you put calibrases now let's override the draw function in our round button because when that function is called now I want to add some specific code some new functionality which is specific to a round button so it's not gonna draw just a button but it's gonna draw a round button so we of course we're just going to add the simple print line there but um in a real app you can put here the actual cottage which is gonna draw the round butter so we put here print line and we put rowing the round button now let's create some instances let's create some objects with those classes and we type here Val view so we're going to create our generic View we Define the battery Constructor we don't have to pass any values there because we didn't Define any properties inside our view then we create a button so we put here Val button equals button and you don't need to pass some value so I'm going to pass here the text let's say login the orientation let's say yo it's going to be a text here so we put here let's say Center next we create a new a new object but this is going to be now a run around the button so we put around button equals round button and you pass the text here round button actually let's pause it takes uh sign up and uh for the orientation let's put Center also lo you need to pass also value from for the colors let's put let's say 30 degrees it will be in our imaginary example now let's call the function the function draw on all of our objects that we create so we type view dot draw then we put button dot draw and round button dot draw now if you just press Ctrl Z if you run this code so we get in the output drawing The View then we get drawn in the button drawing The View again drawing the round button and let's uh think about why you have this output so first we see that we have drawing The View which is the function inside our view that you created here so it's from the generic view so it's drawing The View then we have drawing the button so here when this line of code is uh red it says drawing the button so you have we have our we have our code which is you know which is with just a print line but uh so this is drawing the the button then it's calling the super function so it's calling the function inside the view which it says drawing The View next when this line of code is red so round that round button that draw now it's calling the draw function which is inside the round button so instead of just now calling the because now we are inheriting from the button class now uh we override this function here and it's it's uh using our implementation for creating a round button it's uh executing this line of code and then it's calling the super implementation which is drawing the button you can actually remove this if you want because you let's say that calling the code inside from the button is not gonna affect our logic so if I delete this now if you run this code now we have drawing the view drawing the button and we have drawing the view drawing the wrong button so now it's not calling here the super so it's not it's not calling the code which is inside the for the bottom because we are inheriting first from the button but but the button is also inheriting from The View so it's calling first this then it's calling draw which is inside here and we have the round but now we only have drawing the wrong button because here now it's using our own implementation of the draw so we have drawing the round button so buy this just by by making our view because as I said in real app this view is can have hundreds of maybe thousands of line of code of different functions and properties so you don't want to create all of that from zero when I want only to let's say I want to create a button I can't inherit I can inherit from The View which already provides all the functions and properties and logic to create a generic view but I can override some functions which are responsible let's say for like this draw and I can ex I can Define some logic and when all of that functionality is called It's Gonna not draw only a generic view but it's gonna draw a button so by inheriting from The View we increase we increase code the code reusability and this is very very powerful because let's say that uh like in our example you want to you don't you're not satisfied with the simple button which is used in Android and you want to create a draw a round button so instead of creating all of that logic from zero you can just inherit from a simple button you can have override some functions and when when you execute that quad now it's gonna execute the code with the implementation with the additional implementation the with the additional code which is which is gonna generate a round button and it's just not just a simple button so this is our this is our discussion about inheritance I hope that this clarifies some things and see you in the next video so now it's time to start a discussion about seal classes so often you want to represent only a fixed set of possibilities so however case can either success or it can fail a user can be a standard user or a pro user and in those cases you may be thinking now that you can use enum classes but enumclasses have some limitations and let's see why you should use instead seal class so let's type Main I'm going to create a in on class here call it the result and let's put curly braces unless I hear success and the error now the problem with this is that we cannot encode more information here so let's say that I want to to to Define here a nonresolvable resolver error and resolver error and I cannot do that here so if I type here x dot exception I can I cannot do that because um the the the the types that are defined here cannot have properties so you cannot Define this here and for that we need to use seal classes and to use the seal class you just type seal class I'm going to call it result it's going to have a parameter called Val message it's going to be of type string and you can Define your uh classes which are gone inherit from the seal class either outside the seal class so you can Target class let's say success and let's type here meh message of type string and we can inherit from the seal class so you can type here result message or you can copy this and you can Define it inside the enumclass so you can have it as an SSC class so I'm going to type another class here called error foreign the parameter here actually not that is the parameter message foreign the parameter here message I'm gonna hit it from the result you know from the results class I'm gonna pass that parameter here to the parent class now I'm gonna Define a function down here called get data fun get data and it's gonna have a parameter called the result it's going to be of type result and here you're going to define a when statement so we type when the type result and now is the interesting part now if you hover over this underline over when it says when expression must be exhaustive unnecessary is error comma is Success branches or else Branch instead so in other words what is saying here by uh to have the one statement exhaustive it's it's what it's saying another word is that it needs to cover all the possibilities so both possibilities that we have here and you can type yourself this or you can click on here click on this right bulb and you can click here add the remaining branches and as you can see it's added the remaining browser you add is result. error and easy result does success and those are exhausted those are the only two possibilities which are which are possible so here I'm gonna type result let's define a function inside the CL class so I'm going to type here fun show message it's gonna have a print line which is going to say result dollar sign message so and now I'm going to put dot show message and also here result dot show message and now this is uh this is uh exhausted because now we call we covered all the possibilities which which are uh inside the which are as a consequence of the fact that we our classes are uh inheriting from the seal class so if I add here an uh else Branch so if I put here else as you can as you you'll see this is going to be redundant because we covered all the possibilities and the compilers know this and this can be very useful in some scenarios so if I put calibrations as you can see this is gray out because it's redundant because it knows that we covered all the possibilities and the possibilities are only those two result that error and result are success so if I type here now success let's type success equals result bo2s there equals result dot success let's type success here let's press Ctrl D let's call this error result let's change this to error so this is how you create instances of the nested classes let's call this failed now let's type here get data down here get data and let's let's pass success and let's run our code now as you'll see the message result success so we get results success in the output so if I change now this to error you will see that this is the result error because it is executing this branch so if I run this to get result failed now the interesting part here is if I add here another possibilities so if I type here class progress and I type message string inheriting from result let's type let's pass the message parameter to the super class to the parent class now what what we have because our class is a sealed class what we have here is that the when is underlined and is trying to say something to us is saying that when expression must be exhaustive unnecessary is progress so it knows that there is another possibility for uh for our result uh we it can be therefore you need to add that possibility otherwise I'm going to show you this order and if you try to compile this code I'm gonna throw an error so what what you can do here is can we can type here is a result to make it exhaustive so to cover all the possibility result of that progress let's put Arrow result dot show message and now if I create here another Val let's call this uh progress because the result dot progress and let's define for the parameter progress here now if I change this to progress now you'll see the output result progress so we get result progress because now this branch is true but if I let's if I delete all of those look what happens if I click here or is where you have those on this underline it says add else Branch so when expression must be exhausted so it means that it needs to cover all the possibility possibilities are necessary is error is progress and is Success so if we click here on more actions and if you click here on ADD remaining branches it it knows that those are all the possibilities on which our result can be and it automatically generated the the check for us and we we only just need to type here result not show message and that's all and with tnumps you you don't have this autogenerated code for you because uh I'm gonna explain immediately so with with an enum if you add another so if you have a Nemo class I can delete the code now here because but I'm going to keep the code as it is and because all the subclasses of excel class are known by the compiler the compiler can fill all the possible cases automatically for us if I declare this Arrow class as a seal class and I declare two classes inside here called let's say class resolvable error so or recoverable error and it's going to have a parameter called exception it's going to be of type exception this one and we're going to extend from our error seal class not this one this one and we're going to pass the message parameter and I'm going to declare another class nonrecoverable and it's going to have an exception so this is more powerful than in arms because you can have all those properties and you can you can have subtypes and and all of this and within arms we cannot do this so let's extend from error let's pass the message and now I need to delete this because we cannot instantiate The Shield class so let's delete this now if I delete this now from here look what happens I have an underline and it says add it says one expression must be exhaustive so it must cover all possible cases that that exists for this cell class unnecessary is not recoverable or is recovered or branches so if I click on this and I click on this bulb I click here add remaining branches as you can see it adds all the possible cases so all the possible cases that we Define inside our seal class for us automatically and we just type your result dot show message again here result message and you cannot have this Behavior with the nonclass so this is why still classes are more powerful because they can have subclasses you can have more information on the classes so you can have exceptions passed to them and so on so this is our discussion about seal classes and see you in the next video so now it's time to start a discussion about abstract classes and to show you what abstract classes are I'm going to use the code that you had in our discussion about inheritance but I'm going to change it a little bit so I'm going to delete for this class plane because you don't need this class and I'm gonna I'm gonna delete this instances that we have here and I'm going to declare this as a VAR and this also has a VAR so they're gonna be now properties I'm gonna delete the properties that we have here and uh now we have this here so I'm gonna delete these two let's delete this let's delete this now what are abstract classes um abstract classes are very similar to interfaces the only difference is that in abstract classes you can declare properties which can have a value and you know in interfaces you can't actually you can but you you need to provide an access modifier and to declare an abstract class we go in front of the class that you I want to make it abstract and we type the abstract keyword let's put the class keyword and now our class is abstract and with an abstract class you cannot create instances abstract classes are created only to be inherited from uh by other classes and now if I try to create an instance with this abstract class and I just type Val vehicle and we type vehicle here and we put the parenthesis to call the go to the Constructor you have an error here and says cannot create an instance of an abstract class so you cannot create an object with an abstract class an abstract class can only be inherited by another class and abstract classes usually are used like interfaces when you want to provide what you need what needs to be done but you don't provide how it's going to be done so you can you need abstract classes are used when you define uh functions without the body and the code the body and the code is uh it's uh implemented it's provided by the class by the class which inherits from the abstract class so they are as I say similar very similar to interfaces the only difference that in abstract classes you can have properties so you can have here a Val text and you can assign here some text in uh in an interface you cannot do this let's type some text so this is the difference and uh also um you I should say that um you can Implement many as many interfaces as you want but in a class but you can only inherit from a single class right this I forgot to say when I talked about the interfaces now if I want to make uh if I want to if I to make now our functions abstract you just type the keyword abstract in front of them and now they are abstract and we're gonna do the same for our stop function but now we have this underline because as I said abstract functions like interfaces or the functions which are defined in the interfaces cannot have a body so we need to delete this uh you need to delete the body you need to delete the curly braces Because the actual body the actual logic and the code is going to be provided by the class which uh in head is from the abstract class now to inherit from an abstract class we go here we put colon and we type the name of the abstract class from which you want to inherit vehicle now if you go out here now we have this red bar which says so need to call the Constructor here all right actually I think I can delete this but you still you still need to call this Constructor here even though we don't have any any parameters any even though we didn't even Define The Constructor here now we need because like the interface the abstract class if you inherit from an abstract cluster and if that abstract abstract class has some abstract abstract functions defined in it you need to implement those functions inside your class and you go here when you have this underline if you click on this right red bulb and it says Implement members order make car abstract and we click on Implement members we select our two functions we click ok and now we have our functions implemented inside our class so this is what Astra classes are and they are as I said very similar to interfaces but the only difference is that you can Define in properties inside the an abstract class and you can provide the value to that property and here because we we have inherited from our abstract class here you can provide the actual implementation of the functions so as you can see we have this to do which says not yet implemented so they are they are very similar to interfaces so I'm gonna end this video now and see you in the next video but before I end the video I saw that it's a good idea to to say to you where abstract classes and interfaces are used uh interfaces that are using many many places but um abstract classes are particularly used when uh and also interfaces are used when you have some apis and those apis want to just to define the functions and the API is going to generate the actual code for uh for those function so you can have a let's say a database and you can provide the the name of the functions which are responsible for creating the database for getting getting data from the database but you don't provide the actual code which is gonna select that data from the database and return the data you just you just declare your functions as as the abstract and the API is going to generate all that code which is responsible for uh returning the data and from the in other words the API is going to do all the hard work you just you you just Define the the functions if you have if you let's say if you have a property Define an abstract class in the abstract functions or interfaces and the API is going to do the hard work of uh based on what your function is doing by editing the name of the function is going to generate all that code which you you've you've had to generate if you do if you don't have if you're not before the API to generate that for you so this is where uh interfaces and after classes are sometimes used and the interfaces also are used in event handling and that is one in one um uh the you need to write code to respond to respond to respond to graphical using using your interface uh movements so I'm gonna end the video now see you next so now it's time to start a discussion about data classes but in order to understand what data classes are we first need to understand what is the difference between structure equality versus referential equality and to restart the difference I'm going to create two variables the first one is going to be a Val it's going to be called name one and we're gonna assign the follow Alex three so it's going to be of type string now I'm going to press Ctrl D to duplicate that line of code and to declare the second variable which is going to be called name two and it's also going to have the value RX now I'm going to add the printerland here to output something to the console and here we're gonna type name one equals equals name to so the equals to operator is doing what is called is checking for structural equality because it's checking to see if the content of the variable name 1 is the same with the content of the variable name too so another loss is checking to see if they have the same value and it's they have because both have Alex assigned to them so now if I run this code because this is a Boolean expression this is going to return true or false and we're going to see in the console too but if I change this to Alexandro now the variable name 2 has a different value so this is going to return false because they are not structurally equal their content is different they have different values now get false and this is called the structure equality the next type of equality is called referential equality and the reference equality is used when you want to check if two variables or two objects are the same so what the referential equality operator is doing is checking to see if a tool as I said variables or objects are the same so if I type here name one and to use the the reference we call it operator we put three equal sign here and if I type here name one equals name one so is name one equals to itself that is going to be true so you're gonna see through on the console outputted so we have two but if I change name one equals equals equals to name two that is going to return false because they are distinct objects in memory they are different uh variables they are not the same there is the name one name one variable is not the same variable as name two so we're gonna have false here so we have false so this is the difference between a structural versus referential equality so now I'm going to close this I'm going to close the console and having this in mind we're going to start a discussion about data classes so let's go down here and let's create our user class because I want to compare to user objects to see if they are structure equals so you type user let's define the primary Constructor and let's define three properties for the primary Constructor the first name the last name and the age which is going to be an integer now if I want to check if to user objects are a star vehicle let's first create those objects so let's delete this code let's say Val user1 equals now let's create our object and let's pass some values to the properties of the Constructor let's pass here Alex for the last name let's put open and for the age 23. now let's press Ctrl D to duplicate that line of code and to create the second user object let's give a different name to this user too now go down here let's press Ctrl alt alt for mother code we typed our println because I want to check to see if our users objects are equal if they are structurally equal so we type here user1 equals equals so the equals to operator user 2. now if you run this code what do you think you're going to see in the output what you're seeing the output is actually that you'll get we get false and you may be wondering why because if you think about the air structurally because they have the same values for the properties but they are a distinct objects but we said previously that the equals equals uh two equals operator is checking for uh structure equality so why get false here this is because previously the equals to operator is it was checking to see if the two strings are structurally equal and the equals to operator is actually a function which is defined inside the any class and the string class what actually was doing when we called the equals to operator it was using its own implementation of the equals method so uh every class that we create in kotlin it's using its implicitly inheriting from the any class and because every class that we created it's implicitly inheriting from the any class every class is also going to use the functions which are inside the any class so if you don't override those functions inside your class to provide your own implementation like the string class did for our strengths then it's going to use the implicit uh the font is going to use the function which inside which are inside the any class and if you type here user1 that and we have equals to string and hashcode those three but those three functions we are particularly interested and the particular one is interested inside the equals they perform when you don't Implement inside your own class those functions again particularly on Bay course class the equals class spin forums only a referential equality so it only checks if those two users are the same users and if they're not that's gonna it's gonna return false so this is why you get false here because it's calling the function the function which is inside any class so what you have implicitly is something like this so for any class that you you use or for any class that you declare you have implicity inherited from the any class and because of that you have those three functions which are defined and if you don't override them to provide your own implementation then it's going to use the code that's inside there so actually if you press Ctrl here and if you click it takes us inside the any class so it's clear that this function the equals function is inside any class so because we don't have any functions here so we need to override that function inside our class and we need to provide our own implementation to Define our own code to determine if two user are one of when two users are slash legal this is what you're going to Define inside our class so let's delete this let's pull the curly braces and actually I'm gonna bring an image to show you how the quarter and hierarchy actually looks so this is the image and at the top as you can see we have the any class and then we have our Boolean class our string class and then we have our user class and all of those classes I have here the Boolean the string the number they are inheriting from the any class they are using the the functions which are defined inside the any class and they override the they are overriding those methods inside them and they are providing their own implementation for those functions and this is what we need to do also here as you can see they will inherit from the any class implicitly so we need to override them to provide our own implementation for the equals and for the next two because we're going to look at also at the as you saw there you are going to look also at hash code because uh equals and hash code are very linked together and also the two string function so we need to override those uh inside our class so this is what we're gonna do so we go inside our user class and here we need to override the equals function when we type overwrite and while I'm dumping you can see that we have three suggestions here and we select the user function because this is the one that we are interested in and as you can see here this function is part of the any class so we press enter we delete the super return and the first thing that we need to check is to see if the current instance the current object that on which this equals function is called it's comparing with its cell so we need to check if the the if the object is the same as the object that we are comparing with and to do that we type here if this so if this current object is current instance equals equals so three equals we check for referential equality to see if they are the same equals other so we type other and if that is the case if we call we are comparing the same object so you have user one equals user one then gonna return true because that means that uh we are comparing uh with the same object if that is not true then the next thing that we need to check we we're gonna go down here so if not we're not comparing with uh it's not comparing with itself then we need to check if the other so the object which is passed as an argument to this function which is called on another object and to check if other so the argument is user because we we can uh we need to check the expressly to see if this object which is passed as an argument to our equals function is an user object because we don't want to check for a different object we need we need to to see if this is a new zero object so only if the object which is passed as an argument to the equals function is an user object then we're gonna return true so here you need to type now we need to determine we need to Define our Logic for what it means for two users to be equal and it's up to you how we Define this implementation I'm going to type here only return so I'm gonna my logic is if they have the same first name the same last name and the same age we're gonna say that they are equal we have the same user of course that in a real app you can have a more complex implementation so we type here return this so This current instance that first name so and then put two equals other so if so the other is because we check here explicit to see if this is another also because this condition is going to only pass if the other argument is unusual so we type other because we have access to the first name and the last name and the age if other DOT first name so this is our first condition and this Dot this dot last name so I'm going to check for the all uh for our three properties equals equals other so other is another object because we determine that here that last name and this dot age equals equals H so this entire expression that is that we have here is gonna return through only or if all the our three conditionals so if this DOT first name is equal to other that first name so with the object that is passed as an argument or equals and if this data last name is equal to other that last name and if this dot h is equal to the other that age let's put here then and only then we're gonna have a true here so it's going to return through otherwise if one of those condition fails it's gonna return false and down here you need to if other let's say doesn't pass so if other reason is not an user we're gonna return false so in that case going to turn false now if I run this code look what happens so previously we had the false and now we have true here and this is because now it's using the equals function which is inside our user class so it's using our own implementation so it's checked here to see if uh our first name is equal to other DOT first name so it's checking uh so it's using our logic inside the the equals function so this is why you get true and you can also you can now if you press if you hold Ctrl here as you can see now it's taking us inside the equals method that we defined here it's not taking it inside the ionic class this is because now it's using our own implementation so first to check to see if we are dealing with the same object then we're going to return true you're not going to go any any we're not going to go down and if this is false you're gonna come up here you're gonna check to see if other the object which is passed or equals function is an user instance it's an user object then I'm gonna check to see if our current object that we are calling on the sqls function is equal which exclusive for the first name there is the same we check to see if the last name is the same and we check to see if the age is also the same then in that case it's going to return true and we're gonna say that they are structurally equal so we're gonna see through in the output else if other is not an user so if you pass to the function argument the different parameter a different argument here let's say you pass an integer then it's going to return false here we're going to come down here so now if you look here you may be wondering how this syntax works so we have those signs but it's calling the equal smart function so you can also put that equals if it makes more sense and if we put that equals user so so uh now you can see that but if you hover over he says replace with the two equals so it's the same thing as having that equals and passing that argument here which is user two so again we are invoking uh the equals method on the user one object let's press Ctrl J and we are passing our user to objects and we are using our logic that we Define here to determine if they are equal and you can replace this back to to equals or if it makes more visual sense to put the to use the equals you can use equals it's the same thing we put user to here so as you can see we are calling the function so this means this object so this object so defined here this if uh when we're saying this that first name it we we mean this object so if this is that first name it's equal with the other other that first name it's then we are calling this object that is passed here as an argument so um next we will look we're going to look at the next two functions because as I said the equals and hash codes are very linked together and we're going to also look at the the two string function and now if I change the first name for the user 2 to join and if I run this code you will get false in the output because when it will come inside this if it will check to see if this does first name equals to other at first name and because we're using the end operator and all the conditions have to be true this is going to return false so I get false in the output and um but if I change it back to Alex we'll have true so the objects are structurally equal based on the logic that we defined here inside our equals function and as I said you also you can also look at equals and hashcode because they are very linked together and uh the rule is whenever you override equals you also need to override the the hashcode and if two objects are comparing equal so if they are equal based on the equals method that you implemented they also have to have the same hash code and I'm not going to go into that but this is because they are the hash code is used for performers reasons in collections but we're not to go now into that we can just type here override and uh here we just type return zero and this uh this is not gonna affect our equality at all as I said this hash code it will make it makes more sense to implement the hash code in a different way in collections because they are used um for performance reasons particularly with hash set and hashmobs but uh for now for our simple class because we don't use this class inside any collections we don't need because uh we don't uh don't have to think about that per the performance reasons to of the hashcode and uh just if you want to just uh just return zero here like I return and yeah because it would work fine it's not it's not going to affect at all our equality but remember that rulebook that if you override the equals you also have to write a hash code and uh if two objects are comparing equal the more must have the same hashcode this is true as I said particularly in collections not now because we're not using this code inside collection and we can also override the tostring method and this two string method is used to return the string representation of the class so we also type here override and we have our two string function I I said method a few times but there are functions not methods methods are different thing in Java and uh let's delete this function let's type it again so if you can see so this is going to return the string representation of the class so I need to to return here the values that that are passed to our to our first name and last name and age and if we don't do that if you add the print line here and you type user1 let's press Ctrl D and user 2. you're gonna see just some you're gonna see the user and you're gonna see some numbers but we're not gonna see the string representation of the those two users you're not going to see Alex so the name and the age so you see this dosto but uh to avoid that because this also use useful because previously when we want to um output in the console the values of the properties you have to call those properties and to add multiple Sprint lines but with the two string function we can just type here return and type here user we put parenthesis and here we type first name we put equals we put dollar sign let's put a single quotation mark dollar sign first name let's put the quotation marks here a single quotation marks last name equals dollar sign last name let's put inside the single quotation marks this comma and age we put also equals dollar sign h now if you run this code again now it's going to use it's gonna one when we are typing user one and user two is going to use the tostring function that we defined inside your class and it's gonna return the string representation of that specific object so if you run this code we get user and get first name Alex last name Adobe in h23 and get for the second you use their first name Alex last name domain and H22 so now get the string representation of this class and this is uh more beautiful because you don't have to work to always type that user one user1.a user1. last name the first name and so on and for the second object two because now it's using the two string function with our own implementation inside here so this is how you can use the tostring function and this also how you can use the password but as I said hashcode is it's a different discussion which you're gonna have when we're going to talk about collections for now just type return 0 here and then we could all fine and if you think about there is a lot of code just to compare to two objects we have almost 38 line of hold just to to determine if two objects two user objects are equal and we also have to override this not necessary but it will also variety this hash code and the two strings so there is a lot of code just to do this uh simple thing to compare it is to user objects are equal and because kotlin is a byte it's about conciseness we don't actually need to do all of this stuff but I I thought I thought that it is a okay to explain to you what you'll need to do in the past in order to understand what now questioning is doing better especially with data classes so you don't need to type yourself all of this code that you have here you can just so if I delete all of this code let's copy it first and then delete it so if I delete all of this code also the and now if I run this now we get false and we get those we get user and this tag text because now we don't have an implementation of the equals of the two string of the hashcode and if you think as I said it's a lot of code to implement all of that and in kotlin you can just type the data keyword in front of the class and all of that code not specifically the same logic but all of that code that we typed there is going to be generated automatically for you so the equals method is going to be generated the hash code and the tostring and uh the properties which are going to be included inside the implementation of the equals of the inside the of the hash code and inside of the tostring are gonna beat all the properties defined inside the property Constructor so all the properties defined inside the property inside the primary Constructor they're going to be used inside the implementation of the equals of the hashcode and the tostring so we just by putting here the data keyword all of that code all of that logic is going to be implemented for us so if you run this code now so look at this how concise is compared to what happens just one line of code and if if you run our code with the data keyword now as you can see we have true and we have user first name Alex last name so you have the same output as previously and just by putting data keyword all of that was all of these calls so let's press Ctrl J all of this squad not specifically exactly this code but all of this code all the implementation of the equals of the harsh code entry was generated automatically for us just by uh just by putting the data keyword in front of our class and if you don't want to have a property included in the implementation of the of the equals or of the harsh code or of the the two string you can just omit it from here and you just you declare it inside the inside the class so if I put let's say here so if I delete this because data classes cannot have parameters and I declared it inside the class inside the data class VAR age and it will sign a value because we cannot let the property uninitialized let's delete this now and if you run this now that property is going to be excluded from the implementation of the equals the hash code and of the two string so we have here true but we have a first name Alex last name Domi so now the limitation for the equals only includes those properties the first name and the last name and also for the to string function we have only the first name and the last name the age is excluded but let's put this back so this is what data classes are they are generating Auto automatically for you the implementation of the equals the harsh code the two string also for the copy function and for the component function but we're going to look at the copy of copy function in a separate video and they generate all of that code that we saw previously that we talked about automatically for you by just putting the data keyword you put the properties inside the primary Constructor and all of that implementation is going to be generated for you for all the properties you find inside the primary construction and just that just by one line of code all of that logic is generated automatically so this is what data classes are see you in the next video so now it's time to start a discussion about interfaces so what are interfaces interfaces um are you used when you want to have a commonly used Behavior shared among different classes but you don't want to provide the actual code that goes inside the class which is going to implement that interface but you just want to define the the name of the function and the parameter of the function the actual code that goes inside the the functions that you define in inside the interface they are particular to each object that implements that specific interface so let's say that you have let's say that we have some classes let's say that you have a class car a class which is uh which represents a truck and you have a class which represents represents a plane you know that all of those three objects have in common the same behavior of starting the engine let's say and you don't know how each particular class is going to start the engine but you know that each class is gonna have in common this function which is I'm gonna start the engine again you don't care about the particular how each particular object is gonna uh what code goes inside the or what uh logic goes inside The Stand start engine function for each of those particular objects but to care only about the fact that they they share the same behavior they they all start the engine but how they start the engine is uh particular to each class and this is what we do with interfaces we only Define the what so what what we Define in the interface only the the the what and the what represents the what those classes are gonna have in common so you know that they uh gonna have a function called start engine but you don't don't know how each object how each class is gonna Implement that logic and to that to to for that I'm gonna use an interface so we Define what needs to be done but we don't Define how it's going to be done so to declare an interface we go down here at the enclosing calibrates of the main function and we type interface and while I'm typing you see that we have this suggestion we type we press enter we can type the entire word if you want so interface and I'm going to call this internal phase engine and the name of the interface should be with a capital letter to start a capital letter it should be in Pascal case if it has multiple words and the interfaces cannot have Constructors because they cannot be instantiated you cannot create you cannot create an object with an interface interfaces are used only they are created only to be implemented by classes they cannot be instantiated so we need to put curly braces and inside the the body inside the curly braces we Define what needs to be done so we Define only the function we Define we type the name of the function I'm going to call it start engine but we don't Define the actual code for the function so we put parenthesis here you can Define parameters if you want but we don't put curly braces and we Define our logic here because we only care what about what needs to be done so we only care that each class needs to start the engine how it's going to start the engine it's up to each particular class so we go down here we type class and I'm going to create a class called car and it's going to have a a vowel name which is going to be a string and a vaal color which is also going to be a string and now to implement the interface we put colon and we type engine and as you can see we have this engine we have this eye for interface here so you press enter then we put curly braces to define the body of the class and now we have this underline here and this underline is here to tell us that we need to in now we need to implement the we need to implement this function because the the interface and the class have a contract is like a contract and the contract says that if you implement an interface you need to you must Implement you must override the the the function so you need to implement the function you still will this is why we have here here an underline so if I click on this underline what if I hover over there and I click on the light on the red bulb you see that it says Implement members so click on Implement and have our start engine function we click OK and now our functions was overrided here and we have this to do which is not yet implemented and this is there to to tell us that this method this function is not Yeti implemented so we need to define the actual logic here and let's create two other classes let's um call this class track and it's also going to have a name a Val going to be a string and the color also string and we're gonna also implement the interface so I'm going to put colon engine then we put curabase now we need to implement because I said there is a contact between the interface and the class and the contract says that you need to implement the function so we Implement a function here and we create another class call plane and it's also going to have a Val name it's going to be a string and the eval color also string and here we put colon and we're gonna also implement the interface interface inside the plane class and we put call on engine our interface then curly braces and now we have the underline because again we there is the contract now between the interface and the class and that says that we need to implement this function inside our plane class and we have those to do and those to do are here to tell us that we need to we need to imple we need to provide some logic to the to the actual function so let's delete those and let's put some code here so let's delete this and let's add the print line here which is gonna output some text to the console and we're gonna have the text the car you starting the engine and I'm gonna copy this because now I'm gonna put here some text I'm gonna say the track is starting the engine and here is going to say the plane starting the engine now what what we have done here and what we did here is that we know that each class respectively our car our tracking and our plane they all gonna start the engine so they all gonna share this start engine Behavior the one all all gonna have this functionality what we don't know is how each class how each how each object is gonna start the engine because they uh they start the engine in a different way the engine of of a car is different from an engine of a truck or form of Lane so we know that each each is gonna not that each class or each object is gonna start the engine but we don't know how they're gonna start the engine so here we go inside the actual uh feelings inside the the function which we type the text the car is starting the engine the truck is starting the engine and the plane is starting the engine so they differed in how they start the engine but you know that they all gonna they all gonna start the engine so this is what interfaces allows us to do you can define an interface if you know that uh multiple uh related or unrelated classes or objects are gonna have a function shared between them but you don't know how each particular class or object is gonna em is gonna uh how is gonna how it's gonna have the actual quad uh how it's gonna write the actual code for that uh that behavior so you don't you don't care about the how you want to care about the what so we know that in this case they will start the engine but they they start the engine in a different way and you can have here another class let's say that a person which creates another another class and the class is gonna be called Tesla and in that case again you can implement the interface because you know that uh the Tesla is also going to start the engine you don't know how it's going to start the engine but you know that uh is going to start the engine and how it's going to start the engine is specific to a Tesla car so this is what interfaces allow us to do we can Define uh some shared Behavior between unrelated or related classes and that the actual code you don't Define any code inside the interface you can put you actually can Define here a property but uh uh usually you just Define uh the the function the function name some parameters and the actual code goes inside the class which implements that interface let's let's actually create here a class Tesla so we put here let's put this a little bit up so we put here class Tesla is gonna have also a Val name it's going to be a string Naval color and this is also going to be a string so now we can Implement our engine interface so we don't know how Tesla is going to start the engine but we know that it's going to start the engine so we we Implement our interface put call on the name of the interface and now we need to implement the start engine so we click on that and we have not yet implemented let's put our print line here I'm going to press Ctrl V and here's gonna say that's like starting the engine so this is what interfaces are and see you in the next video because I'm going to end the video now so here you should say a Tesla is starting the engine not the Tesla so I collected that so I thought it's a good idea to show you a practical example using Android studio where interfaces are used because the when I first learned about interfaces and after classes I found them very confusing because they are very very abstract and you don't see when when you somebody teaches you those Concepts you don't see how where and where you're gonna use those uh those Concepts interfaces and Abstract classes and for that I'm going to open Android Studio to show you a practical example using interfaces and also organize Android Studio to show you a practical example where we're going to use abstract classes so I opened Android Studio you don't need to it looks similar to our IntelliJ because this IntelliJ IDEA just that is it's Android Studio so we will click on my application and here we have this thing called main activity we don't need to worry about this because as I said I just want to show you where interfaces are used in Android Studio to get to get an idea about where they are used because I said they are very abstract foreign this thing called activity.main This is where we put our UI this is where we put our buttons this is where we put our list views uh this is where we put generally our UI so as you can see we have two buttons here and they have an ID again I'm not gonna go into this but if you click here on design you see that we have a login button and a sign up button so this is the UI part of our app now I'm gonna click on this main activity and this is the part where you're gonna put our code and now I'm gonna link those UI buttons so let's go to quad so this is the code for creating those buttons and I'm gonna link those buttons because they have this ID here login button so you have here Android ID and if you come from Android Studio you already know all of this I'm gonna link those UI buttons with some objects buttons by typing some code so I'm gonna Define up here foreign called the login button and it's going to be of type button so this is a class button then I'm gonna Define another later need because I'm not gonna initialize it right there so Laten it again sign up button and it's gonna be also of type button so types like we have types for uh for our numbers or for our just that this is a class and this rep this class is a button objectives and now we need to link those those objects that we created here with those buttons that we have here those UI buttons so to link those login button and sign up button and to do that to go down here and I'm gonna I'm gonna go I'm gonna do this in the longer way and here we type login button again you don't need to understand all of this this is just to illustrate how interfaces work I'm gonna put equals and now I'm going to type find view by D and this function find view by ID is gonna link our button object that we created here with our UI button that we have that we have created here and it's going to be linked by its ID by this ID that we have here login button so if you go here hero Type R so R is this thing which uh again don't need to understand all of these arrays is used to to get that ID to link our button object with our button UI so if you put r dot ID that and we have our uh our two IDs so we choose login button so now we have linked our UI button with our button object so we linked the UI in other words with the code now let's link also the setting up button so we type here saying a button equals find view by ID you you also type r dot ID Dot sign up button again you don't need to type this code because probably you don't even have Android Studio this is just to illustrate something now to illustrate how interfaces work let's say that I want to let's say that I want to to do something when this login button is clicked and I want to do also something when design up button is clicked and it and here interface is coming to action what you can do is you can say login button Dot and there is a function called set on click listener and this function what is doing is basically setting a listener on our UI button so that when you click on that button the function called on click is going to be executed and the code that is going to be in that function is particular to each to each button so you you you're gonna set the interface so you types don't click listener and hero type also this illustrates uh the object also this by by this example we also illustrate how the Anonymous classes work so you type object and now I'm gonna inherit actually gonna Implement our interface on click listener and this only listener interface has a function called on click and here to put curly braces and press enter and now here we have this underline and if you click on it you have this red bulb because it wants us to implement to implement that on click function so we're going to implement that and it says to do not get implemented I'm not going to do the same thing for the for the sign up button so I'm gonna copy this I'm gonna paste it down here and I'm going to change this to sign up button so now each individual each individual button has us on has its own on click listener interface and the code which is going to be executed inside the one click method because this function is going to be triggered when you click on the button is particular to each button so this button is going to log in the user this button you're gonna put here the code to sign up the user but you're not going to do that we're just gonna we're gonna uh show some text on our emulator so we type here to show the text toast dot make text here you need to pass the context so don't worry about all of this main.activity here you need to pass uh how how long this is gonna show on the screen so we choose a short and we put that show to show this on the actually here we need to pass the text so what text is going to be shown on the screen so here we're gonna say login button clicked and now here we need to pass how long it's going to slow so you type those Dot short so if it's going to be shown for a short time and then we need to call the show functions to show this on the screen and I'm going to press Ctrl uh C to copy this and I'm gonna paste inside our on click function in our interface that we have here for the sign up button and this is gonna say that sign up button was click so sign up button clicked now in Android Studio we have what is called an emulator and this is basically a virtual phone and we can run you can run our code and we can test our code and we're gonna see when on that emulator those buttons and when you're going to click on those buttons this code that we Define here for for those buttons because we linked them so we linked those two buttons that have the login button the sign up button so this is their UI code this is their XML code you we've linked them through code here and when we click on them the Code in each particular object is going to be executed so now if you run our code go up here and I'm gonna create now the virtual font to see our buttons and I'm going to click on them to see how it works I'm going to close those now it's connecting to the emulator and this is our virtual virtual phone so this is the virtual phones and here we have our UI that we created here so this is what the users see so this the what the user say and this is what we see it's the this is what happens under the covers and now if I click on this login button look what happens it says login button click so it executes this on click function inside the login button if I click on the sign up button it says sign up button click because it's executing the one click function and the code inside the one click function for the sign up button and they are as I said linked by the by the ID so this is what happens under the covers this is what the user see now this is where interfaces can be used because if you think about you can have multiple uis different uis text views lists or items into the items in a list which can be clicked and for all of those you know that always go all of them are gonna have on click function all all all have this shared functionality to respond to a click you don't know how that is gonna how that that one click function is gonna execute or what code that on click function is going to have for each particular UI uh UI but you know that each each one is gonna have one click function what is going to go inside the one click function for you for each particular UI it's up to that specific UI so it's up to a button it's up to a text views and so on so this is a over interfaces are used because we know that they're going to have a shared functionality of one click but you don't know how that functionality is going to be implemented by each particular uis in our case we do we know that login button and sign up button both both are going to have a one click both we're gonna are gonna respond to click events but you don't know what they're gonna do so this is why you define the interface and the developers who write code gonna Implement that interface and you're gonna write the actual implementation for that function which is specific to that object so this is our discussion and if you find this confusing particularly if I'm confusing the uh if because I touch a little bit on Android Studio in our discussion don't be because I just wanted to show you a practical example where interfaces are used using Android studio so let's click again on login button we get our toast login button clicked slang a button click I can create another button which can be used for a I don't know if you forgot the password and you you're gonna implement the on click listener you're gonna override the you're gonna override the one click function I'm gonna write some code to to send uh to send to help help the user to recover its uh puzzle and so on so we can see how interfaces can be used practically in this with this example so this is our discussion see you in the next video so now it's time to start a discussion about object expression but first let's go down here and let's create a class to see why you'll need to use object expression in the first place so you type here class and now and our class is going to be called button we put the parenthesis to create the primary Constructor we Define some properties here the first one is going to be text is going to be of type string the second one is going to be also available it's going to be called ID it's gonna be an integer and the last one is going to be called One Click listener it's going to be of type on click listener so this is an interface that we're gonna create so let's go down here to create the interface we type interface on and while I'm jumping you see that you have this suggestion one click listener to create the interface press enter put curly braces and let's define a function fun on click let's put parenthesis now let's create some objects with our class button to see why you'll need to use a object expression in the first place so let's go here and here we type Val let's call it login button put equal and now let's create our object type button with parenthesis now let's pass some values to the properties of the primary Constructor and this is gonna have the text to login for the ID we type some arbitrary numbers here one two one three two and um now here you need to pass the one click listener interface but do not we cannot type here one click listener because we cannot instantiate the interface so what can we do to solve this problem one solution to this would be to create a separate class here let's put it actually above the interface let's call it click listener this class class click listener and this class is going to implement the interface so we put here colon and we call our on click listener interface put curly braces and now we need to implement that one click method that one click function that we defined actually inside our own click listen interface so press ok to override to add on click function and we have that to do we have this to do which says to do not yet implemented so this is there to tell us that it's not implemented yet so let's delete this all right so what we could do is you can create here an instance of the click listener so we type here Val click listener equals create the instance we'll create an object and now you can pass here the click listener so now the arrow disappeared but if I create a second object let's call it the sign up button equals button let's pause the text so sign up for the ID was an arbitrary number now in our imaginary or example that we have here actually if you think for real scenario with this button and the one click listen what we want to achieve here is that if you have a graphical user interface you want that you want to detect that click so you want to declare detect one that specific button let's see that this button object that we have here is linked to an uh graphical button which on which you click because they are linked when you click on that you want to call that one click function that is defined inside our interface inside here but you want to make that one click interface we want you want to make that one click function particular to particular to that button which was clicked so we we want to to implement that uh one click function to that particular button which was clicked and the code that goes inside that particular button so let's say that you click on the login button it's particular to that button so that in the next when the next button is clicked so when if the user clicks for when the sign up button then you know you need to also have the one click method called but that one click that one click function actually I I keep saying method but the one click function should should have its own implementation a particular to the sign up button so what can we do in that case we cannot pass the same instance here to click listener because even if it creates here another instance of the click listener it will still have the same code which is here so if you put here some code this is code blue it will be shared among all the objects that are created so what you can do in this case is to use an object expression or also called anonymous anonymous anonymous classes so what you can do here we can type object we put colon and now we are inheriting from our we are actually implementing our own click listener interface so we type object colon on click listener and we put curly braces because here we declare and we also instantiate the the anonymous class so we need to implement that right there so by doing this now we where we made the one click function particular to each object Which object button so we can do the same thing here we type object and we Implement our on click listener interface we put curly braces now we need to implement for this particular object for the sign up or button objects we need to implement that function so if we type we click we click on this object we go to the red light bulb and we type we press here where it says Implement members so implement the one click function and now what we did here is we made the one click function particular to each object so each object now we can put here some code code or we can type here this sign in actually let's type login that was it so now we can have code here which actually log logs in if you have a real graphical user interface which logs logs in the user and here you can also code to sign up the user when that specific button is clicked so by doing by using the object expression also called Anonymous class because you don't have reference you don't have a name for the class here you just it's just Anonymous for this is anonymous so we cannot it does not have a name so we cannot call it later or do something because it's created and also instantiating right there this is why I need to implement the one click function and now we made the one click function particular to each button and you have more objects more objects of created with the class button they'll have their own implementation of the one click function which comes from the interface on click listener so this is why you need to use the anonymous class or also called object expression and it's an expression because the value that the because the object is always it's created and instantiate it is actually declared and instantiated at the same time it's also assigned to the property that we Define here so this is why it's called an expression so see you in the next video all right so now it's time to start a discussion about delegation but first I'm going to add the main function here now what is delegation delegation means giving power given Authority from one instance from one class to another class and delegation is usually used in in scenarios where inheritance starts to break so when inheritance starts to break when you want let's say it for whatever reason to inherit from two classes in that case you can't use inheritance because with inheritance you can you inherit just from only one class but with delegation you can plug in multiple implementation of classes in your own class and let's see how we can do that so I'm going to create first an interface called a and it's going to have a function called print then I'm going to create another interface called B and it's going to have a function print though then I'm going to create a class so I'm going to type here class and it's going to be called first delegate and it's going to implement the fun the interface a here and I'm gonna press Ctrl o to override the function print here and I'm going to create another class called second delegate and this is going to implement the interface B so I'm going to place Ctrl to override the function print tool now I'm going to create up here a class called up so class up now let's say that I want here to inherit from the first delegate and from the second regulator so I'm going to inform the single delegate and if I type here first delegate I put parenthesis opening parentheses closing parentheses if I put curly braces now I have another line because I should Mark this as open so mark this as open and also this as open because I want to show you that so now if I want to inherit from the second class called from the second delegate because let's say that I want to use the the print to function in my class for whatever reason I can't because I can't only inherit from one class so if I hover over here over this underline it says only only one class may appear in a super type list so in other words saying that you can only inherit from one class and that is all we cannot inherit from multiple classes now with delegation we can plug in multiple implementations in our own class so what I can do here I can say hey implement the interface a so I'm going to inherit it from the interface a but you're gonna say use for the interface a the implementation of the first delegate class so this is what we're saying here a and the keyword by first delegate we're saying hey use for the interface a the implementation which is provided by the first delegate class and that will work then I'm going to put a comma here and I'm going to say use also for the class B so I'm going to type for the interface B so we're gonna type B and we're gonna use the by key you're also going to type here by second delegate so you're saying use for the interface B the second delegate implementation and it's gonna use that and it's gonna be him happy with that so you're gonna see that we get no error and now I can override here both the print function and also the print to function so if I press Ctrl o now I can override also the print too and this is inherently very powerful because we can plug in here multiple as many implementations as you want in your class so this is in the if you think about in contrast with the inheritance this is very powerful because here you can plug in as many implementations as you want and this is very powerful so this is how you can use the delegation in kotlin and next we're going to see how you can use delegation with properties so to use delegation on properties first I'm going to paste some code here so I'm going to paste this code here and what we are having here is a class format delegate which is inheriting from the read and write property and it's overriding the get value and the set value so we are overriding the setter and the getter inside our class and we provide our own implementation so whenever you you use the setter to set a value or to get as a get a value we we are overriding those functions and we provide our own implementation next I'm going to create here up here a class but first I'm going to delete the code and the interface that we have here because we don't need this code so I'm gonna delete this code and I'm going to create another class and this class is going to be called user I'm going to put curly braces and I'm going to define the properties inside the class so I'm going to type here VAR first name so what we are doing now is we're creating a property first it's called first name and I'm going to use the by queue we're just going to say buy format delegate so what we are saying now is use the use the the we use the code which is inside the format delegate Whenever you set the value or get the value of the first name I'm going to put the parenthesis here next I'm going to type another VAR last name and I'm going to type here again bye and I'm going to type format delegate so format delegate and we put parentheses so not now what is going to happen is that whenever you set the first name properly or we get the name the first name property is going to use our implementation that we provided here this is what you're gonna do and the same it will be true for the last name because we are using the delegation here on properties so I'm going to create here a user so I'm going to type here Val user want to type equals to user and I'm gonna type here with I'm gonna type user this is the scope function I'm going to put curly curly braces and I'm going to type here first name equals Alex and the last name equals uh dominga now if I output those values in the console look what happens so if I tap it here print line user that first name and print line let's actually use again with the scope function type here with just pass here user curly braces print line first name and print line last name now if you run this code you're gonna see that it's using the overriding functions that we provide in our format delegate so we have in uppercase letters like we defined here we're gonna wanna whenever we set about is going to be set it with the it's going to change the value to lowercase letter so get Alex and obinka in lowercase letters so this is how you can use the delegation on properties and see you in the next video so now it's time to start a discussion about collections but first i'm going to create a new project I'm going to call it collections for the language select link for the build system IntelliJ make sure to have the jdk selected and also check this box to have the main function Auto generated for us so I'm going to click on create to create the project now I'm going to delete this code because you don't need this code and also I'm going to hide the project pane now what are collections collections are a group of objects stored together in a single variable they are similar to array but there are there are different in some sense and they are mainly three collections that we're gonna look at and this those are the list the set and the map and the and those among those collections they are separated in two groups so there are multiple multiple lists and set air maps and immutable lists set and map and in the motable means that you can write to that collection so you can add or or remove elements to it so the that collection can grow or Shrink as you add or remove elements to it and immutable means that you can only add elements when it when you instantiate that or we're going to create that collection you cannot add later elements to it the size is fixed so we cannot add or remove element so this is the difference between immutable and multiple and we're gonna look at all of those in this video so we're gonna look at the list collection first and we're gonna look at an immutable list so we type Val I'm going to create a variable names and here we're gonna type to create an immutable list type list of and here we need to specify the type what kind of data I'm going to put here and do type name one name two and name three now we cannot add or remove elements from this list because it's an immutable list but we can get on Elemental output in the console and to do that to type it in the line we type names we put square brackets and we get the element by its index and the index also starts at zero so let's get the first element so if you're on this code you'll see name one I'll put it in a new console so you get name one so this is an immutable list we cannot add or remove elements from it after we instantiate it here what now now let's look at an mutably so a list which can within which you can add and remove elements to it so to do that we just change this from a list of to a mutable list of so we type here multiple list of we can also remove the explicit type here the explicit type declaration because it's gray out so remove that because it can be inferred and to this mutable list now we can add or remove the elements so I can type here names and we have this add function so you can type add and here we can you can pass a new element so we pass here let's say name 4. now if I uh let's type here names that for each print line not in this footage name start for each this for each opening the line now if you run this now you see you have name one name two name three and name four so name four was added to our Multiple List because our list is multiple we can add or remove new elements so down here I can I can type names dot remove and we can remove an element and we can remove the element I think by you can remove you can use this function remove art so we can remove the element by its index so we can type here the index and that is going to remove the first element so if you run this code name one is not going to be showed so as you can see name one was removed because you can you will remove it by its index and we can also remove an element using this function by typing uh the elements so we type here let's say name two name two elements and now it's going to be removed so now if you run this name two was removed so those are two functions with which you can remove elements from the Multiple List so this is a multiple list you can add and remove elements to it and the list is gonna grow and Shrink as you add or remove elements to it so this is the Multiple List now we're gonna look at a set and I set this a collection which can store only unique unique elements so you cannot have duplicates so if I delete this so in our in our Multiple List you can put an element which is the same so we can have two elements which are the same so if you run this we have two elements which are the same going to see name one at the end I have name one name two name three and name one again so you can have uh duplicates in our collection on our multiple list but in a set you can't so but first we're gonna look at uh first we're gonna look at the immutable set and then add automotive ball set so we type here uh let's delete this we type here set off and here you need to buy string now if you run this you will see that name one is not shown two times here it's going to be shown only one time so you have name one name two and name three this is because the set Seto the set is not allowing duplicates in its uh in its list so and this is a new multiple set set off so if I type here names dot add we cannot add or remove new elements but you can also use a multiple set of so we type here Moto motable set off and now we can add and remove new elements so you can type names that add so here you can add a new element let's say name so now if you run this I'm going to name one name two name three name four and our duplicate is not strong because I said a set can only can only store unique elements not duplicates but if I add objects that we create look what happens so let's create some user objects but first let's create the class user and it's gonna have a Val name is going to be of type string no let's create some user objects here and we're gonna add to our multiple set so we type here wall user one I'm gonna type here user I'm going to pass some generic names like name one and let's control the a few times let's change this to name two five and let's add here a Val user six equals user and let's type here Alex let's press Ctrl d and let's change this to user 7. now let's add those to our multiple cells so let's change now the type so it's gonna store user objects so we're gonna pass here user one I'm going to speed up now this a little bit I'm gonna press Ctrl tilde format the code now we can add this we cannot add here a name for because now the type is user now if you're on this let's actually change this print to it dot name and let's let's run our code now and we have name one name two name three name four Nerf name five and have Alex two times so why you have duplicates even though I said that sets can only store unique elements this is because previously the set actually what is doing to determine to if to if it has duplicates is using the equals to function that we talked about in our video about data classes so when we typed only strings then it was using the equals to function which was overridden inside the string class to determine if there are uh if there are equal strings but now because our class doesn't have the equals to function over it then it's in its class it's not it's using the equals to function which is inside the ending class so you cannot determine if two users are are equal and to change that just let's hide the console and just put the data keyword here because now this will generate the equals to function the the the two string and the harsh code so now if you run this now we have Alex only one time because now it's using the equals to function which was uh Auto generated by by uh by the class user because you put here the data key or so this is a good thing to have in mind that this model set is using the equals to function to determine if the object that you add to to yourself are equal so having this in mind now let's look at Maps so I'm going to close this I'm gonna delete this let's delete this let's delete this also now let's look at the next collection that you can use in kotlin and that is the map collection and use collection when you want to store key value pairs so I'm going to create a variable it's going to be called users and I'm going to put equals and I'm going to create first animated bottom up so we type map off map of and here you need to specify what kind of type is going to be the key so the key is going to be an integer but you can put any class you want here and the value is going to be a string so I'm going to store the ID and the name of an user and to Define our element in pairs here we type first the key and then we use the to keyword to map our kit to its element so 2 is value actually so type 1 2 and now the value let's first type Maria so now we have one element stored in paired and the key is one the value is Maria next I'm gonna do the same for the next one so I'm gonna type here two two the keyword tool Alex and then I'm gonna type three the keyword tool so inside you need to type the value now now type John now to get one element from this map with I print line we type here users square brackets and we type we get the element by its key as you can see by this hint key so we get let's say the element one so now if you run this code we get Maria because Maria has because this key code is for the for the key one the value mapped the value which is corresponding to this key is Maria and if you change this to two gonna get Alex if you run this so this is an immutable map in this map you cannot add or remove elements but if I declare this as a multiple map so let's change this to a multiple map so we type here mutable map off let's delete this from here and let's pass here and and string now here now so you need to put this in parenthesis here we can add new elements so we can type users actually first let's Loop through our mob to see our elements and I'm going to use the for each function to Loop so we type here users dot for each and we choose this one and inside our Rook without we are the print line and I'm going to put quotation marks and here we're going to put dollar sign I'm going to type T and T is the key and dollar sign U and U is the value so now if you're on this you get one and Maria to and Alex Three Angels so we have the key and we have the corresponding values and you cannot have duplicated keys and this is very important to know you can also add or remove elements from this map so to add an element you just type users and we need to specify the key so we put square brackets so we type user square brackets and then put a key let's say five and we put here equals to and here we need to pass a value so the value is going to be let's say Vlog now if you run this we get one and Maria two and Alex three and John N5 and the corresponding value Vlad so Vlad has the Kiwi the key value five so you can also remove an element from our map so we type users dot remove you know you you here for this remove function you pass the key of the of the element that you want to be removed and let's say that I remove two so I remove Alex from our map so if I run this quad now Alex you know it's not going to be shown here because it was removed on the line for so Alex was removed so this is how you can use the immutable and multiple Maps this is how you can add and remove elements and this is how you can Loop through our map and this is our discussion about Collections and see you in the next video now it's time to start a discussion about collections operations and we're going to look at the first operation and that is Transformations and we're going to start with the first one called mapping so I'm going to create a new project I'm going to call it collections operations IntelliJ then click on create we go on the left hand side click on kotlin right click new I'm going to create a new file I'm going to call it Main I'm going to create the main function now what are transformations as the name implies Transformations are some functions which which you can change a specific collection and we're going to look at the first one which is called mapping so I'm going to create first a collection so I'm going to type Val numbers and it's going to be a set so I'm going to type numbers you're gonna equals to set off and here we're gonna Define some values like one two three four five let's press Ctrl alt format the code now I'm gonna add the print line here now to use the mapping collection transformation we just type numbers and one important thing to know here is that those transformation functions are Lambda functions so if you don't know what Lambda functions are I suggest you to watch the section which is called Lambda function to First understand what our Lambda functions because it will be it will be very hard for you to understand how this how those Transformations work without understanding how Lambda functions work now here we're gonna call our our transformation function which is the first one which as I said is mapping and the function is called map I'm going to explain immediately what it's doing and as you can see it's a Lambda function so we're going to press enter and we we are inside the curly braces and here we're gonna Define our transformation so what we are saying basically here is do whatever I I type here in this those uh curly braces apply to every element of the of this cell of this collection so if I if uh now to refer to to refer to the parameter uh uh to the specific parameter from the numbers uh uh set we type it and I'm gonna type it times 10. so what we are saying here is do this transformation so change this uh change this uh this set by uh more multiplying every element inside the this uh this collection inside this set by 10. so if you run this now every number is going to be multiplied by 10. so if I run this now we get instead of one two three four and five we get 10 20 30 45 so what this map function and what this uh it times 10 did is is it transformed it changed our set into into what it it was changed by the expression that we defined here so we said that I want every element we said here to be multiplied by 10 and then we display them here we can go even further we can put here an if statement so we can type here if let's say it so it refers to the to a specific element in that list in that set so if it equals equals so if equals three I'm gonna say we're gonna say here it times 100. so what we're saying here if one of those elements inside these numbers set is equal to 3 then multiply it change it so change it by by the by this expression so multiply it by 100 and you can also put the else part so we put else you want to put it times so if the else part is true if the else part is executed we're saying if the number is not equal to 3 from this list then multiply the number multiply the number by uh by 10. so now if I run this look what we have here so we have 10 20 and we have 300 here this is because this transformation now is using the if and else statements that you define here so this is what the map Transformations allows you to do you can change you can transform a specific collection by an expression that we defined inside the curly braces of the map function all right now let's look at how we can can use the map transformation to with another collection unless you'll see how can you can use the map transformation with a map so with uh with the with the map which has a key and a value so to do that we just type here Val numbers map so I'm going to type file numbers equals I'm going to type map off and here I'm gonna type key one two one then key tool two two then key three two three and finally key for two four now if you wanna use the map map transfer transformation function on the map map collection you you you can use it either on the keys so you can use it on the keys or on the values so we can type here print line number map number map so we choose here Dot and we choose map Keys now so choose this one map key Lambda expression so map keys that one and here to type eat dot key so get the key Dot uppercase so that is going to upper case all the keys inside our map then I'm gonna add an another print line here I'm gonna type number map Dot map now choose map values and we type here it dot value so the Value Plus it dot key dot length now if you run this though this expression is going to be applied to all of our keys inside our numbers map that we Define above and the second transformation is going to be applied to all the values that we defined inside our numbers map so if you run this code now I'm going to see the the keys being first uppercase and then we're going to see the keys plus plus the length so you see first I get 10 20 300 for 40 and 50 for our first transformation that we have here then we have our second then we have our transformation on the map on the map keys so we have we have the key and then we have the value we have he and the the key is uppercase because we said uh to to do that by using this expression it so it uppercase all the keys as you can see here and then you see the corresponding value for the key after that you see you have numbers map map that value so you have it that Value Plus e dot key dot length so we have key and I have one and we have six we have key two and half seven so the key the value of the key is uh is uh to the value of the key it's added the length of the so to the value that we have here we we have added the the value length of the string key that we defined here so this way I have uh we have uh two then we have seven then we have eight and then we have nine so this is our and you can also you can also do for the uh map for the map transformation and we type here numbers Dot map and we choose this one index not node and here we choose we have two parameters first is the index and second is the value so I'm gonna choose the name for the first one index and for the second one let's call it uh value then you have the auto and here we have we're going to Define our transformation of our expression which is going to be applied on our numbers so here I can use the index so again I'm going to type here an effects if a statement so if index equals equals zero then I'm gonna assign so I'm going to transform to the to that we're going to put the value null to the index 0 else I'm gonna type index times value so else you're gonna uh multiply the index time times the value so if you run this we get 2 6 12 and 20. so for for the first one we get nothing because we for the first index we signed null and then uh it's using the else part to to transform our numbers list and it's multiplying the index by the value so we we first uh we first have this indexed uh zero multiply the here we have null for this because we checked here so we have not so at the index two we have one times two and uh we have two then here we have add indexed two we have two times three so the index is two the value is three and uh we we get uh we get six here and so on so this is how we can use also the index if you want in your transformation now we're going to look at the next transformation that you can do in our collection and that is zipping now it's time to look at the transformation function called zipping so I'm going to add a comment here called the zipping and I'm going to declared to list I'm gonna call the first one colors no particles I'm gonna type please stop I'm gonna type red Brown and Gray and I'm going to create another list called the animals stuff I'm gonna type here Fox beer quotation marks and uh wolf now what does the zipping or the zip functions allow us to do is to create pairs of elements with the same position in both collections so we can create pairs with red we can create a pair of fox and red a pair of bear and brown and a pair of wolf and gray and you can do that just by typing here print line and we have you can do this in two ways to type colors and you can type Dot dot zip and you type here animals and if you run this you'll see them in pairs so you're gonna see Fox thread bear brown and so on so you see here red fox brown bear gray also the zip and the zipping is used to create Pairs and the pairs are at the same position in both on both collections or if you don't want to use this Z function with parenthesis you can type here colors zip and animals and type here any models now if you run this code you're going to see the same output now if you want to use a transformation with the Z function you can type here print line you can type colors dot zip and I'm going to use the parenthesis animals and animals and now I'm going to put curly braces so the Lambda function here I'm going to type animal for a let's put for scholar and animal I'm gonna put the arrow sign and here I'm gonna type day I'm gonna but I'm gonna put first quotation marks and quite the and I'm gonna put dollar sign and we're going to refer our animal uh parameter that we defined here so we type here there animal Dot and we call the replace first chart function so type replace first chart and as you can see this also has uh I think along the function and inside of this we type it dot uppercase uppercase and this is gonna uppercase the first letter of the animal uh with the animal that is defined here and I'm going to type yes dollar sign color right now if you run this you're gonna see the force and the f is uppercase because it's uppercase by this expression that we have here it replaces and this it refers to the animal uh an animal uh variable animal variable that is defined here and it refers to the first letter so it says eat that uppercase so uppercase the first letter then uh then uh return that to the to the animal uh any more variable and we have the fox is red so I have the color and then we have the bear is brown the wolf is gray and all the animals start the capital letter like we Define here in this in this expression so this is the zip function so this is how you can use the Z function to create Pairs and also you can use the unzip function to unzip a list of pairs so first let's create a list of pairs so I'm going to type Val number pairs equals I'm gonna type list of and here we're going to put one two one two two three two three four two four now if you want to unzip those pairs that we created you can just type here print line number pairs let's first display them as pairs and the necklace print line and so let's type number pairs dot unzip now if you run this you're gonna see them first in pairs and then you're gonna see them unpaired because we use here the anzi function so as you can see here you have first one and you have one two two three three four four so you have in pairs first and then we have them separated so we have first one two three four and then we have the numbers one two three four so did you we unzip them we separated them they're not pairs now anymore with this unzip function this so this is how you can use the NZ function now it's time to look at the next transformation that we can use and that is Association now what is association association Transformations allows you to build maps from The Collection elements and certain values associated with them and different Association types the elements can be either keys or values in the association map I'm going to see what this means and the basic Association function is the association associated with which creates a mob on which the elements of the original collection are keys and the values are produced from them by the given transformation function so let's see an example with uh with this so I'm going to delete this code because it will make a doubt but hard to understand we could have so many things here and I'm going to type Val numbers you know put equals I'm gonna type really stuff nanotype here one two three and four now I'm going to type here print line numbers and we are going to use the association associate with the function so we type associated with and this is going to produce as I said previously it's going to produce a map in which the elements of the original collection are keys so the keys of this map are going to be those elements and the values are going to maybe are going to be produced by what expression we Define here inside the parenthesis so I'm going to Define here it so I'm going to type it dot length so now if you run this you're gonna see the keys being one and then I'm gonna see the value being the length of that specific element so if you run this we get the key one the value three the key two the value three then you get three the value is five then you get four and the value is four so what has happened now is that the associate with function created the map in which the elements the key the key are the elements of the collections so those are the keys inside our map and the values of uh those uh with the association with the associated with those keys are produced by the expression that we Define here by its dot length so basically gonna use the length of that specific element and it's going to be the value so this is why I have one three two three three five and so on now for building maps with collection elements as values there is a function called associate by it takes a function that returns a key based on an element's value and if two elements keys are equal only that last one remains in the map so let's look at this one so I'm going to type here print line I'm going to put here numbers so we type numbers dot associate by and now here going to define the expression which is going to build the key because now the the associate by function is going to build a correlation which the elements now are not Keys like we had previously but they are values so here in the expression need now to Define how the key for those respective values that we have here is going to be created so we type here it DOT first dot uppercase so this is what what is this is gonna do it's gonna create a key it's gonna use one let's say that we have element one and it's gonna take your element one it's gonna take the first letter of the element one and it's gonna uppercase it and you're gonna have o and as the key we're gonna have o and as the value we're gonna have one and uh for the next ones uh it will be the same so now if I run this quad foreign elements are the values here so they are the values previously The Collection elements what the key is and the the keys were builded by the expression that we defined here by this so we have o and we have t and we have four and we we have uh t uh only one time and we don't have two entry because uh you cannot have duplicated keys in a map so this is why you only have one only one t here so uh this is associated so this is Association now associate by can also be called with a value transformation function and to do to do that you just type here print line numbers that associate by now we need to apply a transformation now on the key and on the value and how gonna how gonna do that we can type here actually let's delete this because we don't need curly braces we put parentheses and we type here key and we have a suggestion key selector so we're gonna apply the First Transformation on the key so we type key selector that named argument and we put curly braces and here we type it so the key DOT first dot uppercase so now what we're saying here apply this transformation for every key in in in the map that is going to be built so apply this transformation for every key that is in the map that is going to be built so we're saying to uppercase uh to take the first letter and uppercase it then we also need to apply transformation for the value we put comma here at the end of our curly brace and we type here value you also have a name argument you put again curly braces and here we're gonna type it dot length so this is the transformation that is going to be applied to all the values in the map that is going to be built so this is the transformation so this is how all the keys and the the in the map that is going to be built are gonna be uh change so the first letter is going to take this thing is going to take the first letter of the keys and it's going to uppercase it this will uh we'll take the length of the the all the values in the in the the in the in the map that is going to be built and it's gonna display the the length of that element so if you run this we get 0 3 T 5 F4 so we have the first letter uppercase and then we have the length three then we have t we have the letter upper case and we have the value five the length of that uh uh element then we have F so we have a four and we have the the the transformation apply on that element on this element on on four and we have the length and we have four so this is how we can use transformation Transformations with the associate by function and the next we're going to look at the next transformation fact function and that is flattened now it's time to look at the next transformation function that you can use and that is the flattened function but first let's see why you'll need to use this flattened function in the first place so I'm gonna add the comment here called flatten and I'm going to create a variable here so I'm going to die Val it's going to be called numbers sets and this is going to be a list with list so I'm gonna type here list of and inside the list I'm gonna Pro I'm gonna type set off so we have a list inside the inside of our list and I'm going to provide some values to our set of like one two three then another set of four five and six then another set of seven eight and nine so what we are having now is we have a list within a list where the index of this list is it's its own list so we have a list of sets of ins now if you want to Loop through this list if you want to display the elements in this list uh it is not that easy because you will first need to Loop because let's say that because what we have here is what is called a multidimensional array so more specifically what we have here is a twodimensional array and at the index 0 we have a list at the index one we have another list and at the index two we have another list and to navigate to this list we need to first get inside that list that is at that other specific index to Loop to that list and then we need to move to the next index and to to look to that list to that next list which is that index but now let's see first how we can access one individual element from our twodimensional array so from our array of arrays and to do that to type here print line gonna put numbers set and if we we put square brackets and we Define the index from uh which from which list we want to access the element and now I want to access the element nine and the element 9 is stored at the index two so we put two and let's say that I want and I want to access as I said the the element 9 now to access the element line I need to go within this list and use the index to get the element I and element 9 is stored at the index two so I'm going to put square brackets two but this for whatever reason doesn't work with a list of sets and we need to change this to array of array of also those also change it to array of array of also array of an hour everything will work fine so array of so if you run this so now we are accessing the index tool where the array is stored where our number is stored and we get the element two we get element nine so now if I run this we're gonna see nine autopilot in the console so we get nine so this is how you can access one individual element from our multidimensional array so I'm going to delete this I'm going to change it back to to a list of and to set off so let's type a list of set off set off and set off and now let's see how we can Loop through this type to the dimensional array and to do that to type here four and type numbers I type specific numbers because this is gonna as as you can see um gonna hold on hold the numbers the set of numbers four numbers in number sets so now you we are you we are getting the as you can see here this is of type is the the type set of ins so this uh basically gets the element of the number set index let's say zero and it gets the first set and now we need to Loop through that set so another four number in numbers so now we are looping through the list through the set which is inside the list of the index zero I didn't zero and you can add the print line to add to do output that number I'm going to type here number and also I'm gonna add the space here so I'm gonna add the print line here and I'm gonna type here four or slash n now if you run this as you can see you have on the output one two three then we have a space four five seven six then seven eight and nine but uh we achieved this by using a loop and then we use another loop so we have a loop inside the loop we have a nested Loop in order to get to the to this uh two dimensional array because as I said the in the index of this array is its own list so it contains the list now with the flattened uh with the flattened function what you can do is that we can convert this twodimensional array in one dimensional array so you don't need to use this nested for Loops in order to Loop through to them it will return the nested the nested uh is it to private it will provide access to the nasty collection elements without you needing to Loop through this twodimensional Ray it will it will basically take that twodimensional array and it will convert it in one dimensionally and you will not need to create to have this nested Loop inside you have to have this Loop inside the loop in order to to display the number so to do that to type here uh Val numbers let's say flatten equals to number sales so our our list to it list that flatten now if you look at the type here now this is a list of fins you no longer have a list of sets of ins so this is a very very uh informative because it tells us that this now is just simply a list of ins is not a list with the set which is which is uh which itself is also or a list of events so this converts that twodimensional array in one dimensional array and because of that now it's much easier to get one element from our list because now our list is not a twodimensional array and it's just one dimensional array so if I type here print line and the let's say that I want to get the element nine I'm going to type here uh numbers flatten square brackets and I'm going to type here eight because it's stored at the index 8. so now if I run this so we get 9 here and as you can see this is much easier than uh with the the two that dimensional array so this is what the flattening function is doing is converting the the two dimensional array or if a multidimensional array in into one dimensional array so now let's look how we can Loop through our uh one dimension array so let's delete this and if you want to to Loop through this you just type 4 number in numbers flatten and we either here a print line number and let's comment this code and if you run this code now get the number displayed one after another so get one two three four five six seven nine and we got this because our function our flattened function our transformation function is transforming it's converting our twodimensional array in one dimensional array so it's easier for us to get the elements into loop loop through them so this is what the flatten function is doing and next we're going to look at the string representation and the functions that you can use uh what we for the for the string representation I'm going to close the console now it's time to start a discussion about string representation so if you need to retrieve the collection content in a readable format you can use functions that transform the collections to Strings and there are two functions to do that the join to string and the join two The Joint to string build a single string from the Collision elements based on the provided arguments the join 2 does the same but appends the result of the given appendable object and what that means is that it's gonna add the text to the object on which that function The Joint function is called you're going to see an example with this immediately and now I'm going to create a variable called numbers while numbers I'm going to put equals I'm going to call it actually numbers strings equal and I'm gonna type here list off and I'm gonna put here the text one two three and four now if you want to retrieve the this if you want to get the string representation of this list if you just type here print line and type you put your numbers strings and if you run this we get one two three and four but this I I think is calling the two string function it's not because we're not using the joint to string function and I don't like those square brackets I want them to be separated by comma with spaces to get the to get data just type here print line so let's put here print line and to type numbers to string Dot joint to string and uh we don't we delete this and put parenthesis now you throw on this you'll see now the single presentation of our list they are going to be separated by comma when we do is going to have a it's going to have spaces now let's look at the Joint 2 function and for that I'm gonna Define another list down here so I'm going to type here let's press Ctrl alt for model code so I'm going to type here uh Val is going to be called list string and now I'm going to use something called a string buffer and this is like the string type is a little bit different but it's gonna allow us to do is going to allow us to present how the joint function over so string buffer and we put parenthesis and here we Define our text and we're gonna type the list of numbers I'm going to put colon so the type here the list of numbers colon now to use the join 2 function just type here another print line we we type number string number strings dot join tool and as you can see this receives a buffer and this is the buffer that we have created here so I'm gonna press enter and we're going to type I'm gonna give us the argument the listing that we created and what is this this is gonna do is gonna append this text that we have here in front of all of our elements that we have in our list number strings so now if you run the squad as you can see it added the text the list of numbers that we have here to our number strings in front so we have the list of numbers one two three and four now if you want to build the custom string representation you can specify its parameters in a function arguments which are the separator prefix and postfix and the result will start with the prefix and end with the with the postfix and the separator will come will come after each element except the last so let's see how we can do that so um I'm gonna use I'm going to use the number numbers to string so I'm going to type here print line numbers to string and we type join join to string and we select this one with the you select this one with the which with the separator parameter and the type is separator so now we Define the what is going to be the S the separator here and we're gonna put quotation marks and we're going to put this so this is going to be our separator between our elements next we're going to define the prefix so we put we put here comma type prefix and now I'm going to put the prefix and the prefix is going to be the text start and colon so I put quotation marks start and colon and we also need to provide the post fix and to do that we put another comma here so those are named the arguments which are defined in this files and join the string so we type here postfix and we put colon and now if you run this you're going to see them separated by this separator that we Define here is going to have the prefix start and it's going to have at the end this post fix which is comma and N so now if you run this quad as you can see we have start and we have one then it's separated by the sign that we defined here then we have 2 3 4 and we have the end so we have our post fix that had defined here now for bigger Coalition you may want to specify limit so a number of elements that will be included into the result and if the collection exists that size with that limit all the other elements will be replaced with a single value called the truncated argument so let's see what all of this means so let's say that I have a list called the numbers let's type here Val numbers and I'm going to create a range from one to 100 so what we have here is 100 numbers and let's say that I type here print line but first let's convert this to a list so I'm going to put this in parentheses so you put this in parenthesis and you put at the end that to list and this is going to convert now our range into a list and as you can see the the type is a list of ins and now if I type here numbers and if I run this code when I get all of our numbers displayed now with as I said with the join join tostring function we can specify a limit and also a truncated this is going to be the thing which is going to be sold out after our number limits so what I can type here is I can type join to string and uh which is also one with parenthesis so hero type limit the named argument limit and let's say that I don't want to get all the numbers as you can see here from to 100 and I want to get only the first 15 elements to do this you just type here limit 15. then we type truncated and that is going to be that this trunky thing is going to be showed after our limit number so I'm gonna put here uh quotation marks less than um sine dot dot and uh greater than PSI so now if you run this look at what we have in the output now we get we only have the first 15 elements and then for the next elements we only have this uh string that we typed here this is this expression that we have here and we can change this if you can change this let's say to 25 so if you run this now you'll see only the first 25 elements displays foreign to string with the limit name argument and the truncated now let's say that you want to customize the representation of elements of the elements themselves you need to in that case you need to provide the transform function so what we can do is that we can type here print line let's say and I'm going to type number strings put dot join to string and choose this one with curly braces and here I'm gonna Define how this uh this uh list is going to be transform so how's going to be changed so I'm going to type here quotation marks element and I'm gonna put colon we're going to put the dollar sign and put it dot uppercase so we're gonna uppercase all the elements so if I run the code now get element and get one so you can get one uppercase an element to get two uppercase element three uppercase element four uppercase so this is how you can use the transformation uh we can this I can transform your list we using the joint to string function so this is our discussion about the string representation and now I'm going to move to the next sections so I'm gonna end the video now now it's time to start a discussion about filtering so what is filtering filtering is one of the most popular tasks in collection processing in kotlin filtering conditions are defined by predicates and that is Lambda function that take a collection element and return a Boolean value true means that the given element matches the predicate false means the opposite the standard Library contains a group of extension functions that lets you filter collection in a single call those functions leave the original collection unchanged so they are available for both multiple and readonly collections to operate the filtering result you should assign it to a variable or change the function after filtering now the basic filtering function is filter when called with a predicate filter Returns the collection elements that match it for both list and set the resulting Collision is a list for map it's a map as well now let's Define a variable here call number so let's type in val numbers I'm going to put equals to list of and I'm gonna type here one two three and four now if you want to filter this list what you need to do is let's create another variable here called longer then three I'm going to put equals I'm going to type numbers Dot and we type filter so filter and we choose this one and here we defined how our list so we will Define the expression which is gonna determine how our list is going to be is gonna be filtered so I'm gonna type here it so the element dot length let's say greater than 3. now if we I add the print line down here print line now this list is going to contain all the elements from our numbers list which are longer than three so if I put here longer than three and if I run this we get 3 and 4 because those are the only string numbers which have a length longer than three so I'm going to close the console next let's see how we can filter them up and for that I'm going to create another variable called numbers map foreign here the key is going to be a string key one the value is going to be one comma then key to to then key three two three and now I'm gonna put key 101 two 101 the value now if you want to filter now this map I'm going to create another variable called filtered mop and it's going to be equal to our numbers map but it's going to be filter so I'm going to type DOT number snap that filter and now I'm going to filter filter the map both by the key and by the value so we type here it dot key dot ends with so we we want to filter it first by the key and the one that key to ends with a specific character and that character is going to be one and so we put the operator and we want the the value to be greater than 100 so we put here it dot value greater than 100 and the only key which satisfy this condition that we find here it's only is this key so now if I add the print line here and if I type filter map so the map which was filtered using the expression that we defined here now if you run this you're gonna see gonna see this in the output because this is the only one which satisfy the condition so you get key 101 and we get the value 101 so this is how you can filter them up using the both the key and the value now the predicates in filter can only check the values of the elements if you want to use element position in the filter use filter indexed it takes a predicate with two arguments the index and the value of an element to filter correction by a negative condition use filter not it's written as a list of the elements for which the predicate yields false so let's see how we can do this so I'm gonna declare two variables down here file filtered index is going to be equal to numbers or a variable that is defined above that filter index and this is gonna take two parameters index and the value so I'm going to type here actually you need to put curly braces index let's change this to value actually let's keep it as s Ctrl Z and here we're gonna Define our expression by a by which our list is going to be filtered so I'm going to type here that first I want the index to not be equal to zero and I I also want that the value of the element so actually let's change this to valid to make more sense so let's type here to value because we're talking about those ones so I want the value of that string so the value dot length I want I want it to be less than a 5. all right so this is the transformation if you want this is not a transformation this is how we want to filter our numbers list that we defined above I want to filter both by the index so this is why we use the filter index and also by the value and I want the index to not be equal to zero this is the first condition for the filtering and I also want so use the end operator that the valued of the element the length to be less than five now if I print this if I added here a print line but first let's Also let's also use the uh filter not so I'm going to type here Val foreign filtered nut and I'm going to type equals numbers dot filter not curly braces and we type here it dot length so the value of the element is to be less than equal to 3. now if we output those two in the console so if I add here print line and I'm going to Output filter Index this should be filtered in the solicit Factor this so let's type here in the index I type it already so let's type here edex actually it will make more sense but I have Elixir so why anyway so I'm gonna output that first then I'm gonna hear a print line and I'm gonna type filtered not and filter not as I said is gonna return a list of the elements for which the predicate yields false now if you run those two look what you're gonna have on the output so this is the output for our first for this print line and for this print line so let's think about what we have here first we have two and four and we Define the filter here first the index which should not be equal to zero so the one is first excluded and we also want to that to the value that length to be less than five so the only ones which uh for which the value is less than five is the 2 and 4 because the length of the three is bigger than 5 because it has a length of 0 1 2 3 4 and the length is 5 but I want the length to be less than five not less than equal than five so this is why this is not included and you only have two and four next uh now use the filter nut and it's gonna as I said it's gonna return a list of elements for which the predicate for each this expression is gonna yield false so it's gonna go through all of our elements and it's gonna return the elements for which this is false so we get three N4 because those are the only ones which are not less than equal to three they are greater than equal to three so this is why we have here three and four because this returns if Returns the elements if the uh the the length of the element is less than equal to 3 so this is why you get here 3 and 4. and there are also functions that narrow the element type by filtering elements of a given type so there is a function called filter is instance which returns a collection of filaments of a given type being called so let's see how you can use that but first let's create a Val mixed let's call it mixed list I'm gonna put equals another card type list off and I'm gonna Define some mixed elements here so I'm going to type here let's say one two three then some charts like a B C now so on strings let's type here hello World another string Alex and let's also type a Boolean so let's type here let's say false now there is a function as I said which which Narrows the element type by filtering the elements of a given type so we can use this function called filter is instance so what you can do here is we can we can type mixed list Dot filter is instance so we choose I think this one not this one filter is instance of Y so mixture is that filter is instance and here with inside the angle brackets we Define the generic type for which this list is going to be filtered so let's first choose the chart Char then I'm going to put that for each so I'm going to use the for each Loop and I'm gonna add print line and I'm going to type it here so I'm going to type the parameter which is the each chart so now if I run this we will get only the charts being displayed here because it is filtering by using the instance of charge so you get the charge if I change this to to in now I'll get the integers from our mixed list so if I run this now get the integers one two three that we have defined here and if I change this to let's say a string I will get the strings inside our mixed list because filter is instance it's gonna take the specific title that you type here and then it's gonna Loop through all of those types which are of this type in this list so if I run this I'm gonna see Hello World Analytics so we get hello world and Alex also I can filter for Boolean values if I type here Boolean is gonna it's gonna output in the closet or the one Boolean value that we have here which is false so if I run this I get false so this is how you can use the filter is instant function on types to filter the mixed list and you can also put that because this Returns the list this entire thing a filter at least you can put that for each to call the the this the for this for each Lambda function and then we output them in the console uh the next thing that you can look and that we're gonna look at is called Partition so I'm going to add a comment here but I'm going to hide the console first so I'm going to put here a comment I'm going to type here partition part T1 so partition and this is an alter another filtering function called Partition and it filters a collection by a predicate and it keeps the elements that don't match in a separate list so you have a pair of lists as a return value the first list is containing the element that match the predicate the predicate and the second one is containing everything else from the original collection so I'm gonna take again our numbers that have defined the path so I'm going to type here uh file and to to get this partition we put we put parentheses and here to type match so this is going to be the values which are going to be matched by the predicate and I'm gonna type here rest and you're gonna be stored the rest of the value which which don't match the expression the predicate that's going to be defined and I put here equals numbers dot partition and we type here it Dot length greater than 3. now if I other print line here I can print first the match let's press Ctrl D and now I can print the rest of the elements which don't match this this condition this expression that is defined here so if I run this code you will see first all the elements which are greater than 3 and then we're gonna see the rest of the elements which are not greater than 3. but let's add the space here to make things more clearly so we're going to add a hero print line quotation marks for recession so let's run this again so we get three and four so those are the elements which are coming from our match list which is defined here uh which is uh which satisfy this condition which is greater than 3 so we have three and four so the length is greater than three and then we have one and two so those are the rest of the elements which are not satisfying this condition that is defined here so we have one and two so this is how you can use the partition function to to get the basically to get a pair in which the return of value the first is the first is the list containing the elements that match the predicate and the same code is the one containing everything else from the original collection so this is how you can use the the partition function so now I'm gonna end the video and see you in the next video now it's time to look at testing predicates and those are functions that simply test the predicate against the collection elements and we have three functions any which returns true if at least one of the element matches the given predicate then we have none which returns true if none of the elements match the given predicate and then we have all which returns true if all of the elements match the given predicate so let's test all of them so I'm gonna type here print line numbers that let's start with any so we put any so here we type it dot ends with and let's put let's say e then out of another print line numbers dot none it should be curly braces eat Dot and sweet let's say w and print line numbers dot all let's say it dot length so if if the length of all the elements is greater than one so now if you run this all of those gonna return either true or false so get true true and true this is because first testing any and then this returns true with at least one of the elements much in the given predicate so it is true we have two elements which ends with the E we have three and one so that's why you return true there then we check to see if uh none of the elements ends with W so we're checking to see if none of the elements uh in our numbers ends with w n is true not only for elements will end through double so we have two in the output then we check numbers.org so we check into if all the elements the line the length of all the elements the element strings that we have here one two and three are greater than one and this row all of them are greater than one so this one have true true intro so this is how you can use the test predicates uh on your collections first time to look at the plus and minus operators so in Catherine plus and minus operators are defined for collections they take a collection as the first operand and the second operand can be either an element or another collection the return value is a new readonly collection and let's look at an example on this I'm going to type here Val numbers you want to put equals two so now I'm going to type your Multiple List off Multiple List at least with we to which you can add and remove elements and I'm gonna type here one two three and four now if you want to add an element to this list you need to type here numbers dot add and here you need to specify let's say five and now this new element is going to be added to the list but with the plus and minus operator you can do we can do this in an another way so you can type here uh but I'm gonna put this in another list so you can type here Val plus list so we put equals to and type numbers Plus and to type five and now this element is going to be added to our list that we have here it's going to be added to the the string five and it's going to be stored in this plus list now let's look at the minus operator here Val I'm going to call this minus list and put equals 2 and I'm going to type numbers so now I'm going to use the minus operator so I put minus and we type minus multiple list of and we put here let's say three and four so we type here three and four I have an underline let's see what it says now anyway let's run our code to see what to get in the output but we need to add some print lines together so I'm gonna add here a print line plus list and another print line minus list now if I run this again we get one two three four and our Five Element added to our numbers list from our class list which is outputted here and then we get 1 and 2 because 3 and 4 were removed using the minus operator so this is how you can use the minus and plus operators with the collections so this is our discussion about the plus and minus operators and I'm going to look at we're gonna uh move to the next section so I'm going to close the console and I'm going to end the video now it's time to start a discussion about grouping so the kotlin standard Library provides extension functions for grouping collection elements the basic function Group by takes a Lambda function and returns them up in this map each key is the Lambda result so the result of that expression inside the Lambda function and the corresponding values is the list of filaments on which this result is returned this function can be used for example to group a list of strings by the first letter you can also call Group by with a second Lambda argument a value transformation function in the result map of group y with two lambdas the key is produced by key produced by key selector function are mapped to the result of the value transformation function instead of the original elements so let's see what all of this means by looking at an example so if I type here Val numbers and I'm going to put list of again one two three four and five now we I can add here a print line I can type numbers and I can type here dot Group by and I'm gonna group it by it dot first so the first letter in in one of our elements that uppercase and now we're going to look at the next the next Group by with the key selector and with the transformation function so I'm going to type here print line numbers Dot group y so we have this one key selector so you type here key selector equals and here we put curly braces and we type eat that first so the first letter in our element so first it should be here we put a comma and we type value so the how the value of the the value of this list is going to are going to be transformed and here we also put curly braces and we put it that uppercase so put it curly braces it should be it dot uppercase let's press Ctrl alt L to format code and now let's run our code to see what we get in the output so we get for the first one number the numbers are grouped by for uh and we have this Lambda it that first.apper case it takes the first letter in Upper cases so it gets whoa whoa so then you get one we get T we get to we get F we get four we get uh then we use this one which on which we we uh you we we group uh elements with a second Lambda argument with the value transformation function and the result uh map of group y with two lambdas are the keys produced by the key selector and the function are the function are mapped to the result of the value transformation function so the results are mapped to this transformation that is defined here so this this is what creates the keys this is what creates the key this uh Lambda function and this is what creates the the the the the values so we get all because you get in that first so the first letter and get one because this is the value so the value is uppercased we get one so we get one here then we get again eat that first for the for all men so you get T then you get two and I get uppercased and get F lowercase f and get four and uh and five so this is our discussion about grouping and uh my suggestion for you is to play with the code try different values for the key selector for the value transform for uh try to group The Elements by different expressions and just play with the code until you get uh get uh until you get comfortable with the code now it's time to start a discussion about the driven collection parts and the quoting standard Library contest accession functions for retrieving parts of a collection these functions provide a variety of ways to select elements for the result collection listing their position explicitly specifying the result size and others I'm going to start with the first function called slice which Returns the list of collection elements with given integers the indices may be based either as a range or as a collection of integer values so I'm gonna create first domain function I'm going to type Val numbers I'm going to create a list of and I'm going to type here one to three four five and six now to use the slice function we simply add here a print line and we'll type your numbers dot slice and we create here arrange so we type 1 dot dot 3 and next we're going to add another print line and I'm going to type numbers dot slice and I'm going to put here now zero dot dot four and I'm gonna type step two foreign list so slice here slice and I'm gonna add another print line here numbers dot slice and I'm gonna add now a set here so I'm going to type set off and I'm gonna type three five and zero so let's press Ctrl R till the format the code now if you run this code look at the output so you first get the first three elements we get to two three and four because uh we're starting from the index one so we get two three and four then we get from 0 to 4 so you get one but you don't get the two because you have this step two which steps the second element and then we have three and five because it's stepping for the four so this is what step two is doing here and next we have numbers slice and get four six and uh one but we get them as the string representation we don't get them as as a integers so all right now let's look at the next functions and those are the take and drop and to get the specified numbers of elements starting from the first you can use the take function for getting the last elements use the take last when call when when called with a number larger than the collection size both functions return the whole collection to take all the elements except a given number of first or last elements called the drop or the and the drop loss function respectively so I'm gonna add some print lines here I'm gonna add print line and I'm going to type numbers dot take three Another Printer line numbers dot take last hmm also three then another print line numbers Dot drop one and another print line numbers dot drop last five now if you run this code look what you get in the output but let's add a space here so on another print line quotation marks photosyn now let's run this code again so we get uh for you get numbers take three and this function basically takes only three um three elements from our list then numbers take last three is gonna take the last three elements from hourly so I have four five and six then we have a print print line numbers drop one so you have two three four five and six and the first element is dropped so this this is what this function is doing next we have numbers dot drop plus five and this function is basically dropping all the uh file the last five elements and you have only the one so this is what those functions are doing you can also use predicates to define the number of elements for taking or dropping and there are four functions similar to the ones described above and those are take while take last while drop while and drop drop last while and let's look at all of them but I'm gonna put a space between uh our code that we have here so I'm gonna have the print line here quotation marks photo session print line so I'm going to type here numbers dot take while and here we Define the predicate I'm going to type not eat dot starts with f in quotation marks now another print line numbers dot take last while and we Define here the predicate it not equal to 3. not equal two three another print line we type numbers dot drop while and we Define the expression the predicate which is going to be applied for our drop last while so it should be drop while here and type it dot length equals equals to 3. and what another print line numbers Dot drop last while and we type here it contains it dot contains quotation marks I no if you run this code we first get one two and three so because here we check in we're uh because using the logical not operated we want all the elements which don't start with f so we don't have four and a five we have only one two and three next we have numbers that take last while and we Define the expression for which is going to be returned the elements by it not equal to three so you only have four five and six and uh the the the three the three is is missing and we don't have one because take last value only takes the uh last elements so this is why we have only and six when you don't have three so it doesn't care about the first element or uh about uh the second element next we have numbers drop while eat that length equals to 3 and here we have we have so it at the lines equals to three and we have three four five and six so this condition is satisfied so it basically it drops all the elements which are equal to three so we have three four five and six and all of those are bigger than three and the ones which are equal to three respectively one uh uh two and uh let's see and six actually six is appearing here so one two I don't know why six supreme but this basically saying that it should drop while if that length equals uh to three so it basically drops all the elements which are equal to with the length three so we have this is what we have here um three four five and six six should not be but I don't know why it's here now the next that we have here is numbers dropped last while so again this is uh Focus specifically about the last element so it contains I so get uh uh one two three and four so because this drop last while is basically basically dropping all the elements all the last Elements which contain uh which contains I so we have six five so we have a drop last while so we have it that contains I so it drops all the elements which contains I so sorry for what I said previously so this way I have here one two three and four and uh the five and the six are missing because it basically drops the old Elements which contains the letter i so this is how you can use the take and drop the next function that you can use is called chunked and if you want to break a collection through parts of a given size then you can use the chunked function chunks take a single argument the size of the chunk and Returns the list of list of the given size the first chunk starts from the first element and contains the size of the elements and the second chunk holds the next size elements and so on the last chunk maybe may have a similar size so if I have here let's change this to numbers strings and let's type here Val numbers while I was changing that I should use refactor so let's use a refactor rename numbers strings so it will be changed in all the places we're using that and here have numbers and I'm gonna put equals and I'll put parentheses zero dot dot 13. and I'm gonna put that to list to convert this to a list and we add a print line to see how this chunk function is working so we got the print right let's close the console and we type here numbers Dot Dot chunked and would put three so it's gonna chunk our elements into three into um basically elements of three so we have zero one two three four five six seven eight and they're both on on chunks of three elements so this is what this chunks is doing so this is why I have here this result and the next function that you're going to look at is called windowed and and we we can also use a transformation on our chunked element so I cannot hear a print line we type numbers Dot chunked chunked which we also choose the size three then you put curly braces and here I'm gonna Define how our chunked elements are going to be transformed so we put it dot sum so it's going to sum the chunked elements so if I press Ctrl I'll tell the format the code and now if I run this look what we're going to see in the output so we get uh you get first the chunked elements here in entry in three elements and then we have our chunked elements but they are summed up so we have first three because zero plus one plus two is three then we have three four five because that is twelve don't have seven eight uh seven uh six seven eight and they have twenty one then we have uh 10 11 and 9 and we have 30 and so on so this is uh how uh you can use the chunked function to chunk the elements together by a given size and you can also use the transformation function to do a transformation on them like adding them so as you can see we have adding them here next we're going to look at the next function function that you can use and that is called the windowed function and we can retrieve all possible ranges of the collection elements of a given size with the window function the function of getting them is called windowed it returns a list of element ranges that you would see if you are looking at the collation through a slightly wind off of the given size unlike chunked window returns element ranges Windows starting from each collection element all the all the windows are returned as an element of a single list so if I have here the let's create another variable here let's call it Val numbers string two and we're gonna type here let's say or I can assign I can assign the number of strings here so I'm going to type here number strings now what I can do here I I can add a print line and like I can type numbers string store Dot windowed and we choose let's say three and let's see what we have on the output so now if you run this code I should have added here a space so let's add the print line here backslash photo selection foreign so we have one two three then we have two three four you have three four five and four five six so this is similar to junk but window provides more flexibility because uh you can specify a step which defines a distance between the first element and and to a DH and windows by default the value is one so the result contains Windows starting from all elements if you increase the step to two you'll receive only Windows 30 from the other element first third and so on and finally you can apply transformation to the return ranges right away to do this you provide the transformation as a Lambda function when calling windows so it is similar to chunked and um so with this I think we end our discussion about the thieving collection parts and see you in the next video and if you find this confusing don't worry because it's so confusing for uh for me for me and for probably other people because it takes time to to get used to this and my suggestion for you just play with the code change the the parameters play with the functions try different uh values and so on so see you in the next video now we're going to look at some functions with which you can retrieve single elements from our Collections and the first one is one which retrieves an element by its position so I'm gonna create the Val numbers again numbers equals to list of and we type here one two three and four and also five and let's say that I want to get the element at position three to do that just add here a print line and we type numbers dot element and here you specify the position three so zero one two three so we're going to get four outputted in the console so we get in the output as expected for now there are there are also two functions for retrieving the first and last element and to do that just add another print line here and type numbers that first so this is gonna retrieve the first element and Ctrl d numbers Dot last so this is gonna receive the first element one and last is gonna retrieve the last element five so if you run this we get first four from our disappearance line then we get first one and again the last five and we can also edit three elements by condition so I can type here uh I can type down here or or I will type it here actually I'm going to type it down here it's going to add here a print line numbers let's say DOT first now I'm going to retrieve by a condition so once I first I'm going to choose this one with curly braces and the condition is that I want to leave the first element for which the length is greater than 3 so I'm going to type here it dot length greater than 3. and I'm gonna add I'm gonna press Ctrl D because I'm gonna do the same thing for the by condition so I'm going to type here numbers that last but I'm gonna change the condition I'm gonna change it to eat that starts with the it that starts with the letter f so now we're retrieving the first element which is greater than three and next retrieving the last element which starts with the letter f so now if you run this we get 3 and 5 because 3 is the first element which is has a length greater than three and can get five because this is the one the last element which starts with the letter F and if you can other space here if you want to make things more clear so we're gonna add the print line quotation marks backslashing actually forward selection so if you run this we get three and five output today in the console and we can also retrieve a random element from our numbers so I can type here print line numbers dot random and this is going to return a random number from our list of numbers so if I run this we get one and if I run this again get four so every time you run this you'll get a random number and you can also check if the list is empty so you can type here print line numbers that is empty then that is going to return true if the list is empty and if the list is not empty it's going to return false so if you run this we get false so this is our discussion about how to retrieve single elements see in the next video now it's time to start a discussion about aggregate operations so kotlin collections contains functions for commonly used aggregate operations and those are operations that return a single value based on the collection content most of them are well known and work in the same way as they do in other programming languages and we have minor null and Max ornal which return the smallest and the largest element respectively and on empty collections the return null then we have average which Returns the average value of elements in the collection then we have sum which Returns the sum of elements in the collection of numbers and have count which Returns the number of elements in our collections so please declare a list numbers list of let's put so let's put some numbers here like let's say six then 14 4 let's say 100 now let's press Ctrl format the code and let's add the print line here let's put quotation marks and let's type the sum is dollar sign and the type here numbers dot sum numbers that's sum all right and uh I'll add another print line and now this is gonna say the count is again dollar sign numbers dot count another print line the average is again dollar sign numbers that average another print line and now I'm going to say the max value is again dollar sign numbers dot marks numbers Dot marks or null and I'll print line the mean value is dollar sign numbers that mean or null now if you run this code you're gonna see in the output the corresponding values for those expressions that we have here so again the sum is 134 the count is 5 because we have five elements here the average is 26.28 the maximum value is 100 and the minimum value is 4. so this is how you can use those aggregate operations and agree and those aggregate um functions and beside the regular sum there is an advantage so much summation function called sum of that takes a selected function and Returns the sum sum of its application to all collection elements and let me show you how this works so you just type here so we type here print line the sum is dollar sign numbers dot sum of we select this one and here we type it times two now if you run this what it's going to do is it's gonna sum all the numbers like the first function that we have here so it's going to sum 134 and it's multi is going to multiply that that number by two so if you run this we get 260 which is 132 times 134 times 2. so this is how you can use the sum off with this uh transformation which is gonna basically multiply the list with a number with the with the sum of the list with the number so this is our discussion about aggregate operations and see you in the next video now it's time to start a discussion about ordering and in this video we're going to look at comparable and add comparator interfaces so first I'm going to create a list of numbers and I'm not gonna I'm gonna get a multiple list so Multiple List off and I'm gonna Define some numbers here not in a specific order so we type two let's say five one let's say 40. 20. 100 let's say 60. now what if I want to order the numbers that I have inside our list numbers to do that you just need you type numbers Dot and there is a function called sorted so if I type number that's sorted now our number on our numbers are going to be sorted so if you type here for each put in the line it so now if you run this even though we didn't type our numbers in ascending order there will be sorted and as you can see they are sorted we have one two five twenty forty six three and one hundred so they are sorted by this function called sorted and why this is working it's working because if you click on this sorted function what a actually if you type here let's say let's say that I put the type here and if I click on the type this tie this type integer this class is implementing this thing called comparable and this comparable has a function called compare to so when we actually type numbers that are sorted what what internally was happening is that the integer class was using the compared to function which is which is a function which you want to you need to implement if you implement the comparable interface to compare if to compare our numbers and to based on that to to sub them to to sort them and now let's say that I have or let's say that I have a data class called laptop and it's gonna have a variable called brand it's going to be of type string another variable called here this could be the the year one one this specific version was released on int also need and the wall let's say um price also an integer right now if I create here a list of laptops laptops equals to Multiple List of and I type here laptop let's say that I type here Dell and I put the year let's say 2021 the ram let's say that is four gigabytes RAM and the price will say that is 600 okay comma I'm going to create another laptop here so another object I'm gonna type here let's call it Acer is going to be let's say the year um let's put 20 20. the para is let's say the ram let's say that is eight gigabytes Ram and the prices say that it's 100 dollars comma and let's create another laptop object so we type laptop and create an Apple laptop which is which you're gonna for which you're gonna choose the the year let's say um Tony 2020 2022 and for the ram let's say they're choose 16 gigabytes RAM and 1 000 for the price now if I type here laptops that sorted let's say that I want to sort the laptops as if you can see while on time pink the IntelliJ is not giving me any hints to have this function sorted as a true fill in that function because that function is not working on our laptops list and why why is happening that that is happening because the IntelliJ doesn't know how we want to sort this laptop list that we have here because you want you can sort it in many ways you can sort it by the name you can sort it by the year you can sort it by Dynamic and sort it by the price so when you say laptops are sorted the IntelliJ is not it's not annoying what do you mean because previously it was working with our integers or and without integer class because the integer class if you type if you put the type here back integer the integer class or the int class what I was doing actually it was inheriting from this comparable interface and it was implementing the compared to function which is used when you call the sorted function and inside this comparative function it has defined its own Logic for comparing integers for comparing whole numbers and what we need to do in order to be able to sort our list of laptops is we need to implement the comparable interface and you need to Define our own logic which is going to determine how our list is going to be awarded by by which uh property by the Year by the ram by the price so this is what you need to do and to do that just put here a colon and we'll implement the interface comparable so we type it comparable and we have a suggestion you should choose this one we put angle brackets and here we type laptop because you want to implement this we want to compare laptops so laptops so this swipe water level there then you put curly braces and now we need to implement the function so click on that it says Implement members you have the compare to function now you don't need to Define our logic which is gonna determine what makes uh uh zero the final logic which is going to determine how our elements is going to be watered by what criteria and I'm gonna order the the laptops first by the price and to do that to do that just type if and to type this and we type in this because this is going to be called on an inst an instance of our laptop left of class is going to call the compared to function and it's going to compare with another argument so if this dot price we say here is greater than other that price we we return as positive number so we type return one and a positive Value Plus simply shows that the receiver object so the objects this object is greater than the the uh the object which was passed so this is what this means this one else lcf is the receiver object is not so if this dot price is less than other that price let's say then gonna return 1 a negative number so I'm going to put here minus one and what this basically logic is I'm just going to swap them so it's going to swap the elements based on this logic else I'm going to return 0 and that is going to mean that they are equal so if you type here return 0. and if you click here it says that you can write this in a different way so if you click on this and let's add the print line to see that our if if uh are called so if I type here print line I'm gonna say in if statement dollar sign actually let's type swapping dollar sign this dot brand name with dollar sign other dot brand so let's add this print line also in our lcf and I'm not gonna add in inside the ears because our we don't have Elements which are equal but you can add that if you want now if I type laptops that's sorted now I have a suggestion and if I type for each print line it so print the element now if you run this look you're gonna see the elements sorted and uh ascending order by their uh their price so you see that we have first the brand the brand name Dell and we have price 600 then we have the price uh you have laptop Acer and we have eight hundred dollars and have left to apoll the brand and you have the price one thousand dollars so the nearest so now they are sorted using our own logic which was defined inside this comparable interface and which was defined inside the which was defined by this comparable interface and which was defined inside this function compared to that we've overrided inside our client and as you can see if uh you look you see here that he says if an if statement swapping Acer window so the elements are swapped based on our road in if statements it says swapping apple with Acer so they are they are swapped based on our logic so this is how you can use the comparable uh interface but what if I want now to compare by the let's say uh RAM what can I do I can't implement the comparable interface again here and I can't uh I I can I can add the that property here but that is gonna conflict with my logic with for the price so what can we do and here comes into action comparator with comparator you can compare your uh your list you can you can uh com you can order actually I should say you can sort your list using multiple properties so you can order it by the uh brand name you can order by the year we can already buy the ram you can already buy the price and with compare because with the comparable interface we can do that just only by one property and that is pretty uh inflexible and it's not what you want and how how to use this comparator to use the comparator we just type here class I'm gonna call it comparator let's say Ram and it's gonna extend from comparator so type comparator and you have the type and for the type here we want to compare laptop so you type laptop here angle brackets curly braces and press enter and now we need to override the compare function inside our class so you override that function and here again let's change those to laptop one so no now we have laptop one and laptop two and we Define the same logic so we type here uh return if because you need to return an integer if this dot Ram actually not this that ram laptop laptop1.com is greater than laptop 2. Ram and we need to delete this nullables because you need to have some errors there and put curly braces return one else if else if laptop one dot Ram is less than laptop 2. laptop two dot Ram then gonna return I'm gonna put curly braces I'm gonna type return minus one else we're gonna return zero now if I want to now to compare our let's add the space here now I want to sort our elements based on the RAM and another print line here to add a space so I'm gonna have the biggest photos in also here one so go quickly space it here should be print and now what we can do is we type laptops Dot and we type here sorted with and which is we choose this one which has the parameter Define a comparator and we're going to pass our comparator that we defined here with the comparative function so I'm gonna pause I'm going to type sorted with and we type comparator foreign our class and create an instance and within the type dot for each now this one for each print line it so now if you run this you're gonna see them sorted by their border Ram so if you run this as you can see uh if you look at the if you look at the first there are they are First Source did by their price we have 68 800 and 1000 dollars and then we have them sorted by the ram so we have four for the four which is the dell and then we have the Acer which is uh eight gigabytes around and you have the Apple which is 16 and uh if you look uh actually they are in this order in the list so let's change this to to let's say to 16 and these two to wait to to make it more clear so let's run this again so as you can see they are still started so we have first the Dell which has four gigabytes of RAM then we have the Apple which is eight then we have the Acer which is 16. so this is why so now it's sorting our list this sorted width using comparator Ram that we defined we created and then we Loop through all our all elements because that Returns the list so this is how you can use comparator and if you want to uh to to sort of let's say now the list by the year you just create another comparator so you type class comparator let's say here and it's also going to extend comparator comparator is going to have for the type laptops because it's gonna Source laptops curly braces we implement the function compare and to define the logic for comparing elements using uh using the ear so let's delete this nullables let's type here laptop one and here laptop too and I'm gonna copy this chord I'm gonna paste it here but I'm going to change this from Ram to here so here here also here again and we have an error here missing so let's add the curly brace here all right so now if I want to to have the element sorted by the year we just type here let's put a space Also print line quotation marks for us this run and found the laptops to be sorted by the by the by the year I just like laptops that sorted with and this expects a comparator so I'm gonna call our comparator that we created comparator here comparator here an instance of that then for each now this one again for each print line it so if you run this now we're gonna see the last element sorted by their ear I have as you can see you have uh we have them sorted by the ram so this is from this one and now it's using comparator here so you're sorting the embodies we have 20 20 21 and 2022 so this is just not like the order that they are defined in uh in the list so this is how you can use comparable and comparable but if you think about there is a lot of code here to just have to have our our list so that you have to we found to you have to you can use the compare the comparable and with the comparable you can use it with just one property and if you want to use it with another property you have to create those comparators which gives you some flexibility but still you have a lot of code and we can remove all of this code and use Lambda functions so I can delete all of this all of this comparable that we have here and instead of using those comparators and all of this stuff what I can do is I can delete all of this I can little or this also now what I can do is I can add here laptops dot sorted with and here so we choose this one sorted with which has this parameter comparator press enter and here we type compare by and here we type and this line of code that we have here we it what it actually is doing is creating a comparator but is creating a comparator using a Lambda expression so here you can type it dot it's dot let's say uh price right and then for each print line it so this is equivalent to creating that comparator here and inheriting from the comparator interface and defining the logic for uh uh or ordering for sorting them so now if you if you run this this will have the same effect like the comparator price that we have implemented previous as you can see they are ordered now by the price and I can do now on another line of code Source dot laptop dot sorted weight and we type here compare by we type it dot let's say uh Ram dot for each print line and it now if you run this I'm gonna have the same output let's add the space between them print line so let's add the space to see them to see the code more clearly and now as the as you can see the first they are sorted by their price and then they are sorted by their uh their RAM memory so this code is equivalent to creating what we had previously with the comparator and implementing the dotting interface and the function and actually there is a shorter way even to do this we can delete this let's say so the sorted with and compare bear compare by and we can just type here sort by so this this will create internally the same thing that we had previously so if I type it dot ROM and I can do the same thing here I can delete all of this and I just could type here selector the sort by eat that price now this will have the same effect like all the code that we had previously but now it's extremely concise and easier to read you just say laptop sorted by sorted them by their price so the elliptos by the ram so if you run this code you'll see the exact output in the console because what this function is doing uh actually we should Loop through them so let's add the print line here print line it so let's put here for each put into line it so now if you run this you will see the exact same output we just this simple line of code so as you can see you have the same output we have them sorted divide their price first and then they are sorted by their RAM memory and if you hold Ctrl on this sorted by function as you can see this actually internally calls the sorted width which receives the comparator and is calling the compound the compare buy so this is like a syntactical sugar for us which makes the code more concise but internally it's using using that sorted weight and uh if you want to use the salt to do it one advance for using a sorted with let's say that I type here another print line to add a space let's put photos lesson should be in quotation marks forward slash n one good thing about the sorted width so let's type laptops Dot sorted weight and here we type compare by let's say it dot year one thing that you can do with the sorted with if you call specific restorative function you can put that and then buy so it will sort by year and then by I know let's say uh it dot price so this is what you would get what you can do with the sorted with you can sorted by year first and then by uh by the price so if you run this as you can see they are sorted first by the year so and then buy their uh their price so this way we get this in the output now I'm gonna end this video and uh you should you should use this uh this one always because it's concise monitable yeah very easy to to to read and to and to type is in contrast with what we had previously with the or creating that comparators and implementing the comparator interface or the comparable this is a lot a lot more concise and easier to read so this is our discussion about the comparable and comparator interface so this line of code I repeat this line of code that we have here this sorted by it does RAM is creating internally that comparator that we talked about the node we're just using this Lambda function so I'm going to end the video now and see you in the next video so there is one mistake that I did previously so if I press Ctrl Z to have this code uh when I run this code you you didn't sound output then the list sorted by the year and then by the price and that is because I forgot to add the four each to Loop through our elements so if I add the four each and now if I run this now we're gonna see them sorted first by the year and then buy the price because previously it wasn't so this is why it wasn't now if you look they are sorted by the first by the year so we have 2020 2021 and 22 and then buy uh by their price so this is why previously you saw this one this output and also I saw this output that but uh some way I uh I didn't uh didn't saw that I forgot to add the foliage here so this is how you can also sort the sorted width you can um sort it by more elements you can put here I think another then buy not here we can put another so dot then by you can put another then by here if you want so eat that so let's say your RAM so you can add more more than buy if you want so now I'm gonna end with the video see you and see you in the next video now it's time to start a discussion about binding the search but before you look at binary search you're going to first look at linear search to see why a binary search works better so I'm gonna type a function here I'm going to type private fun it's going to be called search element and you're going to type search elements so this parameter is going to be the element that we are searching for and it's gonna then another parameter is going to be a list of numbers so it's going to be a multiple list of ins and it's going to return a number the search element or minus one if you don't find the search element and here we're going to Loop through our release so I'm going to type for number in our list of numbers if at a particular iteration or number it's equal to the search element that means that we found the element that we found the number so we're going to return number else if you come down here and after we Loop and we did our if checks we didn't return the number that means we didn't find a number we're going to return minus on here now I'm gonna add the print line here and I'm gonna type search element because this is going to return an element and then you're gonna output with the print line dot in the console and I'm going to type here 27 and for the next parameter I'm going to define a list of numbers one time Multiple List off and here I'm going to define a number from 1 to 30 so I'm going to type here the numbers one and our last element 30. now if you run this code you're gonna see in the output 27 so we get as expected 27 but let's declare a variable here I to number the number of iteration it took it took to find the elements I'm going to assign 0 to it I'm going to increment it every time you Loop so I'm going to type Val I'm going to type I sorry plus plus and I'm gonna print line here and I'm gonna it's gonna say search number colon dollar sign I so now if you run this we're gonna see how many iteration it took to found our element and if you look at the console as you can see it took 27 27 iteration before we found our element because the way the linear search is working is it's going through all of the elements is checking out each iteration if the number of that particular iteration is equal to the search element if not it's going to loop again and again again until it reaches 27 then it found that element and it Returns the element and you get that element outputted here in the console so this is what we call a linear search and this is not particularly good because imagine if you have 1 billion elements or 10 billion elements and you need to find I don't know maybe the 7th billion element in the in that array that is going to be very hard and it's going to take a time and memory and because of that we have another data structure for a searching element and that is called binary search and I'm going to type the code for binary search here and also you're going to see the number of iteration it tooks to find element and also I'm going to explain how binary search works so I'm going to delete this I'm going to type here VAR low I'm going to put equals to zero VAR High equals to numbers that size minus one I'm going to explain the code immediately here I'm going to type while low is less than equal to high here I'm gonna type Val mid so now we're going to get the middle element so I'm going to put parenthesis slow plus High divided by 2 and that's going to give us the middle element 15. then I'm going to type Val comparison so I'm going to type CMP equals to numbers dot get the middle element compared to we're going to compare the middle element with the search element then I'm going to type here if now I'm going to type if comparison is less than zero then I'm going to type here low equals to mid plus one lcf if comparison is not less than zero so it's greater than zero I'm going to type here that low is equal to High sorry is equal to my mid 1 else when I type here return numbers dot get meet and that is going to give us the middle element now if I declare here a variable VAR I and if I assign 0 to 8 and if I increment that I at each iteration and if I add a print line here search number dollar sign I now if you run this you're gonna see uh you're gonna actually I should return minus on here because uh if at the end of our looping and after we checked our all of our list and we didn't find the number then we determine this one meaning that we didn't find the element so now if you run this again we get search number one two three and then we get 27 and as you can see this is significantly different from our linear search because now we only took three searched and then I found the he found our element previously we had to search through all of our elements through our elements until uh the number 27 to to get the number seven but now we only get the three iteration and we get the number 27 and how is that possible this is because now we're using what is called the binary search and how this binary search works I'm going to explain it now so now let's see how the code works so first we have a variable declare code load which assign a value of 0. then we have another variable called height which assign number the PSI minus one so we assign the size of the array to our high then we have a variable called I to which you assign 0. then we have a while loop and we start looping by this condition while low is less than equal to high then we increment our I to keep track of how many iteration it takes before we find the element and without any console search element and the number at that iteration then we have a variable called mid and this is going to give us the middle element and to get the middle element we add the lower lowest element plus the highest element so yeah we'll add here 0 plus 30 divided by 2 which is 15. so this is the middle element then we declare another variable called comparison and we type here numbers that get the middle element which is 15 compared to search element and if the middle element is less than the search element that means that the search element is on the right of the numbers which come after the 15 and because of that this is gonna return because our middle element is less than the search element is going to return a negative number so this is going to be true comparison is going to be less than zero and then I'm gonna assign low equals to Mid Plus on so now the low variable has the value 16 all right now it will loop again it will uh it will uh do it will have the I incrementally it will do the while loop it will increment the I again and it will output into I in the console now here now it will calculate again the middle element and it will it will add now 16. Plus 30 divided by 2 and that is going to give give us 23. all right now that is the middle element now and what we do now here is we again uh I have our variable comparison and we get numbers that get 23 so we get the 23 element and we compile with our search element which is 27. and again because our middle element is less than the search element this is going to return on any negative number so this shift check is going to be true again now what is gonna happen is that now low is going to be equal to Mid plus 1 and the low previously was equal to 23 so now I'm going to have 23 plus 1 which is 24 all right now this will loop again or loop again so as you can see this basically breaks the the list in half at each iteration and now this will loop again it will increment the eye to Output I and now it will calculate again the middle element now the middle element is 24. and the high element is 30 and we have 24 plus 30 divided by 2. and that is 27 the exact number that we are searching for so this is how binary search works it will compare the middle element with the search element if the middle element is less than the search element that means that your element is on the right side of the element which come after the middle element so all the elements from the left are going to be excluded and it's going to search only on the on the right side then it will split the list again in half if the middle element again is less than the search element it will go to the right again it will speed the least in half I need to sooner or later it will find the element to to to the right or to the left so this is how one research version is very powerful because for a very big uh list you can use binary search and it's more effective that uh only the linear search and uh this is the code that I type but it doesn't you don't need to use this code because uh I only type this code to show you how the binary search works but usually you'll use the binary search function provided by The Collection so you will just type here return numbers we're gonna put square brackets and I'm gonna type binary I'm going to type here numbers again binary dot binary search because the binary search function provided by The Collection only return the returns the index so if I search for the 27 element that is going to return the index 26th and the index 26 then it's gonna be the number 27 from our numbers list so now if you run this you'll see 27 output in the console so get 27 and we did this one with one line of code you can even remove this and just have a single expression function so we can put here equals so just by that it will do the same thing that we did previously with all the code that I typed so this is our discussion about binary search and see you in the next video but before I end the video I should say that binary search only works with the order collection of elements so your elements need to be sorted in order to for the binary search to work and in our case we look we used integer numbers and it was easy because we typed elements in a in a sorted order but uh if the elements are not sorted by by research is not going to work also if you have your own class so you have your own objects and you search with using one research uh through a list for a specific element in that case your class has to implement the comparable interface or it has to to to to use the comparator interface and I'm going to show you how to do that in the next video so see you in the next video so now it's time to start a discussion about genetics so what are genetics genetics allows us to give to the compiler some hints about what kind of objects you are dealing with and this helps the compiler to figure out some errors at compile time and it also helps us to write more consistent and better code and we already use genetics when we look at collections so every time you use an array and you you specified in the angle brackets an INT or a double or a class that you created an object what you actually did there is that you use generic you set the compiler that that is the kind of data that specific collection is gonna store so if you have something like this while let's say numbers and we put equals is equals here and type array of here you can put angle brackets and you can specify a type here let's say in because I'm going to put numbers here and now this helps the compiler to figure out if let's say we want to add here let's say a string so if I type here numbers equals let's say your some text let's put in quotation marks some text as you can see you have those underlines red which says if you hover over here first it says that Val cannot be resent so let's change this to VAR to get the error that I want so let's put VAR here so we get here type mismatch required and found string so here we are using a generic type and the generic type is an integer and because we said explicitly here that this array is only going to store integers we cannot go down here and assign some string but as I said at the beginning genetics are only a compile timing feature they don't make it through the runtime and again we're going to come back to this later because this has some implications now let's uh delete this and let's create our own generic class to see how it works because here we're passing in but if you click on this array of you see that you don't have here any an intest the type that we SP we specifically decided to pass to this array but if you look here inside this library.kt and if you go to array here you see you see that we have VAR Arc elements and we have this t and T is a genetic type and the specific type that is going to be passed here is the type that we pass when we create an arrays when we want to store some numbers or some strings and now now let's see how we can create a similar thing that we have here with our with our own code so I'm gonna delete this so again generics are there to to to help the compiler to figure out errors and it also they are there for helping us to write better and consistent calls so that you you don't add let's say uh strings to to an array which is meant to store only numbers so first I'm going to create a class and it's going to be an Open Class and it's going to be called player and it's going to have a property called name so it's going to be a Val name we're going to Define this in the primary Constructor it's going to be a string now I'm gonna create open class here and down here I'm going to create two classes first is going to be called football player so football player and this is gonna have a name and it's gonna be a property because you're gonna gonna extend from our player class we're gonna derive from our operator class I'm gonna pass this property to the dot parameter name to our property name from the superclass so if we type here player because we were in inheriting from it and here first name so you pass your name next I'm going to create another class called baseball player so we type here baseball player and this is also going to have a name also only a parameter because the property is going to be ultimately defined by the superclass by the class from which we are inheriting from so here we're gonna inherit put the colon to inherit from our player player class and here we pass our name parameter that we defined here we pass it here to the primary Constructor of the base class from which we are inheriting from all right so now I'm gonna go up here and now I'm gonna create a class called team and this class is going to represent a team and this thing can be a football team or a baseball team and here we're going to create the class called team so we type the keyword class I'm gonna call it team and now here we put angle brackets and inside the angle brackets we're gonna Define the generic type t and you can use a different letter here if you want but usually and generally use the T because it stands for the for type parameter next to put parenthesis to define the primary Constructor and for the primary Constructor I'm going to define a Val name and this is going to represent the name of the theme and it's going to be a string and next I'm going to Define also valuable this is going to be called players and it's going to be a multiple list of also of type T so we type here Multiple List and we put here t right now I'm going to put curly braces because I'm going to define a function inside our class team so here we type fun and I'm going to call this function add players so this function is going to add players to the team we put parentheses and here we Define a parameter called called player and it's going to be of type T so it's going to be should put a colon here and we put curly braces and this is going to receive a parameter of type T and this type T that we Define here and here and here is going to be the type the specific type that we gonna pass when we create an instance with our class team so first here we're gonna check if the players so our list of players contains this player that is passed our ad player function because if or you already have that player in our list We're Not Gonna add it to our list so if player and to check if that player is in the list we call the contains function on our uh on on our uh Multiple List so here we we type players that contains player the argument and if that is true I'm gonna put curly braces and here we're gonna output something because to the console so we type here print line quotation marks and we type player colon and then we put dollar sign curly braces and here we need to do something which is called casting and casting casting is used when you want a variable to be treated as a certain type of variable so when you want a variable to be treated by the component by the compiler as a certain type of object or or a class so we type here player because let's let's let me show you why we need to do that because if I type here player now I want to get the name and if I put here dot name as you can see we don't have any name here because because this type because this T and this T that we have here is generic the compiler has no idea if this T that is going to be passed here so this piece so if you pass here a baseball player or football player it has no idea if at this moment now if that is gonna have uh is gonna have a name property on it this is why when you type here that's name we don't get nothing and to solve that we can say to the compiler for them to the compiler to treat this parameter here so this is going to be a value pass to this parameter as a player and in that sense in that in that way you can get access to the name property so we type here player and to cast to cast a variable to a certain type we put as so we put the keyword as and the type player and we put this in parentheses so we surround our expression in parentheses inside the curly braces and now here at the end of of the of the end of the enclosing parentheses you put that and now we have access to name because we settle the compiler hey treat this player variable I don't know because I don't know if this is going to be it's going to be a player a player object passed here or a baseball player or or a football player treat this player variable that is passed here as because here we have teeth so we don't know what it is three display to display a variable as a player so you can use the name of a variable and we're gonna say is already in the TM and we can put here the team and we can type here dollar sign this Dot name so the name of the TM else if if our player is not in the team we put else we're going to press enter to add the right curly brace we're gonna add this player to the list because if the if fails that means that the player is not present in our list so we type here players our Multiple List dot add this player that is passed player and we're also going to output something to go to the console so you add here print line and uh I'm gonna copy this because I'm just gonna change the text a little bit so let's delete this player and so here is we're gonna say instead of it's already I'm gonna say it was added in the team now let's create some objects with those classes that we have here so first I'm going to create some some players so I'm going to create first the football player so type here Val for the ball player equals football player and for the name I'm going to use a generic name I'm gonna type just football player one and I'm gonna press Ctrl D to create another football player so football player two is going to be called and I'm gonna create two baseball players so we type here Val baseball player equals baseball player and we type here baseball player one and I'm gonna call Press Ctrl D here also I'm gonna call this baseball player 2 and I'm gonna change this to 2. now I'm going to create an instance of our team class so we cut we type here Vault team and this is going to be a team of football players so we type Val team equals and hero type team and we put now because as you can see it's expecting a type here and the type is going to be football player so it's gonna be a team with what it's gonna be a team with the football players and you're gonna Define a name also generic name football team is going to be called and they also need to pass an array there and for this array I'm gonna type just uh mod multiple array of we can't foreign list of and here I'm gonna pass our football player I'm gonna pass only our first football player here now I'm going to create another team Val team uh let's actually call this first team football team so let's type here food bowl football team now if you run this code we don't get it on any output because our ad player's function wasn't called but if I type here a football team foreign actually here football team that add players and I'm gonna add football player too now if I run this code we get football player two was actually here should be added football player 2 was added in the team football team so our code works well and we use generic types for our classes here we specified only the T and this T that we have here was replaced with football player that we Define here and um uh we're gonna do the same thing we're gonna create another theme for the baseball player and we're also going to look at how we can restrict the types that are going to be passed to our generic type here so now I'm going to create a baseball team so I'm going to type here Val baseball team put equals then you put Here theme and here we type for the generic type T baseball player because this is gonna store baseball players and we Define a name here the name is going to be baseball team or generic name and uh also you need to type to pass a multiple list so type Multiple List and we pass here a baseball player but as you can see here for the type the type here is great oh that is because here we pass the football player uh object that we create then here we pass the baseball player because kotlin has Type inference it can infer the type as being a team of football players so we don't need to put here for the player we can delete this you can delete all of this and now our code still works and you can see we have this type here which says team football player so it's a team of football players and it's uh inferred it's inferred automatically by quoting for us and you can do the same thing if here for a baseball player so I'm gonna delete this as you can see now we also have the hint team baseball player now let's add to the baseball player let's call the baseball player function let's put here a so we type here base bullet team let's call the function dot add players and hero type baseball player 2 because first one was added there so now if you run the squad not debug so run this code let's increase this we get let's actually decrease this so let's put here we get player football player 2 was added to the team football team so we have this code here which is called and it says that the the football player was added to the team and the name of the football team and then we have player and we have baseball player player two so this this one that we have here that we pass here baseball team that was this to the baseball team as you can see it says player baseball player 2 was added to the baseball team and what generics helps out to do because I said they can help the compiler to figure out errors if you try to pass here baseball TM Dot add football player so we type here football player now you get an error because the generic type enforces the type on the the on the class because here we said explicitly that this is because this was inferred to be as a baseball player if you cannot pass here a football player in our baseball team because this is in first because you said Siri here explicitly explicitly because first because this was inferred from here so we have team baseball player so we cannot add here a football brain inside our team football player and this is very very powerful for us because in this way we don't do things which doesn't make sense and the the same is true about our football team so if on our football team so if enough of working with a football team dot add and here to put baseball player we get an error because we specified we specified that because the generic type was in fair to be a football player so we cannot put a baseball player in our team of football players so this is what generics is doing is figure out those errors for us at compile time and this is very powerful because we cannot we can run our code and we don't get in those some scenarios where we have a bay of baseball player added to a baseball team or maybe other examples there so I'm gonna delete this next we're gonna look at upper bounds because our upper bounds basically allows us to restrict what kind of type is passed to our generic type here so and particularly gonna see how this is gonna affect this code that we use here to cast so to to add an upper bound so to restrict what kind of type is passed to this type we can put colon so extends and here you can we can type player so what we are saying here is that every type that is going to be passed here when you create an instance like we did here so but only that this was in Fair here this type that is going to be passed here needs needs to inherit from the player class otherwise this type is not going to work so because of that because the compiler now knows that and enforces this that this type that is going to be passed here is is going to be is going to inherit from the player class we we can't delete this cast because now it knows that that type is gonna have uh it's gonna be it's gonna inherit from the player class so it's gonna have the property name so if I delete this and if I delete this so let's put name here now so let's delete these two should be player here player so now we have player the name because it knows that this type so this type that is going to be passed series is going to inherit from the player cards from the player class so it's gonna have the property name so you don't need to do this the weird this word cast is overcasting so I'm gonna delete this and now as you can see we don't have uh any arrows so now we have the name here because now it knows that whatever type you pass here it has to inherit from the player class so if I go down here and I create another class called gamer player so we type here class let's call it games player and it's gonna have a Val is going to be actually let's define a parameter only name is going to be a string and we will not inherit from our player class let's see what happens so if I um if I uh create here another theme let's call it Val let's call it the game Steam so I'm gonna type here team and we're gonna specify here games player now if if I put now the primary Constructor here here we need to define a name let's call it games team and multiple list of now here we have an error and if you look it says expected player found games player and this happens because our games player that we have here is not inheriting from the player class and because we said here that the upper bound is this T that is passed here so this T is this here has to inherit from the player class otherwise if you if you don't uh inherit from the player class it will not work because you said here that it it must inherit from the player class now if I change this to if I change this down here to inherit from the player class so it I hear player we type here name now as you can see the error disappears because now it's respecting the upper bound that we set we set up here which is T meaning games player has to inherit from the player class and down here it's inheriting so this is our discussion about how we can use generics and how we can use how you can Define upper bounds and in the next videos you're gonna look at um type erasures and you're going to lose what reified a keyword and how you can inline our function with because you need to inline your function when the use refine the keyword so see you in the next video well actually before I end the video I should say why this uh genetics is important why because if you think about because here you can type we can define a generic type we don't need to create um a separate class for for every team that that we want to use so we don't need to create a football team we don't need to create a separate baseball team we don't need to create a separate games team we we just create a team we Define the generic type T and here we pass our we pass our our type and in this way we can use only one class and we can we can have all of those uh those uh baseball team we can have the football team we can have just by having the the type here which is generic otherwise we'll have to create separate classes for each of those teams so see you in the next video and next video as I said we're gonna look at type erasers and refine the verified the keyword and the inline functions and in the next videos we're going to look also at covariance and counter variance so see in the next video
