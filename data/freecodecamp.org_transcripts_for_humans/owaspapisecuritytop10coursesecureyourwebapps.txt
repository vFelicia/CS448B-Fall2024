With timestamps:

00:00 - The OWASP API Security Top 10 is a standard reference guide highlighting  
00:05 - the most critical web API vulnerabilities to help developers and organizations understand and mitigate potential security threats.
00:14 - In this course, you will learn about each security risk and learn techniques to fortify your APIs against potential threats.
00:22 - Corey Ball developed this course.
00:24 - He is a cybersecurity consultant and a leading expert in API security.
00:30 - So he's the perfect person to teach you how to secure your APIs.
00:35 - Hello, freeCodeCamp community and welcome
to APIsec University and this course on
00:39 - OWASP API Security Top 10 and Beyond.
00:43 - My name's Dan Barahona.
00:44 - I'm the co-founder of APIsec University,
and for the next 90 minutes, you'll
00:48 - learn all about the OWASP API Security
Top 10, updated in 2023, and we'll
00:53 - even add a few extra bonus topics that
are really important to know about.
00:57 - Your instructor for the course is my
good friend, Corey Ball, author of the
01:01 - Hacking APIs book and well-recognized
expert in the field of API security.
01:06 - I invite you to check out all our free
courses over on APIsec University,
01:10 - including a hands-on course on API Pen
Testing, an introductory course on API
01:15 - Security Fundamentals, this course here
on the OWASP API Top 10, as well as a PCI
01:21 - Compliance course, an API Documentation
course, and many more to come.
01:25 - All the courses on our site include
quizzes to assess your knowledge,  and
01:29 - if you complete everything and pass
the final quiz, we'll issue you a
01:32 - certificate and badge to recognize
your accomplishment, which you can
01:35 - also display on your LinkedIn profile.
01:37 - Thanks again for watching and
I hope you enjoy the course.
01:48 - Welcome to OWASP API
Security Top 10 and Beyond.
01:52 - In this course, we'll dive into the
latest updates to the OWASP API Security
01:55 - Top 10, and discuss other significant
security considerations beyond the Top 10.
02:00 - The first edition of the API Security Top
10 was released in 2019, and now OWASP
02:05 - has officially released the 2023 version.
02:08 - As APIs are a critical component
of the modern digital world, this
02:12 - list is of utmost importance.
02:15 - This course highlights the most common
API security vulnerabilities and is
02:18 - meant to help educate the community
of builders, breakers, and defenders.
02:23 - The course will help you identify and
analyze the most common weaknesses
02:26 - that plague modern web application
programming interfaces, or APIs.
02:31 - By the end of this course, you should
have an understanding of the variety
02:34 - of vulnerabilities associated with
APIs, the attack vectors involved,
02:38 - and the technical impact and
exploited vulnerability could have.
02:42 - So who is this course for?
02:44 - This course is great for anyone
involved in the API economy.
02:47 - It is meant to help improve the skills
and knowledge of bug bounty hunters,
02:51 - developers, penetration testers,
organizational leadership, and anyone else
02:55 - interested in learning about API security.
02:58 - Before taking this course, you should be
familiar with API security fundamentals.
03:02 - If you would like to learn more
about this, check out our API
03:05 - Security Fundamentals course.
03:09 - So how does this course work?
03:10 - Read, watch, and or listen to the
content provided in the course modules.
03:14 - It is highly recommended that you
take notes, explore the recommended
03:18 - resources, follow along with the
course materials, and complete the
03:21 - quizzes at the end of every module.
03:23 - The content presented in the video should
closely align with the written content.
03:27 - The videos offer visual and
audible alternatives to consuming
03:30 - the content of this course.
03:33 - Quizzes
03:33 - During the course, quizzes will be
used to validate your knowledge.
03:36 - Quizzes are knowledge-based, multiple
choice tests based on the content
03:40 - discussed within the given module.
03:42 - The OWASP API Security Top 10 and
Beyond course is meant to be a
03:45 - challenging course that sets a high bar.
03:48 - To pass any quiz or assessment,
you must answer a hundred percent
03:51 - of the questions correctly.
03:52 - Completing all quizzes will result in
obtaining a  certificate of completion.
03:56 - This course is entirely free, and
you can earn the certificate of
03:59 - completion by passing all course
modules and passing all the quizzes.
04:03 - Those who would like to certify their
knowledge can take the course exam.
04:07 - The exam is a knowledge based
assessment of your ability to analyze
04:10 - APIs and find vulnerabilities.
04:12 - Students who pass the exam will
earn the Certified API Security
04:15 - Analyst certification or CASA.
04:18 - Formatting
04:18 - Please note that all content in
italics under sections designated
04:23 - OWASP is sourced directly from the
OWASP API Security Top 10 2023.
04:28 - This content is attributed to the OWASP
API Security Project Team and OWASP
04:33 - API Security Project contributors.
04:35 - All other sources will
be directly referred to.
04:38 - No changes were made to the content.
04:42 - Hey everyone.
04:43 - Quick introduction.
04:44 - My name is Corey Ball.
04:45 - I'm the author of Hacking APIs,
technical editor of Black Hat
04:49 - GraphQL, and contributor to the
OWASP API Security Top 10 2023.
04:54 - I'm also the Chief Hacking Officer for
APIsec University and a Senior Manager of
04:58 - Penetration Testing over at Moss Adams.
05:00 - I have over 13 years of experience
working in IT and cybersecurity
05:03 - across several industries.
05:05 - In addition to a Bachelor's degree in
English and philosophy from Sac State,
05:09 - I also hold several certs including the
OSCP, CCISO, CISSP, and several others.
05:15 - I hope you enjoy this course.
05:19 - The objective of this course is to
help students become API security
05:22 - professionals, and be able to identify
and reduce API related security risks.
05:27 - OWASP API Security Top 10 and Beyond
is meant to help improve the skills
05:31 - of bug bounty hunters, developers,
penetration testers, organizational
05:34 - leadership, and anyone else interested
in learning about API security.
05:39 - Course objectives include the
introduction to OWASP, the API
05:43 - Security Project, and the changes
from the 2019 to the 2023 version.
05:48 - Should help prepare students
to pass the Certified API
05:52 - Security Analyst or CASA exam.
05:55 - Develop a strong foundation in the
following API security risks: Broken
05:59 - Object Level Authorization, Broken
Authentication, Broken Object Property
06:04 - Level Authorization, Unrestricted
Resource Consumption, Broken Function
06:09 - Level Authorization, Unrestricted
Access to Sensitive Business Flows,
06:14 - Server Side Request Forgery, Security
Misconfiguration, Improper Inventory
06:20 - Management, Unsafe Consumption of APIs.
06:23 - In addition to that, it's to help
secure the APIs of the internet and
06:27 - prevent API related data breaches.
06:30 - Finally this course is meant to help
prepare students with additional
06:34 - resources for continued learning
and growth in API security.
06:41 - The Open Web Application security
project, or OWASP, is a nonprofit
06:44 - foundation that was created to
help improve application security.
06:48 - The OWASP Foundation launched on
December 1st, 2001, and is most well
06:52 - known for its Top 10 list open source
tools and other security projects.
06:57 - The OWASP API Security Top 10 is a list
of the most critical security risks
07:02 - for application programming interfaces.
07:04 - The founders of the project
include Erez Yalon and Inon Shkedy.
07:08 - The OWASP API Security Top 10 was
originally released in December, 2019
07:12 - and was driven by several key factors.
07:15 - The first was the rapid rise of APIs.
07:18 - APIs power the flow of the world's
most valuable resource, which is data.
07:24 - A business no longer needs to specialize
in all aspects of creating software.
07:28 - Instead, they can use the features
of software shared by other
07:31 - companies and organizations.
07:33 - Historically, the issue with doing
this was the disconnected nature of
07:37 - different programming languages, web
application programming interfaces
07:41 - allowed for a common method to consume
or provide data across the internet.
07:46 - Since the widespread adoption of
web APIs, organizations have been
07:49 - enabled to leverage the functionality.
07:51 - Of other applications.
07:53 - Instead of having to develop
custom software for maps, gps,
07:56 - payment processing, authentication,
communication, and much more,
08:00 - developers can leverage APIs to use
the functionality of other applications
08:04 - that specialize in that given area.
08:06 - APIs are a major business enabler, which
explains the global rapid adoption.
08:12 - Second, a major gap in security.
08:15 - So the next factor that compounded
the effects of the other two is the
08:18 - fact that the tools and techniques
of the past were not effective at
08:21 - detecting API related vulnerabilities.
08:24 - The tools and techniques that were used
for enterprise vulnerability management
08:27 - programs, web applications, scanners, and
traditional network security monitoring
08:31 - tools were not designed to handle
the unique challenges posed by APIs.
08:36 - As a result, many organizations
were not adequately prepared to
08:39 - defend against API attacks leaving
them vulnerable to data breaches.
08:44 - Third, a new leading attack vector.
08:46 - Often when it comes to the rapid
adoption of new technologies,
08:49 - security is an afterthought.
08:51 - APIs are no different.
08:53 - The rapid adoption of APIs led to
a new attack vector that exposes
08:57 - data application functionality.
08:59 - Public internet facing APIs often
bypassed all of the security
09:03 - measures that had grown with
businesses over the past decades.
09:06 - An attacker no longer needs to go
through the classic MITRE cyber kill
09:10 - chain by bypassing the firewall, gaining
entry to the network, pivoting around
09:14 - to system that contains data, and then
finding a way to exfiltrate that data.
09:18 - Instead, an attacker can use
an insecure API and have direct
09:22 - access to that sensitive data.
09:24 - In response to the massive adoption of
APIs, the security gaps introduced by API
09:29 - providers, and the new wave of API related
security incidents, the OWASP API Security
09:34 - Project published its Top 10 list.
09:37 - The API-focused Top 10 list provides
a comprehensive set of guidelines,
09:41 - best practices, and tools to help
organizations secure their APIs and
09:45 - protect against API related threats.
09:49 - The OWASP API Security Project has
become a widely recognized and respected
09:53 - resource for security professionals
and has helped raise awareness of
09:57 - the importance of API security.
10:01 - How is the top 10 compiled?
10:03 - As described by Paulo Silva, OWASP
API Security Project leader, the 2023
10:08 - OWASP API Security Top 10 list is put
together by the project team based on
10:13 - internal research, based on publicly
available data, bounty platforms and news.
10:18 - Since the project did not receive
any data during the call for data
10:21 - during the two month window in late
2022, the top 10 list was compiled
10:26 - based on the project team's research.
10:28 - This was not something new or different
for the project as this is, as
10:32 - Silva stated, what was done in 2019.
10:35 - Without dataset received from
the community, the OWASP project
10:39 - team had to compile data based on
public disclosures from bug bounty
10:43 - pro platforms and API security
incidents that made it into the news.
10:47 - Although this dataset isn't as ideal
as data compiled directly from testing
10:52 - hundreds of thousands of endpoints
across the internet, it does represent
10:55 - a sample of real-world API weaknesses.
10:58 - Some potential  issues with applying
this data include bug bounty
11:03 - program  incentivizes certain
types of findings over others.
11:07 - Bug bounty programs attract participants
that represent a small sample of the
11:11 - APIs that are actually out in the wild.
11:13 - Newsworthy incidents often leave
security researchers without
11:17 - specific technical details.
11:19 - Obviously newsworthy incidents do
not include all of the breaches
11:22 - and security incidents that
are not reported or publicized.
11:26 - That being the case, there are lessons
to be learned and risks to be aware
11:30 - of based on bug bounty, writeups,
and publicized security incidents.
11:34 - If you are interested in learning
more about the sources, belows a
11:37 - list of common websites to dive
deeper into bug bounty research.
11:42 - In addition to these, attached
to this module is a JSON extract
11:46 - from PentesterLand that contains
all documented API writeups.
11:50 - PentesterLand writeup compilation,
HackerOne hack activity, Awesome
11:54 - Bugbounty writeups, all the
links are in the content below.
11:58 - Also, in the course content is a list
of some of the most newsworthy API
12:02 - incidents in the last five years,
including data breaches and leaks from
12:06 - the USPS, Optus, T-Mobile, and Toyota.
12:10 - The OWASP API Security Top 10 list
contains common groups of the most
12:14 - critical security risks to be on the
lookout for based on these sources.
12:22 - The OWASP API security
risks are associated with
12:24 - references to external sources.
12:27 - These sources include CWEs, or Common
Weakness Enumeration, other OAS projects,
12:33 - and the National Institute of Standards
and Technology, or NIST Guidance.
12:38 - Most of the references involve CWE.
12:40 - CWEs are a list of common software
and hardware vulnerabilities developed
12:44 - by the community and hosted by MITRE.
12:47 - Each CWE is identified by a
unique identifier or CWEID.
12:52 - This identifier can be used to refer
back to a specific vulnerability.
12:56 - Check out the full table of external
sources in the course material below.
13:00 - Understanding the external sources and
how they're associated with a given
13:04 - OWASP API Security Top 10 risk will help
provide you with additional insight.
13:09 - Throughout the course external
sources will be provided for the
13:11 - OWASP API Security Top 10 risks.
13:15 - These resources will be provided to you
to help you dive in as deep as you'd
13:19 - like into the topic of API security.
13:21 - We will dive deeper into
these  in later modules.
13:24 - In the next section, we'll go
over the updates to the top
13:27 - 10 list from 2019 to 2023.
13:32 - Since the release of the
OWASP API Security Top 10 in
13:35 - 2019, API usage has grown.
13:38 - API related data breaches have continued
and new API technologies have emerged.
13:43 - All of this has played a role in the
need for an updated version of the
13:46 - API security project's Top 10 list.
13:49 - Since the 2019 Top 10, several events
have demonstrated the importance of
13:53 - keeping the list updated and relevant.
13:56 - API attacks are consistently on the rise.
13:58 - Akamai reported seeing nearly 114 million
API attacks in a single day in 2021.
14:06 - The global API market value was
valued at 2.2 billion in 2021, and
14:11 - was predicted to reach 41.5 by 2031.
14:15 - That's a 20 times growth
rate, in 10 years.
14:18 - In 2022, Postman had over 46 million
Postman collections, and GitHub
14:23 - had 3 million API related repos.
14:27 - APIs continue to be rapidly adopted and
the financial stakes continue to climb.
14:32 - The OWASP API Security Project updated
the Top 10 list to address some of the
14:36 - changes in the attack trends that have
emerged since the previous version.
14:40 - Inon Shkedy, OWASP API Security
Project Leader, stated that the
14:44 - OWASP API Top 10 2023 version is
different from the 2019 version.
14:49 - "We aspire to follow the security
trends that are relevant to APIs and
14:53 - have been developed in recent years.
14:55 - If you try to hack or protect
an API that was developed five
14:58 - years ago, it would make more
sense to refer to the 2019 list."
15:03 - At a high level, when you compare the Top
10 from 2019 to 2023, you see that two
15:08 - previous risks were removed from the list,
three remained exactly the same, four were
15:13 - updated, and five of the 2023 are new.
15:16 - The two items that were removed
included Injection and Insufficient
15:20 - Logging and Monitoring.
15:22 - These two risks were not completely
mitigated and resolved, but the
15:25 - importance of new emerging risks
pushed them beyond the Top 10.
15:29 - Logging and Monitoring is a classic
OWASP Top 10 risk, but it is not
15:32 - an item that is represented in
breaches or disclosed bug bounties.
15:37 - Injection attacks are still around and
many web APIs are still susceptible,
15:41 - but the adoption of web application
firewalls and implementation of other
15:45 - mitigation techniques has reduced the
occurrence of notable API injection.
15:50 - There were three categories
that remained on the list.
15:53 - Broken Object Level Authorization or
BOLA, Broken Function Level Authorization,
15:57 - or BFLA, and Security Misconfiguration.
16:01 - BOLA and BFLA are still among the most
common API risks and account for many of
16:06 - the breaches in bug bounty disclosures.
16:08 - APIs continue to have severe issues
when it comes to authorization risk.
16:12 - The Security Misconfiguration category
contains a wide range of possible
16:16 - misconfigurations that can plague APIs.
16:18 - In other words, this category is unlikely
to leave the Top 10 because it is a
16:22 - catchall for many API vulnerabilities.
16:25 - Four categories were renamed.
16:27 - The renaming of these categories helped
simplify the risk categories and bring
16:31 - additional focus to the issue at hand.
16:33 - Broken User Authentication has
now become Broken Authentication.
16:37 - This simplification has done
away with User and now brings
16:40 - additional attention to the API
authentication as a whole process.
16:44 - Improper Assets Management has
become Improper Inventory Management.
16:48 - This change was likely made to better
align with industry terminology and
16:52 - to cover a wider range of resources.
16:54 - The term Assets might only refer to
tangible items valued by an organization
16:58 - while the term Inventory could
refer to a wider set of resources.
17:02 - There were a total of five categories that
were added to the OWASP API Security Top
17:06 - 10 2023 that were not on the 2019 version.
17:10 - Server Side Request Forgery and Unsafe
Consumption of APIs are completely new and
17:15 - did not have previous representation on
the 2019 OWASP API Security Top 10 list.
17:20 - Server Side Request Forgery was
represented on the 2021 OWASP Top
17:24 - 10 list and was added to that list
based on survey results rather
17:28 - than by incident occurrence.
17:30 - The remaining new risk categories
included Broken Object Property Level
17:34 - Authorization, or BOPLA, Unrestricted
Resource Consumption, and Unrestricted
17:39 - Access to Sensitive Business Flows, each
containing elements from the 2019 list.
17:44 - For example, BOPLA is a combination
of Excessive Data Exposure and Mass
17:48 - Assignment, and we will dive deeper
into each of these later in the course.
17:52 - Paired with each OWASP API security
risk category are Risk Ratings.
17:56 - The risk ratings were based on
the OWASP risk rating methodology.
18:00 - The project now refers to the
OWASP risk rating framework.
18:04 - In the written course content, there is a
table demonstrating the risk ratings used
18:08 - for the OWASP API security project from
the OWASP API Security Top 10 2019 pdf.
18:14 - Any of these factors could significantly
affect the overall likelihood of
18:18 - an attacker finding and exploiting
a particular vulnerability.
18:22 - This rating does not take into account
the actual impact on a specific business.
18:27 - The risk score must be determined
by the given organization,
18:30 - as the project team states.
18:32 - The purpose of the OWASP API
Security Top 10 is not to do
18:36 - this risk analysis for you.
18:37 - In other words, the purpose of
the OWASP API Security Top 10 was
18:40 - not to perform a specific risk
analysis for a given organization,
18:44 - but to provide a guideline for
organizations to consider risk factors.
18:49 - In the course content, you can see
a table containing the changes to
18:52 - the 2019 and 2023 risk ratings.
18:58 - The classic equation for risk
is likelihood multiplied by
19:01 - impact with each risk score.
19:04 - The OWASP API Security Project team
has left the impact as a relative
19:08 - value to be determined by the business.
19:10 - In addition, the project team
includes a note along with these
19:14 - scores that the likelihood of these
scores is not taken into account.
19:18 - What we are left with are values that
represent overall exploitability,
19:23 - including complexity, exploitability,
weakness prevalence, weakness
19:28 - detectability, and technical impact.
19:30 - Note that the overall score does not
equate to a risk score because significant
19:34 - factors such as business impact and
likelihood are not accounted for.
19:41 - API1:2023 Broken Object Level
Authorization, or BOLA, is
19:45 - one of the most prevalent and
severe vulnerabilities for APIs.
19:49 - BOLA vulnerabilities occur when an API
provider does not have sufficient controls
19:53 - in place to enforce authorization.
19:55 - In other words, API users should
only have access to sensitive
19:59 - resources that belong to them.
20:01 - When BOLA is present, an attacker
will be able to access the
20:04 - sensitive data of other users.
20:06 - The OWASP attack vector
description states:
20:09 - "Attackers can exploit API endpoints that
are vulnerable to a broken object level
20:13 - authorization by manipulating the ID of
an object that is sent within the request.
20:18 - Object IDs can be anything from sequential
integers, UUIDs or generic strings.
20:25 - Regardless of the data type, they're
easy to identify in the request target,
20:29 - either through the path or a query
string parameter request headers, or
20:34 - even as a part of the request payload."
20:37 - The OWASP security weakness
description states:
20:40 - "This has been the most common
and impactful attack on APIs.
20:44 - Authorization and access control
mechanisms in modern web applications
20:48 - are complex and widespread.
20:50 - Even if the application implements
a proper infrastructure for
20:53 - authorization checks, developers
might forget to use these checks
20:57 - before accessing a sensitive object.
21:00 - Access controlled detection is not
typically amenable to automated
21:04 - static or dynamic testing."
21:06 - The OWASP impact description states:
21:09 - "Unauthorized access can result in data
disclosure to unauthorized parties,
21:13 - data loss or data manipulation.
21:16 - Unauthorized access to objects can
also lead to full account takeover."
21:21 - If an API endpoint has insufficient
access controls, it will not
21:25 - perform checks to ensure users can
only access their own resources.
21:30 - When these controls are missing,
User A will be able to obtain User
21:33 - B's resources via API requests.
21:36 - APIs use some sort of value like names
or numbers to identify various objects.
21:41 - When an attacker discovers an API's
resource ID, they will attempt to obtain
21:45 - the resources when unauthenticated
or authenticated as a different user.
21:50 - For instance, imagine that
an authenticated user Bruce
21:53 - sends a GET request to
https://herohospital.com/api/v3/users?id=2727
22:03 - and receives a JSON response back
with his data, this poses no problem.
22:08 - Bruce should be able to access
Bruce's own information.
22:11 - However, if Bruce is able to access
another user's information, then a
22:15 - BOLA vulnerability would be present.
22:17 - This weakness can be tested by using
other resource IDs in place of 2727.
22:23 - Say Bruce is able to obtain
information about another
22:25 - user by sending a request to:
https://herohospital.com/api/v3/users?id=2728,
22:33 - and receives a response about Harvey
Dent and his dissociative identity
22:38 - disorder, then there would be a problem.
22:41 - Assuming that Bruce is still using
his authorization to access this
22:44 - data, this would be a clear indication
that the API is vulnerable to BOLA.
22:49 - BOLA isn't always as simple as this
example because there's flexibility
22:53 - in how resources are provisioned and
requested from one API to the next.
22:57 - The written course content contains
several examples of how API resources
23:01 - may be requested and attacked.
23:04 - In these examples, tests can be performed
by replacing the bolded resource
23:08 - IDs with other numbers or words.
23:10 - Of course, in POST request, the resource
could also be requested in the POST body.
23:15 - If User A can successfully access
the information of any other user,
23:20 - then there's a vulnerability present.
23:22 - BOLA vulnerabilities are the
most common API vulnerabilities
23:25 - and are easily exploitable and
require a low amount of technical
23:29 - skills in order to discover these.
23:31 - BOLA can present itself in many forms
depending on how resources are organized.
23:36 - As you can see in the written
course, content resources can be
23:39 - organized by a user, by group,
or by a combination of both.
23:44 - In all of these instances, only those
with the proper permission should be
23:48 - allowed to retrieve their resources.
23:51 - The OWASP preventative measures state:
23:54 - In order to improve API security,
it is important to implement
23:57 - robust authorization controls.
23:59 - These controls should consider
user policies and role-based
24:03 - access control hierarchies.
24:05 - The primary focus should be to
ensure that authenticated users
24:08 - only have access to resources they
are authorized to have access to.
24:13 - Using less predictable resource
IDs can increase the challenge
24:16 - of a user or attacker guessing
the resource ID of other users.
24:20 - Developers should perform
tests that specifically test
24:22 - for authorization controls.
24:25 - Implement a proper authorization
mechanism that relies on the
24:28 - user policies and hierarchy.
24:30 - Use the authorization mechanism to
check if the logged in user has access
24:35 - to perform the requested action on
the record in every function that
24:39 - uses an input from the client to
access the record in the database.
24:44 - Prefer the use of random and unpredictable
values, such as GUIDS for records IDs.
24:50 - Write tests to evaluate the vulnerability
of the authorization mechanism.
24:54 - Do not deploy changes
that make the tests fail.
24:58 - Check out the written course content
for additional resources about BOLA.
25:09 - API2:2023, Broken Authentication,
refers to any weakness within
25:13 - the API authentication process.
25:16 - All APIs that contain sensitive
information should have some
25:19 - mechanism to authenticate users.
25:21 - Authentication is the process that is used
to verify the identity of an API user.
25:25 - Whether that is a person,
device, or system.
25:29 - In other words, authentication is the
process of verifying that an entity
25:33 - is who that entity claims to be.
25:35 - This verification process is normally
done with the use of a username
25:39 - and password combination, a token
and or multifactor authentication.
25:45 - Authentication related vulnerabilities
typically occur when an API provider
25:48 - either doesn't implement a strong
authentication mechanism or implements
25:52 - an authentication process incorrectly.
25:56 - The OWASP Attack Vector description for
this states that "The authentication
26:00 - mechanism is an easy target for
attackers since it's exposed to everyone.
26:05 - Although more advanced technical
skills may be required to exploit some
26:09 - authentication issues, exploitation
tools are generally available."
26:14 - The OWASP Security Weakness description
states "Software and security
26:17 - engineers' misconceptions regarding
authentication, boundaries and
26:21 - inherent implementation complexity
make authentication issues prevalent.
26:26 - Methodologies of detecting
broken authentication are
26:29 - available and easy to create."
26:32 - The OWASP Impacts Description states
"Attackers can gain complete control
26:36 - of other users' accounts in the system,
read their personal data, and perform
26:41 - sensitive actions on their behalf.
26:43 - Systems are unlikely to be able
to distinguish attackers actions
26:47 - from legitimate user ones."
26:50 - Broken Authentication continues to be a
significant security issue due to poor
26:54 - password policies, weak authentication
mechanisms, and misconfigurations.
26:59 - API authentication is a complex
process that is commonly found with
27:03 - most APIs and is necessarily exposed.
27:06 - The impact of Broken Authentication can
lead to an attacker taking control of
27:09 - user accounts, compromising personal data,
and conducting sensitive actions like
27:14 - editing someone else's healthcare data.
27:17 - The authentication process is often
one of the first lines of defense
27:20 - for APIs, and when this mechanism is
vulnerable, it can lead to a data breach.
27:24 - A weak password policy does
not sufficiently protect user
27:27 - accounts by enforcing strong
password creation and management.
27:32 - This allows users to create simple
passwords, allows brute force attempts
27:36 - against user accounts, and allows
users to change their password without
27:39 - asking for password confirmation.
27:42 - Also allowing users to change their email
without asking for password confirmation.
27:47 - Weak password policies also disclose
tokens or passwords in the URL.
27:53 - It has a lack of authentication
for sensitive requests.
27:56 - And in regards to GraphQL queries,
weak password policies would
28:00 - allow for many authentication
attempts within a single request.
28:05 - Credential stuffing is a type of
attack against authentication where
28:07 - a large number of username and
password combinations are attempted.
28:11 - Credentials used in these
types of attacks are typically
28:13 - collected from data breaches.
28:16 - This sort of attack allows users to brute
force many different username and password
28:20 - combinations without restrictions.
28:23 - Predictable tokens refers to any
token obtained through a weak token
28:26 - generation authentication process.
28:28 - Weak tokens can easily be guessed,
deduced, or calculated by an attacker.
28:34 - This would be an issue if an API is using
incremental or guessable tokens for IDs.
28:41 - JWTs are commonly used
for API authentication and
28:45 - authorization processes.
28:46 - JWT stands for JSON Web Token.
28:49 - JWTs provide developers with the
flexibility to customize which algorithm
28:54 - is used for signing the token, the
key and secret that is used and the
28:58 - information used in the payload.
29:00 - This customization allows for
plenty of room for security
29:03 - misconfigurations to occur.
29:05 - These include API providers that accept
unsigned JWT tokens, API providers that do
29:11 - not check JWT expirations, API providers
that disclose sensitive information
29:17 - within the encoded JWT payload, and
if the JWT is signed with a weak key.
29:23 - API authentication can be a complex
system that includes several processes
29:27 - with a lot of room for failure.
29:29 - A couple decades ago, security
expert Bruce Schneier said, "the
29:33 - future of digital systems is
complexity, and complexity is
29:36 - the worst enemy of security."
29:38 - As we know from the six constraints
of REST APIs, RESTful APIs
29:42 - are designed to be stateless.
29:43 - To be stateless the API providers
shouldn't need to remember the
29:47 - consumer from one request to another.
29:49 - For this constraint to work, APIs often
require users to undergo a registration
29:54 - process to obtain a unique token.
29:56 - The token that is generated is then
used in subsequent requests for
30:00 - authentication and authorization.
30:03 - As a consequence, the registration
process used to obtain an API token,
30:07 - the token handling, and the system
that generates the token could all
30:11 - have their own set of weaknesses if
the token generation process doesn't
30:15 - rely on a high level of randomness,
or entropy, there's a chance that an
30:19 - attacker will be able to create their
own token or hijack another user's token.
30:24 - The other authentication processes
that could have their own set of
30:27 - vulnerabilities include aspects of the
registration system, like password reset
30:31 - and multifactor authentication features.
30:34 - For example, imagine a password
reset feature requiring you to
30:37 - provide an email address and a six
digit code to reset your password.
30:41 - While if the API allowed you to
make as many requests as you wanted,
30:44 - you'd only have to make 1 million
requests in order to guess the
30:47 - code and reset any user's password.
30:50 - A four digit code would
require only 10,000 requests.
30:54 - As it states in the OWASP Preventative
Measures, make sure you know all the
30:58 - possible flows to authenticate to the API.
31:01 - Ask your engineers what flows you missed.
31:04 - Read about your authentication mechanisms.
31:07 - Make sure you understand
what and how they are used.
31:10 - OAuth is not authentication
and neither are API keys.
31:14 - Don't reinvent the wheel in
authentication, token generation or
31:18 - password storage, use the standards.
31:21 - Credential recovery and forgot password
endpoints should be treated as login
31:25 - endpoints in terms of brute force,
rate-limiting and lockout protections.
31:29 - Require re-authentication for
sensitive operations, including
31:33 - changing the account on our email
address and multifactor phone number.
31:37 - Use the OWASP API
Authentication Cheat Sheet.
31:39 - You can find that in the written content.
31:42 - Where possible implement
multifactor authentication.
31:45 - Implement anti-brute force mechanisms
to mitigate credential stuffing,
31:49 - dictionary attacks, and brute force
attacks on your authentication endpoints.
31:53 - This mechanism should be
stricter than the regular rate
31:56 - limiting mechanisms on your APIs.
31:58 - Implement account lockout capture
mechanisms to prevent brute force
32:02 - attacks against specific users.
32:04 - Implement weak-password checks.
32:07 - API keys should not be
used for authentication.
32:10 - They should only be used for
API client authentication.
32:13 - Check out the written course
content for additional resources
32:16 - about Broken Authentication.
32:25 - API3:2023 Broken Object Property
Level Authorization, or BOPLA, is a
32:31 - combination of two items from the 2019
OWASP API Security Top 10: Excessive
32:36 - Data Exposure and Mass Assignment.
32:38 - Excessive Data Exposure takes place
when an API provider responds to a
32:42 - request with an entire data object.
32:45 - Usually an API provider will
filter out  the data object
32:48 - down to what is being requested.
32:50 - When the data object is shared without
being filtered, there is an increased
32:53 - risk of exposing sensitive information.
32:56 - Mass Assignment is a weakness
that allows for user input to
32:59 - alter sensitive object properties.
33:02 - If, for example, an API uses a special
property to create admin accounts,
33:07 - only authorized users should be able
to make requests that successfully
33:10 - alter those administrative properties.
33:13 - If there are no restrictions in
place, then an attacker would be
33:16 - able to elevate their privileges
and perform administrative actions
33:19 - by altering those properties.
33:21 - Both of these vulnerabilities
involved issues with object property
33:25 - authorization, so they're combined
under the new title of Broken
33:29 - Object Property Level Authorization.
33:32 - As it states in the OWASP Attack Vector
description: APIs tend to expose endpoints
33:37 - that return all objects properties.
33:40 - This is particularly valid for REST APIs.
33:43 - For other protocols such as GraphQL, it
may require  crafted requests to specify
33:48 - which properties should be returned.
33:50 - Identifying these additional properties
that can be manipulated requires more
33:54 - effort, but there are a few automated
tools available to assist in this task.
33:59 - The OWASP Security Weakness description
states in inspecting API responses is
34:03 - enough to identify sensitive information
in returned objects, representations.
34:08 - Fuzzing is usually used to identify
additional hidden properties.
34:13 - Whether they can be changed is a
matter of crafting an API request
34:16 - and analyzing the response.
34:18 - Side effect analysis may be
required if the target property is
34:21 - not returned in the API response.
34:24 - The OWASP Impacts Description states
unauthorized access to private
34:28 - or sensitive object properties
may result in data disclosure,
34:32 - data loss, or data corruption.
34:35 - Under certain circumstances, unauthorized
access to object properties can
34:39 - lead to privilege as escalation or
partial to full account takeover.
34:44 - As previously stated, Broken Object
Property Level Authorization, or
34:48 - BOPLA, is a combination of Mass
Assignment  and Excessive Data Exposure.
34:51 - In the 2023 release notes, the
security project states that these two
34:54 - vulnerabilities were combined focusing on
the common root cause, object, property
34:59 - level authorization, validation failures.
35:01 - The OWASP API Security project also states
an API endpoint is vulnerable if either
35:07 - the API endpoint exposes properties of an
object that are considered sensitive and
35:11 - should not be read by the user, which is
an Excessive Data Exposure, or the API
35:16 - endpoint allows a user to change, add, or
delete the value of a sensitive object's
35:21 - property, which the user should not be
able to access, which is Mass Assignment.
35:25 - Excessive Data Exposure is when an API
endpoint responds with more information
35:29 - than is needed to fulfill a request.
35:31 - This often occurs in cases when
the provider expects the API
35:35 - consumer to filter results.
35:37 - When a consumer requests specific
information, the provider might respond
35:41 - with all sorts of information, assuming
the consumer will then remove any data
35:45 - they don't need from the response.
35:47 - When this vulnerability is present, it can
be the equivalent of asking someone for
35:51 - their name and having them respond with
their name, date of birth, email address,
35:54 - phone number, and the identification
of every other person they know.
35:58 - For example, if an API consumer
requests information for their user
36:02 - account and receives information
about other user accounts as well,
36:06 - the API is exposing excessive data.
36:09 - Check out the written content
for an example of an excessive
36:12 - data exposure vulnerability.
36:15 - Excessive Data Exposure is an API
vulnerability that is very difficult
36:18 - to detect with automated scanners.
36:20 - In addition, this vulnerability will
often bypass every security control in
36:24 - place to protect sensitive information
and hand sensitive data to an attacker
36:29 - simply because they use the API.
36:31 - To detect excessive data
exposure API providers must test
36:34 - API endpoints and review the
information sent in the response.
36:38 - Mass Assignment occurs when an API
consumer includes more parameters in its
36:42 - request than the application intended,
and the application adds these parameters
36:46 - to code variables or internal objects.
36:49 - In this situation, a consumer may
be able to edit object properties
36:52 - or escalate the privileges.
36:54 - For example, an application might have
an account update functionality that
36:58 - the user should use only to update
their username, password, and address.
37:02 - If the consumer can include additional
parameters in the request related to their
37:07 - account, such as the account privilege
level, or sensitive information like
37:11 - an account balance, and the application
accepts those parameters without checking
37:15 - them against the whitelist of permitted
actions, the consumer could take advantage
37:19 - of this weakness to change these values.
37:22 - Imagine an API is called
to create an account with
37:24 - parameters for user and password.
37:27 - The user could be hapi_hacker,
password could be GreatPassword123.
37:31 - While reading the API documentation
regarding the account creation process,
37:35 - an attacker could discover that there's
an additional property, which is
37:39 - an admin that the API provider uses
to create administrative accounts.
37:43 - An attacker could add this to a
request and set the value to "true".
37:48 - If the API does not sanitize the request
input, it is vulnerable to Mass Assignment
37:53 - and attacker could use the request
to create their own admin account.
37:57 - On the backend the vulnerable web
app will add the key value attribute
38:01 - {“isAdmin”: true} to the user object,
and make the user the equivalent of
38:06 - an administrator for that application.
38:08 - The OWASP Preventative Measures
state when exposing an object using
38:12 - an API endpoint, always make sure
that the user should have access to
38:16 - the object properties you expose.
38:18 - Avoid using generic methods such
as to_json() and to_string().
38:22 - Instead, cherry-pick specific
object properties you
38:25 - specifically want to return.
38:27 - If possible, avoid using functions
that automatically bind to client's
38:31 - input into code variables, internal
objects or object properties.
38:36 - Allow changes only to the
object's properties that should
38:39 - be updated by the client.
38:41 - Implement a schema based
response validation mechanism
38:44 - as an extra layer of security.
38:46 - As part of this mechanism, define and
enforce data returned by all API methods.
38:52 - Keep return data structures to the
bare minimum according to the business
38:56 - functional requirements for the endpoint.
38:59 - Check out the written course content
for additional resources about BOPLA.
39:10 - API4:2023 Unrestricted Resource
Consumption is an API issue where
39:16 - the provider of the API does
not have safeguards in place to
39:18 - prevent excessive use of their API.
39:21 - When there are no restrictions for
resource consumption, the API provider
39:25 - could become a victim of a denial
of service, attack, or experience,
39:28 - unnecessary financial costs.
39:31 - Unrestricted Resource Consumption
is an updated version of API4:2019,
39:36 - Lack of Resources and Rate Limiting.
39:38 - The OWASP Attack Vector description states
exploitation requires simple API requests.
39:45 - Multiple concurrent requests can be
performed from a single local computer
39:49 - or by cloud computing resources.
39:52 - Most of the automated tools
available are designed to cause
39:55 - denial of service via high loads of
traffic impacting API service rate.
40:00 - The OWASP Security Weakness
description states it's common to
40:03 - find APIs that do not limit client
interactions or resource consumption.
40:08 - Crafted API requests such as those,
including parameters that control
40:11 - the number of resources to be
returned and performing response
40:15 - status, time length analysis, should
allow identification of the issue.
40:20 - The same is valid for batched
operations, although threat agents
40:23 - don't have visibility over costs
impact, this can be inferred based
40:27 - on the service provider's business.
40:30 - OWASP Impacts Description states
exploitation can lead to denial of
40:34 - service due to resource starvation, but
it can also lead to operational cost
40:39 - increase, such as those related due to the
infrastructure due to higher CPU demand,
40:44 - increasing cloud storage needs, etc.
40:47 - The OWASP API Security project
states an API is vulnerable if at
40:51 - least one of the following limits
is missing or set inappropriately,
40:54 - either too low or too high.
40:56 - Execution timeouts, maximum allocable
memory, maximum number of file
41:00 - descriptors, maximum number of
processes, maximum upload file size
41:05 - number of operations to perform in
a single API client request with
41:10 - things like GraphQL batching, number
of records per page to return in a
41:14 - single request response, and third
party service provider spending limit.
41:19 - Every API request has a technical and
financial cost when API providers do
41:24 - not enforce limitations on resource
consumption, there's an increased
41:28 - risk of denial of service, distributed
denial of service, unnecessary
41:32 - financial costs, and degradation of
the quality of service to other users.
41:36 - In addition rate limiting plays an
important role in the monetization
41:39 - and availability of APIs.
41:42 - Many API providers monetize their APIs
by limiting requests and allowing paid
41:46 - customers to request more information.
41:50 - RapidAPI, for example, allows
some API providers to also have
41:54 - infrastructure that automatically
scales with the number of API requests.
41:58 - In these cases, an unlimited
number of requests would lead to a
42:01 - significant and easily preventable
increase in infrastructure costs.
42:06 - The OWASP Preventative Measures
states Docker makes it easy to limit
42:10 - memory, CPU, number of restarts,
file descriptors and processes.
42:14 - Implement a limit on how often
a client can call the API
42:17 - within a defined timeframe.
42:19 - Notify the client when the limit is
exceeded by providing the limit number and
42:23 - the time at which the limit will be reset.
42:26 - Add proper server side validation
for query string and request body
42:29 - parameters, specifically the one
that controls the number of records
42:33 - to be returned in the response.
42:35 - Define and enforce maximum size of data
on all incoming parameters and payloads,
42:40 - such as maximum length for strings and
maximum number of elements in arrays.
42:45 - Check out the written course content
for additional resources about
42:48 - Unrestricted Resource Consumption.
42:56 - API5:2023, Broken Function Level
Authorization, or BFLA, is a
43:01 - vulnerability where API functions
have insufficient access controls.
43:06 - Where BOLA is about access to data, BFLA
is about altering or deleting that data.
43:11 - In addition, a vulnerable API would allow
an attacker to perform actions of other
43:16 - roles, including administrative actions.
43:18 - To drive the point home, a fintech
API susceptible to BOLA would allow an
43:23 - attacker the ability to see what is in
the bank account of another user, while
43:27 - the same API vulnerable to BFLA would
allow an attacker to transfer funds
43:31 - from other users accounts to their own.
43:34 - The OWASP Attack Vector description
states "exploitation requires the
43:38 - attacker to send legitimate API calls
to an API endpoint that they should
43:42 - not have access to as an anonymous
user or regular non privileged user.
43:48 - exposed endpoints will
be easily exploited."
43:51 - The OWASP Security Weakness description
states "authorization checks for
43:55 - a function or resource are usually
managed via configuration or code level.
44:00 - Implementing proper checks can be a
confusing task since modern applications
44:04 - can contain many types of roles,
groups, and complex user hierarchies.
44:09 - It's easier to discover these
flaws in APIs since APIs are more
44:13 - structured, and accessing different
functions is more predictable."
44:17 - The OWASP Impacts Description states
"such flaws allow attackers to
44:21 - access unauthorized functionality.
44:24 - Administrative functions are key
targets for this type of attack
44:27 - and may lead to data disclosure,
data loss, or data corruption.
44:32 - Ultimately, it may lead
to service disruption."
44:35 - Broken Function Level Authorization,
or BFLA, is a vulnerability where a
44:39 - user of one privilege level can use the
API functionality of a different user,
44:43 - user group, or another privilege level.
44:46 - API providers will often have
different privilege levels for
44:50 - different types of accounts, such as
public users, merchants, partners,
44:53 - vendors, administrators, and so on.
44:56 - BFLA can be exploited for unauthorized
use of lateral functions or a similarly
45:01 - privileged group, or it could be
exploited for privilege escalation,
45:05 - where an attacker can use the
functions of a more privileged group.
45:09 - Particularly interesting API functions
to access include those that deal
45:13 - with sensitive information, resources
that belong to another group,
45:17 - and administrative functionality,
like user account management.
45:21 - If an API has different privilege
levels, it may use different endpoints
45:25 - to perform those privileged actions.
45:27 - For example, a bank may use
/{userid}/account/balance as an
45:33 - endpoint for a user wishing to access
their account information, and then
45:37 - use /admin/account/{userid} as an
endpoint for an administrator that needs
45:43 - to access user account information.
45:46 - If the application does not
have access controls implemented
45:49 - correctly, an attacker will be able
to perform administrative actions
45:52 - and perform an account takeover.
45:54 - An API won't always use
administrative endpoints for
45:57 - administrative functionality.
45:59 - Instead, the functionality could be
based on different HTTP request methods
46:03 - like GET, POST, PUT, and DELETE.
46:06 - If a provider doesn't restrict the
HTTP methods, or verbs, an attacker
46:10 - can use simply making an unauthorized
request with a different method,
46:16 - could indicate a BFLA vulnerability.
46:18 - When testing for BFLA, look for
any functionality that an attacker
46:22 - could use to their advantage.
46:23 - These functions include, but are not
limited to, altering user accounts,
46:27 - deleting user resources, and gaining
access to restricted endpoints.
46:32 - For example, if an API gave partners
the ability to add new users to the
46:36 - partner group, but did not restrict this
functionality to the specific group, any
46:42 - user could add themselves to any group.
46:45 - Moreover, if an attacker added
themselves to a group, there's a good
46:48 - chance that there'll be able to access
that group's sensitive resources.
46:52 - Take a look at the written course
content for an example of a BFLA attack.
47:02 - The OWASP Preventative Measures
state "your application should have
47:06 - a consistent and easy to analyze
authorization module that is invoked
47:10 - from all your business functions.
47:12 - Frequently, such protection is
provided by one or more components
47:16 - external to the application code.
47:18 - The enforcement mechanisms should
deny all access by default, requiring
47:23 - explicit grants to specific roles
for access to every function.
47:28 - Review your API endpoints against
function level authorization flaws, while
47:33 - keeping in mind the business logic of
the application and group's hierarchy.
47:37 - Make sure that all of your
administrative controllers inherit from
47:40 - an administrative abstract controller
that implements authorization checks
47:45 - based on the user's group or role.
47:47 - Make sure that administrative
functions inside a regular controller
47:51 - implement authorization checks
based on the user's group and role."
47:55 - Check out the written course content
for additional resources about
47:58 - Broken Function Level Authorization.
48:05 - API6:2023, Unrestricted Access to
Sensitive Business Flows represents
48:10 - the risk of an attacker being able to
identify and exploit API driven workflows.
48:16 - If vulnerable an attacker will be able
to leverage an organization's API request
48:19 - structure to obstruct other users.
48:22 - This obstruction could come in the form
of spamming other users, depleting the
48:25 - stock of highly sought after items,
or preventing other users from using
48:29 - expected application functionality.
48:32 - This is a new addition
to the 2023 top 10 list.
48:35 - The OWASP Attack Vector description
states "exploitation usually involves
48:40 - understanding the business model backed
by the API, finding sensitive business
48:45 - flows, and automating access to these
flows, causing harm to the business."
48:50 - The Security Weakness description
states "lack of a holistic view of the
48:54 - API in order to fully support business
requirements tends to contribute
48:58 - to the prevalence of this issue.
49:00 - Attackers manually identify what resources
or endpoints are involved in the target
49:05 - workflow and how they work together.
49:07 - If mitigation mechanisms are
already in place, attackers need
49:11 - to find a way to bypass them."
49:13 - The OWASP Impacts Description states "in
general, technical impact is not expected.
49:19 - Exploitation might hurt the
business in different ways.
49:22 - For example, prevalent legitimate
users from purchasing a product
49:26 - or lead to an inflation in the
internal economy of a game.
49:31 - Regarding APIs, a flow is a
series of requests and responses
49:35 - that lead to an operation.
49:37 - If, for example, a purchase flow for a
web application does not restrict access
49:41 - to a purchase process, then a scalper
could automate requests to instantly drain
49:44 - the stock of an item down to nothing.
49:47 - This is where mechanisms like a completely
automated public Turing test to tell
49:51 - computers and humans apart, or better
known as CAPTCHA, comes into play.
49:56 - If a flow has a capture mechanism that
requires human interaction, then the
50:01 - automated request could be interrupted
and slow down automated purchasing.
50:06 - Check out the written course material
for an example API flow used to help
50:09 - build a notification bot for the PS5.
50:12 - Customers and or scalpers competing
to purchase the PS5 would use API
50:17 - flows to either complete purchases
as soon as new stock was available
50:20 - or alert upon stock updates.
50:23 - In the example, an API flow was used
to automatically check for stock
50:27 - updates and send out email alerts.
50:30 - The OWASP Preventative Measures state
the mitigation planning should be done
50:33 - in two layers, business and engineering.
50:37 - Business should identify the business
flows that might harm the business
50:40 - if they are excessively used.
50:42 - Engineering should choose the
right protection mechanism to
50:45 - mitigate the business risk.
50:47 - Some of the protection mechanisms
are more simple while others
50:50 - are more difficult to implement.
50:52 - The following methods are used
to slow down automated threats.
50:55 - Device fingerprinting.
50:57 - Deny service to unexpected client
devices, tends to make threat
51:01 - actors use more sophisticated
solutions, thus more costly for them.
51:06 - Next up is human detection
using either CAPTCHA or more
51:10 - advanced biometric solutions.
51:13 - Non human patterns.
51:15 - Analyze the user flow to
detect non human patterns.
51:19 - For example, the user accessed the
add to cart and complete purchase
51:23 - functions in less than one second.
51:25 - Consider blocking IP addresses of Tor
exit nodes and well known proxies.
51:30 - Secure and limit access to APIs that
are consumed directly by machines.
51:35 - They tend to be an easy target
for attackers because they
51:38 - often don't implement all the
required protection mechanisms.
51:41 - Check out the written course content for
additional resources about unrestricted
51:46 - access to sensitive business flows.
51:51 - API7:2023, Server Side Request Forgery
is a vulnerability that takes place when
51:56 - a user is able to control the remote
resources retrieved by an application.
52:01 - An attacker can use an API to supply
their own input in the form of a URL
52:05 - to control the remote resources that
are retrieved by the targeted server.
52:09 - An attacker could supply URLs that
expose private data, scan the target's
52:14 - internal network, or compromise the
target through remote code execution.
52:18 - SSRF is also number 10 on the
2021 OWASP Top 10 List and
52:23 - is a growing threat to APIs.
52:26 - The OWASP Attack Vector description
states "exploitation requires the attacker
52:31 - to find an API endpoint that accesses
a URI that's provided by the client.
52:37 - In general, basic SSRF, when the response
is returned by the attacker, is easier
52:43 - to exploit than blind SSRF, in which
the attacker has no feedback on whether
52:48 - or not the attack was successful."
52:51 - The OWASP Security Weakness description
states "modern concepts in application
52:55 - development encourages developers to
access URIs provided by the client.
53:00 - Lack of, or improper validation
of such URIs are common issues.
53:05 - Regular API requests and response analysis
will be required to detect the issue.
53:11 - When the response is not returned,
detecting the vulnerability requires
53:14 - more effort and creativity."
53:17 - The OWASP Impacts Description states
"successful exploitation might lead
53:21 - to internal services enumeration,
information disclosure, bypassing
53:26 - firewalls, or other security mechanisms.
53:29 - In some cases, it can lead to denial
of service or the server being used as
53:33 - a proxy to hide malicious activities."
53:36 - SSRF is a vulnerability that takes place
when an application retrieves remote
53:40 - resources without validating user input.
53:42 - When an attacker has control over the
resources a server requests, then they can
53:46 - gain access to sensitive data, or worse,
completely compromise a vulnerable host.
53:52 - The impact of this vulnerability is
that an attacker would be able to
53:55 - leverage a target server to perform
and process requests that they supply.
53:59 - Note that  bug bounty payouts for SSRF
are driven based on the impact that can
54:04 - be demonstrated with a proof of concept.
54:07 - The higher the demonstrated
impact, the higher the bounty.
54:10 - There are two general types
of SSRF that are worth noting.
54:14 - In-Band SSRF and Out-of-Band
SSRF, also known as Blind SSRF.
54:18 - In-Band SSRF means that the
server responds with the resources
54:23 - specified by the end user.
54:26 - If the attacker specifies a payload
such as google.com to a server with an
54:30 - In-Band SSRF vulnerability, the server
would make the request to google.com
54:35 - and then respond to the attacker with
information served from google.com.
54:41 - Blind SSRF takes place when the
attacker supplies a URL and the server
54:45 - makes the request, but the server does
not send the information back from
54:50 - that specified URL to the attacker.
54:53 - In the case of blind SSRF, an attacker
would need control over a web server
54:58 - that would capture the request from the
target as proof that they were able to
55:02 - force the server to make this request.
55:04 - In the course In-Band SSRF
example, an attacker makes a
55:08 - request that includes a URL.
55:10 - That will be used to update the
stock of an item in the store.
55:14 - The attacker is able to replace that
item stock URL with a local host
55:18 - URL to a directory with a password.
55:20 - The server is vulnerable and provides
the password back to the attacker.
55:25 - Blind SSRF takes place when a vulnerable
server performs a request from user input,
55:30 - but does not send back the response to the
attacker indicating a successful attack.
55:34 - In other words, the victim server
makes the request to the URL
55:37 - specified by the attacker, but the
attacker does not receive a direct
55:42 - message back from the victim server.
55:44 - In this case, to know if the request
was made, an attacker will need to
55:48 - have some control over the web server
that is specified in the attack.
55:52 - For examples and demonstrations of
In-Band and Out-of-Band SSRF attacks
55:57 - check out the written course material.
56:00 - The OWASP Preventative Measure
states "isolate the resource
56:03 - fetching mechanism in your network.
56:05 - Usually these features are
aimed to retrieve remote
56:07 - resources and not internal ones.
56:09 - Whenever possible, use allow lists
of remote origins users are expected
56:15 - to download resources from, such
as Google Drive or Gravatar, URL
56:19 - schemes and ports, accepted media
types for a given functionality.
56:24 - Disable HTTP redirections.
56:27 - Use a well tested and maintained
URL parser to avoid issues caused
56:31 - by URL parsing inconsistencies.
56:34 - Validate and sanitize all
client supplied input data.
56:38 - Do not send raw responses to clients."
56:40 - Check out the written course content
for additional resources about SSRF.
56:51 - API8:2023, Security Misconfiguration
represents a catch-all for
56:56 - many vulnerabilities related
to the systems that host APIs.
56:59 - When an API's security is misconfigured,
it can be detrimental to the
57:02 - confidentiality, integrity, and
availability of the API provider's data.
57:07 - Due to the wide variety of flaws that
could exist, the impacts of an exploited
57:11 - security misconfiguration can range from
information disclosure to data breach.
57:16 - The OWASP Attack Vector description
states "attackers will often attempt
57:20 - to find unpatched flaws, common
endpoints, or unprotected files and
57:24 - directories to gain unauthorized
access or knowledge of the system."
57:28 - The OWASP Security Weakness description
states "security misconfiguration
57:32 - can happen at any level of
the API stack from the network
57:35 - level to the application level.
57:37 - Automated tools are available to detect
and exploit misconfiguration such as
57:42 - unnecessary services or legacy options."
57:45 - The OWASP Impacts Description states
"security misconfigurations can not
57:50 - only expose sensitive user data,
but also system details that can
57:54 - lead to full server compromise."
57:56 - Security misconfigurations include all
the mistakes that API providers can make
58:00 - within the supporting systems of an API.
58:03 - Security misconfigurations are really
a set of weaknesses that include
58:06 - misconfigured headers, misconfigured
transit encryption, the use of
58:10 - default accounts, the acceptance of
unnecessary HTTP methods, a lack of input
58:15 - sanitization, and verbose error messaging.
58:19 - For example, if the API supporting
security configuration reveals
58:22 - an unpatched vulnerability.
58:24 - There's a chance that an attacker
could leverage a published exploit to
58:27 - easily pwn the API and its systems.
58:30 - A lack of input sanitization
could allow attackers to upload
58:33 - malicious payloads to the server.
58:35 - APIs often play a key role in automating
processes, so imagine being able
58:40 - to upload payloads that the server
automatically processes into a format
58:44 - that could be remotely executed or
executed by an unsuspecting end user.
58:49 - For example, if an upload endpoint
was used to pass uploaded files
58:53 - to a web directory, then it could
allow the upload of a script.
58:57 - Navigating to the URL where the file is
located could launch the script resulting
59:01 - in direct shell access to the web server.
59:04 - Additionally, a lack of input
sanitization can lead to unexpected
59:08 - behavior on the part of the application.
59:10 - API providers use headers to provide the
consumer with instructions for handling
59:14 - the response and security requirements.
59:16 - Misconfigured headers can
result in sensitive information
59:19 - disclosure, downgrade attacks,
and cross site scripting attacks.
59:23 - Many API providers will use
additional services alongside
59:26 - their API to enhance API related
metrics or to improve security.
59:30 - It's fairly common that those additional
services will add headers to requests
59:34 - for metrics and perhaps as some
level of assurance to the consumer.
59:38 - The X-Powered-By header
reveals back end technology.
59:41 - Headers like this one often advertise the
exact supporting service and its version.
59:46 - An attacker could use information
like this to search for exploits
59:49 - published for that version of software.
59:51 - The X-XSS-Protection header is
exactly what it sounds like, a
59:55 - header that's meant to prevent
cross-site scripting (XSS) attacks.
59:58 - Cross site scripting is a common
type of injection vulnerability where
60:01 - an attacker could insert scripts
into a web page and trick end users
60:04 - into clicking on malicious links.
60:06 - A X-XSS-Protection header with a
value of 0 indicates no protections
60:11 - in place, and a value of 1 indicates
that the protection is turned on.
60:15 - This header and others like it,
clearly reveals whether or not
60:20 - a security control is in place.
60:22 - The X-Response-Time header is middleware
that provides the usage metrics.
60:27 - In this example, in the written
course material, its value
60:30 - represents 566 milliseconds.
60:33 - But if the API isn't configured properly,
this header can function as a side
60:37 - channel used to reveal existing resources.
60:40 - If the X-Response-Time header has
a consistent response time for non
60:44 - existing records, for example, but
increases its response time for certain
60:49 - other records that actually exist, this
could be an indication to an attacker
60:54 - that they've come across these files.
60:56 - Say, for instance, an attacker can
determine that a bogus account like
61:00 - /user/account/thisdefinitelydoesnotexist
has an average response
61:05 - time of 25 milliseconds.
61:07 - The attacker can know that
their existing account is
61:11 - /user/account/1021, which receives an
X-Response-Time of 510 milliseconds.
61:18 - An attacker could then send requests
brute forcing account numbers
61:21 - and review the results and see
which account numbers resulted in
61:24 - drastically increased response times.
61:27 - Any API providing sensitive information
to consumers should use Transport Layer
61:31 - Security to encrypt the data even if
the API is only provided internally,
61:36 - privately, or at a partner level.
61:38 - Transport Layer Security, the protocol
that encrypts HTTPS traffic, is one of
61:44 - the most basic ways to ensure that API
requests and responses are protected
61:48 - when being passed across a network.
61:50 - Misconfigured or missing transit
encryption can cause API users to pass
61:55 - sensitive API information in clear
text across networks, in which case an
61:59 - attacker could capture the responses
and requests with a Man-in-the-Middle
62:02 - (MITM) and read them plainly.
62:05 - They would simply have to  intercept
the network traffic with a network
62:08 - protocol analyzer like Wireshark to
see the information being communicated
62:13 - between a consumer and a provider.
62:15 - When a service uses default accounts or
credentials, and the defaults are known,
62:19 - an attacker can use those credentials
to assume the role of that account.
62:23 - This could allow them to gain access to
sensitive information or administrative
62:27 - functionality and potentially lead to
a compromise of the supporting systems.
62:31 - Lastly, if an API provider allows
unnecessary HTTP methods, there's
62:36 - an increased risk that the
application won't handle these
62:39 - methods properly or will result in
sensitive information disclosure.
62:44 - Out of all the vulnerabilities covered
on the OWASP Top 10, API8:2023 Security
62:51 - Misconfiguration is one of the only
ones that can be detected by web
62:54 - application vulnerability scanners.
62:56 - Automated scanners like BurpSuite,
Nessus, Qualys, OWASP, ZAP, and Nikto
63:01 - will automatically check responses
from the web server to determine the
63:05 - version information, headers, cookies,
transit encryption configuration,
63:09 - and parameters to see if expected
security measures are missing.
63:14 - Security misconfigurations can also be
checked manually if you know what you're
63:18 - looking for, by inspecting the headers,
SSL certificate, cookies, and parameters.
63:23 - The OWASP Preventative Measures states
the API lifecycle should include:
63:28 - repeatable hardening process leading
to a fast and easy deployment of a
63:31 - properly locked out environment, a task
to review and update configurations
63:35 - across the entire API stack.
63:37 - The review should include
orchestration files, API components
63:41 - and cloud services and automated
process to continuously assess the
63:45 - effectiveness of the configuration
and settings in all environments.
63:49 - Furthermore, ensure that all API
communications from the client to
63:53 - the API server And any downstream
upstream components happen over an
63:57 - encrypted communication channel,
regardless of whether it is an
64:01 - internal or public facing API.
64:04 - Be specific about which HTTP
verbs each API can be accessed by.
64:09 - All other HTTP verbs should be disabled.
64:13 - API's expecting to be accessed from
browser based clients should at
64:18 - least implement a proper Cross Origin
Resource Sharing (CORS) policy.
64:22 - Include applicable security headers,
restrict incoming content types/data
64:27 - formats to those that meet the
business functional requirements.
64:31 - Ensure all servers in the HTTP server
chain process incoming requests in a
64:35 - uniform manner to avoid desync issues.
64:38 - Where applicable, define and enforce all
API response payload schemas, including
64:43 - error responses to prevent exception
traces and other valuable information
64:48 - from being sent back to an attacker.
64:50 - Check out the written course content
for additional resources about
64:53 - API security misconfigurations.
65:02 - API9:2023, Improper Inventory
Management represents the risks
65:07 - involved with exposing non production
and unsupported API versions.
65:11 - When this is present, the non production
and unsupported versions of the API are
65:15 - often not protected by the same security
rigor as the production versions.
65:19 - This makes improper inventory
management a gateway to other
65:22 - API security vulnerabilities.
65:24 - The OWASP Attack Vector description states
"Threat agents usually get unauthorized
65:28 - access through old API versions or
endpoints left running unpatched and
65:33 - using weaker security requirements.
65:36 - Alternatively, they may get
access to sensitive data through
65:39 - a third party with whom there's
no reason to share data with."
65:43 - The OWASP Security Weakness
description states "Outdated
65:46 - documentation makes it more difficult
to find and or fix vulnerabilities.
65:50 - Lack of assets, inventory, and
retirement strategies leads to
65:54 - running unpatched systems, resulting
in leakage of sensitive data.
65:58 - It's common to find unnecessarily exposed
API hosts because of modern concepts like
66:03 - microservices, which makes applications
easy to deploy and independent.
66:08 - Simple Google Dorking, DNS
enumeration, or using specialized
66:12 - search engines for various types of
servers connected to the internet
66:16 - will be enough to discover targets."
66:19 - The OWASP Impacts description states
"Attackers can gain access to sensitive
66:23 - data or even take over the server.
66:26 - Sometimes different API version
deployments are connected to the
66:30 - same database with real data.
66:32 - Threat agents may exploit deprecated
endpoints available to in old API versions
66:37 - to get access to administrative functions
or exploit known vulnerabilities."
66:41 - Improper Inventory Management takes place
when an organization exposes APIs that
66:46 - are unsupported or still in development.
66:48 - As with any software, old API
versions are more likely to contain
66:51 - vulnerabilities because they are no
longer being patched and upgraded.
66:55 - Likewise, APIs that are still being
developed and are typically not as secure
66:59 - as their production API counterparts.
67:01 - Improper inventory management can
lead to other vulnerabilities such as
67:05 - excessive data exposure, information
disclosure, mass assignment, improper
67:10 - rate limiting, and API injection.
67:12 - For attackers, this means that discovering
an improper inventory management
67:16 - vulnerability is only the first step
toward further exploitation of an API.
67:20 - Detecting Improper Inventory Management
can be tested by using outdated
67:24 - API documentation, changelogs, and
version history on repositories.
67:29 - For example, if an organization's API
documentation has not been updated
67:33 - along with the API's endpoints, it
could contain references to portions of
67:37 - the API that are no longer supported.
67:40 - Organizations often include
versioning information in their
67:43 - endpoints names to distinguish
between older and newer versions.
67:47 - Such as /v1/, /v2/, or /v3/ and so on.
67:50 - APIs still in development often
use paths such as /alpha/,
67:54 - /beta/, /test/, /uat/ and /demo/.
67:57 - If you know that an API is now using
apiv3.org/admin, but a part of the API
68:04 - documentation refers to apiv1.org/admin,
you could try testing different endpoints
68:09 - to see if apiv1 or apiv2 are still active.
68:13 - Additionally, the organization's
change log may disclose the reasons
68:16 - why v1 was updated or retired.
68:19 - If an attacker has access to v1,
they can test those for weaknesses.
68:24 - Outside of using documentation, an
attacker could discover improper
68:27 - inventory vulnerabilities through
the use of guessing, fuzzing,
68:30 - or brute forcing requests.
68:32 - Testing for improper assets management
is all about discovering unsupported
68:36 - and non production versions of an API.
68:38 - API providers will often update
services and the newer version
68:42 - of the API in a variety of ways,
such as api.target.com/v3, or
68:48 - /api/v2/accounts, or /api/v3/accounts.
68:52 - API versioning could also
be maintained as a header.
68:55 - So you could see something like Accept:
version=2.0, or Accept api-version=3.
69:02 - In addition, versioning could
also be set within a query
69:04 - parameter or the request body.
69:06 - So you could see /api/accounts?ver=2.
69:11 - Or POST to API accounts with
the versioning equals 1.0.
69:15 - Non production versions of an API
include any version of the API that
69:19 - was not meant for end user consumption.
69:22 - Non production versions could include
api.test.target.com, beta.api.com,
69:29 - /api/private, /api/partner or /api/test.
69:34 - In these instances, earlier
versions of the API may no longer
69:37 - be patched or updated since the
older versions lack this support.
69:41 - They may expose the API to additional
vulnerabilities and lead an attacker
69:44 - to a path that can be used to
compromise the provider's data.
69:47 - The OWASP Preventative Measures states
inventory all API hosts and document
69:52 - important aspects of each one of them,
focusing on the API environment, such as
69:56 - production, staging, test or development,
who should have network access to the
70:00 - host, such as public, internal or partners
and the API version inventory integrated
70:06 - services and document important aspects,
such as their role in the system, what
70:11 - data is exchanged and its sensitivity.
70:14 - Document all aspects of your API, such as
authentication, errors, redirects, rate
70:19 - limiting, cross origin resource sharing,
CORS policy, and endpoints, including
70:24 - their parameters, requests, and responses.
70:27 - Generate documentation automatically
by adopting open standards.
70:30 - Include the documentation
built in your CI/CD pipeline.
70:34 - Make API documentation available
to those authorized to use the API.
70:38 - Use external protection measures,
such as an API security firewall, for
70:42 - all exposed versions of your APIs.
70:44 - Not just for the current
production versions.
70:46 - Avoid using production data with
non production API deployments.
70:50 - If this is unavoidable, these
endpoints should get the same security
70:53 - treatment as the production ones.
70:55 - When newer versions of the API include
security improvements, perform risks
70:59 - analysis, risk analysis to make the
decision of the mitigation actions
71:03 - required for the older version.
71:05 - For example, whether it is possible to
backport the improvements without breaking
71:09 - API compatibility, or you need to take
the older version, but quickly enforce
71:14 - all clients to move to the latest version.
71:17 - For additional resources about
improper inventory management, check
71:20 - out the written course materials.
71:25 - API10:2023, Unsafe Consumption of
APIs is the only item on the Top 10
71:29 - list that focuses less on the risks
of being an API provider and more on
71:33 - the risks of being an API consumer.
71:35 - Unsafe consumption is
really a trust issue.
71:37 - When an application is consuming the data
of a third party API, it should treat
71:41 - those with a similar trust to user input.
71:44 - By that, I mean there should
be little to no trust.
71:47 - So data consumed from third party API
should be treated with similar security
71:50 - standards as end user supplied input.
71:53 - If a third party API provider is
compromised, then that insecure
71:57 - API connection back to the consumer
becomes a new attack vector
72:00 - for the attacker to leverage.
72:02 - In the case of an insecure API
connection, that could mean the complete
72:05 - compromise of organizations insecurely
consuming data from that API provider.
72:11 - The OWASP Attack Vector description
states "exploiting this issue requires
72:15 - attackers to identify and potentially
compromise other APIs or services
72:20 - the target API is integrated with.
72:22 - Usually this information is not publicly
available or the integrated API or
72:26 - service is not easily exploitable."
72:29 - The OWASP Security Weakness description
states "developers tend to trust and not
72:34 - verify the endpoints that interact with
external or third party APIs relying
72:38 - on weaker security requirements such
as those regarding transport security,
72:42 - authentication, authorization, and
input validation and sanitization.
72:47 - Attackers need to identify services the
target API interacts with or integrates
72:52 - with and eventually compromise them."
72:54 - The OWASP Impacts description states
"the impact varies according to what
72:59 - the target API does with pooled data.
73:02 - Successful exploitation may lead to
sensitive information exposure to
73:05 - unauthorized actors, many kinds of
injections, or denial of service."
73:10 - Most of the 2023 API Security Top 10
is about APIs and the API provider.
73:15 - An API can often serve as the path
of least resistance for an attacker.
73:19 - So if an attacker compromises a third
party API provider, then that third
73:23 - party's connection to other businesses
can become an additional attack vector.
73:27 - If that API is over an unencrypted
connection, then an attacker would be able
73:31 - to capture sensitive data in clear text.
73:33 - If that third party API isn't held
to similar security standards as
73:37 - internet facing APIs, then it could
also be vulnerable to injection,
73:41 - authorization, authentication
and other compromising attacks.
73:44 - The OWASP Preventative Measure states
when evaluating service providers
73:48 - assess their API security posture.
73:50 - Ensure all API interactions happen
over a secure communication channel.
73:55 - Always validate and properly
sanitize data received from
73:58 - integrated APIs before using it.
74:00 - Maintain and allow a list of
well known locations integrated
74:04 - APIs may redirect yours to.
74:06 - Do not blindly follow redirects.
74:09 - For additional Resources about
unsafe consumption of APIs, check
74:13 - out the written course materials.
74:21 - Injection vulnerabilities have plagued
web applications for over two decades.
74:25 - They take place when an attacker can
send commands that are executed by the
74:29 - systems that support the web application.
74:31 - The most common forms of injection attacks
are SQL injection, cross site scripting,
74:35 - and operating system command injection.
74:37 - APIs are yet another attack vector for
these critical attacks to be communicated
74:41 - from an attacker to the supporting
system, supporting databases and systems.
74:46 - The OWASP 2019 Attack Vector description
states, "attackers will feed the API
74:52 - with malicious data through whatever
injection vectors are available,
74:55 - such as direct input parameters,
integrated services, expecting
74:59 - it to be sent to an interpreter."
75:01 - The OWASP 2019 Security Weakness
description states, "injection flaws
75:05 - are very common and are often found
in SQL, LDAP, or NoSQL queries,
75:10 - OS commands, XML parsers, and ORM.
75:13 - These flaws are easy to discover
when reviewing the source code.
75:17 - Attackers can use scanners
and fuzzers to find these."
75:21 - The OWASP 2019 Impacts Description
states, Injection can lead to
75:25 - information disclosure and data
loss and may also lead to denial of
75:28 - service or complete host takeover.
75:31 - Injection flaws exist when a
request is passed to the API
75:34 - supporting infrastructure and the
API provider doesn't filter the
75:37 - input to remove unwanted characters.
75:39 - As a result, the infrastructure
might treat the data from the
75:42 - request as code and run it.
75:44 - When this sort of flaw is present, an
attacker will be able to conduct injection
75:47 - attacks like SQL injection, NoSQL
injection, and system command injection.
75:52 - When these injection attacks are
successful, the API delivers an
75:55 - unsanitized payload directly to
the operating system running the
75:58 - application or a query to its database.
76:01 - As a result, if an attacker sends
a payload containing SQL commands
76:05 - to a vulnerable API that uses a
SQL database, the API will pass the
76:09 - commands to the database, which will
process and perform the commands.
76:13 - The same will happen with vulnerable
NoSQL databases and affected systems.
76:18 - Verbose error messaging, HTTP response
codes, and unexpected API behavior
76:22 - can all be clues to an attacker
and will be an indication that they
76:26 - have discovered an injection flaw.
76:28 - Say, for example, an attacker were
to send OR1 00 DAS as an address
76:34 - in an account registration process.
76:36 - The API may pass that payload
directly back to the back end SQL
76:40 - database, where the or 1 equals 0
statement, which would fail as 1 does
76:44 - not equal 0, causing a SQL error.
76:47 - An error in the backend database could
show up as a response to the consumer.
76:52 - In this case, the attacker, who's
the consumer, might receive a
76:55 - response like, Error equals you
have an error in your SQL syntax.
77:00 - But, any response directly from the
database or the supporting system will
77:04 - serve as a clear indicator that there's
likely an injection vulnerability.
77:08 - Injection vulnerabilities are often
complemented by other weaknesses
77:11 - like poor input sanitization.
77:14 - Injection flaws can have serious
impacts by providing an attacker
77:17 - with the ability to manipulate an
API supporting system or database.
77:21 - Finding injection flaws requires
diligently testing API endpoints and
77:24 - paying attention to how the API responds,
then crafting requests that attempt
77:28 - to manipulate the backend systems.
77:30 - Injection attacks have been around for
decades, so there are many standard
77:34 - security controls that can be used
to protect API providers from them.
77:38 - The OWASP 2019 Preventative
Measures states, Preventing
77:42 - injection requires keeping data
separate from commands and queries.
77:45 - Perform data validation using
a single trustworthy and
77:48 - actively maintained library.
77:50 - Validate, filter, and sanitize all
client provided data or other data
77:54 - coming from integrated systems.
77:57 - Special characters should be
escaped using the specific syntax
78:00 - for the target interpreter.
78:02 - Prefer a safe API that provides
parameterized interface.
78:06 - Always limit the number of
returned records to prevent mass
78:09 - disclosure in case of injection.
78:11 - Validate incoming data using
sufficient filters to only allow
78:14 - valid values for each input parameter.
78:17 - Define data types and strict
patterns for all string parameters.
78:21 - For additional resources
about API injection, check out
78:24 - the written course content.
78:27 - Logging and Monitoring are a necessary
and important layer of API security.
78:32 - In order to detect an attack
against an API, an organization
78:36 - must have monitoring in place.
78:38 - Without sufficient logging and monitoring,
an API provider is operating in the
78:41 - dark, and API attacks are guaranteed to
go unnoticed until it's far too late.
78:46 - The OWASP 2019 Attack Vector description
states, "Attackers take advantage of
78:51 - a lack of logging and monitoring to
abuse systems without being noticed."
78:55 - The OWASP 2019 Security Weakness
description states, "Without logging
78:59 - and monitoring, or insufficient logging
and monitoring, it is almost impossible
79:03 - to track suspicious activities and
respond to them in a timely fashion."
79:08 - The OWASP 2019 Impacts description states,
"Without visibility over ongoing malicious
79:13 - activities, attackers have plenty
of time to fully compromise systems.
79:17 - Logs can reveal patterns in API
usage and can be used as evidence
79:21 - to understand how an API is abused.
79:24 - Logging and monitoring provide an
audit trail of activities and are often
79:27 - required for compliance purposes."
79:30 - An important part of logging is to
ensure that the logs have integrity
79:33 - and cannot be altered by an attacker.
79:35 - Monitoring an API will help providers
detect suspicious activities
79:39 - and anomalous user behavior.
79:41 - This helps providers be able to
take action to thwart attacks.
79:45 - Logging and monitoring are essential for
improving API performance and security.
79:49 - The OWASP 2019 Preventative
Measures states, log all failed
79:54 - authentication attempts, denied
access, and input validation errors.
79:59 - Logs should be written using a format
suited to be consumed by a log management
80:03 - solution and should include enough
detail to identify the malicious actor.
80:07 - Logs should be handled as sensitive
data and their integrity should
80:10 - be guaranteed at rest and transit.
80:13 - Configure a monitoring system to
continuously monitor the infrastructure
80:17 - network and API functioning.
80:19 - Use a SIEM system to aggregate and
manage logs from all components
80:23 - of the API stack and hosts.
80:26 - Configure custom dashboards and alerts
enabling suspicious activities to be
80:30 - detected and responded to earlier.
80:33 - For additional resources about
insufficient logging and monitoring,
80:36 - check out the written course content.
80:40 - Business logic vulnerabilities
are weaknesses within applications
80:43 - that are unique to the policies and
features of a given API provider.
80:47 - The exploitation of business logic
takes place when an attacker leverages
80:51 - misplaced trust or features of
an application against the API.
80:54 - Identifying business logic
vulnerabilities can be challenging due
80:57 - to the unique nature of each business.
80:59 - The impact of these vulnerabilities
can range based on the severity of
81:03 - the vulnerable policy or feature.
81:05 - My attack vector description for this
Business logic vulnerabilities are
81:09 - unique to each application and exploit
the normal intended functioning of
81:13 - an application's business processes.
81:15 - They often require specific knowledge
of the application's functionality
81:19 - and the flow of transactions or data.
81:21 - Since these vulnerabilities are
specific to the business logic of
81:24 - each application, there's no one size
fits all approach to identifying them.
81:29 - My security weakness description states,
business logic vulnerabilities arise when
81:34 - the assumptions and constraints of a given
business process aren't properly enforced
81:38 - in the application's control structures.
81:41 - This allows users to manipulate
the application's functionality
81:44 - to achieve outcomes that are
detrimental to the business.
81:47 - These weaknesses typically occur when
developers fail to anticipate the various
81:52 - ways that an application's features can
be misused or when they don't consider
81:56 - the wider context of the business rules.
81:59 - This is often due to a lack of
comprehensive understanding of the
82:02 - application's business logic, a lack
of input validation, or incomplete
82:07 - function level authorization checks.
82:09 - My impacts description states Business
logic vulnerabilities can cause a variety
82:14 - of technical impacts depending on the
specific flaw in the systems involved.
82:18 - These impacts can range from unauthorized
access to data or functionality to
82:23 - a total bypass of system controls.
82:26 - Business logic vulnerabilities, also
known as business logic flaws, or BLFs,
82:30 - are intended features of an application
that attackers can use maliciously.
82:34 - For example, if an API has an upload
feature that instructs users to only
82:38 - upload certain encoded payloads,
but doesn't actually validate those
82:41 - encoded payloads, a user could upload
any file as long as it was encoded.
82:46 - This would allow end users to upload
and potentially execute arbitrary
82:49 - code, including malicious payloads.
82:52 - Vulnerabilities of this sort normally
come about from an assumption
82:55 - that API consumers will follow
directions, be trustworthy, or
82:58 - only use the API in a certain way.
83:01 - In those cases, the organization
essentially depends on trust as
83:04 - a security control by expecting
the consumer to act benevolently.
83:08 - Unfortunately, even good natured API
consumers make mistakes that could lead
83:12 - to a compromise of the application.
83:14 - The Experian partner API leak in 2021 was
a great example of an API trust failure.
83:20 - A certain Experian partner was authorized
to use Experian's API to perform credit
83:24 - checks, but the partner added the API's
credit check functionality to their web
83:28 - application and inadvertently exposed
all partner level requests to users.
83:33 - This request could be intercepted
when using the partner's web
83:36 - application, and if it included a
name and address, the Experian API
83:40 - would respond with the individual's
credit score and credit risk factors.
83:44 - One of the leading causes of this business
logic vulnerability was that the Experian
83:48 - trusted the partner to not expose the API.
83:53 - Another problem with trust
is that credentials like API
83:55 - keys, tokens, and passwords are
constantly being stolen and leaked.
83:59 - When a trusted consumer's credentials
are stolen, the consumer can become a
84:02 - wolf in sheep's clothing and wreak havoc.
84:05 - Without strong technical controls in
place, business logic vulnerabilities can
84:09 - often have the most significant impact
leading to exploitation and compromise.
84:13 - An API's documentation can be a telltale
sign of a business logic vulnerability.
84:18 - Statements like the following
should be indications of
84:20 - potential business logic flaws.
84:22 - Only use feature x to perform function y.
84:26 - Do not do x with endpoint y.
84:28 - Only admins should perform request X.
84:31 - These statements may indicate
that the API provider is trusting
84:35 - that end users won't do any of the
discouraged actions as instructed.
84:40 - An attacker will easily disobey such
requests to test for the presence
84:43 - of technical security controls.
84:45 - Another business logic vulnerability
comes about when developers assume
84:50 - that consumers will exclusively use
a browser to interact with the web
84:54 - application and won't capture API requests
that take place behind the scenes.
84:58 - All it takes to exploit this sort of
weakness is for an attacker to intercept
85:02 - requests and alter the API request
before it is sent to the provider.
85:06 - This would allow the attacker to
capture shared API keys or use
85:09 - parameters that could negatively
impact the security of the application.
85:13 - As an example, consider a web
app authentication portal that
85:16 - a user normally would employ to
authenticate to their account.
85:20 - Say the web application issued an API
authentication request that included the
85:24 - username and password along with a query
parameter, multi factor equals true.
85:29 - There's a chance that an attacker could
bypass the multi factor authentication by
85:32 - simply altering the parameter to false.
85:35 - Testing for business logic
flaws can be challenging
85:37 - because each business is unique.
85:40 - Automated scanners will have a difficult
time detecting these issues, as the
85:43 - flaws are part of the API's intended use.
85:46 - You must understand how the
business and API operate, and then
85:49 - consider how an attacker could use
these features to their advantage.
85:52 - One method of testing for business
logic flaws is to study the
85:55 - application's business logic with an
adversarial mindset and try breaking
85:59 - any assumptions that have been made.
86:01 - My preventative measures for business
logic flaws include the following.
86:05 - Use a threat modeling approach.
86:07 - Understand the business processes
and workflows your API supports.
86:11 - Identify the potential threats,
weaknesses, and risks during the design
86:15 - phase that can help to uncover and
mitigate business logic vulnerabilities.
86:19 - Reduce or remove trust relationships
with users, systems, or components.
86:24 - Business logic vulnerabilities
can be used to exploit these trust
86:27 - relationships leading to a broader impact.
86:29 - Regular training can help
developers to understand and avoid
86:32 - business logic vulnerabilities.
86:34 - Training should cover secure coding
practices, common vulnerabilities,
86:37 - and how to identify potential issues
during design and coding phases.
86:41 - Implement a bug bounty program,
third party penetration testing,
86:44 - or responsible disclosure policy.
86:47 - This allows security researchers who
are a step removed from the design and
86:50 - delivery of an application to disclose
vulnerabilities they discover in APIs.
86:55 - For additional resources about
business logic vulnerabilities, check
86:58 - out the written course material.
87:02 - And that wraps up the OWASP API
security top 10 and beyond course.
87:07 - Hope you enjoyed it.
87:08 - And if you'd like to earn a badge and
certificate for this course, please enroll
87:12 - at apisecuniversity.com, take the quizzes,
and we'll be happy to issue your cert.
87:17 - And while you're there, be sure
to check out our other courses,
87:20 - including API Pen Testing, API
Security Fundamentals, and more.
87:24 - We also host many webinars with
API experts across industries,
87:29 - disciplines, and geographies.
87:31 - You'll see these listed on our
website and on our YouTube channel.
87:34 - Please subscribe.
87:36 - Thanks for watching, and
hope to see you again soon.

Cleaned transcript:

The OWASP API Security Top 10 is a standard reference guide highlighting the most critical web API vulnerabilities to help developers and organizations understand and mitigate potential security threats. In this course, you will learn about each security risk and learn techniques to fortify your APIs against potential threats. Corey Ball developed this course. He is a cybersecurity consultant and a leading expert in API security. So he's the perfect person to teach you how to secure your APIs. Hello, freeCodeCamp community and welcome to APIsec University and this course on OWASP API Security Top 10 and Beyond. My name's Dan Barahona. I'm the cofounder of APIsec University, and for the next 90 minutes, you'll learn all about the OWASP API Security Top 10, updated in 2023, and we'll even add a few extra bonus topics that are really important to know about. Your instructor for the course is my good friend, Corey Ball, author of the Hacking APIs book and wellrecognized expert in the field of API security. I invite you to check out all our free courses over on APIsec University, including a handson course on API Pen Testing, an introductory course on API Security Fundamentals, this course here on the OWASP API Top 10, as well as a PCI Compliance course, an API Documentation course, and many more to come. All the courses on our site include quizzes to assess your knowledge, and if you complete everything and pass the final quiz, we'll issue you a certificate and badge to recognize your accomplishment, which you can also display on your LinkedIn profile. Thanks again for watching and I hope you enjoy the course. Welcome to OWASP API Security Top 10 and Beyond. In this course, we'll dive into the latest updates to the OWASP API Security Top 10, and discuss other significant security considerations beyond the Top 10. The first edition of the API Security Top 10 was released in 2019, and now OWASP has officially released the 2023 version. As APIs are a critical component of the modern digital world, this list is of utmost importance. This course highlights the most common API security vulnerabilities and is meant to help educate the community of builders, breakers, and defenders. The course will help you identify and analyze the most common weaknesses that plague modern web application programming interfaces, or APIs. By the end of this course, you should have an understanding of the variety of vulnerabilities associated with APIs, the attack vectors involved, and the technical impact and exploited vulnerability could have. So who is this course for? This course is great for anyone involved in the API economy. It is meant to help improve the skills and knowledge of bug bounty hunters, developers, penetration testers, organizational leadership, and anyone else interested in learning about API security. Before taking this course, you should be familiar with API security fundamentals. If you would like to learn more about this, check out our API Security Fundamentals course. So how does this course work? Read, watch, and or listen to the content provided in the course modules. It is highly recommended that you take notes, explore the recommended resources, follow along with the course materials, and complete the quizzes at the end of every module. The content presented in the video should closely align with the written content. The videos offer visual and audible alternatives to consuming the content of this course. Quizzes During the course, quizzes will be used to validate your knowledge. Quizzes are knowledgebased, multiple choice tests based on the content discussed within the given module. The OWASP API Security Top 10 and Beyond course is meant to be a challenging course that sets a high bar. To pass any quiz or assessment, you must answer a hundred percent of the questions correctly. Completing all quizzes will result in obtaining a certificate of completion. This course is entirely free, and you can earn the certificate of completion by passing all course modules and passing all the quizzes. Those who would like to certify their knowledge can take the course exam. The exam is a knowledge based assessment of your ability to analyze APIs and find vulnerabilities. Students who pass the exam will earn the Certified API Security Analyst certification or CASA. Formatting Please note that all content in italics under sections designated OWASP is sourced directly from the OWASP API Security Top 10 2023. This content is attributed to the OWASP API Security Project Team and OWASP API Security Project contributors. All other sources will be directly referred to. No changes were made to the content. Hey everyone. Quick introduction. My name is Corey Ball. I'm the author of Hacking APIs, technical editor of Black Hat GraphQL, and contributor to the OWASP API Security Top 10 2023. I'm also the Chief Hacking Officer for APIsec University and a Senior Manager of Penetration Testing over at Moss Adams. I have over 13 years of experience working in IT and cybersecurity across several industries. In addition to a Bachelor's degree in English and philosophy from Sac State, I also hold several certs including the OSCP, CCISO, CISSP, and several others. I hope you enjoy this course. The objective of this course is to help students become API security professionals, and be able to identify and reduce API related security risks. OWASP API Security Top 10 and Beyond is meant to help improve the skills of bug bounty hunters, developers, penetration testers, organizational leadership, and anyone else interested in learning about API security. Course objectives include the introduction to OWASP, the API Security Project, and the changes from the 2019 to the 2023 version. Should help prepare students to pass the Certified API Security Analyst or CASA exam. Develop a strong foundation in the following API security risks Broken Object Level Authorization, Broken Authentication, Broken Object Property Level Authorization, Unrestricted Resource Consumption, Broken Function Level Authorization, Unrestricted Access to Sensitive Business Flows, Server Side Request Forgery, Security Misconfiguration, Improper Inventory Management, Unsafe Consumption of APIs. In addition to that, it's to help secure the APIs of the internet and prevent API related data breaches. Finally this course is meant to help prepare students with additional resources for continued learning and growth in API security. The Open Web Application security project, or OWASP, is a nonprofit foundation that was created to help improve application security. The OWASP Foundation launched on December 1st, 2001, and is most well known for its Top 10 list open source tools and other security projects. The OWASP API Security Top 10 is a list of the most critical security risks for application programming interfaces. The founders of the project include Erez Yalon and Inon Shkedy. The OWASP API Security Top 10 was originally released in December, 2019 and was driven by several key factors. The first was the rapid rise of APIs. APIs power the flow of the world's most valuable resource, which is data. A business no longer needs to specialize in all aspects of creating software. Instead, they can use the features of software shared by other companies and organizations. Historically, the issue with doing this was the disconnected nature of different programming languages, web application programming interfaces allowed for a common method to consume or provide data across the internet. Since the widespread adoption of web APIs, organizations have been enabled to leverage the functionality. Of other applications. Instead of having to develop custom software for maps, gps, payment processing, authentication, communication, and much more, developers can leverage APIs to use the functionality of other applications that specialize in that given area. APIs are a major business enabler, which explains the global rapid adoption. Second, a major gap in security. So the next factor that compounded the effects of the other two is the fact that the tools and techniques of the past were not effective at detecting API related vulnerabilities. The tools and techniques that were used for enterprise vulnerability management programs, web applications, scanners, and traditional network security monitoring tools were not designed to handle the unique challenges posed by APIs. As a result, many organizations were not adequately prepared to defend against API attacks leaving them vulnerable to data breaches. Third, a new leading attack vector. Often when it comes to the rapid adoption of new technologies, security is an afterthought. APIs are no different. The rapid adoption of APIs led to a new attack vector that exposes data application functionality. Public internet facing APIs often bypassed all of the security measures that had grown with businesses over the past decades. An attacker no longer needs to go through the classic MITRE cyber kill chain by bypassing the firewall, gaining entry to the network, pivoting around to system that contains data, and then finding a way to exfiltrate that data. Instead, an attacker can use an insecure API and have direct access to that sensitive data. In response to the massive adoption of APIs, the security gaps introduced by API providers, and the new wave of API related security incidents, the OWASP API Security Project published its Top 10 list. The APIfocused Top 10 list provides a comprehensive set of guidelines, best practices, and tools to help organizations secure their APIs and protect against API related threats. The OWASP API Security Project has become a widely recognized and respected resource for security professionals and has helped raise awareness of the importance of API security. How is the top 10 compiled? As described by Paulo Silva, OWASP API Security Project leader, the 2023 OWASP API Security Top 10 list is put together by the project team based on internal research, based on publicly available data, bounty platforms and news. Since the project did not receive any data during the call for data during the two month window in late 2022, the top 10 list was compiled based on the project team's research. This was not something new or different for the project as this is, as Silva stated, what was done in 2019. Without dataset received from the community, the OWASP project team had to compile data based on public disclosures from bug bounty pro platforms and API security incidents that made it into the news. Although this dataset isn't as ideal as data compiled directly from testing hundreds of thousands of endpoints across the internet, it does represent a sample of realworld API weaknesses. Some potential issues with applying this data include bug bounty program incentivizes certain types of findings over others. Bug bounty programs attract participants that represent a small sample of the APIs that are actually out in the wild. Newsworthy incidents often leave security researchers without specific technical details. Obviously newsworthy incidents do not include all of the breaches and security incidents that are not reported or publicized. That being the case, there are lessons to be learned and risks to be aware of based on bug bounty, writeups, and publicized security incidents. If you are interested in learning more about the sources, belows a list of common websites to dive deeper into bug bounty research. In addition to these, attached to this module is a JSON extract from PentesterLand that contains all documented API writeups. PentesterLand writeup compilation, HackerOne hack activity, Awesome Bugbounty writeups, all the links are in the content below. Also, in the course content is a list of some of the most newsworthy API incidents in the last five years, including data breaches and leaks from the USPS, Optus, TMobile, and Toyota. The OWASP API Security Top 10 list contains common groups of the most critical security risks to be on the lookout for based on these sources. The OWASP API security risks are associated with references to external sources. These sources include CWEs, or Common Weakness Enumeration, other OAS projects, and the National Institute of Standards and Technology, or NIST Guidance. Most of the references involve CWE. CWEs are a list of common software and hardware vulnerabilities developed by the community and hosted by MITRE. Each CWE is identified by a unique identifier or CWEID. This identifier can be used to refer back to a specific vulnerability. Check out the full table of external sources in the course material below. Understanding the external sources and how they're associated with a given OWASP API Security Top 10 risk will help provide you with additional insight. Throughout the course external sources will be provided for the OWASP API Security Top 10 risks. These resources will be provided to you to help you dive in as deep as you'd like into the topic of API security. We will dive deeper into these in later modules. In the next section, we'll go over the updates to the top 10 list from 2019 to 2023. Since the release of the OWASP API Security Top 10 in 2019, API usage has grown. API related data breaches have continued and new API technologies have emerged. All of this has played a role in the need for an updated version of the API security project's Top 10 list. Since the 2019 Top 10, several events have demonstrated the importance of keeping the list updated and relevant. API attacks are consistently on the rise. Akamai reported seeing nearly 114 million API attacks in a single day in 2021. The global API market value was valued at 2.2 billion in 2021, and was predicted to reach 41.5 by 2031. That's a 20 times growth rate, in 10 years. In 2022, Postman had over 46 million Postman collections, and GitHub had 3 million API related repos. APIs continue to be rapidly adopted and the financial stakes continue to climb. The OWASP API Security Project updated the Top 10 list to address some of the changes in the attack trends that have emerged since the previous version. Inon Shkedy, OWASP API Security Project Leader, stated that the OWASP API Top 10 2023 version is different from the 2019 version. "We aspire to follow the security trends that are relevant to APIs and have been developed in recent years. If you try to hack or protect an API that was developed five years ago, it would make more sense to refer to the 2019 list." At a high level, when you compare the Top 10 from 2019 to 2023, you see that two previous risks were removed from the list, three remained exactly the same, four were updated, and five of the 2023 are new. The two items that were removed included Injection and Insufficient Logging and Monitoring. These two risks were not completely mitigated and resolved, but the importance of new emerging risks pushed them beyond the Top 10. Logging and Monitoring is a classic OWASP Top 10 risk, but it is not an item that is represented in breaches or disclosed bug bounties. Injection attacks are still around and many web APIs are still susceptible, but the adoption of web application firewalls and implementation of other mitigation techniques has reduced the occurrence of notable API injection. There were three categories that remained on the list. Broken Object Level Authorization or BOLA, Broken Function Level Authorization, or BFLA, and Security Misconfiguration. BOLA and BFLA are still among the most common API risks and account for many of the breaches in bug bounty disclosures. APIs continue to have severe issues when it comes to authorization risk. The Security Misconfiguration category contains a wide range of possible misconfigurations that can plague APIs. In other words, this category is unlikely to leave the Top 10 because it is a catchall for many API vulnerabilities. Four categories were renamed. The renaming of these categories helped simplify the risk categories and bring additional focus to the issue at hand. Broken User Authentication has now become Broken Authentication. This simplification has done away with User and now brings additional attention to the API authentication as a whole process. Improper Assets Management has become Improper Inventory Management. This change was likely made to better align with industry terminology and to cover a wider range of resources. The term Assets might only refer to tangible items valued by an organization while the term Inventory could refer to a wider set of resources. There were a total of five categories that were added to the OWASP API Security Top 10 2023 that were not on the 2019 version. Server Side Request Forgery and Unsafe Consumption of APIs are completely new and did not have previous representation on the 2019 OWASP API Security Top 10 list. Server Side Request Forgery was represented on the 2021 OWASP Top 10 list and was added to that list based on survey results rather than by incident occurrence. The remaining new risk categories included Broken Object Property Level Authorization, or BOPLA, Unrestricted Resource Consumption, and Unrestricted Access to Sensitive Business Flows, each containing elements from the 2019 list. For example, BOPLA is a combination of Excessive Data Exposure and Mass Assignment, and we will dive deeper into each of these later in the course. Paired with each OWASP API security risk category are Risk Ratings. The risk ratings were based on the OWASP risk rating methodology. The project now refers to the OWASP risk rating framework. In the written course content, there is a table demonstrating the risk ratings used for the OWASP API security project from the OWASP API Security Top 10 2019 pdf. Any of these factors could significantly affect the overall likelihood of an attacker finding and exploiting a particular vulnerability. This rating does not take into account the actual impact on a specific business. The risk score must be determined by the given organization, as the project team states. The purpose of the OWASP API Security Top 10 is not to do this risk analysis for you. In other words, the purpose of the OWASP API Security Top 10 was not to perform a specific risk analysis for a given organization, but to provide a guideline for organizations to consider risk factors. In the course content, you can see a table containing the changes to the 2019 and 2023 risk ratings. The classic equation for risk is likelihood multiplied by impact with each risk score. The OWASP API Security Project team has left the impact as a relative value to be determined by the business. In addition, the project team includes a note along with these scores that the likelihood of these scores is not taken into account. What we are left with are values that represent overall exploitability, including complexity, exploitability, weakness prevalence, weakness detectability, and technical impact. Note that the overall score does not equate to a risk score because significant factors such as business impact and likelihood are not accounted for. API12023 Broken Object Level Authorization, or BOLA, is one of the most prevalent and severe vulnerabilities for APIs. BOLA vulnerabilities occur when an API provider does not have sufficient controls in place to enforce authorization. In other words, API users should only have access to sensitive resources that belong to them. When BOLA is present, an attacker will be able to access the sensitive data of other users. The OWASP attack vector description states "Attackers can exploit API endpoints that are vulnerable to a broken object level authorization by manipulating the ID of an object that is sent within the request. Object IDs can be anything from sequential integers, UUIDs or generic strings. Regardless of the data type, they're easy to identify in the request target, either through the path or a query string parameter request headers, or even as a part of the request payload." The OWASP security weakness description states "This has been the most common and impactful attack on APIs. Authorization and access control mechanisms in modern web applications are complex and widespread. Even if the application implements a proper infrastructure for authorization checks, developers might forget to use these checks before accessing a sensitive object. Access controlled detection is not typically amenable to automated static or dynamic testing." The OWASP impact description states "Unauthorized access can result in data disclosure to unauthorized parties, data loss or data manipulation. Unauthorized access to objects can also lead to full account takeover." If an API endpoint has insufficient access controls, it will not perform checks to ensure users can only access their own resources. When these controls are missing, User A will be able to obtain User B's resources via API requests. APIs use some sort of value like names or numbers to identify various objects. When an attacker discovers an API's resource ID, they will attempt to obtain the resources when unauthenticated or authenticated as a different user. For instance, imagine that an authenticated user Bruce sends a GET request to https//herohospital.com/api/v3/users?id=2727 and receives a JSON response back with his data, this poses no problem. Bruce should be able to access Bruce's own information. However, if Bruce is able to access another user's information, then a BOLA vulnerability would be present. This weakness can be tested by using other resource IDs in place of 2727. Say Bruce is able to obtain information about another user by sending a request to https//herohospital.com/api/v3/users?id=2728, and receives a response about Harvey Dent and his dissociative identity disorder, then there would be a problem. Assuming that Bruce is still using his authorization to access this data, this would be a clear indication that the API is vulnerable to BOLA. BOLA isn't always as simple as this example because there's flexibility in how resources are provisioned and requested from one API to the next. The written course content contains several examples of how API resources may be requested and attacked. In these examples, tests can be performed by replacing the bolded resource IDs with other numbers or words. Of course, in POST request, the resource could also be requested in the POST body. If User A can successfully access the information of any other user, then there's a vulnerability present. BOLA vulnerabilities are the most common API vulnerabilities and are easily exploitable and require a low amount of technical skills in order to discover these. BOLA can present itself in many forms depending on how resources are organized. As you can see in the written course, content resources can be organized by a user, by group, or by a combination of both. In all of these instances, only those with the proper permission should be allowed to retrieve their resources. The OWASP preventative measures state In order to improve API security, it is important to implement robust authorization controls. These controls should consider user policies and rolebased access control hierarchies. The primary focus should be to ensure that authenticated users only have access to resources they are authorized to have access to. Using less predictable resource IDs can increase the challenge of a user or attacker guessing the resource ID of other users. Developers should perform tests that specifically test for authorization controls. Implement a proper authorization mechanism that relies on the user policies and hierarchy. Use the authorization mechanism to check if the logged in user has access to perform the requested action on the record in every function that uses an input from the client to access the record in the database. Prefer the use of random and unpredictable values, such as GUIDS for records IDs. Write tests to evaluate the vulnerability of the authorization mechanism. Do not deploy changes that make the tests fail. Check out the written course content for additional resources about BOLA. API22023, Broken Authentication, refers to any weakness within the API authentication process. All APIs that contain sensitive information should have some mechanism to authenticate users. Authentication is the process that is used to verify the identity of an API user. Whether that is a person, device, or system. In other words, authentication is the process of verifying that an entity is who that entity claims to be. This verification process is normally done with the use of a username and password combination, a token and or multifactor authentication. Authentication related vulnerabilities typically occur when an API provider either doesn't implement a strong authentication mechanism or implements an authentication process incorrectly. The OWASP Attack Vector description for this states that "The authentication mechanism is an easy target for attackers since it's exposed to everyone. Although more advanced technical skills may be required to exploit some authentication issues, exploitation tools are generally available." The OWASP Security Weakness description states "Software and security engineers' misconceptions regarding authentication, boundaries and inherent implementation complexity make authentication issues prevalent. Methodologies of detecting broken authentication are available and easy to create." The OWASP Impacts Description states "Attackers can gain complete control of other users' accounts in the system, read their personal data, and perform sensitive actions on their behalf. Systems are unlikely to be able to distinguish attackers actions from legitimate user ones." Broken Authentication continues to be a significant security issue due to poor password policies, weak authentication mechanisms, and misconfigurations. API authentication is a complex process that is commonly found with most APIs and is necessarily exposed. The impact of Broken Authentication can lead to an attacker taking control of user accounts, compromising personal data, and conducting sensitive actions like editing someone else's healthcare data. The authentication process is often one of the first lines of defense for APIs, and when this mechanism is vulnerable, it can lead to a data breach. A weak password policy does not sufficiently protect user accounts by enforcing strong password creation and management. This allows users to create simple passwords, allows brute force attempts against user accounts, and allows users to change their password without asking for password confirmation. Also allowing users to change their email without asking for password confirmation. Weak password policies also disclose tokens or passwords in the URL. It has a lack of authentication for sensitive requests. And in regards to GraphQL queries, weak password policies would allow for many authentication attempts within a single request. Credential stuffing is a type of attack against authentication where a large number of username and password combinations are attempted. Credentials used in these types of attacks are typically collected from data breaches. This sort of attack allows users to brute force many different username and password combinations without restrictions. Predictable tokens refers to any token obtained through a weak token generation authentication process. Weak tokens can easily be guessed, deduced, or calculated by an attacker. This would be an issue if an API is using incremental or guessable tokens for IDs. JWTs are commonly used for API authentication and authorization processes. JWT stands for JSON Web Token. JWTs provide developers with the flexibility to customize which algorithm is used for signing the token, the key and secret that is used and the information used in the payload. This customization allows for plenty of room for security misconfigurations to occur. These include API providers that accept unsigned JWT tokens, API providers that do not check JWT expirations, API providers that disclose sensitive information within the encoded JWT payload, and if the JWT is signed with a weak key. API authentication can be a complex system that includes several processes with a lot of room for failure. A couple decades ago, security expert Bruce Schneier said, "the future of digital systems is complexity, and complexity is the worst enemy of security." As we know from the six constraints of REST APIs, RESTful APIs are designed to be stateless. To be stateless the API providers shouldn't need to remember the consumer from one request to another. For this constraint to work, APIs often require users to undergo a registration process to obtain a unique token. The token that is generated is then used in subsequent requests for authentication and authorization. As a consequence, the registration process used to obtain an API token, the token handling, and the system that generates the token could all have their own set of weaknesses if the token generation process doesn't rely on a high level of randomness, or entropy, there's a chance that an attacker will be able to create their own token or hijack another user's token. The other authentication processes that could have their own set of vulnerabilities include aspects of the registration system, like password reset and multifactor authentication features. For example, imagine a password reset feature requiring you to provide an email address and a six digit code to reset your password. While if the API allowed you to make as many requests as you wanted, you'd only have to make 1 million requests in order to guess the code and reset any user's password. A four digit code would require only 10,000 requests. As it states in the OWASP Preventative Measures, make sure you know all the possible flows to authenticate to the API. Ask your engineers what flows you missed. Read about your authentication mechanisms. Make sure you understand what and how they are used. OAuth is not authentication and neither are API keys. Don't reinvent the wheel in authentication, token generation or password storage, use the standards. Credential recovery and forgot password endpoints should be treated as login endpoints in terms of brute force, ratelimiting and lockout protections. Require reauthentication for sensitive operations, including changing the account on our email address and multifactor phone number. Use the OWASP API Authentication Cheat Sheet. You can find that in the written content. Where possible implement multifactor authentication. Implement antibrute force mechanisms to mitigate credential stuffing, dictionary attacks, and brute force attacks on your authentication endpoints. This mechanism should be stricter than the regular rate limiting mechanisms on your APIs. Implement account lockout capture mechanisms to prevent brute force attacks against specific users. Implement weakpassword checks. API keys should not be used for authentication. They should only be used for API client authentication. Check out the written course content for additional resources about Broken Authentication. API32023 Broken Object Property Level Authorization, or BOPLA, is a combination of two items from the 2019 OWASP API Security Top 10 Excessive Data Exposure and Mass Assignment. Excessive Data Exposure takes place when an API provider responds to a request with an entire data object. Usually an API provider will filter out the data object down to what is being requested. When the data object is shared without being filtered, there is an increased risk of exposing sensitive information. Mass Assignment is a weakness that allows for user input to alter sensitive object properties. If, for example, an API uses a special property to create admin accounts, only authorized users should be able to make requests that successfully alter those administrative properties. If there are no restrictions in place, then an attacker would be able to elevate their privileges and perform administrative actions by altering those properties. Both of these vulnerabilities involved issues with object property authorization, so they're combined under the new title of Broken Object Property Level Authorization. As it states in the OWASP Attack Vector description APIs tend to expose endpoints that return all objects properties. This is particularly valid for REST APIs. For other protocols such as GraphQL, it may require crafted requests to specify which properties should be returned. Identifying these additional properties that can be manipulated requires more effort, but there are a few automated tools available to assist in this task. The OWASP Security Weakness description states in inspecting API responses is enough to identify sensitive information in returned objects, representations. Fuzzing is usually used to identify additional hidden properties. Whether they can be changed is a matter of crafting an API request and analyzing the response. Side effect analysis may be required if the target property is not returned in the API response. The OWASP Impacts Description states unauthorized access to private or sensitive object properties may result in data disclosure, data loss, or data corruption. Under certain circumstances, unauthorized access to object properties can lead to privilege as escalation or partial to full account takeover. As previously stated, Broken Object Property Level Authorization, or BOPLA, is a combination of Mass Assignment and Excessive Data Exposure. In the 2023 release notes, the security project states that these two vulnerabilities were combined focusing on the common root cause, object, property level authorization, validation failures. The OWASP API Security project also states an API endpoint is vulnerable if either the API endpoint exposes properties of an object that are considered sensitive and should not be read by the user, which is an Excessive Data Exposure, or the API endpoint allows a user to change, add, or delete the value of a sensitive object's property, which the user should not be able to access, which is Mass Assignment. Excessive Data Exposure is when an API endpoint responds with more information than is needed to fulfill a request. This often occurs in cases when the provider expects the API consumer to filter results. When a consumer requests specific information, the provider might respond with all sorts of information, assuming the consumer will then remove any data they don't need from the response. When this vulnerability is present, it can be the equivalent of asking someone for their name and having them respond with their name, date of birth, email address, phone number, and the identification of every other person they know. For example, if an API consumer requests information for their user account and receives information about other user accounts as well, the API is exposing excessive data. Check out the written content for an example of an excessive data exposure vulnerability. Excessive Data Exposure is an API vulnerability that is very difficult to detect with automated scanners. In addition, this vulnerability will often bypass every security control in place to protect sensitive information and hand sensitive data to an attacker simply because they use the API. To detect excessive data exposure API providers must test API endpoints and review the information sent in the response. Mass Assignment occurs when an API consumer includes more parameters in its request than the application intended, and the application adds these parameters to code variables or internal objects. In this situation, a consumer may be able to edit object properties or escalate the privileges. For example, an application might have an account update functionality that the user should use only to update their username, password, and address. If the consumer can include additional parameters in the request related to their account, such as the account privilege level, or sensitive information like an account balance, and the application accepts those parameters without checking them against the whitelist of permitted actions, the consumer could take advantage of this weakness to change these values. Imagine an API is called to create an account with parameters for user and password. The user could be hapi_hacker, password could be GreatPassword123. While reading the API documentation regarding the account creation process, an attacker could discover that there's an additional property, which is an admin that the API provider uses to create administrative accounts. An attacker could add this to a request and set the value to "true". If the API does not sanitize the request input, it is vulnerable to Mass Assignment and attacker could use the request to create their own admin account. On the backend the vulnerable web app will add the key value attribute {“isAdmin” true} to the user object, and make the user the equivalent of an administrator for that application. The OWASP Preventative Measures state when exposing an object using an API endpoint, always make sure that the user should have access to the object properties you expose. Avoid using generic methods such as to_json() and to_string(). Instead, cherrypick specific object properties you specifically want to return. If possible, avoid using functions that automatically bind to client's input into code variables, internal objects or object properties. Allow changes only to the object's properties that should be updated by the client. Implement a schema based response validation mechanism as an extra layer of security. As part of this mechanism, define and enforce data returned by all API methods. Keep return data structures to the bare minimum according to the business functional requirements for the endpoint. Check out the written course content for additional resources about BOPLA. API42023 Unrestricted Resource Consumption is an API issue where the provider of the API does not have safeguards in place to prevent excessive use of their API. When there are no restrictions for resource consumption, the API provider could become a victim of a denial of service, attack, or experience, unnecessary financial costs. Unrestricted Resource Consumption is an updated version of API42019, Lack of Resources and Rate Limiting. The OWASP Attack Vector description states exploitation requires simple API requests. Multiple concurrent requests can be performed from a single local computer or by cloud computing resources. Most of the automated tools available are designed to cause denial of service via high loads of traffic impacting API service rate. The OWASP Security Weakness description states it's common to find APIs that do not limit client interactions or resource consumption. Crafted API requests such as those, including parameters that control the number of resources to be returned and performing response status, time length analysis, should allow identification of the issue. The same is valid for batched operations, although threat agents don't have visibility over costs impact, this can be inferred based on the service provider's business. OWASP Impacts Description states exploitation can lead to denial of service due to resource starvation, but it can also lead to operational cost increase, such as those related due to the infrastructure due to higher CPU demand, increasing cloud storage needs, etc. The OWASP API Security project states an API is vulnerable if at least one of the following limits is missing or set inappropriately, either too low or too high. Execution timeouts, maximum allocable memory, maximum number of file descriptors, maximum number of processes, maximum upload file size number of operations to perform in a single API client request with things like GraphQL batching, number of records per page to return in a single request response, and third party service provider spending limit. Every API request has a technical and financial cost when API providers do not enforce limitations on resource consumption, there's an increased risk of denial of service, distributed denial of service, unnecessary financial costs, and degradation of the quality of service to other users. In addition rate limiting plays an important role in the monetization and availability of APIs. Many API providers monetize their APIs by limiting requests and allowing paid customers to request more information. RapidAPI, for example, allows some API providers to also have infrastructure that automatically scales with the number of API requests. In these cases, an unlimited number of requests would lead to a significant and easily preventable increase in infrastructure costs. The OWASP Preventative Measures states Docker makes it easy to limit memory, CPU, number of restarts, file descriptors and processes. Implement a limit on how often a client can call the API within a defined timeframe. Notify the client when the limit is exceeded by providing the limit number and the time at which the limit will be reset. Add proper server side validation for query string and request body parameters, specifically the one that controls the number of records to be returned in the response. Define and enforce maximum size of data on all incoming parameters and payloads, such as maximum length for strings and maximum number of elements in arrays. Check out the written course content for additional resources about Unrestricted Resource Consumption. API52023, Broken Function Level Authorization, or BFLA, is a vulnerability where API functions have insufficient access controls. Where BOLA is about access to data, BFLA is about altering or deleting that data. In addition, a vulnerable API would allow an attacker to perform actions of other roles, including administrative actions. To drive the point home, a fintech API susceptible to BOLA would allow an attacker the ability to see what is in the bank account of another user, while the same API vulnerable to BFLA would allow an attacker to transfer funds from other users accounts to their own. The OWASP Attack Vector description states "exploitation requires the attacker to send legitimate API calls to an API endpoint that they should not have access to as an anonymous user or regular non privileged user. exposed endpoints will be easily exploited." The OWASP Security Weakness description states "authorization checks for a function or resource are usually managed via configuration or code level. Implementing proper checks can be a confusing task since modern applications can contain many types of roles, groups, and complex user hierarchies. It's easier to discover these flaws in APIs since APIs are more structured, and accessing different functions is more predictable." The OWASP Impacts Description states "such flaws allow attackers to access unauthorized functionality. Administrative functions are key targets for this type of attack and may lead to data disclosure, data loss, or data corruption. Ultimately, it may lead to service disruption." Broken Function Level Authorization, or BFLA, is a vulnerability where a user of one privilege level can use the API functionality of a different user, user group, or another privilege level. API providers will often have different privilege levels for different types of accounts, such as public users, merchants, partners, vendors, administrators, and so on. BFLA can be exploited for unauthorized use of lateral functions or a similarly privileged group, or it could be exploited for privilege escalation, where an attacker can use the functions of a more privileged group. Particularly interesting API functions to access include those that deal with sensitive information, resources that belong to another group, and administrative functionality, like user account management. If an API has different privilege levels, it may use different endpoints to perform those privileged actions. For example, a bank may use /{userid}/account/balance as an endpoint for a user wishing to access their account information, and then use /admin/account/{userid} as an endpoint for an administrator that needs to access user account information. If the application does not have access controls implemented correctly, an attacker will be able to perform administrative actions and perform an account takeover. An API won't always use administrative endpoints for administrative functionality. Instead, the functionality could be based on different HTTP request methods like GET, POST, PUT, and DELETE. If a provider doesn't restrict the HTTP methods, or verbs, an attacker can use simply making an unauthorized request with a different method, could indicate a BFLA vulnerability. When testing for BFLA, look for any functionality that an attacker could use to their advantage. These functions include, but are not limited to, altering user accounts, deleting user resources, and gaining access to restricted endpoints. For example, if an API gave partners the ability to add new users to the partner group, but did not restrict this functionality to the specific group, any user could add themselves to any group. Moreover, if an attacker added themselves to a group, there's a good chance that there'll be able to access that group's sensitive resources. Take a look at the written course content for an example of a BFLA attack. The OWASP Preventative Measures state "your application should have a consistent and easy to analyze authorization module that is invoked from all your business functions. Frequently, such protection is provided by one or more components external to the application code. The enforcement mechanisms should deny all access by default, requiring explicit grants to specific roles for access to every function. Review your API endpoints against function level authorization flaws, while keeping in mind the business logic of the application and group's hierarchy. Make sure that all of your administrative controllers inherit from an administrative abstract controller that implements authorization checks based on the user's group or role. Make sure that administrative functions inside a regular controller implement authorization checks based on the user's group and role." Check out the written course content for additional resources about Broken Function Level Authorization. API62023, Unrestricted Access to Sensitive Business Flows represents the risk of an attacker being able to identify and exploit API driven workflows. If vulnerable an attacker will be able to leverage an organization's API request structure to obstruct other users. This obstruction could come in the form of spamming other users, depleting the stock of highly sought after items, or preventing other users from using expected application functionality. This is a new addition to the 2023 top 10 list. The OWASP Attack Vector description states "exploitation usually involves understanding the business model backed by the API, finding sensitive business flows, and automating access to these flows, causing harm to the business." The Security Weakness description states "lack of a holistic view of the API in order to fully support business requirements tends to contribute to the prevalence of this issue. Attackers manually identify what resources or endpoints are involved in the target workflow and how they work together. If mitigation mechanisms are already in place, attackers need to find a way to bypass them." The OWASP Impacts Description states "in general, technical impact is not expected. Exploitation might hurt the business in different ways. For example, prevalent legitimate users from purchasing a product or lead to an inflation in the internal economy of a game. Regarding APIs, a flow is a series of requests and responses that lead to an operation. If, for example, a purchase flow for a web application does not restrict access to a purchase process, then a scalper could automate requests to instantly drain the stock of an item down to nothing. This is where mechanisms like a completely automated public Turing test to tell computers and humans apart, or better known as CAPTCHA, comes into play. If a flow has a capture mechanism that requires human interaction, then the automated request could be interrupted and slow down automated purchasing. Check out the written course material for an example API flow used to help build a notification bot for the PS5. Customers and or scalpers competing to purchase the PS5 would use API flows to either complete purchases as soon as new stock was available or alert upon stock updates. In the example, an API flow was used to automatically check for stock updates and send out email alerts. The OWASP Preventative Measures state the mitigation planning should be done in two layers, business and engineering. Business should identify the business flows that might harm the business if they are excessively used. Engineering should choose the right protection mechanism to mitigate the business risk. Some of the protection mechanisms are more simple while others are more difficult to implement. The following methods are used to slow down automated threats. Device fingerprinting. Deny service to unexpected client devices, tends to make threat actors use more sophisticated solutions, thus more costly for them. Next up is human detection using either CAPTCHA or more advanced biometric solutions. Non human patterns. Analyze the user flow to detect non human patterns. For example, the user accessed the add to cart and complete purchase functions in less than one second. Consider blocking IP addresses of Tor exit nodes and well known proxies. Secure and limit access to APIs that are consumed directly by machines. They tend to be an easy target for attackers because they often don't implement all the required protection mechanisms. Check out the written course content for additional resources about unrestricted access to sensitive business flows. API72023, Server Side Request Forgery is a vulnerability that takes place when a user is able to control the remote resources retrieved by an application. An attacker can use an API to supply their own input in the form of a URL to control the remote resources that are retrieved by the targeted server. An attacker could supply URLs that expose private data, scan the target's internal network, or compromise the target through remote code execution. SSRF is also number 10 on the 2021 OWASP Top 10 List and is a growing threat to APIs. The OWASP Attack Vector description states "exploitation requires the attacker to find an API endpoint that accesses a URI that's provided by the client. In general, basic SSRF, when the response is returned by the attacker, is easier to exploit than blind SSRF, in which the attacker has no feedback on whether or not the attack was successful." The OWASP Security Weakness description states "modern concepts in application development encourages developers to access URIs provided by the client. Lack of, or improper validation of such URIs are common issues. Regular API requests and response analysis will be required to detect the issue. When the response is not returned, detecting the vulnerability requires more effort and creativity." The OWASP Impacts Description states "successful exploitation might lead to internal services enumeration, information disclosure, bypassing firewalls, or other security mechanisms. In some cases, it can lead to denial of service or the server being used as a proxy to hide malicious activities." SSRF is a vulnerability that takes place when an application retrieves remote resources without validating user input. When an attacker has control over the resources a server requests, then they can gain access to sensitive data, or worse, completely compromise a vulnerable host. The impact of this vulnerability is that an attacker would be able to leverage a target server to perform and process requests that they supply. Note that bug bounty payouts for SSRF are driven based on the impact that can be demonstrated with a proof of concept. The higher the demonstrated impact, the higher the bounty. There are two general types of SSRF that are worth noting. InBand SSRF and OutofBand SSRF, also known as Blind SSRF. InBand SSRF means that the server responds with the resources specified by the end user. If the attacker specifies a payload such as google.com to a server with an InBand SSRF vulnerability, the server would make the request to google.com and then respond to the attacker with information served from google.com. Blind SSRF takes place when the attacker supplies a URL and the server makes the request, but the server does not send the information back from that specified URL to the attacker. In the case of blind SSRF, an attacker would need control over a web server that would capture the request from the target as proof that they were able to force the server to make this request. In the course InBand SSRF example, an attacker makes a request that includes a URL. That will be used to update the stock of an item in the store. The attacker is able to replace that item stock URL with a local host URL to a directory with a password. The server is vulnerable and provides the password back to the attacker. Blind SSRF takes place when a vulnerable server performs a request from user input, but does not send back the response to the attacker indicating a successful attack. In other words, the victim server makes the request to the URL specified by the attacker, but the attacker does not receive a direct message back from the victim server. In this case, to know if the request was made, an attacker will need to have some control over the web server that is specified in the attack. For examples and demonstrations of InBand and OutofBand SSRF attacks check out the written course material. The OWASP Preventative Measure states "isolate the resource fetching mechanism in your network. Usually these features are aimed to retrieve remote resources and not internal ones. Whenever possible, use allow lists of remote origins users are expected to download resources from, such as Google Drive or Gravatar, URL schemes and ports, accepted media types for a given functionality. Disable HTTP redirections. Use a well tested and maintained URL parser to avoid issues caused by URL parsing inconsistencies. Validate and sanitize all client supplied input data. Do not send raw responses to clients." Check out the written course content for additional resources about SSRF. API82023, Security Misconfiguration represents a catchall for many vulnerabilities related to the systems that host APIs. When an API's security is misconfigured, it can be detrimental to the confidentiality, integrity, and availability of the API provider's data. Due to the wide variety of flaws that could exist, the impacts of an exploited security misconfiguration can range from information disclosure to data breach. The OWASP Attack Vector description states "attackers will often attempt to find unpatched flaws, common endpoints, or unprotected files and directories to gain unauthorized access or knowledge of the system." The OWASP Security Weakness description states "security misconfiguration can happen at any level of the API stack from the network level to the application level. Automated tools are available to detect and exploit misconfiguration such as unnecessary services or legacy options." The OWASP Impacts Description states "security misconfigurations can not only expose sensitive user data, but also system details that can lead to full server compromise." Security misconfigurations include all the mistakes that API providers can make within the supporting systems of an API. Security misconfigurations are really a set of weaknesses that include misconfigured headers, misconfigured transit encryption, the use of default accounts, the acceptance of unnecessary HTTP methods, a lack of input sanitization, and verbose error messaging. For example, if the API supporting security configuration reveals an unpatched vulnerability. There's a chance that an attacker could leverage a published exploit to easily pwn the API and its systems. A lack of input sanitization could allow attackers to upload malicious payloads to the server. APIs often play a key role in automating processes, so imagine being able to upload payloads that the server automatically processes into a format that could be remotely executed or executed by an unsuspecting end user. For example, if an upload endpoint was used to pass uploaded files to a web directory, then it could allow the upload of a script. Navigating to the URL where the file is located could launch the script resulting in direct shell access to the web server. Additionally, a lack of input sanitization can lead to unexpected behavior on the part of the application. API providers use headers to provide the consumer with instructions for handling the response and security requirements. Misconfigured headers can result in sensitive information disclosure, downgrade attacks, and cross site scripting attacks. Many API providers will use additional services alongside their API to enhance API related metrics or to improve security. It's fairly common that those additional services will add headers to requests for metrics and perhaps as some level of assurance to the consumer. The XPoweredBy header reveals back end technology. Headers like this one often advertise the exact supporting service and its version. An attacker could use information like this to search for exploits published for that version of software. The XXSSProtection header is exactly what it sounds like, a header that's meant to prevent crosssite scripting (XSS) attacks. Cross site scripting is a common type of injection vulnerability where an attacker could insert scripts into a web page and trick end users into clicking on malicious links. A XXSSProtection header with a value of 0 indicates no protections in place, and a value of 1 indicates that the protection is turned on. This header and others like it, clearly reveals whether or not a security control is in place. The XResponseTime header is middleware that provides the usage metrics. In this example, in the written course material, its value represents 566 milliseconds. But if the API isn't configured properly, this header can function as a side channel used to reveal existing resources. If the XResponseTime header has a consistent response time for non existing records, for example, but increases its response time for certain other records that actually exist, this could be an indication to an attacker that they've come across these files. Say, for instance, an attacker can determine that a bogus account like /user/account/thisdefinitelydoesnotexist has an average response time of 25 milliseconds. The attacker can know that their existing account is /user/account/1021, which receives an XResponseTime of 510 milliseconds. An attacker could then send requests brute forcing account numbers and review the results and see which account numbers resulted in drastically increased response times. Any API providing sensitive information to consumers should use Transport Layer Security to encrypt the data even if the API is only provided internally, privately, or at a partner level. Transport Layer Security, the protocol that encrypts HTTPS traffic, is one of the most basic ways to ensure that API requests and responses are protected when being passed across a network. Misconfigured or missing transit encryption can cause API users to pass sensitive API information in clear text across networks, in which case an attacker could capture the responses and requests with a ManintheMiddle (MITM) and read them plainly. They would simply have to intercept the network traffic with a network protocol analyzer like Wireshark to see the information being communicated between a consumer and a provider. When a service uses default accounts or credentials, and the defaults are known, an attacker can use those credentials to assume the role of that account. This could allow them to gain access to sensitive information or administrative functionality and potentially lead to a compromise of the supporting systems. Lastly, if an API provider allows unnecessary HTTP methods, there's an increased risk that the application won't handle these methods properly or will result in sensitive information disclosure. Out of all the vulnerabilities covered on the OWASP Top 10, API82023 Security Misconfiguration is one of the only ones that can be detected by web application vulnerability scanners. Automated scanners like BurpSuite, Nessus, Qualys, OWASP, ZAP, and Nikto will automatically check responses from the web server to determine the version information, headers, cookies, transit encryption configuration, and parameters to see if expected security measures are missing. Security misconfigurations can also be checked manually if you know what you're looking for, by inspecting the headers, SSL certificate, cookies, and parameters. The OWASP Preventative Measures states the API lifecycle should include repeatable hardening process leading to a fast and easy deployment of a properly locked out environment, a task to review and update configurations across the entire API stack. The review should include orchestration files, API components and cloud services and automated process to continuously assess the effectiveness of the configuration and settings in all environments. Furthermore, ensure that all API communications from the client to the API server And any downstream upstream components happen over an encrypted communication channel, regardless of whether it is an internal or public facing API. Be specific about which HTTP verbs each API can be accessed by. All other HTTP verbs should be disabled. API's expecting to be accessed from browser based clients should at least implement a proper Cross Origin Resource Sharing (CORS) policy. Include applicable security headers, restrict incoming content types/data formats to those that meet the business functional requirements. Ensure all servers in the HTTP server chain process incoming requests in a uniform manner to avoid desync issues. Where applicable, define and enforce all API response payload schemas, including error responses to prevent exception traces and other valuable information from being sent back to an attacker. Check out the written course content for additional resources about API security misconfigurations. API92023, Improper Inventory Management represents the risks involved with exposing non production and unsupported API versions. When this is present, the non production and unsupported versions of the API are often not protected by the same security rigor as the production versions. This makes improper inventory management a gateway to other API security vulnerabilities. The OWASP Attack Vector description states "Threat agents usually get unauthorized access through old API versions or endpoints left running unpatched and using weaker security requirements. Alternatively, they may get access to sensitive data through a third party with whom there's no reason to share data with." The OWASP Security Weakness description states "Outdated documentation makes it more difficult to find and or fix vulnerabilities. Lack of assets, inventory, and retirement strategies leads to running unpatched systems, resulting in leakage of sensitive data. It's common to find unnecessarily exposed API hosts because of modern concepts like microservices, which makes applications easy to deploy and independent. Simple Google Dorking, DNS enumeration, or using specialized search engines for various types of servers connected to the internet will be enough to discover targets." The OWASP Impacts description states "Attackers can gain access to sensitive data or even take over the server. Sometimes different API version deployments are connected to the same database with real data. Threat agents may exploit deprecated endpoints available to in old API versions to get access to administrative functions or exploit known vulnerabilities." Improper Inventory Management takes place when an organization exposes APIs that are unsupported or still in development. As with any software, old API versions are more likely to contain vulnerabilities because they are no longer being patched and upgraded. Likewise, APIs that are still being developed and are typically not as secure as their production API counterparts. Improper inventory management can lead to other vulnerabilities such as excessive data exposure, information disclosure, mass assignment, improper rate limiting, and API injection. For attackers, this means that discovering an improper inventory management vulnerability is only the first step toward further exploitation of an API. Detecting Improper Inventory Management can be tested by using outdated API documentation, changelogs, and version history on repositories. For example, if an organization's API documentation has not been updated along with the API's endpoints, it could contain references to portions of the API that are no longer supported. Organizations often include versioning information in their endpoints names to distinguish between older and newer versions. Such as /v1/, /v2/, or /v3/ and so on. APIs still in development often use paths such as /alpha/, /beta/, /test/, /uat/ and /demo/. If you know that an API is now using apiv3.org/admin, but a part of the API documentation refers to apiv1.org/admin, you could try testing different endpoints to see if apiv1 or apiv2 are still active. Additionally, the organization's change log may disclose the reasons why v1 was updated or retired. If an attacker has access to v1, they can test those for weaknesses. Outside of using documentation, an attacker could discover improper inventory vulnerabilities through the use of guessing, fuzzing, or brute forcing requests. Testing for improper assets management is all about discovering unsupported and non production versions of an API. API providers will often update services and the newer version of the API in a variety of ways, such as api.target.com/v3, or /api/v2/accounts, or /api/v3/accounts. API versioning could also be maintained as a header. So you could see something like Accept version=2.0, or Accept apiversion=3. In addition, versioning could also be set within a query parameter or the request body. So you could see /api/accounts?ver=2. Or POST to API accounts with the versioning equals 1.0. Non production versions of an API include any version of the API that was not meant for end user consumption. Non production versions could include api.test.target.com, beta.api.com, /api/private, /api/partner or /api/test. In these instances, earlier versions of the API may no longer be patched or updated since the older versions lack this support. They may expose the API to additional vulnerabilities and lead an attacker to a path that can be used to compromise the provider's data. The OWASP Preventative Measures states inventory all API hosts and document important aspects of each one of them, focusing on the API environment, such as production, staging, test or development, who should have network access to the host, such as public, internal or partners and the API version inventory integrated services and document important aspects, such as their role in the system, what data is exchanged and its sensitivity. Document all aspects of your API, such as authentication, errors, redirects, rate limiting, cross origin resource sharing, CORS policy, and endpoints, including their parameters, requests, and responses. Generate documentation automatically by adopting open standards. Include the documentation built in your CI/CD pipeline. Make API documentation available to those authorized to use the API. Use external protection measures, such as an API security firewall, for all exposed versions of your APIs. Not just for the current production versions. Avoid using production data with non production API deployments. If this is unavoidable, these endpoints should get the same security treatment as the production ones. When newer versions of the API include security improvements, perform risks analysis, risk analysis to make the decision of the mitigation actions required for the older version. For example, whether it is possible to backport the improvements without breaking API compatibility, or you need to take the older version, but quickly enforce all clients to move to the latest version. For additional resources about improper inventory management, check out the written course materials. API102023, Unsafe Consumption of APIs is the only item on the Top 10 list that focuses less on the risks of being an API provider and more on the risks of being an API consumer. Unsafe consumption is really a trust issue. When an application is consuming the data of a third party API, it should treat those with a similar trust to user input. By that, I mean there should be little to no trust. So data consumed from third party API should be treated with similar security standards as end user supplied input. If a third party API provider is compromised, then that insecure API connection back to the consumer becomes a new attack vector for the attacker to leverage. In the case of an insecure API connection, that could mean the complete compromise of organizations insecurely consuming data from that API provider. The OWASP Attack Vector description states "exploiting this issue requires attackers to identify and potentially compromise other APIs or services the target API is integrated with. Usually this information is not publicly available or the integrated API or service is not easily exploitable." The OWASP Security Weakness description states "developers tend to trust and not verify the endpoints that interact with external or third party APIs relying on weaker security requirements such as those regarding transport security, authentication, authorization, and input validation and sanitization. Attackers need to identify services the target API interacts with or integrates with and eventually compromise them." The OWASP Impacts description states "the impact varies according to what the target API does with pooled data. Successful exploitation may lead to sensitive information exposure to unauthorized actors, many kinds of injections, or denial of service." Most of the 2023 API Security Top 10 is about APIs and the API provider. An API can often serve as the path of least resistance for an attacker. So if an attacker compromises a third party API provider, then that third party's connection to other businesses can become an additional attack vector. If that API is over an unencrypted connection, then an attacker would be able to capture sensitive data in clear text. If that third party API isn't held to similar security standards as internet facing APIs, then it could also be vulnerable to injection, authorization, authentication and other compromising attacks. The OWASP Preventative Measure states when evaluating service providers assess their API security posture. Ensure all API interactions happen over a secure communication channel. Always validate and properly sanitize data received from integrated APIs before using it. Maintain and allow a list of well known locations integrated APIs may redirect yours to. Do not blindly follow redirects. For additional Resources about unsafe consumption of APIs, check out the written course materials. Injection vulnerabilities have plagued web applications for over two decades. They take place when an attacker can send commands that are executed by the systems that support the web application. The most common forms of injection attacks are SQL injection, cross site scripting, and operating system command injection. APIs are yet another attack vector for these critical attacks to be communicated from an attacker to the supporting system, supporting databases and systems. The OWASP 2019 Attack Vector description states, "attackers will feed the API with malicious data through whatever injection vectors are available, such as direct input parameters, integrated services, expecting it to be sent to an interpreter." The OWASP 2019 Security Weakness description states, "injection flaws are very common and are often found in SQL, LDAP, or NoSQL queries, OS commands, XML parsers, and ORM. These flaws are easy to discover when reviewing the source code. Attackers can use scanners and fuzzers to find these." The OWASP 2019 Impacts Description states, Injection can lead to information disclosure and data loss and may also lead to denial of service or complete host takeover. Injection flaws exist when a request is passed to the API supporting infrastructure and the API provider doesn't filter the input to remove unwanted characters. As a result, the infrastructure might treat the data from the request as code and run it. When this sort of flaw is present, an attacker will be able to conduct injection attacks like SQL injection, NoSQL injection, and system command injection. When these injection attacks are successful, the API delivers an unsanitized payload directly to the operating system running the application or a query to its database. As a result, if an attacker sends a payload containing SQL commands to a vulnerable API that uses a SQL database, the API will pass the commands to the database, which will process and perform the commands. The same will happen with vulnerable NoSQL databases and affected systems. Verbose error messaging, HTTP response codes, and unexpected API behavior can all be clues to an attacker and will be an indication that they have discovered an injection flaw. Say, for example, an attacker were to send OR1 00 DAS as an address in an account registration process. The API may pass that payload directly back to the back end SQL database, where the or 1 equals 0 statement, which would fail as 1 does not equal 0, causing a SQL error. An error in the backend database could show up as a response to the consumer. In this case, the attacker, who's the consumer, might receive a response like, Error equals you have an error in your SQL syntax. But, any response directly from the database or the supporting system will serve as a clear indicator that there's likely an injection vulnerability. Injection vulnerabilities are often complemented by other weaknesses like poor input sanitization. Injection flaws can have serious impacts by providing an attacker with the ability to manipulate an API supporting system or database. Finding injection flaws requires diligently testing API endpoints and paying attention to how the API responds, then crafting requests that attempt to manipulate the backend systems. Injection attacks have been around for decades, so there are many standard security controls that can be used to protect API providers from them. The OWASP 2019 Preventative Measures states, Preventing injection requires keeping data separate from commands and queries. Perform data validation using a single trustworthy and actively maintained library. Validate, filter, and sanitize all client provided data or other data coming from integrated systems. Special characters should be escaped using the specific syntax for the target interpreter. Prefer a safe API that provides parameterized interface. Always limit the number of returned records to prevent mass disclosure in case of injection. Validate incoming data using sufficient filters to only allow valid values for each input parameter. Define data types and strict patterns for all string parameters. For additional resources about API injection, check out the written course content. Logging and Monitoring are a necessary and important layer of API security. In order to detect an attack against an API, an organization must have monitoring in place. Without sufficient logging and monitoring, an API provider is operating in the dark, and API attacks are guaranteed to go unnoticed until it's far too late. The OWASP 2019 Attack Vector description states, "Attackers take advantage of a lack of logging and monitoring to abuse systems without being noticed." The OWASP 2019 Security Weakness description states, "Without logging and monitoring, or insufficient logging and monitoring, it is almost impossible to track suspicious activities and respond to them in a timely fashion." The OWASP 2019 Impacts description states, "Without visibility over ongoing malicious activities, attackers have plenty of time to fully compromise systems. Logs can reveal patterns in API usage and can be used as evidence to understand how an API is abused. Logging and monitoring provide an audit trail of activities and are often required for compliance purposes." An important part of logging is to ensure that the logs have integrity and cannot be altered by an attacker. Monitoring an API will help providers detect suspicious activities and anomalous user behavior. This helps providers be able to take action to thwart attacks. Logging and monitoring are essential for improving API performance and security. The OWASP 2019 Preventative Measures states, log all failed authentication attempts, denied access, and input validation errors. Logs should be written using a format suited to be consumed by a log management solution and should include enough detail to identify the malicious actor. Logs should be handled as sensitive data and their integrity should be guaranteed at rest and transit. Configure a monitoring system to continuously monitor the infrastructure network and API functioning. Use a SIEM system to aggregate and manage logs from all components of the API stack and hosts. Configure custom dashboards and alerts enabling suspicious activities to be detected and responded to earlier. For additional resources about insufficient logging and monitoring, check out the written course content. Business logic vulnerabilities are weaknesses within applications that are unique to the policies and features of a given API provider. The exploitation of business logic takes place when an attacker leverages misplaced trust or features of an application against the API. Identifying business logic vulnerabilities can be challenging due to the unique nature of each business. The impact of these vulnerabilities can range based on the severity of the vulnerable policy or feature. My attack vector description for this Business logic vulnerabilities are unique to each application and exploit the normal intended functioning of an application's business processes. They often require specific knowledge of the application's functionality and the flow of transactions or data. Since these vulnerabilities are specific to the business logic of each application, there's no one size fits all approach to identifying them. My security weakness description states, business logic vulnerabilities arise when the assumptions and constraints of a given business process aren't properly enforced in the application's control structures. This allows users to manipulate the application's functionality to achieve outcomes that are detrimental to the business. These weaknesses typically occur when developers fail to anticipate the various ways that an application's features can be misused or when they don't consider the wider context of the business rules. This is often due to a lack of comprehensive understanding of the application's business logic, a lack of input validation, or incomplete function level authorization checks. My impacts description states Business logic vulnerabilities can cause a variety of technical impacts depending on the specific flaw in the systems involved. These impacts can range from unauthorized access to data or functionality to a total bypass of system controls. Business logic vulnerabilities, also known as business logic flaws, or BLFs, are intended features of an application that attackers can use maliciously. For example, if an API has an upload feature that instructs users to only upload certain encoded payloads, but doesn't actually validate those encoded payloads, a user could upload any file as long as it was encoded. This would allow end users to upload and potentially execute arbitrary code, including malicious payloads. Vulnerabilities of this sort normally come about from an assumption that API consumers will follow directions, be trustworthy, or only use the API in a certain way. In those cases, the organization essentially depends on trust as a security control by expecting the consumer to act benevolently. Unfortunately, even good natured API consumers make mistakes that could lead to a compromise of the application. The Experian partner API leak in 2021 was a great example of an API trust failure. A certain Experian partner was authorized to use Experian's API to perform credit checks, but the partner added the API's credit check functionality to their web application and inadvertently exposed all partner level requests to users. This request could be intercepted when using the partner's web application, and if it included a name and address, the Experian API would respond with the individual's credit score and credit risk factors. One of the leading causes of this business logic vulnerability was that the Experian trusted the partner to not expose the API. Another problem with trust is that credentials like API keys, tokens, and passwords are constantly being stolen and leaked. When a trusted consumer's credentials are stolen, the consumer can become a wolf in sheep's clothing and wreak havoc. Without strong technical controls in place, business logic vulnerabilities can often have the most significant impact leading to exploitation and compromise. An API's documentation can be a telltale sign of a business logic vulnerability. Statements like the following should be indications of potential business logic flaws. Only use feature x to perform function y. Do not do x with endpoint y. Only admins should perform request X. These statements may indicate that the API provider is trusting that end users won't do any of the discouraged actions as instructed. An attacker will easily disobey such requests to test for the presence of technical security controls. Another business logic vulnerability comes about when developers assume that consumers will exclusively use a browser to interact with the web application and won't capture API requests that take place behind the scenes. All it takes to exploit this sort of weakness is for an attacker to intercept requests and alter the API request before it is sent to the provider. This would allow the attacker to capture shared API keys or use parameters that could negatively impact the security of the application. As an example, consider a web app authentication portal that a user normally would employ to authenticate to their account. Say the web application issued an API authentication request that included the username and password along with a query parameter, multi factor equals true. There's a chance that an attacker could bypass the multi factor authentication by simply altering the parameter to false. Testing for business logic flaws can be challenging because each business is unique. Automated scanners will have a difficult time detecting these issues, as the flaws are part of the API's intended use. You must understand how the business and API operate, and then consider how an attacker could use these features to their advantage. One method of testing for business logic flaws is to study the application's business logic with an adversarial mindset and try breaking any assumptions that have been made. My preventative measures for business logic flaws include the following. Use a threat modeling approach. Understand the business processes and workflows your API supports. Identify the potential threats, weaknesses, and risks during the design phase that can help to uncover and mitigate business logic vulnerabilities. Reduce or remove trust relationships with users, systems, or components. Business logic vulnerabilities can be used to exploit these trust relationships leading to a broader impact. Regular training can help developers to understand and avoid business logic vulnerabilities. Training should cover secure coding practices, common vulnerabilities, and how to identify potential issues during design and coding phases. Implement a bug bounty program, third party penetration testing, or responsible disclosure policy. This allows security researchers who are a step removed from the design and delivery of an application to disclose vulnerabilities they discover in APIs. For additional resources about business logic vulnerabilities, check out the written course material. And that wraps up the OWASP API security top 10 and beyond course. Hope you enjoyed it. And if you'd like to earn a badge and certificate for this course, please enroll at apisecuniversity.com, take the quizzes, and we'll be happy to issue your cert. And while you're there, be sure to check out our other courses, including API Pen Testing, API Security Fundamentals, and more. We also host many webinars with API experts across industries, disciplines, and geographies. You'll see these listed on our website and on our YouTube channel. Please subscribe. Thanks for watching, and hope to see you again soon.
