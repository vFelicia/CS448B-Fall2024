With timestamps:

00:00 - learn the foundational elements of a
00:02 - microservices architecture with net by
00:05 - building a real microservices-based
00:07 - application
00:08 - julio is an excellent teacher and has
00:10 - created many popular.net courses
00:14 - welcome to
00:15 - buildingmicroserviceswith.net the basics
00:18 - my name is julio gasal and i'll be your
00:20 - instructor through these first steps in
00:22 - your mac services learning journey with
00:24 - the.net platform
00:26 - before we move on to learn about
00:28 - microservices i'd like to walk you
00:30 - through the fictional client application
00:32 - that drives the requirements for the
00:33 - backend system that you will build the
00:36 - high level architecture of the system
00:38 - and the technology stack that will be
00:39 - used across this course
00:43 - let's imagine a video game where the
00:45 - player will need to acquire a series of
00:47 - items to stay healthy become stronger
00:50 - and survive the multiple changes that
00:52 - await him in his adventures
00:54 - there will be a series of stores that
00:56 - will allow the player to purchase items
00:58 - like potions antidotes and even source
01:01 - and shields
01:03 - these items have a price
01:05 - to purchase them the player will need to
01:07 - present the right amount of some sort of
01:09 - currency that we will just call jill
01:13 - once the player successfully purchases
01:14 - an item it then goes into his inventory
01:17 - back where it will be available for him
01:19 - whenever he needs it
01:21 - now the client side of this game
01:24 - the app that runs in the player's device
01:26 - is already being built by your company's
01:28 - client team so you don't have to worry
01:30 - about it and in fact this client app is
01:32 - not part of this course
01:34 - our team has been chartered with
01:36 - building the backend services for this
01:38 - game
01:39 - which the client will heavily depend on
01:41 - to be able to store the items catalog
01:43 - the player's deal and inventory and to
01:45 - enable the in-game purchase experience
01:49 - let's now look at the high-level
01:50 - architecture of the
01:52 - system support the client applications
01:55 - the following microservices-based
01:57 - architecture has been designed
01:59 - at the core we have identified four
02:01 - microservices
02:02 - catalog which owns the list of items
02:04 - available for purchase
02:07 - inventory which keeps track of the
02:08 - quantity of items that a player owns
02:11 - identity which manages the list of
02:13 - players and also acts as an identity
02:15 - provider
02:17 - and trading which owns the purchase
02:19 - process that can grant inventory items
02:21 - in exchange for jill
02:23 - each of these services have their own
02:25 - database that has no relationship with
02:27 - other databases and that are of
02:29 - exclusive use by the owning service
02:32 - for inter-service communication the
02:34 - system makes use of a message broker
02:36 - which allows the services to collaborate
02:38 - by polishing and consuming messages
02:40 - asynchronously
02:41 - for the clients to interact with the
02:42 - microservices this architecture has an
02:45 - api gateway which provides a lot of
02:47 - flexibility to make changes to the
02:49 - services without impacting the clients
02:51 - and lets the services focus on their
02:53 - business while delegating multiple
02:55 - cross-cutting concerns to the gateway
02:57 - there is also a front-end portal that
03:00 - enables the administration of the items
03:02 - catalog the players and the inventory
03:04 - and it also includes a store section
03:06 - where players can purchase items
03:08 - finally there are a few infrastructure
03:10 - components like logging distributed
03:13 - tracing and monitoring that all
03:15 - microservices can interact with and that
03:18 - can greatly help to troubleshoot issues
03:20 - and make sure the whole system remains
03:22 - healthy
03:23 - now there are a lot of topics to cover
03:25 - to implement this system so in this
03:27 - course the basics we will focus on the
03:30 - most fundamental parts related to
03:31 - microservices collaboration
03:33 - in that sense you will implement only
03:35 - the catalog and inventory microservices
03:37 - using.net and asp.net core
03:40 - and you will use mongodb to host a
03:42 - non-sql database for each service
03:44 - you will initially explore how the
03:46 - services can communicate synchronously
03:48 - via res and http
03:50 - but later you will stand up a rabbit
03:52 - enqueue message broker that will allow
03:54 - all services to communicate
03:55 - asynchronously by publishing and
03:57 - consuming messages via the mass transit
03:59 - distributed application framework
04:02 - that will give you a solid understanding
04:04 - of how to get started with microservices
04:06 - and net and how to tackle the multiple
04:08 - challenges of getting the services to
04:10 - collaborate in a resilient way
04:12 - the frontend portal is placed on the
04:14 - react ui framework
04:15 - you won't be coding this portal but you
04:17 - will get access to all this source code
04:19 - so you can build and run it in your box
04:21 - and use it to see how real and modern
04:23 - client can take advantage of your
04:25 - microservices
04:27 - also you will run all infrastructure
04:29 - services like mongodb and revit queue
04:31 - via docker containers which is the best
04:34 - way to get things up and running in your
04:35 - box very quickly
04:37 - at the end of this course i will point
04:39 - you to the next steps so you can
04:40 - continue your journey by implementing
04:42 - the rest of the system
04:44 - in the next lesson you will download and
04:46 - install the first set of tools that you
04:48 - will need in your development box for
04:50 - the upcoming models
04:52 - in this lesson you will set up the
04:54 - development environment that will be
04:56 - used across this course
04:59 - here for the tools required for this
05:01 - model
05:02 - the net 5 software development kit or
05:04 - sdk which includes everything needed to
05:06 - build and run.net applications
05:08 - docker desktop which has all the tools
05:10 - needed to run the multiple
05:12 - infrastructure services that we will use
05:14 - across the course
05:15 - and visual studio code the lightweight
05:17 - but powerful source code editor that we
05:19 - will use to write build and debug our
05:22 - microservices code
05:23 - a few of the future models will require
05:25 - more tools but for now this is all that
05:27 - is needed
05:29 - let's go through the installation of
05:30 - these tools and the overall setup of our
05:32 - development environment
05:37 - before getting started just keep in mind
05:39 - that the pages that you will see for
05:40 - downloading the tools will likely look a
05:42 - bit different depending on your
05:44 - operating system and the versions
05:45 - available at the time that you're taking
05:46 - this course
05:48 - but regardless the result download and
05:50 - installation process should be mostly
05:52 - the same
05:54 - so let's start by going to the download
05:56 - page for the net sdk
05:58 - so let's go to
05:59 - net.microsoft.com
06:01 - download
06:04 - and this page is going to present you
06:05 - the latest version of the net sdk which
06:08 - in my case that will be net 6 and in
06:10 - your case it could be different
06:13 - but one thing to keep in mind is that
06:14 - this course has been designed for net5
06:18 - not for dotnet 6 or any other future
06:20 - version
06:21 - so even if you have net 6 or another
06:23 - version installed in your machine you
06:25 - have to make sure that you get the net 5
06:27 - sdk in your box otherwise the project in
06:30 - place that you will be using will
06:31 - generate different code than the one
06:33 - that you're going to see in this course
06:34 - and you're also going to get a few
06:36 - syntax errors
06:38 - so to get the net 5 sdk what you want to
06:40 - do is go to this link all the temp
06:42 - versions
06:44 - and then you want to go into the 5 link
06:46 - over here
06:50 - here at the top of this page you want to
06:52 - look at this table here
06:53 - which lists the links to install.net for
06:56 - the different operating systems so you
06:58 - have to choose the link that corresponds
07:00 - to your operating system in my case i'm
07:02 - running windows and my platform is x64
07:06 - so i'm going to click in the x64 link
07:09 - and that is going to start unload
07:11 - so this unload could take a few seconds
07:13 - depending on your download speed so
07:15 - let's just give it a few seconds
07:19 - okay so the installer has unloaded i'm
07:21 - going to click on installer
07:24 - i'll click on install
07:26 - and installation starts
07:28 - this could take a few seconds or a few
07:29 - minutes depending on the speed of your
07:31 - machine so again let's just give it a
07:33 - moment
07:39 - okay so the identified sdk has been
07:41 - installed already and i'm going to just
07:43 - close this window
07:45 - and what i'd like to do now is to
07:47 - quickly go ahead and verify the
07:48 - installation just to make sure that it
07:50 - has been installed properly so to do
07:52 - that i'm going to go and open my start
07:54 - menu
07:55 - and then i'm going to look for my
07:56 - terminal my windows terminal and of
07:58 - course depending on your operating
08:00 - system what you can do is just open
08:02 - whichever terminal or shell is available
08:04 - in your box
08:06 - this should work in really any kind of
08:07 - terminal or shell
08:09 - and then all you want to do is just type
08:12 - net
08:13 - and then dash info
08:16 - and this is going to present you with a
08:17 - bunch of details regarding your version
08:19 - of the sdk and your machine
08:22 - like in my case it is showing that i
08:24 - have version 5.0 that 404 of the sdk
08:29 - and then there are many other details
08:30 - here but in the end this shows that that
08:32 - end has installed properly into my
08:34 - machine
08:35 - so that net is ready to go
08:38 - now let's go ahead and load the page to
08:40 - download docker desktop
08:44 - let's go to docs.docker.com
08:47 - getdocker
08:51 - and in this page if you scroll down a
08:53 - little bit you're going to see again
08:54 - that you can pick your operating system
08:56 - so again my operating system will be
08:59 - windows so i click on docker desktop for
09:01 - windows
09:03 - and docker desktop for windows so i'll
09:05 - click on that button and let's give it a
09:07 - few seconds for the download to complete
09:15 - okay so let's go ahead and open the
09:17 - docker desktop installer
09:21 - okay so here it goes
09:24 - we'll just keep these two checks right
09:25 - there
09:26 - no need to change anything
09:28 - i'll just click on ok
09:31 - and that's going to get things started
09:33 - again this may take a while so let's
09:35 - give it a moment to complete
09:42 - okay so installation succeeded i'll
09:44 - click on close
09:45 - another thing about docker is that
09:47 - docker desktop will usually not
09:48 - automatically start in your machine
09:50 - after installation
09:52 - so you do have to start it at least the
09:54 - very first time that you install the
09:55 - tool
09:57 - so to start docker i'll just go to my
09:59 - start menu i'll type docker
10:02 - so here it is you're looking for docker
10:04 - desktop i'll click on it
10:06 - and you should see a new icon show up in
10:08 - the right side
10:09 - bottom right i guess which is starting
10:11 - the docker process
10:16 - okay so this screen shows up i'll click
10:18 - accept all the terms accept
10:22 - notice how docker desktop is starting
10:26 - and then this screen shows up local
10:28 - engine waiting double engine starting
10:31 - give it a second
10:33 - installation has completed it has
10:35 - started
10:36 - i'll click on skip tutorial here
10:38 - and at this point docker is up and
10:40 - running
10:41 - and to verify that docker is up and
10:43 - running properly what i'll do is also
10:45 - type a quick command in the terminal
10:46 - window
10:47 - but i'll open a second terminal just
10:49 - because we want to make sure that it has
10:50 - gotten the chance to read the new
10:52 - environment variable to locate docker
10:55 - so i'm going to close this terminal here
10:57 - close our windows
10:58 - and i'll open a new terminal windows
11:00 - terminal
11:03 - and here what i'll do is just type
11:05 - docker version
11:07 - and if docker is installed it should
11:09 - show up all the details about the
11:11 - current version of docker
11:12 - which in my case is version 20.10.11
11:16 - for the docker client at least
11:18 - and with that our docker installation is
11:20 - complete
11:22 - so now i'll go ahead and install visual
11:23 - studio code
11:25 - so i'll close this terminal and i'll go
11:27 - into
11:29 - i'll close this i'll go into the browser
11:33 - let's go into aka rms slash bs code
11:38 - and here's the style page for vs code
11:41 - and as usual you're going to be offered
11:43 - the version that corresponds to your
11:44 - operating system
11:46 - so i'm going to click on this big blue
11:48 - button here download for windows stable
11:50 - build and then download starts
11:52 - and this should be pretty fast this is a
11:54 - small starter
11:59 - okay so i'll click on installer
12:03 - accept agreement
12:05 - and then i'll just click all the default
12:06 - options here
12:08 - click install and let's give it a moment
12:09 - to complete
12:15 - okay so then i'll just click on finish
12:18 - and this code is opening up right away
12:23 - i'll maximize this window
12:25 - and as you can see vs code has open up
12:28 - and that completes our installation of
12:29 - initial tools
12:31 - in the next lesson we will go ahead and
12:33 - customize pixel studio code for c-sharp
12:35 - development
12:39 - visual studio code is a lightweight but
12:42 - powerful source code editor that has
12:44 - built-in support for javascript
12:46 - typescript and node.js and has a rich
12:48 - ecosystem of extensions for other
12:50 - languages and runtimes
12:53 - since all the code that you will write
12:54 - across this learning pad will use the
12:56 - c-sharp language and will run using the
12:59 - network time you will need to install
13:01 - the popular c-sharp extension
13:04 - so to start extensions what you want to
13:06 - do is go into your activity bar on the
13:08 - left side this one over here and look
13:10 - for the extensions view via this
13:13 - extensions icon you can click on that
13:15 - one
13:16 - and this is going to show all the
13:17 - available extensions in to the code
13:19 - marketplace
13:20 - of which there are really hundreds of
13:22 - them
13:23 - and then what you want to do is just
13:24 - search for c-sharp
13:27 - and the extension that you want is
13:28 - usually the very first one on the list
13:31 - and is the one that is provided by
13:32 - microsoft and it says c-sharp for visual
13:35 - studio code powered by omnisharp so
13:37 - let's click on that one
13:39 - and this is the extension that adds all
13:41 - the editing support needed for c-sharp
13:43 - including syntax highlighting
13:45 - intellisense find all references and
13:47 - many other features
13:49 - it also adds support for building and
13:51 - debugging.net and asp.net core
13:53 - applications in your box so you have to
13:55 - make sure that you get in this extension
13:56 - in your box to be able to do proper
13:58 - coding with c-sharp so i'll go ahead and
14:00 - click on install
14:02 - and this may just take a few seconds
14:04 - after which you will be ready to start
14:06 - coding in c sharp
14:09 - okay so extension is ready and you're
14:10 - ready to call on c sharp with visual
14:12 - studio code here but let's also go ahead
14:14 - and enable a few optional settings to
14:17 - further improve your coding experience
14:20 - so let's go to
14:21 - let's first close this and let's close
14:24 - that let's go to file
14:26 - preferences
14:29 - settings
14:30 - and here let's type
14:32 - place open race
14:35 - on new line
14:36 - and this is going to filter a few
14:38 - options here and the ones that you want
14:40 - to enable are
14:41 - this one here javascript format place
14:44 - open brace on new line for contour
14:45 - blocks
14:46 - and place of embrace of new line for
14:48 - functions
14:50 - these two settings will help you format
14:52 - your control blocks like if else blocks
14:55 - and your functions so that when you open
14:57 - braces the opening brace automatically
15:00 - goes to the new line
15:01 - so you don't have to use this setting
15:03 - but i find that my code reads much
15:04 - better when i use it
15:07 - the next setting is let me delete this
15:08 - one here delete this
15:11 - is um format on save
15:14 - which is this option right here this
15:16 - first one so i'll click on that one
15:18 - so what this allows
15:20 - is to uh make sure that all your code
15:23 - for whichever file you're working on
15:25 - will be automatically formatted as soon
15:27 - as soon as you save it into your machine
15:30 - right so you save the file and it will
15:31 - get all the formats so that what again
15:33 - we will help you
15:35 - make sure that the code looks way better
15:37 - without you having to do a lot of work
15:39 - across your lines
15:41 - and the last option setting that i will
15:43 - recommend you is this one in file
15:46 - how to save
15:48 - so as the name says what this allows you
15:51 - is to automatically save whichever file
15:53 - you're working on without you having to
15:55 - do anything so as soon as you finish
15:57 - typing your code the file will be
15:58 - automatically saved to your machine
16:01 - so i find that very handy and to make
16:03 - sure that i never forget to save my
16:04 - files so i'm just going to click on auto
16:06 - save
16:07 - and that will enable the setting
16:10 - the last thing that i wanted to show you
16:11 - here is the visual studio code
16:13 - integrated terminal which is the one
16:15 - that you're going to use to type a bunch
16:16 - of commands across this learning pad
16:18 - so let me go ahead and close this
16:20 - settings tab here and to open the
16:22 - terminal what you can do is either go to
16:25 - view
16:26 - terminal
16:28 - or you can go to terminal new terminal
16:32 - or you can use a few shortcuts like for
16:34 - instance in the case of windows you can
16:36 - do ctrl tilde
16:38 - double open terminal
16:40 - or let me kill this
16:41 - you can also use ctrl j and that will
16:43 - also bring up a terminal so of course
16:46 - the shortcut keys will depend on your
16:48 - current operating system now as you can
16:50 - see in this case this has opened a
16:52 - terminal a powershell terminal in my
16:54 - case and that's because that's a default
16:56 - for windows
16:57 - but you can always go ahead and use this
17:00 - drop down on the right side
17:02 - right here you can open up and you can
17:04 - switch to any other terminal that better
17:06 - switch your needs so if you want to use
17:08 - patch you can use git batch here you can
17:10 - use a standard command prompt or you can
17:12 - switch to either even a wound based
17:14 - terminal so it's really up to you what
17:16 - terminal to use
17:17 - in this course we'll be using mostly a
17:19 - powershell because that's that's what i
17:21 - mostly like to use but it's up to you to
17:24 - use whichever terminal fits better your
17:26 - needs
17:27 - in the next couple of lessons we will
17:29 - define the concepts of monoliths and
17:31 - microservices
17:32 - how they compare and which are their
17:34 - pros and cons
17:38 - before diving into microservices and
17:39 - their benefits it is probably worth it
17:41 - to understand first what a monolith is
17:44 - its benefits and the issues it can
17:46 - present
17:48 - to understand what we mean by a monolith
17:50 - let's look at one way we could design
17:51 - our play economy system
17:53 - we start with our desktop and mobile
17:55 - clients
17:56 - like we said they need some sort of
17:58 - backend piece to enable the game
17:59 - experience
18:01 - therefore we introduce a server
18:02 - component
18:03 - likely hosted as a web server somewhere
18:05 - in the internet
18:07 - as we go through the requirements we
18:09 - identify a model that needs to take care
18:11 - of the in-game catalog of items so we
18:14 - introduce a catalog model
18:16 - right away we also perceive the need for
18:18 - a place to store these catalog items
18:20 - which means it is time to introduce a
18:22 - database along with a table to store
18:25 - these items
18:27 - we also identify the need to store the
18:29 - information about our players and in
18:31 - general any user of the system
18:33 - so we bring in a user's model which we
18:36 - place in the same web server next to the
18:38 - catalog model
18:39 - also since we already have a database
18:41 - configured for a web server we decide to
18:43 - add tables for the user's model in that
18:45 - same database
18:46 - next we identify the need to store the
18:49 - set of items that the player has
18:50 - purchased
18:52 - so we bring in an inventory model
18:54 - and same as before we place it next to
18:56 - our other models and add relevant tables
18:58 - to the same database
19:00 - we also need some place to perform the
19:02 - actual purchase process and since this
19:04 - involves both dividing jill from the
19:06 - player and granting items to him we also
19:10 - know we will need to use some sort of
19:12 - transaction for this
19:14 - so we introduce a trading model on the
19:16 - same server
19:18 - and we will let it take advantage of the
19:19 - transactional capabilities of the
19:21 - database
19:23 - finally we will need some way to secure
19:25 - the access to our web server so that
19:27 - only players registered in the system
19:29 - can make use of it
19:31 - so we bring in an authentication and
19:33 - authorization model which we will
19:35 - abbreviate as oddc
19:37 - as with everything else we will place it
19:40 - on the same server and make it use the
19:41 - same database
19:44 - this system that we have just described
19:46 - is what we call a model it
19:49 - and more specifically a modular monolith
19:52 - in this system all of our server-side
19:54 - capabilities are hosted together in the
19:56 - same web server and they all use the
19:58 - same database
20:00 - likely we also have the source code for
20:02 - all the models in a single repository
20:04 - we build all the code base with a single
20:06 - bill process and we deploy everything
20:08 - together
20:09 - let's now look at the pros and cons of a
20:12 - modulate
20:14 - here for the pros and cons of a modblade
20:17 - first the
20:18 - pros convenient for new projects usually
20:22 - when you're just getting started a
20:23 - monolith is the best option since you
20:25 - can put all the source code in one place
20:27 - including all common libraries this lets
20:29 - you iterate quickly for a while
20:32 - tools mostly focus on them
20:34 - most ides are built around the concept
20:36 - of building a single application
20:38 - which aligns pretty well with a monolith
20:41 - there's great code reviews
20:43 - since all the code lives in the same
20:44 - repository it is easy to reuse code
20:47 - across the multiple models of the
20:48 - application
20:50 - it is easier to run locally being a
20:52 - single process it is a straightforward
20:53 - to have the full application running in
20:55 - your box usually with a single command
20:58 - easier to debug and troubleshoot when
21:00 - it's time to fix box there's usually a
21:02 - single place to look for locks to find
21:04 - out what happened you can also start a
21:06 - debugging session in your box to
21:08 - reproduce and fix the issue
21:10 - there's one thing to build
21:12 - a single command is usually enough to
21:14 - build entire codebase locally
21:16 - and if using a continuous integration
21:18 - server a single build pipeline will do
21:20 - the trick
21:21 - there's also one thing to deploy
21:23 - all the application models can be
21:25 - deployed as a unit with a single
21:27 - deployment pipeline
21:29 - there's one thing to test end to end
21:31 - end-to-end verification of application
21:33 - can take place as soon as application
21:35 - has been deployed with no other moving
21:37 - pieces that could impact testing
21:40 - and there's one thing to scale with
21:42 - increased load demands more risk more
21:44 - instances of the web application there's
21:46 - only one app to scale
21:48 - saying when the increased scale is no
21:50 - longer needed there's only one thing to
21:52 - scale down
21:54 - now the cons
21:57 - easily to get complex and to understand
21:59 - since entire code base is in a single
22:01 - place there will be a point where it
22:04 - starts becoming too hard to navigate it
22:06 - and understand the relationships between
22:07 - the different components
22:10 - merging code can be challenging
22:12 - when using things like git
22:14 - and with more and more people
22:15 - contributing to multiple models in a
22:17 - single code base eventually resolving
22:19 - conflicts gets more troublesome and the
22:22 - chances of a bad merge that could impact
22:24 - on related models increases
22:28 - it slows down ids
22:30 - if the devs use an integrated
22:32 - development environment or ide like
22:34 - visual studio the massive number of
22:36 - projects and source code will eventually
22:38 - start slowing down the ide
22:40 - starting with simple things such as
22:42 - opening the work environment
22:44 - long build times
22:46 - the bigger the single code base becomes
22:48 - the more time it takes to build it
22:50 - things like incremental builds
22:52 - can help here but this is something that
22:54 - can easily not be configured properly
22:56 - and regardless it is undesired to have
22:58 - to build code for all the application
22:59 - models when usually you only work on one
23:02 - or two of them
23:03 - slow and infrequent deployments
23:06 - just like building the code takes longer
23:08 - it also takes more time to complete the
23:09 - deployment since there are a lot of
23:11 - components to deploy with every new
23:13 - build
23:14 - not only that teams tend to delay
23:16 - compound deployments to friday night or
23:19 - even weekends due to the lack of
23:21 - confidence on the impact of the changes
23:23 - that go into that deployment
23:25 - remember that with each deployment you
23:27 - are deploying all the application models
23:29 - all the time
23:32 - long testing and stabilization periods
23:34 - once a deployment is complete regardless
23:36 - of what changes in the deployment you
23:38 - still need to test all the scenarios
23:39 - across all of the application models
23:42 - not only this
23:44 - is inefficient but also teams that don't
23:47 - have testing fully automated may need to
23:49 - run manual tests to compensate and run
23:51 - them again for all the application
23:53 - scenarios
23:56 - rolling back is all or nothing
23:58 - books will eventually make their way to
24:01 - deployment and sometimes there's no time
24:03 - to code and deploy the ideal fix
24:06 - in these cases you just want to roll
24:08 - back the previous version
24:09 - however with a monolith you will be
24:11 - forced to roll back the entire
24:13 - application not just the faulty model
24:15 - and
24:16 - once the fix arrives you will need to
24:18 - redeploy the entire thing again with all
24:20 - the associated testing and stabilization
24:24 - no isolation between models
24:26 - the small spock in one of the models
24:28 - that makes the web application crash
24:30 - will take down all the models with it
24:33 - it can be hard to scale
24:35 - this really depends on the kind of app
24:36 - that you're building but if you have
24:38 - some model that needs say a lot of
24:40 - memory and therefore needs to be scaled
24:42 - to multiple instances to not take over
24:44 - all the ramming a single server
24:46 - while all the other models are fine with
24:48 - a small amount of ram most of the time
24:50 - you still need to scale the entire
24:51 - application with all the models to
24:53 - satisfy the ram needs of the first model
24:56 - also it's hard to adopt new tech
24:59 - if you would like to move one or two of
25:01 - the models to the latest version of say
25:03 - the.net platform you are forced to
25:05 - update all the models along with it
25:07 - which significantly increases the time
25:09 - investment and associated risk of moving
25:11 - to a new stack
25:12 - moreover if you need to switch a model
25:15 - to a different programming language or
25:16 - web framework you still need to account
25:18 - for how that change will impact the rest
25:20 - of the models
25:23 - in the next lesson we will start
25:25 - learning about microservices their pros
25:27 - and cons and when it's a good time to
25:29 - start considering them
25:32 - in this lesson we will understand what
25:34 - microservices are how to decompose our
25:37 - previous model lead into microservices
25:39 - the pros and cons of using microservices
25:41 - and when is the right time to start
25:43 - thinking on using them
25:46 - there are multiple definitions of
25:47 - microservices out there but here's one i
25:49 - have synthetized from a few sources and
25:51 - that i think covers the fundamental
25:52 - characteristics of microservices
25:55 - microservices refers to an architectural
25:57 - style that structures an application as
26:00 - a collection of independently deployable
26:01 - services that are modeled around the
26:03 - business domain and are usually owned by
26:05 - a small team
26:07 - so instead of having a single
26:08 - application deployed as a single
26:10 - monolithic unit we break it down into
26:12 - smaller services where each of them is
26:14 - closely aligned to some part of our
26:16 - business domain
26:17 - each of these services can be deployed
26:19 - independently which by the way includes
26:21 - granting each of them their own database
26:24 - which is one of the main challenges of
26:25 - moving to microservices
26:27 - also there's usually only one small and
26:29 - fairly autonomous team behind each
26:31 - microservice
26:33 - let's see how this looks like for the
26:35 - game back and example we talked about in
26:37 - the previous lesson
26:39 - we start again with our client apps
26:42 - which will still interact with some
26:43 - backend pieces to enable the required
26:45 - game experience
26:47 - and just like before we come up with
26:49 - most of the models that we talked about
26:51 - before to address the multiple scenarios
26:54 - however this time each of these models
26:56 - live in their own individual server
26:58 - process or likely a web server process
27:00 - fully isolated from the other ones and
27:02 - with their own lifecycle
27:04 - not only that but also each of these
27:06 - services have their own associated
27:08 - database that has no relationship with
27:10 - the ones from the other services
27:12 - also notice that we decided to group the
27:14 - users and altc models in a single
27:16 - process that we are now calling the
27:18 - identity service
27:20 - but even when these services are now
27:22 - independent they still have ways to
27:24 - collaborate with each other so that for
27:26 - instance when a purchase starts in
27:27 - trading
27:28 - this service will communicate somehow
27:30 - with identity and inventory services in
27:32 - order to achieve the exchange of yield
27:34 - for catalog items
27:36 - this here is what we call the
27:37 - microservices architecture pattern
27:40 - next let's learn about the benefits and
27:42 - drawbacks involved in the microservices
27:44 - architecture
27:46 - these are some of the pros and cons of
27:48 - using microservices
27:50 - let's start with the pros
27:51 - they have a small easy to understand
27:53 - code base
27:54 - since the microservices are now
27:56 - independent the source code for each of
27:58 - them is usually stored in its own git
28:00 - repository this implicitly results in a
28:02 - much smaller repository which is much
28:04 - easier to understand especially for devs
28:07 - new to the code base
28:09 - they are quicker to build
28:11 - the smaller independent codebase per
28:12 - microservice allows for building each
28:14 - service much faster and in parallel both
28:17 - on deck boxes and on ci pipelines
28:20 - they allow for independent faster
28:21 - deployments and rollbacks
28:23 - each service can now be deployed
28:25 - individually as soon as the relevant
28:27 - source code has been built and testing
28:30 - for the domain covered by the service
28:32 - can start right away and is much smaller
28:34 - in scope
28:36 - also if an issue is detected with the
28:38 - deployment it can be rolled back to the
28:40 - previous version without having to roll
28:42 - back any other service
28:46 - they are independently scalable
28:48 - different services can be skilled
28:50 - according to their needs so if there's
28:52 - one service that needs to scale given
28:53 - the amount of ram or cpu it uses it can
28:56 - be scaled independently of the needs of
28:57 - any of the other services
29:00 - there is much better isolation from
29:01 - failures microservices are isolated from
29:04 - each other
29:05 - so that a crashing one service has no
29:07 - impact in the availability of the other
29:09 - services
29:10 - they are designed for continuous
29:12 - delivery since microservices are small
29:14 - usually start fast and are independent
29:16 - from each other they are great
29:18 - candidates for continuous delivery they
29:20 - can be deployed as soon as the code has
29:22 - been built
29:23 - and this can be done safely in an
29:25 - automated way multiple times a day
29:29 - it is easier to top new variety tech
29:31 - different services don't need to use the
29:33 - same versions of their multiple
29:34 - dependencies including the.net runtime
29:37 - even better if one of them needs to be
29:39 - moved to a completely different language
29:40 - or web framework this is much more
29:42 - straightforward to do with a small micro
29:45 - service than with a big model it
29:47 - microservices ground autonomy to teams
29:50 - and lets them work in parallel
29:52 - the natural independence of deployment
29:54 - and isolation of microservices and the
29:56 - fact that they are closely lined to a
29:58 - specific part of the business domain
30:00 - results in the owning teams to have
30:02 - great autonomy around the entire
30:04 - lifecycle of the service
30:06 - some teams might decide to deploy their
30:07 - microservice every night while others
30:10 - will do it every hour or whenever an
30:12 - origin fix needs to be shipped
30:14 - different teams will do what's best for
30:15 - them
30:17 - now the cons
30:20 - it is not easy to find the right set of
30:21 - services
30:22 - how do you know that you have split the
30:24 - app into the right set of services
30:26 - are three microservices enough or 10
30:28 - perhaps how much granularity
30:31 - these questions are not easy to answer
30:33 - but techniques like domain-driven design
30:35 - and aligning the services to specific
30:37 - pieces of the domain and the teams
30:39 - behind them helps to find the right
30:40 - balance
30:42 - using microservices as the complexity of
30:45 - distributed systems
30:46 - the fact that each service lives in
30:48 - separate silo introduces a lot of
30:50 - complex issues that are non-existent in
30:52 - modulates
30:54 - how to have a service communicate with
30:55 - another one if a model can no longer
30:58 - make a simple method call to the other
31:00 - issues like these are the reason for
31:02 - this curse
31:04 - the shared code moves to separate
31:05 - libraries
31:06 - any piece of code that needs to be
31:08 - shared across two or more microservices
31:10 - now needs to be either duplicated in
31:12 - each service which is not ideal or moved
31:15 - to a separate library and likely sharpie
31:17 - and nougat packages
31:18 - this is technically good since it forces
31:21 - the owners of the share code to have a
31:22 - good way to test the shared code
31:24 - independently but on the flip side
31:26 - things are no longer as easy as adding a
31:28 - new shared class or method to any of the
31:31 - services codebase
31:33 - also you may end up with dozens of
31:35 - shared libraries that may need to
31:37 - collaborate and have the right set of
31:39 - dependencies
31:41 - there is no good tooling for distributed
31:43 - apps
31:44 - ides are usually focused on a single app
31:46 - not uploading several services together
31:48 - this means that devs will usually work
31:50 - on one service at a time and will need
31:52 - to figure out ways for their code to
31:54 - interact with other services in their
31:56 - dev environment where needed
32:00 - releasing features across services is
32:01 - hard
32:02 - simple things like adding a new
32:04 - attribute to say a user record and have
32:07 - it been used across the entire system
32:10 - can involve touching multiple services
32:11 - in a very coordinated fashion even worse
32:14 - updating or removing attributes from
32:16 - data classes is extremely painful and
32:19 - usually avoided as much as possible
32:23 - it is hard to troubleshoot issues across
32:24 - services
32:26 - when a customer reports an issue with
32:27 - the system or application
32:29 - where you will start looking
32:31 - with features potentially distributed
32:33 - across dozens of microservices you are
32:35 - forced to have a very good story around
32:37 - tracing issues across services to be
32:39 - able to quickly find out the root cause
32:41 - and address it
32:43 - you can't use transactions across
32:45 - services
32:46 - since each service has its own database
32:48 - atomic transactions that impact multiple
32:50 - tables are usually out of the question
32:53 - how to ensure a purchase operation will
32:55 - both debit jill from the user and
32:57 - granted the relevant items when one of
33:00 - the involved services could unexpectedly
33:02 - fail in the middle of the purchase
33:03 - process
33:05 - a few new patterns and techniques need
33:07 - to be introduced to properly handle
33:08 - these concerns
33:11 - finally it raises the required skill set
33:13 - for the team
33:15 - with each team fully owning the service
33:18 - and since not all services will be built
33:20 - similarly
33:21 - each team now needs to learn not just
33:23 - how to code features for the service but
33:25 - also how to build it deploy it test it
33:28 - in isolation diagnose it roll it back
33:30 - etcetera
33:31 - many times this also involves building a
33:33 - ton of automation and shared
33:34 - infrastructure to ensure teams can
33:36 - remain agile building features and not
33:38 - have to worry too much about all the
33:40 - other aspects this requires a lot of
33:42 - investment
33:44 - let's close this lesson by understanding
33:46 - when you should start considering
33:47 - microservices
33:50 - you should keep in mind that it is
33:52 - perfectly fine to start with a monolith
33:54 - and only later move to microservices
33:55 - architecture
33:57 - your business domain and the set of
33:58 - requirements for your system might not
34:00 - be fully flushed out by the time you
34:02 - need to start designing and building the
34:04 - system
34:05 - therefore jumping into building multiple
34:07 - microservices from the start could not
34:09 - only significantly slow down the small
34:11 - starter team at a time when quick proof
34:14 - of concepts are desired
34:15 - but also you may end up building the
34:17 - wrong set of microservices with
34:19 - additional cost of having to restructure
34:21 - them later
34:22 - the heavy investments on shared
34:23 - infrastructure and automation will only
34:26 - make sense as the boundaries are clearly
34:28 - defined and the team has grown in size
34:31 - you should start looking at
34:32 - microservices when the code base size is
34:35 - more than what a small team can maintain
34:38 - the different teams can move fast
34:39 - anymore due to the amount of share code
34:42 - the bills have become too slow due to
34:44 - the large code base
34:46 - or the time to market is compromised due
34:48 - to infrequent deployments and loan
34:50 - verification times
34:53 - in the end microservices are all about
34:55 - team autonomy
34:57 - anytime you notice multiple teams no
34:58 - longer being able to deliver features in
35:00 - an agile way due to the drawbacks of the
35:03 - monolithic architecture
35:05 - you know that your teams have lost their
35:06 - autonomy and they could potentially
35:09 - greatly benefit from using microservices
35:11 - instead
35:12 - in the next model we will get our hands
35:14 - dirty by building our first microservice
35:19 - in this model we will build our first
35:21 - microservice from scratch
35:23 - this will give you the foundations and
35:24 - tools you will need to create
35:26 - microservices with the.net platform
35:30 - by the end of this model you will have a
35:31 - solid understanding of the following
35:34 - how to create a microservice from
35:36 - scratch via the.net cli and visual
35:38 - studio code
35:40 - how to define the microservice rest api
35:42 - with the most common operations
35:45 - and what are and how to define the data
35:47 - transfer objects to establish the
35:49 - contract between our service and the
35:50 - service clients
35:53 - in this lesson we will create our first
35:55 - microservice the catalog microservice
35:57 - using the.net cli and visual studio code
36:01 - to create our microservice project we
36:02 - will take advantage of the.net command
36:04 - line interface also known as netcli
36:07 - which comes installed with the net sdk
36:10 - so first thing i'll do is create the
36:12 - folder where i'm going to store my
36:13 - projects so to do that i'll go to
36:15 - terminal new terminal
36:17 - and then i'll switch to my d drive and
36:20 - to my products folder and i'll create a
36:22 - folder called
36:24 - play that catalog
36:26 - so everything related to the play that
36:27 - catalog uh catalog microservice will be
36:30 - stored in that location so i'll open
36:32 - that folder and visuals to the code now
36:33 - by going to file open folder
36:36 - and then i'll look for that location
36:40 - here
36:41 - so this opens a workspace
36:43 - in that location
36:44 - so being here what i'd like to do is
36:46 - create yet another folder to store all
36:48 - the source files for the for the
36:49 - microservice so i'll go on the left side
36:51 - here i'll go and click on new folder and
36:55 - then i'll type src so src is going to be
36:57 - the folder that stores all the files
37:00 - related to compile duplication i'll
37:02 - expand this and then i'll right click on
37:04 - src and select open in integrated
37:07 - terminal so this opens a terminal
37:09 - exactly the location where we're going
37:11 - to create the project files
37:14 - to actually generate the files what we
37:15 - can do is type
37:17 - net new
37:19 - and at this point you can actually pick
37:21 - from a bunch of different templates for
37:23 - creating.net projects but the one that's
37:25 - most useful for microservices is usually
37:27 - the web api kind of project so we'll all
37:29 - type
37:30 - web api
37:31 - and the name we're going to give it is
37:35 - that lay.catalog.service
37:36 - hit enter
37:38 - and this is going to go ahead and
37:40 - generate all the files that we need for
37:41 - the project which at this point you can
37:42 - see on the left side also notice that
37:44 - there's a small warning about the
37:46 - asp.net core https development
37:48 - certificate which we'll take a look in a
37:50 - moment
37:51 - now if by any chance you have multiple
37:54 - versions of the net sdk installed in
37:56 - your machine and you're not sure that
37:58 - that n5 is your default version please
38:00 - add the
38:01 - framework argument to the net new
38:03 - command and specify the value of net 5.0
38:07 - for dot n5
38:08 - that will make sure that you are using
38:10 - the asp.net core 5 templates when
38:12 - creating projects which will produce the
38:14 - same files that you will see in these
38:16 - and in future lessons now let's go
38:18 - quickly across the files that just got
38:19 - generated and see what they are meant to
38:22 - be used for so the first one is going to
38:24 - be alter i'd actually just close this
38:26 - terminal the first one is going to be
38:28 - the cs profile which is what we call the
38:30 - project file so this is the file that
38:31 - defines how the project is going to be
38:33 - built
38:34 - and
38:35 - what version of the dotnet runtime is
38:37 - going to be targeted in this case it's
38:39 - going to be.net 5.
38:41 - the next one is program cs which is what
38:43 - we call the main entry point of the
38:45 - application
38:47 - but also notice that as soon as we open
38:49 - our first sharp file visual studio code
38:51 - is going to prompt us to add a few
38:52 - regard assets to the project and we'll
38:55 - say yes
38:56 - so this will create a vs code folder on
38:58 - the left side with a couple of files
39:00 - that are needed to build and debug the
39:01 - application
39:03 - now like i said back in program cs this
39:06 - is the main entry point so this defines
39:08 - how we're going to start
39:10 - the the host for our application
39:13 - next file is going to be startup.cs this
39:15 - defines how we're going to uh register
39:18 - the services are going to be used across
39:20 - application and what we call also the
39:22 - request pipeline for espnetcore
39:25 - the next one i'd like to show you is the
39:27 - controllers folder this is where we
39:29 - store all the
39:31 - application controllers to handle the
39:32 - requests that are going to come into the
39:34 - application
39:36 - and this is a campaign this is a
39:37 - campaign with uh right now by a model
39:40 - that's called the weather forecast for
39:41 - the simple sample model that has been
39:43 - set up in this template
39:46 - next file is a launch settings.json
39:50 - this one defines a few things but the
39:51 - most important one is the application
39:53 - url which defines which is the address
39:56 - or the addresses
39:57 - where our
39:58 - microservice is going to be running so
40:00 - in this case it is going to be available
40:02 - in https localhost 5001 and on https
40:06 - sorry http localhost 5000.
40:10 - finally like i said this is the code
40:12 - generated a couple of files
40:14 - over here
40:15 - that's a json which defines
40:17 - how we're going to build the code from
40:20 - visual studio code and launch
40:21 - application that defines how to start up
40:24 - how to
40:25 - actually kick off
40:26 - the execution of the application in
40:28 - visual studio code
40:30 - okay now i'll close this and it's time
40:32 - to actually build this project to make
40:34 - sure we'll build and run it to make sure
40:36 - that it's running properly so in order
40:38 - to do that what i'll do is i'll go back
40:39 - to the terminal and you can do that by
40:41 - going to view
40:44 - terminal
40:45 - which by the way you can also do via the
40:47 - control j shortcut
40:49 - faster that way
40:50 - and then i'll switch to
40:53 - our
40:55 - play.catalog that service directory
41:03 - play that catalog service
41:05 - and then we'll be in there and what you
41:07 - can do there's actually a couple of ways
41:08 - that you can build this project so you
41:10 - can either do
41:12 - net build like i'll do now that will go
41:16 - ahead and build the entire project
41:18 - should be pretty fast
41:19 - and the other way to do this is via
41:21 - visual studio codes menus you can go
41:23 - to terminal realm build task
41:27 - and then you select build
41:29 - and that will also go ahead and build
41:30 - the project
41:33 - now this second way is the way that you
41:34 - will most likely be using a while being
41:37 - exhausted to your code and to make this
41:38 - actually a bit faster what you can do is
41:40 - add a little bit of a couple of lines
41:42 - into the task.json file so let me
41:45 - minimize this a bit
41:47 - so go to that json
41:49 - and here under the under the build
41:51 - section what you can do is just add one
41:54 - little group here
41:55 - let's add it it's called group
41:58 - and then we're going to go for kind
42:00 - build is evil true
42:02 - i'll save this
42:04 - and after doing that what you notice is
42:06 - that when you go to
42:08 - terminal and you say run build task it
42:10 - will build it right away as opposed to
42:12 - opening yet another menu to do the build
42:15 - at this point you can also do
42:17 - uh you can also use the ctrl shift b
42:20 - shortcut like i'll do now
42:22 - to kick off the build without having to
42:23 - go through any menus which is pretty
42:25 - handy
42:27 - okay now that we know how to build the
42:28 - project and i'll actually just close
42:30 - this
42:31 - how do we
42:32 - how do we run it so there's a couple of
42:34 - ways to do that too
42:35 - so i'll actually switch in this drop
42:37 - down i'll go back to our terminal the
42:39 - partial terminal
42:41 - and the way to run the this microservice
42:44 - this microservice project is by just
42:47 - typing.net run
42:49 - so that may build the project depending
42:51 - on the current status but after that it
42:53 - will go ahead and run it as you can see
42:56 - and it reports the current status uh the
42:58 - the the address where the
43:01 - where the host is listening the
43:02 - addresses in this case 5001 5000 in
43:04 - localhost
43:06 - and how to actually turn turn down the
43:08 - application if needed by ctrl c
43:11 - that's one way and i'll actually do a
43:13 - control c to stop it
43:14 - the other way to do it is by going to
43:16 - the
43:18 - to the wrong view on the left side
43:20 - and here you can click on this on this
43:24 - icon here says start debugging it will
43:25 - actually start a debugging session
43:27 - of the project as opposed to just
43:28 - running it so i'll click on it
43:35 - okay
43:37 - and this will open a browser window as
43:39 - you can see here
43:40 - for our project
43:42 - now if you see this
43:45 - this kind of an error
43:48 - stating that your connection isn't
43:50 - private this is totally normal so this
43:51 - just means that the development
43:53 - certificate for the
43:56 - for the web host has not been installed
43:58 - yet
43:59 - so in order to address this let's
44:01 - actually go back let's close this and
44:04 - stop it
44:05 - and what we have to do is just install
44:08 - the certificate i mean trust the
44:09 - certificate in our machine so i'll go to
44:12 - terminal
44:14 - switch back to the partial terminal here
44:17 - what i'll do is use the
44:19 - net dev search tool you have to type
44:22 - https
44:25 - trust
44:26 - hit enter
44:28 - and this is going to pop up
44:29 - this little warning here which is
44:31 - totally fine and say yes and that adds a
44:35 - certificate into your thruster rule
44:36 - certificates
44:38 - stored in your machine
44:39 - so after doing that i'll go ahead and
44:42 - instead of clicking on this i'll just
44:44 - hit f5 which is a shortcut for start
44:46 - debugging so i'll hit f5
44:50 - so that obviously browser came and as
44:52 - you can see there's no errors anymore
44:54 - and yes it is not showing anything uh
44:57 - that that's because there's nothing
44:58 - really happening in the in the root of
45:00 - the website so if you actually want to
45:01 - see something you can do slash swagger
45:05 - and this opens the swagger page so i got
45:08 - ui page so this is the page where you
45:10 - can start
45:12 - exploring the different methods exposed
45:14 - by your
45:16 - web api or your res api
45:19 - in this case we have not really coded
45:21 - much the only thing that you're seeing
45:23 - here is the default stuff that's coming
45:24 - with the template so we'll not pay too
45:26 - much attention into it but later on
45:28 - we'll start using this page heavily to
45:29 - start
45:30 - working with our microservice
45:33 - i'll close this
45:34 - and i'll stop the server
45:37 - so that's it for this lesson and in the
45:40 - next lesson we will define the rest api
45:42 - for our catalog microservice
45:46 - in this lesson we will define the res
45:48 - api for our catalog microservice
45:52 - the res api defines the operations
45:54 - exposed by the microservice
45:56 - since the catalog microservice owns the
45:58 - items that players will be able to
46:00 - purchase
46:00 - here are the operations that it should
46:02 - support
46:04 - get items which retrieves all the items
46:07 - currently stored in the service
46:09 - get item by id which retrieves the
46:11 - details of a specific item
46:15 - post item which creates an item in the
46:17 - service
46:19 - put item which updates a specific item
46:23 - and delete item which deletes the
46:25 - specified item
46:27 - as part of the definition of the res api
46:29 - we also need to define the relevant data
46:31 - transfer objects
46:33 - so what is a data transfer object
46:36 - a data transfer object also known as dto
46:39 - is an object that carries data between
46:41 - processes
46:43 - for example
46:44 - let's go back to our client and the
46:45 - catalog service
46:47 - when the client needs to retrieve the
46:49 - details for a specific item it will send
46:51 - a get request to the service with the
46:53 - item id
46:54 - and the service will in turn return the
46:56 - item details
46:58 - this payload returned by the service is
47:01 - what we call the dto
47:04 - the dto represents the contract between
47:05 - the microservice and the client
47:08 - we'll define this contract has
47:10 - significant implications
47:12 - imagine what would happen if we decide
47:14 - to rename the price to item price
47:18 - our clients would break and they would
47:20 - need to get updated right away to ensure
47:22 - no disruption to our customers
47:25 - as a general rule you need to think
47:27 - carefully about each of your details to
47:29 - ensure you minimize the need to update
47:31 - them later as much as possible
47:35 - it's time to define the res api for
47:38 - catalog microservice
47:40 - we'll start by deleting a few files that
47:42 - were created by the template that we
47:43 - will not be using across this
47:45 - microservice which are the weather
47:47 - forces controller i'll delete this
47:50 - and the weather forecast class over here
47:55 - now the first thing that we're going to
47:56 - do is declare
47:58 - the details for our service
48:00 - now we will use record types for dtos as
48:03 - opposed to classes basically because
48:05 - they are simpler to declare
48:07 - they provide value based equality which
48:09 - means that when comparing two of the
48:11 - items then we will consider equal if all
48:13 - their properties have the same value
48:15 - which is not the case with classes
48:17 - they are immutable by default meaning
48:19 - that modifications after creation are
48:21 - not allowed
48:22 - and they have a built in to a string
48:24 - overwrite that shows the names and
48:26 - values of all the record properties
48:29 - so to create the dtos
48:31 - file
48:32 - you can right click on play catalog
48:33 - service right here
48:35 - say a new file
48:36 - and then let's name it
48:38 - dtos.cs
48:41 - in this file first thing we're going to
48:43 - do is just declare a namespace
48:45 - so
48:46 - namespace should have the name of the
48:48 - folder to start with so play
48:51 - catalog service and then we will append
48:54 - dtos
48:57 - now let's declare our first cto this is
48:59 - going to be the dto that is going to be
49:01 - used to return information from our get
49:04 - operations
49:05 - so
49:06 - public record
49:08 - item dto
49:10 - and the first thing that is going to
49:11 - have is an id it's going to be of type
49:14 - good
49:16 - and good is a type that is going to need
49:18 - a namespace import so to import
49:20 - namespace i'm going to use a light bulb
49:22 - here
49:23 - and i'll select using system so that
49:24 - imports the namespace
49:27 - and then we're going to declare
49:30 - a name
49:32 - a description
49:35 - a price
49:37 - and
49:39 - a created
49:41 - date
49:44 - okay
49:46 - now the next cto is going to be used for
49:47 - the creation of our items
49:50 - so let's say public record is going to
49:53 - be named
49:54 - create item dto
49:57 - this cto does not need an id or a
50:00 - created date because both of them are
50:02 - going to be
50:03 - automatically generated within the
50:05 - service so they don't need to be
50:06 - provided by the client so we'll specify
50:09 - a name
50:10 - a description
50:13 - and a price
50:17 - finally we're going to declare a dto for
50:19 - updating an item
50:20 - so pull the record
50:22 - update item
50:25 - dto and this is actually going to have
50:27 - the same members as create item dto so
50:29 - i'm going to copy those
50:31 - and uh it happens to be that right now
50:33 - they have they need the same members but
50:36 - it could be in the future that they need
50:38 - different
50:39 - different properties so
50:41 - a good convention is to keep them
50:42 - separate even if they have the same
50:43 - properties to start with
50:46 - in the next lesson we will add a
50:48 - controller to define our res api
50:50 - operations
50:54 - in order to add our api operations we
50:56 - will need to introduce a controller
50:58 - specifically a web api controller
51:00 - the controller groups the set of actions
51:02 - that can handle the api requests
51:04 - including the routes authorization and a
51:06 - series of other rules usually needed in
51:08 - rest apis
51:10 - so to start let's go to our controllers
51:12 - folder here right click
51:13 - new file and the name that we're going
51:15 - to get to this controller is
51:18 - items controller
51:20 - since this is going to be the controller
51:21 - that's going to be managing our catalog
51:23 - items
51:25 - so let's go ahead and collapse our
51:26 - navigation pane so that we have more
51:28 - space for looking at the code
51:31 - let's start by defining a namespace
51:35 - the namespace
51:37 - catalog service controllers
51:41 - okay and now let's define our class
51:45 - it's going to be items
51:48 - controller
51:52 - and so each of your web api controllers
51:56 - should derive from
51:58 - controller
51:59 - base
52:00 - and i'm going to import the missing
52:02 - space by doing control dot
52:05 - using microsoft switch core mvc
52:08 - so you always want to derive from
52:10 - controller base not from controller but
52:12 - controller base because this provides
52:14 - many properties and methods useful when
52:16 - handling http requests
52:18 - like the battle requests not found and
52:21 - created attacking methods
52:23 - which we'll be using in these and in
52:25 - future lessons
52:27 - now you should always also add to each
52:29 - of your controllers the api controller
52:32 - attribute so api controller
52:36 - this attribute enables a series of
52:38 - features that improve your sapi
52:40 - developer experience
52:42 - like for instance having model
52:43 - validation errors automatically return a
52:45 - 400 request error
52:47 - or how to bind incoming requests into
52:50 - our method parameters
52:52 - the other attribute you want to add here
52:54 - is the
52:55 - route attribute
52:57 - this one specifies the url pattern
53:00 - that this controller will map to for
53:03 - instance if we use
53:05 - items here
53:08 - that means that this controller will
53:09 - handle the
53:10 - rewards that start with slash items so
53:14 - for instance
53:15 - if we get let's say
53:18 - i'll just add a little comment here
53:23 - so we have localhost 5001 and if
53:25 - somebody navigates into items
53:28 - that means that since the route
53:30 - specifies items here that means that
53:32 - items controller is the controller
53:34 - that's going to
53:36 - handle
53:37 - that specific route
53:39 - okay so i'll remove this
53:42 - and you can also use route for the
53:44 - different uh
53:46 - operations that we're going to define in
53:47 - this controller you can specify your own
53:49 - routes but for now uh this is going to
53:51 - be our root route for all the the
53:54 - operations in this controller now since
53:57 - in this lesson we would like to focus on
53:59 - the rest api part of microservice we
54:01 - will not be interacting with the real
54:02 - database just yet
54:03 - we will use an in-memory list of items
54:06 - that our api variations will interact
54:07 - with and in a future lesson we will
54:09 - introduce a proper repository class that
54:11 - will take care of interacting with our
54:12 - database
54:14 - so let's start by defining this a static
54:17 - list so i'll declare
54:20 - probably static
54:21 - read only we'll make this list read only
54:23 - because we will only allow to construct
54:26 - it i mean to create it or instantiate it
54:29 - during a controlled construction time
54:32 - and after that there will be no need to
54:33 - modify the instance of this list
54:36 - so it's going to be list
54:39 - of item dto because uh uh this is going
54:42 - to be the list that we're going to be
54:44 - returning when somebody requests the
54:46 - items from our rest api so we want to
54:48 - specify the contract that we already
54:50 - find for our items here so item dto
54:54 - and then it's going to be named items
54:57 - equals new
55:00 - and so let's see we're missing some more
55:02 - next spaces here
55:04 - okay so i'll do ctrl dot again
55:06 - system collection is generic and we also
55:08 - need our
55:09 - play catalog service dtos namespace
55:12 - so let's find our first item here so
55:14 - i'll just define it in line here so new
55:17 - item dto
55:18 - for the id we'll just generate a
55:22 - generate a random good so a new good
55:26 - mainly another nice space import
55:30 - yup
55:31 - and for the name let's name this one
55:33 - potion
55:35 - the description is going to be
55:37 - restores a small amount of hp
55:43 - the price is going to be let's say five
55:46 - and for the created date let's just do
55:50 - the time of set that utc now okay it's
55:53 - going to be the the current time in utc
55:55 - time
55:57 - so let's add i'll just copy this to add
55:59 - two more items
56:02 - the second one is going to be let's say
56:04 - an antidote
56:06 - and so the antidote
56:08 - cures poison
56:10 - price is going to be let's say seven
56:13 - credit date is utc now
56:15 - and the last item is going to be
56:17 - let's say
56:18 - [Music]
56:20 - a brown sword
56:24 - and it deals a small amount
56:28 - of damage it's going to be a big price
56:31 - here let's say 20
56:32 - and yeah utc now
56:34 - column save
56:36 - okay
56:37 - also notice that we're using a static
56:40 - list here
56:41 - so we do this so that the list does not
56:43 - get recreated every time somebody
56:46 - invokes one of our res api methods right
56:48 - otherwise the list will be recreated
56:50 - every single time
56:51 - that a method is invoked which we don't
56:53 - want
56:55 - so now let's define our first operation
56:57 - this is going to be the operation that's
56:58 - invoked anytime somebody tries to get
57:01 - all the items that we have in the rest
57:02 - api
57:03 - so we're going to say
57:06 - public innumerable
57:09 - off item
57:10 - dto
57:12 - get
57:15 - okay
57:17 - and so
57:18 - yes we're returning a list
57:21 - of identito
57:23 - now each of your
57:25 - api operations should be
57:27 - a marked with the correct http verb
57:30 - right since this is going to be
57:31 - responding to our the get verb we should
57:34 - mark this with the http get attribute
57:40 - and then for for this method really is
57:42 - super simple we only need to return
57:45 - the current list of items right so we
57:46 - just return items
57:49 - so that's our first get operation the
57:50 - next one
57:51 - is going to allow us to return one one
57:53 - specific item so we'll name it
57:57 - public item dto
58:00 - get by id
58:05 - okay and then we're receiving the the
58:07 - specific id as a good
58:10 - and just like we did before we need to
58:12 - decorate this with the http get
58:15 - attribute
58:16 - but here we also need to specify
58:19 - uh what part of the of the route
58:22 - that the user specifies
58:24 - is going to map to that id so in this
58:26 - case we do that by specifying id here
58:29 - okay so that means that uh if somebody
58:32 - comes with and i'll put it so here so
58:34 - somebody go does it get
58:36 - there's a little comment here does it
58:38 - get into
58:40 - our items route
58:42 - and then they specify some id like one
58:44 - two three four five
58:46 - uh that one two three four five is one
58:48 - is is captured as the id in the http get
58:51 - route and that's mapped into the id
58:53 - parameter over here
58:55 - okay so the route would look more like
58:58 - in a more generic case it's going to be
59:00 - slash items slash
59:02 - id
59:04 - and so to do this the only thing we have
59:06 - to do is just find the correct item in
59:07 - our list so we'll say
59:09 - bar item equals items where and for this
59:13 - i'll need ctrl dot system.link
59:18 - so for each item we will do a item.id
59:22 - should match
59:24 - the id that we got in the parameter and
59:26 - then we will say okay so let's find the
59:28 - only
59:29 - the only item that should match with
59:30 - that id get that one
59:33 - otherwise i mean with single default we
59:35 - can say either get the item or just
59:37 - return null in this case
59:40 - and then we return that item
59:44 - okay
59:45 - so
59:46 - that's what we need uh for our get
59:48 - routes so let's try it out to see how
59:50 - that that goes so i'll hit f5 my
59:53 - keyboard
59:54 - to start a web server
59:57 - that opens the browser
59:59 - and let's now navigate to our swagger
60:01 - page so slash swagger
60:04 - and here you can see that we have our
60:06 - two first
60:08 - api operations defined items and items
60:11 - by id
60:12 - and we also have the the schema of our
60:15 - itunes dto showing up here right so if
60:17 - you expand this one we can see the shape
60:19 - of our item video right there
60:22 - so if you expand the items route
60:26 - you can see a little example here of
60:29 - what it would return
60:30 - and expected a return for a successful
60:32 - case and then if you want to try it out
60:34 - just have to click on try it out
60:37 - then you click on execute
60:39 - and here you can see the actual the
60:41 - request url that was invoked into our
60:43 - api
60:44 - slash items
60:46 - and then you can see the response body
60:48 - here along with the status code 200
60:51 - and the response body has the three
60:53 - items that we have in our static list so
60:56 - that's working fine
60:57 - and let's say that we want to try the
60:59 - other a operation where we have to
61:01 - specify an id so i'll just copy the id
61:03 - of one of these
61:05 - i'll collapse this for a moment i'll
61:07 - expand the other
61:09 - so this one expects an id this parameter
61:12 - so i'll do try it out
61:13 - i'll paste the id here and then i'll
61:16 - click on execute
61:19 - and just before it it will go ahead and
61:21 - use
61:22 - the items a route but it will append the
61:25 - id of the item
61:27 - and as you can see we got a 200 okay and
61:30 - we got in the body we got the actual uh
61:33 - the body of the of the item that it was
61:36 - retreat okay so that's working fine
61:39 - so let's now add a method for creating
61:43 - an item
61:44 - so minimize this stop debugging and then
61:47 - i'll close the terminal
61:49 - okay so to create items we're going to
61:51 - be using the post http verb and let's
61:54 - create a method for that so it's going
61:56 - to be
61:57 - public
61:59 - action result
62:01 - now the action result type uh so this
62:03 - one
62:04 - allows us to return a return a type that
62:06 - represents one of the several http
62:10 - status codes
62:11 - like 200 okay or 400 requests
62:15 - but it also allows us to return a more
62:17 - specific type like a dto type if we need
62:19 - to so we can return different types
62:21 - depending on what we have available so
62:23 - let's see how we're going to be using
62:24 - this
62:25 - um so action retooled off type
62:29 - item dto
62:31 - and it's going to be named let's just
62:32 - name it post for now
62:34 - and then
62:35 - here is where we're going to receive our
62:38 - create idm dto contract right so that in
62:41 - that way we enforce that uh whoever
62:43 - calls this this api has to follow our
62:46 - contract for creating items
62:48 - so create item dto
62:52 - and this one has to use
62:56 - also the correct http verb it's going to
62:57 - be http post
63:02 - and then for creating an item we will
63:03 - just create it in line here
63:06 - so
63:07 - i'll just say var item
63:11 - equals new item dto
63:15 - and we'll assign a random id here just
63:17 - like we did with the with the list
63:20 - you do it
63:21 - and then we will say for the name we'll
63:23 - say create ideo.name
63:26 - for the description
63:28 - that description
63:32 - for the price
63:36 - created you that price and for the day
63:38 - for the great date again
63:41 - daytime offset you'd see now
63:45 - so that's the item and now now that we
63:47 - got it we will just say
63:49 - items dot add
63:51 - to add the item to our to our static
63:53 - list
63:56 - finally we're going to return the type
63:59 - created action
64:01 - uh which is a is derived from action
64:04 - result so this so this is going to be
64:07 - used to say hey so the item has been
64:09 - created and you can find it at the
64:11 - following route uh which route is is
64:14 - going to be well is the route with the
64:16 - name
64:18 - so name of
64:20 - get by id so this means that uh the
64:24 - caller will be able to find i mean we're
64:25 - going to produce a heater in the
64:27 - response that includes the exact route
64:30 - of the item as provided by the get id
64:33 - operation over there
64:36 - we will also provide the id of the
64:38 - created item as an anonymous type here
64:41 - is going to be id equals item.id
64:47 - and lastly the actual
64:49 - the actual body of the response which is
64:52 - the entire item
64:54 - right
64:55 - so it's ready i'll do f5 so we can try
64:57 - that out see how that goes
65:00 - okay back here i'll just close this one
65:02 - so back into the previous tab i'll do f5
65:07 - as you can see now we have the
65:09 - the post operation listed here and the
65:12 - create item dto listed at the bottom
65:15 - so i'll go for post i'll expand this and
65:18 - to try it out i'll do try it out
65:23 - uh so here's where we can create a new
65:25 - item right so let's let's figure out
65:26 - some new item to create here let's say
65:28 - we're going to create a high potion
65:32 - and so this one is going to
65:34 - restore a medium
65:37 - restore
65:39 - restores a medium
65:41 - amount of hp
65:44 - and the price is going to be let's say
65:45 - nine
65:48 - okay and so now i'll do
65:50 - execute
65:52 - as you can see it invokes uh the same
65:54 - route
65:55 - but in this case it was with a
65:57 - with a post verb
66:00 - post
66:01 - and uh yeah so we got 201 which means
66:04 - created a created route create or
66:07 - created at
66:09 - here's a response body so the entire
66:11 - created item including the auto
66:12 - generated id over here
66:15 - and here you can see the heaters
66:16 - includes the location
66:19 - the location of the just created item so
66:21 - if i wanted i can grab this id
66:24 - and i can collapse let's call exposed
66:27 - and then expand get inside id
66:30 - try it out and i can paste that id here
66:32 - and i should be able to find that just
66:33 - created item
66:35 - as you can see
66:36 - or here's the high potion
66:39 - so post is working just fine
66:41 - so now let's say that we want to update
66:43 - an item so that's where we need to
66:45 - introduce the put
66:47 - the put operation
66:48 - so let's go back to our piece of studio
66:51 - code stop this and close terminal
66:55 - and let's declare a method to update
66:57 - items
67:00 - so for this term for this one i'm going
67:02 - to declare
67:04 - public action result and i'll be using i
67:07 - action result because in this case we
67:09 - don't really need a specific type for
67:11 - the return we will just return this one
67:13 - called no content meaning uh that's
67:15 - that's what um uh you usually do for a
67:18 - put operation you don't want to return
67:19 - anybody you just say hey uh yeah i did
67:22 - my job but there's nothing to return
67:25 - so it's going to be named put
67:31 - so we want to receive the id of the item
67:33 - to update and
67:34 - we will use the update item dto contract
67:37 - to receive
67:38 - the new
67:40 - the new payload or the new information
67:42 - for this existing item
67:44 - it's updated in dto
67:47 - and we also have to specify the proper
67:50 - verb so http put
67:54 - and just like we did with the get by id
67:56 - we have specify what part of the route
67:59 - is going to be used for the id parameter
68:01 - so just like before it's going to be id
68:05 - okay so once again when somebody comes
68:07 - with a something similar with get items
68:09 - by id
68:10 - somebody comes with uh not get but
68:13 - put items slash id and somebody then
68:17 - this is the operation that's going to be
68:18 - honoring that route
68:22 - so how do we implement this so the first
68:23 - thing that we want uh that we want to do
68:26 - is probably find the item that we're
68:28 - going to be updating
68:29 - so what i'll do is i'll just say
68:32 - existing item
68:35 - listing item is going to be
68:36 - done under items list
68:38 - uh
68:40 - items list where item
68:42 - uh item.id
68:45 - is the id that we distributed the
68:47 - parameter
68:48 - and then again singular default right so
68:50 - if you have it i will find it right
68:52 - there
68:54 - now we found the item we're going to
68:56 - update it and to update it we're
68:57 - actually going to do at this point is
68:59 - just
69:00 - clone it into a new item with the
69:01 - updated values so we will say
69:07 - updated item is going to be
69:11 - the existing item with
69:15 - the name that is going to be update item
69:19 - update item dto dot name
69:22 - description
69:24 - date item dto that description
69:26 - [Music]
69:28 - and price
69:30 - updated in dto
69:35 - price
69:38 - okay so that creates a clone of the
69:40 - existing item and the in into updated
69:43 - item and that's the one that we're going
69:44 - to be updating into the list
69:49 - okay so now we'll do is we're going to
69:51 - find the place in the list
69:52 - that uh that has the item that we need
69:55 - to update so to do that we're going to
69:56 - say
69:58 - so the index of that item is going to be
70:01 - in the list
70:02 - find index
70:08 - okay so it's going to be
70:11 - existing item.id
70:13 - equals id okay so that finds the index
70:15 - on that list where the item is and then
70:17 - now that we have the index we're going
70:18 - to say
70:20 - items index equals updated item
70:24 - replaces that in the list and then like
70:26 - i said we will just return
70:29 - no content
70:30 - there's nothing to return
70:33 - okay so let's try this out so i'll do f5
70:36 - once again
70:38 - start the web host
70:40 - and
70:41 - close this page and then i'll just
70:43 - refresh our swagger ui page and as you
70:45 - can see now we have our put operation
70:47 - here at the bottom and all the way to
70:49 - the bottom we also have our update item
70:51 - dto specified
70:54 - so i'll expand put
70:56 - this is going to require first the id of
70:58 - the item to update so to get an id i'll
71:01 - actually execute our get items route so
71:04 - i'll try it out
71:05 - execute
71:06 - and let's say we're going to update our
71:08 - antidote so i'll copy the id of the
71:10 - antidote
71:11 - collapse this
71:13 - and then back in the input i'll say try
71:15 - it out i'll put the id here
71:18 - and then let's grab a few of the
71:20 - properties of the antidote
71:23 - we don't have to start from scratch
71:24 - there
71:25 - collapse this and then i'll place those
71:28 - items here remove this comma
71:31 - and then let's say we want to update
71:32 - just the price and we'll say that the
71:34 - price the antidote is going to be let's
71:35 - say nine
71:37 - and i'll go ahead and do
71:39 - execute
71:41 - and as you can see in this time it
71:43 - invokes the api with a port with the put
71:45 - verb
71:46 - into this request url that includes the
71:48 - id of the item we get a 204 result
71:52 - meaning no content so as you can see
71:54 - there's nothing being returned here but
71:56 - the item was certainly updated and we
71:58 - can confirm that by grabbing the id of
72:00 - the item once again
72:03 - and going to our get items by id route
72:06 - we can try it out paste it there
72:09 - i'll execute
72:11 - and then you can see now we have the
72:13 - antidote with price nine
72:16 - so the update operation succeeded
72:19 - so finally let's add the operation to
72:21 - delete an item
72:22 - so let's minimize this once again stop
72:25 - and close
72:29 - and
72:30 - before adding our delete route just for
72:31 - completeness let me do let me add the
72:33 - comment here for our http post route
72:35 - which i did indeed didn't do
72:37 - uh this the post route is going to as we
72:40 - as we saw responds to the post verb and
72:43 - the browser is going to be like just
72:45 - items right so jose we have that comment
72:47 - over there
72:48 - now for the delete route
72:52 - uh is we're going to be using uh a
72:54 - method that is also be returning a
72:56 - action result just like in the boot case
72:58 - because we're not we're going to be
73:00 - returning no content here also
73:02 - and it's going to be delete
73:05 - and we're going to receive the only
73:06 - thing that we need to receive here is
73:07 - the id of the item to delete
73:10 - and we also have to respond to the
73:14 - http delete verb
73:16 - and again just with the we put we have
73:18 - to specify which part of the route we're
73:20 - going to be using for the id of the item
73:22 - to delete so that's going to be a id
73:25 - once again
73:27 - and here uh just like we did with update
73:30 - we need to find
73:31 - the index of the item to delete so i'll
73:33 - copy that line from put
73:35 - copy that
73:37 - into here
73:41 - okay
73:42 - and so once we found the index of the
73:44 - item to delete we're going to say okay
73:46 - so from the list
73:48 - remove add
73:50 - and we'll say index so that removes the
73:52 - item at that index location and then we
73:55 - will just return
73:57 - no content
74:01 - so again for completeness let's add a
74:03 - little comment here so when somebody
74:05 - comes with a delete verb
74:07 - and says lash items and then slash
74:11 - some id
74:12 - this is the method that's going to be
74:13 - honoring that that deletion
74:15 - so to try it out again i'll do f5
74:22 - okay so back in swagger ui i'll refresh
74:24 - the page
74:27 - and as you can see now we have our
74:29 - delete route a little operation showing
74:31 - up here
74:32 - and so i'll expand that so we need an id
74:34 - to delete
74:36 - so let's actually execute our get items
74:39 - route try it out execute so we can pick
74:41 - something to delete let's actually
74:43 - delete this antidote once again so let's
74:46 - copy the id of the antidote
74:50 - and so i'll go back to delete try it out
74:52 - i'll paste that id
74:54 - and then i'll hit execute
74:56 - and as you can see now we're using the
74:58 - delete verve
74:59 - invoking the api we delete
75:01 - here's a url of the of the item that
75:03 - needs to be deleted
75:05 - and we got a 204 no content so as you
75:08 - can see there's nothing returned but the
75:10 - item should have been deleted so if i go
75:12 - i'll collapse this and i'll go back
75:14 - again to our to our a get items route
75:19 - i'll to
75:20 - execute again
75:22 - and as you can see the item
75:25 - the antidote item has been removed it's
75:27 - not here so delete succeeded
75:31 - so yes rest api seems to be working just
75:33 - fine
75:34 - um
75:35 - however you can try querying for an item
75:38 - that uh that does not exist and exit on
75:40 - an existing item or perhaps creating an
75:42 - item that does not have a name uh what
75:44 - will happen in that case
75:46 - so we'll need to do something about
75:47 - those those situations
75:49 - uh in the next lesson we will see how to
75:51 - properly handle these kinds of invalid
75:54 - inputs
75:58 - let's try a few of the unexpected
75:59 - scenarios that our microservice dress
76:01 - api could face from time to time
76:04 - so i have our catalog project open here
76:07 - and i'll just do a five to start a web
76:09 - server and go to our swagger ui page
76:13 - so here we are in the browser i'll go to
76:15 - [Music]
76:16 - swagger
76:18 - and let's start by getting the full list
76:20 - of items as we have them right now so
76:22 - open our
76:23 - get items
76:24 - operation try it out
76:26 - click on execute
76:28 - and here are the three items that we
76:29 - have available right now
76:31 - so let's say i want to query for one of
76:33 - these items the potion
76:35 - so i'll copy the idea of the potion
76:37 - i'll close this and then i'll actually
76:39 - go to our get is by id operation
76:42 - okay so i'll do try it out i'll paste id
76:45 - here but i'll actually going to i'm
76:47 - going to flip a one of the characters
76:50 - here i'll flip this one to two so this
76:52 - is an on existing item we don't have
76:54 - that available and i click on execute
76:57 - see what we get
76:59 - so what we're getting is a 204 result
77:02 - right
77:03 - which is not expected when when an item
77:06 - is not found in the rest api the
77:08 - expectation is that you would return a
77:09 - 404 status code or not found
77:13 - so let's see what's actually happening
77:15 - back in visual studio code
77:17 - see where we're getting this
77:22 - so i'll put a breakpoint in
77:25 - over here in organic by the operation
77:28 - and then i'll go back to swagger i'll
77:30 - try this again
77:32 - so i'll hit execute
77:34 - and here we are this is studio code
77:36 - so we try to find the item and
77:39 - of course the item is two we cannot find
77:41 - it
77:43 - okay
77:44 - so
77:45 - what can we do about this
77:47 - let's see i'll just stop debugging here
77:49 - close terminal
77:50 - and so really the fix is fairly
77:52 - straightforward here
77:54 - um
77:56 - what we would like to do is just check
77:58 - that if the item
78:02 - is null
78:05 - we will go ahead and return not the item
78:08 - but would like to return the not found a
78:10 - action result
78:14 - however of course uh intelligence is
78:16 - complaining here because
78:18 - uh
78:19 - we
78:20 - not found does not convert into item dto
78:23 - here right so here's where action result
78:25 - becomes super useful
78:27 - now we can say
78:28 - action result
78:30 - of item dto and that gives us the
78:32 - ability to return it in the either the
78:34 - item over here
78:36 - or the not found result over here in
78:38 - this case so as you can see we can
78:39 - return more than one type of result
78:41 - depending on the current situation
78:45 - so let's try that out i'll hit 5 once
78:47 - again i'll remove this breakpoint first
78:49 - and then i'll hit a 5.
78:55 - okay
78:56 - so here we are again
78:58 - i'll just copy this id
79:01 - and refresh the entire page
79:03 - should still be and not found items so
79:05 - get items by id i click on try it out
79:09 - i'll paste that id here and i'll hit on
79:11 - execute
79:12 - see what we get
79:14 - so as expected this time we get a photo
79:17 - for
79:18 - a result saying not found so this is the
79:20 - correct status code
79:22 - for an item that cannot be found in the
79:24 - in the rest api
79:27 - and likely we're going to have the same
79:29 - issue with our put api
79:31 - right
79:32 - so let's see
79:35 - exactly which apis will be impacted so
79:37 - not post but put is going to be impacted
79:39 - because it needs to find the item
79:43 - and likely the delete operation could
79:45 - also be impacted because it needs to
79:46 - again find the item before it can delete
79:48 - it so let's start by fixing put
79:51 - [Music]
79:53 - it's going to be pretty similar
79:56 - basically if existing item
79:59 - is no
80:01 - we will
80:02 - say
80:04 - not bound
80:07 - okay
80:08 - so that will do it for put
80:11 - and then in the case of delete what
80:12 - we're going to do is
80:16 - just
80:17 - that if
80:19 - index
80:21 - is less than
80:22 - zero so basically a negative number it
80:25 - means that we cannot find the index of
80:26 - the item therefore we have to say
80:29 - return not found
80:33 - okay
80:34 - so i should do it i'll hit f5 and see
80:36 - what we get
80:40 - i'll close this
80:41 - and and i will um
80:44 - yeah i'll copy
80:46 - that's this id one existing id once
80:48 - again
80:49 - and i'll try to do a put operation now
80:52 - so i'll try it out i'll put this id here
80:56 - and uh
80:58 - i'll put just something here for the for
81:00 - the body
81:01 - so some item
81:04 - some item description
81:07 - and
81:08 - price too so just to try it out
81:10 - and so i'll go ahead and say
81:12 - execute and as expected now we can get a
81:16 - 404
81:17 - on that case
81:19 - not found
81:21 - i'll take that id once again
81:23 - and let's try out our delete operation
81:25 - so let's try to delete that an existing
81:27 - item
81:28 - see what happens
81:30 - so yeah as expected delete is also
81:32 - returning a 404
81:35 - so we can now say that we're probably
81:36 - handling the case of not finding items
81:38 - in in our different res api operations
81:42 - now let's try something actually
81:44 - different so what happens if we try to
81:46 - create an
81:47 - item
81:49 - with some missing item properties
81:52 - right so let me collapse this and
81:55 - collect this and then let's go to post
81:58 - okay
81:59 - so i'll try to post an item
82:02 - uh let's say without a name
82:04 - we shouldn't be allowed
82:06 - really
82:08 - and let's say that this was really for
82:10 - our high potion
82:12 - which the description would be
82:14 - restores a medium amount of hp
82:18 - and that price was five right
82:21 - perhaps seven
82:22 - and so let's try to create an item with
82:27 - no name
82:28 - so
82:29 - go ahead and hit execute
82:31 - go down
82:32 - and
82:34 - 201 meaning create an action so it
82:36 - actually got created but look at this
82:39 - the name is nu
82:40 - and if we try to query for that item
82:43 - with this this id
82:45 - so let's do get by id
82:48 - try to query for it
82:51 - as you can see the item is is now in our
82:54 - collection and is with a new name
82:57 - and not only that let's see what happens
82:59 - if we try to create it
83:01 - with a negative number right so not
83:04 - seven but let's say
83:06 - minus seven
83:08 - what happened in that case
83:10 - uh so let's do execute
83:12 - and again it got created to 201
83:16 - and then now we have this order id
83:18 - and so
83:19 - now this item actually has a
83:22 - a null name
83:24 - and a negative price
83:26 - so this is really bad so what what can
83:28 - we do about this situation
83:30 - um let's go back to visual studio code
83:33 - just open close
83:34 - and then i'll expand our navigation pane
83:37 - again
83:38 - so what we can do is actually do some
83:41 - model validation right so back to the
83:44 - dtos
83:45 - we need to introduce a couple of
83:47 - attributes to properly validate the
83:49 - inputs here
83:51 - and the details that we would care about
83:53 - in this case are both in the create and
83:55 - the update details
83:57 - so what we can do is let's say for the
83:59 - case of the name if the name is always
84:01 - required what we can say is just add
84:03 - this attribute here called required
84:06 - which might require a namespace import
84:09 - system company model data annotations
84:11 - import and that makes it so that name
84:14 - will always be required any time
84:16 - somebody uses this create iron detail
84:20 - okay and i'll also add it for our
84:23 - uh
84:26 - name
84:27 - name property in the updated identity
84:30 - and then also
84:32 - i'll do
84:33 - we can do something about the price so
84:35 - in the case of the price
84:36 - let's say that well let's add an
84:38 - attribute here and let's say that what
84:40 - we want to enforce is that the price
84:42 - should always be let's say between 0 and
84:45 - 1000g right let's say but we actually
84:47 - want to allow free items so they can be
84:49 - zero but definitely not negative and
84:51 - only up to a thousand so we can do is
84:54 - use a range attribute here
84:56 - and we can say here the minimum value
84:59 - which is going to be zero and the
85:00 - maximum value let's say it's going to be
85:02 - a thousand here
85:04 - okay so that makes it so that anytime
85:06 - somebody specifies a price here it has
85:07 - to be in this range
85:09 - that implicitly also makes sure that uh
85:12 - it cannot be null right but however i
85:14 - mean since if this is a value type
85:15 - decimal really this value can never meet
85:17 - dual so worst case it will be zero but
85:19 - with this we ensure that it has to be
85:21 - between zero and a thousand
85:22 - i'll do the same thing for our
85:25 - item detail hit save
85:29 - and now let's try it again so i'll hit a
85:31 - five
85:36 - okay
85:37 - back here
85:39 - and i'll go ahead and
85:42 - i'll just copy this
85:44 - and i'll refresh our page
85:46 - so let's go ahead and try to do a post
85:49 - try it out
85:51 - and so let's start first with no name
85:56 - so i'll say
85:57 - the same price is still positive but we
85:59 - don't have a name and let's try to
86:01 - execute this and see what happens
86:06 - so as you can see this time we do get a
86:08 - 400 but request error which is expected
86:11 - in this case and we do have a the proper
86:15 - validation message coming out of the the
86:18 - errors these errors array
86:21 - that is available now so one or more
86:23 - validation error secured status 400 and
86:26 - the name field is required so that's
86:28 - great
86:30 - and furthermore if we still want to use
86:32 - that negative number so i'll do -7 hit
86:36 - execute
86:38 - see now
86:39 - both validations have been performed so
86:42 - the name
86:43 - is name field is required and the field
86:45 - price must be between 0 and 1 000.
86:49 - you can also try using invalid input for
86:50 - our put api operation now and you should
86:52 - get similar validation errors
86:56 - in the next model we will learn about
86:57 - the repository pattern and we will stand
87:00 - up a proper database to store our
87:02 - catalog items
87:05 - in this model we will update our catalog
87:06 - microservice to be able to store and
87:08 - query for items that live outside of the
87:10 - service and into a proper database
87:15 - by the end of this model you will have a
87:17 - solid understanding of the following
87:20 - what is and how to use the repository
87:21 - pattern to store and query data
87:25 - how to use a mongodb database as the
87:27 - underlying data store of catalog items
87:31 - how to use docker to run infrastructure
87:33 - services like mongodb server
87:37 - what is and how to use the dependence
87:39 - injection technique for proper
87:40 - decoupling of dependencies
87:43 - and how to use the net configuration
87:45 - system to specify settings that could
87:48 - change across environments
87:51 - in this lesson we will learn about the
87:53 - repository pattern and how to implement
87:55 - a repository to manage the catalog
87:57 - service items in a mongodb database
88:01 - so what is a repository
88:03 - a repository is an abstraction between
88:05 - the data layer and the business layer of
88:07 - an application
88:09 - to understand why you may want to use a
88:11 - repository let's say that today we have
88:13 - the application logic of our service
88:15 - talking directly to our mongodb database
88:19 - however a few months or years from now
88:21 - requirements change and we need to
88:23 - switch to a different database provider
88:27 - given the way that things have been set
88:29 - up we would likely need to rewrite a
88:31 - good chunk of our application logic in
88:33 - order to talk to the new database which
88:35 - is pretty bad
88:38 - instead what we can do is introduce a
88:40 - repository
88:42 - this repository is the only one that
88:44 - knows how to talk initially to our
88:46 - mongodb database and is the only one
88:48 - that our application logic will
88:49 - interface with
88:51 - then if we ever get the requirement to
88:53 - move to another database the only thing
88:56 - that we would need to change is our
88:58 - repository but the application logic
89:00 - stays the same
89:03 - so the repository pattern is important
89:05 - because it decouples the application
89:07 - logic from the data layer
89:09 - and minimizes duplicate data access
89:10 - logic across our service
89:14 - we will be using mongodb as our database
89:17 - of choice for all the microservices in
89:19 - this course
89:21 - mongodb is a document-oriented non-sql
89:23 - database which stores data in a
89:25 - json-like documents with dynamic schema
89:29 - we will prefer a non-sql solution as
89:31 - opposed to a relational database for
89:33 - microservices because
89:35 - we won't need relationships across the
89:37 - data because each microservice manages
89:39 - its own database
89:41 - we don't need acid guarantees where acid
89:44 - stands for atomicity consistency
89:47 - isolation and durability which are
89:49 - properties of database transactions that
89:51 - we don't need in our services
89:53 - we won't need to write complex queries
89:55 - since most of our service queries will
89:57 - be able to find everything they need in
89:58 - a single document type
90:01 - and we need low latency high
90:02 - availability and high scalability which
90:05 - are classic features of nosql databases
90:09 - let's go ahead and implement our items
90:11 - repository
90:13 - before implementing a repository we will
90:16 - need to decide which is going to be the
90:17 - class that represents the objects that
90:19 - will be managed by the repository and
90:21 - that will make their way into our
90:22 - database
90:23 - the classes we use for this should not
90:25 - be confused with our details because we
90:27 - want to have the freedom of updating how
90:29 - we store the items in the database at
90:31 - any given point regardless of the
90:32 - contract that we'll need to honor with
90:34 - our service clients
90:36 - we will then give the name of entities
90:38 - to the classes that are repository use
90:43 - so let's start by adding a directory to
90:45 - store these entities so right click on
90:47 - play catalog service let's add a new
90:49 - folder let's call this one entities
90:53 - and inside entities let's add a new file
90:55 - and our main entity here is going to be
90:57 - the catalog items so let's just call
90:59 - this one
91:00 - item.cs and here let's go ahead and
91:03 - delete our namespace
91:06 - it's going to be namespace
91:12 - entities
91:15 - and now let's declare the class
91:21 - all right so our item entity is going to
91:23 - have
91:29 - a good
91:30 - which is going to be the id
91:32 - and let me ctrl dot to import the system
91:35 - a space
91:38 - it's going to need a name
91:43 - it also needs a description
91:49 - and we also need
91:52 - the price
91:55 - and finally we are going to need
92:00 - a daytime offset that's going to be the
92:01 - created date
92:04 - okay so now it's time to actually add a
92:06 - repository but before doing that we're
92:08 - going to need a nuget package the
92:11 - mongodb driver nuget package because
92:12 - this is the one that's going to allow us
92:15 - to actually interface with the bongodb
92:17 - database so to do that i'm going to do
92:20 - ctrl j in my keyboard to open the
92:22 - terminal
92:23 - and i'm going to switch to the directory
92:25 - where we have the
92:26 - catalog service so that would be
92:30 - a catalog service
92:31 - so then i'll just do
92:33 - net
92:34 - add package
92:36 - mongodb.driver
92:39 - so this will bring in a bunch of uh
92:41 - libraries
92:42 - that we're going to be using
92:44 - um
92:45 - for interacting with bungryb
92:47 - so and you can configure the the package
92:49 - was added if you click on play catalog
92:51 - service csprock you'll see that we have
92:54 - the new library right here
92:56 - okay so now uh let me just close this
92:59 - terminal
93:00 - and now we can actually create a
93:01 - directory for our repositories so i
93:03 - right click play catalog service new
93:06 - folder repositories
93:09 - and in this folder i'll create a new
93:12 - file uh again since this repository is
93:14 - going to be managing our catalog items
93:16 - i'll name it
93:18 - items repository
93:21 - that's yes
93:23 - and at this point i'll just close this
93:25 - navigation pane so we get more space
93:29 - let's add a namespace
93:33 - it's going to be repositories
93:37 - and the name like we said
93:41 - public class items repository
93:46 - okay in order to be able to interact
93:48 - with mongodb we're going to need a few
93:50 - class level variables here
93:52 - the first thing that we're going to
93:53 - define is actually a constant
93:58 - we're going to name it
94:00 - collection name
94:02 - collection
94:06 - name
94:08 - which is going to be the value is going
94:10 - to be just items so the collection name
94:12 - represents the group a a collection
94:14 - represents a group of objects in mongodb
94:17 - similar to us in a relational database
94:19 - you will have a table in mongodb you
94:21 - have a collection okay so the collection
94:23 - that we're going to store all these
94:24 - items in mongodb is going to be named
94:26 - items in our case
94:29 - now we're going to define the variable
94:30 - that's going to hold the actual instance
94:33 - of this mongodb collection so let's name
94:36 - this one
94:38 - read only i
94:40 -  collection
94:43 - of item
94:47 - db collection
94:49 - okay so i'm i'm going to need to start
94:51 - importing spaces here so ctrl dot to
94:54 - import mongodb the driver
94:57 - and ctrl dot to import play catalog
94:59 - service entities like i said dvd
95:01 - collection is the object that represents
95:03 - our actual mongodb collection
95:08 - we'll add one more
95:09 - class level viral here to
95:11 - represent the the the filter builder
95:14 - that we're going to be using to build
95:16 - the filters to query for items in the
95:19 - mongodb
95:20 - so
95:22 - let's declare a filter
95:24 - definition builder
95:26 - of type item
95:29 - let's name it filter builder
95:32 - and we can get that from builders
95:36 - of item
95:37 - dot filter
95:39 - now that we have that we can go ahead
95:41 - and declare the constructor of this a
95:43 - repository
95:45 - so
95:46 - public items repository
95:50 - and here what we want to get is to
95:52 - actually construct the instance for db
95:54 - collection but before we can do that we
95:56 - have to start by
95:58 - using the client class which is
96:00 - the one that you can use to actually
96:01 - connect to the database here's where you
96:02 - declare how you're going to connect to
96:04 - mongodb
96:05 - so we're going to say client
96:09 - equals new
96:11 -  client
96:14 - and here we can specify the connection
96:17 - string to connect to mongodb for now
96:19 - we'll just declare this connection
96:20 - string
96:21 - right here in plain text but later on
96:24 - we'll move this connection into a more
96:26 - to a more suitable place
96:28 - so it's going to be mongodb
96:31 - localhost
96:33 - 27 0 17.
96:37 - also in a future lesson we will learn
96:38 - how to actually stand up that mongodb
96:40 - server so that it actually lives in
96:42 - localhost 27017.
96:45 - now we're going to declare the object
96:46 - that represents the database the actual
96:48 - database where these
96:50 - catal guides are going to live so
96:53 - database
96:55 - equals mongol client
96:58 - get database
97:00 - and then the name that we're going to
97:01 - give to this database since this is the
97:03 - catalog microservice the name is going
97:05 - to be just catalog
97:08 - finally we can give get an instance for
97:10 - db collection and we can do that
97:13 - by doing
97:14 - database
97:16 - that get collection
97:18 - of item and then we give it the
97:21 - collection name that we have already
97:22 - declared
97:24 - okay we'll be using this divi collection
97:26 - object for a few a few operations in a
97:29 - moment
97:30 - now for the repository public methods we
97:32 - will be using the asynchronous
97:33 - programming model this will avoid
97:35 - performance bottlenecks and enhance the
97:37 - overall responsiveness of our service
97:40 - to take advantage of this model all
97:42 - fermenters will become asynchronous by
97:43 - returning asynctask and by using the
97:46 - await keyword anytime they interact with
97:49 - the database
97:50 - we will also use the async suffix on all
97:52 - the methods to surface the fact that the
97:54 - methods are asynchronous
97:57 - okay so the first method that we're
97:58 - going to implement is the one that's
97:59 - going to be able to return all the items
98:02 - in the database so let's name this one
98:05 - fully async task
98:07 - of i read only
98:12 - collection of item
98:16 - get all async
98:20 - okay so i'm using a i'm using a
98:22 - namespace here so like i said we need to
98:24 - return task to make this method async
98:27 - and i'm also using i read only
98:28 - collection here because really the
98:31 - expectation from the the point of view
98:32 - of the consumer is that we're going to
98:34 - provide a collection of items
98:36 - that the the consumer should not need to
98:38 - modify so this is a collection that
98:40 - should only be read right so this is a
98:42 - good api pattern to follow
98:46 - how with this collection of items so
98:48 - basically we can do
98:50 - return await
98:53 - tv collection then we can do find define
98:56 - operation
98:58 - and here since we are not going to
98:59 - really provide any filter because we
99:00 - want all the items we can just say
99:03 - filter builder dot empty
99:09 - delete sync
99:11 - to convert that list into an
99:12 - asynchronous
99:14 - list and then yeah that will give us all
99:16 - the items in the database
99:19 - okay so let's now declare a method that
99:21 - we can use to get one specific item from
99:22 - the database so i'm going to declare
99:25 - public async again task of item in this
99:30 - case
99:31 - and we'll name this method get async
99:35 - it's going to receive a good it's going
99:37 - to be the id
99:38 - of the item and i'm going to import the
99:41 - system in space for this
99:44 - okay let's scroll down a bit
99:48 - and then
99:49 - to be able to query for this item we
99:50 - need to create a filter so i'm going to
99:52 - declare a filter definition
99:55 - of type item
99:57 - let's name it filter
100:00 - and then
100:02 - we're going to use the filter builder
100:04 - to say that we want to build an
100:06 - equality-based filter
100:11 - we're going to receive this this entity
100:13 - object
100:14 - where the entity.id
100:16 - should match the id of the of the
100:19 - parameter that we just received okay so
100:21 - that's how you can build a filter to
100:22 - find a
100:24 - one of the items based on id
100:27 - then we can just say return await db
100:30 - collection
100:32 - find
100:33 - that we provide the filter
100:36 - and we'll say
100:38 - we want to get the first item that we
100:40 - find so we're going to use first or
100:41 - default async in this case
100:44 - so that will find the first item in that
100:46 - collection that matches that filter
100:48 - let's now add a method to be able to
100:50 - create an item into the database
100:52 - so to do that we can define
100:55 - fully case in task
100:59 - create async
101:02 - receive
101:03 - our item that we're calling it an entity
101:06 - here
101:07 - and the first thing we're going to do is
101:08 - a quick check uh to make sure that the
101:10 - that receive parameter is not null so
101:15 - if entity is no
101:18 - we're just going to run a section
101:20 - [Music]
101:23 - argument exception and we're going to
101:24 - name
101:25 - and give the name of our entity
101:28 - parameter
101:31 - okay and then to create the actual item
101:33 - is as easy as saying
101:35 - um
101:36 - await the collection
101:42 - insert one async and then we provide
101:45 - right so that will go ahead and create
101:47 - the item into the database
101:49 - the next method we're going to implement
101:50 - is i want to update an item an existing
101:52 - item into the database so to do that i'm
101:55 - going to declare
101:56 - public async task of data is sync
102:02 - notice that both create and update are
102:04 - not returning really anything so the
102:06 - citation is that we just insert or
102:08 - update the item but we're not going to
102:09 - return anything back to the client
102:12 - um
102:13 - here we're going to receive
102:14 - the item to update
102:16 - let's call it entity that's the item to
102:18 - update
102:23 - all right
102:24 - and just like we did with create let's
102:26 - do a quick check make sure that we're
102:27 - not getting an old value here
102:31 - and now we're going to build our again
102:32 - our first definition to be able to find
102:34 - that item and i'm going to copy the one
102:36 - from get async just because it's a very
102:38 - similar filter
102:39 - the only difference here is going to be
102:41 - that we're going to rename this this
102:43 - parameter here to
102:45 - existing entity just to not confuse
102:48 - with the the entity that we're going to
102:50 - use to find the id so we're going to say
102:53 - we need to find the existing entity
102:55 - whose id matches the entity that we
102:57 - received
102:58 - that id
103:00 - so that's a filter to find the existing
103:02 - item and then we can go ahead and say
103:04 - weight the collection dot
103:07 - replace one async
103:10 - we pass the filter
103:12 - and we pass the entity that has to
103:14 - replace the existing item found by that
103:17 - filter
103:18 - and finally let's implement the mentor
103:20 - to delete an item from the database
103:22 - so we're going to say
103:26 - public acing
103:28 - task
103:29 - it's going to be remove async
103:33 - you find the id of the item to
103:36 - to delete
103:38 - again we're going to use a filter very
103:40 - similar to the one we use for
103:42 - get async so i'm going to copy that one
103:44 - once again
103:45 - so copy that
103:48 - that finds the item
103:49 - and then we can say
103:51 - weight db collection
103:54 - delete one async
103:57 - and we pass the filter
104:00 - yep that should go ahead and
104:02 - delete the item from the database
104:05 - and with that our itunes repository is
104:07 - ready
104:09 - so in the next lesson we will integrate
104:11 - it with our existing isis controller so
104:13 - that it can start creating items from
104:15 - mongodb
104:18 - it is time to integrate our new items
104:20 - repository with our existing items
104:22 - controller
104:24 - but before we can do that we are going
104:25 - to need a wait a way to translate our
104:28 - new item entities into our existing item
104:32 - dto
104:33 - specifically for the purposes of
104:34 - returning these ctos in our
104:37 - get operations in the rest api
104:39 - so there's a few ways to do this but one
104:41 - simple way that we can achieve this is
104:42 - by introducing an extension method so
104:44 - let's see how to do this we're going to
104:46 - right click on play catalog service and
104:48 - we're going to add a new file that we're
104:50 - going to name
104:51 - extensions that's cs
104:55 - let's add any space here
104:57 - namespace
104:59 - play catalog service
105:03 - and here we're going to declare
105:08 - a class that we're going to name those
105:09 - extensions
105:12 - and in this one we declare
105:14 - a public static
105:17 - method that returns itdto
105:19 - and this is because all extension
105:20 - methods should be
105:22 - should be static
105:24 - and we're going to name it as dto
105:27 - so this method is going to receive a
105:28 - current instance of an item entity
105:33 - okay and then let's import namespace
105:36 - control dot play catalog service ctos
105:39 - and
105:40 - play catalog service entities
105:42 - okay so the purpose is to just turn the
105:44 - item entity into the item dto and to do
105:46 - that we just have to do
105:48 - return new item dto
105:52 - and we're going to provide here the
105:54 - different parameters right everything
105:55 - comes from the entity so item id
105:59 - item that name
106:00 - item description
106:02 - item the price and item that created
106:06 - date
106:07 - okay so as you can see it's a very
106:08 - simple method that just turns an item
106:10 - into an identity
106:11 - we'll see how we use this in our
106:13 - controller
106:15 - so now let's open up that controller so
106:17 - controllers items controller and i'm
106:20 - going to close the navigation pane once
106:21 - again to have more space
106:24 - and the first thing that we're going to
106:25 - do is to actually get rid of this list
106:28 - we don't need it anymore
106:30 - and we're going to replace it with a
106:32 - variable for our repository so it's
106:34 - going to be private
106:35 - again read only because we don't want it
106:37 - to be modified after construction
106:40 - items
106:41 - repository
106:47 - and we're just going to say new so it's
106:50 - going to get constructed
106:52 - when the controller gets constructed i'm
106:53 - going to import the writing space here
106:58 - so let's start using this item
106:59 - repository here
107:00 - however since you remember all of the
107:03 - methods in itunes repository i are
107:05 - asynchronous methods we will also have
107:07 - to turn all the metals in this
107:08 - controller into asynchronous methods
107:10 - that way we can have the asynchronous
107:12 - benefits all the way from the controller
107:14 - all the way to the
107:15 - to the repository and to mongodb
107:17 - so to do that i'm going to turn
107:19 - let's start with get the get all so
107:22 - we're going to turn this into async
107:25 - task of innovable of identito
107:29 - and we're going to append the async
107:31 - suffix to this method
107:33 - let's import a missing
107:35 - treating tasks
107:40 - and now to return the items well this is
107:41 - what we can do
107:43 - items is going to be
107:47 - weight
107:48 - item repository
107:50 - get all async
107:52 - okay
107:53 - and then from that we're going to
107:56 - project these items into these item
107:58 - entities into dtos before we can do that
108:01 - we have to
108:02 - put this into a parenthesis
108:05 - and then we can say okay so from that
108:07 - let's do
108:09 - select
108:11 - and each of the item entities is going
108:13 - to be turned into a dto via our new
108:16 - astitu extension method that's there you
108:18 - can see how it how easy it makes it this
108:21 - extension method to turn an existing
108:23 - entity into a dto
108:25 - and then we just return those items
108:28 - okay so let's go to the next method so
108:30 - this is get by id so once again we will
108:33 - turn it into async task
108:36 - of action result of it and dto
108:39 - get item get by id async
108:43 - and then to get the item
108:44 - what we're going to do now is just
108:47 - wait i can repository
108:50 - get
108:51 - async
108:53 - and we provide the id
108:56 - and at the end of this method we can
108:57 - just return that item entity we have to
108:59 - say as dto so that turns the entity as
109:02 - into a dto
109:04 - let's now go for the post method
109:06 - let's scroll down a little bit
109:11 - so once again this has to be an async
109:15 - task
109:17 - of action result of identity
109:20 - and it's going to be post async
109:26 - task instead of doing this we're going
109:29 - to uh
109:31 - create an item entity in this case out
109:33 - of the properties of create identity so
109:35 - we're going to say bar item equals new
109:40 - item and we're going to start giving it
109:43 - the the properties values so
109:46 - create individual name
109:48 - description
109:51 - description
109:56 - and create a date
109:59 - uh here's where we're going to give the
110:01 - current date as the creation date of
110:04 - this
110:05 - of this item
110:07 - also remember this is not identity or
110:08 - this is just item
110:13 - okay i may need a name space here yeah
110:16 - empty disney space
110:19 - now we can go ahead and actually create
110:21 - the item via our
110:23 - items repository
110:25 - that create async methods and then we
110:28 - pass the item
110:31 - and finally we have to rename this
110:33 - method from get the id to the new name
110:35 - which is get via the async the one that
110:38 - we just renamed
110:39 - because that's where the created action
110:41 - should point to
110:43 - let's now go ahead and implement our
110:45 - boot method
110:47 - scroll down
110:49 - so once again we turn this into public
110:52 - async
110:54 - task
110:55 - of i action result
110:57 - put async
111:01 - and once again we have to do things a
111:03 - little bit different now
111:05 - so i'm going to actually remove this
111:07 - this whole block here
111:09 - and first thing we're going to do is
111:11 - find the item now in the via the
111:12 - repository so it's going to be existing
111:16 - item
111:18 - we're going to see it's going to be
111:19 - await item repository that gate async
111:24 - notice also how easy it is to actually
111:27 - interface with mongodb via our item
111:28 - repository without having to write the
111:30 - same piece of code once and again right
111:32 - at the filters and all that so we just
111:34 - got the item just like that
111:38 - and then
111:39 - yeah if you if we cannot find the item
111:42 - in the database in which case it will
111:43 - return no
111:46 - we want to keep returning
111:49 - not found just like before
111:53 - and here once we find the item we will
111:56 - have to just update these properties
111:57 - based on update item dto so that's going
112:00 - to be
112:01 - existing item that name
112:04 - equals update identity of that name
112:07 - existing item the description
112:10 - date identity of that description
112:12 - and existing item that
112:14 - price of the identity of that price
112:20 - and with that we can go ahead and say
112:22 - await item repository
112:25 - update async with the existing item
112:29 - and finally let's go ahead and update
112:31 - our delete method
112:34 - so we're going to say
112:36 - again
112:37 - async task
112:40 - i can result delete async
112:46 - and we're going to do a similar logic to
112:49 - find the item as we just did with update
112:51 - so i may just copy this piece here
112:56 - okay i'm actually going to remove all
112:58 - this
112:59 - paste that
113:02 - okay i'm going to say
113:04 - so yeah so var item is dedicated async
113:07 - if the item is no we'll say not found
113:11 - and otherwise we can go ahead and say
113:14 - weight
113:15 - item repository
113:17 - dot remove async with item that id
113:22 - and then one last thing that we may want
113:23 - to tackle here since we are making these
113:26 - changes is to actually um
113:29 - fix an issue a kind of a breaking change
113:32 - that happened in asp.net core 3 where if
113:35 - you try to do let me go back to post if
113:38 - you have to do a post and do create an
113:40 - action into a method that ends with
113:42 - async with an async suffix uh that's
113:45 - actually not going to work because at
113:47 - runtime uh
113:48 - sp netcore is going to remove the async
113:51 - suffix
113:52 - from the method and that will make it so
113:54 - that created action will not be able to
113:56 - redirect to the right place or to
113:58 - prevent to produce the heaters that it
114:00 - needs to produce and so there's an easy
114:01 - fix for that so let's actually make that
114:03 - fix right away so i'm going to back
114:05 - going to go back to explorer
114:07 - going to open startup
114:10 - and let's locate the section
114:12 - where we do add controllers in configure
114:13 - services inad controllers
114:15 - we're just going to add a little option
114:17 - here
114:18 - so it's going to say
114:20 - options
114:23 - and then we open and close
114:25 - braces and we're going to say options
114:28 - that
114:29 - suppress async suffix
114:31 - in action names is going to be false
114:36 - and with that at runtime uh asp.net core
114:39 - is not going to
114:40 - remove the
114:41 - async suffix from any any four metres
114:45 - and that will make possessing work just
114:46 - fine
114:48 - so a rest api is ready to use our new
114:50 - repository to store and query the items
114:52 - in the mongodb database however we still
114:54 - don't have an aqua mongodb database or
114:57 - even a mongodb server
114:59 - but that's a problem that we can easily
115:00 - solve via docker
115:02 - in the next lesson we will learn about
115:04 - docker and how we can use it to run the
115:06 - infrastructure components needed by our
115:08 - microservices
115:12 - in this lesson we'll learn about docker
115:14 - and how it can be used to run
115:16 - infrastructure components needed by your
115:17 - microservices
115:20 - so what is docker
115:22 - docker is a platform that provides the
115:24 - ability to package and run an
115:25 - application in a loosely isolated
115:27 - environment called a container
115:30 - here's how it works we start with our
115:33 - catalog service which as we know needs a
115:35 - database to store and query for items
115:38 - the piece of software that knows how to
115:40 - stand up and operate this database in
115:42 - our case is mongodb
115:44 - the mongodb server along with all the
115:46 - software prerequisites has already been
115:48 - packaged in what we call a docker image
115:52 - and this image is publicly available in
115:54 - a place called docker hub
115:57 - we want to download and run this image
115:59 - in our box and to do that we use the
116:01 - docker engine
116:03 - which is one of the pieces that you
116:05 - installed at the start of this model
116:08 - all docker images are guaranteed to run
116:10 - anywhere the docker engine is available
116:13 - to pull and run this image we will use
116:15 - the docker run instruction in our box
116:19 - once the image is run or executed it
116:21 - becomes what is known as a docker
116:23 - container
116:24 - a mongodb container in this case
116:27 - this is a fully working mongodb server
116:29 - ready to respond to the requests of our
116:31 - catalog microservice
116:34 - the catalog service will create a
116:35 - database via the mongodb container and
116:38 - will start interacting with it via the
116:39 - mongodb driver4.net
116:42 - notice that even when this container
116:44 - manages the catalog database the
116:46 - database itself does not live inside the
116:48 - container but outside of it to ensure
116:50 - that it is not deleted once the
116:52 - container is destroyed
116:54 - let's try it out
116:58 - to start using docker in my box i'll
117:00 - start by opening a terminal so i'll
117:02 - press ctrl j
117:04 - and then i'll also close our navigation
117:06 - pane just so we have a bit more space
117:09 - and the first thing that i'll do is i'll
117:10 - just type docker run to run a container
117:13 - and then i'll specify the demodifier so
117:16 - that we don't keep being attached to the
117:18 - docker process all the time
117:20 - and then i'll do
117:22 - rm so this we'll use so that whenever we
117:26 - stop running the container it gets
117:28 - automatically deleted so that we don't
117:29 - keep hanging it around in the box
117:33 - next i'll specify a name
117:36 - which is going to be
117:37 - just so you can put any name here
117:39 - but the idea is that uh you don't lose
117:41 - track of this a docker container because
117:43 - otherwise you get a random name and it's
117:45 - a bit hard to identify
117:48 - next we have to specify a port so we
117:50 - have to specify which is the port that
117:52 - we're going to be using to talk to
117:53 - mongodb the among the v server so we'll
117:55 - specify
117:56 - p
117:57 - 27 0 17 map to 27 0 17. so this means
118:02 - that in order for us to reach the
118:05 - mongodb container we can use port 27017
118:08 - is the external port
118:10 - and then uh in order to
118:12 - to to get that mapped into the internal
118:15 - mongodb server we have to map into 27017
118:18 - also so this port is the default port
118:20 - that mongodb uses internally and this
118:22 - just means that from the outside we open
118:24 - kind of a window uh in order to talk to
118:27 - the container via 27017 and then that
118:29 - can be mapped into the internal port
118:31 - where mongodb is already listening
118:33 - you could be using any port in the left
118:35 - side as really up to you we're just
118:37 - choosing a default map in there
118:39 - then we'll specify a volume the volume
118:42 - we're going to be using so that we
118:43 - specify how we are going to store the
118:46 - database files that mongodb is going to
118:48 - be using so we're going to say
118:50 - mongodb data
118:52 - colon slash data slash db so this
118:56 - section on the right side of the column
118:57 - slash it is tv is a default location
119:00 - where mongodb stores the database files
119:03 - so this mapping means that any time that
119:05 - the mongodb server tries to store files
119:08 - inside the container under slash data tv
119:11 - those files are actually not going to be
119:13 - written inside the container but outside
119:15 - of the container into this location
119:17 - called mongodb data which is part of our
119:19 - local localhost machine so it's outside
119:22 - of the container so this is the way that
119:23 - we can prevent
119:24 - those database files from being deleted
119:26 - anytime the docker container gets also
119:28 - deleted
119:30 - and finally we'll specify the name of
119:32 - the docker image that we want to run in
119:34 - this case is
119:36 - now i'll hit enter
119:39 - i'll perhaps expand this a little bit
119:40 - more
119:42 - so at this time uh docker is pulling the
119:45 - all the layers of of the mongodb docker
119:47 - image into my box
119:49 - okay so layer by layer it gets unloaded
119:51 - uh just the first time uh and this this
119:54 - may take a while but the second time
119:56 - that you do this and any subsequent time
119:58 - this is going to be much faster because
119:59 - the image is already there so if i did
120:02 - if i did that again it will run
120:04 - instantly
120:06 - then we can confirm that the docker
120:07 - image is actually executing by just
120:09 - running docker ps
120:13 - as you can see the docker image is up
120:15 - and running it's been running for 14
120:16 - seconds right now
120:18 - okay so now we can try running our res
120:21 - api against this soccer container and
120:23 - see how that goes so i'll hit a five
120:25 - here
120:30 - and i'll go to our swagger page
120:34 - so the first thing that we can try just
120:36 - to verify that there's nothing here
120:37 - because it's a brand new database is our
120:39 - get all items um operation so i'll try
120:42 - it out
120:43 - i'll hit execute
120:45 - and as you can see there's nothing in
120:46 - there the databases is all empty
120:49 - so let's next let's try creating
120:52 - something so i'll go to our post
120:53 - operation try it out
120:55 - and let's let's try to create something
120:57 - here
120:58 - so we will go back to our
121:00 - back to our potion sample so i'll just
121:02 - name this potion
121:04 - and this is going to
121:06 - restore a small amount
121:09 - of hp
121:10 - and the price is going to be five
121:13 - and with that i'll hit execute
121:18 - and as you can see the item has been
121:20 - created we got a 201 response code
121:22 - create that action here's a response
121:24 - body and we also got the location here
121:27 - to find our item
121:28 - so in fact we can copy the this id of
121:31 - this item and we should be able to use
121:33 - our get by id operation to find it so
121:35 - i'll collapse this i'll expand get items
121:37 - by id
121:39 - i'll try it out
121:41 - paste the item here
121:42 - execute
121:44 - and certainly we can find the item
121:47 - so the item has been stored into the
121:48 - database
121:50 - but now if you wanted to know how this
121:52 - item has been stored into the mongodb
121:54 - database there's an easy way to figure
121:56 - that out so i'll go back to visual
121:58 - studio code
122:00 - and then i'll just stop and close this
122:03 - and what you can do is use a mongodb
122:06 - extension for visual studio code so to
122:08 - install that just go to the extensions
122:10 - hub on the left side
122:12 - look for mongodb
122:15 - and should be the first hit on the left
122:17 - side so i click on that i'll click on
122:19 - install
122:21 - and now there's a new icon showing up on
122:23 - the left side for mongodb which i'll
122:25 - click now
122:27 - and then i it should connect
122:29 - straightforwardly into the mobile dvd
122:31 - database just by expanding this node for
122:33 - localhost 27017 since it's the default
122:35 - port it just connected so i'll expand
122:38 - this
122:39 - and as you can see there's a catalog
122:40 - database available right there
122:43 - so it has been created if i expand that
122:45 - there is an items collection available
122:48 - this is the one that we will be storing
122:49 - our items and then i'll expand that
122:51 - further
122:53 - and as you can see there is one document
122:55 - already created into the catal database
122:58 - if we expand that we can see that
123:01 - there's an item in there
123:03 - however if we try clicking clicking on
123:05 - it let's click on it
123:07 - but you can see you can see
123:09 - most of the members of the created item
123:12 - but some of them are not easy to
123:15 - recognize like for instance the id is
123:17 - not the gui that we were expecting and
123:19 - the created date is a bit hard to read
123:22 - the other elements are there so potion
123:24 - description and price
123:26 - so how can we get a better a more
123:29 - friendly uh
123:31 - the more friendly representation of
123:33 - these items like id and created date so
123:35 - ideally we want to see something more
123:36 - easily recognizable
123:38 - so there's actually an easy way to to
123:40 - fix this let's go back to our explorer
123:45 - and let's go to our startup class
123:49 - okay once again i'll collapse this
123:52 - so to fix the json representation of our
123:54 - items we just need to register a couple
123:56 - of mongodb serializers we can do this in
123:58 - the configured services method of the
124:00 - startup class
124:02 - we will talk more about the role of
124:03 - startup in acefinite core apps in next
124:05 - lesson but for now let's just think of
124:08 - your services as the place where we
124:10 - register services that can be used
124:11 - across entire application so let's
124:13 - scroll down a little bit here we are in
124:15 - configure services
124:16 - and what i'm going to do is just expand
124:18 - this a bit
124:19 - and i'm going to add
124:22 - visual serializer
124:25 - and for this i may need to import
124:27 - namespace mongodb that based on that
124:29 - serialization
124:31 - that register
124:33 - serializer
124:36 - and here we're going to provide the
124:37 - serializer we want to use in this case
124:39 - it's going to be new
124:41 - good serializer
124:44 - and then i'll import mongodb bsun
124:46 - serialization serializers
124:49 - and then it's going to be
124:51 - and type
124:52 - and then import one more namespace
124:55 - that string
124:57 - okay so that means that anytime we store
125:01 - any
125:02 - document into mongodb
125:04 - with a good type it will be stored
125:07 - actually as a string as opposed to the
125:08 - representation that we're looking at a
125:10 - moment ago
125:11 - and we're going to do pretty much the
125:13 - same thing
125:14 - for our the datetime offset so in this
125:17 - case we're going to say so
125:18 - instead of quick serializer we'll use
125:20 - date time offset serializer
125:23 - and then this line now says that anytime
125:25 - we store any document with a datetime
125:27 - offset a property it should be stored
125:30 - that probably should be stored as a
125:31 - string
125:34 - so save that and that should be enough
125:36 - to fix our representation of the items
125:38 - in there however uh to to not mix things
125:41 - what i'll do now is i'll actually delete
125:44 - our existing database so that we can
125:45 - recreate it with the proper esterization
125:47 - type so i'll close this here and i'll go
125:50 - back to our mongodb extension
125:52 - and i'll right click in the catalog
125:54 - database i'll say drop database
125:57 - i'll type the name
125:59 - enter and if we refresh this there
126:01 - should be no database available anymore
126:05 - okay so with that
126:07 - let's hit f5 once again
126:13 - okay back in soccer ui let's see if we
126:16 - still have the post available here yes
126:18 - we have
126:19 - so i'll just refresh the page
126:22 - and i'll go back to post
126:24 - and once again we should have no items
126:27 - so actually i'll go to get all items try
126:29 - it out execute so there's no items
126:31 - because a new database has just been
126:33 - created because we deleted the previous
126:35 - one so back into post
126:37 - i'll try it out
126:39 - and i'll paste the what we typed a
126:41 - moment ago so it's a potion price five
126:43 - restore small amount of hp
126:45 - and i'll hit execute
126:47 - and once again the item has been created
126:49 - with this id
126:51 - and this time we'll go back to visual
126:53 - studio code
126:55 - and let's see how that got stored so
126:57 - i'll refresh this right click refresh
127:00 - expand catalog items documents and as
127:03 - you can see the id it already looks like
127:05 - a good and if i click on it
127:08 - and i'll close this a bit now we have a
127:10 - much friendly representation of the item
127:12 - the id is a proper good
127:14 - and the created date is a daytime offset
127:17 - that we can actually understand
127:19 - so that's the effect of using these
127:21 - serializers in there
127:22 - so let's continue using our res api
127:24 - let's make sure all the operations are
127:26 - working properly so as we saw we just
127:28 - created this item
127:30 - and if we use get items by id we should
127:33 - be able to find it so let's confirm that
127:36 - paste it there execute
127:38 - so yeah indeed we were able to find the
127:39 - item
127:41 - now let's try an update on an item so to
127:44 - do that let's use the put api so i'll
127:46 - click and expand this i'll say try it
127:49 - out let's grab the actually the id of
127:51 - that item once again
127:53 - so it's over here
127:54 - here's the id
127:55 - so i'll paste it here so we're going to
127:57 - update that potion
127:59 - and then for the
128:00 - for the elements of this
128:04 - of this potion let's copy also a few of
128:06 - the existing elements
128:08 - so i'll copy this from our gave id route
128:11 - into here
128:13 - actually inside
128:15 - there i'll remove this extra comma
128:18 - and so the only thing we're going to
128:19 - define here is just the price of the
128:20 - potion so instead of being five i'll say
128:22 - it's going to be price seven
128:26 - and i'll hit execute
128:28 - i've got a 204 so no content
128:31 - successful no content so this means that
128:33 - the item has been updated and to confirm
128:35 - that let's go back again into our get by
128:37 - id route
128:39 - let's execute again
128:42 - and as you can see the price has been
128:43 - updated so output route is working just
128:46 - fine
128:48 - and for the final exercise let's try to
128:50 - delete this potion right so i'll go
128:53 - ahead and copy
128:54 - again the id of the position
128:57 - and let's collapse this and that and
128:59 - let's go to the delete route
129:01 - try it out
129:02 - paste here hit execute
129:06 - 204 no content
129:08 - and it is a success
129:10 - so
129:11 - the item should no longer be there so
129:13 - i'll try to actually get this item by id
129:15 - once again let's see what happens
129:20 - i suspect it's 404 it can't find the
129:22 - item
129:23 - and in fact if we go to get all items
129:26 - there's nothing there so the item was
129:28 - deleted
129:30 - okay so at this point we have a fully
129:32 - working res api with all the basic cloud
129:34 - operations that's working against a
129:36 - mongodb database
129:38 - but we still need to polish a little bit
129:40 - the code base that we have so far
129:42 - so in the next lesson we will learn
129:44 - about the dependence injection technique
129:46 - and the net configuration system
129:51 - in this lesson we will learn about the
129:53 - dependency injection technique and the
129:55 - net configuration system
129:58 - what is defense injection
130:00 - to understand what dependence injection
130:02 - is we can start by thinking about a
130:04 - class that uses some other class
130:07 - for instance our items controller uses
130:09 - the item's repository
130:11 - when you have this relationship where
130:13 - one class uses another class we say that
130:16 - this second class is a dependency of the
130:18 - first class
130:20 - now if instead of constructing the
130:22 - item's repository object directly as we
130:24 - are doing so far
130:25 - we receive an instance of items
130:27 - repository in the items controller
130:29 - constructor
130:31 - then we are injecting item repository
130:33 - into itunes controller
130:35 - this is what we call dependency
130:37 - injection
130:38 - but also notice that the constructor is
130:41 - not exactly receiving an instance of
130:43 - item repository but instead it receives
130:46 - an interface called items repository
130:50 - this relates to what we call the
130:51 - dependency inversion principle
130:55 - the defensive version principle states
130:57 - that code should depend on abstractions
130:59 - as opposed to concrete implementations
131:02 - let's bring again our class and one of
131:04 - its dependencies dependency a
131:07 - currently the class depends directly on
131:09 - dependency a
131:11 - however we can change this so that the
131:13 - class instead depends on an abstraction
131:16 - which in the case of c sharp is an
131:17 - interface
131:19 - and then we can have the dependency
131:21 - depend on
131:22 - or implement the interface
131:25 - why would we do this
131:27 - well by doing this our class
131:29 - implementation is decoupled from the
131:31 - dependence implementation in such a way
131:33 - that if we ever decide to switch to a
131:35 - different or updated dependency our
131:37 - class does not need to change at all
131:40 - the only thing that the dependencies
131:41 - need to do is to implement the interface
131:44 - that our class depends on
131:47 - so by having our code depend on
131:49 - instructions we are decoupling
131:51 - implementation from each other
131:53 - and this also makes our code cleaner
131:56 - easier to modify and easier to reuse
131:59 - now that our code is decoupled from
132:01 - these dependencies we have a new problem
132:05 - how and who is going to construct the
132:07 - dependencies
132:09 - imagine once again that we have our
132:10 - class which depends on an interface
132:12 - implemented by dependency a
132:15 - since our class cannot construct the
132:17 - dependency directly
132:19 - because it only knows about the
132:20 - interface
132:21 - a third actor comes into play which is
132:23 - called the service container
132:26 - which in asp.net core is known as
132:28 - iservice provider
132:31 - loading application startup which
132:32 - typically happens in serap.cs in asp.net
132:35 - core apps
132:36 - we would register our dependencies with
132:39 - the service container and this one in
132:41 - turn builds a map of all the register
132:43 - dependencies
132:45 - then eventually when our class needs to
132:48 - get constructed the service container
132:51 - first finds
132:52 - constructs the dependency or reuses it
132:55 - if it already has been constructed
132:57 - and then injects it into our class as it
132:59 - creates our class instance
133:02 - this is very powerful because you could
133:04 - even have dependencies that depend on
133:06 - other dependencies
133:08 - but as long as they all have been
133:10 - registered with the service container
133:12 - they will all be resolved properly
133:14 - whenever any class needs them during the
133:16 - application life cycle
133:20 - let's also talk about configuration
133:22 - at this point our service is able to
133:24 - talk to our mongodb database via the
133:27 - host and port information that have been
133:29 - hard-coded in our service implementation
133:32 - however this is not ideal since
133:34 - eventually the mongodb docker container
133:36 - will live outside of our local box where
133:39 - localhost will likely not make sense
133:41 - and port 2717 is not guaranteed to be
133:44 - available
133:46 - luckily afia net core supports a few
133:48 - configuration sources that are able to
133:51 - store and provide such configuration
133:53 - details to our service when needed
133:56 - one of the most popular sources
133:57 - especially for local development is the
134:00 - app settings.json file
134:02 - where we can store all sorts of
134:03 - computational information
134:05 - that we expect could change across
134:07 - environments
134:08 - like the database host and port
134:12 - and the good thing is that just like
134:13 - this one there are several other sources
134:16 - like command line arguments environment
134:18 - variables
134:20 - local secrets
134:21 - and even the cloud
134:23 - all these configuration sources are
134:25 - automatically read for us and loaded
134:27 - into the configuration system during
134:29 - host startup which is configured in the
134:32 - program cs file in asp.net core
134:33 - applications
134:35 - and from there we can get access to them
134:36 - typically in our startup.cs file
134:39 - let's now update our catalog service to
134:41 - take advantage of both the penis
134:42 - injection and the acl net core
134:44 - configuration system
134:48 - in order to start using dependence
134:49 - injection in our microservice we will
134:51 - need to start using interfaces as
134:53 - opposed to concrete types when
134:55 - constructing dependencies
134:57 - let's start by updating item repository
134:59 - so that it implements an interface that
135:01 - we can use in ads controller
135:04 - so let's go to
135:05 - our repositories directory
135:07 - items repository
135:10 - and then we want to do is to extract the
135:13 - interface that represents items
135:15 - repository and we can do that by
135:17 - clicking on item repository and as you
135:19 - can see there's this yellow light bulb
135:21 - over here you can click on that one and
135:23 - then you can click on extract interface
135:28 - by doing that as you can see the full
135:30 - skeleton of the interface has been
135:32 - extracted out of the
135:34 - item repository class and item
135:36 - repository is now implementing items
135:38 - repository our new interface
135:42 - we also want to have the interface
135:44 - living in its own file just to follow
135:47 - some good code organization across our
135:49 - microservice
135:51 - what i'll do is i'll click on i items
135:53 - repository i'll click on the light bulb
135:55 - and then i'll click on move type to
135:58 - itemsrepository.cs
136:02 - now i add the repository leaves in its
136:04 - own file over here on the left side i
136:06 - add repository in the same repositories
136:08 - directory
136:10 - and so with that done we are able to
136:13 - start doing dependency injection of item
136:15 - repository into the access controller so
136:16 - i'll open the controllers directory i'll
136:19 - go to items controller
136:21 - i'll scroll up
136:23 - all the way to the start of the class
136:26 - and i'll start by updating our items
136:29 - repository
136:31 - definition here so that we actually use
136:33 - i item repository as opposed to item
136:35 - repository
136:37 - and i will not create an instance right
136:39 - there
136:41 - it is time to introduce a constructor
136:42 - for this controller so i will do
136:48 - public items controller
136:50 - and here we are going to inject the item
136:52 - repository dependency so i items
136:54 - repository
136:56 - item repository
137:02 - and here we'll just do
137:04 - this that oh sorry
137:06 - this that item depository equals item
137:09 - repository
137:12 - so just by doing that uh at the
137:14 - repository has been injected into ideas
137:16 - controller
137:18 - now the same way that we are doing this
137:19 - we also want to use dependency injection
137:21 - in items repository itself so let's go
137:23 - back to that file
137:25 - because we don't want to be constructing
137:27 - the mongol client like we're doing it
137:29 - here we want to just receive an instance
137:31 - of our
137:33 - of our mongol database or imongo
137:35 - database directly as appendix injection
137:39 - so what i'll do is i'll just declare in
137:41 - itunes repository and
137:43 - imongo database
137:46 - object and we'll say database
137:49 - and with that we'll get rid of these two
137:51 - lines
137:54 - so now eisenhower repository is ready to
137:56 - receive an instance of database via
137:58 - defense injection
138:01 - however now that we have removed those
138:02 - lines we need a way to actually
138:05 - construct this database object and
138:07 - configure it
138:08 - so let's go into the configuration part
138:11 - of this now
138:12 - to configure the
138:14 - the host and the port that our service
138:17 - needs to connect to what we can do is to
138:20 - declare these settings in our app
138:22 - settings.json file so let's go to app
138:24 - settings.json
138:27 - and here's the ideal place for you to
138:28 - declare
138:29 - these kind of configurations that could
138:31 - change with different environments
138:33 - so what i'll do is i'll open up another
138:35 - section here
138:36 - let's call it mongodb settings
138:42 - so we'll open up a section i'll put a
138:44 - comma also here
138:47 - and then the first setting is going to
138:49 - be the
138:50 - host which in our case is we're running
138:53 - against a
138:54 - a server in our local machine it's going
138:56 - to be just localhost
138:59 - and the port
139:02 - is going to be
139:03 - 27 0 17. the default port and the one
139:06 - that we've been using in our docker
139:07 - container
139:10 - we are also going to add another
139:11 - settings section to define our service
139:13 - name this service name is going to be
139:15 - used across a few places in our
139:17 - microservice
139:19 - so let's declare that just on top of
139:21 - mongodb settings we will name it
139:24 - this section is going to be service
139:25 - settings
139:28 - service settings
139:31 - and we'll just declare one property here
139:33 - which is going to be
139:35 - service name
139:38 - which in our case since this is a
139:39 - catalog service we will just put the
139:41 - value of catalog
139:45 - okay so now we have a setting for the
139:47 - service name and for the mongodb host
139:50 - and port
139:51 - now the thing is how do we consume these
139:53 - settings in our codebase so there's a
139:55 - couple of ways to do that but i think
139:57 - the most straightforward way is to
139:58 - define a class that represents each of
140:00 - these two settings so that then our
140:03 - codebase can start using them right away
140:06 - so to do that what i'm going to do is
140:08 - just right click on play that catalog
140:10 - service or create a new folder that
140:12 - we're going to naming
140:14 - settings and in this folder i'll declare
140:17 - classes for both service settings and
140:19 - mongodb settings let's start with
140:21 - mongodb settings actually and i'm
140:22 - actually going to copy the name of the
140:24 - settings so to make sure that the class
140:26 - that we create here matches exactly the
140:28 - name of mongodb settings in there so i
140:30 - right click new file mongodb settings
140:33 - dot cs
140:35 - basically namespace
140:38 - going to be play catalog service
140:41 - settings
140:43 - and let's declare our class
140:46 - mongodb settings
140:49 - and just as we just did it should have
140:51 - properties for host and port
140:54 - so let's declare
140:58 - drop string
141:01 - host
141:03 - and prop string
141:05 - for tactile this should be an integer so
141:08 - prop import
141:10 - and then since we are not planning to
141:12 - change these settings after the the
141:15 - microservice loads we will switch from
141:17 - this this setter from set to init so
141:20 - that will prevent any anybody on any
141:22 - piece of the code
141:23 - to modify the values after
141:27 - they have been initialized
141:30 - next we're going to also declare another
141:32 - property kind of a calculated property
141:34 - that's going to define the connection
141:35 - string to mongodb so we're going to
141:37 - declare public string
141:41 - connection string
141:44 - and we'll do a little bit of
141:46 - string interpolation here
141:48 - where we're going to declare mongodb
141:54 - and that's going to have the host import
141:57 - so the host comes from our host property
141:59 - and the port comes from our
142:02 - port property
142:04 - okay so this is what we call an
142:06 - expression body definition so it's a
142:07 - property defined directly by the value
142:09 - on the right side
142:11 - right so we have a connection string
142:13 - there
142:14 - the next thing we need to do is define a
142:17 - type class for service settings so i'll
142:19 - copy the the name of service settings
142:21 - here and then again alright click
142:23 - settings new file service settings
142:25 - dot cs
142:27 - let's declare again namespace
142:31 - catalog service settings
142:34 - public class service settings
142:37 - and the only property that we have for
142:38 - this one is the service name
142:40 - so prop string
142:43 - service name
142:45 - and again this will be
142:47 - in it
142:50 - now that we have all this defined it's
142:52 - time to
142:53 - start
142:54 - constructing all these services
142:56 - registering i'm constructing and
142:57 - registering and registering and
142:58 - constructing all these uh services that
143:00 - we'll be using for depends injection and
143:03 - also taking advantage of configuration
143:04 - so to do that we'll go to the startup.cs
143:07 - file
143:08 - and i'm going to collapse this to get a
143:10 - bit more space so we can see
143:13 - and the first thing that i'll do is i'll
143:14 - go to the
143:16 - top of the startup class and i'll define
143:18 - a variable a local class level variable
143:21 - for our service settings just because
143:22 - we'll we will be using it in a few
143:24 - places across classes subsequent lessons
143:27 - so
143:28 - private
143:29 - serv
143:30 - service settings
143:35 - service settings and i'll have to do
143:37 - control dot to import play catalog
143:38 - service settings
143:40 - all right
143:41 - and then
143:43 - just before adding controllers
143:45 - i'm going to open a section here
143:47 - where first we're going to retrieve the
143:49 - value of those service settings so we're
143:51 - going to do is service settings
143:56 - equals and here's where we access the
143:58 - net configuration system where we'll be
144:00 - at the configuration property that we
144:02 - have available right here at the top
144:04 - configuration so we're going to say okay
144:06 - so configuration
144:08 - we're going to get section
144:10 - so we want to get the section that has
144:13 - the name of
144:15 - our service settings
144:17 - class so this is what we wanted to make
144:19 - sure that the class is named exactly as
144:21 - the name of the configuration
144:24 - and what we have got in that we're going
144:26 - to turn it into the actual type so we're
144:28 - going to say that get
144:31 - service settings
144:36 - there
144:37 - so with that
144:38 - we are
144:40 - digitalizing the value of several
144:41 - settings that has already been loaded
144:43 - into the temp configuration system into
144:45 - this service settings variable here
144:49 - the next thing we're going to do is to
144:51 - construct our mongodb client
144:55 - to do that we're going to be using our
144:57 - services collection so
144:59 - we will do services which we receive in
145:02 - the um as a parameter to configure
145:04 - services
145:06 - we're going to say at singleton
145:09 - uh add singleton allows us to register a
145:13 - type
145:14 - or an object and
145:16 - make sure it makes sure that there will
145:18 - be only one instance of this object
145:19 - across the entire
145:21 - microservice in this case
145:23 - so any class that needs it will get this
145:25 - one instance so it so they can use it
145:28 - so here we're going to receive the
145:29 - service provider
145:35 - okay so now we'll open an expression
145:37 - here and i'll close it this with that
145:41 - and just like we did with service
145:43 - settings we're going to now define
145:46 - or retrieve our mongodb settings
145:48 - so i'm actually going to copy this
145:50 - section here and we're going to say
145:53 - this is going to be
145:56 - mongodb settings
145:59 - okay so is configuration get section
146:01 - name of
146:03 - mongodb settings
146:05 - and then we will again convert it into
146:07 - the actual mongodb settings type
146:12 - now that we have the settings we are
146:14 - able to construct the client which
146:16 - like i said before is the the
146:18 - class we need to use to actually connect
146:20 - to mongodb so we will say
146:22 -  client
146:26 - is a new client
146:31 - and i'll import mongodb driver here
146:34 - and here what we want to pass is the
146:37 - connection string so to pass the
146:39 - connection stream we will do
146:41 - mongodb settings dot connection string
146:47 - and finally now that we have the bongo
146:48 - client we can
146:50 - get the
146:52 - instance of the database object that we
146:53 - care about so we will do
146:55 - return client
146:58 - get database
147:00 - and then what's the name of our database
147:01 - well the name of our database is going
147:03 - to be the one that we defined for the
147:04 - service name service name is catalog our
147:06 - database will be just catalog so service
147:10 - settings that service name
147:15 - and that's it
147:17 - so with this uh
147:19 - with this section we have defined a
147:20 - singleton object that represents a an
147:23 - imongo database that's going to be
147:25 - injected as remember into um
147:28 - items repository over here is going to
147:30 - be landing over here i'm on the database
147:32 - so here's where we're constructing and
147:34 - registering it with the service
147:36 - container
147:37 - and then one more thing that we need
147:38 - here is to uh also in register
147:42 - the items repository dependency so we're
147:44 - going to be doing
147:46 - services that add singleton
147:50 - and then we will use our new i items
147:55 - items repository interface and then
147:59 - i'll import the play catalog service
148:01 - repositories namespace
148:03 - and then the concrete type is going to
148:05 - be
148:06 - items repository
148:10 - all right so this is this registration
148:13 - is a bit different than the previous one
148:14 - because the previous one in the prison
148:15 - we're cons explicitly constructing
148:18 - our mongol client and the mongol
148:20 - database before registering it with the
148:22 - service container well in this case
148:24 - we're just declaring which is the type
148:28 - that we want to register and which
148:29 - interface implements and the exponential
148:32 - runtime will take care of constructed
148:34 - that instance whenever it is needed
148:37 - so we should be ready to try this out
148:39 - but what i'll do is i'll place a few
148:41 - break points so we can see how things
148:43 - start lighting up
148:44 - as they do
148:46 - so i'll put a free break point so i'll
148:48 - put one over here
148:52 - then i'll go to item repository and i'll
148:53 - put one in the constructor over here
148:57 - and i'll also go to our items controller
149:00 - and i'll put another breakpoint here
149:03 - and now i'll hit f5
149:08 - okay so we can go to our soccer ui page
149:12 - i'll go slash
149:13 - swagger
149:15 - and of course we don't have anything in
149:17 - our database right now but regardless
149:20 - our servers will need to construct all
149:22 - these dependencies to be able to figure
149:23 - out that this is actually no items right
149:24 - now so i'll open up our get all items
149:28 - operation i'll click on try it out and
149:30 - then i'll click on execute
149:33 - now back in vs code and now collapses a
149:35 - bit
149:37 - we are now in our startup file
149:39 - and notice that we right away we are
149:41 - entering into the add singleton section
149:43 - here this is because uh so there is one
149:45 - or more
149:46 - services that need this imongodb
149:50 - objects
149:52 - so if we inspect the value of mongodb
149:54 - settings
149:55 - we can see that we already have defined
149:57 - the host port and the calculated
149:59 - connection string is right there and
150:01 - that's what we are using to fit into the
150:04 -  client connection string
150:06 - we should also have a value for service
150:08 - name here from service settings has been
150:10 - read from configuration and it's been
150:12 - used to get the database
150:14 - form that we're going to be using this
150:15 - database is being will be constructed
150:18 - the first time and the next time it will
150:19 - be just reduced
150:22 - so i'll hit
150:23 - continue here
150:25 - and now we are into items repository
150:27 - which now is able to receive retrieve
150:29 - that instance of the imongo database
150:32 - object that has been constructed and
150:34 - it's been injected here and it is via
150:36 - that one that is going to be able to
150:37 - retrieve the items collection that's
150:39 - going to be used across the is
150:41 - repository
150:43 - then i'll click
150:44 - continue and now we are in the itus
150:47 - controller which is not able to now able
150:49 - to retrieve
150:51 - to receive that injected as a repository
150:53 - that is going to also be been used be
150:55 - used for all the operations
150:57 - i click
150:58 - continue and we're back into play
151:02 - catalog service the socket ui which of
151:04 - course it says there's no items right
151:05 - now
151:06 - but we know we can easily go ahead and
151:08 - start creating items updating items and
151:10 - all these things with the swagger ui
151:12 - but yeah so depends injection is
151:14 - configured and the configuration system
151:16 - is enabled too
151:18 - so we have reached the end of this model
151:20 - with a fully working decoupled and
151:23 - configurable microservice that is able
151:25 - to store and guided for your catalog
151:27 - items in a mongodb database
151:30 - in the next module we will introduce our
151:31 - second microservice and we'll be
151:33 - learning about the multiple challenges
151:35 - of having microservices talk to each
151:37 - other
151:41 - this module is an intermediate step to
151:43 - get ready to build our future
151:44 - microservices
151:46 - we will learn about a few new tools that
151:49 - will help you as you start working with
151:50 - more microservices
151:52 - and we will build a useful library that
151:55 - we will use in future models
152:00 - here's what you will achieve after
152:01 - finishing this model
152:04 - you will learn how to use postman as an
152:06 - alternative to swagger ui to interact
152:08 - with your microservices
152:10 - you will generalize the items repository
152:13 - so that it can be used with any future
152:15 - entity
152:17 - you will create a nuget package where
152:19 - you will place all common classes that
152:21 - you would like to reuse in future
152:23 - microservices
152:25 - and finally you will use docker compose
152:27 - to simplify how to run mongodb and the
152:30 - multiple infrastructure services to be
152:31 - used in future models
152:34 - let's get started
152:38 - in this lesson we will learn about
152:39 - postman which is a popular api client
152:42 - that we will be using starting with this
152:44 - model
152:45 - postman will allow us to interact with
152:46 - our microservices res apis without
152:49 - having to open a browser to navigate to
152:50 - the swagger ui page of each of the
152:52 - services
152:54 - in addition it will offer us a few
152:55 - additional capabilities that will prove
152:57 - useful across this course
153:02 - the only additional tool required
153:04 - starting with this model is the postman
153:06 - client which you can get at this
153:07 - location
153:09 - let's get started
153:14 - let's go ahead and install postman
153:17 - i'll go to the postman download page at
153:19 - postman.com
153:20 - downloads
153:22 - and here i'll just scroll down a little
153:24 - bit i'll click on download the app
153:27 - i'll pick my parent system
153:29 - and that will start download
153:31 - in the same way depending on your
153:32 - operating system you can choose the mac
153:34 - os or linux version
153:36 - this should take just a few seconds
153:42 - okay so it's downloaded i'll click on
153:44 - the installer
153:47 - and yeah the way that installer worked
153:49 - for pulseman is that it will just pop up
153:50 - this screen here so it's already
153:52 - installing the application uh it will
153:53 - take a few seconds and then the our the
153:55 - postman ui will just pop up in your
153:57 - screen
153:59 - and here it is
154:01 - and so at this point you have the option
154:03 - to create an account with most men if
154:06 - you want to keep track of your
154:07 - collection settings and a bunch of
154:09 - things that you may be interested in
154:11 - but in our case
154:13 - we really don't care about that at this
154:14 - point so i'll just click that link at
154:16 - the bottom side here skip signing in and
154:19 - take me straight to the app so i'll just
154:20 - click on that
154:21 - and then we are in the postman uh user
154:24 - interface
154:26 - the first thing that i'll do here just
154:28 - because i don't like this theme at all
154:30 - so i'll just go to settings over here
154:33 - settings
154:34 - teams and then i'll switch to the dark
154:36 - emote setting
154:39 - okay so now that we have postman
154:41 - available let's go back to our catalog
154:44 - service and this code and let's start
154:46 - waiting for its several apis so let's
154:48 - minimize this i'll close this browser
154:51 - and yeah here we are in the catalog
154:53 - service
154:54 - and then yeah i'll just do f5
155:02 - all right so as usual the browser opens
155:05 - but this time we are not going to be
155:07 - using the browser we are going to go
155:08 - straight into postman over here and here
155:12 - uh what you can do to start creating
155:14 - your rest api is uh if you have the
155:16 - launchpad open like me you can click on
155:18 - create a request over here or if you
155:21 - don't have it open you can click on this
155:23 - plus button to open a brand new tab in
155:26 - this tab what you want to do the first
155:27 - thing you want to do is figure out which
155:29 - is the verb that you're going to use for
155:30 - your res api if you click on this
155:33 - drop-down you're going to find a bunch
155:34 - of http verbs for the different
155:36 - operations so let's say that we want to
155:38 - start by doing a get uh so click on get
155:41 - and so that we want to get the list of
155:43 - items in our catalog api
155:45 - uh so then you want to type here the url
155:48 - of the address api and if you don't
155:50 - remember the the host where you're
155:52 - running your web server you can easily
155:54 - find that out by going back to visual
155:57 - studio code
155:59 - and here you can find that
156:01 - that url either right here in the debug
156:03 - log where it says now listening on is
156:05 - right here
156:07 - or you can also find it if i scroll down
156:09 - this a bit and then you open
156:11 - properties launch settings.json
156:13 - is right here close to the bottom where
156:15 - it says application url is over here so
156:18 - https localhost 5001. so i'm going to
156:20 - copy that
156:22 - and back into postman and so i'm going
156:24 - to paste that over here
156:27 - and then what you want to do is add the
156:29 - route for our controller so once again
156:32 - backing visual studio code if you open
156:34 - controllers iris controller you're going
156:36 - to find a route right here so router is
156:38 - items
156:39 - to copy that
156:41 - back into postman
156:43 - and i'll say slash items
156:46 - and with that you can just hit send and
156:48 - that's going to query the rest api
156:50 - now if you get an error like the one
156:52 - that i'm getting down here which says
156:54 - ssl error unable to verify the first
156:55 - certificate this is actually expected is
156:57 - a default verification for the
156:59 - certificate of your web server since we
157:01 - are using a self-signed certificate that
157:03 - comes bundled with asp.net core
157:05 - that's not really a friendly certificate
157:07 - for postman
157:08 - but it is okay to get past that
157:10 - verification because it's just a local
157:13 - web server for development purposes so
157:15 - what i'll do is i'll just click on
157:16 - disable ssl verification
157:20 - and that's going to go ahead and i'll
157:21 - just close this and that goes ahead and
157:23 - queries the rest api without issues
157:27 - of course we don't have any items
157:29 - available in the database right now so
157:30 - that's why we see an empty array over
157:32 - here but we can actually try out to
157:35 - create a brand new
157:37 - item and to do that what i'll do is i'll
157:39 - click on the plus icon over here
157:42 - which opens a new tab
157:44 - and i'll switch from get into post
157:48 - and once again i'll paste our our entire
157:52 - route here so i'll copy from get i'll
157:54 - paste it here in post
157:56 - and then we want to do is go to the body
157:58 - section over here
158:01 - and we want to choose raw
158:04 - and at the end of this section i'll pick
158:08 - json
158:11 - so i'll open up this
158:14 - and here we go where we can define the
158:16 - body that we want to send to this post
158:18 - request so i'll open up a section uh as
158:21 - a json section here
158:23 - and i'll start typing the elements for
158:25 - creating a in this case uh an item so if
158:29 - you remember the the elements are a name
158:31 - so we need a name
158:32 - and let's say we go back to our portion
158:34 - example so i'll just say potion
158:37 - then we need a description
158:40 - a description
158:42 - is going to be
158:43 - restores
158:46 - a small amount of hp
158:51 - and finally we'll set up a price
158:54 - which is going to be let's say five
158:57 - okay so with that done i'll do this i'll
159:01 - go ahead and hit send
159:03 - and as you can see the item has been
159:05 - created
159:06 - okay we have an id
159:08 - and we if we wanted to we can now go
159:10 - back to the get
159:11 - tab here and we can query for items once
159:14 - again so i'll click on send
159:16 - and now we can get items
159:19 - so just like this you can keep going on
159:21 - and using the rest of our rest api
159:24 - operations by opening new tabs and
159:26 - opening and using the different verbs
159:28 - over here
159:29 - however
159:30 - each of these times you'll have to
159:31 - remember
159:32 - what to put exactly on the on both on
159:35 - the url and in the case of pause for
159:37 - instance uh the body and the elements
159:39 - that you want to use uh for the uh for
159:42 - the for the payload to send in that body
159:44 - right uh so what if you don't remember
159:46 - exactly what to put in all these cases
159:48 - so what i'd like to do is just show you
159:50 - another way to do this to simplify a
159:52 - little bit this this oral process so
159:54 - what i'll do is i'll just right click
159:55 - here and i'll close close all tabs
159:58 - so
159:59 - actually i'll say cancel
160:02 - let me close this down save close that
160:05 - so
160:07 - one thing that you can do if we go back
160:09 - into our browser over here is we can go
160:13 - ahead and find the open api
160:14 - specification for our api so if i go to
160:17 - slash swagger
160:18 - hit enter we're back into our soccer ui
160:21 - page but this time we're not going to
160:23 - use any of these methods we're going to
160:24 - do is click on this if you can see this
160:26 - swagger.json
160:28 - link over here i'll click on it and this
160:31 - opens the open api specification so this
160:33 - describes the entire res api
160:35 - in a standard way
160:37 - so what i'll do is i'll copy this entire
160:40 - url
160:42 - and then i'll go back to postman and
160:44 - i'll go into the import button over
160:46 - here i'll click the link section
160:50 - and then i'll paste that url over here
160:52 - click continue
160:54 - and finally i'll just say import
160:58 - and now if we go into the collection
161:01 - section over here
161:03 - you're going to see that now we have a a
161:06 - description of our play catalog service
161:08 - listed here with all the requests so if
161:10 - i open this
161:12 - and there's the items
161:14 - the items route and if you open that you
161:17 - can see that we have routes a forget and
161:20 - for post and also if we want to go by id
161:23 - we can go ahead and get an item by id we
161:26 - can do the put which requires an id and
161:28 - we can do also the delete
161:31 - so this time if you want invited to get
161:33 - a ghetto items what i can do is just
161:35 - click on
161:36 - get items
161:37 - and then that's going to open a
161:40 - a tab with an already filled in
161:43 - verb and url to go ahead and request the
161:46 - items
161:47 - however you're going to notice one new
161:48 - thing here which is the base url so the
161:51 - visual represents uh really the root of
161:54 - your or where you're hosting your res
161:56 - api at this point so this is the
161:57 - localhost 5001 section so postman just
162:01 - doesn't know that information just yet
162:03 - it just knows about the routes and the
162:04 - payloads so to fill in this this
162:07 - variable here base url what you can do
162:09 - is go to back to play catalog service
162:11 - over here click on these three dots
162:14 - click on edit
162:17 - and then you go to the variable section
162:18 - here
162:21 - and then you want to put a value for
162:24 - for current value so what i'll do is
162:26 - i'll just put https
162:28 - localhost
162:31 - 5001
162:33 - okay i'll also put that in initial value
162:36 - this is what's somebody else that wanted
162:37 - to reuse your postman collection it
162:40 - would have as an initial value if they
162:42 - wanted to so i'll just keep the same
162:43 - value for both of them
162:45 - so then i'll just hit update
162:48 - and now if we hov a hover over base url
162:51 - you can see that now we have
162:54 - the result value being pop-up there uh
162:57 - for our res api
162:59 - so now i can go ahead and hit send
163:02 - and once again i get my items
163:05 - but more interestingly if i wanted to do
163:06 - a post this time i can click on post
163:09 - and then again the the url the birth is
163:11 - filled the url is right there and the
163:13 - body is already pre-populated with all
163:15 - the elements required for this api
163:19 - let's actually try to do a put so i'll
163:21 - go ahead now into put
163:23 - and again the url is pre-filled in there
163:26 - we want to do is to in this case
163:28 - first we need the id of the item which
163:30 - we can get from the get items tab here
163:33 - so i'll just copy that id
163:36 - back to put and i can put the id right
163:38 - there
163:39 - and then in terms of the
163:42 - of the body
163:43 - i can go to the body section and like i
163:45 - said it is pre-filled so i just have to
163:47 - put the elements for this body
163:50 - so i'll actually just copy
163:52 - those elements from here
163:58 - okay
164:00 - and now do a proper indentation
164:02 - and so here's where we can go ahead and
164:04 - update something about this potion so
164:05 - i'll just update the price again so i'll
164:07 - say seven
164:09 - and then we're going to click on send
164:11 - and we got a response uh 204 no content
164:14 - meaning that
164:15 - it succeeded and so now we can actually
164:18 - try let me copy the id of this item we
164:21 - can try our get buy id api
164:24 - and then again the url is pre-filled
164:26 - i'll just paste the id over here i'll
164:28 - hit send
164:30 - and there it is we got a our potion
164:33 - so as you can see it is pretty handy to
164:35 - just import the open specification of an
164:37 - api specification into postman and be
164:39 - able to be able to quickly very quickly
164:42 - start working with your rest api
164:43 - imposement
164:45 - now a few other things that are
164:47 - available in postman as opposed to our
164:49 - previous swagger ui page is things like
164:52 - for instance of course we have the the
164:53 - concept of these collections which in
164:55 - fact you can actually export if you
164:57 - wanted to and share this with somebody
164:59 - else in your team or some of your
165:00 - teammates you can easily export this
165:02 - collection
165:04 - and you will do that by clicking these
165:06 - three dots and you can click on export
165:07 - and there's going to be a few options
165:08 - for you to export this for somebody else
165:11 - then also we you have a this this tab
165:15 - over here that says history this will
165:16 - show the history of all the
165:19 - previous implications of your res api so
165:21 - if you wanted to go back to something
165:22 - that you did in the past with the
165:24 - specific payload that you did and url uh
165:26 - you can do that so this is going to keep
165:28 - a long list of all the
165:30 - the queries that you've made to your api
165:32 - across your different sessions
165:34 - there's also this concept of
165:36 - environments over here
165:38 - which you can use to define the
165:40 - different environments where you want to
165:42 - invoke your request api so if eventually
165:44 - you're not just running in your
165:46 - localhost machine but perhaps you have
165:47 - deployed this to some a cloud
165:49 - environment you can define variables
165:51 - over there so that you don't have so
165:53 - that for instance device url
165:54 - automatically changes as you change the
165:56 - environment that you're specifying over
165:58 - here
165:59 - that way you don't have to keep opening
166:01 - more and more tabs for the different
166:02 - environments
166:04 - there's also the ability to specify
166:05 - authorization options over here
166:08 - for the different authorization types
166:10 - uh so that you can for instance generate
166:13 - a generate and use uh
166:15 - authorization tokens to call your res
166:17 - api if your recipi is enabled for that
166:20 - that's actually something that we'll
166:21 - look at in a future a model okay so now
166:25 - that we have done that uh one more thing
166:27 - that we want to do is to since we are
166:28 - not going to be using post one we don't
166:30 - really want to be opening browsers all
166:32 - the time so how can we prevent the
166:34 - browser from uh keep opening every
166:36 - single time so let me just go back to
166:39 - the browser and i'll just click close
166:40 - this
166:42 - and then i'll go back to visual studio
166:43 - code
166:45 - and let's stop and close this
166:48 - and what you can do is to go back to we
166:51 - go to explorer
166:53 - and we're going to go to that vs code
166:55 - launch.json
166:58 - and you want to look for this section
166:59 - that says server ready action
167:01 - so this section here is the one that
167:03 - visual studio code uses to define if
167:06 - they wanted to open a browser after
167:09 - something happens with the web server in
167:10 - this case it's just looking for the
167:12 - message that says now listening on
167:14 - so when it finds that it knows that it
167:15 - needs to open the browser so in our case
167:17 - we don't want to open browsers anymore
167:19 - we'll find with postman so we're just
167:21 - going to remove this section
167:24 - delete
167:25 - and now if i do f5
167:31 - okay
167:32 - no browser is going to open
167:34 - we just stay here
167:35 - uh but as as always you can just go to
167:38 - postman and start creating the api like
167:41 - we already did
167:44 - okay so that's it for this lesson and in
167:47 - the next lesson we will start extracting
167:50 - a few of the classes that we are using
167:52 - in catalog microservice into some shared
167:55 - components that we can use in our future
167:58 - microservices
168:01 - in this lesson we will learn about the
168:03 - need to reuse common code across
168:05 - microservices and how the nuget package
168:07 - manager can be used to package and share
168:09 - code across services in a
168:11 - straightforward way
168:14 - one of the things that you will likely
168:15 - realize as you start building more than
168:18 - one microservice is how much code starts
168:21 - getting repeated between each service
168:23 - implementation
168:24 - for instance our catalog microservice
168:27 - currently has a repository
168:28 - implementation for querying and storing
168:31 - data in its mongodb database
168:34 - it also has a couple of settings classes
168:36 - to more easily use the different service
168:38 - configurations that are stored in our
168:40 - app settings.json file
168:43 - eventually we will also add classes to
168:45 - interact with our service broker
168:47 - code to add instrumentation to the
168:49 - services and likely some more code that
168:51 - is not directly related to the purpose
168:53 - of the microservice
168:55 - the problem with this is that as soon as
168:57 - we bring in our second microservice the
169:00 - inventory service we would likely need
169:02 - to copy to it that same code with very
169:05 - little modifications
169:08 - this is time consuming and goes against
169:10 - the don't repeat yourself principle
169:13 - which states that every piece of
169:14 - knowledge must have a single unambiguous
169:17 - authoritative representation within a
169:19 - system
169:20 - which in our case means that our common
169:22 - code should live and be maintained in a
169:24 - single place
169:26 - therefore
169:27 - we could be tempted to keep our common
169:29 - code in one of our microservices and
169:31 - have all the other services simply
169:33 - reference that project to get access to
169:35 - the common code
169:36 - however this is not a good idea because
169:39 - microservices should be independent of
169:41 - each other to ensure each of them can
169:44 - evolve quickly and have no ties to the
169:46 - internal implementation of others
169:48 - we can solve this problem by introducing
169:50 - a new library project that we will call
169:52 - the common library and then we can
169:54 - extract all the common code into it
169:58 - the common library becomes the single
169:59 - place where we have all the code that is
170:01 - not specific to any microservice and
170:04 - therefore is the single place where we
170:06 - will perform any updates to it when
170:08 - needed
170:10 - but then
170:11 - how can we make the code in this new
170:13 - common library available to our
170:14 - microservices
170:15 - we could have our microservices add a
170:17 - direct reference to the library project
170:19 - file
170:20 - but that's not a good idea because as
170:22 - new members join our team each of them
170:24 - might want to work on one microservice
170:26 - or the other or even in the common
170:28 - library and therefore they will only
170:31 - graph the code base for the project they
170:33 - are interested in but not the code basis
170:35 - of all projects all the time
170:37 - plus eventually each microservice and
170:40 - the common library should get their own
170:42 - independent source control repository
170:44 - where they can be tracked and built
170:45 - independently
170:48 - so if the microservice projects can
170:49 - access the common project directly what
170:52 - can they do
170:53 - here is where we can use nougat which is
170:56 - the package manager for dotnet
170:58 - with nuget we can execute a simple
171:01 - command like dotnetpak to bundle all the
171:04 - output files from the common project
171:06 - into a nougat package
171:08 - another package is nothing more than a
171:10 - zip file with a new pkg extension that
171:13 - contains all the files that are to be
171:14 - shared with other projects
171:17 - now each of our microservices can
171:19 - reference the nougat package to get
171:20 - access to everything that the common
171:22 - library has to offer
171:24 - and the good thing is that microservice
171:26 - projects don't need to know where these
171:28 - nuget packages are hosted
171:29 - we will initially place the package in
171:31 - our local machine but eventually you
171:33 - will likely want to host them in a
171:35 - cloud-based location either accessible
171:37 - just by your team or by anybody on the
171:39 - web the important thing is that
171:41 - regardless of the location you won't
171:42 - have to change how the microservices
171:44 - access the common code
171:46 - with our new common noked package our
171:49 - common code is now maintained in a
171:50 - single place
171:52 - and the time to build new microservices
171:54 - is significantly reduced
171:57 - in the next lesson we will extract our
171:59 - current common code into a new common
172:01 - library and we will produce our first
172:03 - nuget package that the catalog
172:04 - microservice and every filter service
172:07 - will be able to reference to get quick
172:09 - access to the common code
172:13 - if we take a look at our item repository
172:15 - class over at repositories items
172:18 - repository
172:20 - we will notice that there's a lot of
172:21 - code here that we will need to reuse in
172:24 - future microservices
172:27 - and the same goes for our settings
172:29 - classes over in the settings directory
172:32 - mongodb settings service settings
172:35 - we can certainly reuse these in future
172:36 - microservices
172:38 - but before we can move anything to a new
172:40 - shared library we will need to do some
172:42 - good refactoring to keep the generic
172:44 - pieces separated from what's really
172:46 - needed in the catalog microservice
172:49 - so let's start by looking at our items
172:51 - repository
172:53 - and if we take a closer look at what's
172:55 - going on here there's one piece that's
172:56 - really repeated a lot across this class
172:59 - and that is the use of the item entity
173:01 - the item entity is being used uh
173:04 - in several cases like for instance in
173:07 - ghetto lacing is being used to return
173:08 - the items that are going to be queried
173:12 - and we are also filtering by the id of
173:15 - this item
173:16 - in both in engage async method and also
173:19 - in the update async method will
173:21 - filtering by id and also in the remove
173:22 - async method
173:24 - so we need to find a way to generalize
173:27 - the use of this entity so that it can be
173:29 - used in like i said in a more general
173:31 - way in this repository so let's actually
173:33 - go to the item entity so right click go
173:35 - to
173:36 - definition
173:38 - but what we're going to do here is to
173:40 - actually extract an interface out of
173:42 - this item class
173:44 - uh to
173:46 - nail down narrow down the pieces that we
173:48 - really need to generalize about the item
173:51 - so we're going to do is just click on
173:52 - the light bulb
173:55 - and say extract interface
173:57 - and now we have the item interface here
174:00 - that our item class is implementing
174:03 - however we don't want to call this
174:05 - interface i item we actually want to
174:06 - call it
174:08 - i
174:09 - int
174:12 - and this ai entity
174:14 - is what our item class is going to
174:16 - implement
174:17 - but also we don't want to have all these
174:18 - properties in the interface but only
174:20 - daily having the id will be good enough
174:24 - to be used in the repository class we're
174:26 - going to implement
174:28 - now we also want to move this interface
174:30 - into a different file
174:32 - so i'm going to click on the light bulb
174:35 - and i'm going to move the type to
174:36 - indit.cs
174:39 - okay so now we have a i the item entity
174:42 - that implements i entity
174:44 - that is in the i entity.cs file over
174:47 - here
174:48 - now what we're going to do is to before
174:50 - going back to the item repository let's
174:52 - go to the items repository class
174:54 - and see how we can generalize this
174:58 - so to start with
174:59 - we don't want this class to be
175:01 - about just items anymore but about a
175:04 - generic type and the way that we can do
175:06 - this is to by renaming this interface
175:09 - into
175:10 - uh instead of iot depository is going to
175:12 - be i repository
175:14 - and it is going to be off a generic type
175:17 - that we're going to use name t where t
175:19 - represents the actual entity that's
175:21 - going to be used in a specific
175:22 - microservice
175:24 - so this t will add a constraint here
175:27 - where t
175:28 - is has to be
175:31 - and i entity
175:33 - the interface that we just defined so
175:35 - whatever we use for t it has to be a
175:37 - class that implements the identity
175:38 - interface
175:41 - so now that we have that generalization
175:42 - we can say that all of our methods
175:44 - actually use this
175:46 - this t type so for instance instead of
175:48 - having item here we're going to name it
175:51 - as t
175:52 - and the same the same way we're going to
175:54 - do for the item that's going to return
175:56 - in general lacing
175:58 - the item does return in get async
176:00 - and
176:01 - also the item
176:02 - the entity that's received in updated
176:04 - sync
176:06 - okay so with that there's no longer a
176:09 - mention of the item type anywhere in
176:11 - this interface
176:14 - so with that done we can now go back to
176:17 - our items repository and also generalize
176:19 - it to represent a more generic
176:22 - repository
176:24 - so instead of being an items repository
176:26 - this is now going to be
176:28 - a repository
176:30 - that is going to be off some type so
176:33 - again we're going to use a type t to
176:35 - represent the actual
176:36 - entity that's going to be managed by
176:38 - this repository and also our repository
176:41 - class now needs to implement the i
176:44 - repository
176:45 - of the interface
176:49 - again
176:50 - where t
176:53 - is an i entity
176:56 - okay
176:57 - so let's also rename the constructor
177:00 - to be repository
177:03 - and let's start changing this so that it
177:05 - actually to start removing everything
177:07 - related to item from this class so one
177:09 - of the things that we have to get rid of
177:11 - is this constant
177:12 - that is the collection name items uh
177:14 - since this is not going to be just about
177:16 - items anymore let's remove it and what
177:18 - i'm going to do is just copy collection
177:20 - name
177:21 - just the name of the var for the
177:22 - constant and remove it
177:25 - and now we are going to receive that
177:27 - collection name as a parameter in the
177:28 - constructor so we're going to receive
177:31 - string collection name
177:33 - so that's a collection name that's going
177:34 - to be used when we try to retrieve a
177:36 - collection
177:37 - from mongodb from here on
177:40 - okay and so now we need to start moving
177:42 - forward and
177:44 - start analyzing things so let me just
177:46 - get a copy of t
177:49 - and so anywhere where we find item we
177:52 - want to replace it with t
177:54 - so this is a db collection of t filter
177:56 - builder of t
177:57 - builders of t dot filter
178:01 - and we get a collection of a t
178:03 - a i t entity
178:07 - when we do get a lacing we have to do t
178:10 - again
178:13 - and again when we do the filtering so
178:16 - get is of t d over here
178:19 - it's all generic
178:20 - also create async should be t
178:25 - update async should be also t
178:29 - filter definition of t
178:32 - and notice that since our actual since
178:34 - our interface has the id property it
178:37 - doesn't really care
178:39 - that it doesn't know what's a real item
178:41 - as long as that
178:42 - the real entity sorry as long as that
178:44 - entity implements a identity it is able
178:47 - we know that there's going to be an id
178:49 - property a quick id property that we can
178:51 - filter by
178:53 - and finally let's
178:54 - change our remove async to also deal
178:56 - with just with t
178:59 - all right so just to confirm let's make
179:01 - sure we don't have item anywhere in this
179:03 - file anymore yep there's no more item
179:05 - here
179:06 - so
179:08 - let's also rename the file by the way
179:10 - so this should be
179:12 - mango
179:12 - repository and this other file here
179:16 - should be
179:17 - a repository
179:20 - and with that done
179:23 - it is time to start fixing all the
179:25 - references to our repositories so let's
179:28 - start by going to our controllers class
179:30 - items controller
179:32 - and let's fix things right so this is no
179:34 - longer an iates repository it's just
179:36 - and i repository
179:40 - of type item
179:43 - and that is what we are going to be
179:45 - receiving in the itunes controller in
179:47 - the constructor here
179:50 - okay
179:51 - next thing that we need to do is to fix
179:53 - the way that we are registering the
179:54 - repository in startup so let's open up
179:57 - startup
179:59 - and let's see how we are registering the
180:01 - repository over here so this is what
180:03 - we're doing today at singleton i attend
180:04 - repository item repository
180:07 - so we will switch to a more
180:09 - a more concrete way of defining this
180:11 - singleton because now we need to specify
180:13 - a parameter as an input to the
180:15 - repository so remember in manga
180:16 - repository
180:18 - now we are receiving a collection name
180:20 - so we cannot just just expect to all
180:22 - parameters to be injected automatically
180:24 - by the service container for us so we
180:26 - need to be more explicit
180:28 - so let's update the repository
180:30 - registration
180:31 - to start with we are no longer using the
180:34 - item repository interface
180:36 - we are using a repository
180:39 - of type item
180:41 - and let's see if we're missing something
180:43 - so let's
180:44 - add the service entities namespace
180:47 - so it's another repository of item
180:50 - we will notice is define an actual class
180:53 - as a second parameter here
180:55 - and then we have to specify this service
180:57 - provider
181:00 - service provider just like we did in the
181:02 - other at singleton
181:04 - call let's open braces here
181:09 - and now before we can create the
181:10 - instance of the mango repository first
181:12 - we need an instance of the imongo
181:14 - database
181:15 - because remember we actually registered
181:17 - an imongo database in the previous
181:19 - singleton call so how can we get an
181:21 - instance of such a registered service so
181:23 - that's where you can use the get service
181:24 - method of the service provider so just
181:27 - like this so bar database
181:30 - equals service provider
181:32 - that get service
181:34 - i database
181:38 - okay so anytime that you need to get an
181:41 - instance of
181:42 - a service already registered in the
181:44 - service container like we did with
181:45 - imongo database uh you just you just
181:47 - need to call get service on service
181:49 - provider
181:50 - and this will work as long as that
181:53 - service has been registered before the
181:54 - call that you're going to make here
181:57 - and then having that
181:59 - imogo database instance we can now
182:01 - return
182:03 - our new repository
182:06 - of type item
182:08 - and then we need to provide two
182:09 - parameters first one the database the
182:11 - one that we just got and then the
182:13 - collection name that so far is being
182:16 - just items
182:20 - okay so that should do it let's make
182:21 - sure everything is building successfully
182:23 - so i'll do ctrl shift b
182:26 - and indeed everything is building just
182:28 - fine
182:30 - so at this point we have generalized our
182:32 - repository class so that it can be used
182:34 - with any type of entity
182:36 - however
182:37 - it feels like we're writing too much
182:39 - code on startup to register the mongodb
182:40 - related classes because look at this we
182:42 - have to do register serializers
182:45 - we have to do the singleton registration
182:47 - for the client for the
182:49 - database and then the other singleton
182:51 - for the repository
182:52 - so in the next lesson we will introduce
182:55 - a couple of hand extension methods that
182:57 - will simplify things quite a bit for
182:59 - this and for future microservices
183:02 - so let's take a quick look at everything
183:04 - that we have to do in order to use our
183:06 - mango repository so far so here i am in
183:08 - a startup class
183:09 - and
183:11 - the first thing that we have to do is
183:12 - register the the bson serializers in
183:15 - order to change the way that we store
183:16 - codes and date times
183:18 - then we have to get the mongodb settings
183:21 - the the movie settings section for an
183:23 - app settings the json in order to
183:25 - construct our client and then we
183:27 - can create our imongo database that we
183:29 - registered as another singleton
183:32 - and then finally when we have that we
183:34 - are able to retrieve that imongo
183:36 - database and then construct that
183:37 - repository for the items collection
183:41 - so let's see how can we simplify all
183:43 - these lines
183:44 - to make the life of future microservices
183:46 - much easier
183:47 - what i'm going to do is create a new
183:50 - extensions class inside the repositories
183:52 - directory so i'm just going to right
183:54 - click here i'm going to create
183:56 - extensions
183:57 - that's yes
183:59 - not to be confused with the other
184:00 - extensions that we have over here this
184:02 - is a new class
184:03 - let's give it a namespace
184:08 - like dialog service repositories
184:11 - so let's name this class public static
184:16 - class
184:17 - extensions
184:19 - and let's declare a function here so
184:21 - it's going to be public static
184:24 - i service collection
184:27 - because we're going to be extending a
184:29 - service collection here
184:31 - and let's name it admongo
184:34 - and it's going to receive we're going to
184:36 - extend the i service
184:39 - uh collection object
184:43 - okay so it receives a service collection
184:45 - and it will return a live service
184:47 - collection let's see if we're missing a
184:49 - space so let's add the defense injection
184:51 - space there
184:55 - and here let's go ahead and grab a few
184:57 - lines from startup
184:58 - so let's grab these lines
185:03 - over here
185:04 - and let's go ahead and add missing nice
185:07 - bases so i'll do visual serialization
185:11 - i'll do serialization serializers and
185:14 - then i'm going to device vision
185:17 - okay
185:18 - and then we will need service settings
185:20 - but we will not receive them here
185:22 - we will get them
185:25 - over here
185:26 - as bar service settings but one thing
185:29 - that you can notice is that we don't
185:30 - have an instance of configuration here
185:32 - just like we had in starbucks where it
185:34 - was uh when it was a property that we
185:36 - received as part of the constructor
185:39 - so we can do is use a service provider
185:42 - to explicitly request a an instance of
185:44 - office services has a varying register
185:46 - so configuration is registered already
185:48 - by asp.net infrastructure so we should
185:50 - be able to request it at this point what
185:52 - i'm going to do is just say bar
185:54 - configuration
185:56 - is service provider dot
185:58 - get service
186:00 - and the type of service is going to be
186:02 - just i configuration
186:06 - okay which
186:08 - needs the extensions configuration space
186:12 - so now we can flip this configuration
186:14 - into just configuration with
186:16 - with a small cap c
186:20 - and then we are also missing another
186:22 - namespace here which is the service
186:24 - settings namespace
186:26 - okay so we get the configuration we
186:28 - retrieve service settings mongodb
186:29 - settings we construct the client
186:31 - let's add the missing space here too
186:35 - and that allows us to return the imongo
186:37 - database
186:39 - finally we're going to return the
186:42 - services collection just to enable the
186:45 - fluent use of this extension method
186:48 - so that will register the imongo
186:50 - database instance and now let's add
186:52 - another method to register the
186:53 - repository itself
186:55 - so i'll open up another menu here
186:58 - let's call it public static
187:01 - my service collections go to return
187:04 - add repository
187:07 - it's going to be the name
187:09 - and then
187:10 - we'll specify a constraint of t for the
187:13 - actual entity type that's going to be
187:14 - used
187:16 - and then
187:17 - it's going to extend a service
187:19 - collection
187:21 - the name is going to be services
187:24 - and then remember we have specify a
187:26 - collection name in order to create a
187:27 - repository so let's receive
187:30 - collection name
187:31 - as a parameter
187:33 - we also need to specify a constraint for
187:35 - that
187:37 - for that t parameter so
187:40 - t
187:41 - the the the t type that's going to be
187:42 - used has to be a type that implements i
187:45 - entity
187:49 - okay so we may need another namespace
187:51 - let's first expand this
187:54 - save it
187:55 - let's send this to the other line
188:00 - and let's
188:01 - add the service entities namespace
188:04 - okay so this will be useful to register
188:06 - uh repository with any type of entity
188:08 - but that entity has to implement i in
188:10 - the indit interface so now what we can
188:12 - do is go back to startup and grab these
188:16 - these few lines
188:18 - for the i brother registration we'll
188:20 - copy that here
188:23 - and then uh to make it generic we're no
188:26 - longer going to be using item here but
188:28 - just d
188:31 - and then this also registers as
188:33 - and we no longer hardcode the collection
188:35 - name we're going to be using the
188:36 - collection name parameter
188:40 - and finally to keep it fluent we return
188:43 - services once again
188:46 - so with that we should be able we should
188:48 - be ready to start using these extension
188:49 - methods so let's go back to startup
188:53 - okay so we're going to go ahead and
188:54 - remove this serializer registration
188:57 - let's skip several settings for now in
188:59 - case we need it later but we definitely
189:01 - don't need any of this stuff
189:05 - so now what we can do is just say
189:07 - services
189:09 - add that registers
189:12 - are a client and
189:14 - a imog database and then since this is
189:16 - fluent we can say
189:19 - at mongol repository
189:22 - we specify a type in our case type is
189:24 - item
189:26 - and then we provide the name of the
189:28 - collection which is still items
189:32 - so with that done let's just make sure
189:34 - things are keep working properly so i'm
189:36 - going to hit f5 to start a web server
189:38 - and i'm going to go into postman
189:42 - and i'll do again our simple get all the
189:44 - items request i'll hit send
189:48 - and yeah it keeps working just fine
189:51 - but as you can see the coding startup is
189:53 - way way simplified
189:56 - in the next lesson we will see how to
189:58 - move all of these common classes into a
190:01 - new shared library that can be used by
190:03 - all of our microservices
190:08 - it's time to move the common code with
190:10 - refactor from catalog microservice to a
190:12 - new shared class library that can be
190:14 - used by both catalog and any future
190:16 - microservice
190:17 - so to start with i have opened a new
190:19 - visual studio called instance
190:20 - i have opened my terminal and i am in
190:23 - the project directory so here we're
190:25 - going to create a new directory let's
190:26 - call it
190:28 - play that common
190:31 - and i'm going to open that directory in
190:32 - visual studio code
190:38 - all right
190:40 - now as usual i'm going to create a new
190:42 - sources directory
190:44 - src
190:46 - and here's where i'm going to open a new
190:48 - terminal
190:51 - to create a class library not a web api
190:53 - project but just a class library as we
190:54 - need
190:55 - what we can do is use dot cli
190:57 - by doing dot net new
190:59 - glass sleep
191:00 - and then we will give the name of play
191:03 - dot
191:04 - command
191:14 - so let's just erase the files that i can
191:16 - see that we can see on the left
191:18 - and then the first thing that i'd like
191:19 - to do is to generate the files that
191:21 - visual code needs to build our project
191:24 - but before we can do that we have to
191:25 - make sure that the omnisharp server is
191:27 - running the omnicharge server is the the
191:29 - component of the c-sharp extension for
191:30 - visual code that takes care of a bunch
191:32 - of productivity improvements in visual
191:34 - studio code like the generation of these
191:36 - files so what i'll do is just to kick
191:38 - off the object server i'll just click on
191:40 - class1.cs
191:42 - and as you can see on the bottom here
191:44 - omnisar servers is starting already
191:47 - and with that i can now go to view
191:50 - command plate
191:52 - that then generate assets for build and
191:53 - debug
191:56 - so that will go ahead and generate our
191:58 - vs code folder with the dash.json file
192:00 - inside
192:01 - and now that we have it i'll click on it
192:04 - and i'll go to this section to
192:06 - make
192:07 - the the build action the default action
192:10 - uh for building our project so i'll just
192:12 - add our group folder just like we did
192:14 - with the catalog microservice i'll
192:16 - select build easy fall true and save
192:20 - okay so with that i'll go ahead and
192:22 - close this
192:24 - and i'll delete this class one file we
192:25 - don't need it
192:28 - and now it's time to add a few nougat
192:31 - packages that our shared libraries our
192:33 - shared classes are going to need so
192:35 - first i'm going to switch to
192:40 - play that common and here i'm going to
192:42 - start adding a bunch of packages so i'll
192:44 - do
192:45 - net add package
192:46 - mongodb.driver
192:51 - okay so that's for mongodb now we need a
192:53 - couple of packages for the configuration
192:55 - related classes so donate a package
193:00 - microsoft
193:02 - extensions
193:04 - configuration
193:07 - okay we'll do that one and
193:08 - configuration.binder
193:14 - lastly we have to add the extensions
193:17 - that
193:18 - dependency
193:20 - injection and nugget package which is
193:22 - going to be used for everything related
193:24 - to the service container that we're
193:26 - using for the penis injection in this
193:28 - library
193:30 - with that done let's go ahead and start
193:32 - creating a folder to bring in our files
193:35 - so first of all that i'm going to create
193:37 - a right click and play that comma new
193:39 - folder folder is going to be settings
193:42 - and here's where we're going to place
193:44 - the settings files that we have in
193:45 - catalog so i'm going to go back to
193:46 - catalog folder the catalog directory
193:50 - or here
193:52 - and i will open settings and i'm going
193:54 - to copy these two files mongodb settings
193:56 - settings settings
193:58 - copy
193:59 - and back in common i'm going to paste
194:01 - those files here
194:04 - and i'm going to close the terminal for
194:05 - now
194:08 - and now that we have them here let's fix
194:10 - the the name space so that it matches
194:12 - our current uh our current project so
194:15 - this is going to be
194:16 - play dot
194:18 - com dot settings
194:20 - so vote for tv settings and for
194:23 - service settings
194:26 - okay with those files done let's go back
194:28 - to catalog and let's bring in
194:33 - our i entity interface i'll copy that
194:37 - i'm going to place it just at the root
194:38 - of play that common
194:43 - i entity
194:46 - and let's also bring our a repository
194:48 - interface
194:50 - repository copy into play.com at the
194:53 - root
194:55 - okay so these two should have also the
194:58 - name spaces fix it so they're just going
195:00 - to be played that
195:01 - common
195:02 - so play that common that one and play
195:06 - that comment on this one
195:08 - let's also get rid of any needed
195:09 - namespaces like this one here
195:11 - get rid of that one
195:13 - and we're good
195:15 - now i'm going to add a new folder for
195:17 - our mongodb related classes so i'm going
195:20 - to create a new folder here
195:22 - and play that command called
195:24 - mongodb
195:27 - and in this folder we're going to add
195:29 - let's go back to catalog
195:32 - we're going to add the extensions file
195:34 - and the repository file
195:38 - copy those ones
195:39 - back in common
195:41 - mongodb
195:42 - paste
195:45 - so for these ones the namespace is going
195:48 - to be play that
195:50 - common that mongodb
195:57 - and on this one again
195:59 - play that common that mongodb
196:01 - i'll also remove any needed namespaces
196:03 - from here
196:05 - and from here
196:09 - and in the case of extensions we also
196:11 - need to tell it the new namespace for
196:13 - the settings files so i'll go to service
196:16 - settings ctrl dot
196:17 - and i'll use play that command.settings
196:22 - okay so now we have all of these common
196:24 - classes in our new common common project
196:27 - and that should be good
196:29 - to start building a new package but
196:31 - since we are here let's actually take
196:32 - advantage of the opportunity to
196:34 - expand a little bit our mongol
196:36 - repository class with a couple of new
196:38 - functions
196:39 - that our future microservices are going
196:41 - to be using for querying entities based
196:43 - on a filter
196:45 - so
196:46 - let's go ahead and go to our i
196:48 - repository interface so let's start here
196:51 - and what we're going to do is add a
196:52 - couple of new functions similar to
196:55 - our overloads to get all async and gate
196:58 - async but they are going to be able to
197:00 - receive an expression
197:01 - as a filter to filter which entities are
197:04 - going to be returned
197:06 - so let's start by get lsync i'm just
197:07 - going to copy this function
197:09 - i'll add a new one here and the way that
197:12 - we're going to specify the filter is
197:14 - going to be an expression
197:16 - a link expression
197:17 - so it's going to be an expression let's
197:19 - add a missing space link expressions
197:23 - and the signature we're going to use is
197:24 - the one that mongodb is expecting from
197:26 - us so it's going to be a func
197:28 - of type t
197:30 - so whichever type is the empty
197:32 - and bull
197:36 - filter
197:38 - okay so again so this is the way to
197:40 - specify a filter so that eventually when
197:41 - we want to retrieve uh entities based on
197:44 - some features let's say
197:45 - give me
197:46 - all the items that are owned by a
197:48 - specific user in the case of inventory
197:50 - and we will be able to use such a filter
197:52 - here so you can pass a query expression
197:53 - here
197:55 - and then mongodb will be able to to
197:56 - handle that filter and return the
197:58 - correct items for us
198:00 - the same way that we did that let's do
198:02 - go ahead and do get async another
198:04 - overload that is also going to receive
198:06 - expression so in this case
198:08 - you don't need to specify just an id to
198:10 - get one item or one one entity but you
198:12 - can specify a filter to retrieve any
198:14 - entity that matches that filter
198:18 - yeah and when we get to our new
198:19 - microservice our emitter microservice
198:20 - will see how both of these functions can
198:22 - be used
198:24 - so now that we have that in the in the
198:26 - interface let's now go to
198:28 - repository and actually implement these
198:30 - new methods
198:32 - so i'll go ahead and click on a
198:33 - repository
198:34 - ctrl dot implement interface
198:37 - so that brings in our new
198:40 - methods at the bottom i'm just going to
198:42 - relocate them next to their other
198:44 - overloads just to keep them
198:46 - close to each other so put that there
198:48 - i'll grab get async
198:51 - and i'll put it next to
198:53 - our other get async overload
198:57 - there
199:00 - and really this is very straightforward
199:02 - so what i'll do is i'll copy the the
199:03 - last line of our other uh sorry other
199:06 - get all async
199:08 - method
199:10 - i've got here this line
199:11 - and i'll copy it to our new get a
199:13 - license overload and really the only
199:15 - thing that we have to do is pass the
199:16 - filter there
199:19 - because
199:20 - let's see if you go to find
199:23 - you're going to see that it it can
199:25 - expect it can receive a filter
199:26 - definition
199:29 - but then in another overload it can
199:31 - actually receive an expression of the
199:33 - type that we have defined so that's if
199:35 - that's the overload that we're going to
199:36 - be using from mongodb to be able to
199:38 - filter so i'm just going to pass the
199:39 - filter here
199:42 - and i'm going to make this method also
199:44 - async
199:46 - that will be enough to retrieve all the
199:47 - items based on the filter
199:49 - and for the other overload they get
199:51 - async
199:52 - again i'll copy the code from the other
199:55 - overload over here and here the filter
199:58 - is already
199:59 - there so it's ready to receive the
200:00 - filter
200:02 - but let's make it async
200:06 - and that that will do it so we can
200:08 - receive one one entity based on
200:10 - certified filter
200:11 - and like i said these methods are going
200:13 - to be very handy as we move to the
200:14 - future microservices
200:16 - so with that done let's go ahead and
200:17 - build everything make sure everything is
200:18 - built in correctly so i'll do ctrl shift
200:20 - p
200:24 - okay so everything builds just fine and
200:27 - what i'll do now is i'll switch to my
200:29 - powershell terminal so that we can
200:30 - create this nugget package and how do
200:32 - you create a nuget package very
200:33 - straightforward you just use dotnet cli
200:36 - with the netback operation so we will do
200:41 - and then you have specified the output
200:43 - directory with dash o
200:45 - and then given my current file structure
200:48 - what i would like to do is to place the
200:50 - package in a packages directory under
200:52 - the d projects
200:54 - folder
200:55 - so what i'll do is
200:57 - dash o
200:58 - slash
201:00 - i'll go up three directories and then
201:02 - i'll specify
201:03 - packages
201:04 - slash
201:05 - and that should be enough hit enter
201:09 - and that's it the nuget package has been
201:11 - created under the packages and we can
201:13 - confirm that by going to
201:15 - here
201:16 - we have a packages directory now and if
201:18 - i go to
201:20 - packages
201:21 - the package is right here so this
201:23 - package contains everything
201:25 - compiled out of our play.com
201:28 - library
201:29 - so now it's time to go back to catalog
201:32 - and start using this new nougat package
201:34 - so i'll switch to catalog
201:39 - here we are
201:40 - and before we can get a reference to
201:42 - that to our play.com nugget package from
201:44 - catalog there are two things that we
201:46 - have to do
201:47 - the first one is to specify a nougat a
201:50 - package source for recurring nougat
201:52 - installation
201:53 - so remember that nuget packages can live
201:55 - in multiple locations they could live
201:57 - somewhere in your internet they could
201:59 - live somewhere in the cloud in a public
202:01 - location like doggy.org or in a private
202:03 - feed library
202:04 - private feed sorry
202:06 - or or they could live in your local
202:08 - machine as it is our case
202:09 - but nougat doesn't know about that so
202:11 - you have to tell your nugget
202:12 - installation which are the possible
202:13 - package sources where it can find the
202:16 - nugget packages so we're going to tell
202:17 - it right now that our nugget packages
202:19 - are in our d a pack the project package
202:21 - location so to do that i'll open our
202:23 - terminal right here
202:26 - what i'll do is i'll use again.cli
202:29 - with the dot net nougat command but then
202:31 - do get add search and here's i have to
202:34 - specify the location of my packages so
202:36 - in my case that's going to be the
202:38 - projects
202:39 - packages
202:41 - and then i'll give it a name
202:43 - n uh just to have like two for easier of
202:46 - reference i'll name it play economy
202:50 - okay
202:51 - so it's been added successfully and just
202:53 - make sure that you update this this
202:55 - location depending on where you send
202:56 - your packages in the in the previous
202:58 - step
202:59 - the next thing i'd like to do and i'll
203:01 - collapse this a bit is to go to our
203:03 - plate catalog service cs prog and what
203:06 - i'm doing is i'd like to remove this
203:07 - mongodb driver reference because now
203:10 - everything mongodb is actually
203:11 - referenced and brought in via the nougat
203:13 - package so we will not need to have an
203:16 - explicit reference to mongodb driver
203:17 - here i'll just remove that
203:19 - and now save this project
203:22 - and now we can go ahead and add our
203:25 - play.com reference so to do that let me
203:27 - switch to
203:28 - src let's go to play that catalog
203:32 - service
203:33 - and then we can do
203:35 - dot net
203:36 - add package
203:38 - play that common
203:40 - enter
203:43 - and the reference has been added as you
203:45 - can see right here
203:47 - so with that it is time to start
203:49 - cleaning up things
203:50 - so i'll go ahead and close my terminal
203:53 - and i'll close this and a bunch of
203:55 - things that we can remove now are the
203:56 - identity interface
203:58 - you can remove
204:00 - our entire repositories directory can be
204:02 - removed
204:04 - and our settings directory can also be
204:06 - removed
204:09 - okay so now it's time to fix our
204:12 - our imports so let's go to item cs and
204:14 - make sure it can find that identity now
204:17 - leaves under play.com
204:19 - from nuget package
204:22 - in our controller also the irrepository
204:25 - interface now is coming from play.common
204:28 - and we'll remove this old namespace
204:33 - and finally in startup
204:35 - let's get rid of these all namespaces
204:37 - exactly clean up the entire thing i
204:40 - remove all new desired usings
204:42 - and service settings is now going to be
204:44 - coming from play.com on that settings
204:47 - also our addmongo extension method is
204:50 - also coming now from play.com.mongodb
204:54 - and that's what it is so we are now
204:56 - completely using our nuget package i'll
204:58 - make sure everything is built in via
205:00 - control shift p
205:02 - yep it's building just fine and now
205:04 - let's test if the
205:06 - if the service is running properly so
205:08 - i'll do f5 to run our service
205:12 - and i'll go to postman
205:16 - and i'll just go ahead and do a simple
205:18 - query for all the items in the database
205:20 - via our items operation in the res api
205:23 - i'll hit send
205:25 - and here we are we are retrieving items
205:27 - from the database so everything is
205:29 - working properly
205:30 - so it works just as before but now
205:34 - as you can see our uh and i'll just stop
205:36 - this
205:38 - our code base is much simpler so we
205:39 - don't have the i i entered this
205:41 - interface here we don't have the
205:42 - repositories folder we don't have the
205:44 - settings folder anymore
205:46 - and yeah our startup looks very clean
205:48 - and so this is going to help us a lot
205:50 - for the construction of our future
205:52 - microservices
205:54 - in the next lesson we will learn about
205:56 - docker compose and how it can help us
205:58 - simplify the way we configure and start
206:00 - our infrastructure services
206:05 - in this lesson we will learn about
206:07 - docker compose and how it can help us
206:09 - simplify the way we run our
206:11 - infrastructure services
206:14 - we already started using docker to run
206:16 - our mongodb database and we are doing
206:18 - this via simple docker run command
206:21 - however starting with the next model we
206:24 - will need to start bringing in many
206:25 - other infrastructure services to support
206:27 - our microservices
206:28 - for instance in the next model we will
206:31 - use ravidmq as our meshes broker
206:34 - and in future models we will choose sec
206:37 - prometheus and grafana to enable a
206:40 - series of observability related
206:42 - components
206:43 - so if we keep just using docker run to
206:46 - execute our infrastructure services we
206:48 - will have to perform too many steps to
206:50 - setup them and we will need to remember
206:52 - too many arguments for each of them
206:54 - like the right environment variables
206:56 - ports and volumes
206:58 - also some of our containers might need
207:01 - to talk to each other
207:02 - like grafana and prometheus
207:04 - and some of them might not be able to
207:07 - work at all without another container be
207:09 - up and running first
207:11 - which again is the case of grafana which
207:13 - won't be able to do much without
207:14 - prometheus being available first
207:17 - that's where docker compose come into
207:19 - play
207:20 - compose is a tool for defining and
207:22 - running multi-container docker
207:24 - applications
207:25 - we will now be able to define all of our
207:27 - infrastructure services in a single file
207:29 - called the door compose jaml file
207:33 - this will include the definition of the
207:34 - container to use in each case
207:37 - environment variables ports and even
207:39 - dependencies between them
207:41 - then we will execute a single docker
207:44 - compose up command
207:45 - and all the containers will start in the
207:48 - right order with the correct
207:49 - configurations
207:51 - also
207:52 - compose provides a default network that
207:54 - all containers are joined to
207:56 - in case they need to talk to each other
207:59 - so with docker compose we are able to
208:01 - document the way to configure all of our
208:03 - infrastructure services in a single file
208:06 - and we get to start all of them with
208:08 - just one line
208:09 - as opposed to multiple commands
208:12 - also they all join a default network
208:15 - in the next lesson we will create our
208:17 - docker compose file and move our current
208:20 - mongodb configuration over there
208:25 - before we start using docker compose
208:27 - let's first create a new directory where
208:29 - we can place the compose jaml file and
208:31 - any future infrastructure related files
208:34 - so here i am in a new visual studio code
208:36 - instance i have opened my terminal and i
208:39 - am switch it into the project directory
208:42 - so this directory i'm going to create a
208:43 - new folder i'm going to call it
208:45 - play.infra
208:48 - and now i'm going to open in the visual
208:49 - studio code
208:59 - and the first thing that i like to do
209:00 - here
209:01 - is to take advantage of the
209:04 - another extension for visual code which
209:06 - is the docker extension
209:08 - which we can find if we go to extensions
209:11 - this type docker
209:13 - this one here
209:15 - because this one is going to provide us
209:17 - some good recommendations as we start
209:19 - working in our docker compose file so
209:21 - i'm going to install this extension
209:22 - click install
209:24 - and that will show up a new icon on the
209:26 - left side docker
209:28 - so let's close this and let's go back to
209:30 - our explorer
209:32 - now we can do is just go back here and
209:34 - let's create a new file
209:36 - let's call it
209:38 - docker compose.java
209:41 - and before writing any code here what
209:44 - i'd like to do is to bring in that
209:45 - previous docker run command line that
209:47 - we've been using
209:49 - just to keep it as a reference as we
209:50 - start writing this docker compose file
209:53 - okay you remember this this line that i
209:54 - just pasted this is what we've been
209:55 - using so far to kick off our
209:59 - or container
210:01 - so the first thing that you want to do
210:02 - in this docker compose file is to define
210:04 - a version for it the version determines
210:06 - what features you're going to have
210:08 - available in docker compose because
210:10 - different versions of the token compose
210:12 - engine support different versions so you
210:14 - have to define what version is this file
210:16 - for
210:17 - so i'll say version
210:20 - it's going to be 3.8 is the last one the
210:22 - latest one available as i'm recording
210:24 - this lesson
210:26 - and the next section is what we call
210:28 - services the services will determine
210:30 - each of these services is really one of
210:32 - our
210:33 - docker containers
210:35 - so i'll define a services section
210:38 - and under services you want to define
210:41 - our first service which is in our case
210:43 - is going to be mongodb so i'll just name
210:44 - it one go
210:47 - and as i start as i start writing this
210:49 - uh notice the indentation that i'm
210:52 - setting between each of these
210:54 - elements indentation is important
210:56 - because it defines which elements go
210:58 - inside other elements
211:00 - uh but to make this more uh
211:02 - more easier to see for you what i'll do
211:05 - is i'll enable another setting because
211:06 - to the code so we can see the white
211:08 - spaces
211:09 - that are happening across across the
211:11 - place so i'll go to file
211:14 - preferences
211:15 - settings
211:17 - and i'll look for render
211:20 - white space
211:24 - yeah so it's this one here so i'll
211:26 - switch from selection
211:28 - into all
211:30 - then i'll close this
211:32 - and now we can see the white space right
211:34 - there
211:36 - yeah so as you work on this file just
211:38 - make sure that you're leaving the same
211:39 - amount of white spaces or indentation
211:41 - with different elements that we're going
211:42 - to write
211:44 - i will also collapse this left side the
211:46 - navigation pane since we don't need it
211:48 - for now so we can have more space
211:51 - so inside the element we're going
211:53 - to open yet another element
211:56 - we have to define the properties for
211:57 - this for this service so first thing
211:59 - we're going to define is the image
212:02 - and as you remember from the command
212:04 - line on the top the image is so
212:06 - i'll grab that
212:08 - then we have to give a name to this to
212:10 - this container so the container is going
212:12 - to start up so i'll say container name
212:14 - and the name that we've been giving over
212:16 - here is so let's use the same name
212:19 - it's going to be
212:22 - the next thing is the ports so
212:25 - for sports is actually an array of ports
212:29 - so the rate you can define by placing a
212:30 - dash first
212:32 - and then you specify the port mapping so
212:34 - i'll grab that port mapping from here
212:36 - as you remember port is 27017
212:40 - external port on the left side internal
212:42 - port on the right side
212:45 - and the next thing we have to define is
212:46 - a section for our volumes because
212:48 - remember that we need to map uh the
212:51 - slash data slash db directory inside the
212:54 - db container into a location outside of
212:56 - the host where the files are actually
212:58 - going to be written that's what we call
213:00 - a volume so to define volumes i'm going
213:02 - to go all the way
213:04 - here at the same level as our services
213:06 - section over there
213:08 - here we're going to declare a section
213:09 - called volumes
213:11 - and under volumes i'm going to define
213:14 - our mongodb data section which i'm
213:15 - actually going to copy
213:17 - over here one go to data
213:19 - column and that's really all you have to
213:21 - do to define a one volume uh in your in
213:25 - your machine
213:27 - and now we have to associate that volume
213:29 - to our service over there so i'm
213:32 - going to open yet another section here
213:35 - called volumes under ports
213:38 - and under volumes you have to define an
213:39 - array of all the volumes that you want
213:41 - for this service so the race starts with
213:43 - dash and then you define that that
213:45 - modeling mapping so i'm going to copy
213:47 - this again
213:50 - there
213:51 - so that defines
213:52 - that yeah so slash data slash db is
213:55 - mapped into mongodb data remember that
213:57 - we have to do this because otherwise
214:00 - our database files will be lost if we
214:02 - restart the container so from here on
214:04 - any time that the mongodb container
214:06 - tries to write to slash data slash db
214:08 - those files are actually going to be
214:10 - written into the mongodb data volume
214:12 - that's outside of the of the container
214:14 - and into a host machine
214:17 - okay so now i'll save this file
214:19 - and it's time to start running this a
214:21 - container via docker compose
214:24 - so i'll open my terminal ctrl j
214:27 - and the first thing i'd like to do here
214:29 - is make sure that i am not running
214:31 - mongodb container already
214:33 - so let's see
214:35 - wps
214:39 - docker ps
214:41 - and
214:42 - yeah so we are indeed running it already
214:45 - we don't want to have it running there
214:46 - because that could cause conflicts so
214:48 - i'll just go ahead and stop it
214:51 - docker stop monko
214:54 - okay and now uh it has been stopped
214:59 - so
214:59 - with that done we can go ahead and start
215:02 - our docker a container video via docker
215:05 - compose and we can do
215:07 - docker compose
215:09 - up
215:10 - hit enter
215:12 - and then that starts running the
215:14 - container and what you're seeing now is
215:16 - just the output of the mongodb container
215:19 - being generated directly into the
215:20 - terminal
215:22 - so now that we have the docker compose a
215:25 - docker composer running our dock our
215:27 - mongodb docker container uh let's see
215:30 - how is our catalog api working with this
215:33 - a new new way of running the container
215:35 - so i'm going to go back to uh to our
215:39 - catalog microservice
215:41 - and i'm just going to hit f5 to get
215:43 - things started
215:47 - okay with the host up and running let's
215:49 - go ahead and open postman and let's go
215:53 - ahead and try to get our old items in
215:55 - the database so here i am in my get
215:57 - operation for the rest api
216:00 - so i'll hit send
216:03 - and interestingly i'm not getting any
216:06 - items which is interesting because the
216:08 - as per our previous lessons we did have
216:10 - at least one item um already stored in
216:12 - the database
216:14 - so what's going on
216:15 - let's see uh let's go back quickly to
216:18 - visual studio code
216:19 - catalog
216:20 - and let's let's explore our database at
216:22 - this point in time so i'll collapse this
216:24 - a little bit
216:26 - and let's go to the mongodb extension
216:29 - and here's a localhost 27017
216:32 - i'll connect to it
216:34 - and the interesting piece here and i'll
216:36 - collapse these other pieces is that we
216:39 - don't have a catalog database anymore
216:41 - and this is happening because as we are
216:44 - started
216:45 - as we moved into docker compose
216:47 - a new volume has been created for our
216:49 - database files so technically this is a
216:51 - brand new database
216:53 - which has no items yet right so there's
216:55 - actually nothing in there so there has
216:57 - not been any need to create the database
216:59 - yet so that's why you don't see any
217:00 - database here so just keep that in mind
217:02 - as you switch from a raw docker
217:04 - execution into torque compose a new
217:06 - volume will be created
217:09 - so let's actually come up with something
217:10 - for our catalog database so i'll go back
217:12 - to postman
217:15 - and i'll go to my post tab
217:19 - body
217:21 - okay and so let's again define something
217:24 - here
217:24 - we'll go again to our potion example so
217:27 - it's a potion
217:29 - and
217:30 - it stores a small amount
217:33 - of hp
217:35 - and the price is going to be just 5.
217:39 - so go ahead and send
217:42 - this and the item has been created
217:47 - if we go back to our get items api once
217:50 - again hit send
217:52 - the item is there and if you go back to
217:54 - visual studio code to catalog and we've
217:56 - refreshed this
217:58 - you can see that now we have our catalog
218:00 - database with our items collection and
218:02 - the one document already created in
218:03 - there
218:05 - and one last tip that i want to give you
218:07 - as you start working with docker compose
218:09 - is how to prevent let me actually open
218:11 - docker compose how to prevent all this
218:13 - uh output to be shown here so in case i
218:16 - don't want to see all this output from
218:17 - the database all the time uh you can see
218:19 - things in a much cleaner way by doing
218:21 - the following so i'll go back here to my
218:23 - terminal i'll just hit ctrl c to stop
218:26 - docker compose
218:28 - and what you can do is
218:30 - you can do docker compose app but you
218:32 - can append the dash d
218:34 - a parameter to run in detach mode so if
218:37 - i do enter now
218:39 - the only that you're going to see is
218:40 - that it's starting and then it
218:42 - says done so the container is running in
218:44 - the background but you don't have to be
218:46 - looking at all the output all the time
218:48 - so you're running in a detached mode
218:50 - and still if you go back to
218:53 - postman and you query you can see that
218:55 - the container is actually running
218:57 - so we have reached the end of this model
219:00 - with a few improvements to our developer
219:01 - workflow
219:02 - and with a reusable library that will
219:04 - speed up the construction of our future
219:06 - microservices
219:08 - in the next module we will introduce our
219:10 - second microservice and we will learn
219:12 - about the multiple challenges of having
219:14 - microservices talk to each other
219:19 - in this model you will learn about the
219:20 - different microservice communication
219:22 - styles and then you will learn about a
219:24 - few techniques to properly implement
219:25 - synchronous inter-service communication
219:27 - between the existing catalog service and
219:29 - a new inventory service
219:32 - by the end of this model you will have a
219:34 - solid understanding of the following
219:37 - the different microservice communication
219:39 - styles
219:41 - how to implement synchronous
219:43 - communication between two services via
219:45 - rest and the http protocol
219:49 - what kind of partial failures could
219:50 - impact your mega services and why you
219:52 - should design for them
219:56 - how to set timeouts to fail fast when
219:58 - doing inter-service communication
220:02 - what is and how to implement the retries
220:04 - with exponential back-off technique
220:07 - and when to use and how to implement the
220:09 - circuit breaker pattern
220:12 - in this lesson we will create our
220:14 - inventory microservice which owns the
220:16 - player's inventory of purchase items
220:20 - just like we did with the catalog
220:21 - service we will define a rest api for
220:24 - inventory with a couple of operations
220:26 - which are
220:27 - both items which will be used to add an
220:29 - item to the player's inventory back
220:32 - and
220:33 - get items by user id which should
220:35 - retrieve all the items for the specified
220:38 - player or user
220:39 - talking about users you may have noticed
220:41 - that we have not properly introduced the
220:43 - concept of players or in general users
220:46 - into our system
220:47 - this is fine the management of the
220:49 - actual users database will be the
220:51 - responsibility of the identity service
220:53 - which will be we will create in a future
220:55 - model along with all the microservices
220:57 - security
220:58 - infrastructure for now we will choose
221:01 - random guides to identify the users that
221:03 - own the inventory items
221:05 - let's get started
221:07 - let's create our inventory microservice
221:10 - i have started by opening
221:12 - a new piece of studio called instance
221:14 - i have opened my terminal and i have
221:16 - switched to the project directory so
221:18 - i'll create a brand new directory for
221:20 - this new microservice
221:21 - so let's call it play that
221:24 - inventory
221:25 - and then let's switch to that directory
221:27 - in the terminal
221:30 - and then what i'll do is i'll use this
221:32 - command line to ask the current instance
221:34 - of visual studio code to open this new
221:36 - folder so i'll just do code
221:39 - that for the current directory and then
221:40 - i'll do dash r to reuse the green window
221:44 - so i'll hit enter
221:46 - that will be the equivalent to or we use
221:49 - the file open folder and menu but it's
221:51 - much faster
221:52 - now i'll create as usual our source
221:54 - directory
221:57 - and in that one i'll right click i'll
221:59 - say open integrated terminal to open a
222:01 - new terminal in that location
222:03 - and then i'll go ahead and use dot net
222:04 - cli to create the new project
222:06 - so.net new web api dash n play dot
222:12 - inventory dot service is going to be the
222:14 - name
222:23 - okay so that generates a bunch of files
222:25 - on the left side and i'll i'll get the
222:28 - omnishar server started by clicking on
222:30 - any of rc chart files so i'll click
222:32 - there that kicks in on the chart server
222:37 - and that prompts us to
222:38 - add the the
222:40 - test.json and logistics.json files so
222:43 - that this will code can build and debug
222:44 - our project so i'll say yes
222:47 - that adds our files on the left side
222:49 - over here
222:50 - and then i'll go right away to our
222:51 - task.json file
222:53 - to add our
222:55 - group section where we can say that this
222:58 - is the
222:59 - section that by default builds the
223:00 - project
223:02 - save that
223:03 - okay so now also close our terminal for
223:05 - now and then i'll go to launch.json and
223:08 - i will remove this section just like we
223:10 - did with catalog so that anytime we
223:12 - start the server it doesn't open up web
223:14 - browser by default i'll just remove that
223:18 - and what i'll do next is i'll go to
223:20 - uh under properties i'll go to launch
223:22 - settings.json because we want to specify
223:24 - which is going to be the ports that
223:26 - we're going to use for inventory so
223:28 - remember we are already using the
223:29 - default ports for catalog 5001 500 and
223:32 - 5000 so we have to use new ports for
223:35 - inventory they cannot be the same port
223:37 - so i'll use i'll go for 5005
223:41 - and 5004
223:43 - for our
223:45 - https and http ports for inventory you
223:47 - could use any other port really here as
223:49 - long as they are not being used by any
223:51 - other application in your your computer
223:53 - next i'll go ahead and i'll delete what
223:55 - we don't need from these projects i'll
223:57 - delete weather forecast controller
223:59 - and i'll delete the weather forecast
224:01 - class over here
224:03 - so now i'll get started by creating our
224:05 - details so the dtos that are going to be
224:07 - used by our controller class and their
224:09 - arrest api
224:10 - so just like we did before i already
224:12 - click in play inventory service i'll say
224:14 - new file i'll create dtos.cs
224:18 - here i'll declare our namespace
224:21 - the namespace is going to be
224:22 - play.inventory.service.dps
224:30 - and so we're going to define two dtos at
224:33 - this point
224:34 - the first one is going to be the dto
224:35 - used
224:36 - to
224:37 - grant items to a user and the other one
224:40 - is going to be the dto used to return
224:42 - the series of items that a user already
224:44 - has in their inventory
224:46 - so let's start by defining public record
224:50 - grant items video
224:53 - and to grant the knight into a user we
224:55 - obviously obviously need to specify the
224:57 - id of the user so it's going to be a
224:59 - good user id
225:02 - let's add the system in space there
225:06 - we also have to specify which is the
225:08 - item the catalog item that's going to be
225:10 - assigned so we will define that as
225:12 - catalog item id
225:14 - and lastly we have to specify how much
225:16 - of the item is going to be assigned to
225:18 - the user so that's going to be
225:21 - the quantity
225:24 - let's notify the other the other dto as
225:26 - public record this is going to be
225:29 - inventory
225:31 - item dto like i said this is the dto
225:33 - used to return items
225:35 - the items that are assigned to a user
225:37 - and the user's inventory so for this
225:40 - we're going to be returning the
225:42 - catalog item id
225:45 - the quantity
225:48 - and also let's define the
225:52 - the acquired date
225:54 - so this is the date when the item was a
225:57 - was put into the user's inventory
226:02 - so now that we have our details it is
226:04 - time to start defining the entities that
226:06 - we're going to be using to store
226:08 - inventory items into the database
226:10 - however before we can do that uh we have
226:12 - to bring in the
226:14 - our play.com nugget package so that we
226:16 - can start using the the bunch of classes
226:18 - and types that we have defined there
226:20 - including our i items
226:22 - our intt interface
226:24 - so to do that i'll go ahead and do ctrl
226:26 - j to open my terminal
226:28 - and i'll go to
226:30 - late that
226:32 - inventory service
226:33 - and then i'll just do
226:35 - net
226:36 - add
226:37 - package
226:38 - play that common
226:42 - okay
226:43 - so if you go now to play men3 service
226:45 - we'll see that we have the nuget package
226:47 - added here
226:48 - now we can go ahead and right click in
226:51 - play inventory service new folder
226:55 - entities
226:56 - and let's go ahead and define a new file
226:59 - it's going to be
227:01 - inventory item dot cs
227:05 - let's define our namespace
227:08 - it's going to be
227:09 - play.inventory service
227:13 - entities
227:15 - let's define the class
227:18 - public class
227:22 - inventory item
227:25 - and let's make this class right away
227:27 - implement our i
227:30 - i entity interface
227:33 - let's make it use play.com into a
227:36 - namespace
227:37 - and
227:38 - as we're implementing that interface
227:40 - let's do ctrl dot implement interface so
227:42 - we have to define a good
227:45 - so probably good id
227:47 - we'll make it define just a get
227:50 - we will use a get and set
227:52 - just like that
227:53 - okay so each metal item will have an id
227:56 - then it should have it should know to
227:58 - which user it belongs to
228:00 - so let's do
228:04 - probe good
228:07 - it's going to be user id
228:10 - next let's define
228:12 - which catalog item this inventory item
228:15 - corresponds to a reference to the
228:16 - catalog item
228:18 - so it's going to be prop
228:20 - good
228:21 - catalog item id
228:25 - next we'll define the
228:26 - quantity it's going to be the quantity
228:29 - how much of this item we have
228:31 - let me also close this terminal now
228:34 - and lastly
228:36 - let's define
228:38 - the time of set
228:40 - is going to be the acquired date
228:43 - the day when the item was assigned to
228:45 - the user in the inventory
228:47 - save that
228:49 - and just like we did with catalog let's
228:51 - define an extension method so that we
228:52 - can transform
228:54 - one of these inventory items into the
228:57 - inventory item dto
228:59 - so i go ahead to the root play inventory
229:01 - service i'll add a new file i'll call it
229:03 - extensions
229:06 - let's add an a space
229:11 - play that inventory that service
229:15 - and let's add
229:16 - public static
229:22 - class extensions
229:28 - and let's define our method here so
229:30 - public
229:32 - static is going to return an inventory
229:34 - item video
229:37 - let's call it sdto and let's import a
229:40 - missing namespace
229:42 - and it is going to be extending
229:45 - inventory item
229:48 - into the item
229:50 - let's import that it's going to be the
229:52 - item
229:56 - and here it is just about creating a
229:58 - brand new item dto out of this item so
230:01 - we will say return new
230:04 - inventory item dto with item
230:08 - dot catalog item id
230:10 - item dot
230:14 - quantity
230:15 - and item that
230:19 - acquire date
230:21 - so that's all we have to do to transform
230:23 - the item entity into an identity
230:26 - now we can go ahead and create our
230:27 - controller so let's go to the
230:29 - controllers folder right click new file
230:32 - we'll name it items controller
230:35 - just like we did in catalog
230:40 - let's define the namespace for it
230:44 - play inventory service
230:47 - controllers
230:48 - it's going to be
230:50 - public class
230:52 - items controller
230:56 - and remember each of our itunes
230:57 - controllers should be
230:59 - a mark with the api
231:02 - controller attribute
231:06 - it should derive from
231:09 - controller base
231:12 - and it should define the base route that
231:14 - is going to be a map2 so route
231:17 - this route just like with catalog is
231:19 - also going to be items
231:21 - just because it also manages items
231:23 - so route items
231:27 - so now we're going to need a one class
231:28 - level variable here which is going to be
231:31 - the repository that we're going to be
231:32 - using to store and retrieve items so
231:35 - let's define private
231:37 - read-only
231:39 - it's going to be a repository
231:42 - of type
231:44 - inventory item
231:48 - and let's just name it items repository
231:54 - so let's import play common here
231:58 - and let's import play inventory service
231:59 - entities
232:02 - let's also collapse this navigation pane
232:03 - for now since we are not going to be
232:05 - using it for a bit
232:06 - and now we have to do dependence
232:07 - injection to actually receive this items
232:09 - repository into the controller so let's
232:11 - define a constructor
232:16 - okay so this constructor is going to
232:18 - receive again our i
232:22 - our repository so just copy that here
232:24 - item repository
232:26 - and let's assign it to our local
232:28 - instance
232:30 - hide the repository
232:33 - so now it's time to define our two
232:35 - operations
232:36 - here we need an operation to get all the
232:38 - items in the inventory and one operation
232:40 - to put an item or to create an item into
232:43 - the inventory so let's start with the
232:45 - get operation
232:46 - let's define that as public async
232:50 - task
232:51 - of action result
232:54 - and this is going to be of an
232:55 - innumerable
233:00 - of inventory
233:03 - iron detail
233:07 - and then we'll name it just get async
233:12 - get async and the parameter is going to
233:14 - be the user id so we want to get all the
233:16 - items in a user's inventory so we're
233:19 - going to receive
233:21 - good user id
233:25 - okay let's see let's add any missing
233:27 - spaces 3d tasks
233:31 - systems collection generic
233:35 - and service ctos
233:38 - and for the guide using system
233:41 - let's also define the verb that is
233:43 - associated to this api which is going to
233:46 - be http get
233:50 - and so the way that this api is going to
233:51 - where this operation is going to work is
233:53 - we just need to go ahead and get
233:55 - all the items based on the user so but
233:57 - before we can do that let's do a quick
233:59 - check let's make sure that this user id
234:02 - is not empty so if it is a good empty we
234:05 - are going to return
234:08 - a
234:09 - bad request
234:13 - request
234:14 - a simple validation in there
234:16 - and so to get the items we're going to
234:18 - do this so we'll say so the items
234:21 - is going to be and we're going to open
234:23 - up braces here
234:26 - we're going to do a sink call to items
234:28 - repository
234:29 - get all the
234:30 - sync and here's where we can start using
234:33 - our
234:34 - expression our filter based on an
234:37 - expression
234:38 - so in this case what we want to say is
234:39 - that we want to get
234:41 - any item
234:43 - where item.user id equals the user id
234:47 - that we got as a parameter over here
234:52 - okay so that's that's how we can filter
234:54 - items based on a user in this case
234:57 - and then when we have that we can do a
235:00 - select
235:02 - and let's see if we're missing another
235:03 - namespace system link
235:06 - where we're going to specify that we
235:08 - want to take each of these items that we
235:10 - found in the database and transform them
235:12 - as
235:13 - into a dto with our extension method
235:18 - and finally we'll go ahead and just say
235:20 - return
235:22 - return the items
235:24 - let's also transform this let's just
235:26 - wrap this into the ok
235:28 - into the k action result
235:31 - and that's all we have to do so that
235:33 - will return all the items in the user's
235:35 - inventory
235:38 - the next method is the one that we're
235:39 - going to use to assign one item to the
235:41 - inventory
235:43 - this is going to be a post operation
235:45 - so let's see let's define it as
235:46 - publication task
235:49 - we will just do action
235:51 - result we're not returning really
235:52 - anything out of this method
235:55 - i'm going to impose async
235:57 - and it's going to be receiving
236:00 - our grand ideas dto
236:03 - at istio
236:07 - let's mark this with the
236:09 - http post verb
236:13 - here we're going to do is we will try to
236:15 - find
236:16 - the
236:16 - if we have that inventory item already
236:19 - assigned in inventory because it could
236:20 - already have it so in which case we just
236:22 - need to increase the quantity or in the
236:24 - other case when we don't have it
236:26 - we just have to
236:27 - create it for the first time in
236:29 - inventory
236:30 - so let's try to find it so we'll do
236:33 - so it's going to be inventory item
236:36 - equals
236:38 - await
236:40 - items repository
236:42 - get a sync
236:44 - and again here's where we can use the
236:45 - expression filter
236:47 - where we're going to say that the item
236:49 - that we're going to
236:50 - try to find has to be one where the item
236:53 - that user id
236:55 - has to match the grand item cto user id
237:00 - and also
237:01 - the item that catalog item id has to
237:04 - match
237:04 - grant identity to your catalog item id
237:08 - let me see if i can put this in the next
237:09 - line
237:14 - so that will find the item if it is
237:16 - there so
237:17 - but if the inventory item
237:20 - happens to be new it is this is the
237:22 - first time that we assign this item to
237:23 - the user
237:27 - so in that case we will go ahead and say
237:30 - inventory item equals new
237:33 - inventory item
237:41 - and we will set its catalog item id
237:44 - is grant items dto.cattleguardian id
237:49 - the user id is
237:52 - grab itemcto.userid
237:55 - the quantity
237:58 - is that quantity
238:00 - and for acquired date we will just set
238:02 - our current date time offset so it's
238:05 - going to be
238:07 - daytimeoffset.utc.now
238:14 - and finally we will call
238:16 - our method in items repository to create
238:20 - an item so create a sync
238:23 - inventory item
238:28 - okay let's add this missing
238:30 - using semicolon there
238:32 - and then let's go for the other branch
238:35 - so else we did find the item so we just
238:37 - need to increase the quantity so for
238:39 - that we will do
238:40 - inventory item.quantity
238:43 - plus equals
238:45 - itemcto.quantity
238:48 - and then we will do weight
238:50 - itemrepository.updatesync
238:54 - with the inventory item
238:58 - and finally we will just return
239:00 - we'll just return okay
239:04 - and that's pretty much for the a
239:06 - controller operation so we have two
239:08 - two operations to retrieve the items in
239:10 - inventory and to put an item into the
239:12 - inventory
239:13 - so with that done it is time to start
239:15 - doing the basic uh configuration of a
239:18 - startup
239:19 - so i'll go back to our
239:22 - explorer here
239:23 - and first let's go to websites.json here
239:26 - we have to define
239:27 - uh the settings for our
239:30 - in order to define the service name and
239:32 - the mongodb a mongodb connection
239:36 - so to save time what i'll do is i'll go
239:37 - back to catalog actually and i'll open
239:40 - my app sizing json file over there and
239:42 - i'll just copy these two sections
239:44 - from the app statistic json
239:46 - i'll go back to inventory and i'll paste
239:49 - that right here
239:51 - really the main thing the only thing
239:52 - that we have to change here is that this
239:54 - is not the catalog service anymore this
239:56 - is the
239:57 - inventory service remember that this is
239:59 - what's going to define the name of the
240:00 - database that's going to be created in
240:02 - in mongodb
240:04 - save that
240:05 - and now i'm going to want to go to
240:06 - startup
240:09 - i'll actually clean up a bit disney
240:11 - spaces so i'll do control dot here
240:13 - remove necessary usings
240:15 - and now i'll go to the start of
240:16 - configure services
240:19 - and i'll add the services for mongodb
240:22 - and the repository so i'll do services
240:25 - that
240:26 - add
240:28 - and that may need another import pay
240:30 - common mongodb
240:32 - and then i'll add
240:34 - a repository
240:36 - of type
240:37 - inventory item
240:41 - let's add a using there
240:44 - and here we have to specify the name of
240:46 - the collection here so the name that
240:47 - we're going to give it is
240:49 - inventory
240:51 - inventory items
240:54 - save that
240:56 - and so with that we have registered
240:57 - everything related to mongodb
241:00 - and
241:00 - we actually are ready to
241:02 - start trying out this microservice so
241:05 - i'll go ahead and hit f5
241:10 - okay
241:11 - and then what i like to do is actually
241:13 - import the
241:14 - the specification cover api into postman
241:17 - to make our lives a bit easier what i'll
241:19 - do is i'll copy
241:20 - a copied
241:22 - url of our service localhost 5005
241:26 - and then i'll go to our browser just for
241:29 - this time paste that there and then
241:31 - let's go to slugger
241:33 - so this defines as you can see this is
241:35 - the soccer ui page for our
241:38 - rest api then i'll click in the
241:40 - swagger.json link here and i'll copy
241:42 - that
241:44 - copy that and then i'll just close this
241:46 - browser
241:48 - now i'll go to postman
241:50 - and here what i'll do is i'll just click
241:51 - on import
241:53 - link
241:54 - i'll paste that
241:56 - click continue
241:58 - and i'll just say import
242:00 - so now if we go to collections we have
242:03 - now not just a catalog service section
242:05 - but also a collection but also a plain
242:06 - inventory service collection with our
242:09 - two items related operations
242:12 - so what i'd like to do is to go ahead
242:14 - and post and try out our post to assign
242:16 - an item to a user
242:18 - but of course before that we have to
242:20 - define the base url for our for this
242:23 - collection
242:25 - so let's go to dot
242:27 - let's go to edit
242:30 - variables
242:32 - and in this case our base url is as
242:34 - remember let's go to
242:36 - inventory base url is
242:38 - localhost 5005.
242:43 - put that here
242:45 - i'll put it for current value and for
242:48 - initial value
242:50 - update that
242:51 - okay so it knows
242:52 - the base url
242:54 - now being imposed we go to body and
242:56 - here's the three things that we need
242:58 - user id catalog item and quantity
243:00 - now for user id um like i said in the
243:03 - introduction we don't uh we don't have
243:05 - actual users so far so we just generate
243:07 - a random one and one handy way that we
243:09 - can do that in postman is by using the
243:11 - coolid function that's built into
243:13 - postman so what you can do is just this
243:15 - so open two sets of curly braces and
243:17 - then you're going to do just good so
243:20 - that will on the fly generator quit for
243:22 - us
243:24 - and for the catalog item id we want to
243:26 - know the id of one of our items in the
243:28 - catalog so to do that let's actually
243:30 - query our catalog items but before doing
243:32 - that let's go back to catalog and just
243:35 - hit f5 to actually start the web server
243:37 - so that we can query the catalog
243:40 - and then i'll go back to postman
243:42 - into our play catalog service collection
243:44 - i'll expand this i'll go to get items
243:47 - and i'll just hit send
243:50 - and here is the one item that we have
243:52 - the catalog the potion so i'll copy this
243:54 - id
243:58 - and i'll go back to our post operation
244:01 - paste it there
244:02 - and let's say that we want to assign
244:03 - just one
244:05 - one of these potion into the user's
244:07 - inventory
244:09 - so now go ahead and hit send
244:13 - and we got 200 okay meaning it was a
244:15 - success
244:17 - and so to verify that this actually
244:19 - worked let's actually try out our get
244:21 - all items in inventory
244:23 - operation so i'll click on this new
244:26 - operation
244:27 - and in this case the first thing that
244:29 - we're going to need is uh to specify the
244:32 - which is the user id right so which user
244:34 - was that item assigned to
244:36 - which we if you go back to post it was
244:38 - an automatic automatically generated
244:40 - users we actually don't know yet but we
244:42 - can figure that out via our console so
244:44 - i'll click on the console down here
244:47 - and you open the post operation
244:49 - and we expand the body the request body
244:52 - you see the user id is right here so
244:54 - this
244:54 - the console records everything that's
244:56 - going on behind the scenes so it's
244:57 - pretty handy in this case so i'll just
244:58 - copy the user id and i'll close this
245:02 - then i'll go back to our get items from
245:04 - the inventory service and i'll paste
245:06 - that right here
245:08 - so with that i'll go ahead and hit send
245:12 - and here it is
245:13 - so this user has a one of the catalog
245:16 - item of this id and with this acquired
245:19 - date where the date was assigned
245:22 - and so let's say that we wanted to
245:24 - increase the quantity of that item for
245:26 - this user and we want to actually test
245:28 - this this other codepath so let's go
245:30 - back to post
245:32 - body and let's say that we want to add
245:35 - uh perhaps four more uh potions to these
245:38 - users inventory so i'll just do that
245:40 - uh we want to change now we don't want
245:42 - to generate get another good so replace
245:45 - user id
245:46 - with the id that we we just copied
245:49 - for our user so then i'll go ahead and
245:53 - hit send
245:54 - 200 okay and then if we get items for
245:57 - this user in inventory i'll hit send
245:59 - and now the quantity is five
246:01 - so now the user has five items in his
246:03 - inventory
246:05 - okay
246:06 - so at this point our inventory service
246:08 - can store and report the items that each
246:10 - user has in his inventory back
246:12 - however notice that this dto that we
246:14 - have returned
246:16 - by the get operation only provides the
246:18 - ids of the items in the user inventory
246:21 - so since we don't have any names of
246:23 - descriptions it is a bit hard to tell
246:25 - which items are in the user inventory
246:27 - which are the actually so what does 4e
246:30 - 9c
246:31 - means really
246:33 - so
246:34 - in the next lesson we will learn about
246:36 - microservice communication styles and
246:39 - how our inventory service can use them
246:41 - to retrieve more details about each of
246:43 - these items from the catalog service
246:48 - in this lesson we will learn about the
246:49 - different microservice communication
246:51 - styles and how to implement the
246:52 - synchronous communication style vrs and
246:54 - the http protocol
246:58 - there are basically two ways you can
247:00 - communicate with microservices
247:02 - the synchronous style where the client
247:04 - sends a request and waits for a response
247:06 - from the service
247:08 - and the asynchronous style where the
247:10 - client sends a request to the service
247:12 - but the response if there's any response
247:14 - will not be sent immediately
247:17 - so far we have been using the
247:18 - synchronous communication style when
247:20 - interacting with our services via
247:21 - swagger ui and postman
247:23 - and in this lesson we will explore how
247:25 - to use it for inter-service
247:26 - communication
247:28 - we will learn about the asynchronous
247:29 - communication style in a future lesson
247:34 - when using the synchronous communication
247:36 - style the client sends a request and
247:38 - waits for a response from the service
247:40 - which means that the client cannot
247:42 - proceed without a response
247:45 - you may make this more evident with any
247:47 - of our services if you put a breakpoint
247:49 - in one of our service controller actions
247:51 - like get async in the catalog items
247:52 - controller start a debug session in bs
247:55 - code and then try sending a get request
247:57 - to it be a postman
247:59 - you will notice that postman waits
248:00 - indefinitely for our service to respond
248:03 - it can continue until the service
248:04 - responds
248:06 - many times this type of communication
248:08 - uses a blocking threat meaning that the
248:10 - client is unable to receive any other
248:12 - inputs or perform any other task until
248:13 - the response arrives but it could also
248:16 - use an unblocking thread where the
248:17 - client just offers a callback method to
248:19 - the service so the service can call the
248:21 - client back when the response is
248:23 - available
248:24 - in this case the client thread does not
248:26 - block even when it still waits for
248:28 - response
248:30 - there are two approaches currently to
248:31 - use the synchronous configuration style
248:34 - rest with the http protocol
248:37 - which is a traditional approach and the
248:38 - one that we have been using so far
248:40 - in res the business objects are modeled
248:43 - as resources
248:44 - and http verbs are used to manipulate
248:47 - them
248:48 - also you usually use xml or json to
248:51 - represent the resources
248:52 - most clients support rest
248:56 - the other approach is grpc
248:58 - which is a binary message-based protocol
249:00 - in which clients and servers exchange
249:02 - messages in the protocol buffers format
249:05 - grpc is becoming increasingly popular
249:07 - because it supports http 2
249:10 - and is more efficient addressed
249:12 - however not all clients support http 2
249:15 - which is why in a microservices
249:17 - architecture grpc is used mostly
249:20 - internally between the api gateway and
249:22 - the services or between the services
249:26 - in the next lesson we will be
249:27 - implementing synchronous communication
249:29 - between catalog and inventory
249:30 - microservices using rest and http
249:34 - at this point when the client requests
249:36 - the items inventory back for a user
249:39 - the inventory service creates its
249:40 - database and retrieves an array that has
249:43 - basic info about each item including the
249:45 - catalog item id and the quantity
249:49 - however having a list of item ids does
249:51 - not tell much to our client in terms of
249:52 - what actual items the user has on
249:54 - inventory
249:55 - ideally we would like to get at least
249:57 - the name of each item and hopefully also
249:59 - a subscription
250:00 - however inventory doesn't know such
250:02 - details about the items since the
250:04 - information is owned by the catalog
250:05 - service
250:07 - one way to address this is to have the
250:09 - inventory service send a get request to
250:11 - the catalog service to retrieve the
250:13 - details of all the items
250:15 - inventory can then combine this
250:17 - additional info with the details it has
250:19 - in its own database to send back the
250:21 - decided more detailed payload to the
250:23 - client
250:24 - let's go ahead and implement this
250:26 - approach
250:29 - our inventory microservice needs to
250:31 - receive data from the catalog
250:33 - microservice
250:34 - but before we can do that it first needs
250:36 - to define the dto that represents the
250:38 - retrieved catalog items
250:40 - now it turns to be that we already have
250:41 - such a dto that represents catalog items
250:44 - and if we go to our catalog
250:48 - project our catalog microservice and if
250:50 - we go to dtos.cs we're going to see that
250:52 - such d2 is right here so this is the dto
250:54 - item dto
250:56 - that represents
250:57 - cattle guidance when you query for them
250:59 - so what i'll do is i'll just copy this
251:01 - dto
251:03 - copy this and then i'll go to inventory
251:06 - here we are in inventory and i'll open
251:09 - dto.cs and i'm just going to paste that
251:11 - as initial
251:13 - dto for uh for the inventory
251:16 - and the case of inventory we're going to
251:18 - rename this into
251:20 - catalog item detail
251:22 - just do not confuse it with inventory
251:24 - attended to you
251:25 - and uh for example inventory again uh we
251:28 - don't need that many properties when
251:30 - we're querying for catalog items and you
251:32 - don't have to retrieve everything or at
251:34 - least digitalize everything into
251:36 - inventory the only thing that we're
251:37 - going to need in this case is the id of
251:39 - the item the name and the description
251:43 - we don't need price and created date
251:45 - for our purposes so remove those save
251:48 - this
251:49 - and now that we have this dto we can
251:51 - actually build a client that is going to
251:54 - be able to query for this item from
251:55 - catalog so i'm going to right click in
251:57 - play inventory service i'll create a new
251:59 - folder
252:00 - let's call it clients
252:04 - and in this one i'm going to create a
252:05 - new file that i'm going to name
252:07 - catalog client that's cs
252:11 - let's give it a namespace
252:16 - display inventory service
252:19 - clients
252:22 - public class
252:25 - catalog client
252:27 - so in order for our catalog client to be
252:29 - able to talk to any external
252:31 - http endpoint it needs to use the
252:35 - net http client class so we're going to
252:38 - define that as a class level variable
252:40 - here
252:42 - private read-only http client
252:46 - http client
252:48 - and i'll import the
252:50 - system.http in space
252:52 - and now we're going to do dependency
252:54 - injection of this client into our class
252:57 - so public catalog client
253:00 - http client
253:05 - and we'll take that reference
253:11 - now that we have that client available
253:13 - we're going to define the function
253:14 - that's going to retrieve actually
253:16 - retrieve the items from catalog so this
253:18 - is going to be an async function so
253:20 - let's define it as asynctask
253:23 - and what we're going to return is a
253:25 - collection of catalog item dto
253:27 - since the the consumer is not expected
253:29 - to modify this collection in any way
253:31 - we're just going to return a read-only
253:35 - collection
253:36 - of type catalog item dto
253:41 - and we'll name it get
253:43 - catalog
253:45 - items async
253:48 - let's import missing spaces
253:51 - for
253:52 - tasks and forbid on the collection
253:56 - and for catalog item video
253:59 - to retrieve the items
254:00 - we can do that really easily with one
254:02 - line so we'll do
254:05 - items
254:06 - equals weight
254:08 - http client
254:11 - get from json let's change this
254:15 - get from json async
254:18 - we need to import another space system
254:20 - http json
254:22 - and we'll um
254:24 - will deserialize as i
254:26 - read only collection of type catalog
254:29 - item video
254:33 - and then here is where you put the route
254:35 - that you want to access in the invoked
254:38 - address api in our case in the cases of
254:40 - catalog the
254:41 - route would be under items
254:45 - and with that we can go ahead and return
254:48 - return the items
254:50 - that's all you have to do to invoke
254:52 - another a recipe i in another service
254:56 - with that done it is time to update our
254:58 - inventory identity to have this
255:00 - additional information that we're going
255:02 - to collect from catalog so let's go back
255:04 - to dtos
255:06 - and inventory item dto we're going to
255:08 - add
255:10 - a name
255:12 - and a description
255:16 - but as we do that and as we can see
255:18 - extension is complaining and it's
255:20 - because we need to provide that
255:21 - additional additional uh members to the
255:24 - construction of inventory in dtu as we
255:25 - transform the inventory item entities
255:29 - so what we'll do is we're going to
255:31 - receive additional parameters into this
255:32 - method which are going to be
255:35 - the name
255:36 - and the description
255:37 - [Music]
255:40 - and we'll fit those two into inventory
255:43 - item dto constructor
255:46 - there
255:48 - with that done we are ready to go to our
255:50 - controller to actually take advantage of
255:52 - this new
255:53 - this new information so i'll go to items
255:55 - controller
256:00 - and the first thing that i'll do is i'll
256:01 - get a reference while defining a
256:03 - classless variable for our catalog
256:05 - client so i'll define
256:07 - private read-only
256:10 - catalog client
256:13 - capital client
256:16 - okay let's import the missing space
256:18 - and let's receive that
256:21 - as a penis injection into items
256:22 - controller
256:24 - i receive the catalog client
256:26 - and we'll get the reference
256:31 - and now that we have that let's change a
256:33 - little bit how we do the our get async
256:36 - method
256:37 - so we'll get rid of these lines for
256:40 - now and the first thing that we're going
256:42 - to do is to actually
256:45 - retrieve the catalog items so how do we
256:47 - get the catalog items
256:49 - very easily now we can do
256:51 - catalog items
256:53 - equals
256:54 - weight
256:55 - cattle client that get catalytic items
256:58 - async
256:59 - that's all it is
257:01 - okay so that gives us all the catalog
257:03 - items in the catalogs microservice now
257:05 - we want to get the list of all the
257:07 - inventory items that we have currently
257:09 - in the inventory microservice
257:11 - so we'll do that via
257:13 - inventory item entities
257:16 - it's going to be
257:18 - await item repository get all these sync
257:22 - where the item item that user id
257:26 - equals the user id that we got as a
257:28 - parameter
257:30 - okay so now we have all the catalog
257:32 - items and then we have all the entities
257:34 - the inventory item entities for the
257:35 - current user now we need to combine
257:37 - these two pieces of information to
257:39 - produce the dto that we want to return
257:41 - so to do that we'll do this so
257:44 - inventory item dtos
257:47 - equals
257:48 - inventory item entities
257:52 - select so we're going to do a projection
257:54 - here
257:55 - for each inventory item
257:57 - [Music]
257:58 - we will do this
258:01 - let me close that
258:04 - first we will look into the collection
258:06 - of catalog items and we will find the
258:07 - catalog item that corresponds to the
258:10 - current inventory item
258:11 - so
258:12 - catalog item equals catalog items
258:17 - that's single there should be one and
258:19 - only one catalog item where
258:21 - the catalog
258:24 - item
258:26 - catalog item
258:29 - that id
258:31 - should match exactly the inventory item
258:34 - that
258:36 - catalog item id
258:39 - and once we have that we can
258:42 - do the
258:43 - conversion of the inventory item into a
258:44 - dto so we will do
258:47 - enter the item
258:49 - return inventory item as dto
258:51 - and then we have to provide the catalog
258:54 - item
258:54 - that name and the catalog item
259:00 - that description
259:04 - and finally now that we have the
259:05 - inventory identities we will return
259:06 - those as opposed to these old items
259:08 - collection so inventory item details
259:12 - so our catalasing method is ready to
259:14 - retrieve
259:15 - an improved set of items with name and
259:17 - description
259:18 - and now it is time to do the proper
259:20 - registration in a startup
259:22 - to let our
259:24 - application know about this new
259:26 - catalog client that we're going to be
259:28 - using
259:30 - let's go to startup
259:32 - and what i'll do is i'll open a little
259:34 - section just under our
259:36 - registration
259:38 - so i'll do
259:40 - services
259:41 - dot
259:42 - add
259:43 - http client
259:45 - and alt line is going to be catalog
259:47 - client
259:49 - let's import missing a space
259:54 - and then i'll receive a specifier
259:56 - parameter here is going to be the client
260:00 - okay let's open that expression there
260:03 - and here really the only thing that we
260:04 - have to specify for now is the the base
260:07 - address of this automaker because
260:09 - otherwise how how would it know
260:11 - so we're going to say that the client
260:13 - base address
260:15 - equals
260:16 - a uri
260:19 - let's import a missing space
260:21 - and then if you remember the uri where
260:23 - our catalog microservice leaks so far is
260:26 - a localhost 5001 so that's what you have
260:28 - specified here https
260:32 - localhost
260:33 - 5001.
260:36 - okay
260:37 - so this is a handy way to register our
260:40 - catalog client so that it can be used
260:43 - by dependency injection in other classes
260:44 - like in the controller right so you say
260:46 - http client catalog client and then you
260:49 - specify the base address and then when
260:51 - that client is instantiated it will
260:52 - automatically receive an instance of the
260:54 - http client that you're going to be
260:56 - using to query four items
260:59 - okay so with that done let's go ahead
261:02 - and hit f5 let's see this in action
261:05 - let's not forget to also do an f5 in our
261:08 - catalogue service so i'll go ahead and
261:10 - start also here's catalog i'll start it
261:12 - f5
261:15 - and with the two service up and running
261:17 - we can go ahead and go to postman
261:22 - here in postman i am already
261:24 - in the in the tab for the operation that
261:26 - can retrieve all the inventory items for
261:28 - specified user id so this is user data
261:30 - we've used in the previous lesson uh so
261:32 - let's see what information we can get
261:34 - now that we created the api so we'll go
261:36 - ahead and hit send
261:39 - and as you can see we are able to
261:41 - retrieve the catalog item but this time
261:43 - we not just have the id of the item we
261:45 - also have the name
261:47 - and the description of the catalog
261:52 - okay so this seems to be working pretty
261:55 - well
261:56 - however
261:57 - think about what will happen
261:59 - if the catalog service started having
262:01 - issues at least temporarily but what
262:03 - happens if it's completely down
262:06 - in the next lesson we will learn about
262:08 - the problems that we might find when
262:10 - having a service communicate with
262:12 - another service
262:15 - in this lesson we will learn about
262:17 - partial failures in microservices and
262:20 - how to deal with them using timeouts and
262:22 - the exponential back-off technique
262:26 - even after placing our best efforts to
262:28 - ensure we have a healthy system it is a
262:30 - matter of fact that in distributed
262:32 - systems partial failures will happen
262:35 - this could be due to multiple reasons
262:37 - including network outages
262:39 - hardware failures
262:41 - dependency failures and even routine
262:43 - things like having a deployment in
262:45 - progress
262:46 - regardless of the cause of the partial
262:48 - failure
262:49 - when calling a dependent service it
262:51 - could certainly cause our microservice
262:53 - to fail
262:54 - which will end up in a bad experience
262:55 - for our clients
262:58 - so whenever a service makes a
262:59 - synchronous request to another service
263:01 - there is an ever present risk of partial
263:03 - failures and so you must assign your
263:06 - service to be resilient to them
263:10 - one of the first things to consider when
263:11 - making requests to dependent service is
263:13 - setting appropriate timeouts
263:16 - a service client should be designed not
263:18 - to block infinitely and use timeouts
263:22 - think about the experience of our client
263:24 - when the catalog service takes a long
263:25 - time to come back to our inventory
263:27 - service
263:28 - if it ever comes back
263:30 - now the inventory service is also taking
263:32 - forever to respond to the client leaving
263:34 - our users with a bad experience
263:37 - and not only that at least one of the
263:40 - threads of inventory is now busy not
263:42 - being able to serve any other requests
263:44 - which reduces the amount of available
263:45 - resources in the service
263:48 - instead of this you can set a timeout of
263:50 - say no more than one second so that if
263:53 - catalog service takes more than that to
263:56 - respond
263:57 - the request immediately fails
263:59 - and the inventory service can in turn
264:02 - return the appropriate request to the
264:03 - client even if it's a failure
264:06 - this enables a more responsive
264:08 - experience and also ensures that
264:10 - resources are never tied up indefinitely
264:15 - like we mentioned it is not uncommon for
264:17 - transit failures to occur in a
264:19 - distributed environment
264:21 - therefore you usually want to give the
264:22 - dependent service one more chance to
264:24 - come back with a successful reply
264:27 - however you don't want to keep
264:28 - retraining at a constant rate since that
264:30 - could overwhelm the dependency
264:33 - a good strategy that you can use for
264:35 - retries is the one called retries with
264:38 - exponential back off
264:40 - this strategy performs call retries a
264:43 - certain amount of times with a longer
264:45 - wait between each retry
264:47 - and here's how it works
264:50 - as usual the client will make a request
264:51 - to our service and this one in turn will
264:54 - make a request to its dependent service
264:57 - if this second request fails instead of
265:00 - failing right away our service will wait
265:02 - some time
265:03 - and then it will try again
265:06 - if the request fails again we will now
265:08 - wait a longer amount of time before
265:10 - trying the request
265:13 - if it keeps failing we will wait a yet
265:16 - longer amount of time before one more
265:18 - try
265:20 - and eventually if we have tried enough
265:22 - times
265:23 - with no successful response we will let
265:25 - the call fail
265:28 - as you see this strategy lets the
265:30 - failing dependency have an increasing
265:31 - amount of time to
265:32 - recover it also avoids overwhelming the
265:35 - dependency
265:37 - let's see how to implement timeouts and
265:39 - retries with exponential back off in our
265:41 - inventory microservice
265:45 - let's see our inventory and catalog
265:47 - microservices in action once again
265:49 - so here i am in catalog
265:51 - and i'll just hit f5 to start a web
265:53 - server
265:55 - and then i'll go to inventory and i'll
265:57 - do the same thing hit f5
266:00 - and now i'll go to postman and i'll try
266:03 - to get
266:04 - all the inventory items for this user id
266:07 - so i'll just go ahead and hit send
266:12 - and here's what we expected to get right
266:14 - so the list of inventory items with them
266:16 - and description
266:17 - now to simulate the effects of partial
266:19 - failures let's first add a few temporal
266:22 - modifications to our get out items
266:24 - operations in catalog microservice
266:27 - so i'll go to our catalog visual studio
266:29 - code instance and i'll stop it for now
266:32 - close terminal
266:34 - and i'll go to items controller
266:39 - and what i'll do is i'll modify or get
266:41 - async method the one that retrieves all
266:42 - the items so that it introduces a few
266:45 - temporal failures uh for our inventory
266:48 - client
266:49 - so before doing that i'm going to add a
266:51 - little uh
266:53 - a little variable to track how many
266:54 - requests we have received from the from
266:57 - the client at this point
266:58 - so i'll just add
267:01 - private static in i'm making it static
267:03 - so that it doesn't reset after every
267:05 - request
267:06 - let's just call it request counter
267:10 - start with zero
267:12 - and now in get a scene i'm going to open
267:14 - space here let's go down
267:17 - and i'll do the following first thing
267:18 - that i'll do is i'll just
267:21 - increase the counter
267:23 - and then let's add a lock line just
267:25 - after this
267:26 - console.the right line
267:28 - [Music]
267:32 - i will just say
267:34 - string interpolation
267:36 - request
267:39 - request
267:42 - discounter
267:46 - starting
267:47 - so that's that's why it tells us that
267:49 - it's starting a new request
267:51 - then what we're going to do is for the
267:53 - first two requests we will actually
267:55 - increase i mean we'll add a delay to
267:57 - simulate the timeout scenarios
267:59 - so if request counter
268:03 - less than or equals to two
268:06 - we're going to say i'm going to copy
268:08 - this line here console.writeline
268:11 - we will say
268:13 - delaying
268:14 - and i'm going to say wait
268:17 - that's that delay this is how you can
268:19 - introduce a delay in the current request
268:21 - in an asynchronous way
268:23 - time span
268:24 - that frame seconds will say 10 seconds
268:27 - so the first request will be delayed 10
268:29 - seconds
268:31 - then i'll copy this block
268:33 - here
268:34 - down here and we will say that if the
268:36 - request counter is less than or equals
268:39 - to four what we're going to do is just
268:41 - return
268:42 - an internal server error right so three
268:44 - to to simulate that kind of error
268:47 - so request request counter we will say
268:51 - 500
268:53 - internal server error
268:57 - and we will return
268:59 - status code
269:02 - 500
269:03 - now at this point we are introducing
269:05 - this capability of uh returning either
269:08 - one result here or another type of
269:10 - result here and in order to do that
269:12 - uh remember that we have to switch from
269:14 - just returning the innumerable into
269:16 - returning an actual i actually result so
269:19 - i'll say
269:20 - action
269:22 - result
269:23 - of a numerable of identity and i'll
269:26 - close this
269:27 - so that gives us ability to return more
269:29 - than one type of a result
269:31 - and also we'll have to modify our final
269:33 - return clause here so that it returns
269:35 - something that can be mapped to
269:36 - afghanistan like the okay
269:39 - result
269:40 - and lastly what we're going to add here
269:42 - just over here
269:44 - let me copy this console right line this
269:46 - is going to be the happy path where we
269:48 - finally return something and we're going
269:50 - to say resquez request counter we will
269:53 - just say 200
269:56 - okay
269:58 - okay so for a quick review we have a
270:00 - static request counter so every time a
270:01 - request comes in it increases the
270:02 - counter uh the first two requests are
270:04 - going to have a 10 second delay the next
270:07 - two requests are going to end up in a
270:09 - 500 error and then if we get get past
270:12 - that we'll get at 200 okay
270:15 - and so at this point i'll go back to
270:18 - our
270:20 - inventory
270:21 - this is our inventory i've used to call
270:23 - instance i'll just stop it
270:26 - close
270:27 - and what i'll do is i'll first go ahead
270:29 - and collapse our navigation pane for now
270:31 - i'll open my terminal
270:34 - over here
270:35 - i'll open a new partial terminal what
270:38 - i'd like to do is actually have two
270:40 - terminals in this window so we can see
270:41 - the interactions between microservices
270:43 - so i'll use the split terminal icon here
270:46 - to open a second terminal and in this
270:48 - one i'll actually switch back to play
270:50 - that the catalog directory
270:54 - okay
270:56 - play the catalog service
270:58 - and here i'll do dot net run
271:01 - so that we can see the outputs that are
271:03 - coming out of catalog
271:05 - and then on the left side i'll start up
271:07 - our inventory microservice same way i'll
271:10 - do
271:14 - that run
271:17 - okay
271:18 - so with that done let me go back to
271:20 - postman
271:21 - and i'll try the query once again so
271:24 - i'll hit send
271:26 - and back in bs code
271:28 - you can see that now this first request
271:30 - is getting delayed
271:32 - and now our inventory client is
271:35 - experienced experiencing this
271:36 - significant timeout
271:39 - if we try it again for the point of
271:41 - views postman so look at this it just
271:43 - keeps waiting waiting and waiting we're
271:46 - giving a really bad experience to to our
271:48 - clients right
271:51 - okay so what can we do about this so the
271:53 - first thing as we mentioned is to
271:54 - introduce a proper timeout to avoid this
271:56 - kind of situation
271:58 - so let's go back to visual code
272:00 - and what i'll do now is i'll stop both
272:02 - web servers so i'll go to my inventory
272:04 - turbine and i'll do ctrl c
272:06 - stop server catalog control c stop
272:08 - server
272:09 - and
272:10 - what i'd like to do now is to add
272:13 - our
272:14 - a reference to the poly nougat package
272:17 - so so this is the package that you can
272:19 - use in your.net applications to properly
272:22 - handle transient error failures in a
272:24 - very easy way
272:25 - so being in play inventory service i'll
272:27 - do
272:29 - net add package
272:32 - microsoft.next
272:37 - enter
272:39 - okay and then perhaps i'll put this back
272:41 - into place and then i'll just do ctrl j
272:43 - to hide all terminals for a moment
272:45 - then i'll go to our explorer and i'll go
272:48 - to startup.cs and i'll collapse this
272:50 - once again we don't need it
272:53 - and let's go into configure services
272:56 - and um yeah so let's find the section
272:58 - where we are adding the http client
273:00 - right here
273:02 - and here what we're going to do is we're
273:04 - going to append yet another call to
273:06 - another method here that's going to be
273:08 - that's called add policyhandler
273:11 - and uh here's where we can define a
273:13 - policy so paulie has this concept of
273:15 - policies that different policies that
273:18 - can be used to handle a different
273:20 - transient errors
273:22 - when you're invoking an external api so
273:24 - we're going to use policy
273:28 - and then let's import any missing space
273:30 - using poly
273:32 - so we will say policy dot
273:35 - timeout async
273:38 - and then we specify a type here and that
273:40 - type is going to be http
273:45 - response message
273:48 - and let's add the system.net namespace
273:50 - because this is the type of response i
273:52 - will get when you invoke the external
273:55 - external client so
273:56 - and uh in this parameter we'll specify
274:00 - uh how many seconds we want to wait
274:01 - maximum
274:03 - after calling an external api and before
274:05 - just failing
274:07 - so i'll say one second in our case and
274:09 - i'll close this
274:10 - so just by doing this you're saying that
274:12 - anytime we invoke anything under
274:15 - localhost 5001 we're going to wait at
274:18 - much one second before giving up
274:21 - so let's see now how this works i'll
274:23 - bring in back my terminals via ctrl j
274:26 - and then i'll do
274:28 - dot net run in both cases
274:35 - okay perhaps i'll move this a little bit
274:36 - to the right
274:38 - and then let's go to postman
274:41 - and try the request once again
274:44 - as you can see it now took just a little
274:46 - bit more than one second to complete the
274:48 - request so instead of waiting for all
274:50 - those 10 seconds wasting resources let's
274:53 - try again
274:55 - yep and once again it just took just a
274:57 - bit more than one second
274:59 - if we go back to postman
275:02 - we can also see we tried the two
275:03 - requests on the right side but then they
275:06 - usually took more time to respond but
275:08 - regardless we were already we had
275:10 - already failed on the on the left side
275:11 - on the inventory side
275:14 - so that would at least help us fail fast
275:16 - to avoid the long delay and avoid
275:18 - consuming inventory resources
275:19 - unnecessarily
275:20 - however we note that transient errors
275:23 - are not uncommon in distributed systems
275:25 - so we would like to not just fail right
275:27 - away but instead try a few times hoping
275:29 - for the catalog service recovery
275:32 - in the next lesson we will implement the
275:34 - retries with exponential back-off
275:35 - technique
275:36 - to improve our chances of succeeding in
275:38 - the presence of transient errors
275:41 - in the last lesson we introduced a
275:43 - one-second time-out policy to inventory
275:45 - microservice
275:46 - let's now use the retries with
275:48 - exponential back-off technique to let
275:50 - inventory retry the calls to catalogue a
275:52 - few times before giving up
275:54 - so here i am once again in the play the
275:56 - inventory microservice and here's a line
275:59 - where we last in last lesson we added
276:01 - our timeout policy
276:03 - what we want to do here is add yet
276:05 - another policy to specify what to do in
276:07 - the presence of transient errors and how
276:09 - to retry
276:11 - so now i'm going to be adding that
276:13 - policy handler right here just between
276:15 - the add http client call and the add
276:18 - policy handler call
276:20 - and just pay attention of the location
276:22 - of this because we want to make sure
276:24 - that we can combine the timeouts with
276:26 - the transient error hunting so that any
276:29 - time that we retry we actually
276:31 - wait just one second like specified in
276:33 - this policy
276:35 - we wait one second uh between tries if
276:37 - you don't do things in the order that
276:39 - are going to be shown here
276:41 - that combination is not going to work
276:43 - properly
276:44 - so at this location i'm going to say
276:47 - add transient http error policy
276:51 - and let's actually go into the
276:53 - definition of this method for one second
276:54 - so go to definition uh so so just so
276:57 - that you can see what this this method
277:00 - is handling so this method is taking
277:01 - care of network failures
277:04 - it's also taking care of 500 500 errors
277:07 - several errors and a 408 status quo so
277:11 - request time out
277:12 - so this method we're going to use is
277:13 - very handy so because it can handle all
277:15 - these situations by itself automatically
277:18 - i close this
277:20 - and again notice the location where i
277:22 - added this
277:23 - so now what i'll do is i'll say builder
277:29 - and then we'll say builder dot
277:33 - weight and retry async
277:36 - and here we're going to open parentheses
277:37 - and we need to specify a series of
277:39 - parameters for this policy and the first
277:42 - parameter is going to be the retry count
277:43 - so this is how many times we want to
277:45 - retry in the presence of transient error
277:47 - failures so for our case let's say we're
277:49 - going to go for five retries
277:53 - the next parameter is the sleep duration
277:55 - provider so this is just a function that
277:57 - determines how much time to wait between
278:00 - each retry so for this we're going to
278:02 - say
278:04 - we try attempt
278:06 - and then we'll use a time span class
278:08 - to specify a duration in seconds
278:13 - but here is where the exponential
278:14 - back-off part comes into place we are
278:16 - not going to just specify a one specific
278:19 - amount of seconds we are going to say
278:22 - but that pow so that we can say uh let's
278:26 - go for two and then we'll raise that
278:28 - into retry attempt
278:31 - so this means that every time we're
278:33 - going to wait we're going to be waiting
278:34 - an increasing amount of time that
278:36 - depends on the retry attempt
278:38 - so for like the first time it's going to
278:40 - take two raised t raise it into one the
278:42 - first which i attempt so two at one is
278:45 - going to be two so two seconds so next
278:47 - time it's going to be two a raise a two
278:50 - so it's going to be four seconds the
278:51 - next time eight seconds it will keep
278:52 - going that way in an exponential way so
278:55 - that every time we just wait a little
278:56 - bit more so that's that's a potential
278:58 - back-off
278:59 - piece of of this technique
279:02 - and then next we're going to specify yet
279:03 - another parameter uh that you don't
279:05 - really need it but we're going to use it
279:08 - just for the purposes of demonstrating
279:09 - what happens between the different uh
279:11 - the different calls so you can totally
279:14 - skip this if you want to if you want to
279:15 - don't want to see what's going on behind
279:17 - the scenes so i'm going to say on retry
279:21 - and then we specify three parameters
279:24 - it's going to be outcome
279:26 - a
279:27 - time span
279:29 - and we try
279:31 - attempt
279:32 - so i'll open this
279:35 - and then here we can specify
279:38 - um what we want to do
279:40 - each time that retry happens what we
279:42 - want to do is just present the lock a
279:43 - lock message in the console and we can
279:45 - do when you we can use i logger for this
279:48 - now uh uh to do that at this point we
279:51 - need to actually get an instance of the
279:52 - ilogger a lower class but uh we don't
279:55 - have a easy way to do that right now so
279:58 - what we're going to do is to as an
279:59 - instance of the service provider we're
280:00 - going to create a service provider and
280:02 - from that one we're going to get that
280:03 - service this is not ideal and that's
280:05 - actually going to present a warning
280:07 - message in the console
280:09 - but we're doing this just for
280:10 - demonstration purposes so totally avoid
280:12 - this this technique in production code
280:15 - so let's see we'll say service provider
280:20 - equals services
280:22 - dot build service provider
280:25 - and then we will say
280:27 - service provider that gets service we
280:30 - want an i logger
280:33 - of catalog client
280:37 - okay let's see if we're missing a
280:38 - namespace
280:40 - extension's logging
280:43 - okay so if you're able to get that that
280:46 - that service instance so we'll use this
280:48 - equal
280:49 - question mark there we'll say
280:52 - that log warning
280:54 - and here's where we're going to specify
280:56 - that
280:56 - message and the message is going to be
280:58 - and we'll do a string interpolation here
281:01 - we'll say
281:02 - lane for
281:04 - so many seconds
281:06 - and those seconds are going to come from
281:09 - time span
281:11 - the total seconds
281:14 - and then
281:15 - then making retry
281:18 - and that's going to be retry
281:21 - attempt
281:22 - okay
281:23 - close that
281:24 - save
281:26 - and one more thing that we have to do
281:28 - here is make sure that we combine both
281:30 - of these policies so that they can work
281:32 - together and to do that what we have to
281:33 - do is go back to this builder
281:36 - declaration here so where and then we
281:38 - have to say builder dot or
281:41 - and then we specify the exception that
281:43 - will be coming out of the timeout
281:46 - of the timeout async call over here so
281:48 - in that case that exception is going to
281:50 - be
281:51 - timeout
281:53 - rejected
281:54 - exception and then let's see if you're
281:56 - missing any space using polytimeout
281:59 - okay so that's how you can say that if
282:02 - the actual and then let's
282:03 - add missing parenthesis
282:05 - if
282:07 - we fail because of a timeout produced by
282:09 - the timeout policy then it will fire a
282:12 - timeout section let's go ahead and also
282:14 - retry okay so that's the right way to
282:16 - combine both policies
282:18 - okay so now let's just save this
282:20 - and i'll open my terminals
282:23 - and left side is inventory i'll do dot
282:25 - net run
282:27 - right side is catalog dot net run
282:31 - let's expand this a bit
282:33 - and notice the warning that i was
282:34 - mentioning before and this happens like
282:37 - i said because of the way that we are
282:39 - doing a the service provider
282:40 - construction here there's a radio
282:42 - service provided
282:43 - built in into the spinal cord of time we
282:45 - are creating a second one that's not
282:47 - ideal and but like i said it's used for
282:49 - demonstration purposes feel free to
282:51 - remove this section in your production
282:52 - code
282:54 - so now that we have both services up and
282:55 - running let's go back to postman
282:58 - and let's go ahead and do a send to see
283:01 - what happens so it starts and go back
283:04 - going back here
283:05 - you can see
283:06 - that uh first time we tried and then we
283:09 - waited two seconds then we waited four
283:11 - seconds then we waited eight seconds
283:13 - we're trying to wait eight seconds on
283:15 - the right side you can see that the
283:16 - multiple requests are coming in now
283:18 - they're firing internal server drivers
283:20 - and now we are in what's probably the
283:22 - last the last weight uh for 16 seconds
283:25 - and so the client in postman as you can
283:27 - see it just keeps waiting
283:29 - uh it's not it doesn't fail right away
283:32 - but we are trying to get a chance to
283:33 - actually succeed and yeah eventually
283:36 - that happened
283:37 - the client succeeded and we no longer
283:40 - see an error if we see back into postman
283:44 - we can see that yeah indeed eventually
283:46 - we go to 200 okay 200 okay for the last
283:49 - request
283:51 - and it is looking great
283:53 - now the one issue with this is that if
283:55 - you have multiple instances of your in
283:58 - this case our inventory service uh
284:00 - calling a catalog
284:02 - and they are all waiting exactly four
284:03 - seconds exactly eight seconds 16 seconds
284:05 - between the tries that can actually
284:07 - cause a kind of burst of of calls into
284:11 - catalog service at the very same time
284:13 - right because they are waiting for
284:14 - exactly the same time between retries so
284:16 - to avoid overwhelming our catalog
284:18 - service what we can do is introduce a
284:20 - little bit of randomness so that it is
284:22 - not exactly four seconds or exactly
284:24 - eight seconds and stuff like that
284:26 - so how can we do that i'll do ctrl c in
284:29 - both of my terminals to stop those
284:30 - processes and do ctrl j to close the
284:32 - terminals
284:34 - and what we're going to do is add what
284:35 - we call
284:36 - a jitter so this is going to be
284:40 - the way to add that randomness here so
284:42 - i'll go up
284:44 - and just over here i'll introduce
284:48 - a
284:49 - random
284:51 - error
284:54 - it's going to be
284:58 - new random
285:01 - and then let's go back to the section
285:05 - where we're defining the retry attempt
285:07 - over here
285:08 - and we're going to do is just go to next
285:09 - line and we will say
285:12 - plus
285:14 - time span
285:15 - that
285:16 - from milliseconds
285:18 - and we will say uh
285:22 - yearly dot next and so we want to add is
285:26 - some number of milliseconds to those
285:28 - seconds so we'll say any number from 0
285:30 - to
285:31 - 1000 should be fine
285:34 - so this time we should see that it's not
285:35 - just a specific amount of seconds but
285:37 - those seconds plus some milliseconds
285:39 - that are going to be generated at random
285:41 - so i'll save that
285:43 - open terminals again ctrl j
285:46 - dot net run
285:48 - and dotnet run
285:52 - and let's go back to postman and try
285:54 - this again so i'll hit send
285:56 - let's go back here and as you can see
285:58 - now we are not waiting just two seconds
286:00 - but 2.5 to 3 seconds and the next time
286:03 - we're waiting for that
286:05 - 3-8 seconds and so on and so on yeah so
286:09 - with that the different instances will
286:10 - be invoking back to a client at
286:12 - different slightly different times
286:14 - which lets a catalog not get overwhelmed
286:18 - and so this is much better and would
286:21 - certainly help us handle temporal
286:23 - glitches uh when reaching out to the
286:25 - catalog service
286:26 - however
286:28 - imagine that a widespread network outage
286:30 - is preventing us from reaching catalog
286:32 - or perhaps is preventing catalog from
286:34 - reaching its defenses so such outage
286:36 - would likely last let's say a half an
286:37 - hour and if we have all of an inventory
286:39 - service threats retrying that much time
286:41 - we may end up exhausting its resources
286:44 - in the next lesson we will learn more
286:46 - about resource exhaustion and how to
286:49 - deal with it via the circuit breaker
286:51 - technique
286:53 - in this lesson we will learn about
286:55 - resource exhaustion in microservices and
286:57 - how to deal with it using the circuit
286:59 - breaker pattern
287:02 - having a retry policy in place is good
287:04 - but you also must be mindful about the
287:06 - limited resources available to your
287:08 - service
287:09 - imagine once again a situation where
287:11 - there is an ongoing issue with your
287:13 - service dependency
287:15 - this might not be just a transient issue
287:17 - but instead
287:18 - some prolonged downtime caused perhaps
287:21 - by a broad network
287:24 - now the client calls our service and
287:26 - this one in turn invokes the already
287:28 - failing dependency
287:30 - which will hopelessly start waiting for
287:32 - a reply
287:34 - while this is happening more clients
287:36 - keep sending requests to our service and
287:38 - this results in more requests being sent
287:40 - to the failing service
287:43 - one thing you have to realize is that
287:44 - each of these requests are making use of
287:46 - your service threads
287:48 - of which there is only a limited amount
287:51 - once enough threads are in use
287:55 - there are no more resources available
287:57 - and you can reach what we call resource
287:59 - exhaustion
288:01 - when this happens your entire service
288:03 - becomes unavailable
288:05 - for any future requests potentially
288:07 - causing a lot of trouble in the system
288:11 - one approach we can use to properly
288:13 - handle this issue is implementing the
288:15 - circuit breaker pattern
288:17 - a circuit breaker prevents service from
288:20 - performing an operation that's likely to
288:22 - fail
288:23 - here's how it
288:24 - works once again we are in a situation
288:27 - where our dependent service is already
288:29 - in a bad state
288:31 - unable to provide successful replies
288:34 - our client then makes a request to our
288:36 - service
288:37 - however this time instead of invoking
288:40 - the failing dependency directly there is
288:42 - an intermediary that we will call the
288:44 - circuit breaker
288:46 - the circuit breaker will now start
288:48 - monitoring the results of each of the
288:49 - requests that go through it
288:51 - that go through it to the external
288:53 - dependency
288:56 - and when it detects that the rate of
288:58 - failure goes beyond the configured
289:00 - threshold it will immediately stop
289:03 - letting any more requests go out
289:05 - and will fail them right away
289:09 - this is what we call opening the circuit
289:12 - after this request will just keep
289:14 - failing immediately during the
289:16 - configured wait time
289:18 - which would hopefully give the dependent
289:20 - service enough time to go back to a
289:22 - healthy state
289:26 - eventually the circuit breaker will let
289:28 - some requests go out to verify if they
289:29 - succeed
289:31 - and if that is the case
289:33 - it will close the circuit again
289:36 - letting all 40 requests reach the
289:38 - dependent surface
289:40 - that's how the circuit breaker prevents
289:42 - our service from reaching resource
289:44 - exhaustion
289:45 - while at the same time avoids
289:47 - overwhelming dependent services until
289:49 - they get a chance to recover
289:53 - let's go ahead and implement the circuit
289:54 - breaker pattern in an inventory
289:56 - microservice
289:59 - to implement the circuit breaker pattern
290:01 - all that we have to do is add a new
290:03 - transient http record policy just like
290:05 - we did for the weight and retry policy
290:08 - so here we are again in the inventory
290:10 - microservice in the startup class
290:12 - configure services method and i'm going
290:14 - to scroll down a little bit here
290:17 - and remember we have already added
290:18 - policy for weight and retries and we
290:20 - have a policy for timeouts
290:22 - so what i'll do now is i'll open yet
290:24 - another section here
290:25 - to add our our next
290:27 - http record policy so i'll do a
290:29 - transient http load policy remember we
290:32 - want to do this just before the timeout
290:34 - and not after so that this policy can
290:36 - also wrap the benefits of the timeout
290:38 - policy
290:39 - so open parenthesis here
290:41 - and what i'll do is i'll just copy this
290:42 - little section here so that we are
290:45 - we are properly combining this policy
290:47 - with the time with deceptions that could
290:49 - come out of the timeout policy
290:52 - but then what i'll do is i'll invoke the
290:55 - circuit breaker async method here
290:58 - and i'll open parentheses
291:00 - and here we have to suffice the
291:02 - parameters for circuit breaker
291:04 - so the first parameter that we have to
291:06 - define here is how many
291:08 - tries we're going to allow or how many
291:10 - requests we're going to allow through
291:11 - the circuit breaker before the circuit
291:15 - has to open right so in our case let's
291:18 - say that's going to be three so three
291:21 - failed requests are going to are going
291:23 - to go through the circuit breaker before
291:25 - the secret breaker actually notices that
291:27 - yeah there's a problem and we have to
291:28 - open the circuit
291:31 - next comes the duration of the or time
291:33 - span of the other break so this is how
291:35 - much time we will keep the circuit open
291:38 - so let's say this is going to be
291:40 - time
291:40 - span from seconds let's say 15.
291:45 - and that's really most of what you have
291:47 - to do you don't have to do more than
291:49 - that to enable the secret breaker uh but
291:51 - just like we did with our tries let's
291:53 - add a couple of functions here
291:55 - to get an insight of what's going on
291:57 - behind the scenes
291:58 - so what i'll do is i'll say
292:00 - on break so this is a functional that
292:03 - will be used when
292:04 - when the secret opens
292:06 - so i'll say outcome
292:09 - and time span
292:17 - okay
292:19 - so in this case we want to add a log
292:21 - message and stating that the secret the
292:24 - secret breaker is opening
292:26 - so this is going to be really very
292:27 - similar to what we did for
292:29 - uh
292:30 - for our weight and we try so i'm
292:32 - actually going to copy these three lines
292:33 - from here
292:35 - i'll copy them over here for our own
292:37 - break function
292:39 - and i'll just change the message
292:41 - the following way
292:43 - so i'll delete this and i'll say
292:47 - opening the circuit
292:50 - for
292:52 - and this is going to be
292:55 - time span that
292:57 - total seconds
293:00 - seconds
293:03 - okay so that's what's going to happen
293:04 - when the secret breaker opens
293:07 - and then next we're going to add another
293:09 - one
293:10 - for the on reset
293:12 - on reset function
293:14 - that's not going to receive any
293:15 - parameters
293:18 - and in this one we're going to do
293:19 - something very similar so i'll copy
293:21 - again that that line those lines
293:24 - paste them there
293:25 - and in this case we're just going to say
293:31 - closing the
293:33 - circuit
293:35 - okay
293:36 - so that's really all you have to do to
293:38 - enable secret breaker so
293:40 - again
293:42 - we are waiting we will allow three
293:44 - requests to go into secret breaker and
293:46 - if those three are failing the rate the
293:48 - circuit is going to open
293:50 - then it's going to wait 15 seconds uh
293:52 - before allowing any new request to
293:54 - actually totally try to to reach the
293:56 - other end uh during those 15 seconds
293:58 - things are going to just fail right away
294:01 - and then we have functions to
294:03 - lock what's happening when the secret
294:05 - opens and when the circuit closes
294:07 - and now i'll go ahead and i'll open my
294:10 - terminal so i will save this file i'll
294:12 - open the two terminals using the like in
294:13 - previous lessons i have two terminals
294:15 - inventory service on left side catalog
294:17 - service on the right side i'll do.net to
294:19 - run in both sides
294:25 - okay notice we keep getting these
294:26 - warnings about the build service
294:27 - provider issue that we talked before but
294:29 - like i said that's this is just for
294:31 - demonstration purposes
294:33 - so now i'll get back into postman
294:36 - and we'll try out that inventory api to
294:38 - get all the items in the user's
294:40 - inventory see what happens so i'll just
294:42 - go ahead and hit send
294:45 - and notice the left side that we tried
294:48 - we failed so we waited for 2.02 seconds
294:51 - then we tried failed waited for 4.64
294:53 - seconds and then at that point the
294:55 - circuit actually opens for 15 seconds so
294:58 - we're waiting at 71 seconds for the next
295:00 - try but the moment that we try this
295:02 - again
295:03 - things fail right away as you can see on
295:05 - the left side and you see if we see
295:06 - what's happening in postman yeah we're
295:08 - getting that error the circuit is now
295:10 - open is not allowing any further calls
295:13 - and if we try once again uh it may take
295:16 - one or two seconds but it will fail
295:18 - because the sequence is open and if we
295:20 - just keep trying and keep trying uh
295:22 - we're getting an immediate result so
295:24 - this is the effect of having the circuit
295:27 - open so any new requests are coming here
295:29 - from any client or service are going to
295:31 - fail right away
295:33 - however eventually the circuit
295:36 - lets us go through one word request and
295:39 - if it notices that it's successful it
295:41 - opens the circuit like it happened right
295:43 - here we go back to postman
295:46 - we can see that it allowed one more
295:47 - request just to see if things are
295:49 - healthy once again and it got a 200
295:52 - result
295:53 - and then it said yeah closing the
295:54 - circuit and it allowed things to keep
295:56 - working once again
295:58 - so that's how the secret work breaker
296:00 - works and that's how it can help us
296:01 - prevent
296:02 - overwhelming other services or having to
296:05 - waste resources and cause resource
296:07 - exhaustion in our microservice
296:09 - at this point we are doing a fairly good
296:11 - job at handling parts of failures
296:13 - between our inventory and catalog
296:14 - services
296:15 - however could there be a better way to
296:18 - have inventory get all the information
296:20 - he needs from catalog without having to
296:22 - rely on catalog to be available most of
296:24 - the time
296:26 - in the next module we will learn about
296:28 - the asynchronous communication style and
296:30 - how it can help us enable a much more
296:32 - resilient communication between our
296:33 - services
296:36 - in this model you will learn about the
296:38 - asynchronous inter-service communication
296:40 - style the challenges it can help solve
296:42 - how to implement it via habit and queue
296:44 - and mass transit and how to enable
296:46 - eventual data consistency between our
296:48 - two microservices
296:51 - by the end of this model you will have a
296:53 - solid understanding of the following
296:55 - the basics of and when to use
296:57 - asynchronous communication between
296:59 - microservices
297:01 - how to enable microservices autonomy and
297:03 - the impact to the sla
297:06 - how to use a message broker for
297:07 - asynchronous data propagation
297:10 - how to stand up a ravine queue message
297:12 - broker via docker compose
297:15 - how to publish messages to ravit mq via
297:17 - the mass transit framework
297:20 - how to consume messages from gravitmq
297:22 - using mass transit
297:24 - and how to implement eventual
297:25 - consistency of data propagated across
297:28 - microservices
297:31 - in this lesson we will learn about the
297:33 - asynchronous communication style and how
297:35 - it can help us enable much more
297:37 - resilient communication between our
297:38 - services
297:42 - imagine a scenario where after receiving
297:44 - a request from a client our microservice
297:46 - needs to reach out to two other
297:48 - microservices
297:50 - also each of these services need to get
297:52 - in touch with other services which in
297:54 - turn might need to further reach to more
297:56 - services
297:58 - there may also be services that depend
298:00 - on the services that our service depends
298:02 - on
298:04 - we originally fine tune our service so
298:06 - that it never takes more than 300
298:08 - milliseconds to respond to our client
298:10 - requests
298:12 - however when we started making
298:13 - synchronous calls to one of our
298:15 - dependent microservices we had to add to
298:18 - our time the 200 milliseconds that that
298:20 - service can take to respond
298:24 - that was still okay in the beginning but
298:27 - unfortunately when that dependency
298:29 - eventually started calling another
298:30 - dependency
298:32 - and that one yet to another one
298:34 - our oral
298:36 - average latency bumped to
298:39 - 1450 milliseconds
298:41 - which is bad
298:43 - on top of that if one of our deeper
298:45 - indirect dependencies starts failing
298:48 - even if temporarily it can cause all of
298:51 - the services that depend on it to also
298:53 - start failing
298:55 - and the effect keeps cascading until
298:57 - potentially most of our system becomes
299:00 - unavailable
299:01 - one important concept that you should
299:03 - keep in mind as you embrace
299:04 - microservices is the service level
299:07 - agreement or sla
299:09 - the sla is basically a commitment
299:11 - between you as a service provider and
299:14 - the client
299:16 - for instance as part of our sla we could
299:18 - have defined that our service can be
299:20 - expected to be up and running
299:23 - 99.9 of the time
299:26 - so when our clients choose to use our
299:28 - service they should expect it to be down
299:30 - approximately 44 minutes during the
299:33 - month
299:34 - which the owners of the client will have
299:36 - to decide if it's susceptible
299:38 - however when using synchronous
299:40 - communication calculating such numbers
299:43 - for our service sla gets more
299:44 - complicated
299:46 - our deepest dependency is also
299:48 - advertising at 99.9
299:51 - uptime in their sla
299:53 - and let's say that all of the services
299:55 - initially advertised at the same value
299:58 - however in our scenario when dependency
300:00 - 4 fails
300:02 - it impacts the sla of dependency 3
300:05 - which now sets its sla down to 99.8
300:09 - this in turn impacts the sla of
300:11 - dependency 1
300:13 - and ultimately
300:15 - impacts our own sla
300:19 - now with an sla of 99 at six percent of
300:21 - time our clients would be subject to
300:23 - about
300:24 - 175 minutes of downtime across demand
300:29 - which
300:30 - is way below of what we wanted to
300:32 - provide initially
300:34 - so the synchronous communication style
300:36 - suffers from an increase of latency due
300:39 - to the chain of calls
300:41 - it can significantly amplify the impact
300:43 - of partial failures and can potentially
300:46 - reduce the sla of our service
300:50 - now let's look at the asynchronous
300:52 - communication style
300:54 - here the client does not have to wait
300:56 - for a response in a timely manner
300:58 - and in fact depending on how the
301:00 - communication has been set up there
301:02 - might not be any response at all
301:06 - to enable such communication there is
301:08 - usually an intermediary called the
301:10 - message broker
301:11 - which is pretty dumb in nature
301:13 - meaning that it has no business logic on
301:15 - it
301:16 - and it is also highly available
301:19 - with the message broken in place the
301:21 - service client sends messages to the
301:22 - broker and the broker forwards the
301:24 - messages to receivers as soon as
301:25 - possible
301:27 - the messages can be received by two
301:29 - types of receivers
301:31 - a single receiver in which case we think
301:34 - of the message as a command via which
301:37 - the client requests an action on the
301:39 - receiving service for instance when a
301:41 - purchase operation starts our trading
301:43 - service will send a command to our
301:45 - inventory service asking it to grant
301:47 - items to the user's inventory
301:49 - and another command to an identity
301:51 - service asking it to david kill from the
301:53 - user
301:55 - we could also have multiple receivers
301:58 - where there are multiple services that
302:00 - subscribe to the events published by the
302:02 - client service
302:04 - this would be the case if for instance
302:06 - our catalog service would like to
302:08 - publish any updates with catalog of
302:10 - items so that other services can be
302:12 - informed about the changes
302:17 - one of the key benefits of using
302:18 - asynchronous communication is that it
302:20 - enforces a microservices autonomy
302:23 - let's see how it's enabled
302:26 - in a single receiver scenario we would
302:28 - have again our client talking to our
302:30 - service
302:31 - but our service will not talk to its
302:33 - dependent service
302:35 - it will instead send an asynchronous
302:37 - message to a broker
302:40 - and he will immediately acknowledge to
302:42 - decline the successful reception of the
302:44 - request
302:46 - the dependent service will consume this
302:48 - message from the message broker as soon
302:50 - as possible and will eventually provide
302:53 - a reply via the same broker
302:55 - at that point the client can request a
302:57 - status of its initial request to our
303:00 - service
303:01 - or our service can notify the client of
303:03 - the response
303:05 - all of the services in our system would
303:07 - follow the same message-based approach
303:10 - including cases where a reply is not
303:12 - required from the call service
303:15 - the great thing about this kind of
303:16 - layout is that when one of the dependent
303:18 - services fell
303:20 - it would not cause any impact on the
303:22 - other services
303:24 - since all of them have been decoupled
303:25 - from each other and only talked to the
303:27 - message broker
303:29 - so the same sla that one of the services
303:31 - presents
303:33 - can be honored across the entire system
303:36 - assuming that the message broker offers
303:38 - high availability
303:41 - so with asynchronous communication
303:43 - partial failures are no longer
303:45 - propagated
303:46 - each service has its own independent sla
303:49 - and best of all
303:51 - the autonomy of all microservices is
303:53 - enforced given the lack of coupling
303:55 - between them
303:59 - one of the nice things that asynchronous
304:00 - communication provides is the ability to
304:03 - asynchronously propagate data across
304:05 - services
304:07 - in the synchronous communication
304:08 - scenario when the client requests the
304:10 - user the user's inventory
304:13 - and since the inventory service only has
304:15 - the data that's relevant to it
304:17 - inventory has to first talk to the
304:18 - catalog service in order to retrieve
304:20 - additional details
304:22 - about each item
304:24 - how comes asynchronous communication
304:25 - health here
304:27 - well thanks to the presence of the
304:29 - message broker
304:30 - what we can do now is have the catalog
304:32 - service publish an event each time a
304:35 - catalog item is created or updated or
304:37 - deleted
304:39 - such event doesn't have to have all the
304:40 - details of each item but only the ones
304:42 - of interest to client services
304:45 - we can then have our inventory service
304:48 - listen to these events and create its
304:50 - own collection of catalog items
304:52 - in its own database
304:54 - as long as we have a highly available
304:56 - message broker the list of catalog items
304:58 - in the inventory database should be
305:00 - eventually consistent with regards to
305:02 - what's in the catalog service
305:04 - now when the client requests the user's
305:07 - inventory
305:08 - inventory has no need to go out into any
305:11 - dependent service to request item
305:12 - details it has everything it needs in
305:15 - its own database and it can immediately
305:17 - provide a reply to the client with no
305:19 - additional latency
305:21 - so
305:22 - thanks to asynchronous communication we
305:24 - can enable eventual consistency across
305:26 - our system the autonomy of our services
305:29 - is preserved
305:31 - and the previous inter-service latency
305:33 - is reduced or completely removed
305:37 - in the next lesson we will start
305:39 - implementing asynchronous communication
305:41 - between our two microservices
305:44 - we will introduce revit nq as our
305:46 - message broker of choice given that it
305:48 - supports the amqp protocol it is
305:52 - lightweight
305:53 - easy to run locally and is very popular
305:55 - in the open source community
305:58 - revit queue introduces a concept of
305:59 - exchanges which you can compare to a
306:02 - mailbox
306:03 - when a service like catalog needs to
306:05 - publish a message it will send it to an
306:08 - exchange in gravity mq
306:11 - and with the appropriate bindings in
306:13 - place
306:14 - the exchange will distribute the message
306:15 - to any of the configured queues
306:18 - from there habit and queue will take
306:20 - care of delivering the message to any
306:23 - subscribe services like inventory
306:25 - we could use revit queue directly in our
306:27 - code but we would first need to create
306:29 - the exchanges and queues and configure
306:32 - the bindings to ensure messages are
306:34 - properly routed also our code will be
306:36 - tied to ravitmq and if we ever wanted to
306:39 - move to another message broker we would
306:41 - need to rewrite a good part of our
306:43 - services code
306:45 - for this and a few other reasons we will
306:47 - instead use mass transit on top of
306:49 - raviten
306:50 - queue mass transit is a popular open
306:53 - source distributed application framework
306:55 - for net
306:57 - mass transit can take care of doing most
306:59 - of the heritage mq configuration for us
307:01 - and is able to integrate with multiple
307:03 - other message brokers while allowing our
307:05 - services to stick with a higher layer of
307:08 - broker agnostic apis
307:11 - as part of this mass transit introduces
307:13 - the concept of a publisher
307:15 - and a consumer
307:16 - which is what our service code will
307:18 - focus on
307:20 - let's start coding
307:23 - just like we need to define dtos to
307:25 - establish contracts between a rest api
307:28 - and our api consumers we also need to
307:30 - define the contracts that define the
307:31 - messages to exchange between services
307:34 - that use asynchronous communication
307:36 - however this time we will define the
307:38 - contracts in a separate project mainly
307:40 - because we will later package and share
307:43 - the contracts with other services so
307:45 - they can easily use them
307:47 - so let's start by defining the contracts
307:49 - that our catalog service will use to
307:51 - send events asynchronously anytime an
307:53 - item is created updated or deleted
307:56 - so here we are once again in our catalog
307:59 - microservice project and what i'll do is
308:01 - i'll open my terminal via ctrl j
308:04 - and then i'll switch to the
308:06 - search directory and i'll go ahead and
308:08 - create a new class library so i'll do
308:10 - dot net new
308:12 - classlip
308:13 - and the name we're going to give it is
308:15 - play that catalog that contracts
308:27 - okay so now we have a new contract
308:30 - project over here and before we forget
308:32 - let's make sure we get a reference from
308:34 - the catalog project into the contract
308:37 - project
308:38 - so what i'll do is i'll go into
308:41 - play that catalog that service and then
308:44 - i'll do dot net add reference
308:50 - and it's going to go into play that
308:52 - catalog that
308:54 - contracts
308:55 - lay that catalog.contract.cspro
308:59 - so i'll make sure that we can use this
309:00 - contract from the a catalog service
309:04 - now let's go to our let's collapse this
309:06 - and let's go to our contracts project
309:07 - and let's actually collapse this
309:09 - terminal
309:10 - and let's delete this class one we're
309:12 - not going to need it and let's actually
309:14 - bring in a brand new file into the
309:16 - contracts project
309:18 - we will call it just
309:21 - contracts.cs
309:24 - let's give it a namespace
309:26 - i'm going to replay that
309:29 - catalog that
309:31 - contracts
309:33 - and here we're going to declare three
309:35 - records that are going to represent
309:36 - these contracts four items are getting
309:38 - created updated and deleted so let's
309:41 - start with the created case so public
309:43 - record
309:45 - catalog
309:47 - item created
309:51 - so
309:52 - here we need to specify not everything
309:53 - about the catalog item but really the
309:56 - stuff that our consumers are interested
309:58 - in so in this case what our consumer
310:00 - needs in this case inventory needs to
310:01 - know is the item id the name and the
310:04 - description so let's specify that so
310:07 - good item id
310:09 - let's import the missing namespace
310:16 - the name and the description
310:22 - and then we need to specify the the
310:24 - event for when items are getting updated
310:26 - so i'll just copy the one for created
310:28 - since these are very similar uh i'll say
310:31 - update
310:32 - okay it's really the same information
310:34 - we're going to emit any time and writing
310:35 - has been updated
310:37 - and then lastly
310:41 - let's define catalog
310:44 - item deleted
310:46 - and in this case the only thing that we
310:48 - need to communicate is the id of the
310:50 - item so in this case it's just going to
310:51 - be
310:52 - good item id
310:56 - so with that we have defined all the
310:57 - controls that we need
310:59 - and in the next lesson we will update
311:01 - the catalog service to start using these
311:03 - contracts and a few new nuget packages
311:05 - to start publishing messages to a
311:07 - service broker
311:09 - it's time to update our catalog
311:11 - microservice so that it starts
311:13 - publishing messages anytime an item is
311:15 - created updated or delete it
311:18 - so i'll start by opening a terminal so
311:21 - that we can bring in a couple of uh
311:23 - nuget packages that we're going to need
311:25 - so here i am in the play that catalog
311:27 - directory i'll switch to src and to
311:32 - play that catalog that service not the
311:35 - contract but the service one
311:37 - and here i'll add the net add package
311:43 - masstransit.asp.net core
311:46 - okay so this one brings in a bunch of
311:48 - functions that we're going to use
311:50 - in order to interact with the mass
311:52 - transit libraries
311:53 - and the next package is going to be mass
311:55 - transit that
311:58 - habit
311:58 - mq so this one introduces a couple of
312:02 - additional api so that we can explicitly
312:04 - use the a rabid nq service bus
312:08 - okay so with those added let me close
312:09 - this terminal
312:11 - and i'll go to play catalog service and
312:13 - into our items controller
312:16 - and perhaps i'll close the navigation
312:18 - pane for now
312:20 - and here we're going to do a few things
312:21 - first let's get rid of this temporal
312:24 - code that we added in previous lessons
312:25 - to simulate temporal failures so we
312:27 - don't need really any any of these
312:29 - anymore
312:30 - remove that
312:31 - remove that and also remove this request
312:34 - counter that we had added
312:36 - now the first thing that we're going to
312:38 - need here in order to be able to publish
312:39 - messages is what we call a polish
312:41 - endpoint so this is the this is the
312:43 - class that allows us to really
312:45 - communicate that we want to send
312:46 - messages to some location
312:49 - so i'm going to declare
312:53 - a variable of type i publish endpoint
312:57 - let's call it just publish endpoint
313:00 - and for this we're going to need to
313:01 - import
313:03 - the mass transit namespace
313:06 - and then we're going to receive this
313:08 - variable as via dependence injection
313:10 - into the constructor
313:13 - and then we will grab that instance into
313:15 - our pollution point variable
313:18 - now we can go to each of our
313:21 - controller actions operations where we
313:24 - want to push a message and start sending
313:26 - those messages so i'm scrolling down
313:28 - into our post async method
313:31 - and what we're going to do is that just
313:32 - after creating the item in our database
313:36 - we're going to publish a message
313:37 - announcing that the message has been
313:39 - that the item has been created so i'll
313:41 - do
313:41 - await
313:42 - foolish endpoint
313:44 - dot publish
313:46 - and here we're going to use our new set
313:48 - of contracts and we will start with our
313:51 - catalog item created
313:54 - contract and let's see control dot we
313:56 - need to import the play catalog contract
313:58 - namespace
313:59 - and here we have to provide of course
314:01 - the item.id
314:04 - item.name and item.description
314:10 - and that's really all you have to do to
314:12 - publish a message
314:14 - and i'll copy this line
314:16 - because now it's time to go to our put
314:18 - async method and do something very
314:19 - similar so just after updating the item
314:21 - into the database over here
314:23 - let's add and paste that line but in
314:25 - this case the
314:27 - method is going to be catalog item
314:30 - updated
314:32 - and we will choose the existing item
314:33 - variable that we have here
314:35 - we'll use the the id the name and the
314:37 - description
314:40 - i'll copy this once again
314:43 - and let's go to our delete async method
314:46 - and again just after removing the item
314:48 - we will go ahead and publish a message
314:51 - saying that we have a catalog catalog
314:53 - item
314:55 - deleted
314:56 - which is going to be
314:58 - just the
314:59 - id that we received from the
315:02 - from the parameter
315:04 - so yeah so that's all you have to do and
315:06 - so now any
315:08 - any consumer of these messages that is
315:10 - listening to to to the queue to the
315:12 - right queue it will be notified that an
315:15 - item has been created updated or deleted
315:17 - now what we have to do is to
315:19 - do the proper registration in startup uh
315:22 - to configure and to register the classes
315:24 - that we need for mass transit from wmq
315:26 - so i'll open my explorer here
315:30 - and i'll go first to upsetting.json
315:33 - here just like we did with mongodb we
315:36 - need to add a little section for our
315:38 - rabbit enqueue settings
315:40 - so i'll open a section here let's name
315:42 - it
315:42 - rabbit mq settings
315:47 - open a section here
315:50 - and here the only thing that we're going
315:51 - to declare at this point is
315:56 - the host so which which where is this uh
315:59 - this gravity mq server living and in our
316:01 - case since this old local machine is
316:03 - just going to be
316:04 - localhost
316:06 - you could specify more details like
316:07 - username password and a bunch of other
316:09 - settings but for now for local purposes
316:11 - we will just accept the defaults and we
316:13 - will go with localhost
316:16 - save that
316:17 - now just like we did with the other
316:19 - settings libraries settings classes we
316:21 - need to introduce a class that
316:22 - represents a habit and q settings so
316:24 - that we can use that in startup so i'll
316:26 - create a new settings directory here now
316:32 - and of course we will move this later
316:33 - into our shared command command library
316:36 - but for now let's just do it here and we
316:38 - will do that refactoring later on i'll
316:41 - add a new file into the settings
316:42 - directory
316:44 - let's call it
316:45 - rabbit nq
316:47 - settings that's cs
316:50 - let's add a namespace
316:54 - that
316:55 - catalog
316:56 - let's service
316:58 - that settings
317:01 - and then let's declare our class
317:04 - public class
317:06 - habit mq settings
317:10 - and as we know the only thing that we
317:11 - need here is the host so i'll declare
317:14 - our
317:15 - string
317:17 - host
317:19 - and as with any other settings class we
317:21 - will do use this as
317:23 - as
317:24 - init as opposed to set because and
317:26 - nobody should be setting these
317:28 - these properties after they have been uh
317:31 - deserialized from the configuration file
317:33 - i'll save that
317:35 - and now it's time to go to startup to
317:36 - register with the services that we're
317:38 - going to need so i'll go to startup
317:41 - and again i'll collapse this navigation
317:43 - pane
317:45 - so here in startup i'll locate our
317:47 - configure services method
317:49 - right here
317:51 - and then we will add the mass transit a
317:53 - classes just before the controllers
317:56 - let's do it here
317:58 - we're going to say
317:59 - services that
318:01 - add mass transit
318:04 - and we will receive a variable here that
318:05 - we're going to be using to configure
318:07 - things
318:09 - i'll open a section here
318:12 - close this let's see if we're missing
318:14 - something
318:15 - yeah so we need to import the mass
318:17 - transient space
318:20 - and then we will use this x variable
318:22 - here
318:23 - which is that we call the configurator
318:25 - uh to specify the type of transport that
318:28 - we want to use in our case that transfer
318:30 - is going to be rabbit and q so we have
318:32 - to say x dot
318:34 - using rapid mq
318:38 - and then we need to receive we need to
318:39 - specify a function to configure the
318:41 - habit and queue so in this function
318:42 - we're going to declare two parameters
318:44 - which is going to be the context
318:47 - and the configurator
318:52 - and then let's give it a let's give this
318:54 - function a body
318:57 - stat
318:58 - say
319:00 - and the first thing we're going to do
319:01 - here is to
319:03 - get an instance of those rabbit mq
319:05 - settings so that we can figure out
319:06 - what's the host that we're going to use
319:08 - so we will just say
319:10 - have it
319:12 - mq
319:15 - settings
319:19 - it's going to be
319:20 - configuration get section
319:23 - and then the section that it should have
319:25 - the name of
319:28 - covet mq
319:29 - settings
319:33 - have it into settings class
319:34 - and let's see if we're missing something
319:36 - yeah we need to import the play catalog
319:37 - service settings namespace
319:40 - and when we have that we can say okay so
319:42 - now get it as a
319:45 - habit enqueue
319:48 - settings type
319:52 - okay so we have the settings and now
319:54 - what we can do is use the configurator
319:56 - to set the host
319:58 - where our gravity mq instance lives and
320:00 - that's going to be in
320:01 - gravitysettings.host
320:06 - and now we'll add one more line this is
320:07 - not necessary but i think it's very
320:09 - handy and this line is going to help us
320:11 - define or modify a little bit how the
320:13 - cues are created in the rabbit and queue
320:16 - so i'll do configurator dot configure
320:18 - endpoints
320:21 - and here we're going to receive the
320:23 - context
320:25 - and
320:26 - afford mater and what we're going to use
320:28 - is the
320:31 - kebab
320:32 - case
320:33 - endpoint name formatter
320:38 - see if we're missing something yeah we
320:39 - need mass transit that definition
320:42 - and in this formatter we're going to
320:43 - define
320:44 - um
320:46 - we're going to define first uh the
320:48 - prefix that we're going to be using for
320:49 - our cues and that's going to be
320:51 - service settings
320:54 - dot
320:56 - service name
320:58 - and then we will not need to include the
321:00 - full name space of our classes in those
321:03 - queues so we'll say we'll just say false
321:05 - here
321:07 - and lastly we'll add one more line just
321:09 - after this one
321:10 - to start they must transit
321:12 - the hosted service
321:14 - so we will say services that
321:17 - add
321:19 - holds service
321:20 - and this is the service that actually
321:22 - starts the rapid mq bus so that messages
321:25 - can be published to the different
321:27 - exchanges and queues in rapid queue
321:30 - i'll save that
321:32 - and for one last change i'll go to our
321:35 - i'll go to our explorer
321:38 - and i'll go to app settings at
321:39 - development.json and this is something
321:41 - that i like to do more for demonstration
321:42 - purposes than for anything else but this
321:44 - is a changing the default
321:47 - login level
321:48 - from information to debug
321:50 - so i found that this is going to be very
321:52 - handy for us to understand what's going
321:54 - on behind the scenes when messages start
321:56 - flowing between services so we'll do
321:59 - that
322:00 - over
322:00 - here
322:02 - and at this point the catalomic service
322:04 - is ready to publish messages to have it
322:06 - and queue
322:07 - but we don't have a rabbitmq instance
322:09 - available just yet
322:11 - in the next lesson we will expand our
322:13 - docker compose file to also stand up a
322:15 - rabbitmq docker container that our
322:18 - catalog service can communicate with
322:21 - it's time to stand up our rapidmq
322:23 - message broker
322:24 - and of course we'll use docker for that
322:27 - so here i am in visual studio code and
322:29 - what i'll do is i'll open our play.inf
322:32 - directory play that infra and then i'll
322:35 - do code.r
322:41 - and here i'll just go ahead and close
322:44 - this close that and i'll open our docker
322:46 - compose java file and perhaps i'll
322:48 - collapse this
322:51 - so the first thing that i'll do is i'll
322:53 - go ahead and remove this comment that we
322:54 - had at the top
322:56 - and now we can go ahead and start
322:57 - declaring our gravity mq service so just
323:00 - like we did with
323:02 - we'll come here
323:03 - and we will declare a service for
323:05 - driving queue
323:07 - let's name it having queue
323:11 - and then as usual the first thing that
323:13 - we want to declare here is the image
323:14 - that we're going to use
323:16 - that image is going in this case is
323:18 - going to be the standard rabbitmq image
323:22 - that includes also a portal to manage a
323:25 - derivative infrastructure so that would
323:27 - be driving queue management
323:29 - then we will mention the container name
323:31 - the name that we're going to give to
323:32 - this container and it's just going to be
323:34 - rabbitmq
323:36 - then we'll go for the ports section
323:41 - we're going to open uh two ports
323:43 - one port for our services to communicate
323:46 - without having queue and then another
323:48 - port for us to be able to navigate to
323:52 - the cabinet and queue portal so the
323:54 - first port is going to be
323:57 - five six
323:58 - seven two
324:01 - maps to the same one internally
324:03 - and the other port is going to be
324:05 - fifteen
324:06 - six seven two
324:09 - which maps to the same port internally
324:10 - too so the first one is going to be used
324:12 - by the services to publish messages to
324:14 - or to consume messages from hybrid and
324:16 - queue and the second one is going to be
324:17 - used to be able to go to the portal to
324:19 - the writing q portal
324:21 - then we're going to go to the volume
324:23 - section and we're going to declare a
324:24 - volume also for having queue
324:27 - which is important because we don't want
324:28 - to be missing those messages if the
324:31 - gravity and queue container goes down
324:33 - so i'll just declare gravity mq data
324:38 - and now we have to uh we have to map
324:40 - that volume into some location in our
324:42 - rabbit mq
324:44 - image or container
324:45 - so i'll declare volumes
324:50 - i will copy have it in queue data
324:55 - and then location the location that you
324:57 - want to map inside rabbit enqueue
324:59 - is going to be var
325:03 - leave
325:04 - grab it mq
325:06 - and one more thing that we have to
325:07 - suffice here which is pretty important
325:09 - is the hostname
325:11 - so hostname and we will give it the
325:13 - value of rabbit enqueue
325:15 - so this one here is pretty important
325:17 - because this is associated to how having
325:19 - mq stores data internally and if you
325:22 - don't specify it then it gets a random
325:24 - value and then each time we restart the
325:26 - container gravity and q would store data
325:28 - in a different place which is not going
325:30 - to help us really a lot so keep in mind
325:32 - you always want to specify here it
325:34 - doesn't matter what value is here but
325:35 - you have to specify some value
325:37 - okay so with that done i'll do ctrl s to
325:39 - save this file
325:41 - and then i'll open the terminal
325:43 - and it's time to start this container
325:45 - via docker
325:47 - compose
325:50 - up dash d
325:52 - hit enter
325:54 - and this is the first time that i'm
325:56 - pulling in the
325:57 - hovering q image so you have to download
325:59 - it to my machine
326:00 - like i said next time it will be faster
326:04 - so yeah now we have
326:06 - we have raving queue up and running over
326:08 - here
326:10 - and with that we can start trying this
326:11 - out so i'll go back to our catalog
326:14 - project
326:16 - and here we're going to start the
326:18 - catalog the catalog web server uh but
326:20 - we'll do it via dotnet run so that we
326:22 - can take a closer look at what's
326:23 - happening behind the scenes so i have
326:25 - opened the terminal ctrl j then i'll do
326:28 - src and then i'll do
326:30 - data catalog that service
326:33 - and then let's just do dot net run here
326:36 - i'm going to collapse this also
326:40 - and so a couple of things to notice here
326:42 - is that
326:43 - uh so yeah mass transit is doing its job
326:45 - it's starting the starting the bus
326:48 - and then it has connected to
326:50 - it has connected to gravity and q in
326:52 - port 5672
326:54 - is using the protocol aem qp so here's
326:57 - where you can see the actual address of
326:59 - rabbit enqueue in the docker container
327:01 - uh like i said this is the one port to
327:03 - connect uh today to the queues
327:05 - and so things are looking ready on this
327:08 - side so now we'll go to postman
327:12 - and what i'll do is i'll go ahead and i
327:14 - will create an item in our catalog so
327:17 - i'll go to our catalog
327:19 - api and i'll open the post one
327:25 - and here i'll create some new item
327:28 - let's say this time we're going to
327:29 - create an antidote
327:31 - so antidote
327:34 - curse poison
327:35 - and then price going to b7
327:38 - and i'll hit send
327:41 - so that then got created in the database
327:43 - but now let's see what else happened so
327:46 - if we see now here
327:48 - yeah the item got created but also
327:51 - an exchange was created uh in gravity
327:54 - and queue so mass transit created this
327:56 - exchanging gravity queue for us that's
327:58 - one of the nice things about mass
327:59 - transit so we don't have to create it
328:01 - manually and it got the name play
328:03 - catalog contracts and then the name
328:05 - would be catholic item create
328:08 - so an exchange will be created for each
328:09 - of the messages that we publish
328:12 - from from catalog
328:14 - and you can see that after created
328:16 - exchange it also sent the message to
328:18 - that
328:20 - to that exchange the message was sent
328:22 - over there
328:24 - and so if you want to see
328:25 - how this looks like in gravity and queue
328:27 - actually we can go ahead and check out
328:29 - the java and q portal so let's open that
328:30 - portal now
328:34 - here we are in the browser let's go to
328:37 - localhost
328:40 - 15672
328:41 - is the
328:42 - easy place
328:44 - and here we're going to use just the
328:46 - default username and password for having
328:48 - queue so that's going to be guest and
328:50 - it's exactly the same password just
328:52 - guest
328:53 - login
328:55 - and in this ui you can see a couple of a
328:58 - bunch of things but really the one thing
329:00 - that i wanted to show you now is the uh
329:02 - the exchanges
329:04 - and as you can see there is a exchange
329:06 - created here cattle guiding created
329:09 - and issued i find out meaning that
329:11 - anybody listening to this exchange will
329:13 - be able to
329:14 - get the messages
329:15 - and then cattle guide and create it i'll
329:17 - go in there
329:18 - and then
329:20 - there's not much to see here because the
329:22 - exchange just takes messages from one
329:23 - place to the other it's not going to
329:24 - store the messages and then as you can
329:27 - see the exchange right here in binding
329:28 - section it is not connected to any it
329:30 - doesn't have any bindings just yet and
329:32 - that's because we don't have a consumer
329:34 - of these messages yet which is going to
329:36 - be inventory and but it's not there yet
329:38 - so the queue has not been created and so
329:40 - there's no destination for these
329:42 - messages just yet
329:44 - and so at this point we are able to
329:46 - publish messages from our catalog
329:48 - service
329:49 - anytime our items database is updated
329:53 - so in the next lesson we will generalize
329:55 - some of the code that we have added here
329:57 - into our common library in preparation
329:59 - for having inventory start consuming the
330:01 - polished messages
330:04 - let's move the code that configures mass
330:06 - transit and rabbitmq into our common
330:09 - library so that things get easier and
330:11 - cleaner for catalog and any future mic
330:14 - services
330:15 - so here i am back in our catalog project
330:19 - and i'll start by
330:21 - going to our settings folder
330:23 - and i will copy our raven queue settings
330:26 - file copy that
330:29 - and then i'll switch to
330:31 - our common project our common library
330:34 - i'll open our settings folder and i'll
330:36 - paste the copied class
330:39 - and i'll grab the name space from some
330:41 - other of our
330:42 - settings classes i'll just fix that
330:44 - namespace here
330:46 - save
330:47 - and now before adding the mass transit
330:49 - classes let's bring in the nougat
330:51 - packages that we're going to need over
330:53 - here so i'll do ctrl j
330:56 - let's go into sirs
330:59 - play that common
331:01 - and let's add the same packages that we
331:03 - already added into catalog so
331:07 - dot net add package
331:10 - mass transit that is b net core
331:17 - and then let's do
331:18 - mass transit that
331:21 - have it mq
331:26 - all right
331:27 - so with that done let's go ahead and
331:31 - create a new folder
331:34 - let's call it
331:35 - mass transit
331:39 - and perhaps let's close this terminal
331:40 - for now
331:41 - and just like we did with mongodb
331:44 - let's add an extensions file here
331:49 - but we're going to add our handy
331:50 - extension method so let's first declare
331:52 - namespace
331:59 - click that command that means transit
332:01 - and now let's create our class
332:07 - it should be a static class
332:10 - and now we'll bring in our extension
332:11 - method so this is going to be
332:13 - public static iservice collection
332:19 - add mass transit
332:22 - with rabbit mq so that way we can do all
332:25 - the registration for mass transit and
332:27 - everything queue in one location let's
332:29 - add the missing space
332:31 - and
332:32 - let's expand
332:34 - let's extend i service collection
332:38 - services
332:42 - and here is where we're going to bring
332:43 - that code from the catalog service i'm
332:45 - going back to catalog
332:49 - into the startup class
332:51 - scrolling down
332:53 - i'll copy these lines
332:56 - copy that
332:59 - into common
333:00 - and i'll paste them over here
333:04 - and now let's start fixing all these
333:06 - missing name spaces so admins transit we
333:10 - need to import using mass transit
333:14 - and then uh for gravity mq settings
333:16 - we'll need to import play that
333:18 - command.settings
333:19 - give that case endpoint name for matter
333:22 - we'll need my strategy.definition
333:25 - okay and just before we also will need
333:28 - an actual instance of the configuration
333:30 - class and an instance of our service
333:33 - settings class now these are very
333:34 - similar to what we did in mongodb so
333:37 - let's see if we can get something from
333:38 - there so mongodb extensions
333:40 - let's see let's yeah let's grab these
333:42 - two lines
333:44 - let's close this
333:46 - and into this spot
333:49 - there
333:50 - and let me collapse this navigation pane
333:52 - now
333:55 - so here we also need an entry an import
333:56 - for eye configuration let's grab that
333:59 - extensions configuration
334:01 - and you can notice that there's no
334:03 - service provider variable available here
334:06 - however we do have a service provider
334:08 - and that is this context class that
334:10 - that's that's over here this ibus
334:11 - registration context exactly a service
334:13 - provider so we'll use that
334:15 - as the class that can give us an
334:17 - instance of i configuration
334:20 - we can also fix this other configuration
334:23 - member here
334:25 - and let's also rename this x variable
334:27 - here to something more meaningful let's
334:29 - name it
334:30 - configure
334:31 - and since we are here one more thing
334:33 - that we can do
334:34 - is to perform the consumer's
334:36 - registration the consumers are the
334:38 - classes that are in charge of consuming
334:41 - messages from the rabbit and queue
334:43 - message queues
334:44 - we have not created these classes just
334:46 - yet for catalog because catalog is not
334:48 - consuming but just publishing messages
334:49 - but we will create these classes
334:50 - inventory so since inventory will be
334:53 - using this method we might as well just
334:54 - add that registration over here
334:56 - so i'll open a couple of lines here and
334:59 - what i'll do is i'll just say
335:01 - configure
335:02 - dot add consumers
335:04 - and there's a few ways to register
335:06 - consumers and the way we're going to do
335:07 - it is that we're going to specify
335:09 - the assembly that should have all the
335:11 - consumers already defined and that's
335:13 - going to be the uh the entry assembly
335:15 - for whichever microservice is invoking
335:17 - this this class so to get that we're
335:19 - going to say
335:21 - assembly and we need another import here
335:23 - using system reflection
335:25 - that get entry assembly
335:28 - and that that should do it
335:30 - okay so any consumer classes that are in
335:32 - that assembly will be registered by this
335:33 - method
335:35 - and finally let's go ahead and
335:38 - return our services instance
335:42 - to complete this method
335:45 - okay so with that let's make sure
335:47 - everything is built in so i'll do ctrl
335:49 - shift b
335:51 - and yeah everything builds just fine and
335:53 - now let's go ahead and package it all
335:56 - these new changes into a new version of
335:58 - our nougat package so let's go back into
336:01 - our powershell terminal and perhaps our
336:03 - clean this
336:05 - and listen we did before we're going to
336:07 - do dot net pack
336:09 - but this time we're going to specify a
336:10 - version last time we didn't do it and
336:12 - that generated version 100 for package
336:15 - this time we need to increase the
336:16 - version so that our consumers can
336:18 - actually notice that there's something
336:19 - new available in the in the package so
336:22 - to specify version what you can do is
336:23 - use the d
336:25 - p sorry
336:26 - parameter and then you specify
336:28 - package version
336:31 - and then you specify the version so i'll
336:32 - say 1
336:34 - 0 1
336:36 - and then just before we'll specify an
336:38 - output directory it's going to be the
336:39 - same location as before
336:42 - packages
336:44 - enter
336:46 - and we got a new nuget package created
336:48 - right there
336:50 - so now let's go back to our catalog
336:51 - project and start taking advantage of
336:53 - this package
336:57 - and first thing i'll do is i'll delete
336:59 - our settings directly once again we
337:00 - don't need it
337:02 - get rid of it
337:03 - then i'll go to our project file and
337:06 - since we're bringing in this nuget
337:08 - package that has all the master assets
337:09 - stuff we should not need these two
337:11 - references so i'm going to get rid of
337:13 - them
337:15 - save
337:16 - and now what i'll do is i'll just go to
337:18 - our play.com dependency and i'm going to
337:20 - bump the version number here this is one
337:22 - zero zero bumping it to one zero one
337:25 - i'll hit save
337:27 - this pop-up dialog shows up asking us to
337:29 - resolve the updated dependencies so i'll
337:31 - do a click on restore
337:33 - and that's going to bring in the updated
337:35 - package into catalog
337:37 - so i'll close this and i'll close that
337:39 - and now it's time to update our startup
337:41 - class to take advantage of the new
337:44 - package
337:46 - and first let's get rid of this unneeded
337:48 - import at the top
337:52 - and now what we can do is just since
337:54 - it's fluent let's expand on top of our
337:56 - admonk repository so let's just do
338:00 - add
338:02 - mass transit
338:05 - with rabbit enqueue
338:09 - we may be missing a namespace
338:11 - we need to import play.com on that mass
338:13 - transit
338:14 - and then that becomes a one line that we
338:16 - have to run to execute all this stuff
338:18 - that we were doing before so i'll get
338:20 - rid of all these lines
338:22 - save
338:24 - and that should be good enough i'll do a
338:25 - ctrl shift v to make sure that things
338:27 - are compiling
338:29 - yep it's looking good so let's go back
338:32 - let's open a new terminal here
338:34 - and let's verify that things keep
338:36 - working properly so i'll do i'll go to
338:38 - src
338:44 - it's not into contracts we want to go
338:46 - into
338:49 - service and then i'll do dot net run
338:55 - yup so yeah we are connected we have
338:58 - connected to the rabbit and queue
338:59 - so it's time to do something about
339:01 - messaging so let's go back to postman
339:06 - and last time we had created this
339:07 - antidote
339:09 - item and so instead of creating a new
339:11 - one why not let's try the an update
339:14 - operation so i put so i'm going to just
339:16 - copy this
339:18 - and then
339:19 - let's go into put
339:22 - and then in the body we're going to just
339:24 - paste paste this
339:26 - so it's the same antidote curse poison
339:28 - but let's say that the price is now 9
339:31 - and then let's bring the id
339:33 - hopefully the same id that we used
339:34 - before
339:35 - so copy this id
339:38 - into the url
339:39 - for the put operation
339:41 - and then i'll hit send
339:45 - so we go 204 so it was a success
339:48 - and now let's go back to vs code
339:51 - and yeah just like before the exchange
339:53 - was declared
339:54 - and the message was sent to the exchange
339:57 - as you can see
339:59 - but this time we should have a new
340:00 - exchange so let's go back to riveting
340:02 - queue briefly
340:04 - and here let's go now to exchanges
340:07 - and as you can see there's a new
340:08 - exchange here cattle guiding updated so
340:10 - things are working properly
340:14 - and one last thing that we have to do
340:15 - here is to actually publish the catalog
340:18 - contracts as a nugget package so that
340:20 - inventory can use it in the next lesson
340:22 - so let's go ahead and go back to catalog
340:27 - and here i am i'm going to do ctrl c in
340:29 - my terminal so that the whole stops and
340:32 - then i'll switch to
340:34 - our play dead catalog that contrast
340:37 - directory
340:39 - and here i'll do what we did before so
340:41 - dot net
340:43 - back
340:44 - and then output directory
340:49 - packages
340:50 - that should go ahead and produce our
340:52 - contracts package hit enter
340:55 - and there it is so now we have a
340:57 - contacts package that inventory service
340:59 - will be able to
341:00 - use to consume the messages
341:03 - in the next lesson we will update our
341:05 - inventory service so that it can consume
341:07 - the messages published by catalog
341:11 - the whole point of moving inventory to
341:12 - using asynchronous communication is to
341:14 - have its own database of catalog items
341:17 - that it can use without ever having to
341:18 - get in touch with the catalog service
341:20 - api
341:21 - therefore let's start by defining the
341:23 - entity that represents catalog items in
341:25 - the inventory microservice
341:27 - so here i am back in our inflatable
341:29 - inventory microservice
341:31 - and i'll open our entities directory now
341:34 - this new entity that we're going to
341:35 - create has some similarities with
341:36 - inventory items so i'm actually going to
341:38 - start by getting a copy of inventory
341:40 - item
341:41 - so i'll just copy this and i'll paste it
341:43 - right there and let's rename this into
341:47 - catalog
341:48 - item
341:50 - catalog item and we rename this as
341:53 - catalog item which also implements
341:55 - identity
341:56 - but in this case it's not going to have
341:59 - most of these properties but it's only
342:00 - going to reduce the id
342:02 - now remember the categorizing has a
342:04 - bunch of properties in the catalog
342:06 - service but here we will only introduce
342:08 - the properties that make sense for
342:10 - inventory
342:11 - so in this case this is going to be
342:13 - we'll start with the
342:15 - with the name
342:17 - and then we will also need
342:21 - description
342:24 - okay so keep in mind that as you are
342:26 - bringing in these entities from other
342:27 - microservices you don't have to have
342:29 - everything that
342:30 - these entities have in the other service
342:32 - it's only a the version
342:34 - that the new market service needs in
342:36 - this case us id name and description
342:39 - with that done let's go ahead and start
342:41 - bringing in the nuget packages that we
342:42 - need for this
342:43 - so i'll go to
342:44 - play.inventory.service.csprock
342:47 - and then i'll open my terminal
342:49 - so let's go to src
342:54 - enter the service play inventory service
342:57 - and let's get a reference to our new a
343:00 - catalog contracts nuget package so
343:03 - dotnet add package
343:07 - play that catalog that contracts
343:10 - remember this has all the contracts that
343:12 - we can use to consume messages from
343:14 - catalog okay with that done let me close
343:17 - this and now you can see that we have
343:19 - applicator contracts here
343:20 - but we also need to bump the version of
343:23 - play.com because remember we added some
343:25 - new uh
343:26 - so some new classes in there so album
343:29 - from version one zero zero to version
343:31 - one zero one i'll save that
343:34 - let's go ahead and restore the new
343:37 - the new nugget package
343:39 - now we can close this
343:41 - close this these files
343:43 - now it is time to define the consumers
343:45 - and like i said before the consumers are
343:47 - the classes in charge of consuming the
343:50 - messages that have been published by any
343:52 - other microservice
343:53 - so to define the consumers let's go
343:55 - ahead and
343:57 - create a new folder let's call it
344:00 - consumers
344:02 - and we have to create one consumer for
344:04 - each of the different operations that
344:07 - happen in catalog so that's for creation
344:09 - update and delete of
344:12 - of catalog items so i'll go ahead and
344:14 - create a new file let's name this one
344:16 - catalog item
344:18 - created
344:19 - consumer
344:23 - copy the
344:24 - name let's give it a name space
344:30 - service
344:32 - consumers
344:37 - okay so this is our catalog item created
344:39 - consumer
344:40 - and the first thing that you have to do
344:41 - about this consumer's class is to make
344:43 - sure that they are actually consumers
344:44 - and to do that you have to implement the
344:47 - iconsumer
344:49 - high consumer interface which is part of
344:51 - mass transit and i'll do control dot so
344:54 - using mass transit and here you also
344:56 - have to specify what is the type of
344:58 - message that this consumer is going to
344:59 - handle and that type of message is
345:01 - actually coming from them the contracts
345:04 - that we're bringing in from catalog so
345:06 - in this in this case it's going to be
345:08 - catalog item created
345:13 - let's see if we're missing something
345:14 - using play.contracts
345:17 - so then let's go ahead and implement
345:19 - this interface so i'll do ctrl dot here
345:21 - implement interface and as you can see
345:23 - we just have to implement one method
345:25 - that which is the consume method so
345:27 - which is where we're going to actually
345:28 - uh perform the action of of consuming
345:30 - the message
345:32 - and so what we want to do when we
345:33 - consume the message is actually a
345:35 - storage in our local catalog items
345:38 - database
345:40 - so to do that let's first introduce a
345:42 - repository that we can use for for that
345:44 - so i'll declare
345:47 - read-only i repository
345:52 - of type catalog item okay so this is the
345:55 - new entity we just introduced it
345:57 - for catalog guidance in inventory
346:01 - all right
346:02 - see if you're missing something play
346:04 - that common for i repository
346:08 - and play that inventory service entities
346:12 - and now we need to inject this
346:13 - repository in the constructor of this
346:15 - class so let's define a constructor
346:17 - so
346:18 - public catalog item created
346:22 - consumer
346:23 - and so here's where the repository comes
346:24 - in
346:28 - okay
346:29 - so let's say this data repository equal
346:32 - repository
346:34 - let's now go ahead and implement the
346:36 - consume method for this class
346:39 - so i'll get rid of this and let's first
346:42 - get a copy of the of the message so the
346:45 - message
346:46 - that we're receiving
346:48 - is available in the context variable
346:51 - as the message property so let's grab
346:53 - that copy there
346:55 - and then what we want to do as we
346:56 - consume this message is probably first
346:59 - make sure that we have not consumed this
347:01 - already right uh we we may have a very
347:03 - consuming message of the creation of an
347:05 - item uh
347:07 - with the idea that we're going to get in
347:09 - this message uh and if we did we already
347:11 - would have that into the database so
347:12 - let's make sure that we don't have it
347:14 - and if we do have it let's just return
347:16 - there's nothing else to do but if we
347:17 - don't have it we'll go ahead and create
347:18 - it
347:19 - so let's see
347:20 - item is a weight
347:24 - repository
347:26 - not get async
347:29 - and that's going to be in message dot
347:31 - item id
347:33 - let's also make sure that this method is
347:35 - async
347:39 - and then
347:40 - if item
347:42 - is not new
347:45 - then we will go ahead and return
347:47 - okay because in this case it happens to
347:49 - be that we already created this item in
347:50 - our local database so why would we
347:52 - create it again
347:53 - if not we will say new catalog item
348:00 - and then we'll say all these
348:02 - message.item id
348:06 - name is message that name
348:10 - and description
348:12 - is message the description
348:17 - finally we'll go ahead and
348:19 - do repository dot create async
348:23 - of this item
348:25 - okay so that's all you have to do to
348:26 - consume a message that represents a new
348:29 - item that has been created in the
348:30 - catalog like i said we just verified if
348:32 - the item is already here because it
348:34 - could happen in the cases where
348:36 - for some reason the publisher publishes
348:38 - the same message twice
348:40 - and so we don't want to be having errors
348:42 - here because we already have the item in
348:43 - our catalog guidance database so if we
348:45 - don't have it we'll go ahead and define
348:47 - it and create it into our local database
348:50 - let's go ahead and do something similar
348:52 - for our a update so when a catalog item
348:54 - has been updated so i'll get a copy of
348:57 - our of the consumer
349:00 - and let's just rename it into
349:05 - catalog item
349:08 - updated consumer
349:11 - okay
349:12 - so i'll do this
349:13 - and then the the message is catalog item
349:17 - updated
349:20 - so let's fix a couple of things
349:21 - constructor
349:26 - there
349:27 - okay so we are consuming now catalog
349:29 - item updated
349:31 - and here the logic is going to be a
349:32 - little bit different so
349:34 - for an update it could be that we
349:36 - already have this inventory item in our
349:39 - local database so in which case we'll
349:41 - need to go ahead and just update the
349:43 - properties or it could be that this is
349:44 - the first time that we receive this
349:47 - message for this item in which case
349:49 - we'll go ahead and create it
349:51 - so now in the case that uh so first just
349:54 - before we can go ahead and get the item
349:56 - but if the item is new so we'll change
349:58 - this if item equals no then we will go
350:02 - ahead and define these lines that we had
350:05 - over here
350:07 - there
350:09 - so editing is new we don't have it in
350:10 - the database so let's go ahead and
350:11 - create it
350:13 - otherwise
350:17 - let's just update the the properties
350:19 - that make sense in this case it's going
350:20 - to be item.name equals message.name
350:25 - and item.description equals
350:27 - message.description
350:30 - and in this case let's go ahead and call
350:32 - weight repository
350:34 - that update async
350:37 - item
350:39 - okay so quick recap we for an update
350:42 - operation we go ahead find the item if
350:43 - we cannot find it we will go ahead and
350:46 - create it into the database and if we
350:47 - find it we update nameless description
350:49 - and update it into the database
350:52 - now let's go ahead and implement our
350:53 - third consumer which is going to be four
350:55 - deleted items so again i'll get a copy
350:57 - of
350:58 - this last consumer
351:00 - paste here and then rename it into
351:05 - catalog item
351:08 - deleted consumer copy this name
351:12 - so i'll update the name of the class the
351:15 - constructor and then let's make sure we
351:17 - also update the message that we're
351:18 - handling here this is catalog item
351:20 - deleted
351:24 - here and there and in this case things
351:27 - are even easier
351:29 - and so we will go ahead we'll try to
351:32 - find the item and if we cannot find it
351:34 - uh it means that for some reason it does
351:35 - not exist in our local database so
351:36 - there's really not much more to do in
351:38 - our case so we will go ahead and just
351:40 - return
351:42 - we don't have it just go ahead and
351:43 - return and if we have the item
351:46 - then we can go ahead and say
351:49 - weight repository remove async
351:53 - message.item id
351:56 - okay so with that we have our three
351:59 - consumers defined
352:01 - and now it's time to perform the proper
352:02 - registration in startup
352:05 - and before we can do that let me go to
352:07 - app settings.json and we need to declare
352:09 - those rabbitmq settings so that we know
352:11 - how to communicate to have it in queue
352:14 - so i'll actually go back to catalog
352:16 - our catalog service over here and i'll
352:18 - just grab those
352:19 - three lines for hybrid mq settings for
352:21 - an upsizing adjacent
352:23 - and then back to inventory we will add
352:25 - that over here
352:28 - same thing we're talking to localhost
352:29 - for arriving in queue
352:31 - now let's go to startup
352:34 - okay um perhaps i'll collapse this for a
352:36 - moment
352:38 - so let's do a few things here so as you
352:40 - see we still have this logic to
352:43 - use the catalog client to talk to the
352:45 - catalog service uh we will not be using
352:47 - this anymore
352:48 - but let's keep this logic around in case
352:51 - you want to reference it later but what
352:52 - we're going to do is we're just going to
352:54 - refactor it into another method so we
352:56 - don't have to have all this stuff
352:57 - hanging around here so i just selected
352:59 - all this logic
353:00 - to use the you know the retries and the
353:03 - configuration of the client i'll do ctrl
353:04 - dot and i'll say extract method
353:08 - so we'll name this method at catalog
353:11 - client
353:14 - and i'll take this method and just send
353:16 - it
353:18 - to the end of the file
353:20 - so that we don't have to see it
353:22 - frequently
353:26 - and now a couple of things that we have
353:27 - to do here for
353:30 - for uh our new a catalog items
353:34 - repository and mass transit so
353:36 - first we need to introduce a new
353:37 - repository here for the catalog items so
353:39 - i'll say
353:40 - add repository
353:43 - catalog of catalog item and then we need
353:46 - to give a new name for this new
353:47 - collection of items in this case it's
353:49 - going to be
353:51 - catalog items
353:54 - okay so keep in mind that both of these
353:56 - are going to live in the same database
353:57 - the same inventory database but it's two
353:59 - collections one collection for inventory
354:01 - items and one collection for catalog
354:02 - items
354:04 - and then we also need to add the mass
354:06 - transit registration so i'll say add
354:09 - as transit
354:11 - with habit mq
354:16 - let's add a missing space
354:18 - and that's pretty much it on startup
354:21 - then let's go back to our explorer one
354:24 - more thing that i'll do is just like we
354:25 - did in catalog let's flip the default
354:27 - log level so that we can see also
354:30 - what's going on regarding
354:32 - all these message exchanges
354:34 - so i'll change this to debug
354:37 - and with that our inventory service is
354:39 - ready to start consuming messages but
354:41 - one more thing that i'd like to do is to
354:43 - actually
354:44 - clean up our databases and i like to do
354:46 - this because
354:48 - at this point we we do have some data
354:50 - both in inventory and catalog site but
354:52 - that that data has never been
354:53 - synchronized at all so it will be better
354:56 - to use a start clean in a situation
354:58 - where both sides are actually
355:00 - synchronized from the start so i'll go
355:02 - back to mongodb
355:04 - the mongodb extension i'll expand this
355:07 - and as you can see we do have the
355:08 - catalog and inventory databases so to
355:10 - clean them up i'll just right click and
355:11 - say drop database
355:14 - i'll drop catalog
355:17 - and then i'll drop
355:19 - inventory
355:22 - you may choose to not delete them but
355:23 - that could cause issues as as you start
355:25 - moving forward so it's better to use
355:27 - starkling in this case
355:30 - at this point i'll start our micro
355:31 - services so i'll do ctrl j to open the
355:33 - terminal
355:34 - i'll go to my terminal and perhaps i'll
355:37 - do
355:38 - clean
355:40 - and just so that we can see things
355:41 - better what i'll do is i'll
355:43 - see i'll collapse this and i'll bring in
355:44 - yet another terminal with the split
355:46 - terminal put on here so that we can see
355:48 - services in both sides
355:51 - so perhaps what i'll do is i'll switch
355:53 - to
355:53 - a catalog on the left side
355:57 - so i'll go to play that catalog
356:00 - and then
356:03 - play catalog service and on the right
356:05 - side i'll stay in inventory so i'll do
356:12 - play inventory service
356:14 - okay so let's clean both sides
356:18 - and now we can start both services i'll
356:20 - do dotnet run both sides
356:27 - and now notice in the right side that a
356:30 - few new things are happening and perhaps
356:32 - i'll move this around a little bit
356:36 - and yeah it may be a bit hard to see but
356:40 - exchanges has been declared for the
356:43 - for the consumers that we declare here
356:45 - you can see we have exchanges for a
356:47 - cutter guiding created updated and
356:49 - deleted
356:51 - and if we scroll down a little bit let's
356:53 - see
356:56 - these exchanges are now connected to the
356:58 - queues so you can see that this this
357:00 - exchange is now connected to our new
357:02 - inventory catalog item updated queue
357:05 - same for created and deleted
357:09 - and
357:10 - the consumers are reporting that they
357:12 - are okay so they're ready to start
357:13 - consuming messages okay so let's move
357:16 - this
357:17 - over here
357:19 - so now let's see this in action so let's
357:20 - go to
357:21 - postman
357:23 - and what i'll do is i'll start by
357:24 - creating a brand new item
357:26 - so i'll go to our post item api in play
357:30 - catalog service body
357:32 - and let's define our classic potion
357:34 - example again
357:36 - we'll say potion
357:39 - sources small amount of hp
357:42 - and the price is going to be 5.
357:45 - i'll go ahead and hit send
357:48 - the item has been created
357:50 - and then let's go back to our terminals
357:52 - and see what happened
357:55 - so as you can see on the left side
357:57 - the change was declared cut the guiding
357:59 - created and the message was sent right
358:02 - so cattle guiding created was sent
358:05 - and then the right side we can see that
358:07 - now we actually received the message
358:10 - and that was handled by the cattle guide
358:12 - and created consumer
358:14 - so if things went uh
358:16 - correctly we should now have a copy of
358:18 - the catalog item in our local a catalog
358:20 - guidance collection in inventory site
358:22 - inventory database
358:24 - let's go to mongodb
358:27 - let's see what we have so i'll expand
358:29 - this
358:31 - so we have the catalog database with
358:33 - this item created here and then we'll
358:35 - expand inventory
358:37 - and then you can see that we do have now
358:39 - our catalog items collection
358:41 - with that
358:43 - item created over here
358:45 - so the item has been replicated from
358:47 - catalog into inventory
358:50 - we can now take a look also
358:52 - the activity that happened in driving
358:54 - queue so let me go to the driving queue
358:55 - portal over here
358:57 - and let's take a look at exchanges so
358:59 - see that we now have the three exchanges
359:02 - uh for category created deleted and
359:04 - updated
359:05 - from the catalog side
359:08 - and then also the
359:10 - the changes from the inventory side
359:13 - created outdated and then if we go to
359:15 - queues you can see that now we have the
359:17 - three queues for the three types of
359:19 - events
359:20 - and
359:21 - if you go to cattle guide and create it
359:23 - we could see here any activity that goes
359:26 - across this queue now the item has been
359:28 - already consumed so there's nothing not
359:30 - much to see here but let's see what
359:32 - happens in a case where let's say that
359:34 - our catalog service is is not running
359:37 - right so
359:38 - actually our inventory service is not
359:39 - running so our catalog service pulls
359:41 - some message but inventory is not
359:42 - running now that the queue is up and
359:44 - running
359:45 - things are going to work in a speed of a
359:47 - different way so let's go back to
359:50 - inventory
359:52 - and i'm going to stop the terminal on
359:53 - the right side i'm just going to do ctrl
359:55 - c
359:56 - inventory stops now
359:58 - and let's go back to postman and create
360:01 - yet another item so i'll create an
360:03 - antidote
360:05 - which cures poison
360:08 - and price is going to be seven
360:10 - so i'll go ahead and pause this
360:13 - and then if we go back to rabbit and q
360:17 - let's see gather guy and create it
360:20 - you can see that now there is a one item
360:23 - in the queue as reflected by this
360:26 - as you can see it's one item
360:28 - which is waiting to be
360:30 - consumed by somebody
360:32 - so here is where the nice thing about
360:34 - asynchronous communication starts
360:35 - happening so there's no need for
360:37 - cataract to be up and running all the
360:38 - time uh inventory can nicely just keep
360:41 - polishing these updates uh to their
360:44 - to to their items and then whenever
360:47 - inventory comes back it should be able
360:48 - to consume the the message
360:50 - and in fact let's go back to our
360:52 - terminals
360:53 - over here
360:54 - you can see that the category was
360:56 - created on the left side and now let's
360:57 - go ahead and start a terminal on the
360:59 - right side
361:00 - let me collapse this once again
361:03 - okay so on the right side i'm going to
361:04 - do.net run again
361:07 - and then you can see that right away
361:09 - inventory is able to consume the new
361:12 - message
361:13 - so the databases should be in sync again
361:17 - we can see that there's no more messages
361:19 - here waiting the message was consumed
361:22 - and our databases should be once again
361:25 - sync let me refresh this
361:27 - so yeah we have two documents here and
361:29 - we have two documents over there
361:32 - so things are in sync
361:35 - so our inventories microservice now have
361:37 - a nice way to stay in sync with any
361:39 - updates to the items managed by the
361:40 - catalog service
361:42 - in the next lesson we will update
361:44 - inventory so that it starts taking
361:46 - advantage of this new capability anytime
361:49 - it needs to present data that is
361:50 - partially coming from catalog
361:54 - now that our inventory microservice has
361:56 - its own copy of the catalog items it no
361:59 - longer needs to query the catalog
362:00 - microservice to gather additional
362:02 - information about the items of inventory
362:05 - so let's update our inventory controller
362:07 - to take advantage of its new catalog
362:08 - items collection
362:10 - so here we are back in our inventory
362:12 - project and i'll go ahead and open our
362:14 - controllers folder and i'll go to items
362:16 - controller
362:17 - let's collapse the navigation pane to
362:19 - get more space
362:20 - and let me scroll down a little bit
362:23 - and the first thing that we will do is
362:25 - to get rid of our catalog client
362:28 - because we will no longer need to invoke
362:30 - catalog client i mean the catalog
362:32 - service anymore instead of that we're
362:34 - going to declare another variable here
362:38 - is going to be just another i repository
362:40 - but in this case it's going to be off
362:43 - catalog item
362:46 - so this is going to be our
362:48 - catalog items
362:50 - repository and since we're introducing
362:52 - this new repository let's also rename
362:54 - the previous one so that it better
362:56 - resembles its purpose so this is going
362:58 - to be our
362:59 - inventory items repository
363:02 - let's also rename this
363:04 - the variables in constructor so this
363:06 - items repository becomes inventory as a
363:08 - repository
363:09 - and then the it's time to inject also
363:12 - our new catalog items repository as
363:14 - opposed to the catalog client
363:17 - here we will capture that
363:22 - so with that let's go down into our get
363:24 - async method
363:27 - and here's what we're going to do
363:29 - the first thing is that we definitely
363:30 - don't need to cut to call catalog client
363:32 - anymore so we're going to get rid of
363:33 - this
363:34 - we still need to get the list of all the
363:37 - inventory item entities
363:39 - uh represent the items in the user's
363:41 - inventory so this this stays
363:44 - but after that what we want to get is a
363:47 - from our local catalog items collection
363:49 - we want to get all the corresponding a
363:52 - catalog items that i mean the ones that
363:53 - could respond to the inventory items on
363:55 - inventory the today's inventory so to
363:58 - get that let's first get all the list of
364:00 - all the catalog item ids
364:02 - that that are involved in the inventory
364:05 - items collection that we have here so to
364:08 - do that let's do this so
364:10 - item ids
364:13 - equals
364:15 - inventory item entities select
364:18 - let's do a little projection here
364:20 - where item
364:23 - item dot catalog item id this gives us
364:26 - the list of all the the catalog items
364:29 - that we have an inventory the ids
364:30 - specifically
364:32 - and with that we can go ahead and
364:35 - get the actual catalog items so let's do
364:38 - catalog item entities
364:42 - is weight catalog items repository
364:47 - get all they sync
364:49 - where item
364:51 - and what we're going to say is that we
364:52 - want to get all the items that are in
364:54 - the item ids collection so i'm going to
364:56 - say
364:57 - item ids
364:59 - contains
365:01 - item dot id
365:05 - so now here we have all the catalog
365:07 - items that match the
365:10 - the items that we have an inventory for
365:12 - this current for the current user
365:14 - having that we can go ahead and
365:16 - update this little function here so they
365:18 - take advantages of this new items
365:21 - collection and i'll say catalog item
365:23 - entities is going to go here so now we
365:26 - can go ahead and say okay so as we go
365:28 - through all the inventory items
365:31 - first we're going to look at the catalog
365:33 - item entities and we're going to find
365:34 - the catalog item whose id matches the
365:38 - id of the catalog item id of the
365:40 - inventory that we're looking at so
365:42 - that's a catalog item
365:44 - and then we'll keep moving forward as
365:45 - usual and we say okay so now that we've
365:47 - found the inventory item and now that we
365:49 - have the catalog item let's go ahead and
365:51 - turn it into dto adding the catalog item
365:54 - name and the catalog item description
365:56 - okay
365:57 - so i don't think we need to make more
365:58 - changes to pause async
366:02 - so we should be ready to start using
366:05 - this so i'll save this
366:07 - i'll go back to catalog
366:09 - i'll just going to hit f5 to start the
366:11 - service
366:14 - and i'll go back to inventory and i'll
366:17 - do the same f5 to start the service
366:24 - and now let's go ahead and go back to
366:26 - postman and let's grant one item to a uh
366:30 - to our user
366:31 - so the first thing that we'll do is
366:33 - actually get the list of current items
366:35 - in our catalog to know what to grant so
366:38 - i'll just open our get operation in the
366:40 - catalog service and i'll hit send
366:44 - here we are
366:46 - we have currently a portion and an
366:48 - antidote so let's say we want to do the
366:50 - potion
366:51 - so i'll copy the id of the potion
366:54 - and now let's go to the
366:57 - to the inventory collection let's expand
366:59 - this and i'll go to our post operation
367:01 - where we can assign
367:03 - a assigned one item
367:05 - to a user so i go to body
367:09 - i'll paste the catalog item id that we
367:11 - just copied over here so this is the
367:12 - item to assign and then just like before
367:15 - we need a user id
367:17 - so and just as we did before let's use
367:19 - the postman function go it to generate a
367:22 - random user id
367:24 - and finally let's get some quantity
367:26 - let's say we're going to assign one
367:28 - portion to this user
367:30 - okay and so with that i'll go ahead and
367:32 - pause that sent
367:34 - and it's done and if it worked now our
367:36 - user should have one potion right so
367:39 - i'll go ahead and first we need to
367:40 - figure out what's the idea of the user
367:42 - that was generated and we can do that
367:44 - from the console so i'll click on the
367:45 - console
367:47 - and i'll go down to our post operation
367:50 - request body and it's right here this is
367:52 - a user id that was generated i'll copy
367:54 - that
367:55 - close console and then we can go
367:58 - to our get operation
368:00 - to get all the users in the
368:02 - sorry all the items in the user's
368:04 - inventory and so we'll get
368:06 - the items for this user
368:08 - i'll hit send
368:11 - and as you can see now we can see that
368:13 - this user a has a potion has one potion
368:16 - but more instruments interestingly it is
368:18 - able to show the name and the
368:20 - description of the potion from the local
368:23 - catalog items collection so it no longer
368:26 - needed to go ahead and and talk to the
368:28 - catalomic service to retrieve decision
368:30 - information so things are much more
368:32 - resilient and rely and faster now
368:34 - because we don't need to go out and ask
368:36 - for this additional info
368:38 - now what would happen if we go ahead and
368:40 - update the description of this catalog
368:42 - item in the catalog microservice how
368:44 - would that look like here
368:46 - let's try that out so first i'll go to
368:48 - back to our get items
368:50 - results and i'll copy a few details
368:53 - about the potion i'll just copy that and
368:56 - then i'll go to the catalog collection
368:58 - and i'll go to the put operation
369:00 - here's where we can make updates to our
369:02 - item so i'll just come here
369:05 - paste that
369:07 - fix
369:08 - indentation and let's say that instead
369:11 - of having this description
369:13 - it just says restores some hp
369:16 - that's going to be the new description
369:19 - also the id of this item is this one
369:21 - here so let me grab it
369:23 - go back to put i'll paste that here
369:26 - and so let's go ahead and update this
369:28 - item in the catalog microservice so i'll
369:31 - go ahead and do that
369:33 - and then i'll go back to our query for
369:36 - the inventory items of the user and
369:38 - let's see what happens with the
369:39 - description of this of this item so i'll
369:41 - hit send
369:43 - and as you can see the description is
369:45 - already updated and this is because as
369:47 - soon as we updated the item in the in
369:49 - catalog my service
369:51 - a message was published into habit mq
369:54 - and then our inventory service grabbed
369:55 - that update into its local database and
369:58 - is ready to present the updated
369:59 - description
370:00 - as we query for items
370:02 - so this is great but now what would
370:04 - happen if our catalog microservices is
370:07 - having issues actually what happens if
370:09 - it's completely down right so it has a
370:11 - major problem
370:13 - what would happen with it with inventory
370:14 - maker service can it still keep working
370:16 - just fine
370:17 - let's see i'll go back to catalog
370:20 - here's catalog i'm just going to stop
370:22 - the service so service is completely
370:24 - down
370:25 - and in fact if we go back to
370:27 - a postman and we try to get items again
370:30 - let's see what happens
370:34 - connection refused because the service
370:36 - is completely down but then let's try to
370:38 - get all the items on the user's
370:40 - inventory
370:41 - so i'll hit send
370:45 - and still works
370:47 - even more i can try granting yet another
370:50 - item to the user's inventory
370:52 - so just to test this out i'm going to
370:54 - start catalog once again
370:57 - hit a 5
370:59 - back to postman let's go ahead and get
371:01 - the list of items and now i'm going to
371:03 - grind and grant the antidote to that
371:05 - same user
371:06 - let's do antidote
371:08 - into the post operation
371:11 - body so let's grab the antidote
371:15 - let's make sure we use the same user id
371:18 - it's right here
371:22 - maybe it's ready
371:24 - and then again like i said catalog is
371:26 - having problems i'll just stop it it's
371:28 - completely down it's not working
371:31 - yet i'm going to go ahead and grab that
371:32 - item to the user
371:34 - i hit send
371:35 - 200 okay so it looks like it was
371:37 - successful and then let's get all the
371:39 - items inventory now so i'll hit send
371:41 - again
371:42 - over here and as you can see we can
371:44 - query for the for all the items and all
371:46 - the items are showing name and
371:48 - description regardless of the fact that
371:50 - the catalog microservice is completely
371:52 - down
371:53 - so this is the power of asynchronous
371:55 - communication and this is how you enable
371:58 - very resilient communication between
371:59 - microservices
372:01 - both services are now really autonomous
372:03 - because they don't rely on each other to
372:05 - be available at any given time
372:08 - one more thing to consider is a case
372:10 - where one of our consumers is not able
372:12 - to consume the message properly perhaps
372:15 - due to some issue when trying to talk to
372:16 - its local database
372:19 - so for instance let's go to
372:21 - our inventory
372:23 - inventory service over here
372:25 - and i'm going to stop this for now and
372:27 - close terminal
372:29 - and i'll go here
372:31 - into our consumers let's say cattle
372:33 - guide and create consumer and
372:35 - what would happen
372:37 - if this line here is having trouble
372:39 - right so when we when we go into the
372:41 - consumer uh this this all this logic
372:43 - happens because we're consuming the
372:44 - message but if we fail if an exception
372:47 - is thrown in this in this case and the
372:48 - message is going to be sent into some
372:50 - error queue and if you would not be able
372:52 - to consume it anymore so at that point
372:54 - you missed an update from the from the
372:56 - catalog mic service
372:58 - so is there a good way to handle this so
373:00 - there's to be that yeah there's a
373:01 - there's a way to do that so if you go
373:03 - back to our
373:05 - to our common library so here we are
373:07 - back in common library
373:08 - and we're i'm going to go to the mass
373:10 - transit extension that we created before
373:12 - and scroll down a bit
373:14 - and what we can do is to enable analysis
373:17 - we can do is enable message retries
373:20 - for the consumption of the messages so
373:23 - you can go here and say
373:25 - configurator
373:27 - that use message
373:30 - message retry
373:32 - and then here we're going to define our
373:34 - retry configurator
373:38 - okay let's open this section
373:45 - and then you can say retry configurator
373:48 - that interval
373:52 - and then the first item the first
373:54 - parameter you're going to specify is how
373:56 - many times you want to retry so anytime
373:57 - the the consumer is not able to consume
374:00 - the message how many times you want to
374:01 - retry that consumption so let's say we
374:03 - want to say 3
374:06 - and then you have to define the time
374:07 - span
374:09 - or our time between retries let's say
374:11 - that's going to be
374:14 - time span
374:18 - let's import missing space
374:22 - from seconds
374:24 - and that's going to be five
374:27 - five seconds
374:28 - let's also import another missing space
374:30 - we need to use using green pipes here
374:34 - and that's all it is so with that logic
374:36 - any time a message is is not able to be
374:38 - consumed by the consumer it will predict
374:40 - right three times
374:42 - and with a five seconds delay
374:44 - in there and there's a bunch of
374:46 - different ways to configure this
374:47 - depending on how you want to do your
374:48 - retries
374:49 - and with that let's just save extensions
374:52 - and then if you wanted to consume this
374:53 - in your microservices as usual you will
374:55 - go ahead and generate another version of
374:57 - the nugget package so in this case it
374:59 - would be
375:02 - it would just do dot net back
375:06 - it would be
375:08 - package version
375:10 - let's say in this case would be one zero
375:12 - two and then we send it to the same
375:15 - location fe4
375:19 - packages
375:23 - package generated
375:25 - and then you would just go back to
375:27 - catalog
375:30 - and update its version
375:32 - over here to play.com102
375:35 - save
375:37 - restore dependencies
375:39 - and then we would go back to
375:41 - inventory and do the same thing
375:43 - 102
375:45 - save
375:46 - and then we'll not exercise this really
375:48 - in this lesson and restore but that's
375:50 - how you do it so from here on both
375:51 - microservices has this capability to
375:54 - retry the consumption of the messages
375:57 - so that marks the end of this lesson and
375:59 - of this model
376:00 - you now have two independent and
376:02 - resilient microservices that can
376:04 - collaborate asynchronously to manage a
376:06 - catalog of items and to grant and query
376:08 - for items in a user's inventory pack
376:11 - you also have a reusable common library
376:14 - that any of your mute future
376:15 - microservices can take advantage of and
376:17 - that you can keep improving according to
376:19 - your needs
376:22 - in this model you will connect the
376:24 - provided front-end project to your
376:26 - microservices to enable basic end-to-end
376:29 - scenarios from a modern single page
376:30 - application
376:33 - by the end of this model you will have a
376:35 - solid understanding of the following
376:38 - how to get and build the front-end
376:40 - project in your box
376:43 - how to host the front-end project in a
376:45 - node.js server
376:48 - what is the structure of the react-based
376:50 - front-end
376:52 - what is course and how to configure it
376:54 - in your microservices
376:56 - and how to debug the communication
376:58 - between the front-end and your
376:59 - microservices
377:03 - in this lesson you will install node.js
377:05 - which is a javascript runtime that will
377:08 - host the front-end portal and that also
377:10 - includes npm the package manager that
377:12 - provides all the dependencies required
377:14 - by the portal
377:16 - the only additional tool required to
377:19 - build and launch the front-end portal is
377:21 - node.js
377:22 - which you can get in the nodejs.org
377:25 - website
377:27 - let's see how to install node.js and
377:29 - verify the installation afterwards
377:33 - before installing node.js just keep in
377:35 - mind that the pages that you will see
377:36 - next will likely look a bit different
377:38 - depending on your operating system and
377:40 - the versions available at the time that
377:42 - you're taking this course
377:44 - but regardless the overall download and
377:46 - installation process should be mostly
377:47 - the same
377:49 - so let's now browse to the node.js
377:51 - website
377:53 - and here the first thing that you're
377:55 - going to see is a right away a few
377:57 - download buttons for your current
377:59 - operating system version and
378:00 - architecture in my case that will be for
378:02 - windows 10 x64 these are the two
378:05 - versions the one on the left is the most
378:08 - stable version available and the one on
378:10 - the right is the latest version
378:12 - available which may not be
378:14 - the most stable one but it has the
378:15 - latest features
378:17 - i would recommend going for the most
378:19 - stable version the lts version since
378:21 - that's a recommended one for most users
378:24 - now if the version that you would like
378:25 - to download is not here you can always
378:27 - go to the other downloads link over here
378:30 - and here you can pick
378:32 - the right version for your operating
378:33 - system and you also have a few other
378:36 - download options
378:37 - now in my case i'm going to go back to
378:39 - the
378:40 - first page and i'm going to download
378:42 - 14170 lts so just click there
378:47 - and i'll go ahead and start installer so
378:49 - click here
378:52 - here's installer
378:54 - so i'll just click next
378:56 - accept next
378:58 - next and next
379:01 - and at least for this course i have not
379:03 - seen the need to install any additional
379:06 - tools here so i'll just click next
379:08 - and install to get installation started
379:13 - say yes
379:17 - and so with that node.js is installed in
379:19 - the box so click finish
379:21 - and what we want to do now is to verify
379:23 - that the installation has completed
379:25 - properly
379:26 - so what i'll do is i'll just close the
379:28 - browser now
379:29 - and i'll open my visual studio code
379:32 - instance here
379:34 - and here in business to the code what
379:36 - i'll do is i'll open my terminal by
379:38 - pressing ctrl j
379:41 - and i'll just type a couple of commands
379:42 - to verify that the tools are installed
379:44 - properly so i'll just type
379:46 - node
379:47 - v to get the version of node.js
379:50 - which you can see right there
379:51 - 14
379:53 - 17 0
379:55 - and and now also verify the version of
379:57 - npm which is the package manager that
379:59 - comes with node.js so i'll do mpm-v
380:03 - and i can see the version right there
380:05 - also
380:08 - so with this we know that node.js has
380:09 - been properly installed and we're ready
380:11 - to move on
380:13 - in this lesson you will explore the
380:15 - structure of the front-end code base how
380:18 - to install its dependencies and how to
380:20 - build and run the portal
380:23 - before exploring the front end code base
380:26 - let me give you a few details about it
380:29 - the front end is a simple single page
380:31 - application that demonstrates one way to
380:34 - interact with all the play economy
380:35 - microservices
380:37 - a single page application is a web
380:39 - application that dynamically rewrites
380:41 - the current web page with new data from
380:43 - a server instead of constantly loading
380:45 - new pages
380:47 - it is built using react which is a
380:50 - javascript library for building
380:52 - interactive user interfaces
380:54 - i chose react because at the time of
380:56 - creating the course it was one of the
380:58 - most popular front-end frameworks and is
381:01 - easy to learn assuming that you have
381:03 - worked with javascript before
381:06 - it uses create react app to simplify how
381:09 - you do local development how you build
381:12 - and debug the code in your box
381:14 - and how you package everything in
381:15 - preparation for deployment
381:18 - finally it is hosted in a node.js server
381:21 - a very popular runtime for javascript
381:23 - applications
381:26 - there are a few things that i'd like you
381:28 - to keep in mind as you work with the
381:30 - provided front-end portal in these and
381:32 - the next lessons
381:34 - this is not a course about front-end
381:36 - development and certainly not about
381:38 - react
381:39 - as a back-end developer myself i only
381:42 - know enough react to build this simple
381:44 - portal
381:45 - however
381:46 - i'm probably making lots of beginner
381:48 - mistakes and i'm probably not following
381:50 - client-side best practices in many
381:51 - places so please don't use this code as
381:54 - a template for the production level
381:56 - application but more as a basic example
381:59 - of one way you could interact with the
382:01 - microservices from a modern client
382:04 - you won't be coding this front end in
382:06 - this course
382:07 - there is both not enough time and i'm
382:09 - not qualified to teach you how to build
382:11 - a front end step by step instead i'm
382:14 - providing you the finished portal so you
382:16 - can use it as is
382:18 - it should work with no issues and no
382:20 - changes required
382:22 - provided that you make a small update to
382:24 - the microservices as i'll explain in the
382:26 - next lesson
382:28 - in this lesson i'll give you a quick
382:30 - overview of the structure of the
382:31 - front-end codebase with a focus on the
382:33 - areas that interact with your
382:35 - microservices as opposed to the many
382:37 - components that handle layout rendering
382:39 - and many other things
382:42 - finally please check out the links below
382:44 - if you would like to know more about the
382:45 - deck used in the front end project
382:49 - so here i am in a new bezel studio code
382:51 - instance and i have already opened my
382:54 - terminal into the projects directory
382:56 - where i have all my files
382:58 - and as you can see i have already
383:00 - downloaded and extracted the front-end
383:02 - project files into this directory play
383:04 - that front-end
383:06 - and what i'm going to do now is just
383:08 - switch to that directory
383:12 - and i'm going to open this instance of
383:13 - code into that directory by doing
383:16 - code that in dash r to reuse the window
383:19 - enter
383:22 - and here you can see the structure of
383:24 - the project files on the left side
383:27 - and what i'm going to do is first close
383:29 - this terminal for a moment i'd like to
383:30 - point you to the readme.md file so this
383:34 - is a file that will give you a
383:36 - description of
383:37 - what this project is about and a few
383:39 - other things and in fact what you can do
383:41 - is just open this uh preview window
383:45 - with this button
383:46 - that opens up review on the right side
383:47 - and close the original one so this gives
383:50 - you a nice view of
383:51 - the redmi file
383:54 - so as you can see this is crafty project
383:56 - it is creative prerequisites of the
383:58 - project
383:59 - and then it tells you how to
384:02 - build the project how to run it locally
384:05 - and also
384:07 - it provides a bunch of other scripts
384:10 - that are also available
384:11 - now
384:13 - what we're going to do is to actually
384:15 - follow
384:16 - this couple of first lines in this in
384:18 - this file to get started with the front
384:20 - end so as it says what you can do to
384:22 - install a all the dependencies of this a
384:26 - front end is a run just npm install
384:31 - so open my terminal once again
384:34 - here scroll down a bit and what you want
384:37 - to type just at the root of this project
384:39 - is npm install
384:41 - hit enter
384:42 - what this is going to do is to bring in
384:45 - a bunch of node models
384:47 - that represent all the dependencies
384:50 - that
384:51 - this this portal depends on
384:53 - including react bootstrap and a bunch of
384:56 - other things this is going to take a
384:58 - while depending on your internet speed
384:59 - because there's a lot of stuff that
385:00 - needs to get downloaded so just give it
385:02 - a moment
385:08 - okay so the dependencies have been
385:10 - installed and as you can see there's now
385:12 - a node models folder on the left side
385:14 - if you expand it you're going to find a
385:16 - bunch of directories have been created
385:22 - right
385:22 - so
385:24 - now that we have that we are ready to
385:25 - run the portal so to do that if you
385:28 - scroll down in the readme you can see
385:29 - that you can just do npm start and
385:31 - that's what i'm going to do here
385:32 - npm
385:34 - start
385:35 - enter
385:37 - so this is going to
385:40 - compile the entire code
385:42 - base and then it's going to start the
385:46 - node.js
385:48 - host
385:49 - okay so it compiles successfully and as
385:51 - you can see we get an address here to
385:53 - browse locally to it
385:55 - so i'm going to copy this address
385:58 - localhost 3000
386:00 - and i'm going to go to my browser i'm
386:02 - going to paste that there and hit enter
386:05 - and there it is
386:06 - the portal is up and running in this box
386:09 - now in the home page here what we have
386:11 - is just a few basic things like the
386:13 - description of the project
386:15 - and then a couple of links uh both to go
386:18 - to the catalog section uh to get the
386:20 - list of the catalog items
386:22 - and the inventory section so that you
386:24 - can
386:26 - inspect which are the items that are in
386:28 - inventory back of a user
386:30 - notice that we also have a navigation
386:32 - bar at the top that takes you either to
386:34 - the home or to the catalog and inventory
386:36 - sections
386:37 - there's also links here to go to the
386:40 - rabbitmq portal if you wanted to to
386:42 - explore what's going on with the queues
386:44 - and there's also links here to explore
386:47 - the swagger
386:48 - soccer ui open api documentation for
386:51 - both catalog and inventory service
386:53 - and also a few other things
386:55 - general links to
386:57 - the different technologies that were
386:58 - used to create the whole the whole
387:01 - system
387:02 - now before we go and dive into the
387:04 - catalog and inventory sections which are
387:06 - of course the most important uh parts of
387:08 - this portal at this point uh let's go
387:10 - back to pieces to the code for a moment
387:13 - and let's explore briefly the files that
387:15 - are available here just so that you get
387:17 - an idea of how this project is
387:19 - structured
387:20 - so what i'm going to do is just close
387:22 - this terminal for now and close the
387:23 - readme
387:25 - and the first file that i'm going to
387:26 - show you is package.json this one here
387:29 - describes all dependencies of this
387:32 - project which are all the node models
387:33 - that are installed by now and like i
387:35 - said these include things like react
387:38 - being used for all the components
387:40 - interactive and dynamic components use
387:42 - it across the portal
387:44 - bootstrap for layout
387:45 - and a bunch of things for being able to
387:48 - do routes in the client side
387:51 - the react scripts uh which are the ones
387:53 - that we can use to start the portal
387:55 - and a few other things
387:59 - and uh and yeah many other dependencies
388:02 - now let me close this
388:04 - and then
388:05 - uh take a look at the public folder here
388:09 - this one is the one that defines
388:11 - index.html which is what we call the
388:14 - the page template so in a single page
388:17 - application like i think i mentioned
388:18 - before
388:19 - there's not really a navigation into
388:21 - different pages of a portal there's no
388:23 - reload of pages there's just one page in
388:26 - this case in the html
388:28 - where every
388:30 - all of these
388:31 - dynamic components are loaded and
388:33 - refreshed constantly
388:35 - and in fact uh in this section here in
388:38 - this div root here is where all the
388:41 - javascript files uh javascript content
388:44 - is injected with all the react
388:47 - components
388:49 - now this file also references config.js
388:51 - which happens to be over here and this
388:54 - is a file
388:55 - where if you're asking where is the
388:57 - addresses of all the microservices this
388:59 - is the file so this is where you're
389:01 - going to see the address of the catalog
389:02 - service and the others of the inventory
389:04 - microservice right there
389:06 - as well as the address of the having
389:08 - queue portal and a few other derived
389:10 - address addresses for the items apis in
389:13 - catalog and inventory
389:15 - now the most important directory
389:16 - actually here is the search directory
389:20 - because this is the one that contains
389:22 - all the react components so this is
389:24 - pretty much
389:25 - is the heart
389:26 - of the of the project this is where the
389:28 - system logic
389:30 - happens
389:31 - and in this file if you go to in the gs
389:34 - this is where this is the
389:36 - the route where we start rendering a
389:39 - react components and we are asking it to
389:41 - start rendering them in the a root div
389:44 - that we just saw in in the in the html
389:47 - this one here we saw that there's a root
389:49 - div and that root div is where index.js
389:53 - will get rendered as you can see right
389:54 - here
389:56 - and so the first react component that we
389:58 - actually start rendering is this app
389:59 - component over here which is coming from
390:02 - app.js
390:04 - this app component defines our app by
390:07 - using uh first the layout component
390:10 - which is in charge of rendering the
390:12 - basic layout
390:13 - of the system as you can see
390:15 - over here if you expand components
390:17 - layout js this is one that defines the
390:19 - navigation menu at the top the container
390:22 - for all the other components in the
390:23 - middle and then the footer at the bottom
390:29 - back to app.js
390:30 - as you can see we have layout and layout
390:32 - defines that inside of layout we're
390:33 - going to have a component
390:35 - for the home
390:36 - a component for the catalog and a
390:38 - component for inventory
390:41 - so then if it goes just go into the
390:42 - components directory we have our catalog
390:46 - file and this is the one where you can
390:48 - start really seeing interesting things
390:50 - because
390:52 - this file allows you to communicate to
390:55 - the catalog microservice
390:58 - if you go down into the populate items
391:00 - method over here you can see that here
391:03 - is where we are actually talking to the
391:05 - academic service and then we're
391:07 - getting a response from it and that's
391:09 - that's the one that we are uh
391:11 - collecting and setting it into the
391:13 - client-side state that later on if you
391:16 - see at the bottom
391:17 - it's been rendered
391:20 - as a list
391:21 - as a table in the into the page
391:26 - okay and it's the same idea with the
391:28 - inventory.js which is able to render the
391:30 - items inventory back of a user
391:33 - we also have a few form well model files
391:36 - and form files like guiding model which
391:38 - is the one that is used to render the
391:40 - model
391:40 - a model dialog
391:42 - so you can go ahead and either create or
391:45 - update an item in the item form which is
391:47 - the one that actually shows the form
391:49 - inside that model
391:51 - and the same way we have a model for
391:53 - granting items for a for a user so that
391:56 - it can go into his inventory back so a
391:58 - model and a form for that same purpose
392:02 - and lastly we have the that vs code
392:04 - folder
392:05 - which you should be very familiar but
392:08 - with
392:08 - at this point where we also have a
392:11 - launch.json file
392:13 - where we define a defining
392:15 - configurations that you can use to start
392:17 - debugging
392:18 - either the server side or the client
392:20 - side of this portal so you can see we
392:23 - have a configuration for the server we
392:24 - have named it server
392:27 - this is going to be the one that can
392:28 - launch the npm server
392:31 - or the nodejs server
392:33 - and one configuration for launching the
392:35 - client at the location of the client in
392:37 - the browser
392:38 - there's also a compound configuration
392:40 - which i named server and client server
392:42 - client that can can be used to launch
392:45 - both the server and the client at the
392:47 - same time in your local box
392:49 - okay so i'll just close this so now
392:51 - let's go ahead and try that catalog
392:53 - section so i'm going to open the
392:55 - terminal once again here
392:57 - so our front end is still running
393:00 - but what we may not be running right now
393:02 - is a catalog service so let me go back
393:04 - to catalog
393:05 - here's my a catalog code base so i'll
393:08 - just switch to src
393:10 - play that catalog service and then i'll
393:13 - do
393:14 - dotnet run
393:18 - so catalog is now up and running
393:20 - so let's go back to
393:22 - the portal the browser
393:25 - and in order to see the list of catering
393:27 - items what you can do is either click in
393:30 - catalog in the navigation bar over there
393:32 - or you can click in this catalog link
393:34 - right here and i'll click on it
393:36 - and uh this should display the list of
393:39 - categorical guidance but as you can see
393:40 - that is not working right now so we
393:42 - cannot load the items so there is some
393:44 - problem happening here
393:46 - and so
393:47 - the client side
393:48 - one way that you can tell what's going
393:50 - on is by using the
393:53 - the browser developer tools which
393:55 - usually you can you can go to by
393:56 - pressing the f12 key which i'm going to
393:58 - do now f12
394:01 - and this opens the developer tools
394:04 - section now on this one there's a bunch
394:06 - of tabs but the one that you're
394:07 - interested in is in the console tab so
394:10 - click on console and this is going to
394:12 - show you what's going on so as you can
394:14 - see there's an error access to fetch at
394:16 - https alcohol 5001 items which is the
394:19 - address of the cataloging service
394:21 - from the origin http localhost 2000
394:23 - which is the address of this
394:26 - of the front end
394:28 - has been blocked by course
394:30 - the course policy so no access control
394:33 - origin heater is present in the resident
394:34 - resource
394:35 - so what is this course thing about
394:39 - that is going to be actually the focus
394:40 - of the next the next lesson
394:43 - so in the next lesson we will learn
394:45 - about cross-origin resource sharing also
394:47 - known as course
394:49 - and how it can help us enable the
394:50 - communication between the front end and
394:52 - our microservices
394:55 - in this lesson you will learn about
394:58 - cross-origin resource sharing
395:00 - also known as course
395:02 - what problem it solves and how it can
395:04 - help us enable the communication between
395:06 - our front-end portal and our mac
395:08 - services
395:10 - to understand course let's first
395:12 - understand what a close origin request
395:13 - is
395:14 - let's put our catalog microservice to
395:16 - the site for a moment and let's imagine
395:18 - that the node.js web server that is
395:21 - hosting our frontend is also the server
395:23 - that hosts the res apis to interact with
395:25 - the database that owns the catalog
395:27 - data
395:28 - in this scenario the browser initially
395:30 - navigates to the web server url to load
395:33 - the front end home page
395:35 - and then when the catalog section is
395:36 - requested the browser makes a get
395:39 - request to the catalog rest api
395:41 - to the same web server url
395:43 - to which the server will reply with the
395:45 - json representation of the catalog data
395:48 - the address from which the browser calls
395:50 - res api is known as the origin
395:52 - and is made of the combination of
395:54 - protocol host and port
395:57 - which in this case is http localhost it
395:59 - doesn't
396:00 - notice how the origin in the browser
396:03 - matches exactly the origin of the server
396:05 - that provides rest api
396:08 - let's now go back to our actual scenario
396:10 - where our catalog microservice hosted in
396:12 - asp.net course kestrel web server is the
396:15 - one providing the res api
396:17 - now when the catalog section is
396:19 - requested in the browser
396:21 - the browser makes a get request to the
396:23 - rest api at the origin of the catalog
396:25 - microservice which is https localhost
396:27 - 5001.
396:29 - since both the protocol and port of the
396:31 - catalog service are different
396:34 - than the one in the browser this is
396:36 - known as a cross-origin request
396:39 - the microservice will return the catalog
396:40 - data just as before
396:43 - but by now the browser knows that this
396:45 - response comes from a different origin
396:48 - since it had set the origin header in
396:50 - the request
396:51 - therefore it rejects a response data
396:54 - with a course error
396:56 - this happens because browsers follow
396:58 - what is known as the same origin policy
397:01 - which states that a web application can
397:04 - only request resources from the same
397:06 - origin the application was loaded from
397:09 - browsers and forces to prevent malicious
397:11 - websites from reading confidential
397:13 - information from other websites
397:16 - unfortunately this is also preventing
397:18 - our front end from reaching the catalog
397:20 - microservice
397:22 - so how can we fix this
397:26 - here's where course comes into place
397:28 - course allows a server to indicate any
397:31 - other origins than its own from which a
397:33 - browser should permit loading of
397:35 - resources
397:37 - here's how it works
397:39 - once again the browser has loaded the
397:41 - front-end page
397:43 - now the catalog section is requested and
397:46 - a get request is sent to the catalog
397:47 - microservice
397:48 - and since catalog is hosted in a
397:50 - different origin the browser appends the
397:52 - origin header
397:54 - the difference this time is that the
397:56 - catalog microservice has been configured
397:58 - with the access control allow origin
398:00 - heater
398:01 - which indicates all the other origins
398:04 - that are allowed to call the res api
398:07 - in this case this header has been
398:09 - configured with the origin where the
398:11 - front end is hosted http localhost 3000.
398:15 - once catalog sends the item's data back
398:17 - to the browser it appends this header to
398:20 - the response
398:21 - the browser now compares the value in
398:23 - the orient header it sent to the value
398:26 - in the received access control allow
398:27 - origin heater
398:29 - since they match the browser now allows
398:31 - the response data to reach the front end
398:34 - this works for simple requests like gets
398:38 - but for post put and other methods
398:40 - things work a bit differently
398:44 - when a cross origin request may perform
398:46 - some sort of write operation on the
398:48 - resources owned by the server
398:50 - like is the case when performing a post
398:52 - put or delete request
398:54 - the request needs to be first
398:55 - preflighted
398:58 - this means that an additional initial
399:00 - request needs to be sent to the server
399:02 - to determine if the actual request is
399:04 - safe to send
399:06 - going back to our scenario imagine we
399:08 - now want to create a new item in the
399:10 - catalog and therefore our front end will
399:12 - send a post request to the res api
399:15 - however since this is a post of json
399:18 - data across origins the browser
399:20 - automatically sends first a request with
399:23 - the options method
399:24 - this time not just adding the origin
399:26 - header but also two other headers called
399:29 - access control request headers and
399:31 - access control request method
399:33 - access control request method indicates
399:36 - that when the actual request is sent it
399:38 - will be a post
399:40 - and access control request headers tells
399:42 - the server that the request will come
399:44 - with a content type heater in this case
399:47 - the server should have been configured
399:49 - to respond with corresponding headers to
399:51 - indicate what it allows
399:53 - the headers returned by the server are
399:55 - access control allow origin access
399:58 - control allow heaters and access control
400:00 - allow methods
400:02 - if the values returned in these heaters
400:05 - match the values in the heaters sent in
400:07 - the request
400:08 - the browser accepts the post request and
400:11 - submits this original request to the
400:13 - server with the json payload of the new
400:15 - item to create
400:17 - the catalog microservice creates the
400:19 - item and returns expected 201 status
400:21 - code
400:23 - as you can see the key to a successful
400:26 - cross-origin request is in the
400:28 - appropriate course configuration on the
400:30 - microservice that exposes the rest api
400:33 - since only the microservice can declare
400:35 - the allowed origins
400:37 - but how do we properly configure cores
400:39 - in atheism net core
400:42 - that's the focus of the next lesson
400:44 - where we will add the missing course
400:45 - configuration to both the catalog and
400:47 - inventory microservices
400:51 - let's now fix the course related errors
400:53 - we are getting in the browser by
400:54 - configuring the course middleware in the
400:57 - request pipeline of our microservices
400:59 - and let's start with the catalogue
401:01 - service so i have the catalog codebase
401:03 - open here in visual studio code
401:05 - and what i'm going to do is open app
401:07 - settings the development.json first
401:10 - here i'm going to declare the ordering
401:12 - of the frontend so that we can properly
401:14 - configure it in startup later
401:17 - i'm using app settings the
401:18 - development.json and not absence.json
401:21 - because the origin of the front end is
401:23 - just a development server at this point
401:25 - and we will not need a course policy for
401:27 - that origin in production
401:30 - so what i'll do is i'll just open
401:31 - another section here
401:34 - this is just going to say
401:39 - allowed origin
401:41 - and that's going to be the address of
401:44 - our front end so this http
401:47 - localhost 3000.
401:50 - now that we have that let's go into our
401:53 - startup file and here's where i'm going
401:55 - to collapse the explorer for a moment
401:58 - let's scroll down a bit
402:00 - and what i'm going to do is define first
402:02 - a constant to represent the name of that
402:05 - setting that we just created
402:07 - so this is going to be
402:09 - private constraint
402:14 - load origin
402:16 - setting is going to be
402:19 - the name that we just created over here
402:21 - i'm going to copy it aloud origin
402:24 - right there
402:26 - and now that we have that we can
402:27 - actually configure course so to
402:29 - configure course what you want to do is
402:31 - go down into the
402:33 - configure method
402:34 - which is where you configure the request
402:37 - processing pipeline
402:38 - and so like i said this is mostly for
402:40 - development scenario at this point
402:42 - because the front end is a development
402:44 - web server so what i'm going to do is
402:45 - take advantage of this m.easy
402:47 - development section which only happens
402:49 - with the 40 minute scenarios and i'm
402:51 - going to add another piece over here
402:53 - so i'm going to say
402:55 - app.use course
402:58 - and here we're going to provide the
402:59 - function
403:00 - that configures the course configuration
403:02 - so i'll do
403:06 - builder
403:08 - and i'll do this
403:13 - and then we're going to say builder dot
403:18 - with origins
403:20 - and here we're going to specify that
403:22 - that origin which at this point comes
403:24 - from the configuration data so it's
403:26 - going to be
403:27 - configuration
403:29 - and here we're going to pick the right
403:31 - key from the configuration which in this
403:33 - case is
403:35 - allowed origin setting
403:37 - so remember this that this configuration
403:39 - is the configuration object that has
403:41 - been declared here
403:42 - right here the configuration object
403:45 - which is populated automatically by the
403:47 - sp net core runtime so that
403:49 - configuration object contains all the
403:50 - data at this point of app settings that
403:53 - json and upsetting the development json
403:54 - included allowed origin setting
403:57 - so you can use this to just go ahead and
403:59 - get the key
404:01 - that corresponds to the allowed origin
404:04 - setting that we just declared so
404:05 - configuration
404:06 - and then allow origin settings
404:10 - that allows the origin
404:12 - but we also have to tell it which
404:13 - headers and which methods are allowed
404:15 - from the client side
404:18 - so to do that what i'm going to do is
404:19 - just say dot
404:22 - allow any heater to allow any of the
404:25 - heaters that the client wants to send
404:28 - and we will say
404:30 - allow any method
404:31 - to allow any of the methods used from
404:33 - the client side including get post put
404:36 - and all these other verbs
404:39 - okay so with that we have allowed the
404:41 - front end origin and we have set any
404:43 - here and any method should be allowed
404:46 - okay so with that we should be able to
404:48 - properly invoke the methods in the
404:50 - microservice from the client side so let
404:53 - me open up
404:54 - my terminal once again and i'll do
404:56 - netrun
405:00 - and then i'll go back to the browser
405:02 - where as you remember last time we did
405:04 - have this course error
405:06 - so now i'll just refresh the page
405:10 - and as you can see
405:11 - things are loading properly
405:14 - and in fact if we inspect briefly
405:17 - the network section here
405:19 - and we inspect the items request that we
405:21 - made right here
405:24 - you can see that the browser did send
405:27 - the origin
405:30 - heater in the request for localhost 3000
405:34 - and the catalog microservice
405:36 - responded
405:37 - with the access control allow origin
405:40 - heater over there which is why the
405:42 - browser allowed the response
405:45 - so that's how you configure cores
405:47 - and since we did this for the catalog
405:48 - mic service we should do the same thing
405:50 - for the inventory mic service
405:53 - so let me go back
405:54 - now to our inventory code base which is
405:57 - open here in this other business to the
405:58 - code instance and i'm going to do just
406:00 - pretty much the same thing that we just
406:01 - did
406:03 - so here in fact i'm going to copy a few
406:05 - sections here so from catalog
406:08 - i'm going to close the terminal for a
406:09 - moment i'm just going to copy this allow
406:12 - origin section
406:15 - into inventory
406:18 - cloud origin
406:20 - then back to catalog i'm going to copy
406:22 - the
406:24 - allowed origin
406:26 - setting from
406:28 - startup back into inventory in startup
406:32 - at the top i'm going to place
406:36 - that constant
406:38 - and then finally
406:39 - back to catalog
406:41 - into the configure section i'm going to
406:43 - copy the use course section here
406:47 - and back into inventory
406:49 - i'll collapse this for a moment
406:52 - in configure i'm going to add this
406:55 - right there
406:57 - okay so this enables the same a
406:59 - configuration for inventory as the one
407:00 - that we have in catalog
407:03 - so both microservices are properly
407:05 - configured now so
407:06 - in the next lesson we will explore in
407:08 - more detail all the scenarios enabled in
407:10 - the front end and how its react
407:13 - components are interacting with the
407:14 - microservices
407:17 - let's now explore in more detail all
407:19 - these scenarios enabled in the front end
407:21 - and how its different react components
407:23 - are interacting with the catalog and
407:25 - inventory mega services
407:27 - so i have stopped all the web servers at
407:29 - this point both for microservices and
407:32 - for the front end they're all stopped
407:33 - because i want to restart them in debug
407:35 - mode that way we can jump from client to
407:38 - server and see line by nine what's going
407:40 - on
407:41 - so here i am in the catalog of my
407:44 - service code base and i'm just going to
407:45 - go ahead and hit f5
407:48 - to start the web server and then i'll go
407:51 - to the inventory maker service called
407:52 - this code instance and i'll do the same
407:54 - thing
407:55 - f5
407:58 - okay and now i'll go to our front end
408:02 - and in this case instead of typing npm
408:04 - start from the terminal i'll take
408:06 - advantage of the debug configuration
408:09 - that we have set here so i'll go to the
408:12 - run on the box section
408:14 - on the activity pane there
408:16 - and as you can see we have a few options
408:18 - here we can debug either server client
408:20 - or server client server client is the
408:23 - one that i'm actually going to pick so
408:24 - that both
408:25 - the client and the server are started at
408:28 - the same time
408:29 - so i'll click there
408:31 - and this is going to bring up the
408:33 - browser right away
408:35 - however
408:36 - it may take a while to load while the
408:38 - server is compiling
408:40 - the source code and starting the node.js
408:42 - server
408:43 - if we head back here you can see that
408:46 - the server is getting started but it may
408:48 - take a while to start
408:52 - okay so as you can see the server has
408:54 - compiled the source code properly and it
408:56 - has started a debugging session of them
408:59 - on the front end in localhost 3000
409:02 - so now we can go back to the browser
409:06 - and here we can go ahead and navigate
409:08 - into the catalog section so i just click
409:09 - there and then things are loading
409:12 - properly
409:13 - but how is this communication from the
409:15 - client happening to the server side
409:17 - so to understand that what we can do is
409:18 - just head back to
409:20 - play the front end
409:22 - and what i'll do is i'll open
409:24 - my explorer on the left side and i'll
409:26 - collapse the terminal for a moment
409:28 - and then i'll go into src
409:30 - components catalog.js
409:33 - let's collapse that
409:35 - so here the communication happens in
409:38 - this populate items method over there
409:42 - first we call the fetch function where
409:44 - we talk to the url of the catalog items
409:47 - api so that total the catalog
409:49 - microservice and then we get a response
409:52 - back from it
409:55 - the response will tell us the status
409:56 - code if you wanted to inspect that but
409:58 - this is actually a promise in the in the
410:00 - javascript land is called the promise
410:02 - which means that we will have to invoke
410:04 - the json method to actually get the
410:06 - items in this other 10
410:08 - that we can then take and then uh put
410:11 - into what we call the state the state of
410:14 - the of this page
410:16 - and then that state
410:17 - is going to later be used into the
410:20 - in the render items table uh the items
410:23 - are going to be taken from the state
410:25 - into this method are received as items
410:28 - and then we will just render them in a
410:30 - normal
410:31 - html table
410:33 - so let me put a few breakpoints back
410:35 - into populate items
410:37 - so that we can see things as they go so
410:40 - i'll place this breakpoints over there
410:42 - and let's also go to the catalog
410:44 - microservice
410:45 - so that we can put a breakpoint on the
410:47 - server side so i'll collapse this and
410:49 - i'll go to items controller
410:51 - collapse that
410:53 - and then here we can go into the
410:56 - get async method put a breakpoint there
410:59 - so now let's go back to the browser and
411:02 - let's just refresh this page
411:06 - and sure enough here back into
411:09 - the front end we have hit the breakpoint
411:11 - and as you can see here's where we have
411:13 - the location of the catalog microservice
411:15 - in the items api
411:17 - so if i say continue
411:20 - that's going to talk immediately to the
411:21 - catalog microservice as you can see now
411:23 - we are in the catalog service
411:25 - let me collapse this a bit
411:27 - and here's where we're going to go ahead
411:29 - and
411:30 - talk to our mango to our repository and
411:33 - to talk to the mongodb database and then
411:34 - return the items so i'll just say
411:36 - continue
411:38 - and now we are go we are back into the
411:40 - front end where we have received that
411:42 - response
411:43 - which we can briefly inspect on the left
411:46 - side
411:47 - let me collapse this and that
411:50 - and that
411:51 - and as you can see we got a 200 status
411:54 - code which is great
411:56 - and then we need to
411:57 - convert that promise into the actual set
411:59 - of items so for that i'll just hit
412:01 - continue
412:03 - and now we have our list of items over
412:05 - here in these returned items a variable
412:08 - where you can see we have collected the
412:10 - items from the server side with the date
412:12 - the description the id and the name
412:15 - as an array
412:19 - and then if we just hit continue then we
412:22 - go back to the browser we can see that
412:23 - the items are right there
412:26 - now how about creating a brand new item
412:29 - so let's go ahead and click the add
412:30 - button here
412:33 - and this is the form where you can go
412:35 - ahead and actually create an item
412:37 - so again how is this form working so
412:40 - going back to
412:42 - play the front end
412:44 - go to the code base you're going to find
412:46 - the code for that in the in on the form
412:49 - in item form
412:50 - here
412:53 - if we go back up
412:57 - there's a method called create item so
412:59 - this is the one that's going to be in
413:00 - charge of sending the post request to
413:03 - the catalog mic service to create the
413:05 - item
413:06 - now we can do the same exercise by just
413:08 - placing a breakpoint over here
413:10 - and then we're going to get a response
413:11 - over there
413:14 - same way we can go back to the catalogue
413:16 - service
413:18 - and we can place a breakpoint into the
413:20 - post async method over here
413:23 - now back to the browser
413:25 - let's go ahead and create an item so
413:27 - let's say we're going to create in this
413:28 - case a shield and let's call it actually
413:32 - round shield
413:33 - and this is going to be
413:35 - a basic shield
413:38 - now
413:39 - what happens if i just don't put a price
413:41 - here so i'll go ahead and hit save
413:43 - and you can see that this is going to
413:45 - happen so we have enabled client-side
413:47 - validation
413:49 - via react into the client side so here
413:51 - it is making sure that i have a name and
413:54 - that i have a price if i don't have a
413:55 - price then this happens
413:57 - so sure enough i can put a price and
413:59 - that should work
414:01 - but before we do that what happens if i
414:03 - do something a bit different like
414:05 - putting
414:06 - an invalid price like a negative five if
414:09 - you remember the catalog service has
414:10 - been configured with validations and it
414:12 - should not allow a negative price here
414:14 - we have i have intentionally not enabled
414:17 - client-side validation for a negative
414:18 - number here so that it just let it go
414:21 - but how would that look like in the
414:24 - uh
414:25 - over here when the validation actually
414:28 - comes from the server side to figure
414:29 - that out i'll actually go back to
414:32 - front end and put yet another breakpoint
414:38 - into the catch section over here
414:41 - so now let's go back to the browser and
414:43 - try to save that
414:45 - now we are back into front end so as you
414:48 - can see we will send the request to the
414:50 - catalog items
414:53 - microservice i'll hit continue
414:56 - and
414:56 - as you can see we already got a response
414:58 - here we didn't even need
415:00 - we didn't even get to reach the
415:02 - controller on the microservice because
415:05 - the asp.net core validation
415:08 - runtime
415:10 - verified that this is not an allowed
415:12 - thing like the dto that we sent did not
415:14 - pass the validations so as you can see
415:16 - the response here is already telling us
415:18 - that this is a 400 bad request
415:21 - because we have sent and uh
415:24 - an invalid value
415:26 - and in fact we want to know more about
415:27 - what happened here what we can do is
415:29 - just
415:30 - let me put another breakpoint
415:32 - over here
415:34 - and i'll hit continue
415:36 - and now we can inspect this error data
415:38 - section here
415:41 - and it says here yeah one or more
415:43 - validation errors occur which by the way
415:45 - is exact same validation that we were
415:46 - seeing before imposement for this kind
415:48 - of invalid inputs and if we expand the
415:51 - error section here
415:52 - you can see that we have all the errors
415:54 - that are coming back from the
415:55 - microservices like the field price must
415:57 - be between zero and a thousand
415:59 - so this is one way that if you wanted to
416:02 - you can show that error with that that
416:04 - specific error into the client in our
416:06 - case we are only showing the error data
416:09 - that title
416:10 - uh property that's as much information
416:12 - we want to show to the client at this
416:13 - point so i'll just say continue then we
416:16 - reach the catch section which will catch
416:18 - all the errors here from validations or
416:20 - for any other kind of communication
416:22 - errors from the client and the server
416:24 - and that's going to show an alert
416:26 - we say continue and then back to the
416:28 - client this is what we're going to see
416:30 - good note at the iron one more
416:31 - validation error secured
416:33 - so to fix this
416:35 - let's actually put a correct price let's
416:37 - say six
416:38 - then i'll hit save
416:42 - so back to front end
416:44 - we'll send the fetch request
416:46 - and now we hit the catalog microservice
416:48 - because the validation succeeded so the
416:50 - controller is actually being hit now
416:52 - so this will go ahead and as you know it
416:54 - will execute the logic to create the
416:55 - item and then publish that item into the
416:58 - message broker and write in writing
416:59 - queue so that the other microservices
417:01 - can get notice of this
417:02 - so i'll hit continue
417:05 - then we're back into the front end
417:07 - and this time if we expand the response
417:09 - we can see that we got expected 201
417:12 - and then we hit continue and
417:15 - back into the browser the item has been
417:17 - created browse shield basic shield with
417:19 - price six
417:21 - okay
417:22 - so what about editing an existing item
417:25 - so to edit an item all you have to do is
417:27 - click on the read button here
417:29 - and this will allow you to perform the
417:31 - edit
417:33 - but before actually going through the
417:34 - editing scenario let me actually just go
417:36 - ahead and
417:38 - remove all these breakpoints since i
417:40 - think we get the idea now of how
417:42 - communication is flowing across places
417:44 - so let me go to the breakpoints and just
417:47 - remove all of them
417:48 - over here and also in the catalog
417:51 - microservice
417:53 - so i'm going to go ahead and
417:56 - remove all breakpoints okay
417:58 - so
418:00 - now back to the front end the edit
418:04 - edit logic is happening if we go back
418:07 - into
418:08 - uh yeah in item form
418:11 - so that is happening in the
418:13 - update update adding method
418:16 - so here's where again we call the fetch
418:17 - method
418:18 - with the
418:19 - uh
418:20 - the url of the rest api plus the id of
418:23 - the current item
418:25 - so double go ahead do the fetch
418:26 - operation
418:28 - and then later we'll get a response over
418:30 - here so let's see how that that works in
418:32 - real life
418:33 - over here i'm going to just bump the
418:35 - price from 6 to
418:37 - and then i'll just hit save
418:39 - and the edit has been performed
418:42 - notice how
418:43 - things never reload here like the page
418:45 - is never really reloading it's just a
418:47 - react component that's fetching the
418:48 - updated data and putting it dynamically
418:51 - into the same page that we're always
418:53 - working on
418:55 - then we can also try the delete scenario
418:58 - and that happens if we go back into
419:00 - front end
419:02 - that is happening
419:03 - directly into the catalog catalog.js
419:06 - file
419:07 - there is a section
419:09 - called delete item that's invoked by
419:11 - that red delete button see there's going
419:13 - to be a confirmation then it invokes the
419:15 - catalog api with the id of the of the
419:17 - item and then it performs the delete and
419:19 - also it removes it from the client state
419:22 - so to see that in action let's go back
419:24 - to the client
419:25 - and then i'll actually like to keep this
419:27 - bronze shield and the other items so
419:28 - what i'll do is i'll create quickly
419:30 - another one let's just call it
419:33 - delete me
419:36 - deleting description
419:38 - and then i'll say price for right so
419:40 - i'll save this item items created and
419:42 - for the delete operation all you have to
419:44 - do is click on delete
419:46 - there's going to be a delete
419:47 - confirmation box here click ok and the
419:50 - item is gone
419:51 - and you can always confirm that these
419:53 - are actually happening in the server
419:54 - side by refreshing the browser and you
419:56 - can see that the items are actually gone
419:59 - and of course you can also take a look
420:00 - at the
420:00 - database now how about granting an item
420:04 - to a user which a touches basis with the
420:08 - inventory side so
420:10 - to do that what you can do is use this
420:13 - grant booth over here so let's say i'm
420:14 - going to grant this bronze shield to a
420:17 - user
420:18 - so i'll click on grant
420:20 - and this pops up this model dialog to
420:23 - grant an item
420:24 - now in this in this dialogue what i have
420:26 - done is i have made it so that anytime
420:28 - you open it it's going to populate some
420:30 - random code for some random user id
420:32 - remember we don't have the console of
420:34 - the users really here so it's just a
420:36 - random user id so just like we did a
420:38 - random user in postman now there's this
420:40 - page is uh presenting a random user id
420:43 - run good here
420:45 - and also there's a quantity that you can
420:47 - increase or decrease as as needed
420:50 - now this here is
420:53 - is happening back in in the front end is
420:56 - happening in the grant item form
420:58 - js file over here
421:00 - here is where
421:02 - uh we can actually do a breakpoint for
421:04 - this one uh this is where
421:06 - we will invoke the inventory items api
421:09 - uh with the data that we have about this
421:11 - item and then the uh inventory service
421:14 - is going to take care of granting the
421:15 - item to the user so if you go back to
421:17 - them to the browser and we say let's say
421:20 - we're going to grant two of the potion
421:22 - actually two of the grand brown to the
421:25 - brown shield to the user i'll say grant
421:29 - and then if you go back here in grant
421:31 - item form
421:32 - we can see that the inventory items a
421:34 - url is going to be invoked this time is
421:36 - 5005 slash items
421:39 - and that is going to use the user id
421:41 - that we specified in the client side
421:44 - the catalog item id which is right here
421:46 - and the quantity
421:48 - which is two
421:50 - and just to lose it i'm going to
421:52 - actually going to grab this user id
421:54 - i'm going to copy this one
421:57 - so that we can query for it later
422:00 - and then uh yeah i'll hit continue
422:05 - and that would have granted the item to
422:07 - the user
422:09 - now there's no visual representation of
422:10 - that completion uh in in this page but
422:13 - that's why we have this other page for
422:16 - inventory so let's go to the inventory
422:18 - section
422:19 - over here
422:20 - and here is where you can
422:22 - paste that user id and you can get
422:25 - inventory for the user now all the logic
422:27 - here is happening if you go back to
422:31 - to the front end this is happening
422:33 - actually in dumb
422:35 - inventory.js page so this is the page
422:38 - that
422:40 - is going to allow us to populate items
422:42 - based on this
422:44 - in on the enter user id
422:46 - that's going to go ahead and talk to
422:47 - inventory api with that user id and that
422:50 - brings back all the items that are in
422:52 - the user's inventory pack
422:54 - which is rendered over here in this
422:56 - section render items table
422:59 - to go back to the browser we'll just hit
423:02 - get inventory and there you go
423:05 - the current inventory for the user is
423:07 - presented in this case just bronze
423:08 - shield
423:10 - now once again it's also interesting to
423:12 - see what happens if there's an update if
423:14 - an update happens to this item right
423:17 - would the the ui be able to to reflect
423:20 - the fact that inventory needs to have
423:23 - updated data from the catalog uh when it
423:25 - happens would that take too much time
423:27 - how about that render so let's see so we
423:29 - have bronze shield it's name bronze
423:31 - shield basic shield quantity two so
423:33 - let's go back to the catalog
423:35 - and we're going to edit the bronze
423:37 - shield
423:38 - uh
423:39 - and we're going to change the name
423:40 - so instead of having it as bronze shield
423:43 - we'll just call it
423:44 - a
423:45 - basic shield
423:46 - right
423:47 - and perhaps we'll also update the price
423:49 - let's say it's nine
423:51 - and so so now the bronze shield is named
423:54 - basic shield so hit save
423:56 - and i'll go back to inventory and i'll
423:58 - query again for the items of this user
424:00 - that we just
424:01 - use a granted inventory to so hit get
424:04 - inventory and as you can see
424:06 - the name has changed to basic shield
424:09 - that means that as soon as we perform
424:11 - the update in the catalog microservice
424:13 - that was immediately
424:15 - replicated via a synchronous message
424:18 - into the inventory service and
424:19 - eventually is now able to present the
424:21 - updated
424:23 - name of the shield in this case basic
424:25 - shield and that happened really fast
424:27 - so there you go
424:29 - we have gone through all the
424:31 - sections in this basic front-end user
424:34 - interface
424:35 - so that marks the end of this model
424:38 - and you have connected a modern single
424:40 - page application built with react and
424:42 - hosted in node.js
424:45 - with your two.net based mic services to
424:47 - light up a basic end-to-end scenario
424:50 - and you learned all about cores along
424:52 - the way
424:54 - i hope you enjoyed building this system
424:55 - with me so far
424:58 - congratulations you made it till the end
425:01 - i really hope the course met your
425:02 - expectations and gave you a good sense
425:04 - of how to get started building
425:06 - microservices with a.net platform
425:08 - please consider hitting the like button
425:10 - if you got value out of this and don't
425:12 - forget to subscribe if you'd like to
425:14 - know right away when i publish new
425:15 - videos
425:17 - now microservices development is a huge
425:20 - topic and this course only covers the
425:22 - tip of the iceberg if you want to become
425:24 - a microservices developer and you are
425:26 - considering this architecture style for
425:28 - a real world project you will need to
425:30 - master many other techniques and
425:32 - patterns essential for distributed
425:33 - systems development
425:35 - also as you move your system to a
425:37 - cloud-based environment you will need to
425:39 - add many other pieces to your tech stack
425:41 - to ensure the microservices can be built
425:43 - and deployed quickly to scale the system
425:45 - to meet the production demands and to
425:47 - have the tools to monitor and diagnose
425:48 - the services when things don't go as
425:50 - expected
425:52 - to cover all these topics i created the
425:55 - buildingmicroserviceswith.net complete
425:57 - learning pad which expands what you saw
425:59 - in these basic skirts with dozens of
426:01 - additional lessons that will teach you
426:03 - step by step how to add all the building
426:05 - blocks needed for the complete
426:06 - microservices-based application and how
426:09 - to take everything to a production
426:10 - environment in the cloud
426:12 - if you are interested please check out
426:14 - the links below to get all the details
426:16 - on this premium offering
426:18 - thanks for watching and i'll see you
426:20 - next time
426:24 - [Music]

Cleaned transcript:

learn the foundational elements of a microservices architecture with net by building a real microservicesbased application julio is an excellent teacher and has created many popular.net courses welcome to buildingmicroserviceswith.net the basics my name is julio gasal and i'll be your instructor through these first steps in your mac services learning journey with the.net platform before we move on to learn about microservices i'd like to walk you through the fictional client application that drives the requirements for the backend system that you will build the high level architecture of the system and the technology stack that will be used across this course let's imagine a video game where the player will need to acquire a series of items to stay healthy become stronger and survive the multiple changes that await him in his adventures there will be a series of stores that will allow the player to purchase items like potions antidotes and even source and shields these items have a price to purchase them the player will need to present the right amount of some sort of currency that we will just call jill once the player successfully purchases an item it then goes into his inventory back where it will be available for him whenever he needs it now the client side of this game the app that runs in the player's device is already being built by your company's client team so you don't have to worry about it and in fact this client app is not part of this course our team has been chartered with building the backend services for this game which the client will heavily depend on to be able to store the items catalog the player's deal and inventory and to enable the ingame purchase experience let's now look at the highlevel architecture of the system support the client applications the following microservicesbased architecture has been designed at the core we have identified four microservices catalog which owns the list of items available for purchase inventory which keeps track of the quantity of items that a player owns identity which manages the list of players and also acts as an identity provider and trading which owns the purchase process that can grant inventory items in exchange for jill each of these services have their own database that has no relationship with other databases and that are of exclusive use by the owning service for interservice communication the system makes use of a message broker which allows the services to collaborate by polishing and consuming messages asynchronously for the clients to interact with the microservices this architecture has an api gateway which provides a lot of flexibility to make changes to the services without impacting the clients and lets the services focus on their business while delegating multiple crosscutting concerns to the gateway there is also a frontend portal that enables the administration of the items catalog the players and the inventory and it also includes a store section where players can purchase items finally there are a few infrastructure components like logging distributed tracing and monitoring that all microservices can interact with and that can greatly help to troubleshoot issues and make sure the whole system remains healthy now there are a lot of topics to cover to implement this system so in this course the basics we will focus on the most fundamental parts related to microservices collaboration in that sense you will implement only the catalog and inventory microservices using.net and asp.net core and you will use mongodb to host a nonsql database for each service you will initially explore how the services can communicate synchronously via res and http but later you will stand up a rabbit enqueue message broker that will allow all services to communicate asynchronously by publishing and consuming messages via the mass transit distributed application framework that will give you a solid understanding of how to get started with microservices and net and how to tackle the multiple challenges of getting the services to collaborate in a resilient way the frontend portal is placed on the react ui framework you won't be coding this portal but you will get access to all this source code so you can build and run it in your box and use it to see how real and modern client can take advantage of your microservices also you will run all infrastructure services like mongodb and revit queue via docker containers which is the best way to get things up and running in your box very quickly at the end of this course i will point you to the next steps so you can continue your journey by implementing the rest of the system in the next lesson you will download and install the first set of tools that you will need in your development box for the upcoming models in this lesson you will set up the development environment that will be used across this course here for the tools required for this model the net 5 software development kit or sdk which includes everything needed to build and run.net applications docker desktop which has all the tools needed to run the multiple infrastructure services that we will use across the course and visual studio code the lightweight but powerful source code editor that we will use to write build and debug our microservices code a few of the future models will require more tools but for now this is all that is needed let's go through the installation of these tools and the overall setup of our development environment before getting started just keep in mind that the pages that you will see for downloading the tools will likely look a bit different depending on your operating system and the versions available at the time that you're taking this course but regardless the result download and installation process should be mostly the same so let's start by going to the download page for the net sdk so let's go to net.microsoft.com download and this page is going to present you the latest version of the net sdk which in my case that will be net 6 and in your case it could be different but one thing to keep in mind is that this course has been designed for net5 not for dotnet 6 or any other future version so even if you have net 6 or another version installed in your machine you have to make sure that you get the net 5 sdk in your box otherwise the project in place that you will be using will generate different code than the one that you're going to see in this course and you're also going to get a few syntax errors so to get the net 5 sdk what you want to do is go to this link all the temp versions and then you want to go into the 5 link over here here at the top of this page you want to look at this table here which lists the links to install.net for the different operating systems so you have to choose the link that corresponds to your operating system in my case i'm running windows and my platform is x64 so i'm going to click in the x64 link and that is going to start unload so this unload could take a few seconds depending on your download speed so let's just give it a few seconds okay so the installer has unloaded i'm going to click on installer i'll click on install and installation starts this could take a few seconds or a few minutes depending on the speed of your machine so again let's just give it a moment okay so the identified sdk has been installed already and i'm going to just close this window and what i'd like to do now is to quickly go ahead and verify the installation just to make sure that it has been installed properly so to do that i'm going to go and open my start menu and then i'm going to look for my terminal my windows terminal and of course depending on your operating system what you can do is just open whichever terminal or shell is available in your box this should work in really any kind of terminal or shell and then all you want to do is just type net and then dash info and this is going to present you with a bunch of details regarding your version of the sdk and your machine like in my case it is showing that i have version 5.0 that 404 of the sdk and then there are many other details here but in the end this shows that that end has installed properly into my machine so that net is ready to go now let's go ahead and load the page to download docker desktop let's go to docs.docker.com getdocker and in this page if you scroll down a little bit you're going to see again that you can pick your operating system so again my operating system will be windows so i click on docker desktop for windows and docker desktop for windows so i'll click on that button and let's give it a few seconds for the download to complete okay so let's go ahead and open the docker desktop installer okay so here it goes we'll just keep these two checks right there no need to change anything i'll just click on ok and that's going to get things started again this may take a while so let's give it a moment to complete okay so installation succeeded i'll click on close another thing about docker is that docker desktop will usually not automatically start in your machine after installation so you do have to start it at least the very first time that you install the tool so to start docker i'll just go to my start menu i'll type docker so here it is you're looking for docker desktop i'll click on it and you should see a new icon show up in the right side bottom right i guess which is starting the docker process okay so this screen shows up i'll click accept all the terms accept notice how docker desktop is starting and then this screen shows up local engine waiting double engine starting give it a second installation has completed it has started i'll click on skip tutorial here and at this point docker is up and running and to verify that docker is up and running properly what i'll do is also type a quick command in the terminal window but i'll open a second terminal just because we want to make sure that it has gotten the chance to read the new environment variable to locate docker so i'm going to close this terminal here close our windows and i'll open a new terminal windows terminal and here what i'll do is just type docker version and if docker is installed it should show up all the details about the current version of docker which in my case is version 20.10.11 for the docker client at least and with that our docker installation is complete so now i'll go ahead and install visual studio code so i'll close this terminal and i'll go into i'll close this i'll go into the browser let's go into aka rms slash bs code and here's the style page for vs code and as usual you're going to be offered the version that corresponds to your operating system so i'm going to click on this big blue button here download for windows stable build and then download starts and this should be pretty fast this is a small starter okay so i'll click on installer accept agreement and then i'll just click all the default options here click install and let's give it a moment to complete okay so then i'll just click on finish and this code is opening up right away i'll maximize this window and as you can see vs code has open up and that completes our installation of initial tools in the next lesson we will go ahead and customize pixel studio code for csharp development visual studio code is a lightweight but powerful source code editor that has builtin support for javascript typescript and node.js and has a rich ecosystem of extensions for other languages and runtimes since all the code that you will write across this learning pad will use the csharp language and will run using the network time you will need to install the popular csharp extension so to start extensions what you want to do is go into your activity bar on the left side this one over here and look for the extensions view via this extensions icon you can click on that one and this is going to show all the available extensions in to the code marketplace of which there are really hundreds of them and then what you want to do is just search for csharp and the extension that you want is usually the very first one on the list and is the one that is provided by microsoft and it says csharp for visual studio code powered by omnisharp so let's click on that one and this is the extension that adds all the editing support needed for csharp including syntax highlighting intellisense find all references and many other features it also adds support for building and debugging.net and asp.net core applications in your box so you have to make sure that you get in this extension in your box to be able to do proper coding with csharp so i'll go ahead and click on install and this may just take a few seconds after which you will be ready to start coding in c sharp okay so extension is ready and you're ready to call on c sharp with visual studio code here but let's also go ahead and enable a few optional settings to further improve your coding experience so let's go to let's first close this and let's close that let's go to file preferences settings and here let's type place open race on new line and this is going to filter a few options here and the ones that you want to enable are this one here javascript format place open brace on new line for contour blocks and place of embrace of new line for functions these two settings will help you format your control blocks like if else blocks and your functions so that when you open braces the opening brace automatically goes to the new line so you don't have to use this setting but i find that my code reads much better when i use it the next setting is let me delete this one here delete this is um format on save which is this option right here this first one so i'll click on that one so what this allows is to uh make sure that all your code for whichever file you're working on will be automatically formatted as soon as soon as you save it into your machine right so you save the file and it will get all the formats so that what again we will help you make sure that the code looks way better without you having to do a lot of work across your lines and the last option setting that i will recommend you is this one in file how to save so as the name says what this allows you is to automatically save whichever file you're working on without you having to do anything so as soon as you finish typing your code the file will be automatically saved to your machine so i find that very handy and to make sure that i never forget to save my files so i'm just going to click on auto save and that will enable the setting the last thing that i wanted to show you here is the visual studio code integrated terminal which is the one that you're going to use to type a bunch of commands across this learning pad so let me go ahead and close this settings tab here and to open the terminal what you can do is either go to view terminal or you can go to terminal new terminal or you can use a few shortcuts like for instance in the case of windows you can do ctrl tilde double open terminal or let me kill this you can also use ctrl j and that will also bring up a terminal so of course the shortcut keys will depend on your current operating system now as you can see in this case this has opened a terminal a powershell terminal in my case and that's because that's a default for windows but you can always go ahead and use this drop down on the right side right here you can open up and you can switch to any other terminal that better switch your needs so if you want to use patch you can use git batch here you can use a standard command prompt or you can switch to either even a wound based terminal so it's really up to you what terminal to use in this course we'll be using mostly a powershell because that's that's what i mostly like to use but it's up to you to use whichever terminal fits better your needs in the next couple of lessons we will define the concepts of monoliths and microservices how they compare and which are their pros and cons before diving into microservices and their benefits it is probably worth it to understand first what a monolith is its benefits and the issues it can present to understand what we mean by a monolith let's look at one way we could design our play economy system we start with our desktop and mobile clients like we said they need some sort of backend piece to enable the game experience therefore we introduce a server component likely hosted as a web server somewhere in the internet as we go through the requirements we identify a model that needs to take care of the ingame catalog of items so we introduce a catalog model right away we also perceive the need for a place to store these catalog items which means it is time to introduce a database along with a table to store these items we also identify the need to store the information about our players and in general any user of the system so we bring in a user's model which we place in the same web server next to the catalog model also since we already have a database configured for a web server we decide to add tables for the user's model in that same database next we identify the need to store the set of items that the player has purchased so we bring in an inventory model and same as before we place it next to our other models and add relevant tables to the same database we also need some place to perform the actual purchase process and since this involves both dividing jill from the player and granting items to him we also know we will need to use some sort of transaction for this so we introduce a trading model on the same server and we will let it take advantage of the transactional capabilities of the database finally we will need some way to secure the access to our web server so that only players registered in the system can make use of it so we bring in an authentication and authorization model which we will abbreviate as oddc as with everything else we will place it on the same server and make it use the same database this system that we have just described is what we call a model it and more specifically a modular monolith in this system all of our serverside capabilities are hosted together in the same web server and they all use the same database likely we also have the source code for all the models in a single repository we build all the code base with a single bill process and we deploy everything together let's now look at the pros and cons of a modulate here for the pros and cons of a modblade first the pros convenient for new projects usually when you're just getting started a monolith is the best option since you can put all the source code in one place including all common libraries this lets you iterate quickly for a while tools mostly focus on them most ides are built around the concept of building a single application which aligns pretty well with a monolith there's great code reviews since all the code lives in the same repository it is easy to reuse code across the multiple models of the application it is easier to run locally being a single process it is a straightforward to have the full application running in your box usually with a single command easier to debug and troubleshoot when it's time to fix box there's usually a single place to look for locks to find out what happened you can also start a debugging session in your box to reproduce and fix the issue there's one thing to build a single command is usually enough to build entire codebase locally and if using a continuous integration server a single build pipeline will do the trick there's also one thing to deploy all the application models can be deployed as a unit with a single deployment pipeline there's one thing to test end to end endtoend verification of application can take place as soon as application has been deployed with no other moving pieces that could impact testing and there's one thing to scale with increased load demands more risk more instances of the web application there's only one app to scale saying when the increased scale is no longer needed there's only one thing to scale down now the cons easily to get complex and to understand since entire code base is in a single place there will be a point where it starts becoming too hard to navigate it and understand the relationships between the different components merging code can be challenging when using things like git and with more and more people contributing to multiple models in a single code base eventually resolving conflicts gets more troublesome and the chances of a bad merge that could impact on related models increases it slows down ids if the devs use an integrated development environment or ide like visual studio the massive number of projects and source code will eventually start slowing down the ide starting with simple things such as opening the work environment long build times the bigger the single code base becomes the more time it takes to build it things like incremental builds can help here but this is something that can easily not be configured properly and regardless it is undesired to have to build code for all the application models when usually you only work on one or two of them slow and infrequent deployments just like building the code takes longer it also takes more time to complete the deployment since there are a lot of components to deploy with every new build not only that teams tend to delay compound deployments to friday night or even weekends due to the lack of confidence on the impact of the changes that go into that deployment remember that with each deployment you are deploying all the application models all the time long testing and stabilization periods once a deployment is complete regardless of what changes in the deployment you still need to test all the scenarios across all of the application models not only this is inefficient but also teams that don't have testing fully automated may need to run manual tests to compensate and run them again for all the application scenarios rolling back is all or nothing books will eventually make their way to deployment and sometimes there's no time to code and deploy the ideal fix in these cases you just want to roll back the previous version however with a monolith you will be forced to roll back the entire application not just the faulty model and once the fix arrives you will need to redeploy the entire thing again with all the associated testing and stabilization no isolation between models the small spock in one of the models that makes the web application crash will take down all the models with it it can be hard to scale this really depends on the kind of app that you're building but if you have some model that needs say a lot of memory and therefore needs to be scaled to multiple instances to not take over all the ramming a single server while all the other models are fine with a small amount of ram most of the time you still need to scale the entire application with all the models to satisfy the ram needs of the first model also it's hard to adopt new tech if you would like to move one or two of the models to the latest version of say the.net platform you are forced to update all the models along with it which significantly increases the time investment and associated risk of moving to a new stack moreover if you need to switch a model to a different programming language or web framework you still need to account for how that change will impact the rest of the models in the next lesson we will start learning about microservices their pros and cons and when it's a good time to start considering them in this lesson we will understand what microservices are how to decompose our previous model lead into microservices the pros and cons of using microservices and when is the right time to start thinking on using them there are multiple definitions of microservices out there but here's one i have synthetized from a few sources and that i think covers the fundamental characteristics of microservices microservices refers to an architectural style that structures an application as a collection of independently deployable services that are modeled around the business domain and are usually owned by a small team so instead of having a single application deployed as a single monolithic unit we break it down into smaller services where each of them is closely aligned to some part of our business domain each of these services can be deployed independently which by the way includes granting each of them their own database which is one of the main challenges of moving to microservices also there's usually only one small and fairly autonomous team behind each microservice let's see how this looks like for the game back and example we talked about in the previous lesson we start again with our client apps which will still interact with some backend pieces to enable the required game experience and just like before we come up with most of the models that we talked about before to address the multiple scenarios however this time each of these models live in their own individual server process or likely a web server process fully isolated from the other ones and with their own lifecycle not only that but also each of these services have their own associated database that has no relationship with the ones from the other services also notice that we decided to group the users and altc models in a single process that we are now calling the identity service but even when these services are now independent they still have ways to collaborate with each other so that for instance when a purchase starts in trading this service will communicate somehow with identity and inventory services in order to achieve the exchange of yield for catalog items this here is what we call the microservices architecture pattern next let's learn about the benefits and drawbacks involved in the microservices architecture these are some of the pros and cons of using microservices let's start with the pros they have a small easy to understand code base since the microservices are now independent the source code for each of them is usually stored in its own git repository this implicitly results in a much smaller repository which is much easier to understand especially for devs new to the code base they are quicker to build the smaller independent codebase per microservice allows for building each service much faster and in parallel both on deck boxes and on ci pipelines they allow for independent faster deployments and rollbacks each service can now be deployed individually as soon as the relevant source code has been built and testing for the domain covered by the service can start right away and is much smaller in scope also if an issue is detected with the deployment it can be rolled back to the previous version without having to roll back any other service they are independently scalable different services can be skilled according to their needs so if there's one service that needs to scale given the amount of ram or cpu it uses it can be scaled independently of the needs of any of the other services there is much better isolation from failures microservices are isolated from each other so that a crashing one service has no impact in the availability of the other services they are designed for continuous delivery since microservices are small usually start fast and are independent from each other they are great candidates for continuous delivery they can be deployed as soon as the code has been built and this can be done safely in an automated way multiple times a day it is easier to top new variety tech different services don't need to use the same versions of their multiple dependencies including the.net runtime even better if one of them needs to be moved to a completely different language or web framework this is much more straightforward to do with a small micro service than with a big model it microservices ground autonomy to teams and lets them work in parallel the natural independence of deployment and isolation of microservices and the fact that they are closely lined to a specific part of the business domain results in the owning teams to have great autonomy around the entire lifecycle of the service some teams might decide to deploy their microservice every night while others will do it every hour or whenever an origin fix needs to be shipped different teams will do what's best for them now the cons it is not easy to find the right set of services how do you know that you have split the app into the right set of services are three microservices enough or 10 perhaps how much granularity these questions are not easy to answer but techniques like domaindriven design and aligning the services to specific pieces of the domain and the teams behind them helps to find the right balance using microservices as the complexity of distributed systems the fact that each service lives in separate silo introduces a lot of complex issues that are nonexistent in modulates how to have a service communicate with another one if a model can no longer make a simple method call to the other issues like these are the reason for this curse the shared code moves to separate libraries any piece of code that needs to be shared across two or more microservices now needs to be either duplicated in each service which is not ideal or moved to a separate library and likely sharpie and nougat packages this is technically good since it forces the owners of the share code to have a good way to test the shared code independently but on the flip side things are no longer as easy as adding a new shared class or method to any of the services codebase also you may end up with dozens of shared libraries that may need to collaborate and have the right set of dependencies there is no good tooling for distributed apps ides are usually focused on a single app not uploading several services together this means that devs will usually work on one service at a time and will need to figure out ways for their code to interact with other services in their dev environment where needed releasing features across services is hard simple things like adding a new attribute to say a user record and have it been used across the entire system can involve touching multiple services in a very coordinated fashion even worse updating or removing attributes from data classes is extremely painful and usually avoided as much as possible it is hard to troubleshoot issues across services when a customer reports an issue with the system or application where you will start looking with features potentially distributed across dozens of microservices you are forced to have a very good story around tracing issues across services to be able to quickly find out the root cause and address it you can't use transactions across services since each service has its own database atomic transactions that impact multiple tables are usually out of the question how to ensure a purchase operation will both debit jill from the user and granted the relevant items when one of the involved services could unexpectedly fail in the middle of the purchase process a few new patterns and techniques need to be introduced to properly handle these concerns finally it raises the required skill set for the team with each team fully owning the service and since not all services will be built similarly each team now needs to learn not just how to code features for the service but also how to build it deploy it test it in isolation diagnose it roll it back etcetera many times this also involves building a ton of automation and shared infrastructure to ensure teams can remain agile building features and not have to worry too much about all the other aspects this requires a lot of investment let's close this lesson by understanding when you should start considering microservices you should keep in mind that it is perfectly fine to start with a monolith and only later move to microservices architecture your business domain and the set of requirements for your system might not be fully flushed out by the time you need to start designing and building the system therefore jumping into building multiple microservices from the start could not only significantly slow down the small starter team at a time when quick proof of concepts are desired but also you may end up building the wrong set of microservices with additional cost of having to restructure them later the heavy investments on shared infrastructure and automation will only make sense as the boundaries are clearly defined and the team has grown in size you should start looking at microservices when the code base size is more than what a small team can maintain the different teams can move fast anymore due to the amount of share code the bills have become too slow due to the large code base or the time to market is compromised due to infrequent deployments and loan verification times in the end microservices are all about team autonomy anytime you notice multiple teams no longer being able to deliver features in an agile way due to the drawbacks of the monolithic architecture you know that your teams have lost their autonomy and they could potentially greatly benefit from using microservices instead in the next model we will get our hands dirty by building our first microservice in this model we will build our first microservice from scratch this will give you the foundations and tools you will need to create microservices with the.net platform by the end of this model you will have a solid understanding of the following how to create a microservice from scratch via the.net cli and visual studio code how to define the microservice rest api with the most common operations and what are and how to define the data transfer objects to establish the contract between our service and the service clients in this lesson we will create our first microservice the catalog microservice using the.net cli and visual studio code to create our microservice project we will take advantage of the.net command line interface also known as netcli which comes installed with the net sdk so first thing i'll do is create the folder where i'm going to store my projects so to do that i'll go to terminal new terminal and then i'll switch to my d drive and to my products folder and i'll create a folder called play that catalog so everything related to the play that catalog uh catalog microservice will be stored in that location so i'll open that folder and visuals to the code now by going to file open folder and then i'll look for that location here so this opens a workspace in that location so being here what i'd like to do is create yet another folder to store all the source files for the for the microservice so i'll go on the left side here i'll go and click on new folder and then i'll type src so src is going to be the folder that stores all the files related to compile duplication i'll expand this and then i'll right click on src and select open in integrated terminal so this opens a terminal exactly the location where we're going to create the project files to actually generate the files what we can do is type net new and at this point you can actually pick from a bunch of different templates for creating.net projects but the one that's most useful for microservices is usually the web api kind of project so we'll all type web api and the name we're going to give it is that lay.catalog.service hit enter and this is going to go ahead and generate all the files that we need for the project which at this point you can see on the left side also notice that there's a small warning about the asp.net core https development certificate which we'll take a look in a moment now if by any chance you have multiple versions of the net sdk installed in your machine and you're not sure that that n5 is your default version please add the framework argument to the net new command and specify the value of net 5.0 for dot n5 that will make sure that you are using the asp.net core 5 templates when creating projects which will produce the same files that you will see in these and in future lessons now let's go quickly across the files that just got generated and see what they are meant to be used for so the first one is going to be alter i'd actually just close this terminal the first one is going to be the cs profile which is what we call the project file so this is the file that defines how the project is going to be built and what version of the dotnet runtime is going to be targeted in this case it's going to be.net 5. the next one is program cs which is what we call the main entry point of the application but also notice that as soon as we open our first sharp file visual studio code is going to prompt us to add a few regard assets to the project and we'll say yes so this will create a vs code folder on the left side with a couple of files that are needed to build and debug the application now like i said back in program cs this is the main entry point so this defines how we're going to start the the host for our application next file is going to be startup.cs this defines how we're going to uh register the services are going to be used across application and what we call also the request pipeline for espnetcore the next one i'd like to show you is the controllers folder this is where we store all the application controllers to handle the requests that are going to come into the application and this is a campaign this is a campaign with uh right now by a model that's called the weather forecast for the simple sample model that has been set up in this template next file is a launch settings.json this one defines a few things but the most important one is the application url which defines which is the address or the addresses where our microservice is going to be running so in this case it is going to be available in https localhost 5001 and on https sorry http localhost 5000. finally like i said this is the code generated a couple of files over here that's a json which defines how we're going to build the code from visual studio code and launch application that defines how to start up how to actually kick off the execution of the application in visual studio code okay now i'll close this and it's time to actually build this project to make sure we'll build and run it to make sure that it's running properly so in order to do that what i'll do is i'll go back to the terminal and you can do that by going to view terminal which by the way you can also do via the control j shortcut faster that way and then i'll switch to our play.catalog that service directory play that catalog service and then we'll be in there and what you can do there's actually a couple of ways that you can build this project so you can either do net build like i'll do now that will go ahead and build the entire project should be pretty fast and the other way to do this is via visual studio codes menus you can go to terminal realm build task and then you select build and that will also go ahead and build the project now this second way is the way that you will most likely be using a while being exhausted to your code and to make this actually a bit faster what you can do is add a little bit of a couple of lines into the task.json file so let me minimize this a bit so go to that json and here under the under the build section what you can do is just add one little group here let's add it it's called group and then we're going to go for kind build is evil true i'll save this and after doing that what you notice is that when you go to terminal and you say run build task it will build it right away as opposed to opening yet another menu to do the build at this point you can also do uh you can also use the ctrl shift b shortcut like i'll do now to kick off the build without having to go through any menus which is pretty handy okay now that we know how to build the project and i'll actually just close this how do we how do we run it so there's a couple of ways to do that too so i'll actually switch in this drop down i'll go back to our terminal the partial terminal and the way to run the this microservice this microservice project is by just typing.net run so that may build the project depending on the current status but after that it will go ahead and run it as you can see and it reports the current status uh the the the address where the where the host is listening the addresses in this case 5001 5000 in localhost and how to actually turn turn down the application if needed by ctrl c that's one way and i'll actually do a control c to stop it the other way to do it is by going to the to the wrong view on the left side and here you can click on this on this icon here says start debugging it will actually start a debugging session of the project as opposed to just running it so i'll click on it okay and this will open a browser window as you can see here for our project now if you see this this kind of an error stating that your connection isn't private this is totally normal so this just means that the development certificate for the for the web host has not been installed yet so in order to address this let's actually go back let's close this and stop it and what we have to do is just install the certificate i mean trust the certificate in our machine so i'll go to terminal switch back to the partial terminal here what i'll do is use the net dev search tool you have to type https trust hit enter and this is going to pop up this little warning here which is totally fine and say yes and that adds a certificate into your thruster rule certificates stored in your machine so after doing that i'll go ahead and instead of clicking on this i'll just hit f5 which is a shortcut for start debugging so i'll hit f5 so that obviously browser came and as you can see there's no errors anymore and yes it is not showing anything uh that that's because there's nothing really happening in the in the root of the website so if you actually want to see something you can do slash swagger and this opens the swagger page so i got ui page so this is the page where you can start exploring the different methods exposed by your web api or your res api in this case we have not really coded much the only thing that you're seeing here is the default stuff that's coming with the template so we'll not pay too much attention into it but later on we'll start using this page heavily to start working with our microservice i'll close this and i'll stop the server so that's it for this lesson and in the next lesson we will define the rest api for our catalog microservice in this lesson we will define the res api for our catalog microservice the res api defines the operations exposed by the microservice since the catalog microservice owns the items that players will be able to purchase here are the operations that it should support get items which retrieves all the items currently stored in the service get item by id which retrieves the details of a specific item post item which creates an item in the service put item which updates a specific item and delete item which deletes the specified item as part of the definition of the res api we also need to define the relevant data transfer objects so what is a data transfer object a data transfer object also known as dto is an object that carries data between processes for example let's go back to our client and the catalog service when the client needs to retrieve the details for a specific item it will send a get request to the service with the item id and the service will in turn return the item details this payload returned by the service is what we call the dto the dto represents the contract between the microservice and the client we'll define this contract has significant implications imagine what would happen if we decide to rename the price to item price our clients would break and they would need to get updated right away to ensure no disruption to our customers as a general rule you need to think carefully about each of your details to ensure you minimize the need to update them later as much as possible it's time to define the res api for catalog microservice we'll start by deleting a few files that were created by the template that we will not be using across this microservice which are the weather forces controller i'll delete this and the weather forecast class over here now the first thing that we're going to do is declare the details for our service now we will use record types for dtos as opposed to classes basically because they are simpler to declare they provide value based equality which means that when comparing two of the items then we will consider equal if all their properties have the same value which is not the case with classes they are immutable by default meaning that modifications after creation are not allowed and they have a built in to a string overwrite that shows the names and values of all the record properties so to create the dtos file you can right click on play catalog service right here say a new file and then let's name it dtos.cs in this file first thing we're going to do is just declare a namespace so namespace should have the name of the folder to start with so play catalog service and then we will append dtos now let's declare our first cto this is going to be the dto that is going to be used to return information from our get operations so public record item dto and the first thing that is going to have is an id it's going to be of type good and good is a type that is going to need a namespace import so to import namespace i'm going to use a light bulb here and i'll select using system so that imports the namespace and then we're going to declare a name a description a price and a created date okay now the next cto is going to be used for the creation of our items so let's say public record is going to be named create item dto this cto does not need an id or a created date because both of them are going to be automatically generated within the service so they don't need to be provided by the client so we'll specify a name a description and a price finally we're going to declare a dto for updating an item so pull the record update item dto and this is actually going to have the same members as create item dto so i'm going to copy those and uh it happens to be that right now they have they need the same members but it could be in the future that they need different different properties so a good convention is to keep them separate even if they have the same properties to start with in the next lesson we will add a controller to define our res api operations in order to add our api operations we will need to introduce a controller specifically a web api controller the controller groups the set of actions that can handle the api requests including the routes authorization and a series of other rules usually needed in rest apis so to start let's go to our controllers folder here right click new file and the name that we're going to get to this controller is items controller since this is going to be the controller that's going to be managing our catalog items so let's go ahead and collapse our navigation pane so that we have more space for looking at the code let's start by defining a namespace the namespace catalog service controllers okay and now let's define our class it's going to be items controller and so each of your web api controllers should derive from controller base and i'm going to import the missing space by doing control dot using microsoft switch core mvc so you always want to derive from controller base not from controller but controller base because this provides many properties and methods useful when handling http requests like the battle requests not found and created attacking methods which we'll be using in these and in future lessons now you should always also add to each of your controllers the api controller attribute so api controller this attribute enables a series of features that improve your sapi developer experience like for instance having model validation errors automatically return a 400 request error or how to bind incoming requests into our method parameters the other attribute you want to add here is the route attribute this one specifies the url pattern that this controller will map to for instance if we use items here that means that this controller will handle the rewards that start with slash items so for instance if we get let's say i'll just add a little comment here so we have localhost 5001 and if somebody navigates into items that means that since the route specifies items here that means that items controller is the controller that's going to handle that specific route okay so i'll remove this and you can also use route for the different uh operations that we're going to define in this controller you can specify your own routes but for now uh this is going to be our root route for all the the operations in this controller now since in this lesson we would like to focus on the rest api part of microservice we will not be interacting with the real database just yet we will use an inmemory list of items that our api variations will interact with and in a future lesson we will introduce a proper repository class that will take care of interacting with our database so let's start by defining this a static list so i'll declare probably static read only we'll make this list read only because we will only allow to construct it i mean to create it or instantiate it during a controlled construction time and after that there will be no need to modify the instance of this list so it's going to be list of item dto because uh uh this is going to be the list that we're going to be returning when somebody requests the items from our rest api so we want to specify the contract that we already find for our items here so item dto and then it's going to be named items equals new and so let's see we're missing some more next spaces here okay so i'll do ctrl dot again system collection is generic and we also need our play catalog service dtos namespace so let's find our first item here so i'll just define it in line here so new item dto for the id we'll just generate a generate a random good so a new good mainly another nice space import yup and for the name let's name this one potion the description is going to be restores a small amount of hp the price is going to be let's say five and for the created date let's just do the time of set that utc now okay it's going to be the the current time in utc time so let's add i'll just copy this to add two more items the second one is going to be let's say an antidote and so the antidote cures poison price is going to be let's say seven credit date is utc now and the last item is going to be let's say a brown sword and it deals a small amount of damage it's going to be a big price here let's say 20 and yeah utc now column save okay also notice that we're using a static list here so we do this so that the list does not get recreated every time somebody invokes one of our res api methods right otherwise the list will be recreated every single time that a method is invoked which we don't want so now let's define our first operation this is going to be the operation that's invoked anytime somebody tries to get all the items that we have in the rest api so we're going to say public innumerable off item dto get okay and so yes we're returning a list of identito now each of your api operations should be a marked with the correct http verb right since this is going to be responding to our the get verb we should mark this with the http get attribute and then for for this method really is super simple we only need to return the current list of items right so we just return items so that's our first get operation the next one is going to allow us to return one one specific item so we'll name it public item dto get by id okay and then we're receiving the the specific id as a good and just like we did before we need to decorate this with the http get attribute but here we also need to specify uh what part of the of the route that the user specifies is going to map to that id so in this case we do that by specifying id here okay so that means that uh if somebody comes with and i'll put it so here so somebody go does it get there's a little comment here does it get into our items route and then they specify some id like one two three four five uh that one two three four five is one is is captured as the id in the http get route and that's mapped into the id parameter over here okay so the route would look more like in a more generic case it's going to be slash items slash id and so to do this the only thing we have to do is just find the correct item in our list so we'll say bar item equals items where and for this i'll need ctrl dot system.link so for each item we will do a item.id should match the id that we got in the parameter and then we will say okay so let's find the only the only item that should match with that id get that one otherwise i mean with single default we can say either get the item or just return null in this case and then we return that item okay so that's what we need uh for our get routes so let's try it out to see how that that goes so i'll hit f5 my keyboard to start a web server that opens the browser and let's now navigate to our swagger page so slash swagger and here you can see that we have our two first api operations defined items and items by id and we also have the the schema of our itunes dto showing up here right so if you expand this one we can see the shape of our item video right there so if you expand the items route you can see a little example here of what it would return and expected a return for a successful case and then if you want to try it out just have to click on try it out then you click on execute and here you can see the actual the request url that was invoked into our api slash items and then you can see the response body here along with the status code 200 and the response body has the three items that we have in our static list so that's working fine and let's say that we want to try the other a operation where we have to specify an id so i'll just copy the id of one of these i'll collapse this for a moment i'll expand the other so this one expects an id this parameter so i'll do try it out i'll paste the id here and then i'll click on execute and just before it it will go ahead and use the items a route but it will append the id of the item and as you can see we got a 200 okay and we got in the body we got the actual uh the body of the of the item that it was retreat okay so that's working fine so let's now add a method for creating an item so minimize this stop debugging and then i'll close the terminal okay so to create items we're going to be using the post http verb and let's create a method for that so it's going to be public action result now the action result type uh so this one allows us to return a return a type that represents one of the several http status codes like 200 okay or 400 requests but it also allows us to return a more specific type like a dto type if we need to so we can return different types depending on what we have available so let's see how we're going to be using this um so action retooled off type item dto and it's going to be named let's just name it post for now and then here is where we're going to receive our create idm dto contract right so that in that way we enforce that uh whoever calls this this api has to follow our contract for creating items so create item dto and this one has to use also the correct http verb it's going to be http post and then for creating an item we will just create it in line here so i'll just say var item equals new item dto and we'll assign a random id here just like we did with the with the list you do it and then we will say for the name we'll say create ideo.name for the description that description for the price created you that price and for the day for the great date again daytime offset you'd see now so that's the item and now now that we got it we will just say items dot add to add the item to our to our static list finally we're going to return the type created action uh which is a is derived from action result so this so this is going to be used to say hey so the item has been created and you can find it at the following route uh which route is is going to be well is the route with the name so name of get by id so this means that uh the caller will be able to find i mean we're going to produce a heater in the response that includes the exact route of the item as provided by the get id operation over there we will also provide the id of the created item as an anonymous type here is going to be id equals item.id and lastly the actual the actual body of the response which is the entire item right so it's ready i'll do f5 so we can try that out see how that goes okay back here i'll just close this one so back into the previous tab i'll do f5 as you can see now we have the the post operation listed here and the create item dto listed at the bottom so i'll go for post i'll expand this and to try it out i'll do try it out uh so here's where we can create a new item right so let's let's figure out some new item to create here let's say we're going to create a high potion and so this one is going to restore a medium restore restores a medium amount of hp and the price is going to be let's say nine okay and so now i'll do execute as you can see it invokes uh the same route but in this case it was with a with a post verb post and uh yeah so we got 201 which means created a created route create or created at here's a response body so the entire created item including the auto generated id over here and here you can see the heaters includes the location the location of the just created item so if i wanted i can grab this id and i can collapse let's call exposed and then expand get inside id try it out and i can paste that id here and i should be able to find that just created item as you can see or here's the high potion so post is working just fine so now let's say that we want to update an item so that's where we need to introduce the put the put operation so let's go back to our piece of studio code stop this and close terminal and let's declare a method to update items so for this term for this one i'm going to declare public action result and i'll be using i action result because in this case we don't really need a specific type for the return we will just return this one called no content meaning uh that's that's what um uh you usually do for a put operation you don't want to return anybody you just say hey uh yeah i did my job but there's nothing to return so it's going to be named put so we want to receive the id of the item to update and we will use the update item dto contract to receive the new the new payload or the new information for this existing item it's updated in dto and we also have to specify the proper verb so http put and just like we did with the get by id we have specify what part of the route is going to be used for the id parameter so just like before it's going to be id okay so once again when somebody comes with a something similar with get items by id somebody comes with uh not get but put items slash id and somebody then this is the operation that's going to be honoring that route so how do we implement this so the first thing that we want uh that we want to do is probably find the item that we're going to be updating so what i'll do is i'll just say existing item listing item is going to be done under items list uh items list where item uh item.id is the id that we distributed the parameter and then again singular default right so if you have it i will find it right there now we found the item we're going to update it and to update it we're actually going to do at this point is just clone it into a new item with the updated values so we will say updated item is going to be the existing item with the name that is going to be update item update item dto dot name description date item dto that description and price updated in dto price okay so that creates a clone of the existing item and the in into updated item and that's the one that we're going to be updating into the list okay so now we'll do is we're going to find the place in the list that uh that has the item that we need to update so to do that we're going to say so the index of that item is going to be in the list find index okay so it's going to be existing item.id equals id okay so that finds the index on that list where the item is and then now that we have the index we're going to say items index equals updated item replaces that in the list and then like i said we will just return no content there's nothing to return okay so let's try this out so i'll do f5 once again start the web host and close this page and then i'll just refresh our swagger ui page and as you can see now we have our put operation here at the bottom and all the way to the bottom we also have our update item dto specified so i'll expand put this is going to require first the id of the item to update so to get an id i'll actually execute our get items route so i'll try it out execute and let's say we're going to update our antidote so i'll copy the id of the antidote collapse this and then back in the input i'll say try it out i'll put the id here and then let's grab a few of the properties of the antidote we don't have to start from scratch there collapse this and then i'll place those items here remove this comma and then let's say we want to update just the price and we'll say that the price the antidote is going to be let's say nine and i'll go ahead and do execute and as you can see in this time it invokes the api with a port with the put verb into this request url that includes the id of the item we get a 204 result meaning no content so as you can see there's nothing being returned here but the item was certainly updated and we can confirm that by grabbing the id of the item once again and going to our get items by id route we can try it out paste it there i'll execute and then you can see now we have the antidote with price nine so the update operation succeeded so finally let's add the operation to delete an item so let's minimize this once again stop and close and before adding our delete route just for completeness let me do let me add the comment here for our http post route which i did indeed didn't do uh this the post route is going to as we as we saw responds to the post verb and the browser is going to be like just items right so jose we have that comment over there now for the delete route uh is we're going to be using uh a method that is also be returning a action result just like in the boot case because we're not we're going to be returning no content here also and it's going to be delete and we're going to receive the only thing that we need to receive here is the id of the item to delete and we also have to respond to the http delete verb and again just with the we put we have to specify which part of the route we're going to be using for the id of the item to delete so that's going to be a id once again and here uh just like we did with update we need to find the index of the item to delete so i'll copy that line from put copy that into here okay and so once we found the index of the item to delete we're going to say okay so from the list remove add and we'll say index so that removes the item at that index location and then we will just return no content so again for completeness let's add a little comment here so when somebody comes with a delete verb and says lash items and then slash some id this is the method that's going to be honoring that that deletion so to try it out again i'll do f5 okay so back in swagger ui i'll refresh the page and as you can see now we have our delete route a little operation showing up here and so i'll expand that so we need an id to delete so let's actually execute our get items route try it out execute so we can pick something to delete let's actually delete this antidote once again so let's copy the id of the antidote and so i'll go back to delete try it out i'll paste that id and then i'll hit execute and as you can see now we're using the delete verve invoking the api we delete here's a url of the of the item that needs to be deleted and we got a 204 no content so as you can see there's nothing returned but the item should have been deleted so if i go i'll collapse this and i'll go back again to our to our a get items route i'll to execute again and as you can see the item the antidote item has been removed it's not here so delete succeeded so yes rest api seems to be working just fine um however you can try querying for an item that uh that does not exist and exit on an existing item or perhaps creating an item that does not have a name uh what will happen in that case so we'll need to do something about those those situations uh in the next lesson we will see how to properly handle these kinds of invalid inputs let's try a few of the unexpected scenarios that our microservice dress api could face from time to time so i have our catalog project open here and i'll just do a five to start a web server and go to our swagger ui page so here we are in the browser i'll go to swagger and let's start by getting the full list of items as we have them right now so open our get items operation try it out click on execute and here are the three items that we have available right now so let's say i want to query for one of these items the potion so i'll copy the idea of the potion i'll close this and then i'll actually go to our get is by id operation okay so i'll do try it out i'll paste id here but i'll actually going to i'm going to flip a one of the characters here i'll flip this one to two so this is an on existing item we don't have that available and i click on execute see what we get so what we're getting is a 204 result right which is not expected when when an item is not found in the rest api the expectation is that you would return a 404 status code or not found so let's see what's actually happening back in visual studio code see where we're getting this so i'll put a breakpoint in over here in organic by the operation and then i'll go back to swagger i'll try this again so i'll hit execute and here we are this is studio code so we try to find the item and of course the item is two we cannot find it okay so what can we do about this let's see i'll just stop debugging here close terminal and so really the fix is fairly straightforward here um what we would like to do is just check that if the item is null we will go ahead and return not the item but would like to return the not found a action result however of course uh intelligence is complaining here because uh we not found does not convert into item dto here right so here's where action result becomes super useful now we can say action result of item dto and that gives us the ability to return it in the either the item over here or the not found result over here in this case so as you can see we can return more than one type of result depending on the current situation so let's try that out i'll hit 5 once again i'll remove this breakpoint first and then i'll hit a 5. okay so here we are again i'll just copy this id and refresh the entire page should still be and not found items so get items by id i click on try it out i'll paste that id here and i'll hit on execute see what we get so as expected this time we get a photo for a result saying not found so this is the correct status code for an item that cannot be found in the in the rest api and likely we're going to have the same issue with our put api right so let's see exactly which apis will be impacted so not post but put is going to be impacted because it needs to find the item and likely the delete operation could also be impacted because it needs to again find the item before it can delete it so let's start by fixing put it's going to be pretty similar basically if existing item is no we will say not bound okay so that will do it for put and then in the case of delete what we're going to do is just that if index is less than zero so basically a negative number it means that we cannot find the index of the item therefore we have to say return not found okay so i should do it i'll hit f5 and see what we get i'll close this and and i will um yeah i'll copy that's this id one existing id once again and i'll try to do a put operation now so i'll try it out i'll put this id here and uh i'll put just something here for the for the body so some item some item description and price too so just to try it out and so i'll go ahead and say execute and as expected now we can get a 404 on that case not found i'll take that id once again and let's try out our delete operation so let's try to delete that an existing item see what happens so yeah as expected delete is also returning a 404 so we can now say that we're probably handling the case of not finding items in in our different res api operations now let's try something actually different so what happens if we try to create an item with some missing item properties right so let me collapse this and collect this and then let's go to post okay so i'll try to post an item uh let's say without a name we shouldn't be allowed really and let's say that this was really for our high potion which the description would be restores a medium amount of hp and that price was five right perhaps seven and so let's try to create an item with no name so go ahead and hit execute go down and 201 meaning create an action so it actually got created but look at this the name is nu and if we try to query for that item with this this id so let's do get by id try to query for it as you can see the item is is now in our collection and is with a new name and not only that let's see what happens if we try to create it with a negative number right so not seven but let's say minus seven what happened in that case uh so let's do execute and again it got created to 201 and then now we have this order id and so now this item actually has a a null name and a negative price so this is really bad so what what can we do about this situation um let's go back to visual studio code just open close and then i'll expand our navigation pane again so what we can do is actually do some model validation right so back to the dtos we need to introduce a couple of attributes to properly validate the inputs here and the details that we would care about in this case are both in the create and the update details so what we can do is let's say for the case of the name if the name is always required what we can say is just add this attribute here called required which might require a namespace import system company model data annotations import and that makes it so that name will always be required any time somebody uses this create iron detail okay and i'll also add it for our uh name name property in the updated identity and then also i'll do we can do something about the price so in the case of the price let's say that well let's add an attribute here and let's say that what we want to enforce is that the price should always be let's say between 0 and 1000g right let's say but we actually want to allow free items so they can be zero but definitely not negative and only up to a thousand so we can do is use a range attribute here and we can say here the minimum value which is going to be zero and the maximum value let's say it's going to be a thousand here okay so that makes it so that anytime somebody specifies a price here it has to be in this range that implicitly also makes sure that uh it cannot be null right but however i mean since if this is a value type decimal really this value can never meet dual so worst case it will be zero but with this we ensure that it has to be between zero and a thousand i'll do the same thing for our item detail hit save and now let's try it again so i'll hit a five okay back here and i'll go ahead and i'll just copy this and i'll refresh our page so let's go ahead and try to do a post try it out and so let's start first with no name so i'll say the same price is still positive but we don't have a name and let's try to execute this and see what happens so as you can see this time we do get a 400 but request error which is expected in this case and we do have a the proper validation message coming out of the the errors these errors array that is available now so one or more validation error secured status 400 and the name field is required so that's great and furthermore if we still want to use that negative number so i'll do 7 hit execute see now both validations have been performed so the name is name field is required and the field price must be between 0 and 1 000. you can also try using invalid input for our put api operation now and you should get similar validation errors in the next model we will learn about the repository pattern and we will stand up a proper database to store our catalog items in this model we will update our catalog microservice to be able to store and query for items that live outside of the service and into a proper database by the end of this model you will have a solid understanding of the following what is and how to use the repository pattern to store and query data how to use a mongodb database as the underlying data store of catalog items how to use docker to run infrastructure services like mongodb server what is and how to use the dependence injection technique for proper decoupling of dependencies and how to use the net configuration system to specify settings that could change across environments in this lesson we will learn about the repository pattern and how to implement a repository to manage the catalog service items in a mongodb database so what is a repository a repository is an abstraction between the data layer and the business layer of an application to understand why you may want to use a repository let's say that today we have the application logic of our service talking directly to our mongodb database however a few months or years from now requirements change and we need to switch to a different database provider given the way that things have been set up we would likely need to rewrite a good chunk of our application logic in order to talk to the new database which is pretty bad instead what we can do is introduce a repository this repository is the only one that knows how to talk initially to our mongodb database and is the only one that our application logic will interface with then if we ever get the requirement to move to another database the only thing that we would need to change is our repository but the application logic stays the same so the repository pattern is important because it decouples the application logic from the data layer and minimizes duplicate data access logic across our service we will be using mongodb as our database of choice for all the microservices in this course mongodb is a documentoriented nonsql database which stores data in a jsonlike documents with dynamic schema we will prefer a nonsql solution as opposed to a relational database for microservices because we won't need relationships across the data because each microservice manages its own database we don't need acid guarantees where acid stands for atomicity consistency isolation and durability which are properties of database transactions that we don't need in our services we won't need to write complex queries since most of our service queries will be able to find everything they need in a single document type and we need low latency high availability and high scalability which are classic features of nosql databases let's go ahead and implement our items repository before implementing a repository we will need to decide which is going to be the class that represents the objects that will be managed by the repository and that will make their way into our database the classes we use for this should not be confused with our details because we want to have the freedom of updating how we store the items in the database at any given point regardless of the contract that we'll need to honor with our service clients we will then give the name of entities to the classes that are repository use so let's start by adding a directory to store these entities so right click on play catalog service let's add a new folder let's call this one entities and inside entities let's add a new file and our main entity here is going to be the catalog items so let's just call this one item.cs and here let's go ahead and delete our namespace it's going to be namespace entities and now let's declare the class all right so our item entity is going to have a good which is going to be the id and let me ctrl dot to import the system a space it's going to need a name it also needs a description and we also need the price and finally we are going to need a daytime offset that's going to be the created date okay so now it's time to actually add a repository but before doing that we're going to need a nuget package the mongodb driver nuget package because this is the one that's going to allow us to actually interface with the bongodb database so to do that i'm going to do ctrl j in my keyboard to open the terminal and i'm going to switch to the directory where we have the catalog service so that would be a catalog service so then i'll just do net add package mongodb.driver so this will bring in a bunch of uh libraries that we're going to be using um for interacting with bungryb so and you can configure the the package was added if you click on play catalog service csprock you'll see that we have the new library right here okay so now uh let me just close this terminal and now we can actually create a directory for our repositories so i right click play catalog service new folder repositories and in this folder i'll create a new file uh again since this repository is going to be managing our catalog items i'll name it items repository that's yes and at this point i'll just close this navigation pane so we get more space let's add a namespace it's going to be repositories and the name like we said public class items repository okay in order to be able to interact with mongodb we're going to need a few class level variables here the first thing that we're going to define is actually a constant we're going to name it collection name collection name which is going to be the value is going to be just items so the collection name represents the group a a collection represents a group of objects in mongodb similar to us in a relational database you will have a table in mongodb you have a collection okay so the collection that we're going to store all these items in mongodb is going to be named items in our case now we're going to define the variable that's going to hold the actual instance of this mongodb collection so let's name this one read only i collection of item db collection okay so i'm i'm going to need to start importing spaces here so ctrl dot to import mongodb the driver and ctrl dot to import play catalog service entities like i said dvd collection is the object that represents our actual mongodb collection we'll add one more class level viral here to represent the the the filter builder that we're going to be using to build the filters to query for items in the mongodb so let's declare a filter definition builder of type item let's name it filter builder and we can get that from builders of item dot filter now that we have that we can go ahead and declare the constructor of this a repository so public items repository and here what we want to get is to actually construct the instance for db collection but before we can do that we have to start by using the client class which is the one that you can use to actually connect to the database here's where you declare how you're going to connect to mongodb so we're going to say client equals new client and here we can specify the connection string to connect to mongodb for now we'll just declare this connection string right here in plain text but later on we'll move this connection into a more to a more suitable place so it's going to be mongodb localhost 27 0 17. also in a future lesson we will learn how to actually stand up that mongodb server so that it actually lives in localhost 27017. now we're going to declare the object that represents the database the actual database where these catal guides are going to live so database equals mongol client get database and then the name that we're going to give to this database since this is the catalog microservice the name is going to be just catalog finally we can give get an instance for db collection and we can do that by doing database that get collection of item and then we give it the collection name that we have already declared okay we'll be using this divi collection object for a few a few operations in a moment now for the repository public methods we will be using the asynchronous programming model this will avoid performance bottlenecks and enhance the overall responsiveness of our service to take advantage of this model all fermenters will become asynchronous by returning asynctask and by using the await keyword anytime they interact with the database we will also use the async suffix on all the methods to surface the fact that the methods are asynchronous okay so the first method that we're going to implement is the one that's going to be able to return all the items in the database so let's name this one fully async task of i read only collection of item get all async okay so i'm using a i'm using a namespace here so like i said we need to return task to make this method async and i'm also using i read only collection here because really the expectation from the the point of view of the consumer is that we're going to provide a collection of items that the the consumer should not need to modify so this is a collection that should only be read right so this is a good api pattern to follow how with this collection of items so basically we can do return await tv collection then we can do find define operation and here since we are not going to really provide any filter because we want all the items we can just say filter builder dot empty delete sync to convert that list into an asynchronous list and then yeah that will give us all the items in the database okay so let's now declare a method that we can use to get one specific item from the database so i'm going to declare public async again task of item in this case and we'll name this method get async it's going to receive a good it's going to be the id of the item and i'm going to import the system in space for this okay let's scroll down a bit and then to be able to query for this item we need to create a filter so i'm going to declare a filter definition of type item let's name it filter and then we're going to use the filter builder to say that we want to build an equalitybased filter we're going to receive this this entity object where the entity.id should match the id of the of the parameter that we just received okay so that's how you can build a filter to find a one of the items based on id then we can just say return await db collection find that we provide the filter and we'll say we want to get the first item that we find so we're going to use first or default async in this case so that will find the first item in that collection that matches that filter let's now add a method to be able to create an item into the database so to do that we can define fully case in task create async receive our item that we're calling it an entity here and the first thing we're going to do is a quick check uh to make sure that the that receive parameter is not null so if entity is no we're just going to run a section argument exception and we're going to name and give the name of our entity parameter okay and then to create the actual item is as easy as saying um await the collection insert one async and then we provide right so that will go ahead and create the item into the database the next method we're going to implement is i want to update an item an existing item into the database so to do that i'm going to declare public async task of data is sync notice that both create and update are not returning really anything so the citation is that we just insert or update the item but we're not going to return anything back to the client um here we're going to receive the item to update let's call it entity that's the item to update all right and just like we did with create let's do a quick check make sure that we're not getting an old value here and now we're going to build our again our first definition to be able to find that item and i'm going to copy the one from get async just because it's a very similar filter the only difference here is going to be that we're going to rename this this parameter here to existing entity just to not confuse with the the entity that we're going to use to find the id so we're going to say we need to find the existing entity whose id matches the entity that we received that id so that's a filter to find the existing item and then we can go ahead and say weight the collection dot replace one async we pass the filter and we pass the entity that has to replace the existing item found by that filter and finally let's implement the mentor to delete an item from the database so we're going to say public acing task it's going to be remove async you find the id of the item to to delete again we're going to use a filter very similar to the one we use for get async so i'm going to copy that one once again so copy that that finds the item and then we can say weight db collection delete one async and we pass the filter yep that should go ahead and delete the item from the database and with that our itunes repository is ready so in the next lesson we will integrate it with our existing isis controller so that it can start creating items from mongodb it is time to integrate our new items repository with our existing items controller but before we can do that we are going to need a wait a way to translate our new item entities into our existing item dto specifically for the purposes of returning these ctos in our get operations in the rest api so there's a few ways to do this but one simple way that we can achieve this is by introducing an extension method so let's see how to do this we're going to right click on play catalog service and we're going to add a new file that we're going to name extensions that's cs let's add any space here namespace play catalog service and here we're going to declare a class that we're going to name those extensions and in this one we declare a public static method that returns itdto and this is because all extension methods should be should be static and we're going to name it as dto so this method is going to receive a current instance of an item entity okay and then let's import namespace control dot play catalog service ctos and play catalog service entities okay so the purpose is to just turn the item entity into the item dto and to do that we just have to do return new item dto and we're going to provide here the different parameters right everything comes from the entity so item id item that name item description item the price and item that created date okay so as you can see it's a very simple method that just turns an item into an identity we'll see how we use this in our controller so now let's open up that controller so controllers items controller and i'm going to close the navigation pane once again to have more space and the first thing that we're going to do is to actually get rid of this list we don't need it anymore and we're going to replace it with a variable for our repository so it's going to be private again read only because we don't want it to be modified after construction items repository and we're just going to say new so it's going to get constructed when the controller gets constructed i'm going to import the writing space here so let's start using this item repository here however since you remember all of the methods in itunes repository i are asynchronous methods we will also have to turn all the metals in this controller into asynchronous methods that way we can have the asynchronous benefits all the way from the controller all the way to the to the repository and to mongodb so to do that i'm going to turn let's start with get the get all so we're going to turn this into async task of innovable of identito and we're going to append the async suffix to this method let's import a missing treating tasks and now to return the items well this is what we can do items is going to be weight item repository get all async okay and then from that we're going to project these items into these item entities into dtos before we can do that we have to put this into a parenthesis and then we can say okay so from that let's do select and each of the item entities is going to be turned into a dto via our new astitu extension method that's there you can see how it how easy it makes it this extension method to turn an existing entity into a dto and then we just return those items okay so let's go to the next method so this is get by id so once again we will turn it into async task of action result of it and dto get item get by id async and then to get the item what we're going to do now is just wait i can repository get async and we provide the id and at the end of this method we can just return that item entity we have to say as dto so that turns the entity as into a dto let's now go for the post method let's scroll down a little bit so once again this has to be an async task of action result of identity and it's going to be post async task instead of doing this we're going to uh create an item entity in this case out of the properties of create identity so we're going to say bar item equals new item and we're going to start giving it the the properties values so create individual name description description and create a date uh here's where we're going to give the current date as the creation date of this of this item also remember this is not identity or this is just item okay i may need a name space here yeah empty disney space now we can go ahead and actually create the item via our items repository that create async methods and then we pass the item and finally we have to rename this method from get the id to the new name which is get via the async the one that we just renamed because that's where the created action should point to let's now go ahead and implement our boot method scroll down so once again we turn this into public async task of i action result put async and once again we have to do things a little bit different now so i'm going to actually remove this this whole block here and first thing we're going to do is find the item now in the via the repository so it's going to be existing item we're going to see it's going to be await item repository that gate async notice also how easy it is to actually interface with mongodb via our item repository without having to write the same piece of code once and again right at the filters and all that so we just got the item just like that and then yeah if you if we cannot find the item in the database in which case it will return no we want to keep returning not found just like before and here once we find the item we will have to just update these properties based on update item dto so that's going to be existing item that name equals update identity of that name existing item the description date identity of that description and existing item that price of the identity of that price and with that we can go ahead and say await item repository update async with the existing item and finally let's go ahead and update our delete method so we're going to say again async task i can result delete async and we're going to do a similar logic to find the item as we just did with update so i may just copy this piece here okay i'm actually going to remove all this paste that okay i'm going to say so yeah so var item is dedicated async if the item is no we'll say not found and otherwise we can go ahead and say weight item repository dot remove async with item that id and then one last thing that we may want to tackle here since we are making these changes is to actually um fix an issue a kind of a breaking change that happened in asp.net core 3 where if you try to do let me go back to post if you have to do a post and do create an action into a method that ends with async with an async suffix uh that's actually not going to work because at runtime uh sp netcore is going to remove the async suffix from the method and that will make it so that created action will not be able to redirect to the right place or to prevent to produce the heaters that it needs to produce and so there's an easy fix for that so let's actually make that fix right away so i'm going to back going to go back to explorer going to open startup and let's locate the section where we do add controllers in configure services inad controllers we're just going to add a little option here so it's going to say options and then we open and close braces and we're going to say options that suppress async suffix in action names is going to be false and with that at runtime uh asp.net core is not going to remove the async suffix from any any four metres and that will make possessing work just fine so a rest api is ready to use our new repository to store and query the items in the mongodb database however we still don't have an aqua mongodb database or even a mongodb server but that's a problem that we can easily solve via docker in the next lesson we will learn about docker and how we can use it to run the infrastructure components needed by our microservices in this lesson we'll learn about docker and how it can be used to run infrastructure components needed by your microservices so what is docker docker is a platform that provides the ability to package and run an application in a loosely isolated environment called a container here's how it works we start with our catalog service which as we know needs a database to store and query for items the piece of software that knows how to stand up and operate this database in our case is mongodb the mongodb server along with all the software prerequisites has already been packaged in what we call a docker image and this image is publicly available in a place called docker hub we want to download and run this image in our box and to do that we use the docker engine which is one of the pieces that you installed at the start of this model all docker images are guaranteed to run anywhere the docker engine is available to pull and run this image we will use the docker run instruction in our box once the image is run or executed it becomes what is known as a docker container a mongodb container in this case this is a fully working mongodb server ready to respond to the requests of our catalog microservice the catalog service will create a database via the mongodb container and will start interacting with it via the mongodb driver4.net notice that even when this container manages the catalog database the database itself does not live inside the container but outside of it to ensure that it is not deleted once the container is destroyed let's try it out to start using docker in my box i'll start by opening a terminal so i'll press ctrl j and then i'll also close our navigation pane just so we have a bit more space and the first thing that i'll do is i'll just type docker run to run a container and then i'll specify the demodifier so that we don't keep being attached to the docker process all the time and then i'll do rm so this we'll use so that whenever we stop running the container it gets automatically deleted so that we don't keep hanging it around in the box next i'll specify a name which is going to be just so you can put any name here but the idea is that uh you don't lose track of this a docker container because otherwise you get a random name and it's a bit hard to identify next we have to specify a port so we have to specify which is the port that we're going to be using to talk to mongodb the among the v server so we'll specify p 27 0 17 map to 27 0 17. so this means that in order for us to reach the mongodb container we can use port 27017 is the external port and then uh in order to to to get that mapped into the internal mongodb server we have to map into 27017 also so this port is the default port that mongodb uses internally and this just means that from the outside we open kind of a window uh in order to talk to the container via 27017 and then that can be mapped into the internal port where mongodb is already listening you could be using any port in the left side as really up to you we're just choosing a default map in there then we'll specify a volume the volume we're going to be using so that we specify how we are going to store the database files that mongodb is going to be using so we're going to say mongodb data colon slash data slash db so this section on the right side of the column slash it is tv is a default location where mongodb stores the database files so this mapping means that any time that the mongodb server tries to store files inside the container under slash data tv those files are actually not going to be written inside the container but outside of the container into this location called mongodb data which is part of our local localhost machine so it's outside of the container so this is the way that we can prevent those database files from being deleted anytime the docker container gets also deleted and finally we'll specify the name of the docker image that we want to run in this case is now i'll hit enter i'll perhaps expand this a little bit more so at this time uh docker is pulling the all the layers of of the mongodb docker image into my box okay so layer by layer it gets unloaded uh just the first time uh and this this may take a while but the second time that you do this and any subsequent time this is going to be much faster because the image is already there so if i did if i did that again it will run instantly then we can confirm that the docker image is actually executing by just running docker ps as you can see the docker image is up and running it's been running for 14 seconds right now okay so now we can try running our res api against this soccer container and see how that goes so i'll hit a five here and i'll go to our swagger page so the first thing that we can try just to verify that there's nothing here because it's a brand new database is our get all items um operation so i'll try it out i'll hit execute and as you can see there's nothing in there the databases is all empty so let's next let's try creating something so i'll go to our post operation try it out and let's let's try to create something here so we will go back to our back to our potion sample so i'll just name this potion and this is going to restore a small amount of hp and the price is going to be five and with that i'll hit execute and as you can see the item has been created we got a 201 response code create that action here's a response body and we also got the location here to find our item so in fact we can copy the this id of this item and we should be able to use our get by id operation to find it so i'll collapse this i'll expand get items by id i'll try it out paste the item here execute and certainly we can find the item so the item has been stored into the database but now if you wanted to know how this item has been stored into the mongodb database there's an easy way to figure that out so i'll go back to visual studio code and then i'll just stop and close this and what you can do is use a mongodb extension for visual studio code so to install that just go to the extensions hub on the left side look for mongodb and should be the first hit on the left side so i click on that i'll click on install and now there's a new icon showing up on the left side for mongodb which i'll click now and then i it should connect straightforwardly into the mobile dvd database just by expanding this node for localhost 27017 since it's the default port it just connected so i'll expand this and as you can see there's a catalog database available right there so it has been created if i expand that there is an items collection available this is the one that we will be storing our items and then i'll expand that further and as you can see there is one document already created into the catal database if we expand that we can see that there's an item in there however if we try clicking clicking on it let's click on it but you can see you can see most of the members of the created item but some of them are not easy to recognize like for instance the id is not the gui that we were expecting and the created date is a bit hard to read the other elements are there so potion description and price so how can we get a better a more friendly uh the more friendly representation of these items like id and created date so ideally we want to see something more easily recognizable so there's actually an easy way to to fix this let's go back to our explorer and let's go to our startup class okay once again i'll collapse this so to fix the json representation of our items we just need to register a couple of mongodb serializers we can do this in the configured services method of the startup class we will talk more about the role of startup in acefinite core apps in next lesson but for now let's just think of your services as the place where we register services that can be used across entire application so let's scroll down a little bit here we are in configure services and what i'm going to do is just expand this a bit and i'm going to add visual serializer and for this i may need to import namespace mongodb that based on that serialization that register serializer and here we're going to provide the serializer we want to use in this case it's going to be new good serializer and then i'll import mongodb bsun serialization serializers and then it's going to be and type and then import one more namespace that string okay so that means that anytime we store any document into mongodb with a good type it will be stored actually as a string as opposed to the representation that we're looking at a moment ago and we're going to do pretty much the same thing for our the datetime offset so in this case we're going to say so instead of quick serializer we'll use date time offset serializer and then this line now says that anytime we store any document with a datetime offset a property it should be stored that probably should be stored as a string so save that and that should be enough to fix our representation of the items in there however uh to to not mix things what i'll do now is i'll actually delete our existing database so that we can recreate it with the proper esterization type so i'll close this here and i'll go back to our mongodb extension and i'll right click in the catalog database i'll say drop database i'll type the name enter and if we refresh this there should be no database available anymore okay so with that let's hit f5 once again okay back in soccer ui let's see if we still have the post available here yes we have so i'll just refresh the page and i'll go back to post and once again we should have no items so actually i'll go to get all items try it out execute so there's no items because a new database has just been created because we deleted the previous one so back into post i'll try it out and i'll paste the what we typed a moment ago so it's a potion price five restore small amount of hp and i'll hit execute and once again the item has been created with this id and this time we'll go back to visual studio code and let's see how that got stored so i'll refresh this right click refresh expand catalog items documents and as you can see the id it already looks like a good and if i click on it and i'll close this a bit now we have a much friendly representation of the item the id is a proper good and the created date is a daytime offset that we can actually understand so that's the effect of using these serializers in there so let's continue using our res api let's make sure all the operations are working properly so as we saw we just created this item and if we use get items by id we should be able to find it so let's confirm that paste it there execute so yeah indeed we were able to find the item now let's try an update on an item so to do that let's use the put api so i'll click and expand this i'll say try it out let's grab the actually the id of that item once again so it's over here here's the id so i'll paste it here so we're going to update that potion and then for the for the elements of this of this potion let's copy also a few of the existing elements so i'll copy this from our gave id route into here actually inside there i'll remove this extra comma and so the only thing we're going to define here is just the price of the potion so instead of being five i'll say it's going to be price seven and i'll hit execute i've got a 204 so no content successful no content so this means that the item has been updated and to confirm that let's go back again into our get by id route let's execute again and as you can see the price has been updated so output route is working just fine and for the final exercise let's try to delete this potion right so i'll go ahead and copy again the id of the position and let's collapse this and that and let's go to the delete route try it out paste here hit execute 204 no content and it is a success so the item should no longer be there so i'll try to actually get this item by id once again let's see what happens i suspect it's 404 it can't find the item and in fact if we go to get all items there's nothing there so the item was deleted okay so at this point we have a fully working res api with all the basic cloud operations that's working against a mongodb database but we still need to polish a little bit the code base that we have so far so in the next lesson we will learn about the dependence injection technique and the net configuration system in this lesson we will learn about the dependency injection technique and the net configuration system what is defense injection to understand what dependence injection is we can start by thinking about a class that uses some other class for instance our items controller uses the item's repository when you have this relationship where one class uses another class we say that this second class is a dependency of the first class now if instead of constructing the item's repository object directly as we are doing so far we receive an instance of items repository in the items controller constructor then we are injecting item repository into itunes controller this is what we call dependency injection but also notice that the constructor is not exactly receiving an instance of item repository but instead it receives an interface called items repository this relates to what we call the dependency inversion principle the defensive version principle states that code should depend on abstractions as opposed to concrete implementations let's bring again our class and one of its dependencies dependency a currently the class depends directly on dependency a however we can change this so that the class instead depends on an abstraction which in the case of c sharp is an interface and then we can have the dependency depend on or implement the interface why would we do this well by doing this our class implementation is decoupled from the dependence implementation in such a way that if we ever decide to switch to a different or updated dependency our class does not need to change at all the only thing that the dependencies need to do is to implement the interface that our class depends on so by having our code depend on instructions we are decoupling implementation from each other and this also makes our code cleaner easier to modify and easier to reuse now that our code is decoupled from these dependencies we have a new problem how and who is going to construct the dependencies imagine once again that we have our class which depends on an interface implemented by dependency a since our class cannot construct the dependency directly because it only knows about the interface a third actor comes into play which is called the service container which in asp.net core is known as iservice provider loading application startup which typically happens in serap.cs in asp.net core apps we would register our dependencies with the service container and this one in turn builds a map of all the register dependencies then eventually when our class needs to get constructed the service container first finds constructs the dependency or reuses it if it already has been constructed and then injects it into our class as it creates our class instance this is very powerful because you could even have dependencies that depend on other dependencies but as long as they all have been registered with the service container they will all be resolved properly whenever any class needs them during the application life cycle let's also talk about configuration at this point our service is able to talk to our mongodb database via the host and port information that have been hardcoded in our service implementation however this is not ideal since eventually the mongodb docker container will live outside of our local box where localhost will likely not make sense and port 2717 is not guaranteed to be available luckily afia net core supports a few configuration sources that are able to store and provide such configuration details to our service when needed one of the most popular sources especially for local development is the app settings.json file where we can store all sorts of computational information that we expect could change across environments like the database host and port and the good thing is that just like this one there are several other sources like command line arguments environment variables local secrets and even the cloud all these configuration sources are automatically read for us and loaded into the configuration system during host startup which is configured in the program cs file in asp.net core applications and from there we can get access to them typically in our startup.cs file let's now update our catalog service to take advantage of both the penis injection and the acl net core configuration system in order to start using dependence injection in our microservice we will need to start using interfaces as opposed to concrete types when constructing dependencies let's start by updating item repository so that it implements an interface that we can use in ads controller so let's go to our repositories directory items repository and then we want to do is to extract the interface that represents items repository and we can do that by clicking on item repository and as you can see there's this yellow light bulb over here you can click on that one and then you can click on extract interface by doing that as you can see the full skeleton of the interface has been extracted out of the item repository class and item repository is now implementing items repository our new interface we also want to have the interface living in its own file just to follow some good code organization across our microservice what i'll do is i'll click on i items repository i'll click on the light bulb and then i'll click on move type to itemsrepository.cs now i add the repository leaves in its own file over here on the left side i add repository in the same repositories directory and so with that done we are able to start doing dependency injection of item repository into the access controller so i'll open the controllers directory i'll go to items controller i'll scroll up all the way to the start of the class and i'll start by updating our items repository definition here so that we actually use i item repository as opposed to item repository and i will not create an instance right there it is time to introduce a constructor for this controller so i will do public items controller and here we are going to inject the item repository dependency so i items repository item repository and here we'll just do this that oh sorry this that item depository equals item repository so just by doing that uh at the repository has been injected into ideas controller now the same way that we are doing this we also want to use dependency injection in items repository itself so let's go back to that file because we don't want to be constructing the mongol client like we're doing it here we want to just receive an instance of our of our mongol database or imongo database directly as appendix injection so what i'll do is i'll just declare in itunes repository and imongo database object and we'll say database and with that we'll get rid of these two lines so now eisenhower repository is ready to receive an instance of database via defense injection however now that we have removed those lines we need a way to actually construct this database object and configure it so let's go into the configuration part of this now to configure the the host and the port that our service needs to connect to what we can do is to declare these settings in our app settings.json file so let's go to app settings.json and here's the ideal place for you to declare these kind of configurations that could change with different environments so what i'll do is i'll open up another section here let's call it mongodb settings so we'll open up a section i'll put a comma also here and then the first setting is going to be the host which in our case is we're running against a a server in our local machine it's going to be just localhost and the port is going to be 27 0 17. the default port and the one that we've been using in our docker container we are also going to add another settings section to define our service name this service name is going to be used across a few places in our microservice so let's declare that just on top of mongodb settings we will name it this section is going to be service settings service settings and we'll just declare one property here which is going to be service name which in our case since this is a catalog service we will just put the value of catalog okay so now we have a setting for the service name and for the mongodb host and port now the thing is how do we consume these settings in our codebase so there's a couple of ways to do that but i think the most straightforward way is to define a class that represents each of these two settings so that then our codebase can start using them right away so to do that what i'm going to do is just right click on play that catalog service or create a new folder that we're going to naming settings and in this folder i'll declare classes for both service settings and mongodb settings let's start with mongodb settings actually and i'm actually going to copy the name of the settings so to make sure that the class that we create here matches exactly the name of mongodb settings in there so i right click new file mongodb settings dot cs basically namespace going to be play catalog service settings and let's declare our class mongodb settings and just as we just did it should have properties for host and port so let's declare drop string host and prop string for tactile this should be an integer so prop import and then since we are not planning to change these settings after the the microservice loads we will switch from this this setter from set to init so that will prevent any anybody on any piece of the code to modify the values after they have been initialized next we're going to also declare another property kind of a calculated property that's going to define the connection string to mongodb so we're going to declare public string connection string and we'll do a little bit of string interpolation here where we're going to declare mongodb and that's going to have the host import so the host comes from our host property and the port comes from our port property okay so this is what we call an expression body definition so it's a property defined directly by the value on the right side right so we have a connection string there the next thing we need to do is define a type class for service settings so i'll copy the the name of service settings here and then again alright click settings new file service settings dot cs let's declare again namespace catalog service settings public class service settings and the only property that we have for this one is the service name so prop string service name and again this will be in it now that we have all this defined it's time to start constructing all these services registering i'm constructing and registering and registering and constructing all these uh services that we'll be using for depends injection and also taking advantage of configuration so to do that we'll go to the startup.cs file and i'm going to collapse this to get a bit more space so we can see and the first thing that i'll do is i'll go to the top of the startup class and i'll define a variable a local class level variable for our service settings just because we'll we will be using it in a few places across classes subsequent lessons so private serv service settings service settings and i'll have to do control dot to import play catalog service settings all right and then just before adding controllers i'm going to open a section here where first we're going to retrieve the value of those service settings so we're going to do is service settings equals and here's where we access the net configuration system where we'll be at the configuration property that we have available right here at the top configuration so we're going to say okay so configuration we're going to get section so we want to get the section that has the name of our service settings class so this is what we wanted to make sure that the class is named exactly as the name of the configuration and what we have got in that we're going to turn it into the actual type so we're going to say that get service settings there so with that we are digitalizing the value of several settings that has already been loaded into the temp configuration system into this service settings variable here the next thing we're going to do is to construct our mongodb client to do that we're going to be using our services collection so we will do services which we receive in the um as a parameter to configure services we're going to say at singleton uh add singleton allows us to register a type or an object and make sure it makes sure that there will be only one instance of this object across the entire microservice in this case so any class that needs it will get this one instance so it so they can use it so here we're going to receive the service provider okay so now we'll open an expression here and i'll close it this with that and just like we did with service settings we're going to now define or retrieve our mongodb settings so i'm actually going to copy this section here and we're going to say this is going to be mongodb settings okay so is configuration get section name of mongodb settings and then we will again convert it into the actual mongodb settings type now that we have the settings we are able to construct the client which like i said before is the the class we need to use to actually connect to mongodb so we will say client is a new client and i'll import mongodb driver here and here what we want to pass is the connection string so to pass the connection stream we will do mongodb settings dot connection string and finally now that we have the bongo client we can get the instance of the database object that we care about so we will do return client get database and then what's the name of our database well the name of our database is going to be the one that we defined for the service name service name is catalog our database will be just catalog so service settings that service name and that's it so with this uh with this section we have defined a singleton object that represents a an imongo database that's going to be injected as remember into um items repository over here is going to be landing over here i'm on the database so here's where we're constructing and registering it with the service container and then one more thing that we need here is to uh also in register the items repository dependency so we're going to be doing services that add singleton and then we will use our new i items items repository interface and then i'll import the play catalog service repositories namespace and then the concrete type is going to be items repository all right so this is this registration is a bit different than the previous one because the previous one in the prison we're cons explicitly constructing our mongol client and the mongol database before registering it with the service container well in this case we're just declaring which is the type that we want to register and which interface implements and the exponential runtime will take care of constructed that instance whenever it is needed so we should be ready to try this out but what i'll do is i'll place a few break points so we can see how things start lighting up as they do so i'll put a free break point so i'll put one over here then i'll go to item repository and i'll put one in the constructor over here and i'll also go to our items controller and i'll put another breakpoint here and now i'll hit f5 okay so we can go to our soccer ui page i'll go slash swagger and of course we don't have anything in our database right now but regardless our servers will need to construct all these dependencies to be able to figure out that this is actually no items right now so i'll open up our get all items operation i'll click on try it out and then i'll click on execute now back in vs code and now collapses a bit we are now in our startup file and notice that we right away we are entering into the add singleton section here this is because uh so there is one or more services that need this imongodb objects so if we inspect the value of mongodb settings we can see that we already have defined the host port and the calculated connection string is right there and that's what we are using to fit into the client connection string we should also have a value for service name here from service settings has been read from configuration and it's been used to get the database form that we're going to be using this database is being will be constructed the first time and the next time it will be just reduced so i'll hit continue here and now we are into items repository which now is able to receive retrieve that instance of the imongo database object that has been constructed and it's been injected here and it is via that one that is going to be able to retrieve the items collection that's going to be used across the is repository then i'll click continue and now we are in the itus controller which is not able to now able to retrieve to receive that injected as a repository that is going to also be been used be used for all the operations i click continue and we're back into play catalog service the socket ui which of course it says there's no items right now but we know we can easily go ahead and start creating items updating items and all these things with the swagger ui but yeah so depends injection is configured and the configuration system is enabled too so we have reached the end of this model with a fully working decoupled and configurable microservice that is able to store and guided for your catalog items in a mongodb database in the next module we will introduce our second microservice and we'll be learning about the multiple challenges of having microservices talk to each other this module is an intermediate step to get ready to build our future microservices we will learn about a few new tools that will help you as you start working with more microservices and we will build a useful library that we will use in future models here's what you will achieve after finishing this model you will learn how to use postman as an alternative to swagger ui to interact with your microservices you will generalize the items repository so that it can be used with any future entity you will create a nuget package where you will place all common classes that you would like to reuse in future microservices and finally you will use docker compose to simplify how to run mongodb and the multiple infrastructure services to be used in future models let's get started in this lesson we will learn about postman which is a popular api client that we will be using starting with this model postman will allow us to interact with our microservices res apis without having to open a browser to navigate to the swagger ui page of each of the services in addition it will offer us a few additional capabilities that will prove useful across this course the only additional tool required starting with this model is the postman client which you can get at this location let's get started let's go ahead and install postman i'll go to the postman download page at postman.com downloads and here i'll just scroll down a little bit i'll click on download the app i'll pick my parent system and that will start download in the same way depending on your operating system you can choose the mac os or linux version this should take just a few seconds okay so it's downloaded i'll click on the installer and yeah the way that installer worked for pulseman is that it will just pop up this screen here so it's already installing the application uh it will take a few seconds and then the our the postman ui will just pop up in your screen and here it is and so at this point you have the option to create an account with most men if you want to keep track of your collection settings and a bunch of things that you may be interested in but in our case we really don't care about that at this point so i'll just click that link at the bottom side here skip signing in and take me straight to the app so i'll just click on that and then we are in the postman uh user interface the first thing that i'll do here just because i don't like this theme at all so i'll just go to settings over here settings teams and then i'll switch to the dark emote setting okay so now that we have postman available let's go back to our catalog service and this code and let's start waiting for its several apis so let's minimize this i'll close this browser and yeah here we are in the catalog service and then yeah i'll just do f5 all right so as usual the browser opens but this time we are not going to be using the browser we are going to go straight into postman over here and here uh what you can do to start creating your rest api is uh if you have the launchpad open like me you can click on create a request over here or if you don't have it open you can click on this plus button to open a brand new tab in this tab what you want to do the first thing you want to do is figure out which is the verb that you're going to use for your res api if you click on this dropdown you're going to find a bunch of http verbs for the different operations so let's say that we want to start by doing a get uh so click on get and so that we want to get the list of items in our catalog api uh so then you want to type here the url of the address api and if you don't remember the the host where you're running your web server you can easily find that out by going back to visual studio code and here you can find that that url either right here in the debug log where it says now listening on is right here or you can also find it if i scroll down this a bit and then you open properties launch settings.json is right here close to the bottom where it says application url is over here so https localhost 5001. so i'm going to copy that and back into postman and so i'm going to paste that over here and then what you want to do is add the route for our controller so once again backing visual studio code if you open controllers iris controller you're going to find a route right here so router is items to copy that back into postman and i'll say slash items and with that you can just hit send and that's going to query the rest api now if you get an error like the one that i'm getting down here which says ssl error unable to verify the first certificate this is actually expected is a default verification for the certificate of your web server since we are using a selfsigned certificate that comes bundled with asp.net core that's not really a friendly certificate for postman but it is okay to get past that verification because it's just a local web server for development purposes so what i'll do is i'll just click on disable ssl verification and that's going to go ahead and i'll just close this and that goes ahead and queries the rest api without issues of course we don't have any items available in the database right now so that's why we see an empty array over here but we can actually try out to create a brand new item and to do that what i'll do is i'll click on the plus icon over here which opens a new tab and i'll switch from get into post and once again i'll paste our our entire route here so i'll copy from get i'll paste it here in post and then we want to do is go to the body section over here and we want to choose raw and at the end of this section i'll pick json so i'll open up this and here we go where we can define the body that we want to send to this post request so i'll open up a section uh as a json section here and i'll start typing the elements for creating a in this case uh an item so if you remember the the elements are a name so we need a name and let's say we go back to our portion example so i'll just say potion then we need a description a description is going to be restores a small amount of hp and finally we'll set up a price which is going to be let's say five okay so with that done i'll do this i'll go ahead and hit send and as you can see the item has been created okay we have an id and we if we wanted to we can now go back to the get tab here and we can query for items once again so i'll click on send and now we can get items so just like this you can keep going on and using the rest of our rest api operations by opening new tabs and opening and using the different verbs over here however each of these times you'll have to remember what to put exactly on the on both on the url and in the case of pause for instance uh the body and the elements that you want to use uh for the uh for the for the payload to send in that body right uh so what if you don't remember exactly what to put in all these cases so what i'd like to do is just show you another way to do this to simplify a little bit this this oral process so what i'll do is i'll just right click here and i'll close close all tabs so actually i'll say cancel let me close this down save close that so one thing that you can do if we go back into our browser over here is we can go ahead and find the open api specification for our api so if i go to slash swagger hit enter we're back into our soccer ui page but this time we're not going to use any of these methods we're going to do is click on this if you can see this swagger.json link over here i'll click on it and this opens the open api specification so this describes the entire res api in a standard way so what i'll do is i'll copy this entire url and then i'll go back to postman and i'll go into the import button over here i'll click the link section and then i'll paste that url over here click continue and finally i'll just say import and now if we go into the collection section over here you're going to see that now we have a a description of our play catalog service listed here with all the requests so if i open this and there's the items the items route and if you open that you can see that we have routes a forget and for post and also if we want to go by id we can go ahead and get an item by id we can do the put which requires an id and we can do also the delete so this time if you want invited to get a ghetto items what i can do is just click on get items and then that's going to open a a tab with an already filled in verb and url to go ahead and request the items however you're going to notice one new thing here which is the base url so the visual represents uh really the root of your or where you're hosting your res api at this point so this is the localhost 5001 section so postman just doesn't know that information just yet it just knows about the routes and the payloads so to fill in this this variable here base url what you can do is go to back to play catalog service over here click on these three dots click on edit and then you go to the variable section here and then you want to put a value for for current value so what i'll do is i'll just put https localhost 5001 okay i'll also put that in initial value this is what's somebody else that wanted to reuse your postman collection it would have as an initial value if they wanted to so i'll just keep the same value for both of them so then i'll just hit update and now if we hov a hover over base url you can see that now we have the result value being popup there uh for our res api so now i can go ahead and hit send and once again i get my items but more interestingly if i wanted to do a post this time i can click on post and then again the the url the birth is filled the url is right there and the body is already prepopulated with all the elements required for this api let's actually try to do a put so i'll go ahead now into put and again the url is prefilled in there we want to do is to in this case first we need the id of the item which we can get from the get items tab here so i'll just copy that id back to put and i can put the id right there and then in terms of the of the body i can go to the body section and like i said it is prefilled so i just have to put the elements for this body so i'll actually just copy those elements from here okay and now do a proper indentation and so here's where we can go ahead and update something about this potion so i'll just update the price again so i'll say seven and then we're going to click on send and we got a response uh 204 no content meaning that it succeeded and so now we can actually try let me copy the id of this item we can try our get buy id api and then again the url is prefilled i'll just paste the id over here i'll hit send and there it is we got a our potion so as you can see it is pretty handy to just import the open specification of an api specification into postman and be able to be able to quickly very quickly start working with your rest api imposement now a few other things that are available in postman as opposed to our previous swagger ui page is things like for instance of course we have the the concept of these collections which in fact you can actually export if you wanted to and share this with somebody else in your team or some of your teammates you can easily export this collection and you will do that by clicking these three dots and you can click on export and there's going to be a few options for you to export this for somebody else then also we you have a this this tab over here that says history this will show the history of all the previous implications of your res api so if you wanted to go back to something that you did in the past with the specific payload that you did and url uh you can do that so this is going to keep a long list of all the the queries that you've made to your api across your different sessions there's also this concept of environments over here which you can use to define the different environments where you want to invoke your request api so if eventually you're not just running in your localhost machine but perhaps you have deployed this to some a cloud environment you can define variables over there so that you don't have so that for instance device url automatically changes as you change the environment that you're specifying over here that way you don't have to keep opening more and more tabs for the different environments there's also the ability to specify authorization options over here for the different authorization types uh so that you can for instance generate a generate and use uh authorization tokens to call your res api if your recipi is enabled for that that's actually something that we'll look at in a future a model okay so now that we have done that uh one more thing that we want to do is to since we are not going to be using post one we don't really want to be opening browsers all the time so how can we prevent the browser from uh keep opening every single time so let me just go back to the browser and i'll just click close this and then i'll go back to visual studio code and let's stop and close this and what you can do is to go back to we go to explorer and we're going to go to that vs code launch.json and you want to look for this section that says server ready action so this section here is the one that visual studio code uses to define if they wanted to open a browser after something happens with the web server in this case it's just looking for the message that says now listening on so when it finds that it knows that it needs to open the browser so in our case we don't want to open browsers anymore we'll find with postman so we're just going to remove this section delete and now if i do f5 okay no browser is going to open we just stay here uh but as as always you can just go to postman and start creating the api like we already did okay so that's it for this lesson and in the next lesson we will start extracting a few of the classes that we are using in catalog microservice into some shared components that we can use in our future microservices in this lesson we will learn about the need to reuse common code across microservices and how the nuget package manager can be used to package and share code across services in a straightforward way one of the things that you will likely realize as you start building more than one microservice is how much code starts getting repeated between each service implementation for instance our catalog microservice currently has a repository implementation for querying and storing data in its mongodb database it also has a couple of settings classes to more easily use the different service configurations that are stored in our app settings.json file eventually we will also add classes to interact with our service broker code to add instrumentation to the services and likely some more code that is not directly related to the purpose of the microservice the problem with this is that as soon as we bring in our second microservice the inventory service we would likely need to copy to it that same code with very little modifications this is time consuming and goes against the don't repeat yourself principle which states that every piece of knowledge must have a single unambiguous authoritative representation within a system which in our case means that our common code should live and be maintained in a single place therefore we could be tempted to keep our common code in one of our microservices and have all the other services simply reference that project to get access to the common code however this is not a good idea because microservices should be independent of each other to ensure each of them can evolve quickly and have no ties to the internal implementation of others we can solve this problem by introducing a new library project that we will call the common library and then we can extract all the common code into it the common library becomes the single place where we have all the code that is not specific to any microservice and therefore is the single place where we will perform any updates to it when needed but then how can we make the code in this new common library available to our microservices we could have our microservices add a direct reference to the library project file but that's not a good idea because as new members join our team each of them might want to work on one microservice or the other or even in the common library and therefore they will only graph the code base for the project they are interested in but not the code basis of all projects all the time plus eventually each microservice and the common library should get their own independent source control repository where they can be tracked and built independently so if the microservice projects can access the common project directly what can they do here is where we can use nougat which is the package manager for dotnet with nuget we can execute a simple command like dotnetpak to bundle all the output files from the common project into a nougat package another package is nothing more than a zip file with a new pkg extension that contains all the files that are to be shared with other projects now each of our microservices can reference the nougat package to get access to everything that the common library has to offer and the good thing is that microservice projects don't need to know where these nuget packages are hosted we will initially place the package in our local machine but eventually you will likely want to host them in a cloudbased location either accessible just by your team or by anybody on the web the important thing is that regardless of the location you won't have to change how the microservices access the common code with our new common noked package our common code is now maintained in a single place and the time to build new microservices is significantly reduced in the next lesson we will extract our current common code into a new common library and we will produce our first nuget package that the catalog microservice and every filter service will be able to reference to get quick access to the common code if we take a look at our item repository class over at repositories items repository we will notice that there's a lot of code here that we will need to reuse in future microservices and the same goes for our settings classes over in the settings directory mongodb settings service settings we can certainly reuse these in future microservices but before we can move anything to a new shared library we will need to do some good refactoring to keep the generic pieces separated from what's really needed in the catalog microservice so let's start by looking at our items repository and if we take a closer look at what's going on here there's one piece that's really repeated a lot across this class and that is the use of the item entity the item entity is being used uh in several cases like for instance in ghetto lacing is being used to return the items that are going to be queried and we are also filtering by the id of this item in both in engage async method and also in the update async method will filtering by id and also in the remove async method so we need to find a way to generalize the use of this entity so that it can be used in like i said in a more general way in this repository so let's actually go to the item entity so right click go to definition but what we're going to do here is to actually extract an interface out of this item class uh to nail down narrow down the pieces that we really need to generalize about the item so we're going to do is just click on the light bulb and say extract interface and now we have the item interface here that our item class is implementing however we don't want to call this interface i item we actually want to call it i int and this ai entity is what our item class is going to implement but also we don't want to have all these properties in the interface but only daily having the id will be good enough to be used in the repository class we're going to implement now we also want to move this interface into a different file so i'm going to click on the light bulb and i'm going to move the type to indit.cs okay so now we have a i the item entity that implements i entity that is in the i entity.cs file over here now what we're going to do is to before going back to the item repository let's go to the items repository class and see how we can generalize this so to start with we don't want this class to be about just items anymore but about a generic type and the way that we can do this is to by renaming this interface into uh instead of iot depository is going to be i repository and it is going to be off a generic type that we're going to use name t where t represents the actual entity that's going to be used in a specific microservice so this t will add a constraint here where t is has to be and i entity the interface that we just defined so whatever we use for t it has to be a class that implements the identity interface so now that we have that generalization we can say that all of our methods actually use this this t type so for instance instead of having item here we're going to name it as t and the same the same way we're going to do for the item that's going to return in general lacing the item does return in get async and also the item the entity that's received in updated sync okay so with that there's no longer a mention of the item type anywhere in this interface so with that done we can now go back to our items repository and also generalize it to represent a more generic repository so instead of being an items repository this is now going to be a repository that is going to be off some type so again we're going to use a type t to represent the actual entity that's going to be managed by this repository and also our repository class now needs to implement the i repository of the interface again where t is an i entity okay so let's also rename the constructor to be repository and let's start changing this so that it actually to start removing everything related to item from this class so one of the things that we have to get rid of is this constant that is the collection name items uh since this is not going to be just about items anymore let's remove it and what i'm going to do is just copy collection name just the name of the var for the constant and remove it and now we are going to receive that collection name as a parameter in the constructor so we're going to receive string collection name so that's a collection name that's going to be used when we try to retrieve a collection from mongodb from here on okay and so now we need to start moving forward and start analyzing things so let me just get a copy of t and so anywhere where we find item we want to replace it with t so this is a db collection of t filter builder of t builders of t dot filter and we get a collection of a t a i t entity when we do get a lacing we have to do t again and again when we do the filtering so get is of t d over here it's all generic also create async should be t update async should be also t filter definition of t and notice that since our actual since our interface has the id property it doesn't really care that it doesn't know what's a real item as long as that the real entity sorry as long as that entity implements a identity it is able we know that there's going to be an id property a quick id property that we can filter by and finally let's change our remove async to also deal with just with t all right so just to confirm let's make sure we don't have item anywhere in this file anymore yep there's no more item here so let's also rename the file by the way so this should be mango repository and this other file here should be a repository and with that done it is time to start fixing all the references to our repositories so let's start by going to our controllers class items controller and let's fix things right so this is no longer an iates repository it's just and i repository of type item and that is what we are going to be receiving in the itunes controller in the constructor here okay next thing that we need to do is to fix the way that we are registering the repository in startup so let's open up startup and let's see how we are registering the repository over here so this is what we're doing today at singleton i attend repository item repository so we will switch to a more a more concrete way of defining this singleton because now we need to specify a parameter as an input to the repository so remember in manga repository now we are receiving a collection name so we cannot just just expect to all parameters to be injected automatically by the service container for us so we need to be more explicit so let's update the repository registration to start with we are no longer using the item repository interface we are using a repository of type item and let's see if we're missing something so let's add the service entities namespace so it's another repository of item we will notice is define an actual class as a second parameter here and then we have to specify this service provider service provider just like we did in the other at singleton call let's open braces here and now before we can create the instance of the mango repository first we need an instance of the imongo database because remember we actually registered an imongo database in the previous singleton call so how can we get an instance of such a registered service so that's where you can use the get service method of the service provider so just like this so bar database equals service provider that get service i database okay so anytime that you need to get an instance of a service already registered in the service container like we did with imongo database uh you just you just need to call get service on service provider and this will work as long as that service has been registered before the call that you're going to make here and then having that imogo database instance we can now return our new repository of type item and then we need to provide two parameters first one the database the one that we just got and then the collection name that so far is being just items okay so that should do it let's make sure everything is building successfully so i'll do ctrl shift b and indeed everything is building just fine so at this point we have generalized our repository class so that it can be used with any type of entity however it feels like we're writing too much code on startup to register the mongodb related classes because look at this we have to do register serializers we have to do the singleton registration for the client for the database and then the other singleton for the repository so in the next lesson we will introduce a couple of hand extension methods that will simplify things quite a bit for this and for future microservices so let's take a quick look at everything that we have to do in order to use our mango repository so far so here i am in a startup class and the first thing that we have to do is register the the bson serializers in order to change the way that we store codes and date times then we have to get the mongodb settings the the movie settings section for an app settings the json in order to construct our client and then we can create our imongo database that we registered as another singleton and then finally when we have that we are able to retrieve that imongo database and then construct that repository for the items collection so let's see how can we simplify all these lines to make the life of future microservices much easier what i'm going to do is create a new extensions class inside the repositories directory so i'm just going to right click here i'm going to create extensions that's yes not to be confused with the other extensions that we have over here this is a new class let's give it a namespace like dialog service repositories so let's name this class public static class extensions and let's declare a function here so it's going to be public static i service collection because we're going to be extending a service collection here and let's name it admongo and it's going to receive we're going to extend the i service uh collection object okay so it receives a service collection and it will return a live service collection let's see if we're missing a space so let's add the defense injection space there and here let's go ahead and grab a few lines from startup so let's grab these lines over here and let's go ahead and add missing nice bases so i'll do visual serialization i'll do serialization serializers and then i'm going to device vision okay and then we will need service settings but we will not receive them here we will get them over here as bar service settings but one thing that you can notice is that we don't have an instance of configuration here just like we had in starbucks where it was uh when it was a property that we received as part of the constructor so we can do is use a service provider to explicitly request a an instance of office services has a varying register so configuration is registered already by asp.net infrastructure so we should be able to request it at this point what i'm going to do is just say bar configuration is service provider dot get service and the type of service is going to be just i configuration okay which needs the extensions configuration space so now we can flip this configuration into just configuration with with a small cap c and then we are also missing another namespace here which is the service settings namespace okay so we get the configuration we retrieve service settings mongodb settings we construct the client let's add the missing space here too and that allows us to return the imongo database finally we're going to return the services collection just to enable the fluent use of this extension method so that will register the imongo database instance and now let's add another method to register the repository itself so i'll open up another menu here let's call it public static my service collections go to return add repository it's going to be the name and then we'll specify a constraint of t for the actual entity type that's going to be used and then it's going to extend a service collection the name is going to be services and then remember we have specify a collection name in order to create a repository so let's receive collection name as a parameter we also need to specify a constraint for that for that t parameter so t the the the t type that's going to be used has to be a type that implements i entity okay so we may need another namespace let's first expand this save it let's send this to the other line and let's add the service entities namespace okay so this will be useful to register uh repository with any type of entity but that entity has to implement i in the indit interface so now what we can do is go back to startup and grab these these few lines for the i brother registration we'll copy that here and then uh to make it generic we're no longer going to be using item here but just d and then this also registers as and we no longer hardcode the collection name we're going to be using the collection name parameter and finally to keep it fluent we return services once again so with that we should be able we should be ready to start using these extension methods so let's go back to startup okay so we're going to go ahead and remove this serializer registration let's skip several settings for now in case we need it later but we definitely don't need any of this stuff so now what we can do is just say services add that registers are a client and a imog database and then since this is fluent we can say at mongol repository we specify a type in our case type is item and then we provide the name of the collection which is still items so with that done let's just make sure things are keep working properly so i'm going to hit f5 to start a web server and i'm going to go into postman and i'll do again our simple get all the items request i'll hit send and yeah it keeps working just fine but as you can see the coding startup is way way simplified in the next lesson we will see how to move all of these common classes into a new shared library that can be used by all of our microservices it's time to move the common code with refactor from catalog microservice to a new shared class library that can be used by both catalog and any future microservice so to start with i have opened a new visual studio called instance i have opened my terminal and i am in the project directory so here we're going to create a new directory let's call it play that common and i'm going to open that directory in visual studio code all right now as usual i'm going to create a new sources directory src and here's where i'm going to open a new terminal to create a class library not a web api project but just a class library as we need what we can do is use dot cli by doing dot net new glass sleep and then we will give the name of play dot command so let's just erase the files that i can see that we can see on the left and then the first thing that i'd like to do is to generate the files that visual code needs to build our project but before we can do that we have to make sure that the omnisharp server is running the omnicharge server is the the component of the csharp extension for visual code that takes care of a bunch of productivity improvements in visual studio code like the generation of these files so what i'll do is just to kick off the object server i'll just click on class1.cs and as you can see on the bottom here omnisar servers is starting already and with that i can now go to view command plate that then generate assets for build and debug so that will go ahead and generate our vs code folder with the dash.json file inside and now that we have it i'll click on it and i'll go to this section to make the the build action the default action uh for building our project so i'll just add our group folder just like we did with the catalog microservice i'll select build easy fall true and save okay so with that i'll go ahead and close this and i'll delete this class one file we don't need it and now it's time to add a few nougat packages that our shared libraries our shared classes are going to need so first i'm going to switch to play that common and here i'm going to start adding a bunch of packages so i'll do net add package mongodb.driver okay so that's for mongodb now we need a couple of packages for the configuration related classes so donate a package microsoft extensions configuration okay we'll do that one and configuration.binder lastly we have to add the extensions that dependency injection and nugget package which is going to be used for everything related to the service container that we're using for the penis injection in this library with that done let's go ahead and start creating a folder to bring in our files so first of all that i'm going to create a right click and play that comma new folder folder is going to be settings and here's where we're going to place the settings files that we have in catalog so i'm going to go back to catalog folder the catalog directory or here and i will open settings and i'm going to copy these two files mongodb settings settings settings copy and back in common i'm going to paste those files here and i'm going to close the terminal for now and now that we have them here let's fix the the name space so that it matches our current uh our current project so this is going to be play dot com dot settings so vote for tv settings and for service settings okay with those files done let's go back to catalog and let's bring in our i entity interface i'll copy that i'm going to place it just at the root of play that common i entity and let's also bring our a repository interface repository copy into play.com at the root okay so these two should have also the name spaces fix it so they're just going to be played that common so play that common that one and play that comment on this one let's also get rid of any needed namespaces like this one here get rid of that one and we're good now i'm going to add a new folder for our mongodb related classes so i'm going to create a new folder here and play that command called mongodb and in this folder we're going to add let's go back to catalog we're going to add the extensions file and the repository file copy those ones back in common mongodb paste so for these ones the namespace is going to be play that common that mongodb and on this one again play that common that mongodb i'll also remove any needed namespaces from here and from here and in the case of extensions we also need to tell it the new namespace for the settings files so i'll go to service settings ctrl dot and i'll use play that command.settings okay so now we have all of these common classes in our new common common project and that should be good to start building a new package but since we are here let's actually take advantage of the opportunity to expand a little bit our mongol repository class with a couple of new functions that our future microservices are going to be using for querying entities based on a filter so let's go ahead and go to our i repository interface so let's start here and what we're going to do is add a couple of new functions similar to our overloads to get all async and gate async but they are going to be able to receive an expression as a filter to filter which entities are going to be returned so let's start by get lsync i'm just going to copy this function i'll add a new one here and the way that we're going to specify the filter is going to be an expression a link expression so it's going to be an expression let's add a missing space link expressions and the signature we're going to use is the one that mongodb is expecting from us so it's going to be a func of type t so whichever type is the empty and bull filter okay so again so this is the way to specify a filter so that eventually when we want to retrieve uh entities based on some features let's say give me all the items that are owned by a specific user in the case of inventory and we will be able to use such a filter here so you can pass a query expression here and then mongodb will be able to to handle that filter and return the correct items for us the same way that we did that let's do go ahead and do get async another overload that is also going to receive expression so in this case you don't need to specify just an id to get one item or one one entity but you can specify a filter to retrieve any entity that matches that filter yeah and when we get to our new microservice our emitter microservice will see how both of these functions can be used so now that we have that in the in the interface let's now go to repository and actually implement these new methods so i'll go ahead and click on a repository ctrl dot implement interface so that brings in our new methods at the bottom i'm just going to relocate them next to their other overloads just to keep them close to each other so put that there i'll grab get async and i'll put it next to our other get async overload there and really this is very straightforward so what i'll do is i'll copy the the last line of our other uh sorry other get all async method i've got here this line and i'll copy it to our new get a license overload and really the only thing that we have to do is pass the filter there because let's see if you go to find you're going to see that it it can expect it can receive a filter definition but then in another overload it can actually receive an expression of the type that we have defined so that's if that's the overload that we're going to be using from mongodb to be able to filter so i'm just going to pass the filter here and i'm going to make this method also async that will be enough to retrieve all the items based on the filter and for the other overload they get async again i'll copy the code from the other overload over here and here the filter is already there so it's ready to receive the filter but let's make it async and that that will do it so we can receive one one entity based on certified filter and like i said these methods are going to be very handy as we move to the future microservices so with that done let's go ahead and build everything make sure everything is built in correctly so i'll do ctrl shift p okay so everything builds just fine and what i'll do now is i'll switch to my powershell terminal so that we can create this nugget package and how do you create a nuget package very straightforward you just use dotnet cli with the netback operation so we will do and then you have specified the output directory with dash o and then given my current file structure what i would like to do is to place the package in a packages directory under the d projects folder so what i'll do is dash o slash i'll go up three directories and then i'll specify packages slash and that should be enough hit enter and that's it the nuget package has been created under the packages and we can confirm that by going to here we have a packages directory now and if i go to packages the package is right here so this package contains everything compiled out of our play.com library so now it's time to go back to catalog and start using this new nougat package so i'll switch to catalog here we are and before we can get a reference to that to our play.com nugget package from catalog there are two things that we have to do the first one is to specify a nougat a package source for recurring nougat installation so remember that nuget packages can live in multiple locations they could live somewhere in your internet they could live somewhere in the cloud in a public location like doggy.org or in a private feed library private feed sorry or or they could live in your local machine as it is our case but nougat doesn't know about that so you have to tell your nugget installation which are the possible package sources where it can find the nugget packages so we're going to tell it right now that our nugget packages are in our d a pack the project package location so to do that i'll open our terminal right here what i'll do is i'll use again.cli with the dot net nougat command but then do get add search and here's i have to specify the location of my packages so in my case that's going to be the projects packages and then i'll give it a name n uh just to have like two for easier of reference i'll name it play economy okay so it's been added successfully and just make sure that you update this this location depending on where you send your packages in the in the previous step the next thing i'd like to do and i'll collapse this a bit is to go to our plate catalog service cs prog and what i'm doing is i'd like to remove this mongodb driver reference because now everything mongodb is actually referenced and brought in via the nougat package so we will not need to have an explicit reference to mongodb driver here i'll just remove that and now save this project and now we can go ahead and add our play.com reference so to do that let me switch to src let's go to play that catalog service and then we can do dot net add package play that common enter and the reference has been added as you can see right here so with that it is time to start cleaning up things so i'll go ahead and close my terminal and i'll close this and a bunch of things that we can remove now are the identity interface you can remove our entire repositories directory can be removed and our settings directory can also be removed okay so now it's time to fix our our imports so let's go to item cs and make sure it can find that identity now leaves under play.com from nuget package in our controller also the irrepository interface now is coming from play.common and we'll remove this old namespace and finally in startup let's get rid of these all namespaces exactly clean up the entire thing i remove all new desired usings and service settings is now going to be coming from play.com on that settings also our addmongo extension method is also coming now from play.com.mongodb and that's what it is so we are now completely using our nuget package i'll make sure everything is built in via control shift p yep it's building just fine and now let's test if the if the service is running properly so i'll do f5 to run our service and i'll go to postman and i'll just go ahead and do a simple query for all the items in the database via our items operation in the res api i'll hit send and here we are we are retrieving items from the database so everything is working properly so it works just as before but now as you can see our uh and i'll just stop this our code base is much simpler so we don't have the i i entered this interface here we don't have the repositories folder we don't have the settings folder anymore and yeah our startup looks very clean and so this is going to help us a lot for the construction of our future microservices in the next lesson we will learn about docker compose and how it can help us simplify the way we configure and start our infrastructure services in this lesson we will learn about docker compose and how it can help us simplify the way we run our infrastructure services we already started using docker to run our mongodb database and we are doing this via simple docker run command however starting with the next model we will need to start bringing in many other infrastructure services to support our microservices for instance in the next model we will use ravidmq as our meshes broker and in future models we will choose sec prometheus and grafana to enable a series of observability related components so if we keep just using docker run to execute our infrastructure services we will have to perform too many steps to setup them and we will need to remember too many arguments for each of them like the right environment variables ports and volumes also some of our containers might need to talk to each other like grafana and prometheus and some of them might not be able to work at all without another container be up and running first which again is the case of grafana which won't be able to do much without prometheus being available first that's where docker compose come into play compose is a tool for defining and running multicontainer docker applications we will now be able to define all of our infrastructure services in a single file called the door compose jaml file this will include the definition of the container to use in each case environment variables ports and even dependencies between them then we will execute a single docker compose up command and all the containers will start in the right order with the correct configurations also compose provides a default network that all containers are joined to in case they need to talk to each other so with docker compose we are able to document the way to configure all of our infrastructure services in a single file and we get to start all of them with just one line as opposed to multiple commands also they all join a default network in the next lesson we will create our docker compose file and move our current mongodb configuration over there before we start using docker compose let's first create a new directory where we can place the compose jaml file and any future infrastructure related files so here i am in a new visual studio code instance i have opened my terminal and i am switch it into the project directory so this directory i'm going to create a new folder i'm going to call it play.infra and now i'm going to open in the visual studio code and the first thing that i like to do here is to take advantage of the another extension for visual code which is the docker extension which we can find if we go to extensions this type docker this one here because this one is going to provide us some good recommendations as we start working in our docker compose file so i'm going to install this extension click install and that will show up a new icon on the left side docker so let's close this and let's go back to our explorer now we can do is just go back here and let's create a new file let's call it docker compose.java and before writing any code here what i'd like to do is to bring in that previous docker run command line that we've been using just to keep it as a reference as we start writing this docker compose file okay you remember this this line that i just pasted this is what we've been using so far to kick off our or container so the first thing that you want to do in this docker compose file is to define a version for it the version determines what features you're going to have available in docker compose because different versions of the token compose engine support different versions so you have to define what version is this file for so i'll say version it's going to be 3.8 is the last one the latest one available as i'm recording this lesson and the next section is what we call services the services will determine each of these services is really one of our docker containers so i'll define a services section and under services you want to define our first service which is in our case is going to be mongodb so i'll just name it one go and as i start as i start writing this uh notice the indentation that i'm setting between each of these elements indentation is important because it defines which elements go inside other elements uh but to make this more uh more easier to see for you what i'll do is i'll enable another setting because to the code so we can see the white spaces that are happening across across the place so i'll go to file preferences settings and i'll look for render white space yeah so it's this one here so i'll switch from selection into all then i'll close this and now we can see the white space right there yeah so as you work on this file just make sure that you're leaving the same amount of white spaces or indentation with different elements that we're going to write i will also collapse this left side the navigation pane since we don't need it for now so we can have more space so inside the element we're going to open yet another element we have to define the properties for this for this service so first thing we're going to define is the image and as you remember from the command line on the top the image is so i'll grab that then we have to give a name to this to this container so the container is going to start up so i'll say container name and the name that we've been giving over here is so let's use the same name it's going to be the next thing is the ports so for sports is actually an array of ports so the rate you can define by placing a dash first and then you specify the port mapping so i'll grab that port mapping from here as you remember port is 27017 external port on the left side internal port on the right side and the next thing we have to define is a section for our volumes because remember that we need to map uh the slash data slash db directory inside the db container into a location outside of the host where the files are actually going to be written that's what we call a volume so to define volumes i'm going to go all the way here at the same level as our services section over there here we're going to declare a section called volumes and under volumes i'm going to define our mongodb data section which i'm actually going to copy over here one go to data column and that's really all you have to do to define a one volume uh in your in your machine and now we have to associate that volume to our service over there so i'm going to open yet another section here called volumes under ports and under volumes you have to define an array of all the volumes that you want for this service so the race starts with dash and then you define that that modeling mapping so i'm going to copy this again there so that defines that yeah so slash data slash db is mapped into mongodb data remember that we have to do this because otherwise our database files will be lost if we restart the container so from here on any time that the mongodb container tries to write to slash data slash db those files are actually going to be written into the mongodb data volume that's outside of the of the container and into a host machine okay so now i'll save this file and it's time to start running this a container via docker compose so i'll open my terminal ctrl j and the first thing i'd like to do here is make sure that i am not running mongodb container already so let's see wps docker ps and yeah so we are indeed running it already we don't want to have it running there because that could cause conflicts so i'll just go ahead and stop it docker stop monko okay and now uh it has been stopped so with that done we can go ahead and start our docker a container video via docker compose and we can do docker compose up hit enter and then that starts running the container and what you're seeing now is just the output of the mongodb container being generated directly into the terminal so now that we have the docker compose a docker composer running our dock our mongodb docker container uh let's see how is our catalog api working with this a new new way of running the container so i'm going to go back to uh to our catalog microservice and i'm just going to hit f5 to get things started okay with the host up and running let's go ahead and open postman and let's go ahead and try to get our old items in the database so here i am in my get operation for the rest api so i'll hit send and interestingly i'm not getting any items which is interesting because the as per our previous lessons we did have at least one item um already stored in the database so what's going on let's see uh let's go back quickly to visual studio code catalog and let's let's explore our database at this point in time so i'll collapse this a little bit and let's go to the mongodb extension and here's a localhost 27017 i'll connect to it and the interesting piece here and i'll collapse these other pieces is that we don't have a catalog database anymore and this is happening because as we are started as we moved into docker compose a new volume has been created for our database files so technically this is a brand new database which has no items yet right so there's actually nothing in there so there has not been any need to create the database yet so that's why you don't see any database here so just keep that in mind as you switch from a raw docker execution into torque compose a new volume will be created so let's actually come up with something for our catalog database so i'll go back to postman and i'll go to my post tab body okay and so let's again define something here we'll go again to our potion example so it's a potion and it stores a small amount of hp and the price is going to be just 5. so go ahead and send this and the item has been created if we go back to our get items api once again hit send the item is there and if you go back to visual studio code to catalog and we've refreshed this you can see that now we have our catalog database with our items collection and the one document already created in there and one last tip that i want to give you as you start working with docker compose is how to prevent let me actually open docker compose how to prevent all this uh output to be shown here so in case i don't want to see all this output from the database all the time uh you can see things in a much cleaner way by doing the following so i'll go back here to my terminal i'll just hit ctrl c to stop docker compose and what you can do is you can do docker compose app but you can append the dash d a parameter to run in detach mode so if i do enter now the only that you're going to see is that it's starting and then it says done so the container is running in the background but you don't have to be looking at all the output all the time so you're running in a detached mode and still if you go back to postman and you query you can see that the container is actually running so we have reached the end of this model with a few improvements to our developer workflow and with a reusable library that will speed up the construction of our future microservices in the next module we will introduce our second microservice and we will learn about the multiple challenges of having microservices talk to each other in this model you will learn about the different microservice communication styles and then you will learn about a few techniques to properly implement synchronous interservice communication between the existing catalog service and a new inventory service by the end of this model you will have a solid understanding of the following the different microservice communication styles how to implement synchronous communication between two services via rest and the http protocol what kind of partial failures could impact your mega services and why you should design for them how to set timeouts to fail fast when doing interservice communication what is and how to implement the retries with exponential backoff technique and when to use and how to implement the circuit breaker pattern in this lesson we will create our inventory microservice which owns the player's inventory of purchase items just like we did with the catalog service we will define a rest api for inventory with a couple of operations which are both items which will be used to add an item to the player's inventory back and get items by user id which should retrieve all the items for the specified player or user talking about users you may have noticed that we have not properly introduced the concept of players or in general users into our system this is fine the management of the actual users database will be the responsibility of the identity service which will be we will create in a future model along with all the microservices security infrastructure for now we will choose random guides to identify the users that own the inventory items let's get started let's create our inventory microservice i have started by opening a new piece of studio called instance i have opened my terminal and i have switched to the project directory so i'll create a brand new directory for this new microservice so let's call it play that inventory and then let's switch to that directory in the terminal and then what i'll do is i'll use this command line to ask the current instance of visual studio code to open this new folder so i'll just do code that for the current directory and then i'll do dash r to reuse the green window so i'll hit enter that will be the equivalent to or we use the file open folder and menu but it's much faster now i'll create as usual our source directory and in that one i'll right click i'll say open integrated terminal to open a new terminal in that location and then i'll go ahead and use dot net cli to create the new project so.net new web api dash n play dot inventory dot service is going to be the name okay so that generates a bunch of files on the left side and i'll i'll get the omnishar server started by clicking on any of rc chart files so i'll click there that kicks in on the chart server and that prompts us to add the the test.json and logistics.json files so that this will code can build and debug our project so i'll say yes that adds our files on the left side over here and then i'll go right away to our task.json file to add our group section where we can say that this is the section that by default builds the project save that okay so now also close our terminal for now and then i'll go to launch.json and i will remove this section just like we did with catalog so that anytime we start the server it doesn't open up web browser by default i'll just remove that and what i'll do next is i'll go to uh under properties i'll go to launch settings.json because we want to specify which is going to be the ports that we're going to use for inventory so remember we are already using the default ports for catalog 5001 500 and 5000 so we have to use new ports for inventory they cannot be the same port so i'll use i'll go for 5005 and 5004 for our https and http ports for inventory you could use any other port really here as long as they are not being used by any other application in your your computer next i'll go ahead and i'll delete what we don't need from these projects i'll delete weather forecast controller and i'll delete the weather forecast class over here so now i'll get started by creating our details so the dtos that are going to be used by our controller class and their arrest api so just like we did before i already click in play inventory service i'll say new file i'll create dtos.cs here i'll declare our namespace the namespace is going to be play.inventory.service.dps and so we're going to define two dtos at this point the first one is going to be the dto used to grant items to a user and the other one is going to be the dto used to return the series of items that a user already has in their inventory so let's start by defining public record grant items video and to grant the knight into a user we obviously obviously need to specify the id of the user so it's going to be a good user id let's add the system in space there we also have to specify which is the item the catalog item that's going to be assigned so we will define that as catalog item id and lastly we have to specify how much of the item is going to be assigned to the user so that's going to be the quantity let's notify the other the other dto as public record this is going to be inventory item dto like i said this is the dto used to return items the items that are assigned to a user and the user's inventory so for this we're going to be returning the catalog item id the quantity and also let's define the the acquired date so this is the date when the item was a was put into the user's inventory so now that we have our details it is time to start defining the entities that we're going to be using to store inventory items into the database however before we can do that uh we have to bring in the our play.com nugget package so that we can start using the the bunch of classes and types that we have defined there including our i items our intt interface so to do that i'll go ahead and do ctrl j to open my terminal and i'll go to late that inventory service and then i'll just do net add package play that common okay so if you go now to play men3 service we'll see that we have the nuget package added here now we can go ahead and right click in play inventory service new folder entities and let's go ahead and define a new file it's going to be inventory item dot cs let's define our namespace it's going to be play.inventory service entities let's define the class public class inventory item and let's make this class right away implement our i i entity interface let's make it use play.com into a namespace and as we're implementing that interface let's do ctrl dot implement interface so we have to define a good so probably good id we'll make it define just a get we will use a get and set just like that okay so each metal item will have an id then it should have it should know to which user it belongs to so let's do probe good it's going to be user id next let's define which catalog item this inventory item corresponds to a reference to the catalog item so it's going to be prop good catalog item id next we'll define the quantity it's going to be the quantity how much of this item we have let me also close this terminal now and lastly let's define the time of set is going to be the acquired date the day when the item was assigned to the user in the inventory save that and just like we did with catalog let's define an extension method so that we can transform one of these inventory items into the inventory item dto so i go ahead to the root play inventory service i'll add a new file i'll call it extensions let's add an a space play that inventory that service and let's add public static class extensions and let's define our method here so public static is going to return an inventory item video let's call it sdto and let's import a missing namespace and it is going to be extending inventory item into the item let's import that it's going to be the item and here it is just about creating a brand new item dto out of this item so we will say return new inventory item dto with item dot catalog item id item dot quantity and item that acquire date so that's all we have to do to transform the item entity into an identity now we can go ahead and create our controller so let's go to the controllers folder right click new file we'll name it items controller just like we did in catalog let's define the namespace for it play inventory service controllers it's going to be public class items controller and remember each of our itunes controllers should be a mark with the api controller attribute it should derive from controller base and it should define the base route that is going to be a map2 so route this route just like with catalog is also going to be items just because it also manages items so route items so now we're going to need a one class level variable here which is going to be the repository that we're going to be using to store and retrieve items so let's define private readonly it's going to be a repository of type inventory item and let's just name it items repository so let's import play common here and let's import play inventory service entities let's also collapse this navigation pane for now since we are not going to be using it for a bit and now we have to do dependence injection to actually receive this items repository into the controller so let's define a constructor okay so this constructor is going to receive again our i our repository so just copy that here item repository and let's assign it to our local instance hide the repository so now it's time to define our two operations here we need an operation to get all the items in the inventory and one operation to put an item or to create an item into the inventory so let's start with the get operation let's define that as public async task of action result and this is going to be of an innumerable of inventory iron detail and then we'll name it just get async get async and the parameter is going to be the user id so we want to get all the items in a user's inventory so we're going to receive good user id okay let's see let's add any missing spaces 3d tasks systems collection generic and service ctos and for the guide using system let's also define the verb that is associated to this api which is going to be http get and so the way that this api is going to where this operation is going to work is we just need to go ahead and get all the items based on the user so but before we can do that let's do a quick check let's make sure that this user id is not empty so if it is a good empty we are going to return a bad request request a simple validation in there and so to get the items we're going to do this so we'll say so the items is going to be and we're going to open up braces here we're going to do a sink call to items repository get all the sync and here's where we can start using our expression our filter based on an expression so in this case what we want to say is that we want to get any item where item.user id equals the user id that we got as a parameter over here okay so that's that's how we can filter items based on a user in this case and then when we have that we can do a select and let's see if we're missing another namespace system link where we're going to specify that we want to take each of these items that we found in the database and transform them as into a dto with our extension method and finally we'll go ahead and just say return return the items let's also transform this let's just wrap this into the ok into the k action result and that's all we have to do so that will return all the items in the user's inventory the next method is the one that we're going to use to assign one item to the inventory this is going to be a post operation so let's see let's define it as publication task we will just do action result we're not returning really anything out of this method i'm going to impose async and it's going to be receiving our grand ideas dto at istio let's mark this with the http post verb here we're going to do is we will try to find the if we have that inventory item already assigned in inventory because it could already have it so in which case we just need to increase the quantity or in the other case when we don't have it we just have to create it for the first time in inventory so let's try to find it so we'll do so it's going to be inventory item equals await items repository get a sync and again here's where we can use the expression filter where we're going to say that the item that we're going to try to find has to be one where the item that user id has to match the grand item cto user id and also the item that catalog item id has to match grant identity to your catalog item id let me see if i can put this in the next line so that will find the item if it is there so but if the inventory item happens to be new it is this is the first time that we assign this item to the user so in that case we will go ahead and say inventory item equals new inventory item and we will set its catalog item id is grant items dto.cattleguardian id the user id is grab itemcto.userid the quantity is that quantity and for acquired date we will just set our current date time offset so it's going to be daytimeoffset.utc.now and finally we will call our method in items repository to create an item so create a sync inventory item okay let's add this missing using semicolon there and then let's go for the other branch so else we did find the item so we just need to increase the quantity so for that we will do inventory item.quantity plus equals itemcto.quantity and then we will do weight itemrepository.updatesync with the inventory item and finally we will just return we'll just return okay and that's pretty much for the a controller operation so we have two two operations to retrieve the items in inventory and to put an item into the inventory so with that done it is time to start doing the basic uh configuration of a startup so i'll go back to our explorer here and first let's go to websites.json here we have to define uh the settings for our in order to define the service name and the mongodb a mongodb connection so to save time what i'll do is i'll go back to catalog actually and i'll open my app sizing json file over there and i'll just copy these two sections from the app statistic json i'll go back to inventory and i'll paste that right here really the main thing the only thing that we have to change here is that this is not the catalog service anymore this is the inventory service remember that this is what's going to define the name of the database that's going to be created in in mongodb save that and now i'm going to want to go to startup i'll actually clean up a bit disney spaces so i'll do control dot here remove necessary usings and now i'll go to the start of configure services and i'll add the services for mongodb and the repository so i'll do services that add and that may need another import pay common mongodb and then i'll add a repository of type inventory item let's add a using there and here we have to specify the name of the collection here so the name that we're going to give it is inventory inventory items save that and so with that we have registered everything related to mongodb and we actually are ready to start trying out this microservice so i'll go ahead and hit f5 okay and then what i like to do is actually import the the specification cover api into postman to make our lives a bit easier what i'll do is i'll copy a copied url of our service localhost 5005 and then i'll go to our browser just for this time paste that there and then let's go to slugger so this defines as you can see this is the soccer ui page for our rest api then i'll click in the swagger.json link here and i'll copy that copy that and then i'll just close this browser now i'll go to postman and here what i'll do is i'll just click on import link i'll paste that click continue and i'll just say import so now if we go to collections we have now not just a catalog service section but also a collection but also a plain inventory service collection with our two items related operations so what i'd like to do is to go ahead and post and try out our post to assign an item to a user but of course before that we have to define the base url for our for this collection so let's go to dot let's go to edit variables and in this case our base url is as remember let's go to inventory base url is localhost 5005. put that here i'll put it for current value and for initial value update that okay so it knows the base url now being imposed we go to body and here's the three things that we need user id catalog item and quantity now for user id um like i said in the introduction we don't uh we don't have actual users so far so we just generate a random one and one handy way that we can do that in postman is by using the coolid function that's built into postman so what you can do is just this so open two sets of curly braces and then you're going to do just good so that will on the fly generator quit for us and for the catalog item id we want to know the id of one of our items in the catalog so to do that let's actually query our catalog items but before doing that let's go back to catalog and just hit f5 to actually start the web server so that we can query the catalog and then i'll go back to postman into our play catalog service collection i'll expand this i'll go to get items and i'll just hit send and here is the one item that we have the catalog the potion so i'll copy this id and i'll go back to our post operation paste it there and let's say that we want to assign just one one of these potion into the user's inventory so now go ahead and hit send and we got 200 okay meaning it was a success and so to verify that this actually worked let's actually try out our get all items in inventory operation so i'll click on this new operation and in this case the first thing that we're going to need is uh to specify the which is the user id right so which user was that item assigned to which we if you go back to post it was an automatic automatically generated users we actually don't know yet but we can figure that out via our console so i'll click on the console down here and you open the post operation and we expand the body the request body you see the user id is right here so this the console records everything that's going on behind the scenes so it's pretty handy in this case so i'll just copy the user id and i'll close this then i'll go back to our get items from the inventory service and i'll paste that right here so with that i'll go ahead and hit send and here it is so this user has a one of the catalog item of this id and with this acquired date where the date was assigned and so let's say that we wanted to increase the quantity of that item for this user and we want to actually test this this other codepath so let's go back to post body and let's say that we want to add uh perhaps four more uh potions to these users inventory so i'll just do that uh we want to change now we don't want to generate get another good so replace user id with the id that we we just copied for our user so then i'll go ahead and hit send 200 okay and then if we get items for this user in inventory i'll hit send and now the quantity is five so now the user has five items in his inventory okay so at this point our inventory service can store and report the items that each user has in his inventory back however notice that this dto that we have returned by the get operation only provides the ids of the items in the user inventory so since we don't have any names of descriptions it is a bit hard to tell which items are in the user inventory which are the actually so what does 4e 9c means really so in the next lesson we will learn about microservice communication styles and how our inventory service can use them to retrieve more details about each of these items from the catalog service in this lesson we will learn about the different microservice communication styles and how to implement the synchronous communication style vrs and the http protocol there are basically two ways you can communicate with microservices the synchronous style where the client sends a request and waits for a response from the service and the asynchronous style where the client sends a request to the service but the response if there's any response will not be sent immediately so far we have been using the synchronous communication style when interacting with our services via swagger ui and postman and in this lesson we will explore how to use it for interservice communication we will learn about the asynchronous communication style in a future lesson when using the synchronous communication style the client sends a request and waits for a response from the service which means that the client cannot proceed without a response you may make this more evident with any of our services if you put a breakpoint in one of our service controller actions like get async in the catalog items controller start a debug session in bs code and then try sending a get request to it be a postman you will notice that postman waits indefinitely for our service to respond it can continue until the service responds many times this type of communication uses a blocking threat meaning that the client is unable to receive any other inputs or perform any other task until the response arrives but it could also use an unblocking thread where the client just offers a callback method to the service so the service can call the client back when the response is available in this case the client thread does not block even when it still waits for response there are two approaches currently to use the synchronous configuration style rest with the http protocol which is a traditional approach and the one that we have been using so far in res the business objects are modeled as resources and http verbs are used to manipulate them also you usually use xml or json to represent the resources most clients support rest the other approach is grpc which is a binary messagebased protocol in which clients and servers exchange messages in the protocol buffers format grpc is becoming increasingly popular because it supports http 2 and is more efficient addressed however not all clients support http 2 which is why in a microservices architecture grpc is used mostly internally between the api gateway and the services or between the services in the next lesson we will be implementing synchronous communication between catalog and inventory microservices using rest and http at this point when the client requests the items inventory back for a user the inventory service creates its database and retrieves an array that has basic info about each item including the catalog item id and the quantity however having a list of item ids does not tell much to our client in terms of what actual items the user has on inventory ideally we would like to get at least the name of each item and hopefully also a subscription however inventory doesn't know such details about the items since the information is owned by the catalog service one way to address this is to have the inventory service send a get request to the catalog service to retrieve the details of all the items inventory can then combine this additional info with the details it has in its own database to send back the decided more detailed payload to the client let's go ahead and implement this approach our inventory microservice needs to receive data from the catalog microservice but before we can do that it first needs to define the dto that represents the retrieved catalog items now it turns to be that we already have such a dto that represents catalog items and if we go to our catalog project our catalog microservice and if we go to dtos.cs we're going to see that such d2 is right here so this is the dto item dto that represents cattle guidance when you query for them so what i'll do is i'll just copy this dto copy this and then i'll go to inventory here we are in inventory and i'll open dto.cs and i'm just going to paste that as initial dto for uh for the inventory and the case of inventory we're going to rename this into catalog item detail just do not confuse it with inventory attended to you and uh for example inventory again uh we don't need that many properties when we're querying for catalog items and you don't have to retrieve everything or at least digitalize everything into inventory the only thing that we're going to need in this case is the id of the item the name and the description we don't need price and created date for our purposes so remove those save this and now that we have this dto we can actually build a client that is going to be able to query for this item from catalog so i'm going to right click in play inventory service i'll create a new folder let's call it clients and in this one i'm going to create a new file that i'm going to name catalog client that's cs let's give it a namespace display inventory service clients public class catalog client so in order for our catalog client to be able to talk to any external http endpoint it needs to use the net http client class so we're going to define that as a class level variable here private readonly http client http client and i'll import the system.http in space and now we're going to do dependency injection of this client into our class so public catalog client http client and we'll take that reference now that we have that client available we're going to define the function that's going to retrieve actually retrieve the items from catalog so this is going to be an async function so let's define it as asynctask and what we're going to return is a collection of catalog item dto since the the consumer is not expected to modify this collection in any way we're just going to return a readonly collection of type catalog item dto and we'll name it get catalog items async let's import missing spaces for tasks and forbid on the collection and for catalog item video to retrieve the items we can do that really easily with one line so we'll do items equals weight http client get from json let's change this get from json async we need to import another space system http json and we'll um will deserialize as i read only collection of type catalog item video and then here is where you put the route that you want to access in the invoked address api in our case in the cases of catalog the route would be under items and with that we can go ahead and return return the items that's all you have to do to invoke another a recipe i in another service with that done it is time to update our inventory identity to have this additional information that we're going to collect from catalog so let's go back to dtos and inventory item dto we're going to add a name and a description but as we do that and as we can see extension is complaining and it's because we need to provide that additional additional uh members to the construction of inventory in dtu as we transform the inventory item entities so what we'll do is we're going to receive additional parameters into this method which are going to be the name and the description and we'll fit those two into inventory item dto constructor there with that done we are ready to go to our controller to actually take advantage of this new this new information so i'll go to items controller and the first thing that i'll do is i'll get a reference while defining a classless variable for our catalog client so i'll define private readonly catalog client capital client okay let's import the missing space and let's receive that as a penis injection into items controller i receive the catalog client and we'll get the reference and now that we have that let's change a little bit how we do the our get async method so we'll get rid of these lines for now and the first thing that we're going to do is to actually retrieve the catalog items so how do we get the catalog items very easily now we can do catalog items equals weight cattle client that get catalytic items async that's all it is okay so that gives us all the catalog items in the catalogs microservice now we want to get the list of all the inventory items that we have currently in the inventory microservice so we'll do that via inventory item entities it's going to be await item repository get all these sync where the item item that user id equals the user id that we got as a parameter okay so now we have all the catalog items and then we have all the entities the inventory item entities for the current user now we need to combine these two pieces of information to produce the dto that we want to return so to do that we'll do this so inventory item dtos equals inventory item entities select so we're going to do a projection here for each inventory item we will do this let me close that first we will look into the collection of catalog items and we will find the catalog item that corresponds to the current inventory item so catalog item equals catalog items that's single there should be one and only one catalog item where the catalog item catalog item that id should match exactly the inventory item that catalog item id and once we have that we can do the conversion of the inventory item into a dto so we will do enter the item return inventory item as dto and then we have to provide the catalog item that name and the catalog item that description and finally now that we have the inventory identities we will return those as opposed to these old items collection so inventory item details so our catalasing method is ready to retrieve an improved set of items with name and description and now it is time to do the proper registration in a startup to let our application know about this new catalog client that we're going to be using let's go to startup and what i'll do is i'll open a little section just under our registration so i'll do services dot add http client and alt line is going to be catalog client let's import missing a space and then i'll receive a specifier parameter here is going to be the client okay let's open that expression there and here really the only thing that we have to specify for now is the the base address of this automaker because otherwise how how would it know so we're going to say that the client base address equals a uri let's import a missing space and then if you remember the uri where our catalog microservice leaks so far is a localhost 5001 so that's what you have specified here https localhost 5001. okay so this is a handy way to register our catalog client so that it can be used by dependency injection in other classes like in the controller right so you say http client catalog client and then you specify the base address and then when that client is instantiated it will automatically receive an instance of the http client that you're going to be using to query four items okay so with that done let's go ahead and hit f5 let's see this in action let's not forget to also do an f5 in our catalogue service so i'll go ahead and start also here's catalog i'll start it f5 and with the two service up and running we can go ahead and go to postman here in postman i am already in the in the tab for the operation that can retrieve all the inventory items for specified user id so this is user data we've used in the previous lesson uh so let's see what information we can get now that we created the api so we'll go ahead and hit send and as you can see we are able to retrieve the catalog item but this time we not just have the id of the item we also have the name and the description of the catalog okay so this seems to be working pretty well however think about what will happen if the catalog service started having issues at least temporarily but what happens if it's completely down in the next lesson we will learn about the problems that we might find when having a service communicate with another service in this lesson we will learn about partial failures in microservices and how to deal with them using timeouts and the exponential backoff technique even after placing our best efforts to ensure we have a healthy system it is a matter of fact that in distributed systems partial failures will happen this could be due to multiple reasons including network outages hardware failures dependency failures and even routine things like having a deployment in progress regardless of the cause of the partial failure when calling a dependent service it could certainly cause our microservice to fail which will end up in a bad experience for our clients so whenever a service makes a synchronous request to another service there is an ever present risk of partial failures and so you must assign your service to be resilient to them one of the first things to consider when making requests to dependent service is setting appropriate timeouts a service client should be designed not to block infinitely and use timeouts think about the experience of our client when the catalog service takes a long time to come back to our inventory service if it ever comes back now the inventory service is also taking forever to respond to the client leaving our users with a bad experience and not only that at least one of the threads of inventory is now busy not being able to serve any other requests which reduces the amount of available resources in the service instead of this you can set a timeout of say no more than one second so that if catalog service takes more than that to respond the request immediately fails and the inventory service can in turn return the appropriate request to the client even if it's a failure this enables a more responsive experience and also ensures that resources are never tied up indefinitely like we mentioned it is not uncommon for transit failures to occur in a distributed environment therefore you usually want to give the dependent service one more chance to come back with a successful reply however you don't want to keep retraining at a constant rate since that could overwhelm the dependency a good strategy that you can use for retries is the one called retries with exponential back off this strategy performs call retries a certain amount of times with a longer wait between each retry and here's how it works as usual the client will make a request to our service and this one in turn will make a request to its dependent service if this second request fails instead of failing right away our service will wait some time and then it will try again if the request fails again we will now wait a longer amount of time before trying the request if it keeps failing we will wait a yet longer amount of time before one more try and eventually if we have tried enough times with no successful response we will let the call fail as you see this strategy lets the failing dependency have an increasing amount of time to recover it also avoids overwhelming the dependency let's see how to implement timeouts and retries with exponential back off in our inventory microservice let's see our inventory and catalog microservices in action once again so here i am in catalog and i'll just hit f5 to start a web server and then i'll go to inventory and i'll do the same thing hit f5 and now i'll go to postman and i'll try to get all the inventory items for this user id so i'll just go ahead and hit send and here's what we expected to get right so the list of inventory items with them and description now to simulate the effects of partial failures let's first add a few temporal modifications to our get out items operations in catalog microservice so i'll go to our catalog visual studio code instance and i'll stop it for now close terminal and i'll go to items controller and what i'll do is i'll modify or get async method the one that retrieves all the items so that it introduces a few temporal failures uh for our inventory client so before doing that i'm going to add a little uh a little variable to track how many requests we have received from the from the client at this point so i'll just add private static in i'm making it static so that it doesn't reset after every request let's just call it request counter start with zero and now in get a scene i'm going to open space here let's go down and i'll do the following first thing that i'll do is i'll just increase the counter and then let's add a lock line just after this console.the right line i will just say string interpolation request request discounter starting so that's that's why it tells us that it's starting a new request then what we're going to do is for the first two requests we will actually increase i mean we'll add a delay to simulate the timeout scenarios so if request counter less than or equals to two we're going to say i'm going to copy this line here console.writeline we will say delaying and i'm going to say wait that's that delay this is how you can introduce a delay in the current request in an asynchronous way time span that frame seconds will say 10 seconds so the first request will be delayed 10 seconds then i'll copy this block here down here and we will say that if the request counter is less than or equals to four what we're going to do is just return an internal server error right so three to to simulate that kind of error so request request counter we will say 500 internal server error and we will return status code 500 now at this point we are introducing this capability of uh returning either one result here or another type of result here and in order to do that uh remember that we have to switch from just returning the innumerable into returning an actual i actually result so i'll say action result of a numerable of identity and i'll close this so that gives us ability to return more than one type of a result and also we'll have to modify our final return clause here so that it returns something that can be mapped to afghanistan like the okay result and lastly what we're going to add here just over here let me copy this console right line this is going to be the happy path where we finally return something and we're going to say resquez request counter we will just say 200 okay okay so for a quick review we have a static request counter so every time a request comes in it increases the counter uh the first two requests are going to have a 10 second delay the next two requests are going to end up in a 500 error and then if we get get past that we'll get at 200 okay and so at this point i'll go back to our inventory this is our inventory i've used to call instance i'll just stop it close and what i'll do is i'll first go ahead and collapse our navigation pane for now i'll open my terminal over here i'll open a new partial terminal what i'd like to do is actually have two terminals in this window so we can see the interactions between microservices so i'll use the split terminal icon here to open a second terminal and in this one i'll actually switch back to play that the catalog directory okay play the catalog service and here i'll do dot net run so that we can see the outputs that are coming out of catalog and then on the left side i'll start up our inventory microservice same way i'll do that run okay so with that done let me go back to postman and i'll try the query once again so i'll hit send and back in bs code you can see that now this first request is getting delayed and now our inventory client is experienced experiencing this significant timeout if we try it again for the point of views postman so look at this it just keeps waiting waiting and waiting we're giving a really bad experience to to our clients right okay so what can we do about this so the first thing as we mentioned is to introduce a proper timeout to avoid this kind of situation so let's go back to visual code and what i'll do now is i'll stop both web servers so i'll go to my inventory turbine and i'll do ctrl c stop server catalog control c stop server and what i'd like to do now is to add our a reference to the poly nougat package so so this is the package that you can use in your.net applications to properly handle transient error failures in a very easy way so being in play inventory service i'll do net add package microsoft.next enter okay and then perhaps i'll put this back into place and then i'll just do ctrl j to hide all terminals for a moment then i'll go to our explorer and i'll go to startup.cs and i'll collapse this once again we don't need it and let's go into configure services and um yeah so let's find the section where we are adding the http client right here and here what we're going to do is we're going to append yet another call to another method here that's going to be that's called add policyhandler and uh here's where we can define a policy so paulie has this concept of policies that different policies that can be used to handle a different transient errors when you're invoking an external api so we're going to use policy and then let's import any missing space using poly so we will say policy dot timeout async and then we specify a type here and that type is going to be http response message and let's add the system.net namespace because this is the type of response i will get when you invoke the external external client so and uh in this parameter we'll specify uh how many seconds we want to wait maximum after calling an external api and before just failing so i'll say one second in our case and i'll close this so just by doing this you're saying that anytime we invoke anything under localhost 5001 we're going to wait at much one second before giving up so let's see now how this works i'll bring in back my terminals via ctrl j and then i'll do dot net run in both cases okay perhaps i'll move this a little bit to the right and then let's go to postman and try the request once again as you can see it now took just a little bit more than one second to complete the request so instead of waiting for all those 10 seconds wasting resources let's try again yep and once again it just took just a bit more than one second if we go back to postman we can also see we tried the two requests on the right side but then they usually took more time to respond but regardless we were already we had already failed on the on the left side on the inventory side so that would at least help us fail fast to avoid the long delay and avoid consuming inventory resources unnecessarily however we note that transient errors are not uncommon in distributed systems so we would like to not just fail right away but instead try a few times hoping for the catalog service recovery in the next lesson we will implement the retries with exponential backoff technique to improve our chances of succeeding in the presence of transient errors in the last lesson we introduced a onesecond timeout policy to inventory microservice let's now use the retries with exponential backoff technique to let inventory retry the calls to catalogue a few times before giving up so here i am once again in the play the inventory microservice and here's a line where we last in last lesson we added our timeout policy what we want to do here is add yet another policy to specify what to do in the presence of transient errors and how to retry so now i'm going to be adding that policy handler right here just between the add http client call and the add policy handler call and just pay attention of the location of this because we want to make sure that we can combine the timeouts with the transient error hunting so that any time that we retry we actually wait just one second like specified in this policy we wait one second uh between tries if you don't do things in the order that are going to be shown here that combination is not going to work properly so at this location i'm going to say add transient http error policy and let's actually go into the definition of this method for one second so go to definition uh so so just so that you can see what this this method is handling so this method is taking care of network failures it's also taking care of 500 500 errors several errors and a 408 status quo so request time out so this method we're going to use is very handy so because it can handle all these situations by itself automatically i close this and again notice the location where i added this so now what i'll do is i'll say builder and then we'll say builder dot weight and retry async and here we're going to open parentheses and we need to specify a series of parameters for this policy and the first parameter is going to be the retry count so this is how many times we want to retry in the presence of transient error failures so for our case let's say we're going to go for five retries the next parameter is the sleep duration provider so this is just a function that determines how much time to wait between each retry so for this we're going to say we try attempt and then we'll use a time span class to specify a duration in seconds but here is where the exponential backoff part comes into place we are not going to just specify a one specific amount of seconds we are going to say but that pow so that we can say uh let's go for two and then we'll raise that into retry attempt so this means that every time we're going to wait we're going to be waiting an increasing amount of time that depends on the retry attempt so for like the first time it's going to take two raised t raise it into one the first which i attempt so two at one is going to be two so two seconds so next time it's going to be two a raise a two so it's going to be four seconds the next time eight seconds it will keep going that way in an exponential way so that every time we just wait a little bit more so that's that's a potential backoff piece of of this technique and then next we're going to specify yet another parameter uh that you don't really need it but we're going to use it just for the purposes of demonstrating what happens between the different uh the different calls so you can totally skip this if you want to if you want to don't want to see what's going on behind the scenes so i'm going to say on retry and then we specify three parameters it's going to be outcome a time span and we try attempt so i'll open this and then here we can specify um what we want to do each time that retry happens what we want to do is just present the lock a lock message in the console and we can do when you we can use i logger for this now uh uh to do that at this point we need to actually get an instance of the ilogger a lower class but uh we don't have a easy way to do that right now so what we're going to do is to as an instance of the service provider we're going to create a service provider and from that one we're going to get that service this is not ideal and that's actually going to present a warning message in the console but we're doing this just for demonstration purposes so totally avoid this this technique in production code so let's see we'll say service provider equals services dot build service provider and then we will say service provider that gets service we want an i logger of catalog client okay let's see if we're missing a namespace extension's logging okay so if you're able to get that that that service instance so we'll use this equal question mark there we'll say that log warning and here's where we're going to specify that message and the message is going to be and we'll do a string interpolation here we'll say lane for so many seconds and those seconds are going to come from time span the total seconds and then then making retry and that's going to be retry attempt okay close that save and one more thing that we have to do here is make sure that we combine both of these policies so that they can work together and to do that what we have to do is go back to this builder declaration here so where and then we have to say builder dot or and then we specify the exception that will be coming out of the timeout of the timeout async call over here so in that case that exception is going to be timeout rejected exception and then let's see if you're missing any space using polytimeout okay so that's how you can say that if the actual and then let's add missing parenthesis if we fail because of a timeout produced by the timeout policy then it will fire a timeout section let's go ahead and also retry okay so that's the right way to combine both policies okay so now let's just save this and i'll open my terminals and left side is inventory i'll do dot net run right side is catalog dot net run let's expand this a bit and notice the warning that i was mentioning before and this happens like i said because of the way that we are doing a the service provider construction here there's a radio service provided built in into the spinal cord of time we are creating a second one that's not ideal and but like i said it's used for demonstration purposes feel free to remove this section in your production code so now that we have both services up and running let's go back to postman and let's go ahead and do a send to see what happens so it starts and go back going back here you can see that uh first time we tried and then we waited two seconds then we waited four seconds then we waited eight seconds we're trying to wait eight seconds on the right side you can see that the multiple requests are coming in now they're firing internal server drivers and now we are in what's probably the last the last weight uh for 16 seconds and so the client in postman as you can see it just keeps waiting uh it's not it doesn't fail right away but we are trying to get a chance to actually succeed and yeah eventually that happened the client succeeded and we no longer see an error if we see back into postman we can see that yeah indeed eventually we go to 200 okay 200 okay for the last request and it is looking great now the one issue with this is that if you have multiple instances of your in this case our inventory service uh calling a catalog and they are all waiting exactly four seconds exactly eight seconds 16 seconds between the tries that can actually cause a kind of burst of of calls into catalog service at the very same time right because they are waiting for exactly the same time between retries so to avoid overwhelming our catalog service what we can do is introduce a little bit of randomness so that it is not exactly four seconds or exactly eight seconds and stuff like that so how can we do that i'll do ctrl c in both of my terminals to stop those processes and do ctrl j to close the terminals and what we're going to do is add what we call a jitter so this is going to be the way to add that randomness here so i'll go up and just over here i'll introduce a random error it's going to be new random and then let's go back to the section where we're defining the retry attempt over here and we're going to do is just go to next line and we will say plus time span that from milliseconds and we will say uh yearly dot next and so we want to add is some number of milliseconds to those seconds so we'll say any number from 0 to 1000 should be fine so this time we should see that it's not just a specific amount of seconds but those seconds plus some milliseconds that are going to be generated at random so i'll save that open terminals again ctrl j dot net run and dotnet run and let's go back to postman and try this again so i'll hit send let's go back here and as you can see now we are not waiting just two seconds but 2.5 to 3 seconds and the next time we're waiting for that 38 seconds and so on and so on yeah so with that the different instances will be invoking back to a client at different slightly different times which lets a catalog not get overwhelmed and so this is much better and would certainly help us handle temporal glitches uh when reaching out to the catalog service however imagine that a widespread network outage is preventing us from reaching catalog or perhaps is preventing catalog from reaching its defenses so such outage would likely last let's say a half an hour and if we have all of an inventory service threats retrying that much time we may end up exhausting its resources in the next lesson we will learn more about resource exhaustion and how to deal with it via the circuit breaker technique in this lesson we will learn about resource exhaustion in microservices and how to deal with it using the circuit breaker pattern having a retry policy in place is good but you also must be mindful about the limited resources available to your service imagine once again a situation where there is an ongoing issue with your service dependency this might not be just a transient issue but instead some prolonged downtime caused perhaps by a broad network now the client calls our service and this one in turn invokes the already failing dependency which will hopelessly start waiting for a reply while this is happening more clients keep sending requests to our service and this results in more requests being sent to the failing service one thing you have to realize is that each of these requests are making use of your service threads of which there is only a limited amount once enough threads are in use there are no more resources available and you can reach what we call resource exhaustion when this happens your entire service becomes unavailable for any future requests potentially causing a lot of trouble in the system one approach we can use to properly handle this issue is implementing the circuit breaker pattern a circuit breaker prevents service from performing an operation that's likely to fail here's how it works once again we are in a situation where our dependent service is already in a bad state unable to provide successful replies our client then makes a request to our service however this time instead of invoking the failing dependency directly there is an intermediary that we will call the circuit breaker the circuit breaker will now start monitoring the results of each of the requests that go through it that go through it to the external dependency and when it detects that the rate of failure goes beyond the configured threshold it will immediately stop letting any more requests go out and will fail them right away this is what we call opening the circuit after this request will just keep failing immediately during the configured wait time which would hopefully give the dependent service enough time to go back to a healthy state eventually the circuit breaker will let some requests go out to verify if they succeed and if that is the case it will close the circuit again letting all 40 requests reach the dependent surface that's how the circuit breaker prevents our service from reaching resource exhaustion while at the same time avoids overwhelming dependent services until they get a chance to recover let's go ahead and implement the circuit breaker pattern in an inventory microservice to implement the circuit breaker pattern all that we have to do is add a new transient http record policy just like we did for the weight and retry policy so here we are again in the inventory microservice in the startup class configure services method and i'm going to scroll down a little bit here and remember we have already added policy for weight and retries and we have a policy for timeouts so what i'll do now is i'll open yet another section here to add our our next http record policy so i'll do a transient http load policy remember we want to do this just before the timeout and not after so that this policy can also wrap the benefits of the timeout policy so open parenthesis here and what i'll do is i'll just copy this little section here so that we are we are properly combining this policy with the time with deceptions that could come out of the timeout policy but then what i'll do is i'll invoke the circuit breaker async method here and i'll open parentheses and here we have to suffice the parameters for circuit breaker so the first parameter that we have to define here is how many tries we're going to allow or how many requests we're going to allow through the circuit breaker before the circuit has to open right so in our case let's say that's going to be three so three failed requests are going to are going to go through the circuit breaker before the secret breaker actually notices that yeah there's a problem and we have to open the circuit next comes the duration of the or time span of the other break so this is how much time we will keep the circuit open so let's say this is going to be time span from seconds let's say 15. and that's really most of what you have to do you don't have to do more than that to enable the secret breaker uh but just like we did with our tries let's add a couple of functions here to get an insight of what's going on behind the scenes so what i'll do is i'll say on break so this is a functional that will be used when when the secret opens so i'll say outcome and time span okay so in this case we want to add a log message and stating that the secret the secret breaker is opening so this is going to be really very similar to what we did for uh for our weight and we try so i'm actually going to copy these three lines from here i'll copy them over here for our own break function and i'll just change the message the following way so i'll delete this and i'll say opening the circuit for and this is going to be time span that total seconds seconds okay so that's what's going to happen when the secret breaker opens and then next we're going to add another one for the on reset on reset function that's not going to receive any parameters and in this one we're going to do something very similar so i'll copy again that that line those lines paste them there and in this case we're just going to say closing the circuit okay so that's really all you have to do to enable secret breaker so again we are waiting we will allow three requests to go into secret breaker and if those three are failing the rate the circuit is going to open then it's going to wait 15 seconds uh before allowing any new request to actually totally try to to reach the other end uh during those 15 seconds things are going to just fail right away and then we have functions to lock what's happening when the secret opens and when the circuit closes and now i'll go ahead and i'll open my terminal so i will save this file i'll open the two terminals using the like in previous lessons i have two terminals inventory service on left side catalog service on the right side i'll do.net to run in both sides okay notice we keep getting these warnings about the build service provider issue that we talked before but like i said that's this is just for demonstration purposes so now i'll get back into postman and we'll try out that inventory api to get all the items in the user's inventory see what happens so i'll just go ahead and hit send and notice the left side that we tried we failed so we waited for 2.02 seconds then we tried failed waited for 4.64 seconds and then at that point the circuit actually opens for 15 seconds so we're waiting at 71 seconds for the next try but the moment that we try this again things fail right away as you can see on the left side and you see if we see what's happening in postman yeah we're getting that error the circuit is now open is not allowing any further calls and if we try once again uh it may take one or two seconds but it will fail because the sequence is open and if we just keep trying and keep trying uh we're getting an immediate result so this is the effect of having the circuit open so any new requests are coming here from any client or service are going to fail right away however eventually the circuit lets us go through one word request and if it notices that it's successful it opens the circuit like it happened right here we go back to postman we can see that it allowed one more request just to see if things are healthy once again and it got a 200 result and then it said yeah closing the circuit and it allowed things to keep working once again so that's how the secret work breaker works and that's how it can help us prevent overwhelming other services or having to waste resources and cause resource exhaustion in our microservice at this point we are doing a fairly good job at handling parts of failures between our inventory and catalog services however could there be a better way to have inventory get all the information he needs from catalog without having to rely on catalog to be available most of the time in the next module we will learn about the asynchronous communication style and how it can help us enable a much more resilient communication between our services in this model you will learn about the asynchronous interservice communication style the challenges it can help solve how to implement it via habit and queue and mass transit and how to enable eventual data consistency between our two microservices by the end of this model you will have a solid understanding of the following the basics of and when to use asynchronous communication between microservices how to enable microservices autonomy and the impact to the sla how to use a message broker for asynchronous data propagation how to stand up a ravine queue message broker via docker compose how to publish messages to ravit mq via the mass transit framework how to consume messages from gravitmq using mass transit and how to implement eventual consistency of data propagated across microservices in this lesson we will learn about the asynchronous communication style and how it can help us enable much more resilient communication between our services imagine a scenario where after receiving a request from a client our microservice needs to reach out to two other microservices also each of these services need to get in touch with other services which in turn might need to further reach to more services there may also be services that depend on the services that our service depends on we originally fine tune our service so that it never takes more than 300 milliseconds to respond to our client requests however when we started making synchronous calls to one of our dependent microservices we had to add to our time the 200 milliseconds that that service can take to respond that was still okay in the beginning but unfortunately when that dependency eventually started calling another dependency and that one yet to another one our oral average latency bumped to 1450 milliseconds which is bad on top of that if one of our deeper indirect dependencies starts failing even if temporarily it can cause all of the services that depend on it to also start failing and the effect keeps cascading until potentially most of our system becomes unavailable one important concept that you should keep in mind as you embrace microservices is the service level agreement or sla the sla is basically a commitment between you as a service provider and the client for instance as part of our sla we could have defined that our service can be expected to be up and running 99.9 of the time so when our clients choose to use our service they should expect it to be down approximately 44 minutes during the month which the owners of the client will have to decide if it's susceptible however when using synchronous communication calculating such numbers for our service sla gets more complicated our deepest dependency is also advertising at 99.9 uptime in their sla and let's say that all of the services initially advertised at the same value however in our scenario when dependency 4 fails it impacts the sla of dependency 3 which now sets its sla down to 99.8 this in turn impacts the sla of dependency 1 and ultimately impacts our own sla now with an sla of 99 at six percent of time our clients would be subject to about 175 minutes of downtime across demand which is way below of what we wanted to provide initially so the synchronous communication style suffers from an increase of latency due to the chain of calls it can significantly amplify the impact of partial failures and can potentially reduce the sla of our service now let's look at the asynchronous communication style here the client does not have to wait for a response in a timely manner and in fact depending on how the communication has been set up there might not be any response at all to enable such communication there is usually an intermediary called the message broker which is pretty dumb in nature meaning that it has no business logic on it and it is also highly available with the message broken in place the service client sends messages to the broker and the broker forwards the messages to receivers as soon as possible the messages can be received by two types of receivers a single receiver in which case we think of the message as a command via which the client requests an action on the receiving service for instance when a purchase operation starts our trading service will send a command to our inventory service asking it to grant items to the user's inventory and another command to an identity service asking it to david kill from the user we could also have multiple receivers where there are multiple services that subscribe to the events published by the client service this would be the case if for instance our catalog service would like to publish any updates with catalog of items so that other services can be informed about the changes one of the key benefits of using asynchronous communication is that it enforces a microservices autonomy let's see how it's enabled in a single receiver scenario we would have again our client talking to our service but our service will not talk to its dependent service it will instead send an asynchronous message to a broker and he will immediately acknowledge to decline the successful reception of the request the dependent service will consume this message from the message broker as soon as possible and will eventually provide a reply via the same broker at that point the client can request a status of its initial request to our service or our service can notify the client of the response all of the services in our system would follow the same messagebased approach including cases where a reply is not required from the call service the great thing about this kind of layout is that when one of the dependent services fell it would not cause any impact on the other services since all of them have been decoupled from each other and only talked to the message broker so the same sla that one of the services presents can be honored across the entire system assuming that the message broker offers high availability so with asynchronous communication partial failures are no longer propagated each service has its own independent sla and best of all the autonomy of all microservices is enforced given the lack of coupling between them one of the nice things that asynchronous communication provides is the ability to asynchronously propagate data across services in the synchronous communication scenario when the client requests the user the user's inventory and since the inventory service only has the data that's relevant to it inventory has to first talk to the catalog service in order to retrieve additional details about each item how comes asynchronous communication health here well thanks to the presence of the message broker what we can do now is have the catalog service publish an event each time a catalog item is created or updated or deleted such event doesn't have to have all the details of each item but only the ones of interest to client services we can then have our inventory service listen to these events and create its own collection of catalog items in its own database as long as we have a highly available message broker the list of catalog items in the inventory database should be eventually consistent with regards to what's in the catalog service now when the client requests the user's inventory inventory has no need to go out into any dependent service to request item details it has everything it needs in its own database and it can immediately provide a reply to the client with no additional latency so thanks to asynchronous communication we can enable eventual consistency across our system the autonomy of our services is preserved and the previous interservice latency is reduced or completely removed in the next lesson we will start implementing asynchronous communication between our two microservices we will introduce revit nq as our message broker of choice given that it supports the amqp protocol it is lightweight easy to run locally and is very popular in the open source community revit queue introduces a concept of exchanges which you can compare to a mailbox when a service like catalog needs to publish a message it will send it to an exchange in gravity mq and with the appropriate bindings in place the exchange will distribute the message to any of the configured queues from there habit and queue will take care of delivering the message to any subscribe services like inventory we could use revit queue directly in our code but we would first need to create the exchanges and queues and configure the bindings to ensure messages are properly routed also our code will be tied to ravitmq and if we ever wanted to move to another message broker we would need to rewrite a good part of our services code for this and a few other reasons we will instead use mass transit on top of raviten queue mass transit is a popular open source distributed application framework for net mass transit can take care of doing most of the heritage mq configuration for us and is able to integrate with multiple other message brokers while allowing our services to stick with a higher layer of broker agnostic apis as part of this mass transit introduces the concept of a publisher and a consumer which is what our service code will focus on let's start coding just like we need to define dtos to establish contracts between a rest api and our api consumers we also need to define the contracts that define the messages to exchange between services that use asynchronous communication however this time we will define the contracts in a separate project mainly because we will later package and share the contracts with other services so they can easily use them so let's start by defining the contracts that our catalog service will use to send events asynchronously anytime an item is created updated or deleted so here we are once again in our catalog microservice project and what i'll do is i'll open my terminal via ctrl j and then i'll switch to the search directory and i'll go ahead and create a new class library so i'll do dot net new classlip and the name we're going to give it is play that catalog that contracts okay so now we have a new contract project over here and before we forget let's make sure we get a reference from the catalog project into the contract project so what i'll do is i'll go into play that catalog that service and then i'll do dot net add reference and it's going to go into play that catalog that contracts lay that catalog.contract.cspro so i'll make sure that we can use this contract from the a catalog service now let's go to our let's collapse this and let's go to our contracts project and let's actually collapse this terminal and let's delete this class one we're not going to need it and let's actually bring in a brand new file into the contracts project we will call it just contracts.cs let's give it a namespace i'm going to replay that catalog that contracts and here we're going to declare three records that are going to represent these contracts four items are getting created updated and deleted so let's start with the created case so public record catalog item created so here we need to specify not everything about the catalog item but really the stuff that our consumers are interested in so in this case what our consumer needs in this case inventory needs to know is the item id the name and the description so let's specify that so good item id let's import the missing namespace the name and the description and then we need to specify the the event for when items are getting updated so i'll just copy the one for created since these are very similar uh i'll say update okay it's really the same information we're going to emit any time and writing has been updated and then lastly let's define catalog item deleted and in this case the only thing that we need to communicate is the id of the item so in this case it's just going to be good item id so with that we have defined all the controls that we need and in the next lesson we will update the catalog service to start using these contracts and a few new nuget packages to start publishing messages to a service broker it's time to update our catalog microservice so that it starts publishing messages anytime an item is created updated or delete it so i'll start by opening a terminal so that we can bring in a couple of uh nuget packages that we're going to need so here i am in the play that catalog directory i'll switch to src and to play that catalog that service not the contract but the service one and here i'll add the net add package masstransit.asp.net core okay so this one brings in a bunch of functions that we're going to use in order to interact with the mass transit libraries and the next package is going to be mass transit that habit mq so this one introduces a couple of additional api so that we can explicitly use the a rabid nq service bus okay so with those added let me close this terminal and i'll go to play catalog service and into our items controller and perhaps i'll close the navigation pane for now and here we're going to do a few things first let's get rid of this temporal code that we added in previous lessons to simulate temporal failures so we don't need really any any of these anymore remove that remove that and also remove this request counter that we had added now the first thing that we're going to need here in order to be able to publish messages is what we call a polish endpoint so this is the this is the class that allows us to really communicate that we want to send messages to some location so i'm going to declare a variable of type i publish endpoint let's call it just publish endpoint and for this we're going to need to import the mass transit namespace and then we're going to receive this variable as via dependence injection into the constructor and then we will grab that instance into our pollution point variable now we can go to each of our controller actions operations where we want to push a message and start sending those messages so i'm scrolling down into our post async method and what we're going to do is that just after creating the item in our database we're going to publish a message announcing that the message has been that the item has been created so i'll do await foolish endpoint dot publish and here we're going to use our new set of contracts and we will start with our catalog item created contract and let's see control dot we need to import the play catalog contract namespace and here we have to provide of course the item.id item.name and item.description and that's really all you have to do to publish a message and i'll copy this line because now it's time to go to our put async method and do something very similar so just after updating the item into the database over here let's add and paste that line but in this case the method is going to be catalog item updated and we will choose the existing item variable that we have here we'll use the the id the name and the description i'll copy this once again and let's go to our delete async method and again just after removing the item we will go ahead and publish a message saying that we have a catalog catalog item deleted which is going to be just the id that we received from the from the parameter so yeah so that's all you have to do and so now any any consumer of these messages that is listening to to to the queue to the right queue it will be notified that an item has been created updated or deleted now what we have to do is to do the proper registration in startup uh to configure and to register the classes that we need for mass transit from wmq so i'll open my explorer here and i'll go first to upsetting.json here just like we did with mongodb we need to add a little section for our rabbit enqueue settings so i'll open a section here let's name it rabbit mq settings open a section here and here the only thing that we're going to declare at this point is the host so which which where is this uh this gravity mq server living and in our case since this old local machine is just going to be localhost you could specify more details like username password and a bunch of other settings but for now for local purposes we will just accept the defaults and we will go with localhost save that now just like we did with the other settings libraries settings classes we need to introduce a class that represents a habit and q settings so that we can use that in startup so i'll create a new settings directory here now and of course we will move this later into our shared command command library but for now let's just do it here and we will do that refactoring later on i'll add a new file into the settings directory let's call it rabbit nq settings that's cs let's add a namespace that catalog let's service that settings and then let's declare our class public class habit mq settings and as we know the only thing that we need here is the host so i'll declare our string host and as with any other settings class we will do use this as as init as opposed to set because and nobody should be setting these these properties after they have been uh deserialized from the configuration file i'll save that and now it's time to go to startup to register with the services that we're going to need so i'll go to startup and again i'll collapse this navigation pane so here in startup i'll locate our configure services method right here and then we will add the mass transit a classes just before the controllers let's do it here we're going to say services that add mass transit and we will receive a variable here that we're going to be using to configure things i'll open a section here close this let's see if we're missing something yeah so we need to import the mass transient space and then we will use this x variable here which is that we call the configurator uh to specify the type of transport that we want to use in our case that transfer is going to be rabbit and q so we have to say x dot using rapid mq and then we need to receive we need to specify a function to configure the habit and queue so in this function we're going to declare two parameters which is going to be the context and the configurator and then let's give it a let's give this function a body stat say and the first thing we're going to do here is to get an instance of those rabbit mq settings so that we can figure out what's the host that we're going to use so we will just say have it mq settings it's going to be configuration get section and then the section that it should have the name of covet mq settings have it into settings class and let's see if we're missing something yeah we need to import the play catalog service settings namespace and when we have that we can say okay so now get it as a habit enqueue settings type okay so we have the settings and now what we can do is use the configurator to set the host where our gravity mq instance lives and that's going to be in gravitysettings.host and now we'll add one more line this is not necessary but i think it's very handy and this line is going to help us define or modify a little bit how the cues are created in the rabbit and queue so i'll do configurator dot configure endpoints and here we're going to receive the context and afford mater and what we're going to use is the kebab case endpoint name formatter see if we're missing something yeah we need mass transit that definition and in this formatter we're going to define um we're going to define first uh the prefix that we're going to be using for our cues and that's going to be service settings dot service name and then we will not need to include the full name space of our classes in those queues so we'll say we'll just say false here and lastly we'll add one more line just after this one to start they must transit the hosted service so we will say services that add holds service and this is the service that actually starts the rapid mq bus so that messages can be published to the different exchanges and queues in rapid queue i'll save that and for one last change i'll go to our i'll go to our explorer and i'll go to app settings at development.json and this is something that i like to do more for demonstration purposes than for anything else but this is a changing the default login level from information to debug so i found that this is going to be very handy for us to understand what's going on behind the scenes when messages start flowing between services so we'll do that over here and at this point the catalomic service is ready to publish messages to have it and queue but we don't have a rabbitmq instance available just yet in the next lesson we will expand our docker compose file to also stand up a rabbitmq docker container that our catalog service can communicate with it's time to stand up our rapidmq message broker and of course we'll use docker for that so here i am in visual studio code and what i'll do is i'll open our play.inf directory play that infra and then i'll do code.r and here i'll just go ahead and close this close that and i'll open our docker compose java file and perhaps i'll collapse this so the first thing that i'll do is i'll go ahead and remove this comment that we had at the top and now we can go ahead and start declaring our gravity mq service so just like we did with we'll come here and we will declare a service for driving queue let's name it having queue and then as usual the first thing that we want to declare here is the image that we're going to use that image is going in this case is going to be the standard rabbitmq image that includes also a portal to manage a derivative infrastructure so that would be driving queue management then we will mention the container name the name that we're going to give to this container and it's just going to be rabbitmq then we'll go for the ports section we're going to open uh two ports one port for our services to communicate without having queue and then another port for us to be able to navigate to the cabinet and queue portal so the first port is going to be five six seven two maps to the same one internally and the other port is going to be fifteen six seven two which maps to the same port internally too so the first one is going to be used by the services to publish messages to or to consume messages from hybrid and queue and the second one is going to be used to be able to go to the portal to the writing q portal then we're going to go to the volume section and we're going to declare a volume also for having queue which is important because we don't want to be missing those messages if the gravity and queue container goes down so i'll just declare gravity mq data and now we have to uh we have to map that volume into some location in our rabbit mq image or container so i'll declare volumes i will copy have it in queue data and then location the location that you want to map inside rabbit enqueue is going to be var leave grab it mq and one more thing that we have to suffice here which is pretty important is the hostname so hostname and we will give it the value of rabbit enqueue so this one here is pretty important because this is associated to how having mq stores data internally and if you don't specify it then it gets a random value and then each time we restart the container gravity and q would store data in a different place which is not going to help us really a lot so keep in mind you always want to specify here it doesn't matter what value is here but you have to specify some value okay so with that done i'll do ctrl s to save this file and then i'll open the terminal and it's time to start this container via docker compose up dash d hit enter and this is the first time that i'm pulling in the hovering q image so you have to download it to my machine like i said next time it will be faster so yeah now we have we have raving queue up and running over here and with that we can start trying this out so i'll go back to our catalog project and here we're going to start the catalog the catalog web server uh but we'll do it via dotnet run so that we can take a closer look at what's happening behind the scenes so i have opened the terminal ctrl j then i'll do src and then i'll do data catalog that service and then let's just do dot net run here i'm going to collapse this also and so a couple of things to notice here is that uh so yeah mass transit is doing its job it's starting the starting the bus and then it has connected to it has connected to gravity and q in port 5672 is using the protocol aem qp so here's where you can see the actual address of rabbit enqueue in the docker container uh like i said this is the one port to connect uh today to the queues and so things are looking ready on this side so now we'll go to postman and what i'll do is i'll go ahead and i will create an item in our catalog so i'll go to our catalog api and i'll open the post one and here i'll create some new item let's say this time we're going to create an antidote so antidote curse poison and then price going to b7 and i'll hit send so that then got created in the database but now let's see what else happened so if we see now here yeah the item got created but also an exchange was created uh in gravity and queue so mass transit created this exchanging gravity queue for us that's one of the nice things about mass transit so we don't have to create it manually and it got the name play catalog contracts and then the name would be catholic item create so an exchange will be created for each of the messages that we publish from from catalog and you can see that after created exchange it also sent the message to that to that exchange the message was sent over there and so if you want to see how this looks like in gravity and queue actually we can go ahead and check out the java and q portal so let's open that portal now here we are in the browser let's go to localhost 15672 is the easy place and here we're going to use just the default username and password for having queue so that's going to be guest and it's exactly the same password just guest login and in this ui you can see a couple of a bunch of things but really the one thing that i wanted to show you now is the uh the exchanges and as you can see there is a exchange created here cattle guiding created and issued i find out meaning that anybody listening to this exchange will be able to get the messages and then cattle guide and create it i'll go in there and then there's not much to see here because the exchange just takes messages from one place to the other it's not going to store the messages and then as you can see the exchange right here in binding section it is not connected to any it doesn't have any bindings just yet and that's because we don't have a consumer of these messages yet which is going to be inventory and but it's not there yet so the queue has not been created and so there's no destination for these messages just yet and so at this point we are able to publish messages from our catalog service anytime our items database is updated so in the next lesson we will generalize some of the code that we have added here into our common library in preparation for having inventory start consuming the polished messages let's move the code that configures mass transit and rabbitmq into our common library so that things get easier and cleaner for catalog and any future mic services so here i am back in our catalog project and i'll start by going to our settings folder and i will copy our raven queue settings file copy that and then i'll switch to our common project our common library i'll open our settings folder and i'll paste the copied class and i'll grab the name space from some other of our settings classes i'll just fix that namespace here save and now before adding the mass transit classes let's bring in the nougat packages that we're going to need over here so i'll do ctrl j let's go into sirs play that common and let's add the same packages that we already added into catalog so dot net add package mass transit that is b net core and then let's do mass transit that have it mq all right so with that done let's go ahead and create a new folder let's call it mass transit and perhaps let's close this terminal for now and just like we did with mongodb let's add an extensions file here but we're going to add our handy extension method so let's first declare namespace click that command that means transit and now let's create our class it should be a static class and now we'll bring in our extension method so this is going to be public static iservice collection add mass transit with rabbit mq so that way we can do all the registration for mass transit and everything queue in one location let's add the missing space and let's expand let's extend i service collection services and here is where we're going to bring that code from the catalog service i'm going back to catalog into the startup class scrolling down i'll copy these lines copy that into common and i'll paste them over here and now let's start fixing all these missing name spaces so admins transit we need to import using mass transit and then uh for gravity mq settings we'll need to import play that command.settings give that case endpoint name for matter we'll need my strategy.definition okay and just before we also will need an actual instance of the configuration class and an instance of our service settings class now these are very similar to what we did in mongodb so let's see if we can get something from there so mongodb extensions let's see let's yeah let's grab these two lines let's close this and into this spot there and let me collapse this navigation pane now so here we also need an entry an import for eye configuration let's grab that extensions configuration and you can notice that there's no service provider variable available here however we do have a service provider and that is this context class that that's that's over here this ibus registration context exactly a service provider so we'll use that as the class that can give us an instance of i configuration we can also fix this other configuration member here and let's also rename this x variable here to something more meaningful let's name it configure and since we are here one more thing that we can do is to perform the consumer's registration the consumers are the classes that are in charge of consuming messages from the rabbit and queue message queues we have not created these classes just yet for catalog because catalog is not consuming but just publishing messages but we will create these classes inventory so since inventory will be using this method we might as well just add that registration over here so i'll open a couple of lines here and what i'll do is i'll just say configure dot add consumers and there's a few ways to register consumers and the way we're going to do it is that we're going to specify the assembly that should have all the consumers already defined and that's going to be the uh the entry assembly for whichever microservice is invoking this this class so to get that we're going to say assembly and we need another import here using system reflection that get entry assembly and that that should do it okay so any consumer classes that are in that assembly will be registered by this method and finally let's go ahead and return our services instance to complete this method okay so with that let's make sure everything is built in so i'll do ctrl shift b and yeah everything builds just fine and now let's go ahead and package it all these new changes into a new version of our nougat package so let's go back into our powershell terminal and perhaps our clean this and listen we did before we're going to do dot net pack but this time we're going to specify a version last time we didn't do it and that generated version 100 for package this time we need to increase the version so that our consumers can actually notice that there's something new available in the in the package so to specify version what you can do is use the d p sorry parameter and then you specify package version and then you specify the version so i'll say 1 0 1 and then just before we'll specify an output directory it's going to be the same location as before packages enter and we got a new nuget package created right there so now let's go back to our catalog project and start taking advantage of this package and first thing i'll do is i'll delete our settings directly once again we don't need it get rid of it then i'll go to our project file and since we're bringing in this nuget package that has all the master assets stuff we should not need these two references so i'm going to get rid of them save and now what i'll do is i'll just go to our play.com dependency and i'm going to bump the version number here this is one zero zero bumping it to one zero one i'll hit save this popup dialog shows up asking us to resolve the updated dependencies so i'll do a click on restore and that's going to bring in the updated package into catalog so i'll close this and i'll close that and now it's time to update our startup class to take advantage of the new package and first let's get rid of this unneeded import at the top and now what we can do is just since it's fluent let's expand on top of our admonk repository so let's just do add mass transit with rabbit enqueue we may be missing a namespace we need to import play.com on that mass transit and then that becomes a one line that we have to run to execute all this stuff that we were doing before so i'll get rid of all these lines save and that should be good enough i'll do a ctrl shift v to make sure that things are compiling yep it's looking good so let's go back let's open a new terminal here and let's verify that things keep working properly so i'll do i'll go to src it's not into contracts we want to go into service and then i'll do dot net run yup so yeah we are connected we have connected to the rabbit and queue so it's time to do something about messaging so let's go back to postman and last time we had created this antidote item and so instead of creating a new one why not let's try the an update operation so i put so i'm going to just copy this and then let's go into put and then in the body we're going to just paste paste this so it's the same antidote curse poison but let's say that the price is now 9 and then let's bring the id hopefully the same id that we used before so copy this id into the url for the put operation and then i'll hit send so we go 204 so it was a success and now let's go back to vs code and yeah just like before the exchange was declared and the message was sent to the exchange as you can see but this time we should have a new exchange so let's go back to riveting queue briefly and here let's go now to exchanges and as you can see there's a new exchange here cattle guiding updated so things are working properly and one last thing that we have to do here is to actually publish the catalog contracts as a nugget package so that inventory can use it in the next lesson so let's go ahead and go back to catalog and here i am i'm going to do ctrl c in my terminal so that the whole stops and then i'll switch to our play dead catalog that contrast directory and here i'll do what we did before so dot net back and then output directory packages that should go ahead and produce our contracts package hit enter and there it is so now we have a contacts package that inventory service will be able to use to consume the messages in the next lesson we will update our inventory service so that it can consume the messages published by catalog the whole point of moving inventory to using asynchronous communication is to have its own database of catalog items that it can use without ever having to get in touch with the catalog service api therefore let's start by defining the entity that represents catalog items in the inventory microservice so here i am back in our inflatable inventory microservice and i'll open our entities directory now this new entity that we're going to create has some similarities with inventory items so i'm actually going to start by getting a copy of inventory item so i'll just copy this and i'll paste it right there and let's rename this into catalog item catalog item and we rename this as catalog item which also implements identity but in this case it's not going to have most of these properties but it's only going to reduce the id now remember the categorizing has a bunch of properties in the catalog service but here we will only introduce the properties that make sense for inventory so in this case this is going to be we'll start with the with the name and then we will also need description okay so keep in mind that as you are bringing in these entities from other microservices you don't have to have everything that these entities have in the other service it's only a the version that the new market service needs in this case us id name and description with that done let's go ahead and start bringing in the nuget packages that we need for this so i'll go to play.inventory.service.csprock and then i'll open my terminal so let's go to src enter the service play inventory service and let's get a reference to our new a catalog contracts nuget package so dotnet add package play that catalog that contracts remember this has all the contracts that we can use to consume messages from catalog okay with that done let me close this and now you can see that we have applicator contracts here but we also need to bump the version of play.com because remember we added some new uh so some new classes in there so album from version one zero zero to version one zero one i'll save that let's go ahead and restore the new the new nugget package now we can close this close this these files now it is time to define the consumers and like i said before the consumers are the classes in charge of consuming the messages that have been published by any other microservice so to define the consumers let's go ahead and create a new folder let's call it consumers and we have to create one consumer for each of the different operations that happen in catalog so that's for creation update and delete of of catalog items so i'll go ahead and create a new file let's name this one catalog item created consumer copy the name let's give it a name space service consumers okay so this is our catalog item created consumer and the first thing that you have to do about this consumer's class is to make sure that they are actually consumers and to do that you have to implement the iconsumer high consumer interface which is part of mass transit and i'll do control dot so using mass transit and here you also have to specify what is the type of message that this consumer is going to handle and that type of message is actually coming from them the contracts that we're bringing in from catalog so in this in this case it's going to be catalog item created let's see if we're missing something using play.contracts so then let's go ahead and implement this interface so i'll do ctrl dot here implement interface and as you can see we just have to implement one method that which is the consume method so which is where we're going to actually uh perform the action of of consuming the message and so what we want to do when we consume the message is actually a storage in our local catalog items database so to do that let's first introduce a repository that we can use for for that so i'll declare readonly i repository of type catalog item okay so this is the new entity we just introduced it for catalog guidance in inventory all right see if you're missing something play that common for i repository and play that inventory service entities and now we need to inject this repository in the constructor of this class so let's define a constructor so public catalog item created consumer and so here's where the repository comes in okay so let's say this data repository equal repository let's now go ahead and implement the consume method for this class so i'll get rid of this and let's first get a copy of the of the message so the message that we're receiving is available in the context variable as the message property so let's grab that copy there and then what we want to do as we consume this message is probably first make sure that we have not consumed this already right uh we we may have a very consuming message of the creation of an item uh with the idea that we're going to get in this message uh and if we did we already would have that into the database so let's make sure that we don't have it and if we do have it let's just return there's nothing else to do but if we don't have it we'll go ahead and create it so let's see item is a weight repository not get async and that's going to be in message dot item id let's also make sure that this method is async and then if item is not new then we will go ahead and return okay because in this case it happens to be that we already created this item in our local database so why would we create it again if not we will say new catalog item and then we'll say all these message.item id name is message that name and description is message the description finally we'll go ahead and do repository dot create async of this item okay so that's all you have to do to consume a message that represents a new item that has been created in the catalog like i said we just verified if the item is already here because it could happen in the cases where for some reason the publisher publishes the same message twice and so we don't want to be having errors here because we already have the item in our catalog guidance database so if we don't have it we'll go ahead and define it and create it into our local database let's go ahead and do something similar for our a update so when a catalog item has been updated so i'll get a copy of our of the consumer and let's just rename it into catalog item updated consumer okay so i'll do this and then the the message is catalog item updated so let's fix a couple of things constructor there okay so we are consuming now catalog item updated and here the logic is going to be a little bit different so for an update it could be that we already have this inventory item in our local database so in which case we'll need to go ahead and just update the properties or it could be that this is the first time that we receive this message for this item in which case we'll go ahead and create it so now in the case that uh so first just before we can go ahead and get the item but if the item is new so we'll change this if item equals no then we will go ahead and define these lines that we had over here there so editing is new we don't have it in the database so let's go ahead and create it otherwise let's just update the the properties that make sense in this case it's going to be item.name equals message.name and item.description equals message.description and in this case let's go ahead and call weight repository that update async item okay so quick recap we for an update operation we go ahead find the item if we cannot find it we will go ahead and create it into the database and if we find it we update nameless description and update it into the database now let's go ahead and implement our third consumer which is going to be four deleted items so again i'll get a copy of this last consumer paste here and then rename it into catalog item deleted consumer copy this name so i'll update the name of the class the constructor and then let's make sure we also update the message that we're handling here this is catalog item deleted here and there and in this case things are even easier and so we will go ahead we'll try to find the item and if we cannot find it uh it means that for some reason it does not exist in our local database so there's really not much more to do in our case so we will go ahead and just return we don't have it just go ahead and return and if we have the item then we can go ahead and say weight repository remove async message.item id okay so with that we have our three consumers defined and now it's time to perform the proper registration in startup and before we can do that let me go to app settings.json and we need to declare those rabbitmq settings so that we know how to communicate to have it in queue so i'll actually go back to catalog our catalog service over here and i'll just grab those three lines for hybrid mq settings for an upsizing adjacent and then back to inventory we will add that over here same thing we're talking to localhost for arriving in queue now let's go to startup okay um perhaps i'll collapse this for a moment so let's do a few things here so as you see we still have this logic to use the catalog client to talk to the catalog service uh we will not be using this anymore but let's keep this logic around in case you want to reference it later but what we're going to do is we're just going to refactor it into another method so we don't have to have all this stuff hanging around here so i just selected all this logic to use the you know the retries and the configuration of the client i'll do ctrl dot and i'll say extract method so we'll name this method at catalog client and i'll take this method and just send it to the end of the file so that we don't have to see it frequently and now a couple of things that we have to do here for for uh our new a catalog items repository and mass transit so first we need to introduce a new repository here for the catalog items so i'll say add repository catalog of catalog item and then we need to give a new name for this new collection of items in this case it's going to be catalog items okay so keep in mind that both of these are going to live in the same database the same inventory database but it's two collections one collection for inventory items and one collection for catalog items and then we also need to add the mass transit registration so i'll say add as transit with habit mq let's add a missing space and that's pretty much it on startup then let's go back to our explorer one more thing that i'll do is just like we did in catalog let's flip the default log level so that we can see also what's going on regarding all these message exchanges so i'll change this to debug and with that our inventory service is ready to start consuming messages but one more thing that i'd like to do is to actually clean up our databases and i like to do this because at this point we we do have some data both in inventory and catalog site but that that data has never been synchronized at all so it will be better to use a start clean in a situation where both sides are actually synchronized from the start so i'll go back to mongodb the mongodb extension i'll expand this and as you can see we do have the catalog and inventory databases so to clean them up i'll just right click and say drop database i'll drop catalog and then i'll drop inventory you may choose to not delete them but that could cause issues as as you start moving forward so it's better to use starkling in this case at this point i'll start our micro services so i'll do ctrl j to open the terminal i'll go to my terminal and perhaps i'll do clean and just so that we can see things better what i'll do is i'll see i'll collapse this and i'll bring in yet another terminal with the split terminal put on here so that we can see services in both sides so perhaps what i'll do is i'll switch to a catalog on the left side so i'll go to play that catalog and then play catalog service and on the right side i'll stay in inventory so i'll do play inventory service okay so let's clean both sides and now we can start both services i'll do dotnet run both sides and now notice in the right side that a few new things are happening and perhaps i'll move this around a little bit and yeah it may be a bit hard to see but exchanges has been declared for the for the consumers that we declare here you can see we have exchanges for a cutter guiding created updated and deleted and if we scroll down a little bit let's see these exchanges are now connected to the queues so you can see that this this exchange is now connected to our new inventory catalog item updated queue same for created and deleted and the consumers are reporting that they are okay so they're ready to start consuming messages okay so let's move this over here so now let's see this in action so let's go to postman and what i'll do is i'll start by creating a brand new item so i'll go to our post item api in play catalog service body and let's define our classic potion example again we'll say potion sources small amount of hp and the price is going to be 5. i'll go ahead and hit send the item has been created and then let's go back to our terminals and see what happened so as you can see on the left side the change was declared cut the guiding created and the message was sent right so cattle guiding created was sent and then the right side we can see that now we actually received the message and that was handled by the cattle guide and created consumer so if things went uh correctly we should now have a copy of the catalog item in our local a catalog guidance collection in inventory site inventory database let's go to mongodb let's see what we have so i'll expand this so we have the catalog database with this item created here and then we'll expand inventory and then you can see that we do have now our catalog items collection with that item created over here so the item has been replicated from catalog into inventory we can now take a look also the activity that happened in driving queue so let me go to the driving queue portal over here and let's take a look at exchanges so see that we now have the three exchanges uh for category created deleted and updated from the catalog side and then also the the changes from the inventory side created outdated and then if we go to queues you can see that now we have the three queues for the three types of events and if you go to cattle guide and create it we could see here any activity that goes across this queue now the item has been already consumed so there's nothing not much to see here but let's see what happens in a case where let's say that our catalog service is is not running right so actually our inventory service is not running so our catalog service pulls some message but inventory is not running now that the queue is up and running things are going to work in a speed of a different way so let's go back to inventory and i'm going to stop the terminal on the right side i'm just going to do ctrl c inventory stops now and let's go back to postman and create yet another item so i'll create an antidote which cures poison and price is going to be seven so i'll go ahead and pause this and then if we go back to rabbit and q let's see gather guy and create it you can see that now there is a one item in the queue as reflected by this as you can see it's one item which is waiting to be consumed by somebody so here is where the nice thing about asynchronous communication starts happening so there's no need for cataract to be up and running all the time uh inventory can nicely just keep polishing these updates uh to their to to their items and then whenever inventory comes back it should be able to consume the the message and in fact let's go back to our terminals over here you can see that the category was created on the left side and now let's go ahead and start a terminal on the right side let me collapse this once again okay so on the right side i'm going to do.net run again and then you can see that right away inventory is able to consume the new message so the databases should be in sync again we can see that there's no more messages here waiting the message was consumed and our databases should be once again sync let me refresh this so yeah we have two documents here and we have two documents over there so things are in sync so our inventories microservice now have a nice way to stay in sync with any updates to the items managed by the catalog service in the next lesson we will update inventory so that it starts taking advantage of this new capability anytime it needs to present data that is partially coming from catalog now that our inventory microservice has its own copy of the catalog items it no longer needs to query the catalog microservice to gather additional information about the items of inventory so let's update our inventory controller to take advantage of its new catalog items collection so here we are back in our inventory project and i'll go ahead and open our controllers folder and i'll go to items controller let's collapse the navigation pane to get more space and let me scroll down a little bit and the first thing that we will do is to get rid of our catalog client because we will no longer need to invoke catalog client i mean the catalog service anymore instead of that we're going to declare another variable here is going to be just another i repository but in this case it's going to be off catalog item so this is going to be our catalog items repository and since we're introducing this new repository let's also rename the previous one so that it better resembles its purpose so this is going to be our inventory items repository let's also rename this the variables in constructor so this items repository becomes inventory as a repository and then the it's time to inject also our new catalog items repository as opposed to the catalog client here we will capture that so with that let's go down into our get async method and here's what we're going to do the first thing is that we definitely don't need to cut to call catalog client anymore so we're going to get rid of this we still need to get the list of all the inventory item entities uh represent the items in the user's inventory so this this stays but after that what we want to get is a from our local catalog items collection we want to get all the corresponding a catalog items that i mean the ones that could respond to the inventory items on inventory the today's inventory so to get that let's first get all the list of all the catalog item ids that that are involved in the inventory items collection that we have here so to do that let's do this so item ids equals inventory item entities select let's do a little projection here where item item dot catalog item id this gives us the list of all the the catalog items that we have an inventory the ids specifically and with that we can go ahead and get the actual catalog items so let's do catalog item entities is weight catalog items repository get all they sync where item and what we're going to say is that we want to get all the items that are in the item ids collection so i'm going to say item ids contains item dot id so now here we have all the catalog items that match the the items that we have an inventory for this current for the current user having that we can go ahead and update this little function here so they take advantages of this new items collection and i'll say catalog item entities is going to go here so now we can go ahead and say okay so as we go through all the inventory items first we're going to look at the catalog item entities and we're going to find the catalog item whose id matches the id of the catalog item id of the inventory that we're looking at so that's a catalog item and then we'll keep moving forward as usual and we say okay so now that we've found the inventory item and now that we have the catalog item let's go ahead and turn it into dto adding the catalog item name and the catalog item description okay so i don't think we need to make more changes to pause async so we should be ready to start using this so i'll save this i'll go back to catalog i'll just going to hit f5 to start the service and i'll go back to inventory and i'll do the same f5 to start the service and now let's go ahead and go back to postman and let's grant one item to a uh to our user so the first thing that we'll do is actually get the list of current items in our catalog to know what to grant so i'll just open our get operation in the catalog service and i'll hit send here we are we have currently a portion and an antidote so let's say we want to do the potion so i'll copy the id of the potion and now let's go to the to the inventory collection let's expand this and i'll go to our post operation where we can assign a assigned one item to a user so i go to body i'll paste the catalog item id that we just copied over here so this is the item to assign and then just like before we need a user id so and just as we did before let's use the postman function go it to generate a random user id and finally let's get some quantity let's say we're going to assign one portion to this user okay and so with that i'll go ahead and pause that sent and it's done and if it worked now our user should have one potion right so i'll go ahead and first we need to figure out what's the idea of the user that was generated and we can do that from the console so i'll click on the console and i'll go down to our post operation request body and it's right here this is a user id that was generated i'll copy that close console and then we can go to our get operation to get all the users in the sorry all the items in the user's inventory and so we'll get the items for this user i'll hit send and as you can see now we can see that this user a has a potion has one potion but more instruments interestingly it is able to show the name and the description of the potion from the local catalog items collection so it no longer needed to go ahead and and talk to the catalomic service to retrieve decision information so things are much more resilient and rely and faster now because we don't need to go out and ask for this additional info now what would happen if we go ahead and update the description of this catalog item in the catalog microservice how would that look like here let's try that out so first i'll go to back to our get items results and i'll copy a few details about the potion i'll just copy that and then i'll go to the catalog collection and i'll go to the put operation here's where we can make updates to our item so i'll just come here paste that fix indentation and let's say that instead of having this description it just says restores some hp that's going to be the new description also the id of this item is this one here so let me grab it go back to put i'll paste that here and so let's go ahead and update this item in the catalog microservice so i'll go ahead and do that and then i'll go back to our query for the inventory items of the user and let's see what happens with the description of this of this item so i'll hit send and as you can see the description is already updated and this is because as soon as we updated the item in the in catalog my service a message was published into habit mq and then our inventory service grabbed that update into its local database and is ready to present the updated description as we query for items so this is great but now what would happen if our catalog microservices is having issues actually what happens if it's completely down right so it has a major problem what would happen with it with inventory maker service can it still keep working just fine let's see i'll go back to catalog here's catalog i'm just going to stop the service so service is completely down and in fact if we go back to a postman and we try to get items again let's see what happens connection refused because the service is completely down but then let's try to get all the items on the user's inventory so i'll hit send and still works even more i can try granting yet another item to the user's inventory so just to test this out i'm going to start catalog once again hit a 5 back to postman let's go ahead and get the list of items and now i'm going to grind and grant the antidote to that same user let's do antidote into the post operation body so let's grab the antidote let's make sure we use the same user id it's right here maybe it's ready and then again like i said catalog is having problems i'll just stop it it's completely down it's not working yet i'm going to go ahead and grab that item to the user i hit send 200 okay so it looks like it was successful and then let's get all the items inventory now so i'll hit send again over here and as you can see we can query for the for all the items and all the items are showing name and description regardless of the fact that the catalog microservice is completely down so this is the power of asynchronous communication and this is how you enable very resilient communication between microservices both services are now really autonomous because they don't rely on each other to be available at any given time one more thing to consider is a case where one of our consumers is not able to consume the message properly perhaps due to some issue when trying to talk to its local database so for instance let's go to our inventory inventory service over here and i'm going to stop this for now and close terminal and i'll go here into our consumers let's say cattle guide and create consumer and what would happen if this line here is having trouble right so when we when we go into the consumer uh this this all this logic happens because we're consuming the message but if we fail if an exception is thrown in this in this case and the message is going to be sent into some error queue and if you would not be able to consume it anymore so at that point you missed an update from the from the catalog mic service so is there a good way to handle this so there's to be that yeah there's a there's a way to do that so if you go back to our to our common library so here we are back in common library and we're i'm going to go to the mass transit extension that we created before and scroll down a bit and what we can do is to enable analysis we can do is enable message retries for the consumption of the messages so you can go here and say configurator that use message message retry and then here we're going to define our retry configurator okay let's open this section and then you can say retry configurator that interval and then the first item the first parameter you're going to specify is how many times you want to retry so anytime the the consumer is not able to consume the message how many times you want to retry that consumption so let's say we want to say 3 and then you have to define the time span or our time between retries let's say that's going to be time span let's import missing space from seconds and that's going to be five five seconds let's also import another missing space we need to use using green pipes here and that's all it is so with that logic any time a message is is not able to be consumed by the consumer it will predict right three times and with a five seconds delay in there and there's a bunch of different ways to configure this depending on how you want to do your retries and with that let's just save extensions and then if you wanted to consume this in your microservices as usual you will go ahead and generate another version of the nugget package so in this case it would be it would just do dot net back it would be package version let's say in this case would be one zero two and then we send it to the same location fe4 packages package generated and then you would just go back to catalog and update its version over here to play.com102 save restore dependencies and then we would go back to inventory and do the same thing 102 save and then we'll not exercise this really in this lesson and restore but that's how you do it so from here on both microservices has this capability to retry the consumption of the messages so that marks the end of this lesson and of this model you now have two independent and resilient microservices that can collaborate asynchronously to manage a catalog of items and to grant and query for items in a user's inventory pack you also have a reusable common library that any of your mute future microservices can take advantage of and that you can keep improving according to your needs in this model you will connect the provided frontend project to your microservices to enable basic endtoend scenarios from a modern single page application by the end of this model you will have a solid understanding of the following how to get and build the frontend project in your box how to host the frontend project in a node.js server what is the structure of the reactbased frontend what is course and how to configure it in your microservices and how to debug the communication between the frontend and your microservices in this lesson you will install node.js which is a javascript runtime that will host the frontend portal and that also includes npm the package manager that provides all the dependencies required by the portal the only additional tool required to build and launch the frontend portal is node.js which you can get in the nodejs.org website let's see how to install node.js and verify the installation afterwards before installing node.js just keep in mind that the pages that you will see next will likely look a bit different depending on your operating system and the versions available at the time that you're taking this course but regardless the overall download and installation process should be mostly the same so let's now browse to the node.js website and here the first thing that you're going to see is a right away a few download buttons for your current operating system version and architecture in my case that will be for windows 10 x64 these are the two versions the one on the left is the most stable version available and the one on the right is the latest version available which may not be the most stable one but it has the latest features i would recommend going for the most stable version the lts version since that's a recommended one for most users now if the version that you would like to download is not here you can always go to the other downloads link over here and here you can pick the right version for your operating system and you also have a few other download options now in my case i'm going to go back to the first page and i'm going to download 14170 lts so just click there and i'll go ahead and start installer so click here here's installer so i'll just click next accept next next and next and at least for this course i have not seen the need to install any additional tools here so i'll just click next and install to get installation started say yes and so with that node.js is installed in the box so click finish and what we want to do now is to verify that the installation has completed properly so what i'll do is i'll just close the browser now and i'll open my visual studio code instance here and here in business to the code what i'll do is i'll open my terminal by pressing ctrl j and i'll just type a couple of commands to verify that the tools are installed properly so i'll just type node v to get the version of node.js which you can see right there 14 17 0 and and now also verify the version of npm which is the package manager that comes with node.js so i'll do mpmv and i can see the version right there also so with this we know that node.js has been properly installed and we're ready to move on in this lesson you will explore the structure of the frontend code base how to install its dependencies and how to build and run the portal before exploring the front end code base let me give you a few details about it the front end is a simple single page application that demonstrates one way to interact with all the play economy microservices a single page application is a web application that dynamically rewrites the current web page with new data from a server instead of constantly loading new pages it is built using react which is a javascript library for building interactive user interfaces i chose react because at the time of creating the course it was one of the most popular frontend frameworks and is easy to learn assuming that you have worked with javascript before it uses create react app to simplify how you do local development how you build and debug the code in your box and how you package everything in preparation for deployment finally it is hosted in a node.js server a very popular runtime for javascript applications there are a few things that i'd like you to keep in mind as you work with the provided frontend portal in these and the next lessons this is not a course about frontend development and certainly not about react as a backend developer myself i only know enough react to build this simple portal however i'm probably making lots of beginner mistakes and i'm probably not following clientside best practices in many places so please don't use this code as a template for the production level application but more as a basic example of one way you could interact with the microservices from a modern client you won't be coding this front end in this course there is both not enough time and i'm not qualified to teach you how to build a front end step by step instead i'm providing you the finished portal so you can use it as is it should work with no issues and no changes required provided that you make a small update to the microservices as i'll explain in the next lesson in this lesson i'll give you a quick overview of the structure of the frontend codebase with a focus on the areas that interact with your microservices as opposed to the many components that handle layout rendering and many other things finally please check out the links below if you would like to know more about the deck used in the front end project so here i am in a new bezel studio code instance and i have already opened my terminal into the projects directory where i have all my files and as you can see i have already downloaded and extracted the frontend project files into this directory play that frontend and what i'm going to do now is just switch to that directory and i'm going to open this instance of code into that directory by doing code that in dash r to reuse the window enter and here you can see the structure of the project files on the left side and what i'm going to do is first close this terminal for a moment i'd like to point you to the readme.md file so this is a file that will give you a description of what this project is about and a few other things and in fact what you can do is just open this uh preview window with this button that opens up review on the right side and close the original one so this gives you a nice view of the redmi file so as you can see this is crafty project it is creative prerequisites of the project and then it tells you how to build the project how to run it locally and also it provides a bunch of other scripts that are also available now what we're going to do is to actually follow this couple of first lines in this in this file to get started with the front end so as it says what you can do to install a all the dependencies of this a front end is a run just npm install so open my terminal once again here scroll down a bit and what you want to type just at the root of this project is npm install hit enter what this is going to do is to bring in a bunch of node models that represent all the dependencies that this this portal depends on including react bootstrap and a bunch of other things this is going to take a while depending on your internet speed because there's a lot of stuff that needs to get downloaded so just give it a moment okay so the dependencies have been installed and as you can see there's now a node models folder on the left side if you expand it you're going to find a bunch of directories have been created right so now that we have that we are ready to run the portal so to do that if you scroll down in the readme you can see that you can just do npm start and that's what i'm going to do here npm start enter so this is going to compile the entire code base and then it's going to start the node.js host okay so it compiles successfully and as you can see we get an address here to browse locally to it so i'm going to copy this address localhost 3000 and i'm going to go to my browser i'm going to paste that there and hit enter and there it is the portal is up and running in this box now in the home page here what we have is just a few basic things like the description of the project and then a couple of links uh both to go to the catalog section uh to get the list of the catalog items and the inventory section so that you can inspect which are the items that are in inventory back of a user notice that we also have a navigation bar at the top that takes you either to the home or to the catalog and inventory sections there's also links here to go to the rabbitmq portal if you wanted to to explore what's going on with the queues and there's also links here to explore the swagger soccer ui open api documentation for both catalog and inventory service and also a few other things general links to the different technologies that were used to create the whole the whole system now before we go and dive into the catalog and inventory sections which are of course the most important uh parts of this portal at this point uh let's go back to pieces to the code for a moment and let's explore briefly the files that are available here just so that you get an idea of how this project is structured so what i'm going to do is just close this terminal for now and close the readme and the first file that i'm going to show you is package.json this one here describes all dependencies of this project which are all the node models that are installed by now and like i said these include things like react being used for all the components interactive and dynamic components use it across the portal bootstrap for layout and a bunch of things for being able to do routes in the client side the react scripts uh which are the ones that we can use to start the portal and a few other things and uh and yeah many other dependencies now let me close this and then uh take a look at the public folder here this one is the one that defines index.html which is what we call the the page template so in a single page application like i think i mentioned before there's not really a navigation into different pages of a portal there's no reload of pages there's just one page in this case in the html where every all of these dynamic components are loaded and refreshed constantly and in fact uh in this section here in this div root here is where all the javascript files uh javascript content is injected with all the react components now this file also references config.js which happens to be over here and this is a file where if you're asking where is the addresses of all the microservices this is the file so this is where you're going to see the address of the catalog service and the others of the inventory microservice right there as well as the address of the having queue portal and a few other derived address addresses for the items apis in catalog and inventory now the most important directory actually here is the search directory because this is the one that contains all the react components so this is pretty much is the heart of the of the project this is where the system logic happens and in this file if you go to in the gs this is where this is the the route where we start rendering a react components and we are asking it to start rendering them in the a root div that we just saw in in the in the html this one here we saw that there's a root div and that root div is where index.js will get rendered as you can see right here and so the first react component that we actually start rendering is this app component over here which is coming from app.js this app component defines our app by using uh first the layout component which is in charge of rendering the basic layout of the system as you can see over here if you expand components layout js this is one that defines the navigation menu at the top the container for all the other components in the middle and then the footer at the bottom back to app.js as you can see we have layout and layout defines that inside of layout we're going to have a component for the home a component for the catalog and a component for inventory so then if it goes just go into the components directory we have our catalog file and this is the one where you can start really seeing interesting things because this file allows you to communicate to the catalog microservice if you go down into the populate items method over here you can see that here is where we are actually talking to the academic service and then we're getting a response from it and that's that's the one that we are uh collecting and setting it into the clientside state that later on if you see at the bottom it's been rendered as a list as a table in the into the page okay and it's the same idea with the inventory.js which is able to render the items inventory back of a user we also have a few form well model files and form files like guiding model which is the one that is used to render the model a model dialog so you can go ahead and either create or update an item in the item form which is the one that actually shows the form inside that model and the same way we have a model for granting items for a for a user so that it can go into his inventory back so a model and a form for that same purpose and lastly we have the that vs code folder which you should be very familiar but with at this point where we also have a launch.json file where we define a defining configurations that you can use to start debugging either the server side or the client side of this portal so you can see we have a configuration for the server we have named it server this is going to be the one that can launch the npm server or the nodejs server and one configuration for launching the client at the location of the client in the browser there's also a compound configuration which i named server and client server client that can can be used to launch both the server and the client at the same time in your local box okay so i'll just close this so now let's go ahead and try that catalog section so i'm going to open the terminal once again here so our front end is still running but what we may not be running right now is a catalog service so let me go back to catalog here's my a catalog code base so i'll just switch to src play that catalog service and then i'll do dotnet run so catalog is now up and running so let's go back to the portal the browser and in order to see the list of catering items what you can do is either click in catalog in the navigation bar over there or you can click in this catalog link right here and i'll click on it and uh this should display the list of categorical guidance but as you can see that is not working right now so we cannot load the items so there is some problem happening here and so the client side one way that you can tell what's going on is by using the the browser developer tools which usually you can you can go to by pressing the f12 key which i'm going to do now f12 and this opens the developer tools section now on this one there's a bunch of tabs but the one that you're interested in is in the console tab so click on console and this is going to show you what's going on so as you can see there's an error access to fetch at https alcohol 5001 items which is the address of the cataloging service from the origin http localhost 2000 which is the address of this of the front end has been blocked by course the course policy so no access control origin heater is present in the resident resource so what is this course thing about that is going to be actually the focus of the next the next lesson so in the next lesson we will learn about crossorigin resource sharing also known as course and how it can help us enable the communication between the front end and our microservices in this lesson you will learn about crossorigin resource sharing also known as course what problem it solves and how it can help us enable the communication between our frontend portal and our mac services to understand course let's first understand what a close origin request is let's put our catalog microservice to the site for a moment and let's imagine that the node.js web server that is hosting our frontend is also the server that hosts the res apis to interact with the database that owns the catalog data in this scenario the browser initially navigates to the web server url to load the front end home page and then when the catalog section is requested the browser makes a get request to the catalog rest api to the same web server url to which the server will reply with the json representation of the catalog data the address from which the browser calls res api is known as the origin and is made of the combination of protocol host and port which in this case is http localhost it doesn't notice how the origin in the browser matches exactly the origin of the server that provides rest api let's now go back to our actual scenario where our catalog microservice hosted in asp.net course kestrel web server is the one providing the res api now when the catalog section is requested in the browser the browser makes a get request to the rest api at the origin of the catalog microservice which is https localhost 5001. since both the protocol and port of the catalog service are different than the one in the browser this is known as a crossorigin request the microservice will return the catalog data just as before but by now the browser knows that this response comes from a different origin since it had set the origin header in the request therefore it rejects a response data with a course error this happens because browsers follow what is known as the same origin policy which states that a web application can only request resources from the same origin the application was loaded from browsers and forces to prevent malicious websites from reading confidential information from other websites unfortunately this is also preventing our front end from reaching the catalog microservice so how can we fix this here's where course comes into place course allows a server to indicate any other origins than its own from which a browser should permit loading of resources here's how it works once again the browser has loaded the frontend page now the catalog section is requested and a get request is sent to the catalog microservice and since catalog is hosted in a different origin the browser appends the origin header the difference this time is that the catalog microservice has been configured with the access control allow origin heater which indicates all the other origins that are allowed to call the res api in this case this header has been configured with the origin where the front end is hosted http localhost 3000. once catalog sends the item's data back to the browser it appends this header to the response the browser now compares the value in the orient header it sent to the value in the received access control allow origin heater since they match the browser now allows the response data to reach the front end this works for simple requests like gets but for post put and other methods things work a bit differently when a cross origin request may perform some sort of write operation on the resources owned by the server like is the case when performing a post put or delete request the request needs to be first preflighted this means that an additional initial request needs to be sent to the server to determine if the actual request is safe to send going back to our scenario imagine we now want to create a new item in the catalog and therefore our front end will send a post request to the res api however since this is a post of json data across origins the browser automatically sends first a request with the options method this time not just adding the origin header but also two other headers called access control request headers and access control request method access control request method indicates that when the actual request is sent it will be a post and access control request headers tells the server that the request will come with a content type heater in this case the server should have been configured to respond with corresponding headers to indicate what it allows the headers returned by the server are access control allow origin access control allow heaters and access control allow methods if the values returned in these heaters match the values in the heaters sent in the request the browser accepts the post request and submits this original request to the server with the json payload of the new item to create the catalog microservice creates the item and returns expected 201 status code as you can see the key to a successful crossorigin request is in the appropriate course configuration on the microservice that exposes the rest api since only the microservice can declare the allowed origins but how do we properly configure cores in atheism net core that's the focus of the next lesson where we will add the missing course configuration to both the catalog and inventory microservices let's now fix the course related errors we are getting in the browser by configuring the course middleware in the request pipeline of our microservices and let's start with the catalogue service so i have the catalog codebase open here in visual studio code and what i'm going to do is open app settings the development.json first here i'm going to declare the ordering of the frontend so that we can properly configure it in startup later i'm using app settings the development.json and not absence.json because the origin of the front end is just a development server at this point and we will not need a course policy for that origin in production so what i'll do is i'll just open another section here this is just going to say allowed origin and that's going to be the address of our front end so this http localhost 3000. now that we have that let's go into our startup file and here's where i'm going to collapse the explorer for a moment let's scroll down a bit and what i'm going to do is define first a constant to represent the name of that setting that we just created so this is going to be private constraint load origin setting is going to be the name that we just created over here i'm going to copy it aloud origin right there and now that we have that we can actually configure course so to configure course what you want to do is go down into the configure method which is where you configure the request processing pipeline and so like i said this is mostly for development scenario at this point because the front end is a development web server so what i'm going to do is take advantage of this m.easy development section which only happens with the 40 minute scenarios and i'm going to add another piece over here so i'm going to say app.use course and here we're going to provide the function that configures the course configuration so i'll do builder and i'll do this and then we're going to say builder dot with origins and here we're going to specify that that origin which at this point comes from the configuration data so it's going to be configuration and here we're going to pick the right key from the configuration which in this case is allowed origin setting so remember this that this configuration is the configuration object that has been declared here right here the configuration object which is populated automatically by the sp net core runtime so that configuration object contains all the data at this point of app settings that json and upsetting the development json included allowed origin setting so you can use this to just go ahead and get the key that corresponds to the allowed origin setting that we just declared so configuration and then allow origin settings that allows the origin but we also have to tell it which headers and which methods are allowed from the client side so to do that what i'm going to do is just say dot allow any heater to allow any of the heaters that the client wants to send and we will say allow any method to allow any of the methods used from the client side including get post put and all these other verbs okay so with that we have allowed the front end origin and we have set any here and any method should be allowed okay so with that we should be able to properly invoke the methods in the microservice from the client side so let me open up my terminal once again and i'll do netrun and then i'll go back to the browser where as you remember last time we did have this course error so now i'll just refresh the page and as you can see things are loading properly and in fact if we inspect briefly the network section here and we inspect the items request that we made right here you can see that the browser did send the origin heater in the request for localhost 3000 and the catalog microservice responded with the access control allow origin heater over there which is why the browser allowed the response so that's how you configure cores and since we did this for the catalog mic service we should do the same thing for the inventory mic service so let me go back now to our inventory code base which is open here in this other business to the code instance and i'm going to do just pretty much the same thing that we just did so here in fact i'm going to copy a few sections here so from catalog i'm going to close the terminal for a moment i'm just going to copy this allow origin section into inventory cloud origin then back to catalog i'm going to copy the allowed origin setting from startup back into inventory in startup at the top i'm going to place that constant and then finally back to catalog into the configure section i'm going to copy the use course section here and back into inventory i'll collapse this for a moment in configure i'm going to add this right there okay so this enables the same a configuration for inventory as the one that we have in catalog so both microservices are properly configured now so in the next lesson we will explore in more detail all the scenarios enabled in the front end and how its react components are interacting with the microservices let's now explore in more detail all these scenarios enabled in the front end and how its different react components are interacting with the catalog and inventory mega services so i have stopped all the web servers at this point both for microservices and for the front end they're all stopped because i want to restart them in debug mode that way we can jump from client to server and see line by nine what's going on so here i am in the catalog of my service code base and i'm just going to go ahead and hit f5 to start the web server and then i'll go to the inventory maker service called this code instance and i'll do the same thing f5 okay and now i'll go to our front end and in this case instead of typing npm start from the terminal i'll take advantage of the debug configuration that we have set here so i'll go to the run on the box section on the activity pane there and as you can see we have a few options here we can debug either server client or server client server client is the one that i'm actually going to pick so that both the client and the server are started at the same time so i'll click there and this is going to bring up the browser right away however it may take a while to load while the server is compiling the source code and starting the node.js server if we head back here you can see that the server is getting started but it may take a while to start okay so as you can see the server has compiled the source code properly and it has started a debugging session of them on the front end in localhost 3000 so now we can go back to the browser and here we can go ahead and navigate into the catalog section so i just click there and then things are loading properly but how is this communication from the client happening to the server side so to understand that what we can do is just head back to play the front end and what i'll do is i'll open my explorer on the left side and i'll collapse the terminal for a moment and then i'll go into src components catalog.js let's collapse that so here the communication happens in this populate items method over there first we call the fetch function where we talk to the url of the catalog items api so that total the catalog microservice and then we get a response back from it the response will tell us the status code if you wanted to inspect that but this is actually a promise in the in the javascript land is called the promise which means that we will have to invoke the json method to actually get the items in this other 10 that we can then take and then uh put into what we call the state the state of the of this page and then that state is going to later be used into the in the render items table uh the items are going to be taken from the state into this method are received as items and then we will just render them in a normal html table so let me put a few breakpoints back into populate items so that we can see things as they go so i'll place this breakpoints over there and let's also go to the catalog microservice so that we can put a breakpoint on the server side so i'll collapse this and i'll go to items controller collapse that and then here we can go into the get async method put a breakpoint there so now let's go back to the browser and let's just refresh this page and sure enough here back into the front end we have hit the breakpoint and as you can see here's where we have the location of the catalog microservice in the items api so if i say continue that's going to talk immediately to the catalog microservice as you can see now we are in the catalog service let me collapse this a bit and here's where we're going to go ahead and talk to our mango to our repository and to talk to the mongodb database and then return the items so i'll just say continue and now we are go we are back into the front end where we have received that response which we can briefly inspect on the left side let me collapse this and that and that and as you can see we got a 200 status code which is great and then we need to convert that promise into the actual set of items so for that i'll just hit continue and now we have our list of items over here in these returned items a variable where you can see we have collected the items from the server side with the date the description the id and the name as an array and then if we just hit continue then we go back to the browser we can see that the items are right there now how about creating a brand new item so let's go ahead and click the add button here and this is the form where you can go ahead and actually create an item so again how is this form working so going back to play the front end go to the code base you're going to find the code for that in the in on the form in item form here if we go back up there's a method called create item so this is the one that's going to be in charge of sending the post request to the catalog mic service to create the item now we can do the same exercise by just placing a breakpoint over here and then we're going to get a response over there same way we can go back to the catalogue service and we can place a breakpoint into the post async method over here now back to the browser let's go ahead and create an item so let's say we're going to create in this case a shield and let's call it actually round shield and this is going to be a basic shield now what happens if i just don't put a price here so i'll go ahead and hit save and you can see that this is going to happen so we have enabled clientside validation via react into the client side so here it is making sure that i have a name and that i have a price if i don't have a price then this happens so sure enough i can put a price and that should work but before we do that what happens if i do something a bit different like putting an invalid price like a negative five if you remember the catalog service has been configured with validations and it should not allow a negative price here we have i have intentionally not enabled clientside validation for a negative number here so that it just let it go but how would that look like in the uh over here when the validation actually comes from the server side to figure that out i'll actually go back to front end and put yet another breakpoint into the catch section over here so now let's go back to the browser and try to save that now we are back into front end so as you can see we will send the request to the catalog items microservice i'll hit continue and as you can see we already got a response here we didn't even need we didn't even get to reach the controller on the microservice because the asp.net core validation runtime verified that this is not an allowed thing like the dto that we sent did not pass the validations so as you can see the response here is already telling us that this is a 400 bad request because we have sent and uh an invalid value and in fact we want to know more about what happened here what we can do is just let me put another breakpoint over here and i'll hit continue and now we can inspect this error data section here and it says here yeah one or more validation errors occur which by the way is exact same validation that we were seeing before imposement for this kind of invalid inputs and if we expand the error section here you can see that we have all the errors that are coming back from the microservices like the field price must be between zero and a thousand so this is one way that if you wanted to you can show that error with that that specific error into the client in our case we are only showing the error data that title uh property that's as much information we want to show to the client at this point so i'll just say continue then we reach the catch section which will catch all the errors here from validations or for any other kind of communication errors from the client and the server and that's going to show an alert we say continue and then back to the client this is what we're going to see good note at the iron one more validation error secured so to fix this let's actually put a correct price let's say six then i'll hit save so back to front end we'll send the fetch request and now we hit the catalog microservice because the validation succeeded so the controller is actually being hit now so this will go ahead and as you know it will execute the logic to create the item and then publish that item into the message broker and write in writing queue so that the other microservices can get notice of this so i'll hit continue then we're back into the front end and this time if we expand the response we can see that we got expected 201 and then we hit continue and back into the browser the item has been created browse shield basic shield with price six okay so what about editing an existing item so to edit an item all you have to do is click on the read button here and this will allow you to perform the edit but before actually going through the editing scenario let me actually just go ahead and remove all these breakpoints since i think we get the idea now of how communication is flowing across places so let me go to the breakpoints and just remove all of them over here and also in the catalog microservice so i'm going to go ahead and remove all breakpoints okay so now back to the front end the edit edit logic is happening if we go back into uh yeah in item form so that is happening in the update update adding method so here's where again we call the fetch method with the uh the url of the rest api plus the id of the current item so double go ahead do the fetch operation and then later we'll get a response over here so let's see how that that works in real life over here i'm going to just bump the price from 6 to and then i'll just hit save and the edit has been performed notice how things never reload here like the page is never really reloading it's just a react component that's fetching the updated data and putting it dynamically into the same page that we're always working on then we can also try the delete scenario and that happens if we go back into front end that is happening directly into the catalog catalog.js file there is a section called delete item that's invoked by that red delete button see there's going to be a confirmation then it invokes the catalog api with the id of the of the item and then it performs the delete and also it removes it from the client state so to see that in action let's go back to the client and then i'll actually like to keep this bronze shield and the other items so what i'll do is i'll create quickly another one let's just call it delete me deleting description and then i'll say price for right so i'll save this item items created and for the delete operation all you have to do is click on delete there's going to be a delete confirmation box here click ok and the item is gone and you can always confirm that these are actually happening in the server side by refreshing the browser and you can see that the items are actually gone and of course you can also take a look at the database now how about granting an item to a user which a touches basis with the inventory side so to do that what you can do is use this grant booth over here so let's say i'm going to grant this bronze shield to a user so i'll click on grant and this pops up this model dialog to grant an item now in this in this dialogue what i have done is i have made it so that anytime you open it it's going to populate some random code for some random user id remember we don't have the console of the users really here so it's just a random user id so just like we did a random user in postman now there's this page is uh presenting a random user id run good here and also there's a quantity that you can increase or decrease as as needed now this here is is happening back in in the front end is happening in the grant item form js file over here here is where uh we can actually do a breakpoint for this one uh this is where we will invoke the inventory items api uh with the data that we have about this item and then the uh inventory service is going to take care of granting the item to the user so if you go back to them to the browser and we say let's say we're going to grant two of the potion actually two of the grand brown to the brown shield to the user i'll say grant and then if you go back here in grant item form we can see that the inventory items a url is going to be invoked this time is 5005 slash items and that is going to use the user id that we specified in the client side the catalog item id which is right here and the quantity which is two and just to lose it i'm going to actually going to grab this user id i'm going to copy this one so that we can query for it later and then uh yeah i'll hit continue and that would have granted the item to the user now there's no visual representation of that completion uh in in this page but that's why we have this other page for inventory so let's go to the inventory section over here and here is where you can paste that user id and you can get inventory for the user now all the logic here is happening if you go back to to the front end this is happening actually in dumb inventory.js page so this is the page that is going to allow us to populate items based on this in on the enter user id that's going to go ahead and talk to inventory api with that user id and that brings back all the items that are in the user's inventory pack which is rendered over here in this section render items table to go back to the browser we'll just hit get inventory and there you go the current inventory for the user is presented in this case just bronze shield now once again it's also interesting to see what happens if there's an update if an update happens to this item right would the the ui be able to to reflect the fact that inventory needs to have updated data from the catalog uh when it happens would that take too much time how about that render so let's see so we have bronze shield it's name bronze shield basic shield quantity two so let's go back to the catalog and we're going to edit the bronze shield uh and we're going to change the name so instead of having it as bronze shield we'll just call it a basic shield right and perhaps we'll also update the price let's say it's nine and so so now the bronze shield is named basic shield so hit save and i'll go back to inventory and i'll query again for the items of this user that we just use a granted inventory to so hit get inventory and as you can see the name has changed to basic shield that means that as soon as we perform the update in the catalog microservice that was immediately replicated via a synchronous message into the inventory service and eventually is now able to present the updated name of the shield in this case basic shield and that happened really fast so there you go we have gone through all the sections in this basic frontend user interface so that marks the end of this model and you have connected a modern single page application built with react and hosted in node.js with your two.net based mic services to light up a basic endtoend scenario and you learned all about cores along the way i hope you enjoyed building this system with me so far congratulations you made it till the end i really hope the course met your expectations and gave you a good sense of how to get started building microservices with a.net platform please consider hitting the like button if you got value out of this and don't forget to subscribe if you'd like to know right away when i publish new videos now microservices development is a huge topic and this course only covers the tip of the iceberg if you want to become a microservices developer and you are considering this architecture style for a real world project you will need to master many other techniques and patterns essential for distributed systems development also as you move your system to a cloudbased environment you will need to add many other pieces to your tech stack to ensure the microservices can be built and deployed quickly to scale the system to meet the production demands and to have the tools to monitor and diagnose the services when things don't go as expected to cover all these topics i created the buildingmicroserviceswith.net complete learning pad which expands what you saw in these basic skirts with dozens of additional lessons that will teach you step by step how to add all the building blocks needed for the complete microservicesbased application and how to take everything to a production environment in the cloud if you are interested please check out the links below to get all the details on this premium offering thanks for watching and i'll see you next time
