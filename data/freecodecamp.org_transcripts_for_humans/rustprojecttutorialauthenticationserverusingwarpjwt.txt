With timestamps:

00:00 - rust is an increasingly popular
00:02 - programming language in this course you
00:04 - will improve your rust skills by
00:06 - learning how to build an authentication
00:08 - server in Rust Akil Sharma developed
00:11 - this course he is an experienced rust
00:12 - developer and is a great teacher for
00:14 - beginners so let's get started in
00:17 - today's video we're building uh a
00:20 - authentication server so we'll be using
00:23 - JWT but for the apis we'll be using a
00:26 - framework called warp it's a web
00:28 - framework in Rust
00:30 - the benefit of warp is that it's a small
00:32 - lightweight framework so it helps you to
00:35 - get quickly started by building apis
00:39 - and and there are a lot of use cases so
00:41 - in the sense
00:42 - there might be many projects where you
00:43 - don't want to build a full-blown server
00:47 - like you don't want to use actex or you
00:49 - don't want to use rocket because of the
00:50 - much bigger Frameworks and with a lot of
00:52 - features they're also heavier slower
00:54 - slower to build with a lot of Concepts
00:56 - right so in those cases you might want
00:58 - to have something like warp which is
00:59 - very easy to learn very lightweight very
01:03 - easy to very fast to get started with
01:05 - fast to build with and fast to run at
01:07 - runtime it's also very fast so warp has
01:10 - a lot of benefits uh and a lot of use
01:12 - cases
01:14 - uh so uh by the way we've already built
01:17 - a project with actex right and was it
01:20 - wasn't a full-blown project like a very
01:22 - small simple project I just showed you
01:23 - how to use actex right uh so you might
01:26 - want to check that out I think that will
01:28 - be much before in the in the in this
01:30 - playlist series because in this video
01:33 - Even though this framework is much
01:35 - lighter we're actually building a much
01:37 - bigger project than the one that we
01:39 - built with tactics right but the
01:40 - projects are comparable in in the sense
01:42 - that
01:44 - even with this project if you're
01:46 - building we're not going to be using a
01:47 - database we're actually just using a
01:49 - hash map and that hash map we would
01:51 - already
01:52 - pre-create the users and then when we
01:54 - log in we'll just be comparing with the
01:57 - users that are already created in the
01:58 - hash map okay so we don't have a
02:00 - database just a hash map with
02:02 - pre-created users login and we'll do all
02:05 - of the things with JWT like creating
02:07 - tokens authentication there's also one
02:09 - more thing here which is role based
02:11 - authorization so we'll have different
02:13 - routes for users and admin and we'll be
02:15 - checking
02:17 - if the user is a regular user or he's an
02:20 - admin and depending on that we'll be
02:21 - giving him access to the apis okay
02:24 - so that also is there so that means it's
02:27 - uh it's it's almost uh like a proper
02:30 - project for for JWT right you'll have
02:33 - regular authentication and role-based
02:35 - authorization that means you could use
02:37 - this code
02:38 - in multiple places
02:41 - all right so what we'll do now is
02:44 - um I have
02:45 - two terminals let me just show you my
02:48 - uh screen I have two terminals open here
02:51 - for you guys one is the uh place where
02:56 - I've already built the project now I
02:58 - just want to tell you that this project
02:59 - is already built it's on my GitHub right
03:01 - so I'll put the link of the project on
03:04 - GitHub on on this YouTube video but in
03:06 - case I forget to do that you just need
03:08 - to know that I'm akhil Sharma 90 on
03:09 - GitHub and all the projects almost all
03:12 - of the projects that I've built are
03:13 - already there and this one is definitely
03:16 - there because I just built it just
03:17 - uploaded it all right so
03:20 - here uh the project yeah the name of
03:23 - that project would be something like
03:24 - rust warp zero three example something
03:25 - like that anyway so now what we'll do is
03:28 - I'll just run it I'll just say cargo run
03:30 - okay
03:33 - and it's running it's running on Port
03:34 - 8000 and I will now interact with this
03:37 - project so uh the first thing that I'll
03:41 - do is I will hit the login route okay on
03:44 - a different terminal as you can see I'm
03:46 - running I'm hitting the uh the login
03:48 - route
03:49 - all right and I'm inputting the email
03:52 - which is user at userland.com and
03:54 - password1234 because this user is
03:56 - already created in my hash map which is
03:58 - there in the session memory of the
04:00 - project which is running at the moment
04:01 - right there's no database like I said
04:03 - just a hash map
04:04 - when I log in I get the token so this is
04:06 - what the JWT is doing here it's creating
04:08 - a token for us now what I'll do is I'll
04:10 - go ahead and I'll save this token
04:14 - somewhere okay so I recommend if in case
04:17 - you also have this project in your
04:20 - running it long
04:22 - you might want to save this as well but
04:25 - anyways this is just a demo so in case
04:27 - you haven't forged my project from
04:28 - GitHub and are not running it on your
04:30 - system it's completely all right I'm
04:31 - just giving you a demo right I have
04:33 - copied it somewhere the the token and
04:36 - now I'm going to try to hit the user
04:38 - route okay so I'll just press enter
04:39 - enter a couple of times
04:41 - hit the user route and it says as you
04:43 - see Hello user one that means
04:46 - um
04:48 - that means
04:50 - the um jwd is able to determine that
04:54 - this user already exists and it's able
04:57 - to check the token it's also unable to
05:01 - get the information like the user type
05:03 - from the token so this means it allows
05:06 - me to hit and it also sends back a
05:09 - responsing hello user one
05:10 - okay
05:11 - uh now what I'll do is I will
05:17 - um I will try to hit the admin route
05:22 - with this token
05:25 - okay so let me bring out my command for
05:28 - the same
05:30 - sorry
05:32 - uh
05:34 - yeah
05:36 - okay so this is my command my call
05:38 - command where I'm trying to hit the
05:40 - admin route with the same token the
05:42 - token that's meant for the user and
05:44 - ideally it should not let me in because
05:46 - this is the admin route meant for the
05:48 - admin user not for the regular user so
05:50 - it'll say okay not valid status 401
05:52 - unauthorized all right so we have
05:54 - elaborate error handling in our project
05:57 - and that's also what we'll be building
05:58 - today
06:01 - okay and the next thing you want to uh
06:05 - do is
06:07 - hit the
06:09 - login route but with the admin
06:11 - credentials so what I'll do is I will
06:14 - hit the admin route
06:17 - just a second
06:18 - yeah hit the admin route so you can see
06:22 - here sorry the login route but with the
06:25 - admin credentials so I have the admin
06:28 - created here with different password
06:30 - like I said these users are already
06:31 - created uh whenever we start the project
06:33 - these users get created in the beginning
06:35 - and I'll show you how to do that we will
06:37 - initialize these users right so we're
06:39 - just comparing that this user which
06:41 - already exists in session memory right
06:42 - now is it the same as this user that I'm
06:45 - sending in as request
06:47 - and yes it is so it's giving me a token
06:50 - now so what I'll do is I'll just copy
06:52 - and and paste this token
06:56 - in a safe place
07:01 - and what I'll do is I'll try to hit now
07:04 - the admin route so we saw earlier that
07:07 - we were not able to hit the admin route
07:09 - right because it is saying it's
07:10 - unauthorized but now if we try to hit
07:12 - the admin route it says hello admin 2
07:14 - which is with new token you're able to
07:16 - hit the admin drop all right that's
07:19 - awesome
07:19 - so what I'll do now is I will again
07:23 - um try to hit the user route
07:27 - and let's see what happens so try to hit
07:29 - the user route with this admin token and
07:31 - let's see what happens okay
07:33 - so I will come here I'll try to hit the
07:36 - user out but with the admin token
07:39 - so it remembers it says hello user two
07:41 - so that means the admin is able to hit
07:44 - not only the admin route but also the
07:46 - user out but the user is only able to
07:48 - hit the user out not the admin route I
07:50 - think okay I hope that makes sense it's
07:52 - quite elaborate like the rules that
07:54 - we've put in quite elaborate and that's
07:57 - it's like a full-blown working project
07:58 - you can just pick up the code use it on
08:00 - your project right if you have let's say
08:02 - a submission in your college or you're
08:04 - building something and you're at your
08:06 - office in your job you're building
08:07 - something very quick
08:09 - the best way to build it all right but
08:12 - jwd it has what but it has these apis it
08:14 - has error handling it has rules and
08:17 - authorization authentication everything
08:19 - is there
08:20 - anyhow so now let's get started so I'll
08:22 - just clear this all up I will stop this
08:25 - over from running and I will create a
08:29 - new project so I'll say cargo
08:32 - new
08:33 - and I'll give a name like uh rust
08:36 - what
08:38 - I'll say JWT and and waiting for YouTube
08:41 - so I'll
08:42 - CD into it rust warp JWT and YT
08:48 - all right and you can see here cargo
08:50 - tumble SRC
08:53 - now I have not created videos in uh uh
08:56 - in quite some time now and the reason
08:58 - for that is that as many of you might
09:01 - know that my startup armor dot AI was
09:04 - selected by techstars which was the next
09:07 - which is a great accelerator and then
09:09 - recently got selected by outlier
09:11 - Ventures which is again an accelerator
09:13 - Tech accelerator and in the middle we
09:16 - also got grants from companies or
09:19 - blockchains like Aptos so it's been
09:21 - extremely busy very very hectic and
09:24 - basically essentially what armor AI is
09:26 - it's it's a it's a platform where you
09:28 - can build security tools so it could be
09:31 - for web 2 for web 3 doesn't matter uh
09:33 - the platform enables you to build
09:35 - security tools really easily that's what
09:37 - we're building at at armored uh anyhow
09:40 - just wanted to update you on and why
09:41 - I've not been making a lot of videos but
09:43 - then uh now it's getting things are
09:45 - getting a little bit lighter I'll have a
09:46 - little bit more time hopefully and
09:48 - whenever I have time in between the day
09:50 - I'll just create a quick video like this
09:51 - right so that
09:53 - uh unable to also keep in touch with the
09:56 - Technologies
09:58 - anyway so I have it here I am going to
10:01 - open it up in my guess code okay
10:08 - so there are two terminals right the
10:10 - other one
10:12 - I can actually I can just get rid of
10:14 - that
10:18 - okay
10:20 - so here
10:22 - in my SRC I have a main.rs which is
10:25 - awesome
10:26 - but I need two more files I need my
10:30 - uh all the logic for my authentication
10:33 - and all the logic for my headers I need
10:38 - that as well
10:40 - okay
10:42 - so
10:43 - now another thing is it's it's uh
10:45 - there's quite a lot happening in this
10:46 - project so I'm just wondering where to
10:48 - get started with I think I'll just
10:50 - remove I'll just remove I guess get get
10:52 - rid of all of this and I'll start by
10:56 - just creating a user struct okay let's
10:59 - just do that so let's just create a user
11:02 - start okay
11:06 - uh and by the way I I'm not sure if you
11:09 - can see my screens they're up in the sky
11:11 - like up in the air now earlier they used
11:13 - to be on the on on the table now I've
11:15 - put them up in the air so I will be just
11:17 - looking here and there will have like
11:18 - four screens here
11:21 - um four different screens so
11:24 - yeah I just want to tell you that so
11:27 - like there's nobody else in the room I'm
11:28 - not looking at the person when I'm
11:29 - looking here at me I'm just looking at
11:30 - the screens
11:32 - all right
11:33 - so
11:35 - um like this having the same code window
11:37 - on two different places like instead of
11:39 - having like a split view just where to
11:41 - have it on different screens that's what
11:43 - I uh was doing right so uh in the main
11:47 - dot RS you have your user uh struct and
11:52 - I'm going to have a
11:55 - uid which is string
12:00 - and email
12:06 - which is again
12:07 - string
12:09 - okay and then password
12:12 - which is again string now I hope you all
12:15 - know what structs are you shouldn't be
12:18 - doing this video if you don't know the
12:19 - basics of Rush by the way because I I
12:21 - get a lot of comments on on YouTube
12:22 - saying that hey I didn't understand uh
12:25 - anything that you're teaching it's
12:25 - obviously because I'm expecting that you
12:27 - know rust uh before if you want to build
12:30 - a like full-on project with Frameworks
12:32 - and last right and a lot of people don't
12:34 - understand that and they just come and
12:35 - write on my videos I'm not understanding
12:37 - anything you're saying and you're just
12:38 - talking you're not explaining it's
12:40 - because it's because I'm not supposed to
12:43 - be explaining what is a struct in a
12:44 - video that's meant for uh building
12:46 - projects for the web framework right so
12:48 - I need to give me that much off
12:51 - like you have to have that kind of
12:52 - understanding at least so anyways even
12:54 - if you don't know what struct is it's
12:56 - basically uh enables you to create your
12:58 - own custom data types so user is a data
13:01 - type here which has a uid which is
13:03 - string email string password and role
13:06 - okay
13:07 - because role could be user or admin as
13:09 - we just saw in the demo
13:12 - and
13:13 - in then I have another struct
13:17 - for the login
13:20 - request okay so I'll have two things
13:22 - which is the request and the response
13:24 - for login
13:26 - and sorry I'm not able to look at my
13:28 - keyboard because of this mic let me just
13:30 - put it here
13:31 - all right so for the login request I
13:34 - have uh the email
13:38 - so I'll send the email
13:41 - and I will send the
13:44 - password email and password so it's a
13:46 - very straightforward simple
13:47 - straightforward
13:49 - login
13:51 - okay and then I have something called as
13:55 - the login response like I said you know
13:57 - when you
13:59 - um
14:00 - when you make a request for logging in
14:02 - that that is what this will look like
14:04 - the login request will always look like
14:06 - this it will have always an email and a
14:07 - password the login response will always
14:10 - look like this will have a token right
14:12 - so this is my way of defining the write
14:15 - request and response instructs right so
14:19 - that it doesn't deviate the project was
14:21 - interviewed from this
14:23 - all right so
14:24 - now because uh I'm sending the request
14:28 - as Json as you just saw in the terminal
14:30 - I was using
14:31 - um
14:32 - the terminal and I was sending Json
14:34 - requests right and I was receiving a
14:36 - Json response so I need to Desert
14:39 - serialize and serialize right because
14:40 - just
14:42 - it's not able to understand Json one and
14:44 - so on
14:45 - and a lot of people coming from
14:46 - JavaScript background they get very
14:48 - confused in this step they think oh but
14:50 - why is that you know why is Russ not
14:52 - able to understand that when JavaScript
14:54 - understands that by default because Json
14:56 - is Javascript transition and JavaScript
14:58 - already understands that by default but
15:01 - trust does not go Lang does not and
15:03 - that's why we need to do this okay
15:05 - so you're going to say DC realize here
15:10 - in case you're uh you don't you don't
15:12 - know how serialization dexterization
15:14 - works there's a very detailed video that
15:16 - I've created on uh in in this series
15:19 - itself this figures itself it's in the
15:22 - towards the beginning
15:24 - where I explain
15:26 - the Third Day package which is uh the
15:29 - third day it's great sorry which is what
15:31 - which enables us to do digitalization
15:33 - and serialization so what I'm going to
15:34 - do is I'm going to first get that
15:36 - because uh by default rust doesn't have
15:39 - it so we need to make use of the survey
15:42 - package Jesus rise and
15:44 - serialize okay
15:48 - and you have that now
15:50 - for the user
15:53 - uh we'll have to work with the user
15:55 - object multiple times right
15:58 - so when we receive the user object in
16:01 - the
16:02 - um
16:03 - you know so we will create the user
16:05 - object and it'll be stored in the
16:06 - session memory as a hash map we'll have
16:08 - to also compare with the user that we'll
16:10 - get uh you know the user data that we
16:12 - get in the request and then we'll have
16:14 - to search for the users so we'll do a
16:16 - lot of operations with users where we
16:18 - need to have multiple copies of the
16:20 - users so I'll just clone this so I'll
16:22 - just say
16:24 - I'll give it the ability to that that
16:25 - we're able to clone it uh very easily so
16:28 - I'll just say Drive clone
16:30 - and now what you want to do is we want
16:34 - to start working on the main function so
16:38 - I'll say
16:39 - sync
16:41 - FN Main
16:45 - okay
16:50 - and to be able to enable
16:53 - the async function we will be using
16:56 - Tokyo
16:58 - so in case you haven't worked with Tokyo
17:02 - there are multiple videos on the same
17:05 - playlist this rust playlist
17:07 - multiple videos about Tokyo make sure
17:09 - you check them out we've already built
17:11 - projects using Tokyo and the asynchron
17:14 - the async functionality brings us with
17:16 - it
17:17 - so here we'll say let users
17:22 - equal to
17:25 - Arc
17:27 - new
17:28 - in it
17:30 - underscore users now init users is going
17:33 - to be a function
17:35 - that will help us create default users
17:39 - so I'll repeat again and it uses the
17:41 - function that'll help us create default
17:43 - users
17:44 - as the program starts so before we make
17:46 - any requests two users will already
17:48 - exist in our hashmap to users one being
17:52 - the user regular user one being an admin
17:53 - user That's How we'll compare
17:55 - the user coming in the request with
17:57 - these users in the hashmap we'll search
17:59 - for these we'll compare them and that's
18:01 - how we'll create the token right that's
18:03 - the whole logic that's going to be there
18:05 - so Arc that we've just written here
18:07 - we'll have to add in the appropriate
18:14 - so it comes in from standard sync Arc
18:18 - Arc is something that you use usually
18:20 - with things that you will be using uh
18:24 - things that you'll be cloning a lot so
18:26 - it users is something like I mentioned
18:28 - we'll be cloning quite a bit
18:30 - oh by the way I'm not sure if I covered
18:32 - it with C at the end I made C Capital
18:36 - here in Clone uh you just need to see
18:38 - that this color changes right so maybe
18:41 - because I left for a quick break in in
18:43 - between uh just to get some water
18:46 - so maybe I didn't show you this which is
18:49 - C is supposed to be Capital make sure
18:51 - you do that in your code as well okay
18:52 - and we got this Arc now Arc unit users
18:57 - all right
18:59 - um
19:01 - so we have this now
19:03 - and now we quickly create our routes
19:05 - using warp now we also need warp here so
19:07 - I'll just quickly write use Warp
19:12 - and what comes with reject reply
19:15 - filter we'll need filter as well
19:18 - ejection and reply okay
19:22 - and we need warp now to be able to
19:24 - create these uh routes in the main
19:27 - function so we'll first say let login
19:30 - underscore dollars this is for the login
19:31 - route is equal to Warp
19:34 - but
19:38 - login
19:40 - okay
19:41 - so this is how the login starts
19:44 - and we'll say dot and
19:48 - warp post request so for that means for
19:52 - login that's the path right login. and
19:56 - it will be a a post method
20:00 - and we'll change some more things here
20:02 - so we'll say with
20:04 - underscore users
20:07 - and users dot clones as you know we're
20:09 - going to including users quite a bit
20:11 - that's why we have this here
20:13 - Dot and Warp
20:17 - body
20:19 - Json
20:22 - okay because the request will be in Json
20:26 - Dot and underscore then
20:29 - and login underscore
20:33 - handlers
20:36 - so essentially what's happening is if
20:38 - you hit the login route you need to have
20:40 - the login Handler that's the main thing
20:42 - right and everything else is just
20:44 - helping us with that so we have that
20:46 - it's going to be a post route it's going
20:47 - to have users so you'll clone the users
20:49 - and perform some operations in the user
20:51 - because as you you know with login
20:52 - you're going to be uh trying to find
20:55 - those users in the hashmap as we'll
20:56 - write more code it'll make more sense
20:58 - but just need to know that with login
21:00 - you need to have login Handler login
21:01 - Handler is a function we'll create in a
21:03 - while just ignore that right then we'll
21:07 - just create the user out and the admin
21:10 - route so user route
21:12 - is equal to
21:15 - again what
21:17 - paths
21:19 - and user
21:22 - okay
21:24 - Dot and
21:26 - with auth
21:29 - here you'll have role
21:32 - user
21:34 - okay so what we're saying is for the
21:36 - user out it's obviously when we whenever
21:39 - we had the user Outlet slash user that's
21:40 - when we're supposed to come into this
21:42 - chain and the role of that user should
21:45 - be users there are two rules one is the
21:47 - user role the other is the admin role
21:49 - talking about the user role here
21:51 - and
21:52 - then
21:54 - you have the user Handler okay talk
21:58 - about it just like we have the login
21:59 - Handler we have the user Handler here
22:02 - similarly we'll have the admin route and
22:04 - the admin Handler so admin route let's
22:06 - go to Warp
22:08 - path
22:10 - admin
22:11 - okay dot and with
22:16 - auth
22:18 - and you have the role
22:20 - which is
22:21 - admin
22:22 - okay
22:24 - Dot and underscore then
22:28 - admin underscore and
22:31 - essentially login routes with Slash
22:33 - login hits login Handler this is a post
22:36 - request user out with Slash user hits
22:39 - the user Handler admin route slash admin
22:42 - it's the admin Handler
22:44 - and generally let's just Define the
22:47 - routes so routes
22:50 - is going to be login route
22:56 - okay or
23:02 - user
23:05 - route
23:08 - or admin route
23:13 - might also recover so it the error if
23:16 - it's not any of these routes we'll have
23:18 - the recover error
23:20 - handle rejection handle ejection is
23:21 - something we'll work with
23:24 - uh mostly in our error.rs file
23:27 - but I'll mention it here error
23:30 - and handle rejection so what is this
23:31 - error so this error needs to be
23:34 - in in the top so we'll say
23:39 - use
23:41 - error everything from the
23:44 - error
23:47 - mod
23:48 - okay
23:50 - and I'll just get also everything from
23:52 - the auth
23:54 - so error and auth are these two files
23:57 - that we will be using as modules so I'll
23:59 - also get auth and here we'll have with
24:03 - hot and comma role right so
24:09 - we've done here uh
24:12 - reviews with users will not use yeah so
24:14 - we've used with auth also and the with
24:16 - auth you also pass role which is the
24:18 - user and that's the logic that we'll
24:20 - handle in our auth DOT orders file so
24:24 - that's why I've also gotten it from auth
24:27 - which is
24:28 - get with the auth and also the role okay
24:30 - because we're passing the role as well
24:32 - role user or role admin
24:36 - and here we can say mod hot
24:42 - and mod
24:44 - error
24:47 - all right
24:49 - now I need a couple of more things
24:52 - I need to be able to work with hash Maps
24:55 - like you know because we'll be creating
24:56 - multiple users as the program begins and
24:58 - that's the those are the users that
25:00 - we'll be comparing with when we have to
25:01 - do logins so we'll need hashmap and then
25:04 - I'll need another thing called
25:05 - infallible we've used it before it's
25:07 - when we don't want to return any error
25:09 - that's when we use infallible I'll use
25:11 - that also later on so I'll just include
25:12 - them for now so I'll say use standard
25:16 - just a second I'm not able to look at my
25:19 - keyboard because of this mic installing
25:22 - this new setup so you have used standard
25:24 - and you have collections
25:28 - cash
25:31 - okay
25:32 - and then you have use standard
25:37 - convert
25:39 - and parallel
25:45 - okay
25:51 - so
25:53 - we've reached here
25:55 - finally when you have defined all the
25:57 - routes you can simply start off
26:02 - the server so it'll say serve all the
26:04 - routes and run the server
26:10 - on 137 comma zero comma zero comma one
26:16 - comma eight thousand
26:18 - let's say dot await
26:22 - okay
26:24 - that's that
26:27 - now there's this function called with
26:30 - users
26:32 - so here you can go ahead and create that
26:35 - function so we say
26:37 - function with underscore users
26:42 - ticks and users
26:47 - which is a collection of users with a
26:50 - capital u so what does user of the
26:52 - capital user mean
26:53 - use of the capital u is actually the
26:55 - struct so multiple of those structs
26:57 - because we'll have multiple users like I
26:59 - said
26:59 - will be uh
27:03 - collection of these structs basically
27:05 - regulation of these trucks are assigned
27:07 - to users okay
27:11 - okay so implement
27:17 - filter
27:19 - essentially what you need to do is
27:21 - always we have that hash map of multiple
27:23 - users we have not created those yet but
27:25 - we'll create that in the init user
27:27 - function
27:29 - this function will create it very very
27:32 - soon but when you have that when you
27:34 - have that hash map of multiple users you
27:37 - need to be able to extract them right
27:38 - that's how you will you know
27:40 - go user by user extract user by user and
27:44 - then compare the details of that user
27:46 - with the ones that you'll receive in the
27:48 - request okay that's why we are
27:50 - extracting it so let's say is equal to
27:54 - users
27:55 - comma
27:58 - comma errors
28:01 - is equal to n value
28:06 - Plus
28:08 - clone
28:15 - save work
28:17 - any
28:18 - dot map
28:22 - mode
28:28 - enables me to extract users
28:32 - okay so there are three functions that I
28:35 - need to write here one is the login
28:36 - Handler the user Handler and the admin
28:38 - Handler so I'll at least create outlines
28:40 - of those functions so I'll say Pub
28:42 - async function login Handler okay the
28:46 - one that will be called when I have
28:49 - somebody hits the login path login
28:51 - Handler
28:54 - so it'll have users which is a
28:56 - collection of the users
29:00 - have body which is the login request
29:03 - okay so I'll explain this again users as
29:06 - a collection of the user with capital
29:09 - uses struct so multiple of users which
29:11 - are following this data type are the
29:13 - users that we'll have in users okay
29:16 - which is again here which had cloned
29:19 - and in login Handler you also have the
29:21 - body which is the login request so login
29:23 - request is something that you created
29:24 - here
29:25 - which will have an email and password so
29:28 - you'll have that also in the body which
29:30 - is the request body okay
29:33 - and we'll have to perform some
29:34 - operations with that so like like I told
29:36 - you the users
29:39 - we're going to get the users one by one
29:43 - and compare it with what you call in the
29:45 - body the details that's what we'll be
29:47 - doing here essentially
29:49 - and there will be something called as
29:50 - the web I'll just push it down
29:54 - something called as the web result so
29:57 - I'll say
29:59 - result
30:04 - reply
30:07 - match
30:09 - users users being
30:12 - multiple leaders right from
30:14 - the field assigned it to this variable
30:16 - users
30:18 - and you're going to
30:21 - how are you going to match you're going
30:22 - to match them by iterating over the
30:24 - users
30:26 - and you will find
30:28 - so like I I explained before that
30:31 - we have we'll have multiple users and
30:33 - we'll go over each of those users that
30:35 - the function will help us do
30:37 - by iterating user by user we'll go over
30:40 - them and then we'll compare them with
30:42 - the details that we get in the request
30:44 - That's How we'll come to know if this
30:45 - user matches this user which is there in
30:47 - the hashmap that's how you
30:49 - complete the login request
30:52 - so here will be find
30:57 - underscore uid comma user
31:03 - user dot email
31:07 - equal to body dot email
31:11 - user dot password equal to the body Dot
31:17 - password okay
31:20 - [Music]
31:25 - so
31:26 - uh
31:28 - for this web result right I will go up
31:33 - at
31:34 - results
31:35 - so I'll say type so it's a type that
31:39 - we've defined type red result
31:45 - standard
31:48 - result
31:50 - now we'll have to Define this result
31:52 - also T comma
31:55 - rejection
31:58 - now to Define this result also say type
32:02 - result
32:04 - t
32:05 - the standard
32:08 - salt
32:11 - result
32:12 - 2 comma error
32:18 - right
32:21 - and then you have type which is users
32:26 - our case it's Arc and it's a hash map
32:30 - of string comma each user
32:35 - right
32:36 - so this users that we were talking about
32:38 - all this while users like I said it's
32:40 - going to be collection of multiple user
32:43 - which is the struct and here we've just
32:45 - officially defined it as a hash map it's
32:47 - a art enables us to create
32:50 - uh you know with the help of cloning you
32:53 - have a hashmap which is string comma use
32:56 - it
33:00 - all right
33:05 - so here
33:07 - now that we'll find that particular user
33:10 - which is which matches the email
33:12 - uh the body email and user email and
33:15 - user password body parts which matches
33:16 - that you need to perform some operation
33:18 - on it okay so that means
33:22 - and we found it we'll perform some
33:24 - operation on it
33:29 - okay
33:32 - but before we do that I'll just create
33:35 - the init users function so that things
33:37 - are much more clear
33:41 - it's also sum even if I found it all
33:43 - right so first I'll just create the init
33:45 - user functions that things make a lot
33:47 - more sense so well because once I create
33:50 - this function everything will become so
33:51 - much clearer to you that all your doubts
33:54 - will go away
33:55 - so I'll create
33:57 - init underscore users function
34:01 - and this has a hash
34:06 - map
34:08 - string comma sorry
34:11 - string on our user
34:16 - and start with map
34:20 - s map
34:23 - new
34:26 - map dot insert
34:30 - this is the first user so we'll say
34:33 - if you remember here we just created so
34:35 - the reason I'm following this particular
34:37 - order is because I'm taking it through
34:38 - everything so users there's a string
34:40 - right
34:42 - the string is actually we use it for
34:44 - like one two you know the ID of the user
34:46 - and then we have the user
34:48 - and that's what we also had here the ID
34:50 - of the user and the user because we'll
34:52 - have multiple and we go through multiple
34:53 - users when we iterate through them so
34:55 - anyhow so the first thing is from I'll
34:57 - create one user number one
35:04 - comma
35:06 - and I'll say here
35:08 - user which is if you see capital u you
35:11 - mean you you know that I'm talking about
35:13 - the user the struct
35:15 - so here I have something called the uid
35:17 - which is string
35:19 - from one
35:23 - okay
35:25 - why because it starts with uid
35:29 - right
35:32 - and then I have something called as
35:35 - email which is
35:38 - again string from
35:42 - user at the rate user to land.com
35:50 - comma
35:52 - password
35:54 - restraint from one two three four these
35:57 - are all hard-coded values so I'm
35:59 - creating a hash map with these exact
36:01 - users and if you remember the demo that
36:03 - I showed you we were actually using this
36:04 - user details we were using this email
36:06 - exact email exact password to be able to
36:09 - authenticate that user
36:11 - that's what we're basically comparing
36:13 - role
36:16 - string and this particular user is
36:19 - has a role of users that's that's why
36:21 - when we logged in this user and we got
36:24 - the token we were not able to use that
36:26 - token to log in to the admin route the
36:30 - fit member
36:33 - comma
36:37 - so
36:39 - and now we'll say map
36:42 - dot insert for the next user so we want
36:45 - to create the next user now
36:47 - and we'll say
36:50 - string
36:52 - from 2
36:54 - ND user okay
36:57 - comma
36:58 - user
37:00 - and it will say uid
37:02 - string
37:04 - from
37:06 - two
37:08 - come on email
37:13 - again a string
37:16 - from
37:17 - admin
37:20 - rt.com
37:25 - password is string from
37:30 - four three two one
37:35 - and the role is
37:39 - string form
37:42 - add
37:44 - right so this
37:46 - user's role is admin this is Rolex user
37:49 - as we know admin is able to log in to
37:52 - both user and admin
37:53 - but the user is not able to log into
37:55 - admin just user
37:57 - comma here
38:01 - and then finally we'll just say
38:04 - map
38:08 - all right now we can come back here so
38:10 - now that I've created the
38:13 - um
38:15 - init users functions now now everything
38:17 - is very clear to you right that we have
38:19 - these two users
38:21 - and we're basically doing everything
38:22 - else that we've done here is to compare
38:25 - the data that we receive in the in the
38:26 - request
38:27 - with the users right so when you found
38:30 - so we are basically in the login Handler
38:32 - we are trying to get uh we're trying to
38:34 - find the user which actually matches
38:36 - this email and password because that's
38:37 - what we send in the request
38:39 - once we've done that we want to perform
38:41 - some operations so we are going to
38:42 - create a Program forum so we'll say that
38:45 - token
38:46 - is equal to auth
38:49 - create 0w right so in the auth module
38:53 - you say auth because we have the auth
38:55 - multiple here
38:56 - which
38:59 - is going to have function called create
39:01 - 0p we'll have a function in the auth.rs
39:03 - file called create JWT
39:06 - going to just send it the uid comma and
39:10 - the role
39:12 - from
39:13 - string
39:15 - user dot role we would extract the user
39:18 - data
39:21 - Dot map
39:23 - underscore error
39:32 - reject custom error
39:46 - so we'll say
39:48 - okay
39:51 - reply it's Json
39:55 - so I've I've for the time being I've
39:57 - disabled rust analyzer and we will
40:00 - activate it so all of everything will
40:02 - get
40:03 - um
40:04 - formatted correctly but I'm just
40:07 - I'll just disabled it so that I'm able
40:09 - to type with these
40:12 - so all of this happens when that
40:15 - particular user was found
40:16 - so we created a token but let's say if
40:18 - no user was found like that which you
40:21 - know matches the email ID from that user
40:24 - that we were going through one by one
40:27 - and it didn't meet the body email or the
40:30 - body password what do we do then so
40:32 - we'll say none and we'll just send an
40:34 - error with reject and we'll say
40:38 - custom
40:40 - wrong credentials
40:43 - error so when we say custom that means
40:46 - basically we've defined these errors
40:47 - somewhere on our own
40:50 - that's what we mean and all that is
40:52 - there in the error file we'll Define all
40:55 - the errors now
40:57 - before I jump there I'll just go through
40:59 - the entire code once again just to be
41:02 - sure everything is fine and then we'll
41:04 - just hear the two handlers the login and
41:05 - admin Handler which is very
41:07 - straightforward but before that just
41:08 - quickly just quickly go through the code
41:11 - just to make sure everything is
41:13 - perfectly fine perfectly all right
41:17 - [Music]
41:20 - uh we have the user login request the
41:24 - login response and login route to use
41:28 - route
41:29 - yeah everything looks looks all right
41:32 - okay for now
41:35 - and now I will just create the user
41:39 - Handler and the
41:42 - admin handbook so let's see
41:44 - Pub async function user underscore
41:47 - handlers
41:50 - ID string
41:54 - we've already have the web result
42:06 - okay
42:13 - head so you remember in the demo that
42:15 - when the user was logging in
42:18 - it said user one
42:20 - user to admin to like that hello user
42:24 - run well so this is where it's all
42:25 - happening so we just
42:27 - saying hello user
42:29 - and we're embedding the uid dash
42:33 - foreign Handler
42:42 - you have the exact same function
42:45 - so let's say
42:51 - admin Handler
42:53 - takes in all of this says hello admin
43:00 - and with the admins ID
43:04 - that completes our main dot RS files now
43:07 - we we have the
43:10 - error file to complete
43:13 - okay and then we have our auth files to
43:16 - work on
43:19 - all right so now
43:22 - you know that we've completed the
43:23 - main.rs file I will now work on the
43:27 - arts.rs file okay
43:30 - so the first thing that I can Define is
43:32 - the enum roll
43:35 - and I know that role
43:37 - has
43:40 - a role can be of type user which is the
43:42 - struct that I've created or it could be
43:45 - admin so two two different values right
43:47 - user
43:49 - and
43:51 - then I'll Implement some functions for
43:54 - role so for example this
43:56 - function from string
44:00 - get the role from string
44:05 - and you get back role role being the E
44:08 - number right so
44:13 - from string uh like in the
44:18 - request you send the token
44:21 - from the token you will come to know if
44:22 - the user is
44:24 - a user or an admin
44:27 - and that will be a string right and then
44:29 - we'll you put that your string you want
44:31 - that to be in the form of the role the
44:33 - rule which is either user admin so you
44:36 - can compare
44:37 - so you get back to role right
44:40 - and now I'm going to match role
44:46 - if it's admin
44:49 - I'm going to say role
44:57 - admin
45:01 - or role
45:04 - user
45:06 - all right
45:11 - so
45:12 - there needs to be one more closing
45:15 - bracket
45:16 - this makes sense
45:20 - so in a JW token
45:23 - to create a JW token you need claims
45:25 - also right so we'll I'll create the
45:28 - claims
45:29 - struct here
45:33 - but I'll come back to it
45:35 - once I create the
45:37 - creates GW function
45:41 - okay so here we have the
45:44 - create jwd function
45:47 - which helps us create the token
45:50 - so here first you have the uid which is
45:53 - a string roll which is
46:02 - the role which basically sorry this from
46:05 - string is small s
46:08 - make sure you make the change as well
46:13 - okay so for here role is role which is
46:19 - the Ampersand role
46:22 - and you get back the result from here
46:26 - which is
46:28 - string
46:31 - so what all what all does a token
46:34 - comprise of it's the expiration time or
46:37 - date time date
46:39 - and the claims and the header right so
46:42 - first
46:44 - let's have the expiration
46:47 - we need the UTC package here obviously
46:51 - Etc now which is the time which is right
46:53 - now
46:54 - and then you'll say dot checked
46:58 - add
46:59 - signed
47:01 - using Chrono
47:04 - duration this is valid for 60 seconds
47:09 - it's the expiration time so if you were
47:11 - to use this after 60 seconds it won't
47:13 - function
47:16 - dot expect
47:17 - valid timestamp
47:22 - dot time stamp
47:27 - okay so now the other thing
47:30 - is
47:32 - the claims
47:35 - and here this will be equal to claims
47:38 - with the capital c which should be this
47:40 - struct that will create here the claims
47:42 - will have
47:44 - sub which will be string
47:47 - I have the role which will again be
47:49 - string and the expiration which will
47:51 - again be
47:53 - view size
47:56 - okay
47:58 - and here you need three things which is
48:02 - derive
48:04 - debug
48:07 - comma this serialized comma serials
48:12 - we'll be deserializing and serializing
48:14 - it but to
48:19 - have digitalizing serialize you need
48:21 - survey so we'll say
48:24 - use 30
48:28 - serialize comma
48:30 - serialize right
48:35 - and we also use Chrono so we'll say use
48:38 - Chrono
48:45 - get everything from Chrono essentially
48:50 - okay
48:57 - so for claims we've defined what claims
49:01 - looks like
49:03 - uh here also for the role
49:07 - we'll say hash
49:12 - Drive
49:15 - and clone
49:18 - like capital c
49:20 - comma partial
49:23 - okay
49:33 - coming to the claims
49:35 - we have to work with three things sub
49:38 - which is actually the uid so two
49:40 - underscore owned
49:44 - comma we have the role which is role dot
49:47 - two undersource string
49:50 - and we have the expiration which is
49:52 - essentially expiration as unit size
49:56 - which is the type right
49:58 - string you size the types
50:01 - comma
50:03 - and
50:06 - finally as I mentioned the token will
50:08 - have the expiration claims and you'll
50:10 - have
50:11 - header so we'll have header is equal to
50:14 - header new
50:17 - using
50:19 - the
50:21 - hs512 algorithm
50:25 - and we'll encode the header
50:28 - the claims
50:30 - with the encoding key
50:34 - from and Source secrets
50:38 - jwd
50:41 - Secret
50:44 - dot map
50:47 - error
50:50 - sorry
50:59 - token
51:02 - version okay
51:06 - so first let's
51:09 - um
51:13 - let me actually use Json web token
51:20 - that basically gives us the ability to
51:22 - decode and code
51:24 - gives us the algorithm that we just used
51:26 - right
51:27 - so you we use something called as
51:29 - encoding and or the encode function
51:33 - which requires headers and claims which
51:34 - we have right now it is in claims the
51:37 - header will have the the algorithm
51:39 - different type of algorithms can be
51:41 - selected by us
51:42 - and then the encoding key which is
51:44 - directly secret we have to create that
51:45 - encoding key right now
51:47 - algorithm comma decoding
51:51 - key
51:53 - comma and coding key comma
51:57 - header command validation
52:01 - all these things we need
52:08 - and when I
52:10 - also use the fmt package
52:16 - and I'll need warp obviously
52:20 - and warp I'll have filters
52:24 - header
52:26 - headers cloned
52:29 - and have http
52:32 - header
52:35 - at a map column header value comma
52:39 - authorization
52:44 - and we'll have reject
52:47 - filter and ejection
52:53 - we will use this now but up until now
52:56 - what we've done is we have created uh
52:58 - enum for role
53:00 - I'll I'll just switch
53:03 - bring this out here
53:09 - the enum for role
53:13 - create the implementation for all so
53:14 - this shouldn't be here this should be
53:16 - here actually
53:18 - okay with the with the E number the data
53:20 - type
53:22 - and this is the information of function
53:23 - for role which as as I said helps us to
53:26 - get role which is admin and if this
53:30 - string is admin we'll Define role as
53:31 - admin which is part of the enum whole
53:34 - enum otherwise it's user then we have
53:37 - claims which has role and expiry which
53:40 - are the two more important
53:42 - fields
53:43 - the create durability function takes
53:45 - some uid and role and sends a result
53:47 - which is a string which in our case will
53:51 - be the token actually
53:52 - and first we create expiration with the
53:55 - help of Chrono Chrono package helps us
53:58 - create
53:59 - the expiration time which is 60 seconds
54:01 - or the token and expecting about a
54:05 - timestamp
54:06 - then you have claims which is uid role
54:09 - and expiration of all three and you have
54:11 - header header create a starting of
54:13 - header with the algorithm that was
54:15 - uh let's just do 500 in our case which
54:19 - has which you get from the Json web
54:21 - token
54:22 - Library
54:24 - and
54:28 - then you use the encode function
54:31 - so what you do essentially not sure if
54:33 - you use JS Json web token before but
54:36 - I've uh I've shown that on YouTube I
54:40 - think with the node.js video also and
54:41 - with the golang video also the way to
54:43 - create a GW token and you can also go to
54:45 - their website and try this same thing
54:47 - out the way to create a data token is to
54:50 - use some information that you will hash
54:52 - right so you'll create a hash from some
54:54 - information so you can use this
54:56 - algorithm
54:57 - and some information like header and
54:58 - claims and use the encode function which
55:01 - will use this algorithm to hash
55:04 - that data that you send it and you get a
55:06 - key from it
55:07 - now to Hash it you use
55:10 - a secret key which is in our case
55:12 - database Secret
55:14 - and we can Define it here so on top we
55:16 - can just go here
55:18 - before this you can just say
55:21 - we'll Define it as constants constant
55:26 - J
55:27 - interpret is is a type
55:33 - u8
55:40 - Secret
55:43 - we'll also Define the better
55:53 - so what's this this is basically the
55:55 - thing that you see uh
55:57 - in your authorization so you say
55:59 - authorization right whenever you send a
56:02 - token in the request you see
56:04 - authorization and then you also say
56:06 - better and then the token okay so we'll
56:09 - see this value called authorization
56:11 - you'll see this Valrico better
56:12 - and general token a little bit secret is
56:14 - just the constant used for and as the
56:18 - encoding key to encode our header and
56:21 - claims and get the hash based on this
56:23 - algorithm
56:28 - and this error we have not defined it
56:30 - yet it will be in the error dot RS file
56:34 - and we'll work on that in a while
56:38 - okay so there's another function called
56:41 - with auth so if you go to your main.rs
56:44 - file
56:44 - you'll see this function being used
56:46 - called with auth with underscore auth
56:48 - and we
56:50 - are expecting this function to be
56:51 - created here
56:53 - okay
56:54 - so let's do that so we'll say
56:58 - public function with underscore hot
57:01 - let's see what it takes in so this it
57:03 - takes in the role so you pass in the
57:05 - role as user or role as admin
57:07 - again this role or user roller admin are
57:10 - coming from your enum role of user role
57:13 - for admin okay
57:15 - now that we're connecting the dots
57:17 - things will make sense maybe you are
57:18 - confused here why we're writing it like
57:20 - this
57:21 - but it all makes sense when we have uh
57:24 - because we had we're going in a
57:26 - particular order we can't do everything
57:27 - all at once so sometimes things end up
57:31 - we write we end up writing some things
57:33 - before they actually exist on the other
57:35 - file but now as we have with your
57:38 - um
57:39 - connecting all the dots everything will
57:41 - make sense
57:42 - okay
57:43 - so this is the function that you want to
57:45 - work with now function with auth
57:49 - and here we have role
57:53 - takes control
57:55 - and we'll implement
57:59 - filter
58:07 - extract
58:09 - is equal to string
58:13 - from
58:15 - error is equal to objection
58:25 - headers blonde
58:29 - dot map
58:32 - move
58:34 - headers
58:37 - error map
58:40 - header value
59:05 - so essentially it's just a long way of
59:08 - saying
59:10 - we're cloning the headers that you get
59:12 - in the uh
59:15 - along with the role you get you throw on
59:17 - the headers and you basically
59:21 - um
59:22 - you call the authorize function that's
59:24 - what essentially you're doing so in the
59:26 - authorized functions
59:27 - we will be passing the headers and the
59:29 - role
59:30 - okay and the authorized function is the
59:32 - main place where we'll write all the
59:33 - logic so what's happening here is
59:36 - when somebody hits the user out we want
59:39 - to because they're also sending in the
59:41 - token right and the login route when
59:43 - when they hit the login route because of
59:45 - the login Handler they will be able to
59:47 - create the
59:51 - um the token right so the create JWT
59:54 - function gets called from the auth
59:56 - package auth module so creatively
59:58 - function something that we created right
60:00 - now which basically creates the
60:03 - token for you so
60:06 - after you have the token that's when you
60:08 - call the user route right which starts
60:11 - with Slash user call that route when you
60:13 - have a token so here you're passing uh
60:17 - you're passing the role which is of user
60:19 - because you're expected to be a user if
60:21 - you're hitting the user out
60:22 - so you
60:24 - check if that user is is legit or not in
60:29 - the sense he has a right
60:30 - token or not
60:32 - if he has a right token only then you
60:36 - will enter this function called user
60:37 - Handler
60:38 - you have the user Handler function
60:40 - already
60:41 - it's supposed to send hello user and
60:43 - then the uid but to be able to reach
60:46 - here you need
60:48 - the you need to First
60:50 - cross this function called with auth
60:53 - or with auth
60:55 - as you've seen takes in the role which
60:58 - is
60:59 - the the user
61:01 - and it's going to essentially
61:06 - call the authorize function
61:09 - so in the authorized function you're
61:11 - going to pass the role and the headers
61:14 - okay
61:18 - so let's let's actually create that
61:20 - function here
61:22 - it's an asym function so async
61:25 - function authorize
61:29 - rule comma headers
61:37 - roll comma header map
61:43 - so you you might notice that we have to
61:46 - write a lot of boilerplate code like
61:48 - here we have to find that role is of
61:51 - type role and headers of type header map
61:53 - value here also in in the with auth
61:56 - function you're doing the same headers
61:58 - of type header map
61:59 - error value right all of that we're
62:02 - defining all of that
62:05 - but that's only because rust is highly
62:10 - uh you know has a lot of strict typing
62:13 - and it ensures that you don't end up
62:16 - creating a lot of errors
62:20 - so here you'll say match
62:25 - JWT underscore from underscore header
62:29 - class headers here
62:35 - now this function GW from header we will
62:38 - have to create this function as well
62:40 - so just write here function
62:43 - generally from here right so
62:46 - when you pass the token the jdb token in
62:51 - the request it goes in in the header
62:53 - right so you say minus H and then you
62:56 - say authorization then you say better
62:57 - and then the token right
63:00 - so because it's in the header you need
63:02 - to be able to get it out you need to be
63:04 - able to get out the token because that's
63:06 - how you will compare right match
63:08 - basically means comparing matching
63:10 - tokens
63:12 - only if the tokens match can we
63:16 - uh you know get the user to log in now
63:19 - the way to match is
63:21 - we need to uh decode the token as well
63:25 - right because we've encoded a token
63:27 - first we encoded using the encoding key
63:29 - use the encode function and now we'll
63:32 - also use in the authorize function we'll
63:34 - have to use the decode
63:38 - uh
63:42 - the decode function
63:49 - so you'll say
63:50 - in the decoded this is where you'll
63:52 - store it so decode
63:58 - claims
64:02 - Ampersand JWT comma
64:06 - percent decoding key
64:11 - from undersource Secret
64:15 - Ary and Source liquid
64:19 - comma
64:20 - and validation
64:25 - so you got to give it the algorithm with
64:27 - the help of which the
64:29 - encoding was done
64:31 - and you're going to decode with the same
64:34 - [Music]
64:35 - decoded
64:38 - hs512
64:48 - so this bracket I've created here is
64:50 - wrong
64:52 - should be the round bracket
65:00 - dot map
65:03 - the error
65:06 - and just go here reject
65:10 - custom
65:12 - again this error we will create jwd
65:17 - token error
65:22 - okay
65:24 - that means there's some issue with the
65:25 - token
65:27 - and then
65:30 - we'll match the role if role equal to
65:33 - role
65:35 - admin so when you have
65:36 - these four dots
65:39 - right you you're saying that roll admin
65:43 - which is role meaning role with capital
65:45 - r enum and admin this role is the same
65:48 - as the role that we just got
65:51 - that was passed from the body to this
65:54 - function
65:56 - and roll
66:00 - from underscore
66:02 - string
66:05 - decoded dot claims dot role
66:09 - is not equal to
66:11 - role
66:13 - admin
66:20 - okay
66:22 - return error reject
66:26 - custom error
66:29 - no permission error
66:37 - yeah so if it's not an admin
66:40 - if the person is not admin and he's
66:42 - trying to access
66:43 - the admin route
66:46 - then we will say that you don't have
66:49 - permission to do this
66:51 - and that will basically be defined in
66:53 - the no permission error
66:55 - okay
66:59 - and we'll say okay
67:02 - coded
67:04 - dot claims
67:07 - dot sub
67:18 - here we'll handle the error we'll just
67:20 - return
67:22 - better sync
67:25 - eject
67:28 - custom
67:30 - header
67:36 - so this is your authorized function okay
67:44 - now coming back to this function which
67:45 - is the
67:48 - um
67:51 - GLD from header function
67:55 - which helps us get get the token from
67:58 - the header
68:00 - so here again we'll be working with
68:02 - those two things two two Fields or two
68:05 - uh two components of the token of the
68:08 - request body one is the authorization so
68:10 - whenever we pass a token right we say
68:12 - authorization and then
68:14 - then we say better and then actually the
68:17 - token right so we need both of those
68:19 - things so we'll just check for those
68:20 - things and then after that what comes is
68:22 - the token that's what we will return
68:23 - from this function so we'll see
68:26 - headers
68:28 - which is of type header map
68:32 - header value
68:38 - return a result
68:41 - which is string
68:44 - okay
68:46 - that header is equal to match
68:51 - errors dot get
68:53 - authorization
69:00 - if the value is matching
69:03 - then we'll return the value otherwise
69:04 - we'll just return and
69:07 - errors
69:11 - saying error is no auth header found
69:16 - it's no author
69:18 - header header
69:21 - right that will basically show that
69:22 - there was no auth header if there was a
69:26 - Authority it'll just return that but
69:28 - there was none we'll just say no auth
69:30 - header header
69:32 - and this error we will Define in the
69:35 - error module
69:37 - okay
69:40 - and
69:42 - you will
69:46 - um
69:47 - get that from header so
69:51 - so I'll have to import those grades so
69:53 - let's say use create
69:59 - error
70:01 - result
70:08 - okay
70:14 - so now I have the error create resulting
70:17 - with result
70:21 - in web result are these that we've
70:24 - defined here
70:26 - anyhow
70:28 - so coming back to Glory from header
70:34 - um
70:39 - so let's get the auth header which is my
70:42 - matching
70:44 - standard string
70:47 - from UTF 8.
70:50 - header dot as
70:53 - underscore bytes
70:58 - foreign
71:08 - otherwise again we'll return the same
71:10 - error which is
71:17 - no auth header header
71:25 - header and if there's no odd header that
71:27 - starts
71:28 - with
71:30 - better
71:32 - then we will return
71:34 - sorry
71:36 - then we will
71:39 - return
71:42 - error
71:45 - invalid
71:48 - auth error
71:54 - headers
71:56 - okay okay
71:59 - let's go header dot trim
72:02 - start
72:04 - so you're trimming the part which is the
72:06 - bearer part and after that is the token
72:08 - right so you whenever you pass token to
72:10 - make a request
72:11 - uh you say authent like I said
72:13 - authorization and then the uh better and
72:18 - then the actual token so you want to
72:20 - remove or trim the part to start matches
72:22 - with
72:29 - pairs
72:35 - all right
72:49 - so that's it that's that completes the
72:51 - auth.rs file what we'll do is we'll
72:54 - quickly go through everything just to
72:55 - make sure everything is correct
72:58 - and the file
73:00 - and
73:03 - then we'll wrap it up
73:05 - so we have pair you have 0b Secret
73:08 - you have the role the implementation for
73:12 - the role
73:14 - the uh
73:16 - yeah there's one more thing that's
73:19 - spending which is where we'll use this
73:21 - fmt
73:22 - package which will be in the
73:28 - Implement fmt display for role
73:33 - the right way to display the role
73:36 - to format it so it's format it properly
73:39 - which is self
73:42 - comma f
73:46 - Prime percent of mute
73:49 - fmt
73:51 - formatter now this is completely
73:53 - optional you don't have to do it you
73:55 - don't have to do this formatting I'm
73:57 - just doing it
74:40 - okay so the formatting part is complete
74:42 - we have claims we have with auth we have
74:44 - uh create JWT function
74:48 - we have uh authorize we have gwg from
74:53 - header
74:55 - right so quite a bit now the only thing
74:57 - that's left
74:58 - is the error.rs file
75:03 - to do that
75:05 - I will quickly create an enum for the
75:08 - types of errors that will have and we'll
75:10 - we've already used those errors in the
75:12 - other two files which is the main file
75:14 - and the auth file so we shouldn't have
75:17 - shouldn't have uh shouldn't be a big
75:20 - challenge for us now
75:24 - so what we'll say is
75:29 - say
75:33 - uh
75:35 - enum
75:38 - and errors
75:41 - so what kind of errors that I've used
75:43 - I've used the wrong
75:45 - credential error sorry
75:47 - the wrong credentials error
75:49 - I've used the GWT
75:53 - token error okay
75:56 - obviously token creation error
76:01 - this one
76:03 - I've used the no
76:05 - so that's the benefit with ID using a
76:07 - good ide is that we get these
76:09 - suggestions based on
76:11 - the errors that we already used
76:13 - the other is invalid auth header error
76:17 - and in no permission
76:25 - let me just also right here
76:30 - error
76:32 - wrong credentials
76:44 - 223 token not valid
76:54 - then you have
77:01 - awt token creation error
77:11 - no auth error so no error error
77:18 - foreign
77:49 - okay
77:54 - so what does the error response look
77:56 - like so what I'll say is struct
78:00 - and error response
78:05 - looks like this you have
78:09 - a message it's a string you have status
78:11 - which is a
78:13 - string
78:16 - and then in the beginning what you'll do
78:18 - is you'll say use so they
78:22 - serialize
78:24 - use standard
78:27 - convert
78:31 - valuable
78:33 - because I'll be using this
78:35 - and this as well so I'll just
78:38 - bringing them
78:40 - right now so that I don't have to come
78:42 - back here
78:43 - is what is obviously we'll use walk here
78:46 - XL
78:48 - http
78:49 - status code command rejection
78:53 - comma reply
78:59 - awesome
79:00 - okay now that we have everything
79:03 - you know the basics build
79:06 - we'll just Implement warp reject
79:10 - reject call error
79:15 - and now most importantly the handle
79:17 - rejection
79:19 - function
79:21 - so this one this function hand rejection
79:23 - which comes from the error module
79:26 - as the function that we want to create
79:28 - now so we'll say Pub
79:32 - async function handle
79:35 - rejection
79:44 - now after writing all of this code
79:45 - obviously we will have to
79:48 - so I'll just drink some water obviously
79:50 - we will have to
79:57 - turn on the rust analyzer
80:00 - because I'm sure we have made a lot of
80:02 - mistakes
80:04 - well that's completely all right
80:06 - uh
80:09 - this is all about working in Broad
80:11 - Strokes
80:12 - in the beginning
80:14 - and then
80:15 - figuring out
80:17 - how to fix
80:19 - the code
80:24 - because you don't want to break your
80:26 - thought process
80:29 - too much
80:30 - so just write
80:32 - what's coming to your mind here and then
80:35 - we'll fix everything we'll get into
80:36 - details and fix everything right now
80:39 - this is a very different way of working
80:41 - but it works really well good message
80:46 - is equal to if error
80:49 - dot is
80:52 - not
80:53 - found
80:56 - you will say
80:59 - status code
81:03 - not found
81:09 - not found Dot
81:12 - 2 on your Source string
81:18 - okay here
81:20 - it will say else if let
81:25 - sum
81:27 - the error dot find
81:33 - error
81:37 - and then you'll let's
81:39 - match the error right so if there's no
81:42 - error
81:43 - that that error does not exist so you'll
81:46 - say not found otherwise you'll just if
81:48 - there is an error you'll just match it
81:50 - with
81:51 - these ones
81:53 - so the first one is the wrong
81:55 - credentials error then you'll have
81:59 - the no permission error then you will
82:03 - have
82:04 - the jwd token error and then we'll have
82:09 - the JWT so this match function enables
82:13 - you to match the exact
82:14 - error then take
82:16 - um
82:17 - the right action
82:19 - based on the error
82:21 - now again uh this entire file which is
82:24 - error handling is completely optional in
82:27 - the sense you don't have to it if you're
82:29 - not building clicks production grade
82:30 - stuff but if you are building production
82:32 - grade stuff then it's it can really
82:35 - helpful right you don't want to build a
82:37 - project it doesn't have any error
82:39 - handling
82:42 - so here if I have wrong grain chills
82:44 - error what I want to do is I want to say
82:47 - status code forbidden
82:55 - comma e Dot
82:59 - do underscore string
83:04 - clear and Save
83:06 - status code
83:08 - on or
83:10 - authorized
83:12 - e Dot
83:14 - to understand string
83:24 - status code
83:26 - okay unauthorized
83:29 - two underscores let's go screen
83:37 - and for
83:40 - this
83:42 - we'll say
83:45 - status code
83:48 - internal
83:53 - server error
83:58 - done also now all of this that we are
84:01 - doing right now is very very basic
84:03 - simple code there's nothing there's no
84:05 - business logic here nothing that's
84:06 - happening that's critical it's just
84:08 - error handling matching the error right
84:11 - with the right uh
84:15 - with the error type and then giving the
84:17 - right status
84:19 - for it
84:22 - so at the end you'll say comma
84:25 - and
84:30 - status code
84:36 - right underscore request
84:39 - e dot two
84:42 - underscore string
84:49 - this is e.2 string and then after that
84:52 - it's
84:57 - if
84:59 - error dot find
85:10 - Warp
85:12 - checked
85:14 - mapper mode
85:16 - allowed
85:26 - that is underscore sum
85:49 - foreign
85:57 - underscore not underscore
86:01 - loud
86:05 - and the actual text that will be
86:07 - returned which is method
86:08 - not allowed I will be
86:12 - two
86:14 - I'll just call string
86:19 - so in case you don't want to build this
86:20 - entire file you can just copy and paste
86:22 - it as well not a problem like copy and
86:24 - paste it directly from my GitHub
86:27 - it's all just error handling and once
86:29 - you do this in this file or in this
86:31 - project
86:32 - you can
86:37 - we can do it in any other file also you
86:39 - can just copy and paste this so what's
86:40 - essentially Happening Here is we're
86:42 - matching the error with the type of
86:44 - error sending the particular status code
86:46 - like 401 500 blah blah this is 500 for
86:49 - example this is 401 for example right
86:51 - and with the message the error message
86:54 - right
86:55 - and here if
86:58 - there's nothing here then it's just bad
87:00 - request right
87:01 - no type of error is matching so it's a
87:03 - bad request
87:06 - and then we also uh handling for
87:09 - method.loud so if if method.log
87:11 - basically means if it's uh it was meant
87:13 - for post but you were trying to get
87:14 - right so that's method not allowed so
87:17 - that also we're handling out here
87:19 - here we'll say e print this is just very
87:23 - basic error handling I'm sure you
87:26 - already know all of this
87:31 - and then
87:33 - and then
87:36 - comma error
87:41 - here
87:43 - that is code
87:47 - internal server error
87:50 - on an internal
87:57 - server
87:59 - .2 underscore string
88:16 - then we have let Json equal to
88:19 - what
88:28 - reply
88:32 - Json
88:37 - error response
88:41 - status
88:42 - code Dot
88:45 - install string
88:48 - common message
88:56 - finally
88:59 - okay
89:01 - work reply
89:05 - with
89:07 - status
89:10 - Json command code
89:12 - okay so each
89:14 - errors has some Json message which is
89:18 - the Json
89:19 - and the code which is the status right
89:22 - the code has code is like 401 500 like
89:26 - that and the message is basically a Json
89:29 - Json has both of those things and cool
89:32 - all right so this is our error handling
89:36 - file and now we'll go ahead and
89:41 - um
89:47 - I'm looking for rust analyzer actually
89:50 - just say just
89:53 - come up
89:56 - yeah so I'll just enable it
89:59 - and and I get lots of errors
90:03 - which is nice because we will now
90:06 - fix them
90:07 - one by one
90:11 - all right so in the main dot RS file if
90:16 - you
90:16 - go to the login Handler function
90:20 - just login request needs to be one word
90:22 - right because that's how we created the
90:24 - struct
90:25 - and sum needs to be capital s
90:30 - so that
90:31 - fixes two small
90:34 - errors hopefully
90:38 - and now we'll just add some dependencies
90:40 - because those are the packages that
90:44 - you're using so once we add some
90:45 - dependencies hopefully the some of the
90:48 - issues should go away
90:50 - so here we have uh the version edition
90:53 - all of that and dependencies I'll just
90:56 - add
90:58 - the ones that I'm using so you can just
91:00 - copy and paste from my calculator file
91:02 - in case you want to write it on your own
91:04 - you can do that as well so we're just
91:05 - using Json retro control key or warp 30
91:07 - sorry Json
91:10 - this error Chrome no debug
91:13 - sorry for profile Dev file test profile
91:16 - release
91:17 - so I've added those now and as you see
91:19 - now for main.rs lot of the uh almost all
91:24 - of the issues have gone away so it
91:25 - doesn't show any issues anymore
91:27 - all the issues that are pending are in
91:29 - error.rs but now again now again I can
91:33 - see I mean or others there are there's
91:35 - five issues again
91:38 - all right so
91:41 - we move that and then let's
91:44 - find the pending issues
91:48 - now in the auth.rs file there is in the
91:52 - pub inum role there is one comma missing
91:54 - put that there
91:56 - and here instead of fun which is FN I've
91:59 - written fun which is
92:01 - fun so when you when you save that
92:04 - just left the three errors here and then
92:06 - just four errors here right so certainly
92:09 - the errors
92:11 - have become much less
92:15 - with the error.rs file there are many
92:18 - things that are wrong
92:20 - so here
92:21 - should not have the comma should have
92:24 - semicolon here
92:26 - semicolon here
92:29 - and on top of that you need derive error
92:32 - bug
92:34 - out here and derive
92:37 - serialized bug
92:40 - out here
92:42 - so that should hopefully take care of a
92:46 - few issues
92:48 - right so now and take a look
92:52 - four issues are left in the add or RS
92:54 - file but auth and Main
92:57 - these two files are working completely
93:02 - right so this because there's dependency
93:04 - between these files when I fix issues
93:06 - here
93:07 - both these files are now
93:10 - like they're perfectly fine they don't
93:12 - have any issues at all you just have to
93:14 - find
93:15 - four more issues now
93:19 - one really small issue that I found here
93:22 - is that there's double
93:27 - colon missing
93:29 - and now we left with one one small issue
93:34 - and then the final issue is that two
93:37 - string the S should have been small and
93:40 - the other dot artist file now we see all
93:43 - the issues have gone away
93:45 - so the natural step now is to
93:49 - do cargo run
93:54 - and let's just start just one API and
93:56 - then we're sure everything else will
93:58 - work because
94:00 - because there are no issues and we have
94:02 - built it
94:04 - very carefully
94:06 - let's try at least one API
94:09 - okay so I will
94:12 - open up
94:16 - and let's check out
94:19 - if everything works as expected
94:23 - foreign
94:26 - everything's working perfectly fine now
94:29 - let's say uh if this score is not
94:32 - correct maybe because I've not tested
94:34 - all the other apis maybe if this is not
94:35 - correct you don't have to worry because
94:37 - I am going to be uploading the correct
94:39 - code which was which I showed you in the
94:40 - demo right even though this code is
94:43 - correct but like just for your peace of
94:45 - mind I'm going to upload the code which
94:48 - is
94:50 - um the one I showed you in demo right so
94:52 - it's already uploaded in GitHub feel
94:54 - free to take a look now you know how
94:56 - that code works you have a complete idea
94:58 - about that
94:59 - so we learned a lot in this video quite
95:02 - a lot right we understood how to use
95:04 - word power to create apis how to handle
95:06 - errors
95:07 - uh how to use JWT in in Rust for
95:11 - authorization how to encode the code how
95:13 - we used uh the claims the expiration
95:20 - and how we created the token and then
95:25 - the role you know how we had tools for
95:28 - admin and user
95:30 - so a lot of stuff lot of stuff in this
95:32 - video that we've learned I hope you
95:34 - learned a lot as well thank you so much
95:37 - for watching
95:38 - and do share this with your friends to
95:41 - share this playlist with your friends
95:43 - it's all free and it's
95:45 - um good information right thank you so
95:47 - much and I'll see you in the next video

Cleaned transcript:

rust is an increasingly popular programming language in this course you will improve your rust skills by learning how to build an authentication server in Rust Akil Sharma developed this course he is an experienced rust developer and is a great teacher for beginners so let's get started in today's video we're building uh a authentication server so we'll be using JWT but for the apis we'll be using a framework called warp it's a web framework in Rust the benefit of warp is that it's a small lightweight framework so it helps you to get quickly started by building apis and and there are a lot of use cases so in the sense there might be many projects where you don't want to build a fullblown server like you don't want to use actex or you don't want to use rocket because of the much bigger Frameworks and with a lot of features they're also heavier slower slower to build with a lot of Concepts right so in those cases you might want to have something like warp which is very easy to learn very lightweight very easy to very fast to get started with fast to build with and fast to run at runtime it's also very fast so warp has a lot of benefits uh and a lot of use cases uh so uh by the way we've already built a project with actex right and was it wasn't a fullblown project like a very small simple project I just showed you how to use actex right uh so you might want to check that out I think that will be much before in the in the in this playlist series because in this video Even though this framework is much lighter we're actually building a much bigger project than the one that we built with tactics right but the projects are comparable in in the sense that even with this project if you're building we're not going to be using a database we're actually just using a hash map and that hash map we would already precreate the users and then when we log in we'll just be comparing with the users that are already created in the hash map okay so we don't have a database just a hash map with precreated users login and we'll do all of the things with JWT like creating tokens authentication there's also one more thing here which is role based authorization so we'll have different routes for users and admin and we'll be checking if the user is a regular user or he's an admin and depending on that we'll be giving him access to the apis okay so that also is there so that means it's uh it's it's almost uh like a proper project for for JWT right you'll have regular authentication and rolebased authorization that means you could use this code in multiple places all right so what we'll do now is um I have two terminals let me just show you my uh screen I have two terminals open here for you guys one is the uh place where I've already built the project now I just want to tell you that this project is already built it's on my GitHub right so I'll put the link of the project on GitHub on on this YouTube video but in case I forget to do that you just need to know that I'm akhil Sharma 90 on GitHub and all the projects almost all of the projects that I've built are already there and this one is definitely there because I just built it just uploaded it all right so here uh the project yeah the name of that project would be something like rust warp zero three example something like that anyway so now what we'll do is I'll just run it I'll just say cargo run okay and it's running it's running on Port 8000 and I will now interact with this project so uh the first thing that I'll do is I will hit the login route okay on a different terminal as you can see I'm running I'm hitting the uh the login route all right and I'm inputting the email which is user at userland.com and password1234 because this user is already created in my hash map which is there in the session memory of the project which is running at the moment right there's no database like I said just a hash map when I log in I get the token so this is what the JWT is doing here it's creating a token for us now what I'll do is I'll go ahead and I'll save this token somewhere okay so I recommend if in case you also have this project in your running it long you might want to save this as well but anyways this is just a demo so in case you haven't forged my project from GitHub and are not running it on your system it's completely all right I'm just giving you a demo right I have copied it somewhere the the token and now I'm going to try to hit the user route okay so I'll just press enter enter a couple of times hit the user route and it says as you see Hello user one that means um that means the um jwd is able to determine that this user already exists and it's able to check the token it's also unable to get the information like the user type from the token so this means it allows me to hit and it also sends back a responsing hello user one okay uh now what I'll do is I will um I will try to hit the admin route with this token okay so let me bring out my command for the same sorry uh yeah okay so this is my command my call command where I'm trying to hit the admin route with the same token the token that's meant for the user and ideally it should not let me in because this is the admin route meant for the admin user not for the regular user so it'll say okay not valid status 401 unauthorized all right so we have elaborate error handling in our project and that's also what we'll be building today okay and the next thing you want to uh do is hit the login route but with the admin credentials so what I'll do is I will hit the admin route just a second yeah hit the admin route so you can see here sorry the login route but with the admin credentials so I have the admin created here with different password like I said these users are already created uh whenever we start the project these users get created in the beginning and I'll show you how to do that we will initialize these users right so we're just comparing that this user which already exists in session memory right now is it the same as this user that I'm sending in as request and yes it is so it's giving me a token now so what I'll do is I'll just copy and and paste this token in a safe place and what I'll do is I'll try to hit now the admin route so we saw earlier that we were not able to hit the admin route right because it is saying it's unauthorized but now if we try to hit the admin route it says hello admin 2 which is with new token you're able to hit the admin drop all right that's awesome so what I'll do now is I will again um try to hit the user route and let's see what happens so try to hit the user route with this admin token and let's see what happens okay so I will come here I'll try to hit the user out but with the admin token so it remembers it says hello user two so that means the admin is able to hit not only the admin route but also the user out but the user is only able to hit the user out not the admin route I think okay I hope that makes sense it's quite elaborate like the rules that we've put in quite elaborate and that's it's like a fullblown working project you can just pick up the code use it on your project right if you have let's say a submission in your college or you're building something and you're at your office in your job you're building something very quick the best way to build it all right but jwd it has what but it has these apis it has error handling it has rules and authorization authentication everything is there anyhow so now let's get started so I'll just clear this all up I will stop this over from running and I will create a new project so I'll say cargo new and I'll give a name like uh rust what I'll say JWT and and waiting for YouTube so I'll CD into it rust warp JWT and YT all right and you can see here cargo tumble SRC now I have not created videos in uh uh in quite some time now and the reason for that is that as many of you might know that my startup armor dot AI was selected by techstars which was the next which is a great accelerator and then recently got selected by outlier Ventures which is again an accelerator Tech accelerator and in the middle we also got grants from companies or blockchains like Aptos so it's been extremely busy very very hectic and basically essentially what armor AI is it's it's a it's a platform where you can build security tools so it could be for web 2 for web 3 doesn't matter uh the platform enables you to build security tools really easily that's what we're building at at armored uh anyhow just wanted to update you on and why I've not been making a lot of videos but then uh now it's getting things are getting a little bit lighter I'll have a little bit more time hopefully and whenever I have time in between the day I'll just create a quick video like this right so that uh unable to also keep in touch with the Technologies anyway so I have it here I am going to open it up in my guess code okay so there are two terminals right the other one I can actually I can just get rid of that okay so here in my SRC I have a main.rs which is awesome but I need two more files I need my uh all the logic for my authentication and all the logic for my headers I need that as well okay so now another thing is it's it's uh there's quite a lot happening in this project so I'm just wondering where to get started with I think I'll just remove I'll just remove I guess get get rid of all of this and I'll start by just creating a user struct okay let's just do that so let's just create a user start okay uh and by the way I I'm not sure if you can see my screens they're up in the sky like up in the air now earlier they used to be on the on on the table now I've put them up in the air so I will be just looking here and there will have like four screens here um four different screens so yeah I just want to tell you that so like there's nobody else in the room I'm not looking at the person when I'm looking here at me I'm just looking at the screens all right so um like this having the same code window on two different places like instead of having like a split view just where to have it on different screens that's what I uh was doing right so uh in the main dot RS you have your user uh struct and I'm going to have a uid which is string and email which is again string okay and then password which is again string now I hope you all know what structs are you shouldn't be doing this video if you don't know the basics of Rush by the way because I I get a lot of comments on on YouTube saying that hey I didn't understand uh anything that you're teaching it's obviously because I'm expecting that you know rust uh before if you want to build a like fullon project with Frameworks and last right and a lot of people don't understand that and they just come and write on my videos I'm not understanding anything you're saying and you're just talking you're not explaining it's because it's because I'm not supposed to be explaining what is a struct in a video that's meant for uh building projects for the web framework right so I need to give me that much off like you have to have that kind of understanding at least so anyways even if you don't know what struct is it's basically uh enables you to create your own custom data types so user is a data type here which has a uid which is string email string password and role okay because role could be user or admin as we just saw in the demo and in then I have another struct for the login request okay so I'll have two things which is the request and the response for login and sorry I'm not able to look at my keyboard because of this mic let me just put it here all right so for the login request I have uh the email so I'll send the email and I will send the password email and password so it's a very straightforward simple straightforward login okay and then I have something called as the login response like I said you know when you um when you make a request for logging in that that is what this will look like the login request will always look like this it will have always an email and a password the login response will always look like this will have a token right so this is my way of defining the write request and response instructs right so that it doesn't deviate the project was interviewed from this all right so now because uh I'm sending the request as Json as you just saw in the terminal I was using um the terminal and I was sending Json requests right and I was receiving a Json response so I need to Desert serialize and serialize right because just it's not able to understand Json one and so on and a lot of people coming from JavaScript background they get very confused in this step they think oh but why is that you know why is Russ not able to understand that when JavaScript understands that by default because Json is Javascript transition and JavaScript already understands that by default but trust does not go Lang does not and that's why we need to do this okay so you're going to say DC realize here in case you're uh you don't you don't know how serialization dexterization works there's a very detailed video that I've created on uh in in this series itself this figures itself it's in the towards the beginning where I explain the Third Day package which is uh the third day it's great sorry which is what which enables us to do digitalization and serialization so what I'm going to do is I'm going to first get that because uh by default rust doesn't have it so we need to make use of the survey package Jesus rise and serialize okay and you have that now for the user uh we'll have to work with the user object multiple times right so when we receive the user object in the um you know so we will create the user object and it'll be stored in the session memory as a hash map we'll have to also compare with the user that we'll get uh you know the user data that we get in the request and then we'll have to search for the users so we'll do a lot of operations with users where we need to have multiple copies of the users so I'll just clone this so I'll just say I'll give it the ability to that that we're able to clone it uh very easily so I'll just say Drive clone and now what you want to do is we want to start working on the main function so I'll say sync FN Main okay and to be able to enable the async function we will be using Tokyo so in case you haven't worked with Tokyo there are multiple videos on the same playlist this rust playlist multiple videos about Tokyo make sure you check them out we've already built projects using Tokyo and the asynchron the async functionality brings us with it so here we'll say let users equal to Arc new in it underscore users now init users is going to be a function that will help us create default users so I'll repeat again and it uses the function that'll help us create default users as the program starts so before we make any requests two users will already exist in our hashmap to users one being the user regular user one being an admin user That's How we'll compare the user coming in the request with these users in the hashmap we'll search for these we'll compare them and that's how we'll create the token right that's the whole logic that's going to be there so Arc that we've just written here we'll have to add in the appropriate so it comes in from standard sync Arc Arc is something that you use usually with things that you will be using uh things that you'll be cloning a lot so it users is something like I mentioned we'll be cloning quite a bit oh by the way I'm not sure if I covered it with C at the end I made C Capital here in Clone uh you just need to see that this color changes right so maybe because I left for a quick break in in between uh just to get some water so maybe I didn't show you this which is C is supposed to be Capital make sure you do that in your code as well okay and we got this Arc now Arc unit users all right um so we have this now and now we quickly create our routes using warp now we also need warp here so I'll just quickly write use Warp and what comes with reject reply filter we'll need filter as well ejection and reply okay and we need warp now to be able to create these uh routes in the main function so we'll first say let login underscore dollars this is for the login route is equal to Warp but login okay so this is how the login starts and we'll say dot and warp post request so for that means for login that's the path right login. and it will be a a post method and we'll change some more things here so we'll say with underscore users and users dot clones as you know we're going to including users quite a bit that's why we have this here Dot and Warp body Json okay because the request will be in Json Dot and underscore then and login underscore handlers so essentially what's happening is if you hit the login route you need to have the login Handler that's the main thing right and everything else is just helping us with that so we have that it's going to be a post route it's going to have users so you'll clone the users and perform some operations in the user because as you you know with login you're going to be uh trying to find those users in the hashmap as we'll write more code it'll make more sense but just need to know that with login you need to have login Handler login Handler is a function we'll create in a while just ignore that right then we'll just create the user out and the admin route so user route is equal to again what paths and user okay Dot and with auth here you'll have role user okay so what we're saying is for the user out it's obviously when we whenever we had the user Outlet slash user that's when we're supposed to come into this chain and the role of that user should be users there are two rules one is the user role the other is the admin role talking about the user role here and then you have the user Handler okay talk about it just like we have the login Handler we have the user Handler here similarly we'll have the admin route and the admin Handler so admin route let's go to Warp path admin okay dot and with auth and you have the role which is admin okay Dot and underscore then admin underscore and essentially login routes with Slash login hits login Handler this is a post request user out with Slash user hits the user Handler admin route slash admin it's the admin Handler and generally let's just Define the routes so routes is going to be login route okay or user route or admin route might also recover so it the error if it's not any of these routes we'll have the recover error handle rejection handle ejection is something we'll work with uh mostly in our error.rs file but I'll mention it here error and handle rejection so what is this error so this error needs to be in in the top so we'll say use error everything from the error mod okay and I'll just get also everything from the auth so error and auth are these two files that we will be using as modules so I'll also get auth and here we'll have with hot and comma role right so we've done here uh reviews with users will not use yeah so we've used with auth also and the with auth you also pass role which is the user and that's the logic that we'll handle in our auth DOT orders file so that's why I've also gotten it from auth which is get with the auth and also the role okay because we're passing the role as well role user or role admin and here we can say mod hot and mod error all right now I need a couple of more things I need to be able to work with hash Maps like you know because we'll be creating multiple users as the program begins and that's the those are the users that we'll be comparing with when we have to do logins so we'll need hashmap and then I'll need another thing called infallible we've used it before it's when we don't want to return any error that's when we use infallible I'll use that also later on so I'll just include them for now so I'll say use standard just a second I'm not able to look at my keyboard because of this mic installing this new setup so you have used standard and you have collections cash okay and then you have use standard convert and parallel okay so we've reached here finally when you have defined all the routes you can simply start off the server so it'll say serve all the routes and run the server on 137 comma zero comma zero comma one comma eight thousand let's say dot await okay that's that now there's this function called with users so here you can go ahead and create that function so we say function with underscore users ticks and users which is a collection of users with a capital u so what does user of the capital user mean use of the capital u is actually the struct so multiple of those structs because we'll have multiple users like I said will be uh collection of these structs basically regulation of these trucks are assigned to users okay okay so implement filter essentially what you need to do is always we have that hash map of multiple users we have not created those yet but we'll create that in the init user function this function will create it very very soon but when you have that when you have that hash map of multiple users you need to be able to extract them right that's how you will you know go user by user extract user by user and then compare the details of that user with the ones that you'll receive in the request okay that's why we are extracting it so let's say is equal to users comma comma errors is equal to n value Plus clone save work any dot map mode enables me to extract users okay so there are three functions that I need to write here one is the login Handler the user Handler and the admin Handler so I'll at least create outlines of those functions so I'll say Pub async function login Handler okay the one that will be called when I have somebody hits the login path login Handler so it'll have users which is a collection of the users have body which is the login request okay so I'll explain this again users as a collection of the user with capital uses struct so multiple of users which are following this data type are the users that we'll have in users okay which is again here which had cloned and in login Handler you also have the body which is the login request so login request is something that you created here which will have an email and password so you'll have that also in the body which is the request body okay and we'll have to perform some operations with that so like like I told you the users we're going to get the users one by one and compare it with what you call in the body the details that's what we'll be doing here essentially and there will be something called as the web I'll just push it down something called as the web result so I'll say result reply match users users being multiple leaders right from the field assigned it to this variable users and you're going to how are you going to match you're going to match them by iterating over the users and you will find so like I I explained before that we have we'll have multiple users and we'll go over each of those users that the function will help us do by iterating user by user we'll go over them and then we'll compare them with the details that we get in the request That's How we'll come to know if this user matches this user which is there in the hashmap that's how you complete the login request so here will be find underscore uid comma user user dot email equal to body dot email user dot password equal to the body Dot password okay so uh for this web result right I will go up at results so I'll say type so it's a type that we've defined type red result standard result now we'll have to Define this result also T comma rejection now to Define this result also say type result t the standard salt result 2 comma error right and then you have type which is users our case it's Arc and it's a hash map of string comma each user right so this users that we were talking about all this while users like I said it's going to be collection of multiple user which is the struct and here we've just officially defined it as a hash map it's a art enables us to create uh you know with the help of cloning you have a hashmap which is string comma use it all right so here now that we'll find that particular user which is which matches the email uh the body email and user email and user password body parts which matches that you need to perform some operation on it okay so that means and we found it we'll perform some operation on it okay but before we do that I'll just create the init users function so that things are much more clear it's also sum even if I found it all right so first I'll just create the init user functions that things make a lot more sense so well because once I create this function everything will become so much clearer to you that all your doubts will go away so I'll create init underscore users function and this has a hash map string comma sorry string on our user and start with map s map new map dot insert this is the first user so we'll say if you remember here we just created so the reason I'm following this particular order is because I'm taking it through everything so users there's a string right the string is actually we use it for like one two you know the ID of the user and then we have the user and that's what we also had here the ID of the user and the user because we'll have multiple and we go through multiple users when we iterate through them so anyhow so the first thing is from I'll create one user number one comma and I'll say here user which is if you see capital u you mean you you know that I'm talking about the user the struct so here I have something called the uid which is string from one okay why because it starts with uid right and then I have something called as email which is again string from user at the rate user to land.com comma password restraint from one two three four these are all hardcoded values so I'm creating a hash map with these exact users and if you remember the demo that I showed you we were actually using this user details we were using this email exact email exact password to be able to authenticate that user that's what we're basically comparing role string and this particular user is has a role of users that's that's why when we logged in this user and we got the token we were not able to use that token to log in to the admin route the fit member comma so and now we'll say map dot insert for the next user so we want to create the next user now and we'll say string from 2 ND user okay comma user and it will say uid string from two come on email again a string from admin rt.com password is string from four three two one and the role is string form add right so this user's role is admin this is Rolex user as we know admin is able to log in to both user and admin but the user is not able to log into admin just user comma here and then finally we'll just say map all right now we can come back here so now that I've created the um init users functions now now everything is very clear to you right that we have these two users and we're basically doing everything else that we've done here is to compare the data that we receive in the in the request with the users right so when you found so we are basically in the login Handler we are trying to get uh we're trying to find the user which actually matches this email and password because that's what we send in the request once we've done that we want to perform some operations so we are going to create a Program forum so we'll say that token is equal to auth create 0w right so in the auth module you say auth because we have the auth multiple here which is going to have function called create 0p we'll have a function in the auth.rs file called create JWT going to just send it the uid comma and the role from string user dot role we would extract the user data Dot map underscore error reject custom error so we'll say okay reply it's Json so I've I've for the time being I've disabled rust analyzer and we will activate it so all of everything will get um formatted correctly but I'm just I'll just disabled it so that I'm able to type with these so all of this happens when that particular user was found so we created a token but let's say if no user was found like that which you know matches the email ID from that user that we were going through one by one and it didn't meet the body email or the body password what do we do then so we'll say none and we'll just send an error with reject and we'll say custom wrong credentials error so when we say custom that means basically we've defined these errors somewhere on our own that's what we mean and all that is there in the error file we'll Define all the errors now before I jump there I'll just go through the entire code once again just to be sure everything is fine and then we'll just hear the two handlers the login and admin Handler which is very straightforward but before that just quickly just quickly go through the code just to make sure everything is perfectly fine perfectly all right uh we have the user login request the login response and login route to use route yeah everything looks looks all right okay for now and now I will just create the user Handler and the admin handbook so let's see Pub async function user underscore handlers ID string we've already have the web result okay head so you remember in the demo that when the user was logging in it said user one user to admin to like that hello user run well so this is where it's all happening so we just saying hello user and we're embedding the uid dash foreign Handler you have the exact same function so let's say admin Handler takes in all of this says hello admin and with the admins ID that completes our main dot RS files now we we have the error file to complete okay and then we have our auth files to work on all right so now you know that we've completed the main.rs file I will now work on the arts.rs file okay so the first thing that I can Define is the enum roll and I know that role has a role can be of type user which is the struct that I've created or it could be admin so two two different values right user and then I'll Implement some functions for role so for example this function from string get the role from string and you get back role role being the E number right so from string uh like in the request you send the token from the token you will come to know if the user is a user or an admin and that will be a string right and then we'll you put that your string you want that to be in the form of the role the rule which is either user admin so you can compare so you get back to role right and now I'm going to match role if it's admin I'm going to say role admin or role user all right so there needs to be one more closing bracket this makes sense so in a JW token to create a JW token you need claims also right so we'll I'll create the claims struct here but I'll come back to it once I create the creates GW function okay so here we have the create jwd function which helps us create the token so here first you have the uid which is a string roll which is the role which basically sorry this from string is small s make sure you make the change as well okay so for here role is role which is the Ampersand role and you get back the result from here which is string so what all what all does a token comprise of it's the expiration time or date time date and the claims and the header right so first let's have the expiration we need the UTC package here obviously Etc now which is the time which is right now and then you'll say dot checked add signed using Chrono duration this is valid for 60 seconds it's the expiration time so if you were to use this after 60 seconds it won't function dot expect valid timestamp dot time stamp okay so now the other thing is the claims and here this will be equal to claims with the capital c which should be this struct that will create here the claims will have sub which will be string I have the role which will again be string and the expiration which will again be view size okay and here you need three things which is derive debug comma this serialized comma serials we'll be deserializing and serializing it but to have digitalizing serialize you need survey so we'll say use 30 serialize comma serialize right and we also use Chrono so we'll say use Chrono get everything from Chrono essentially okay so for claims we've defined what claims looks like uh here also for the role we'll say hash Drive and clone like capital c comma partial okay coming to the claims we have to work with three things sub which is actually the uid so two underscore owned comma we have the role which is role dot two undersource string and we have the expiration which is essentially expiration as unit size which is the type right string you size the types comma and finally as I mentioned the token will have the expiration claims and you'll have header so we'll have header is equal to header new using the hs512 algorithm and we'll encode the header the claims with the encoding key from and Source secrets jwd Secret dot map error sorry token version okay so first let's um let me actually use Json web token that basically gives us the ability to decode and code gives us the algorithm that we just used right so you we use something called as encoding and or the encode function which requires headers and claims which we have right now it is in claims the header will have the the algorithm different type of algorithms can be selected by us and then the encoding key which is directly secret we have to create that encoding key right now algorithm comma decoding key comma and coding key comma header command validation all these things we need and when I also use the fmt package and I'll need warp obviously and warp I'll have filters header headers cloned and have http header at a map column header value comma authorization and we'll have reject filter and ejection we will use this now but up until now what we've done is we have created uh enum for role I'll I'll just switch bring this out here the enum for role create the implementation for all so this shouldn't be here this should be here actually okay with the with the E number the data type and this is the information of function for role which as as I said helps us to get role which is admin and if this string is admin we'll Define role as admin which is part of the enum whole enum otherwise it's user then we have claims which has role and expiry which are the two more important fields the create durability function takes some uid and role and sends a result which is a string which in our case will be the token actually and first we create expiration with the help of Chrono Chrono package helps us create the expiration time which is 60 seconds or the token and expecting about a timestamp then you have claims which is uid role and expiration of all three and you have header header create a starting of header with the algorithm that was uh let's just do 500 in our case which has which you get from the Json web token Library and then you use the encode function so what you do essentially not sure if you use JS Json web token before but I've uh I've shown that on YouTube I think with the node.js video also and with the golang video also the way to create a GW token and you can also go to their website and try this same thing out the way to create a data token is to use some information that you will hash right so you'll create a hash from some information so you can use this algorithm and some information like header and claims and use the encode function which will use this algorithm to hash that data that you send it and you get a key from it now to Hash it you use a secret key which is in our case database Secret and we can Define it here so on top we can just go here before this you can just say we'll Define it as constants constant J interpret is is a type u8 Secret we'll also Define the better so what's this this is basically the thing that you see uh in your authorization so you say authorization right whenever you send a token in the request you see authorization and then you also say better and then the token okay so we'll see this value called authorization you'll see this Valrico better and general token a little bit secret is just the constant used for and as the encoding key to encode our header and claims and get the hash based on this algorithm and this error we have not defined it yet it will be in the error dot RS file and we'll work on that in a while okay so there's another function called with auth so if you go to your main.rs file you'll see this function being used called with auth with underscore auth and we are expecting this function to be created here okay so let's do that so we'll say public function with underscore hot let's see what it takes in so this it takes in the role so you pass in the role as user or role as admin again this role or user roller admin are coming from your enum role of user role for admin okay now that we're connecting the dots things will make sense maybe you are confused here why we're writing it like this but it all makes sense when we have uh because we had we're going in a particular order we can't do everything all at once so sometimes things end up we write we end up writing some things before they actually exist on the other file but now as we have with your um connecting all the dots everything will make sense okay so this is the function that you want to work with now function with auth and here we have role takes control and we'll implement filter extract is equal to string from error is equal to objection headers blonde dot map move headers error map header value so essentially it's just a long way of saying we're cloning the headers that you get in the uh along with the role you get you throw on the headers and you basically um you call the authorize function that's what essentially you're doing so in the authorized functions we will be passing the headers and the role okay and the authorized function is the main place where we'll write all the logic so what's happening here is when somebody hits the user out we want to because they're also sending in the token right and the login route when when they hit the login route because of the login Handler they will be able to create the um the token right so the create JWT function gets called from the auth package auth module so creatively function something that we created right now which basically creates the token for you so after you have the token that's when you call the user route right which starts with Slash user call that route when you have a token so here you're passing uh you're passing the role which is of user because you're expected to be a user if you're hitting the user out so you check if that user is is legit or not in the sense he has a right token or not if he has a right token only then you will enter this function called user Handler you have the user Handler function already it's supposed to send hello user and then the uid but to be able to reach here you need the you need to First cross this function called with auth or with auth as you've seen takes in the role which is the the user and it's going to essentially call the authorize function so in the authorized function you're going to pass the role and the headers okay so let's let's actually create that function here it's an asym function so async function authorize rule comma headers roll comma header map so you you might notice that we have to write a lot of boilerplate code like here we have to find that role is of type role and headers of type header map value here also in in the with auth function you're doing the same headers of type header map error value right all of that we're defining all of that but that's only because rust is highly uh you know has a lot of strict typing and it ensures that you don't end up creating a lot of errors so here you'll say match JWT underscore from underscore header class headers here now this function GW from header we will have to create this function as well so just write here function generally from here right so when you pass the token the jdb token in the request it goes in in the header right so you say minus H and then you say authorization then you say better and then the token right so because it's in the header you need to be able to get it out you need to be able to get out the token because that's how you will compare right match basically means comparing matching tokens only if the tokens match can we uh you know get the user to log in now the way to match is we need to uh decode the token as well right because we've encoded a token first we encoded using the encoding key use the encode function and now we'll also use in the authorize function we'll have to use the decode uh the decode function so you'll say in the decoded this is where you'll store it so decode claims Ampersand JWT comma percent decoding key from undersource Secret Ary and Source liquid comma and validation so you got to give it the algorithm with the help of which the encoding was done and you're going to decode with the same decoded hs512 so this bracket I've created here is wrong should be the round bracket dot map the error and just go here reject custom again this error we will create jwd token error okay that means there's some issue with the token and then we'll match the role if role equal to role admin so when you have these four dots right you you're saying that roll admin which is role meaning role with capital r enum and admin this role is the same as the role that we just got that was passed from the body to this function and roll from underscore string decoded dot claims dot role is not equal to role admin okay return error reject custom error no permission error yeah so if it's not an admin if the person is not admin and he's trying to access the admin route then we will say that you don't have permission to do this and that will basically be defined in the no permission error okay and we'll say okay coded dot claims dot sub here we'll handle the error we'll just return better sync eject custom header so this is your authorized function okay now coming back to this function which is the um GLD from header function which helps us get get the token from the header so here again we'll be working with those two things two two Fields or two uh two components of the token of the request body one is the authorization so whenever we pass a token right we say authorization and then then we say better and then actually the token right so we need both of those things so we'll just check for those things and then after that what comes is the token that's what we will return from this function so we'll see headers which is of type header map header value return a result which is string okay that header is equal to match errors dot get authorization if the value is matching then we'll return the value otherwise we'll just return and errors saying error is no auth header found it's no author header header right that will basically show that there was no auth header if there was a Authority it'll just return that but there was none we'll just say no auth header header and this error we will Define in the error module okay and you will um get that from header so so I'll have to import those grades so let's say use create error result okay so now I have the error create resulting with result in web result are these that we've defined here anyhow so coming back to Glory from header um so let's get the auth header which is my matching standard string from UTF 8. header dot as underscore bytes foreign otherwise again we'll return the same error which is no auth header header header and if there's no odd header that starts with better then we will return sorry then we will return error invalid auth error headers okay okay let's go header dot trim start so you're trimming the part which is the bearer part and after that is the token right so you whenever you pass token to make a request uh you say authent like I said authorization and then the uh better and then the actual token so you want to remove or trim the part to start matches with pairs all right so that's it that's that completes the auth.rs file what we'll do is we'll quickly go through everything just to make sure everything is correct and the file and then we'll wrap it up so we have pair you have 0b Secret you have the role the implementation for the role the uh yeah there's one more thing that's spending which is where we'll use this fmt package which will be in the Implement fmt display for role the right way to display the role to format it so it's format it properly which is self comma f Prime percent of mute fmt formatter now this is completely optional you don't have to do it you don't have to do this formatting I'm just doing it okay so the formatting part is complete we have claims we have with auth we have uh create JWT function we have uh authorize we have gwg from header right so quite a bit now the only thing that's left is the error.rs file to do that I will quickly create an enum for the types of errors that will have and we'll we've already used those errors in the other two files which is the main file and the auth file so we shouldn't have shouldn't have uh shouldn't be a big challenge for us now so what we'll say is say uh enum and errors so what kind of errors that I've used I've used the wrong credential error sorry the wrong credentials error I've used the GWT token error okay obviously token creation error this one I've used the no so that's the benefit with ID using a good ide is that we get these suggestions based on the errors that we already used the other is invalid auth header error and in no permission let me just also right here error wrong credentials 223 token not valid then you have awt token creation error no auth error so no error error foreign okay so what does the error response look like so what I'll say is struct and error response looks like this you have a message it's a string you have status which is a string and then in the beginning what you'll do is you'll say use so they serialize use standard convert valuable because I'll be using this and this as well so I'll just bringing them right now so that I don't have to come back here is what is obviously we'll use walk here XL http status code command rejection comma reply awesome okay now that we have everything you know the basics build we'll just Implement warp reject reject call error and now most importantly the handle rejection function so this one this function hand rejection which comes from the error module as the function that we want to create now so we'll say Pub async function handle rejection now after writing all of this code obviously we will have to so I'll just drink some water obviously we will have to turn on the rust analyzer because I'm sure we have made a lot of mistakes well that's completely all right uh this is all about working in Broad Strokes in the beginning and then figuring out how to fix the code because you don't want to break your thought process too much so just write what's coming to your mind here and then we'll fix everything we'll get into details and fix everything right now this is a very different way of working but it works really well good message is equal to if error dot is not found you will say status code not found not found Dot 2 on your Source string okay here it will say else if let sum the error dot find error and then you'll let's match the error right so if there's no error that that error does not exist so you'll say not found otherwise you'll just if there is an error you'll just match it with these ones so the first one is the wrong credentials error then you'll have the no permission error then you will have the jwd token error and then we'll have the JWT so this match function enables you to match the exact error then take um the right action based on the error now again uh this entire file which is error handling is completely optional in the sense you don't have to it if you're not building clicks production grade stuff but if you are building production grade stuff then it's it can really helpful right you don't want to build a project it doesn't have any error handling so here if I have wrong grain chills error what I want to do is I want to say status code forbidden comma e Dot do underscore string clear and Save status code on or authorized e Dot to understand string status code okay unauthorized two underscores let's go screen and for this we'll say status code internal server error done also now all of this that we are doing right now is very very basic simple code there's nothing there's no business logic here nothing that's happening that's critical it's just error handling matching the error right with the right uh with the error type and then giving the right status for it so at the end you'll say comma and status code right underscore request e dot two underscore string this is e.2 string and then after that it's if error dot find Warp checked mapper mode allowed that is underscore sum foreign underscore not underscore loud and the actual text that will be returned which is method not allowed I will be two I'll just call string so in case you don't want to build this entire file you can just copy and paste it as well not a problem like copy and paste it directly from my GitHub it's all just error handling and once you do this in this file or in this project you can we can do it in any other file also you can just copy and paste this so what's essentially Happening Here is we're matching the error with the type of error sending the particular status code like 401 500 blah blah this is 500 for example this is 401 for example right and with the message the error message right and here if there's nothing here then it's just bad request right no type of error is matching so it's a bad request and then we also uh handling for method.loud so if if method.log basically means if it's uh it was meant for post but you were trying to get right so that's method not allowed so that also we're handling out here here we'll say e print this is just very basic error handling I'm sure you already know all of this and then and then comma error here that is code internal server error on an internal server .2 underscore string then we have let Json equal to what reply Json error response status code Dot install string common message finally okay work reply with status Json command code okay so each errors has some Json message which is the Json and the code which is the status right the code has code is like 401 500 like that and the message is basically a Json Json has both of those things and cool all right so this is our error handling file and now we'll go ahead and um I'm looking for rust analyzer actually just say just come up yeah so I'll just enable it and and I get lots of errors which is nice because we will now fix them one by one all right so in the main dot RS file if you go to the login Handler function just login request needs to be one word right because that's how we created the struct and sum needs to be capital s so that fixes two small errors hopefully and now we'll just add some dependencies because those are the packages that you're using so once we add some dependencies hopefully the some of the issues should go away so here we have uh the version edition all of that and dependencies I'll just add the ones that I'm using so you can just copy and paste from my calculator file in case you want to write it on your own you can do that as well so we're just using Json retro control key or warp 30 sorry Json this error Chrome no debug sorry for profile Dev file test profile release so I've added those now and as you see now for main.rs lot of the uh almost all of the issues have gone away so it doesn't show any issues anymore all the issues that are pending are in error.rs but now again now again I can see I mean or others there are there's five issues again all right so we move that and then let's find the pending issues now in the auth.rs file there is in the pub inum role there is one comma missing put that there and here instead of fun which is FN I've written fun which is fun so when you when you save that just left the three errors here and then just four errors here right so certainly the errors have become much less with the error.rs file there are many things that are wrong so here should not have the comma should have semicolon here semicolon here and on top of that you need derive error bug out here and derive serialized bug out here so that should hopefully take care of a few issues right so now and take a look four issues are left in the add or RS file but auth and Main these two files are working completely right so this because there's dependency between these files when I fix issues here both these files are now like they're perfectly fine they don't have any issues at all you just have to find four more issues now one really small issue that I found here is that there's double colon missing and now we left with one one small issue and then the final issue is that two string the S should have been small and the other dot artist file now we see all the issues have gone away so the natural step now is to do cargo run and let's just start just one API and then we're sure everything else will work because because there are no issues and we have built it very carefully let's try at least one API okay so I will open up and let's check out if everything works as expected foreign everything's working perfectly fine now let's say uh if this score is not correct maybe because I've not tested all the other apis maybe if this is not correct you don't have to worry because I am going to be uploading the correct code which was which I showed you in the demo right even though this code is correct but like just for your peace of mind I'm going to upload the code which is um the one I showed you in demo right so it's already uploaded in GitHub feel free to take a look now you know how that code works you have a complete idea about that so we learned a lot in this video quite a lot right we understood how to use word power to create apis how to handle errors uh how to use JWT in in Rust for authorization how to encode the code how we used uh the claims the expiration and how we created the token and then the role you know how we had tools for admin and user so a lot of stuff lot of stuff in this video that we've learned I hope you learned a lot as well thank you so much for watching and do share this with your friends to share this playlist with your friends it's all free and it's um good information right thank you so much and I'll see you in the next video
