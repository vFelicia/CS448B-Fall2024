With timestamps:

00:00 - welcome to this comprehensive video
00:02 - course on graphql The Cutting Edge query
00:05 - language designed to empower your data
00:07 - retrieval needs for modern web
00:08 - applications throughout this course
00:10 - you'll learn its core principles
00:12 - explores advantages over traditional
00:14 - rest apis and gain the practical skills
00:17 - to design and Implement robust
00:19 - data-driven applications this beginner's
00:22 - course was developed by the net ninja he
00:25 - is one of the most popular graphql
00:26 - instructors on the internet so you're in
00:29 - good hands hey there gang and welcome to
00:31 - your very first graphql tutorial
00:37 - thank you
00:39 - okay then so although I do already have
00:41 - a graphql course it's about five years
00:43 - old now and I wanted to make a fresh
00:45 - up-to-date one with less bloat so that
00:48 - anyone wanting to get up and running
00:49 - with graphql quickly can do here before
00:52 - diving into more advanced tutorials and
00:54 - projects using it so in this series
00:56 - we'll be learning what graphql is and
00:59 - why we use it and then we'll build a
01:00 - graphql server from scratch using
01:02 - node.js and the Apollo server package
01:04 - we'll also look at how to make queries
01:06 - to that server using Apollo Explorer
01:09 - which is a free tool for testing
01:11 - different kinds of queries now before
01:13 - you start I would already expect you to
01:15 - have a basic understanding of node.js
01:17 - because we'll be using that to make our
01:19 - graphql server so if you want to learn
01:21 - that a little bit more first of all
01:22 - which I highly recommend then you can
01:24 - check out my node.js crash course on
01:26 - netninja Pro and also on YouTube so I'm
01:29 - going to leave a link to that course
01:30 - down below the video you're also going
01:32 - to need a recent version of node
01:34 - installed on your computer which you can
01:36 - get from nodejs.org just click on this
01:38 - download button and then go through the
01:40 - installation steps that easy and then
01:42 - finally before we start I've made course
01:44 - files for this entire series you can get
01:46 - them from this repo on GitHub graphql
01:48 - crash course the link to that is also
01:50 - going to be down below the video now
01:52 - each lesson has its own Branch so if you
01:54 - want the code for a specific lesson you
01:56 - can head to the branch drop down and
01:58 - select that branch that corresponds to
02:00 - that lesson then to download the code
02:01 - just hit the green code button and
02:03 - download a zip folder or if you prefer
02:05 - you can clone the entire repo to your
02:08 - machine
02:09 - so then let's get started by talking
02:11 - about exactly what graphql is and why
02:13 - we'd want to use it so graphql is what's
02:16 - known as a query language which is what
02:18 - the ql in the name stands for query
02:20 - language and by query language we mean a
02:23 - specific syntax that we can use to query
02:25 - a server to request or mutate data so
02:29 - it's kind of like an alternative to the
02:31 - more traditional approach of sending
02:32 - standard requests to a rest API using
02:35 - endpoints but whereas using a rest API
02:38 - is more of an architectural style an
02:41 - approach to serve and fetching data
02:43 - graphql differs in that it's an actual
02:45 - query language with its own syntax and
02:48 - rules and it still uses HTTP requests
02:51 - under the HUD like we'd normally send to
02:54 - a rest API it's just that we have this
02:56 - nice query language sitting on top of
02:59 - that to give us more flexibility and
03:01 - control about how we make them and what
03:03 - data we want to fetch or mutate and also
03:06 - the way a graphql server handles those
03:08 - requests is very different to how a
03:10 - typical rest API would handle them as
03:13 - well
03:13 - so let's take a quick look at those
03:16 - differences and see why in some cases
03:18 - graphql has the edge so when we use a
03:22 - rest API we typically send HTTP requests
03:24 - to specific endpoints like this to
03:28 - interact with a certain type of data
03:29 - right for example we might send a get
03:32 - request to this endpoint to fetch a list
03:34 - of Pokemon and we could also send a post
03:37 - request to that endpoint to add a new
03:39 - Pokemon to the data set we might send a
03:42 - get request to an endpoint like this
03:43 - with an ID on the end of it to fetch a
03:46 - single Pokemon with the ID and we might
03:48 - also send a delete or put request to
03:51 - this endpoint to delete the data or
03:53 - update it and the server would handle
03:55 - requests to those endpoints by
03:57 - connecting to a database probably where
03:59 - the data was stored and either fetching
04:01 - the data and sending it back to the
04:03 - client the browser or updating or
04:05 - deleting the data from the database
04:07 - instead so this is your traditional rest
04:10 - API and for the most part it's really
04:13 - effective and a good way to expose data
04:15 - to clients but there are sometimes some
04:17 - drawbacks when it comes to using a rest
04:19 - API when your application scales and
04:22 - your data gets a little bit more complex
04:24 - now the first drawback is something
04:26 - called over fetching
04:28 - another fetching is when we request some
04:30 - data from an end point and the server
04:32 - sends back too much data so much more
04:36 - data than we actually need for example I
04:38 - might have an endpoint which is forward
04:40 - slash courses and that gets all the
04:43 - courses so that request goes to the
04:45 - server the server gets the courses from
04:47 - the database and sends the whole list of
04:49 - them back to us in Json format now each
04:52 - course object might have a ton of
04:55 - different properties like an ID the
04:57 - title the author property which contains
05:00 - author name and the author ID maybe the
05:03 - price a thumbnail URL a description a
05:07 - video URL and so forth and it might
05:09 - actually be that in this case we only
05:12 - need the ID the title and the thumbnail
05:15 - for each one because that's all we're
05:17 - going to be showing on this particular
05:18 - page and so the rest of this data for
05:22 - each course is pretty much Obsolete and
05:24 - we don't need it for anything which
05:26 - means that we've over fetched what we do
05:28 - need so that's the first drawback of
05:30 - fetching the second drawback is the
05:33 - polar opposite under fetching and under
05:36 - fetching is when we don't get back all
05:38 - the data that we need from a single
05:40 - request and it could lead to making
05:41 - multiple requests to different endpoints
05:44 - to collate everything that we need
05:46 - together for example we might send a get
05:49 - request for a single course the server
05:51 - handles that request by getting the
05:53 - course from a database and sending it
05:55 - back in Json format and it might look
05:57 - something like this with an ID title
05:59 - thumbnail URL description the author
06:01 - property which contains the author name
06:03 - and the author ID price video URL Etc
06:06 - and in this case we need all of those
06:08 - things that's great
06:09 - so we show all of those on our course
06:11 - page on our website but we also want to
06:14 - show additional stuff on the page about
06:16 - the author of that course as well for
06:18 - example the other course is that this
06:20 - author has made and information about
06:22 - those courses such as the title the
06:24 - thumbnail the ID the price and so forth
06:26 - and we don't have all of that deeply
06:28 - nested data here in the course object
06:30 - that we got back so we've actually under
06:32 - fetched what we need in that single
06:34 - request and that could mean we now need
06:36 - to make additional requests to the
06:38 - server to different endpoints to get
06:40 - back that additional data so these are
06:43 - two potential drawbacks of using a rest
06:45 - API when your data layer gets a little
06:47 - bit more complex and these are two
06:49 - things that can easily be solved by
06:51 - using graphql instead so now let's look
06:54 - at how graphql works and how it combats
06:56 - both over fetching and under fetching so
06:59 - first of all when we send a request
07:00 - using graphql to a server we typically
07:02 - do that to a single endpoint which might
07:04 - be forward slash graphql and this is
07:07 - totally different to when we used a rest
07:08 - API where each resource typically has
07:10 - its own set of endpoints for get post
07:13 - delete and put requests Etc so whenever
07:16 - we send a query using graphql to the
07:18 - server it's always going to be sent to
07:20 - probably that single end point and then
07:22 - the server can handle it now the way
07:24 - that we send a query to the server is by
07:26 - using a special graphql syntax that
07:28 - looks something like this and we're
07:30 - going to talk more about this syntax
07:31 - later on in the course but essentially
07:33 - this syntax allows us to specify exactly
07:35 - what data and what fields we need back
07:37 - from the server so in the example from
07:39 - before if we want maybe the call courses
07:42 - data then we can send a query that looks
07:45 - something like this so we'd specify that
07:47 - we want the courses resource and for
07:49 - each course we can also specify which
07:50 - properties we want back as well so in
07:53 - this case that would be the ID the title
07:55 - and the thumbnail URL so it's send that
07:57 - query and the server would respond with
07:58 - a Json array of courses where each one
08:01 - of those courses would only have those
08:03 - properties that we need so there's
08:04 - absolutely no fetching going on there
08:06 - whatsoever which is really good the
08:08 - other thing graphql allows us to do is
08:10 - fetch nested related data within a
08:13 - single query so again for the example
08:15 - before where we needed a single course
08:16 - we'd send a query like this one and
08:19 - specify whatever properties we need from
08:20 - that course but we also said that we
08:23 - wanted extra information about the
08:25 - author of that course along with any
08:27 - related data or any related courses
08:29 - rather that author made and we can do
08:31 - that in graphql by nesting those
08:33 - properties inside the query so I can say
08:35 - get the author Name ID and then also get
08:38 - the courses of the author where for each
08:40 - course I want to get the ID the title
08:43 - and the thumbnail URL and all this is
08:45 - done in a single request or query
08:48 - so we're no longer under fetching the
08:50 - data that we need which is really cool
08:52 - and this right here is one of the really
08:54 - good things about using graphql the
08:56 - ability to Nest any related data we need
08:59 - into a single query instead of making
09:01 - multiple queries as you might do when
09:04 - you're using a rest API
09:06 - so that's the basics of why graphql
09:08 - might be beneficial to you and your
09:10 - application especially as like I said
09:12 - before you scale up the app and the data
09:15 - layer becomes a bit more complex now at
09:17 - the moment you've only seen how to
09:19 - retrieve data here and we'll look at
09:21 - this more closely later on but you can
09:24 - also perform something called mutations
09:26 - to do things like ask the graphql server
09:29 - to add new data or update it or delete
09:31 - it I'm watching the same way a post
09:33 - request might ask a rest API to add new
09:36 - data or a delete request would ask the
09:39 - server to delete some data so we're
09:41 - going to talk much more about that later
09:43 - on in the course as well so in this
09:45 - course then we'll be making a graphql
09:47 - server from scratch using node.js and a
09:50 - package called Apollo server and that
09:52 - server is going to be responsible for
09:54 - handling all the queries and mutations
09:56 - that we send to it now to send the
09:58 - queries we'll be using Apollo Explorer
10:01 - which is a graphql client that we can
10:03 - run in the browser you can kind of think
10:05 - of this as a bit like Postman but it's
10:07 - the graphql equivalent and postman by
10:10 - the way is a free tool to test out rest
10:11 - apis so you're going to learn how to set
10:14 - up a graphql server and also how to make
10:16 - queries and mutations from the front end
10:18 - using this kind of graphql syntax so my
10:22 - friends that's the introduction out of
10:24 - the way now in the next lesson we're
10:25 - going to go over the basic syntax of
10:27 - making queries
10:32 - so then before we get started actually
10:34 - making a graphql server that can handle
10:36 - all of our queries I wanted to go over
10:38 - the basics of this query language right
10:41 - here and show you how I typically
10:42 - structure these queries from the front
10:44 - end now to do this we're going to be
10:46 - using Apollo Explorer which I showed you
10:48 - briefly in the first video of the series
10:50 - an Apollo Explorer is a way for us to
10:53 - send test queries to a graphql server
10:55 - and see the responses that we get back
10:57 - from it now you might have worked with
10:59 - something called Postman before which is
11:01 - for rest apis and it's basically a
11:03 - graphql version of Postman what we're
11:05 - using here it allows us to test and sync
11:07 - queries as we would from a front-end
11:09 - application without having to actually
11:11 - build a front end so the way we're going
11:14 - to be making and sending queries from
11:15 - here is essentially the same way we'd be
11:18 - sending them from a client-side
11:20 - application like a react app for example
11:22 - so this window right here is where we're
11:25 - going to be making the queries and then
11:27 - to send them we'd press this button
11:29 - right here and the response from the
11:31 - server is going to show over on the
11:32 - right now for this lesson I'm connecting
11:35 - Apollo Explorer to a backend graphql
11:38 - server I've already made and it's the
11:40 - one that we're going to be making
11:41 - through the rest of this series but you
11:43 - can also use something called the Apollo
11:45 - sandbox which you can find on the Apollo
11:48 - docs right here I'm going to leave this
11:49 - link down below and when you open the
11:52 - sandbox it connects to a dummy graphql
11:54 - server so you can play around with
11:56 - requests without having to worry about
11:57 - making a server yourself but for now I'm
12:00 - going to go back to the Explorer
12:01 - connected to my own graphql server
12:04 - because that's more pertinent to the
12:05 - rest of this course that we're doing so
12:07 - then how do we make a query using
12:09 - graphql well first off we'd use this
12:12 - word query and then after that we can
12:13 - give our query a name if we want it for
12:15 - example I'm calling this one reviews
12:17 - query because I'm going to be fetching
12:19 - reviews from the server makes sense
12:20 - right so you can call this whatever you
12:22 - want then we open the curly braces and
12:24 - inside these we specify what data
12:26 - resource we want to get back now a
12:28 - graphql server can expose multiple
12:30 - different resources to the clients for
12:32 - example they might expose the reviews
12:34 - resource and author's resource a user's
12:37 - resource games resource Etc and we can
12:40 - specify any of those resources right
12:42 - here as our entry points for the query
12:44 - so right now we're saying we want to
12:46 - jump into the graph on this resource
12:49 - entry point in essence we want to fetch
12:52 - the reviews data to begin with now on
12:54 - its own that's not going to do much for
12:57 - us because although we've said we want
12:58 - to get the reviews data we've not
13:00 - specified which fields from each review
13:03 - that we want to retrieve now this is one
13:06 - of the major differences between graphql
13:08 - and using a rest API because when we
13:10 - send a request for a resource to a rest
13:13 - API endpoint we don't then specify which
13:16 - parts of that resource we want to get
13:17 - back we just get the whole lot back but
13:20 - in graphql we can manually choose which
13:22 - field from this resource that we want to
13:25 - fetch and the way we do that is by
13:27 - opening curly braces again and then
13:29 - writing down whatever fields we want so
13:31 - I could just say get me the rating field
13:33 - of each review and if I press send now
13:37 - I'll see the response is a bunch of
13:39 - review objects each one with just the
13:42 - rating field awesome
13:44 - now if I want more Fields I can just
13:47 - list them inside these curly braces
13:49 - right here so I could say that I want
13:51 - the content of each review and also the
13:54 - ID of each review as well and now if I
13:57 - hit send you're going to see this time I
13:59 - get back all of those fields in each
14:01 - review object so this is a really cool
14:04 - feature of graphql only getting back the
14:06 - fields from the data that we actually
14:08 - need now before we go any further I want
14:11 - to just jump to some slides to quickly
14:14 - explain from a bird's eye perspective
14:15 - how we query the graph and move around
14:18 - it to navigate data so when we make a
14:21 - graphql server or API we're making
14:24 - something called a graph right and a
14:26 - graph in visual terms is basically a
14:28 - bunch of connected data that looks
14:30 - something like this so in this case
14:32 - we've got three different data types
14:33 - we've got reviews authors and games and
14:36 - we can choose to jump into the graph at
14:38 - any point that's exposed to us by the
14:40 - server when we make a query and from
14:42 - there the graphql layout allows us to
14:45 - Traverse or walk through this graph to
14:48 - also fetch any related data to that
14:50 - starting point right so we just made a
14:53 - simple query whereby we requested all of
14:56 - the reviews data and specified which
14:58 - fields we wanted back for each review
15:00 - right
15:01 - so the reviews resource was our jumping
15:04 - in points we landed right there and from
15:07 - there I could say okay also get me the
15:10 - author of each review that I got back
15:13 - and I could also specify which fields of
15:15 - the authors that I want to get back as
15:17 - well and the query would look something
15:19 - like this and the reason I could do this
15:22 - is because when I made the graphql
15:24 - server I connected these data resources
15:28 - I said that each review was related to
15:31 - an author who wrote that review and the
15:33 - author is a separate resource and all of
15:36 - this data would be brought back from a
15:38 - single request we've only made one query
15:40 - and sent that one query to the server we
15:43 - didn't have to first get the reviews and
15:45 - then make a second request for the
15:48 - authors of each of those reviews even
15:50 - though it's a separate resource that
15:52 - we're getting right here
15:54 - another example could be that my initial
15:56 - entry point to the graph would be a
15:58 - specific game with a certain ID and the
16:01 - query for that would look something like
16:03 - this where we specify the ID of the game
16:04 - that we want as a variable now we'll
16:07 - learn more about query variables later
16:08 - on so don't worry too much about that
16:10 - for now but then having jumped in at
16:12 - these points on that game I could also
16:15 - say get me any review related to that
16:18 - game and from those reviews just get me
16:21 - the rating field and to take it one step
16:24 - further I could also say then get me the
16:27 - author of each of those reviews and just
16:30 - give me their name so you can see how
16:33 - this general idea of a graph allows us
16:35 - to initially jump in somewhere and then
16:38 - navigate between related data and fetch
16:41 - it all in a single query and that is the
16:44 - Crux of graphql so let's try one of
16:47 - these queries with nested related data
16:49 - again in Apollo Explorer
16:52 - all right so we saw before that we had
16:54 - this reviews query where we fetched all
16:56 - the reviews and we got the rating
16:57 - content and ID for each one so we got
16:59 - those back right but now we can also get
17:02 - nested content so say for example I want
17:04 - the author of each review now this
17:06 - author is actually a separate resource
17:08 - so they don't have author properties
17:10 - these reviews they're a separate
17:12 - resource but they're linked to reviews
17:14 - so the related data and we've specified
17:16 - that or I've specified that in the
17:18 - graphql server we'll see how to do that
17:20 - later on but let me just show you how we
17:21 - can fetch this stuff now so from the
17:23 - author I could get the name and the ID
17:26 - of the author we also have a verified
17:28 - property to say whether they're a
17:30 - verified author now if I click on this
17:33 - we're going to get all of the same stuff
17:35 - here plus the author details so it's
17:38 - grabbing that as well for each different
17:40 - review now we could also get the game
17:44 - associated with each of you so down here
17:47 - I could say game
17:49 - and then inside parentheses or rather
17:52 - curly braces we can say which properties
17:54 - we want back for the game so I could say
17:56 - the title of the game the price of the
17:58 - game and also the platform of the game
18:01 - and it looks here like we don't actually
18:03 - have a price property so let me get rid
18:05 - of that I mustn't have added that so let
18:08 - me just leave it with the title and
18:09 - platform press that and we can see now
18:11 - we get the title of each game and the
18:13 - platform of each game as well which is
18:15 - an array of different platforms so these
18:18 - are three separate resources author game
18:20 - and reviews but we're getting them all
18:22 - back from the same aquarium and we can
18:24 - take this one step further if we wanted
18:26 - to we could say okay well get me all the
18:29 - reviews now associated with each author
18:32 - for example so let's do it right here we
18:35 - can say we want the reviews from each
18:37 - author and from that we just want the
18:39 - rating and we want the ID of each of you
18:43 - click on that and now you can see nested
18:46 - inside the author we can see the other
18:47 - reviews
18:48 - they've done and again we can take this
18:50 - one step further we can say we also want
18:52 - the game for each one and we want the
18:54 - title for each one now this is getting a
18:56 - bit complex it probably wouldn't make a
18:58 - query this complex I just wanted to show
19:00 - you how we can work with this related
19:01 - nested data all right and how flexible
19:04 - it is that's really cool isn't it all in
19:06 - one query
19:07 - so like I said before we can also have
19:10 - mutations to add new games if we want to
19:13 - delete games or reviews whatever it
19:15 - might be to update different records so
19:18 - we're going to see all of that later on
19:20 - as well so now hopefully you can
19:22 - understand a little bit more about how
19:24 - these queries are made and how we can
19:25 - fetch related data within a single query
19:28 - now there is much more to graphql than
19:30 - making queries like this but for now I
19:32 - think that's probably enough to get us
19:33 - started I just wanted to make sure we
19:35 - all have a little bit of an
19:36 - understanding of this General syntax so
19:39 - in the next lesson we're going to start
19:40 - making our very own graphql server on
19:43 - the back end
19:44 - all right the gang so now we want to
19:46 - make a brand new graphql API and to do
19:49 - that we'll be using node.js and a
19:51 - library called Apollo server an Apollo
19:53 - server is one of many different
19:54 - libraries that you can use to easily
19:56 - spin up a graphql server and each
19:58 - library has their own kind of take on it
20:00 - but the nice thing about using Apollo
20:02 - server is that it automatically spins up
20:05 - an instance of the Apollo Explorer for
20:07 - us on localhost which we can use then to
20:10 - test out our API
20:11 - so when we use Apollo server it's going
20:14 - to create a graphql server for us that
20:17 - then allows us to easily set up resolver
20:19 - functions that can respond to incoming
20:21 - queries it also lets us easily model our
20:23 - different data types like authors blogs
20:26 - reviews
20:26 - Etc and decide how they're all connected
20:29 - on the graph by making something called
20:31 - a schema so we'll talk more about that
20:33 - in the next lesson but for now let's go
20:35 - ahead and make a new node project and
20:38 - install Apollo server alright so I'm on
20:40 - the Apollo docs right here Apollo server
20:42 - and I will leave this link down below
20:43 - just click on get started and this is
20:45 - going to show us how to make a new
20:46 - project with Apollo server so the first
20:49 - step is to make a new directory then see
20:50 - the internet and then we initialize a
20:53 - new project a new node project using npm
20:55 - we also set the type to be module and
20:57 - that allows us to use es6 modules so we
20:59 - can say import something from something
21:01 - rather than require and it also allows
21:03 - us to use top level awaits as well once
21:06 - we've done that we have to install a
21:07 - couple of dependencies graphql which is
21:10 - the meat and bones of graphql we need to
21:11 - install that but also Apollo server and
21:13 - that's the graphql library that we're
21:15 - going to use which makes it really
21:17 - easier to spin up a graphql server make
21:19 - schemas types respond to queries using
21:22 - resolver functions and all that jazz so
21:24 - it just makes working with graphql so so
21:26 - easy so we're going to install both of
21:28 - those right here now if you're using
21:30 - typescript then you can follow these
21:32 - directions we're going to be using
21:35 - JavaScript and basically we're just
21:37 - opening up the index.js file or rather
21:39 - we're making one and then opening the
21:42 - the file up and notice here we have that
21:44 - type set to module inside package.json
21:47 - as well
21:48 - so once we've done that it's all set up
21:51 - and we can go ahead and start defining
21:52 - the schema the resolver functions and
21:54 - all that stuff so to begin with let us
21:56 - go up here I'm just going to copy the
21:58 - installs
22:00 - up here so these two things so we can
22:02 - use them in our project alright so I've
22:05 - opened the terminal right here and
22:06 - navigated to this directory where I want
22:08 - to make the project then I'm going to
22:10 - say npm init and then hyphen Y and
22:13 - that's going to create our package.json
22:15 - file for us I also want to say npm PKG
22:18 - and then we want to set the type to be
22:21 - equal to module that allows us to use
22:23 - es6 modules we'll see that inside
22:25 - package.json in a second then I'm going
22:28 - to open up this director written Visual
22:30 - Studio code so codes and a space then
22:32 - full stop press enter and it's going to
22:34 - open up this project for us so inside
22:36 - package.json we can see that the type is
22:40 - module awesome okay so now we need to
22:42 - install those dependencies so open up a
22:44 - new terminal and you want to paste in
22:47 - that npm install that we grabbed from
22:49 - the Apollo docs so it should be at
22:51 - Apollo forward slash server and also
22:53 - graphql so press enter to install those
22:56 - dependencies
22:58 - all right and now that's done the next
23:00 - thing I'm going to do is create an index
23:02 - .js file and this is where we're going
23:04 - to set up our Apollo server for graphql
23:07 - so the way we do this is we first of all
23:10 - import a couple of things so I'm going
23:11 - to paste these in we import Apollo
23:13 - server from at Apollo forward slash
23:16 - server that was the package we just
23:17 - installed and then also we import this
23:20 - thing start Standalone server from ad
23:22 - Apollo forward slash server forward
23:24 - slash Standalone so basically this
23:27 - Apollo server is first to set up the
23:29 - server and configure it and tell Apollo
23:31 - how to handle all of our different types
23:33 - of data and respond to queries and
23:36 - things like that this one right here
23:37 - this is just to start up the server so
23:39 - we can start listing for requests so
23:42 - after we've imported both of those
23:43 - things I remember for this to work these
23:45 - import statements we need to be saying
23:48 - the type is module over here
23:50 - anyway after we've done that we can do
23:53 - our server setup
23:55 - so we can say const server
23:58 - is equal to new
24:01 - Apollo
24:03 - server like so so that's this thing
24:06 - right here all right like so
24:11 - and then down here I'm going to come
24:13 - back to that in a minute but down here
24:14 - I'm going to say const
24:16 - and then
24:18 - URL a destruction here is equal to a
24:21 - weight and then starts standalone
24:25 - server so that's the other thing we
24:27 - imported
24:28 - and then we pass in
24:29 - this Apollo server we just created and
24:32 - then as a second argument an object to
24:35 - say right here we want to listen to a
24:37 - particular port number so we're passing
24:39 - object as the value here and we say the
24:41 - port is four thousand and then down at
24:44 - the bottom I'll just do a little console
24:46 - log console.log and then in here I'll
24:49 - say server
24:51 - ready at Port and then it was four
24:54 - thousand Okay so we've got the basic
24:57 - setup sorted now we're using Apollo to
24:59 - create a new Apollo server and we start
25:02 - the server using this method down here
25:04 - now the Apollo server takes in an object
25:07 - as an argument and that object expects
25:10 - two properties the first is one called
25:13 - type defs which is short for type
25:15 - definitions and these are basically
25:17 - descriptions of our data types and the
25:20 - relationship they have with other data
25:22 - types so that's what we're going to be
25:25 - looking at in the next lesson but the
25:26 - other property is a resolver's property
25:28 - which is basically a bunch of resolver
25:31 - functions that determine how we respond
25:33 - to queries for different data on the
25:35 - graph so in the next lesson we're going
25:37 - to look at that first property type Deft
25:40 - and we're going to make up our own
25:41 - schema
25:44 - all right then my friends so now we're
25:46 - going to make some type definitions and
25:49 - then later on as well some resolver
25:50 - functions which we can then pass into
25:52 - the Apollo server so it can do its magic
25:54 - with them so let's start with the type
25:57 - defs what are type defs well type defs
26:00 - are definitions of the different types
26:02 - of data we want to expose on our graph
26:04 - for example we might make a type def for
26:07 - an author data type and specify the
26:09 - different fields that author might have
26:12 - like a name an avatar URL a bio Etc and
26:15 - we might have one for a game which is a
26:18 - title a price a platform Etc so these
26:20 - would be the different types of data
26:22 - that we want to make available on the
26:23 - graph that a user can then eventually
26:25 - query
26:27 - and the combination of all of these
26:29 - different types and the relationship to
26:31 - other types and the kinds of queries
26:34 - that can be made combine up to make
26:36 - something called a schema so the schema
26:39 - is something that describes the shape of
26:41 - the graph and the data available on it
26:44 - and normally your graphqbal schema the
26:47 - data that's available on the graph will
26:49 - be fairly similar to the data you're
26:51 - storing in your application database now
26:53 - it can be different they don't have to
26:54 - fully match or anything because graphql
26:57 - is a layer between your database and
26:59 - client-side queries but generally
27:01 - speaking the schema will probably look
27:03 - fairly similar to the kind of data that
27:05 - you have in your database so let's try
27:08 - making a schema then with a few
27:09 - different types of data that we want to
27:11 - add to the graph now to do this I'm
27:13 - going to make a new file called
27:15 - schema.js and inside this is where I'm
27:18 - going to Define all of my different
27:20 - types of data now before we do anything
27:23 - inside here I want to show you a package
27:25 - I've got installed so just typing up
27:27 - here graphql and it's this one graphql
27:29 - syntax highlighting so what this does is
27:32 - it allows us to have syntax highlighting
27:35 - for our different types in our schema
27:37 - because without this we wouldn't get
27:38 - that so if we scroll down it might show
27:40 - you an example you can see
27:43 - down here
27:45 - if we keep on going this is how we're
27:47 - going to be using it using a template
27:48 - string and then we start the template
27:51 - string with hash graphql and if we do
27:53 - that when we're making our types inside
27:55 - that template string we're going to get
27:57 - syntax highlighting on them so
27:58 - definitely install this package first of
28:01 - all or a similar one
28:03 - then if we go back to the schema file
28:05 - the way we're going to do this is by
28:06 - first of all exporting a constant
28:08 - because we're going to use this schema
28:10 - inside this index file over here so we
28:12 - need to import it later so make sure you
28:14 - export it first we'll call this type
28:16 - defs and we set this equal to a template
28:19 - string and like we just saw we started
28:22 - with hash graphql and notice when I
28:24 - press L now it goes green to Signal we
28:27 - are going to get syntax highlighting for
28:29 - this now inside here we're going to
28:31 - Define our different types and built
28:34 - into graphql there are five basic scalar
28:37 - types that we can use so they are ins
28:40 - which are just basically whole numbers
28:42 - floats which are decimal numbers we have
28:45 - strings we have Boolean types and also
28:49 - we have a special ID type as well now
28:52 - the ID type is something that graphql
28:55 - uses as a key for data objects now the
28:58 - basically serialized as strings and
29:00 - that's how we're going to declare the
29:02 - IDS in our data when we make it later
29:04 - but they are their own unique type in
29:07 - graphql
29:08 - and these five types right here are
29:10 - going to be the ones you find yourself
29:11 - using pretty much 99 of the time you can
29:14 - make your own types to build on top of
29:15 - this and use them which we'll see kind
29:17 - of later on but yeah these are the types
29:19 - we're going to be using so let's delete
29:21 - that and then go up here now we want to
29:24 - make different data types for our
29:26 - different types of data that we're going
29:28 - to have later on now we're going to have
29:30 - three types of data we're going to have
29:31 - game objects we're going to have review
29:33 - objects and also auth objects so they're
29:36 - the three different types we need to
29:38 - Define inside this template string now
29:40 - the way we make a type is by saying type
29:42 - first of all then the name of the type
29:45 - so we'll start with game and then inside
29:48 - here we'll Define the different
29:50 - properties that a game data type should
29:52 - have so it should have an ID property
29:54 - and then we do a colon and we say what
29:57 - data type is that using the five
29:59 - different types that we just saw well
30:01 - this is going to be of type ID
30:05 - then the second property is going to be
30:07 - a title because every game needs a title
30:09 - that's going to be a string and then the
30:12 - third one will be a platform now that
30:15 - could be a string as well however it
30:17 - might have multiple platforms so ideally
30:19 - we want this to be an array of strings
30:22 - and we can say that something is an
30:24 - array of a certain type by just putting
30:25 - square brackets around it so now we're
30:27 - saying the type of this property should
30:28 - be an array of strings
30:30 - all right so at the beginning if we were
30:33 - to make a new game using this type later
30:36 - on there's nothing to say that these are
30:38 - required Fields now we can make a field
30:41 - required by adding on the exclamation
30:43 - mark at the end of something if we don't
30:45 - have that then we're basically saying
30:47 - this is allowed to be null if we have
30:50 - the exclamation mark we're saying it's
30:52 - not allowed to be null so I want all of
30:54 - these to be required so this one this
30:56 - one and also this one now right here
31:00 - this exclamation mark is outside of the
31:02 - square brackets meaning we must have a
31:05 - value for platform which is an array of
31:07 - strings but the arrays sorry the
31:10 - elements inside that array can be
31:12 - nullable at the minute because we don't
31:13 - have an exclamation mark after this so
31:16 - we need it there as well to say that
31:17 - this string can't be nullable all right
31:19 - so we need two here one at the end of
31:21 - the entire value type and then one for
31:24 - the type inside the array as well
31:27 - okay so that's the first type done let's
31:29 - do another one I'm going to say type or
31:32 - review this time and then inside here we
31:35 - also want an ID which is of type ID
31:38 - required and then we also need the
31:42 - second property and by the way you don't
31:43 - need
31:45 - commas here
31:46 - the second property inside the review
31:48 - which is going to be the rating and
31:51 - that's going to be an integer also
31:52 - required and then the third one will be
31:55 - the content of the review and that is
31:57 - going to be a string also required so
32:00 - that's the second type the third one is
32:02 - author so type author
32:05 - and inside here again we need an ID
32:09 - which is required we also need a name
32:12 - for the author which is a string also
32:15 - required and get rid of the commas this
32:17 - is just habit and then the third one is
32:20 - going to be the verified property
32:23 - and that is going to be a Boolean and
32:25 - this is just basically to say whether an
32:27 - author is verified on a sign we don't
32:29 - need that I just want to demonstrate the
32:31 - different types that we can use okay
32:33 - then so now we've made three different
32:35 - types Game author and review now there's
32:37 - one more special tag that we need to
32:39 - make and that's the type we're going to
32:40 - call query now the query type is
32:43 - something that every graphql schema that
32:45 - you make needs to have it's not optional
32:47 - and its job is to define the entry
32:49 - points to the graph and specify the
32:51 - return types of those entry points so
32:53 - for example if I want users to be able
32:55 - to query the review data that we have
32:57 - and get back a list of reviews then I
33:00 - need to specify that inside this query
33:02 - type so I could make a field called
33:05 - reviews and then tell graphql that we
33:08 - expect the return type of this entry
33:10 - point to be a list of reviews and now if
33:14 - we left the query type like this we're
33:16 - essentially saying we only want to
33:17 - expose that one single entry point to
33:20 - the graph meaning a user would only be
33:22 - able to enter the graph at this point
33:24 - and then they'd be free to navigate
33:26 - around the graph to eventually get
33:28 - related data but they wouldn't be able
33:30 - to jump in at any other point whether
33:32 - that be a single review instead of a
33:34 - list of reviews or an author or game
33:37 - because we've not specified those entry
33:40 - points right here so this query type is
33:42 - our way of gatekeeping Entry onto the
33:45 - graph if you like and deciding where a
33:47 - user can jump into it initially so let's
33:50 - make some more entry points for our
33:52 - users so after reviews we shall say
33:55 - games and when a user lands on this when
33:59 - they request all the games we're going
34:01 - to send back a list of Game objects and
34:04 - the final one for now is going to be
34:05 - authors and same again it's going to be
34:08 - a list this time of auth objects now
34:10 - eventually we're going to allow Landing
34:12 - points for single reviews single authors
34:14 - and single games at the minute we're
34:16 - just allowing the user to land on a list
34:18 - of reviews to grab them all we'll see
34:21 - how to land on a single one later on so
34:24 - then now we've defined our types and
34:26 - we've also made a query type to say
34:28 - where a user can essentially land on the
34:31 - graph or where queries can start from
34:33 - the next thing we need to do is pass all
34:36 - these type definitions into the Apollo
34:38 - server that we made in the previous
34:40 - lesson so first off make sure these type
34:43 - defs are exported from this file so that
34:45 - we can then go ahead and import them in
34:47 - the index file somewhere near the top so
34:50 - do that first of all and then once
34:52 - you've done that we can then pass them
34:54 - into the Apollo server that we created
34:57 - as the first argument so that Apollo
34:59 - server knows about our different types
35:02 - and query entry points and I just said
35:05 - as our first argument I meant the first
35:06 - property in the object argument
35:09 - but anyway that's our first step
35:11 - completed making our type defs to map
35:14 - out what the graph looks like I also
35:17 - said that we need to pass another
35:18 - property into this Apollo server and
35:20 - that was a resolver's object which
35:22 - basically contains a bunch of resolver
35:24 - functions and the resolver functions are
35:26 - there for us to handle any incoming
35:28 - requests and return data to the client
35:30 - because at the moment all we've done is
35:32 - Define what the graph looks like in
35:34 - terms of the data types that we have and
35:36 - the entry points but we've not yet said
35:38 - how we want to handle requests or
35:40 - queries for that data and that's what
35:43 - the resolver functions are for so you
35:46 - can kind of think of the schema and the
35:48 - type definitions that we set up as like
35:50 - a map for Apollo to structure the graph
35:53 - but they don't actually handle any
35:55 - queries and then we make resolver
35:57 - functions to handle the queries based on
36:00 - our schema and type so I hope that makes
36:01 - sense so in the next lesson we're going
36:04 - to take a look at that and we're going
36:05 - to try making some resolvers for the
36:07 - different types of data that we're
36:09 - making available we're also going to set
36:11 - up some domain local data that we can
36:13 - use on the server as well so that we've
36:14 - got something to send back to the client
36:16 - so that's coming in the next lesson
36:21 - right then so in the last lesson we made
36:23 - our type definitions to describe the
36:25 - data on the graph and also specify the
36:28 - entry points to the graph using the
36:30 - special query type and we pass those
36:32 - into the Apollo server so it knows how
36:34 - to set the graph up next up we need to
36:37 - make some resolver functions which allow
36:39 - us to decide how we respond two queries
36:41 - to the graph so it might be that if a
36:44 - query comes in for all the games then we
36:46 - could maybe fetch all the games records
36:48 - from a database and return those as a
36:50 - response now in our case we don't have a
36:52 - database setup for this and instead I'm
36:54 - just going to use some local data stored
36:56 - in a variable in another file but you
36:59 - could quite easily hook this up to
37:00 - whatever database you prefer and work
37:02 - with that data instead so for now what
37:04 - I'm doing is making a new file called
37:06 - underscore db.js which stands for
37:08 - database and this underscore thing isn't
37:10 - necessary it's just a little naming
37:12 - convention I sometimes use when I'm
37:14 - making a data file but anyway inside
37:16 - this file I'm going to paste in a bunch
37:18 - of data which is essentially just three
37:20 - arrays stored in variables one array for
37:23 - the reviews one for the games and one
37:25 - for the authors and we can see the
37:27 - different properties that these objects
37:29 - inside the arrays have are the same ones
37:31 - that we defined in the types that we
37:33 - made in the last lesson the only
37:35 - difference is that the reviews objects
37:38 - we have a game ID property and also an
37:41 - author ID property and this is for later
37:43 - when we start to talk about how data is
37:46 - related but the rest of the properties
37:48 - match up to the ones that we defined in
37:50 - our different types
37:52 - so if you want to grab this data as well
37:54 - you can do it's all up on my repo I'm
37:57 - going to leave the exact link to that
37:59 - file to grab this data down below the
38:01 - video anyway now we have our data let's
38:04 - start making some resolver functions for
38:06 - the three entry points that we defined
38:08 - in our query type because we need to
38:10 - send a response for queries to each of
38:13 - those so then to make our resolver
38:16 - functions we'll first make a new
38:18 - constant called resolvers and then we're
38:20 - going to set that equal to an object and
38:23 - inside this we can make resolver
38:24 - functions for each different type that
38:26 - we defined now to begin with we want to
38:28 - make resolver functions for the query
38:30 - type because that root query type is
38:32 - where we Define entry points to the
38:34 - graph and specify what data should be
38:36 - returned for them we'll also be making
38:38 - resolver functions for other types later
38:40 - on as well like the review type and
38:42 - author type when we start talking about
38:44 - related nested data but for now we just
38:48 - want to make resolver functions for
38:50 - every field defined in the root query
38:52 - type
38:53 - so that's one for reviews one for games
38:55 - and one for authors and to do that we
38:58 - make a property called query capital Q
39:00 - which matches exactly the type name and
39:03 - this property is going to be an object
39:05 - as well and now we can Define in this
39:07 - object resolver functions for each of
39:09 - the properties defined on our root query
39:12 - type
39:13 - so the way this is going to work is that
39:15 - we need basically a resolver function
39:17 - for reviews called reviews one for games
39:19 - called games and one for authors called
39:21 - authors and the names need to match so
39:24 - if we go over here our first one is
39:26 - going to be for games and then this is a
39:28 - function which returns some data and
39:31 - basically we want to return the data to
39:34 - a user that they've requested now
39:36 - they've requested games so we need to
39:38 - send back an array of game objects now
39:41 - in order to do this we need access to
39:43 - this DB file so let me import that at
39:45 - the top I'm going to come to the top and
39:47 - say DB and then just paste in this
39:50 - import so import DB from dot forward
39:52 - slash underscore db.js and then down
39:55 - here we can use this to say DB Dot and
39:58 - then whatever the property is down here
39:59 - so we've got games authors and reviews
40:01 - that match up to this data so what you
40:03 - want to send back DB dot games and
40:07 - that's all there is to it we're sending
40:08 - back the array of games
40:10 - now remember when a user makes a query
40:13 - they can do so like this so let me just
40:15 - do
40:16 - some
40:18 - comments like this
40:20 - and if they make a query
40:22 - they might make a query that looks like
40:25 - this games
40:27 - and then inside here they want specific
40:29 - properties like just the title now if
40:32 - we're returning the full array right
40:34 - here you'd think well we're returning
40:36 - the ID the title the platform as well
40:38 - however Apollo handles that for us all
40:42 - it needs to know is where to grab the
40:45 - data and then if we're just requesting
40:47 - the title from each of the games it will
40:50 - do its magic on this data to take out
40:52 - any of the other stuff like the platform
40:54 - and the ID and it will just return the
40:57 - title property for each one so we don't
40:59 - have to worry about which fields are
41:01 - returned
41:03 - Apollo server is going to do that for us
41:05 - okay which is really cool so let's get
41:07 - rid of that that's the first resolver
41:09 - function done that's simple so the
41:12 - second one is going to be for reviews
41:14 - let's do that come back to index and
41:17 - we'll say
41:19 - reviews
41:21 - and this is also a function
41:23 - we need to return
41:25 - DB dot reviews and then the final one is
41:30 - going to be for authors so let's do that
41:32 - authors
41:34 - and then inside here we need to return
41:37 - DB
41:38 - dot authors all right and that's it
41:41 - we've made our three now basic resolver
41:44 - functions
41:46 - for this data over here and that's
41:48 - pretty much all we need to do so
41:51 - before this works we need to pass this
41:53 - resolvers object into here as the second
41:56 - property on this argument so let's do
41:58 - that we'll say resolvers
42:02 - and that's it
42:03 - so now what we want to do is start up
42:06 - this server so that we can test it from
42:08 - the front end so let me do that by
42:10 - opening up the terminal and if you've
42:14 - got node one installed you could type
42:16 - node Mon and then the name of the file
42:18 - which is what I'm going to do and
42:19 - basically what node mod does is it
42:22 - restarts the server every time you make
42:23 - a change to the server otherwise if
42:25 - you're just using node and then the file
42:27 - name you need to manually cancel the
42:29 - server every time you make a change and
42:30 - rerun it to pick up that change so we're
42:32 - going to say nerdman and then the name
42:34 - of the file we want to run which is
42:35 - index and hopefully oops
42:38 - we get an error so what's the error
42:41 - so refuse did you mean review let me
42:45 - have a look at this
42:47 - so we've got reviews down here let's go
42:50 - to schema oops there it is okay so this
42:54 - shouldn't be plural because it's a
42:56 - singular type Insider list all right so
42:59 - save that
43:00 - and now hopefully this is gonna work
43:04 - I'm going to cancel out this process and
43:06 - run it again
43:07 - and okay the app crashed again we have
43:10 - another error so let's have a look what
43:12 - this one is okay address is already in
43:15 - use okay so that's because I've got
43:17 - another instance of a graphql server up
43:20 - and running so let me just close that
43:21 - down first of all okay so I've just done
43:23 - that I'm going to cancel out of this
43:24 - again and try running it third time
43:27 - hopefully this is going to work now Okay
43:28 - cool so now the server is ready at Port
43:31 - 4000 awesome all right so now if you
43:34 - visit localhost Port 4000 in the browser
43:36 - you're gonna see Apollo Explorer so it
43:39 - automatically spins this up for us so we
43:41 - can test out our graphql server and let
43:44 - me just take you on a quick tour of this
43:46 - first of all if you go to schema then
43:48 - you're going to see the different
43:49 - queries that we can currently make so
43:51 - you can see it's looked at our code and
43:54 - it's seen the different queries we can
43:55 - make the different entry points our
43:57 - authors games and reviews right here and
44:00 - it also shows the data type so if we
44:02 - click on this it's going to show the
44:04 - different fields that that data type has
44:06 - and it shows what we can base get back
44:08 - all right so we have those three data
44:11 - types right here also if we look at
44:14 - scalar types it's going to come down
44:15 - here show us the different things we're
44:16 - using directives okay we don't really
44:19 - need to worry about directors for now if
44:21 - you go back to Explorer this panel on
44:23 - the left is where we're going to make
44:24 - the queries this is where we're going to
44:25 - get the response down here you might see
44:27 - another panel as well this is for
44:28 - variables which we're going to look at
44:30 - later on so let's make our first query
44:33 - you can name this something different if
44:34 - you want so I could say something like
44:36 - games query to get the games you don't
44:39 - have to name it that it doesn't really
44:40 - matter what it's called
44:42 - but now I want to get the games so I can
44:45 - click on that and remember we have to
44:47 - open up our curly braces and specify
44:49 - What fields we want from this particular
44:52 - resource so I could say that I want the
44:54 - title of each game and also the platform
44:57 - of each game so now if I click on this
45:01 - we can see we get an array of all the
45:03 - games inside a data object so we have
45:05 - this one the title and the platform
45:07 - title and platform and so forth so we're
45:10 - getting all of the games awesome
45:11 - all right so let's change this to
45:14 - something else let's try the authors
45:16 - and from each one we want the name and
45:19 - we also want the verified
45:21 - status
45:23 - click on this and it's going to fetch
45:25 - those for us Mario verified true Yoshi
45:27 - Falls Peach true awesome final one let
45:30 - us try the other resource which is
45:32 - reviews and then from here we can get
45:34 - for example the ID the rating and the
45:38 - content I'm going to click on this and
45:40 - we can see all those reviews now like I
45:42 - said you can just request some of the
45:46 - field so I could get rid of content and
45:47 - I could get rid of ID and just say that
45:50 - I want the rating click on this and now
45:52 - it still fetches all the reviews but we
45:54 - only get that rating property so we're
45:56 - not over fetching which is awesome so
45:58 - even though we explicitly return the
46:00 - full array of data Apollo is using our
46:02 - resolver function and the data we return
46:04 - to automatically filter out any of the
46:07 - fields the user doesn't need which is
46:09 - awesome so this is all working now but
46:12 - what if we wanted to fetch just a single
46:15 - review or a single author or a single
46:17 - game well for that we need to use
46:19 - something called query variables and
46:21 - we'll talk about those in the next
46:22 - lesson
46:25 - all right then gang so now we have some
46:28 - type definitions which describe the data
46:30 - we have on the graph and also specify
46:32 - the entry points to the graph which are
46:34 - to query all the reviews all the games
46:36 - and all the authors and we also have
46:38 - resolver functions for each of those
46:40 - queries too which return the data so it
46:43 - can be sent to the client but what if a
46:45 - user just wants to send a query for a
46:47 - single review or a single author or a
46:49 - single game well currently that wouldn't
46:51 - work for two reasons first we don't
46:54 - specify that a user can enter the graph
46:56 - in that way in the root query the only
46:59 - three entry points that we have are
47:01 - queries for other reviews all the games
47:03 - or all the authors and secondly we don't
47:06 - have any resolver functions to handle
47:07 - queries for single items we only have
47:10 - them to match these three entry points
47:12 - for lists of data so we need to address
47:15 - both of those things starting with this
47:17 - root query type
47:19 - and the way we do that is by just adding
47:20 - more entry points to the graph so
47:24 - underneath reviews I'm going to make
47:26 - another query available called review
47:28 - singular for a user to fetch a single
47:31 - review and that query is going to return
47:33 - a single review object now we need to
47:36 - add one more thing to this and that's a
47:38 - query variable to say that when a user
47:41 - makes this query we expect them to send
47:43 - a variable along with it as well and
47:46 - that variable would be the ID of the
47:48 - review that they want to fetch because
47:49 - we need the ID to find the review in our
47:51 - data in order to send it back to them so
47:54 - to do that we just add parentheses after
47:57 - the query name and then we can add a
47:59 - variable name which I'm going to call ID
48:01 - and we also need to specify the type of
48:03 - this variable that we expect as well
48:05 - which is going to be the ID type and
48:07 - finally we want to say that this
48:09 - variable is required when someone makes
48:11 - this query so it can't be null
48:13 - and we know to do that we can just add
48:15 - the exclamation mark at the end of it so
48:17 - now we're seeing a user can make an
48:19 - initial query for a single review but
48:21 - they must pass in this variable to the
48:24 - query which must be an ID so now we just
48:27 - need to make a resolver function for
48:29 - this query as well so back in the index
48:31 - file we can add a new function inside
48:33 - the query property of the resolvers
48:35 - object and that function is going to be
48:37 - called review singular again and inside
48:40 - this function we basically need to
48:42 - return a single review based on the ID
48:44 - variable that a user passes into the
48:46 - query so how do we get that ID in this
48:48 - resolver function well we automatically
48:51 - get three arguments available to us in
48:53 - these functions that we can use the
48:55 - first one is something called appearance
48:56 - which refers to the parent resolver in a
48:59 - resolver chain that probably doesn't
49:01 - make much sense at the minute but
49:03 - hopefully it will do later on when we
49:05 - start working with related data and
49:07 - nested queries I'm going to rename this
49:09 - first one to underscore because we don't
49:11 - need that in this function the second
49:13 - one which we do need is called args
49:16 - which stands for arguments and it's on
49:18 - here that we can access any query
49:20 - variable since with the query the third
49:22 - one is a context object which we can use
49:24 - for supplying context values across all
49:26 - of our resolvers such as authentication
49:29 - information or something like that but
49:31 - we don't need that third argument right
49:32 - now
49:33 - so we can get any query variables that a
49:36 - user sends in the query from this args
49:39 - object and what we want is the ID
49:41 - variable so we can just say
49:44 - args.id to get that and we can use the
49:48 - ID now to find whatever review has the
49:51 - ID in our data and then return it so the
49:53 - way I'm going to do this is by just
49:55 - taking db.reviews again
49:57 - and then I'm going to use the find
49:59 - method to find a single review so this
50:02 - find method basically finds a function
50:04 - for every item inside the reviews array
50:06 - and for each item we can take in a
50:10 - review as an argument so if we go back
50:12 - to the data if we're cycling through
50:15 - this
50:16 - it will refer to this first then this
50:18 - then this then this okay so each time we
50:21 - cycle through one of these items we can
50:23 - check the ID property of it now if the
50:26 - ID property matches the ID on this
50:28 - argument then we want to return true
50:31 - inside this function and when we return
50:33 - true
50:34 - it no longer needs to cycle through the
50:37 - rest of the array and it just returns
50:38 - that value for us right here okay so we
50:42 - need to say
50:43 - get the review dot ID and see if it's
50:46 - triple equal to args.id so when that is
50:50 - true that is the review that we want to
50:53 - return to the user hope that makes sense
50:56 - and that's pretty much all there is to
50:58 - it so now we can save this and test it
51:00 - out in the browser okay so how do we
51:02 - actually send a query variable from the
51:04 - front end when we're making a query well
51:07 - first of all after the query name we can
51:09 - use parentheses to declare any variables
51:12 - that can be passed into this query as a
51:14 - whole now that can be multiple variables
51:16 - in the future but for now it's just
51:18 - going to be one variable the ID and if
51:21 - you were using something like react to
51:23 - make this query you could pass those
51:24 - variables into the whole query from a
51:27 - react component and then within the
51:29 - query we can use those variables for
51:31 - different parts of the query so first of
51:34 - all let's declare what variables can be
51:36 - passed into the query as a whole so
51:38 - inside parentheses we declare each
51:40 - variable that can be passed in using a
51:42 - dollar sign and then the variable name
51:44 - so we can say dollar sign and then ID
51:46 - and then after that we use a colon and
51:49 - specify what type of data this variable
51:51 - should be in our case that's the ID type
51:54 - for all intents and purposes it's going
51:56 - to be a string that we pass in but it's
51:58 - an ID type
52:00 - now in order to pass that variable into
52:02 - the query from Apollo sandbox you can
52:05 - come down here to the bottom and select
52:07 - variables and then you can make a Json
52:10 - object of key value pairs one for each
52:13 - variable so we can add the ID one and
52:16 - set it to be one in quotations so now
52:19 - these variables are going to get passed
52:21 - into the query and populate the
52:22 - arguments inside the parentheses right
52:24 - up here so this variable will now have
52:27 - the value that we passed in from down
52:29 - here and we can use that variable when
52:32 - we request a single review inside this
52:34 - query so let's do that let's ask for a
52:38 - single review and then passing the ID of
52:41 - the review that we want to find so we
52:44 - can say ID is equal to the ID variable
52:47 - which in turn is equal to one and that's
52:51 - all we have to do to say that we want
52:53 - that one single review
52:55 - we can also specify which fields we want
52:58 - back as well though for example the
52:59 - rating and also the content properties
53:02 - so now we're asking for one single
53:05 - review with the ID of one and we just
53:06 - want these two fields for that review
53:08 - and if we hit send we should see the
53:10 - response from the server which contains
53:12 - that review and inside it the two fields
53:15 - that we asked for awesome so that's how
53:17 - we use Query variables from the front
53:19 - end now let's try and do something
53:21 - similar for the other two data types
53:23 - that we've got
53:24 - or rather than so back in a schema let's
53:27 - define our different entry points so
53:28 - underneath games I'm going to do a
53:31 - single one so game and that's going to
53:33 - return a single game object now again we
53:35 - need to declare that this needs an ID
53:39 - argument or variable which is of type ID
53:42 - and that's required and same for this
53:44 - down here author
53:46 - and again we need to define the query
53:48 - variable which is of type ID and
53:50 - required and that returns a single
53:53 - author so that's the schema done back
53:55 - over in index we need to basically do
53:58 - the same thing for author and game that
54:00 - we did for review so I'm just going to
54:03 - copy this and I'm going to paste it up
54:05 - here
54:06 - change the name of this to game and we
54:09 - still need the args the whole logic is
54:11 - the same however we just need to rename
54:14 - this to game and this to game as well so
54:16 - we're basically returning the game where
54:18 - the IDS match and then down here we need
54:22 - a comma first of all
54:24 - and we have authors so let's paste this
54:27 - in again do a comma change this to
54:29 - author singular
54:31 - and we'll change this to author and
54:34 - change this to author and also we need
54:37 - to change this one right here because we
54:38 - want to look inside the games array and
54:40 - this one should be the author's array I
54:43 - think that's pretty much it so now they
54:45 - should all work for the other two types
54:46 - as well but let's check it out in Apollo
54:48 - Explorer so let's give this a whirl I'm
54:51 - not going to change the name because it
54:53 - doesn't really matter but we're always
54:54 - still passing in the ID and we'll just
54:56 - pass in one it doesn't have to change I
54:58 - mean we'll change it to two just to have
54:59 - a look and then this time instead of
55:02 - review in fact let's try and review
55:03 - first of all to see if we can get a
55:05 - different one back which we do okay now
55:08 - let's change this to game with the ID of
55:11 - two now we need different fields for the
55:13 - game I think we have a title and also a
55:16 - platform I'm also going to return the ID
55:17 - just to make sure it's getting the
55:18 - correct one and we can see the ideas too
55:21 - the title and also the platforms uh
55:24 - let's try a different one so we'll say
55:26 - three here
55:28 - send that okay yeah that works and then
55:31 - finally let's try the authors so
55:34 - singular author
55:36 - I'm gonna go back to one and we want the
55:39 - name and we'll also
55:43 - get the verified status that's it
55:45 - verified like so and the ID
55:48 - press this send button and we can see
55:50 - this works as well let's change the
55:51 - variable to two
55:53 - and yeah it brings back the Yoshi one
55:56 - the different one awesome so this is all
55:58 - working now that's how we can send query
56:00 - variables in our queries
56:04 - all right then so things are starting to
56:06 - take shape now we can query lists of
56:07 - data and also we can query single data
56:09 - items as well using query variables and
56:12 - now I want to take this one step further
56:13 - and talk about related data in graphql
56:16 - so if we open up the DB data file and
56:18 - look at the reviews data we can see that
56:20 - each of you has an auth ID property and
56:22 - also a game ID property and that's the
56:24 - way in our data we're relating these
56:27 - different things so that every review
56:28 - has an Associated author an Associated
56:31 - game as well so if I was to pluck out a
56:34 - random review I would then be able to
56:36 - try and find the author and the game
56:39 - associated with that review and likewise
56:41 - if I was to pick out a random game I
56:43 - could look at the ID of that game and
56:45 - then run through the reviews array to
56:47 - find any review where the game ID
56:49 - matches that meaning I could pick out
56:50 - all the reviews associated with a single
56:53 - game now that's how this looks on the
56:56 - data side of things but currently in our
56:57 - schema we don't really Define any
56:59 - relationships between the data so when
57:02 - Apollo makes our graph based on this
57:03 - schema it won't know that every game has
57:06 - a list of related reviews at the moment
57:08 - and that every review has a related
57:11 - author and game and also that every
57:13 - author has a list of reviews that they
57:15 - wrote so we need a way of defining those
57:18 - relationships in our schema so that
57:20 - Apollo knows to make our graph that way
57:22 - with those relationships alright so
57:25 - let's start with the review type right
57:26 - here so we know that every review is
57:29 - associated with a game and an author so
57:32 - I could say that the game is going to be
57:34 - of type game like so and that's required
57:37 - right because we can't have a review for
57:39 - no game that's not going to exist also
57:42 - we have the author
57:45 - property which is going to be of type
57:47 - auth again required because every review
57:49 - needs an author alright so down here
57:53 - every game is going to have a list of
57:56 - reviews so we'll say reviews
58:00 - it's a list so square brackets and then
58:03 - inside the type is review now the types
58:07 - inside this can't be nullable the data
58:10 - inside it so we need exclamation mark
58:12 - right here but that's not to say that we
58:14 - have to have reviews we're not going to
58:16 - put exclamation mark right here this can
58:18 - be nullable as a whole if the game
58:20 - doesn't have any reviews but if we have
58:23 - some data inside this list it has to be
58:25 - a tight review that is required it can't
58:27 - be null okay
58:29 - so same down here for the author let's
58:31 - say the reviews by this author
58:34 - are going to be a list of review objects
58:36 - again exclamation mark but none at the
58:38 - end because there can be authors that
58:40 - haven't written any reviews yet all
58:42 - right okay so now we've made those
58:44 - connections in our different types we
58:46 - also need to make some resolver
58:47 - functions to resolve any nested queries
58:49 - for the related data for example I might
58:52 - query it for a single game and then make
58:55 - a nested query for all the reviews for
58:57 - that game and that query would look
58:59 - something like this where the initial
59:01 - jumping in point is for a single game
59:03 - but then we also ask for the reviews
59:05 - related to that game along with the
59:07 - rating and content for each review so at
59:10 - the moment Apollo doesn't really know
59:12 - how to handle that nested query for the
59:14 - reviews inside a specific game the only
59:17 - way it knows how to resolve reviews
59:19 - currently is either by grabbing all of
59:21 - them or just by grabbing one of them
59:23 - based on the ID and these are both root
59:26 - queries defined in the query type in our
59:28 - schema so it doesn't know how to get a
59:31 - subset of reviews based on the ID of a
59:33 - particular game we don't have a resolver
59:36 - for that so the way we make this
59:37 - resolver is not by making it inside this
59:40 - query object because these are resolvers
59:43 - for entry points to the graph as defined
59:46 - by the query type that we made in the
59:48 - schema
59:49 - so instead because this nested request
59:52 - is associated with a game object we make
59:55 - a new property inside the resolvers
59:57 - object called game which is also an
60:00 - object and then inside this we can make
60:02 - a resolver function called reviews where
60:05 - we can tell Apollo how to get all the
60:07 - reviews based on the pair inquiry for
60:10 - the single game
60:12 - so I'm going to make a function called
60:14 - reviews to do this and it's going to
60:16 - take in that first argument called
60:18 - parents now remember I mentioned this
60:20 - one in a previous video but we didn't
60:23 - need it back then however now we do need
60:25 - it so the way this is going to work is
60:27 - because our entry point for the query is
60:29 - a single game Apollo will run that
60:32 - initial resolver function inside the
60:34 - query object to get that single game
60:36 - then to resolve the reviews for that
60:39 - game it's going to look to the game
60:41 - object since that's what we just grabbed
60:44 - right again and then it's going to look
60:46 - for the reviews resolver inside that to
60:49 - grab the reviews
60:50 - so it's inside this function that we
60:54 - tell Apollo how to do that but how do we
60:56 - know what game we're getting reviews for
60:59 - well we can access the ID of the game
61:01 - via the parent argument because the
61:04 - parent argument is a reference to the
61:06 - value returned by the previous or parent
61:09 - resolver now in our case that's going to
61:13 - be the game one so the initial one
61:15 - inside the query object so that parent
61:17 - argument will basically be a game object
61:20 - and that game object is going to have an
61:23 - ID which we can then use so we can use
61:25 - the ID now to return all the reviews
61:27 - associated with that game ID and the way
61:31 - we're going to do this is by first of
61:33 - all returning DP which is the data
61:35 - remember that we imported and then we
61:38 - want the reviews array on that then
61:40 - we're going to use the filter method so
61:42 - what we're going to do is filter out any
61:44 - review that doesn't have the same game
61:47 - ID as the ID on the parent
61:50 - because if they are the same and we
61:53 - return true for each of those then it's
61:55 - going to keep those in the filtered
61:57 - array and that's what we want any review
61:58 - associated with the game where the IDS
62:00 - match if they don't match it's going to
62:02 - filter them out and they're not returned
62:03 - in that array so we fire a function for
62:06 - each item inside the array I'm going to
62:09 - refer to each review item as R and then
62:12 - we want to return r dot game underscore
62:16 - ID remember that is the property
62:18 - if we go over here each of you has a
62:20 - game underscore ID to associate it with
62:23 - a particular game and we want to check
62:25 - if that matches with a particular game
62:27 - the game we've just queried so we'll say
62:30 - triple equal to the parent which has the
62:34 - ID property because that is essentially
62:36 - the game object so where they match
62:38 - they're going to stay in The Returned
62:40 - array because they're associated with
62:42 - each other and that's what we want we
62:44 - want to return all the reviews
62:45 - associated with that game where they
62:47 - don't match the filtered out so we don't
62:49 - return those okay so let's save this and
62:52 - give it a whirl okay then so I've got
62:54 - this query already set up so we're using
62:57 - a query variable ID which we're passing
62:59 - right here so id2 we ask for the game
63:02 - with the ID and grab the title but also
63:04 - all the reviews associated with that
63:07 - particular game ID and we'll get the
63:08 - rating and the content from each one so
63:10 - let's give this a whirl and yep cool so
63:13 - we can see we get the game title and two
63:15 - reviews right here and what I'm gonna do
63:17 - is also put in here
63:20 - the game ID let me do commas here like
63:23 - so and then I'll say the game underscore
63:26 - ID that should be two oh in fact we
63:30 - can't do that and the reason we can't do
63:32 - that is because we didn't specify that
63:34 - on our schema all right so I'm not going
63:37 - to do that but if you remember in our
63:39 - different types on the review object we
63:41 - didn't add the game ID that is something
63:43 - you could do if you wanted to but it's
63:45 - not going to work here because I didn't
63:46 - add it but either way we can see that
63:48 - this works and if I put in a different
63:50 - ID like three and try that out we can
63:53 - see now we get a different game with one
63:55 - review I'm gonna put in an idea of one
63:57 - here and yeah that's working as well
63:59 - awesome Okay so we've sorted out related
64:02 - data when it comes to finding reviews
64:04 - for a game but reviews can also be
64:06 - associated with an author can't so if we
64:09 - take a look at author they could have a
64:11 - list of reviews as well so let's do the
64:12 - same thing for author so like we had a
64:14 - game property this time we need an
64:17 - author property like so which is an
64:19 - object and then we want the reviews
64:21 - resolver for this where we're taking the
64:24 - parents and then inside there we're
64:26 - going to do essentially the same thing
64:27 - as this
64:29 - so let's return reviews.filter this time
64:33 - we want to check the author ID is equal
64:37 - to the parent ID all right so the author
64:40 - ID on the review remember we have that
64:42 - right here we're checking this against
64:44 - the ID of the author we selected and
64:46 - then we're only returning the reviews
64:49 - where if this was the author for example
64:51 - one we'd return this one and this review
64:54 - okay
64:55 - so let's save that I'm not going to test
64:58 - it just yet because there's one more set
65:00 - of resolvers I want to do and that's for
65:03 - the review so imagine we select a single
65:07 - review if we go to our schema
65:09 - we can see that each review has an
65:12 - Associated game and author so they would
65:15 - be nested queries so we need to make a
65:17 - resolver function to get the game
65:18 - associated with that review and also the
65:21 - author so two resolver functions right
65:23 - here
65:24 - so let's do the auth first of all
65:27 - and we're taking the parents so the pair
65:29 - at this time is going to be a single
65:31 - review and we're going to return DB
65:34 - dot authors and then we're going to find
65:37 - a single author because this isn't a
65:40 - list of authors associated with a single
65:42 - review we only have one author per
65:44 - review so we're finding a single one so
65:47 - we fire a function for each element in
65:49 - the array and I'm going to call each
65:51 - element a for author and then what we
65:53 - want to do is grab the ID of that so a
65:55 - DOT ID and we want to return true when
65:58 - it's equal to the parent which is the
66:01 - review object dot author ID so where
66:04 - they match it means that author is
66:06 - associated with this review and we're
66:09 - returning that single author now we need
66:11 - to do the same thing but this time it's
66:13 - going to be for the game because again a
66:16 - single game is associated with a
66:18 - particular review so game and then we'll
66:21 - change this to G change this to G for
66:24 - game and then this is going to be game
66:26 - underscore ID and that's all there is to
66:29 - it oops this needs to be games
66:31 - right here
66:32 - cool so now we have our resolver
66:34 - functions for nested authors and games
66:37 - inside a review object and also for
66:40 - reviews inside an author alright
66:43 - cool so let's save this and try it out
66:46 - again
66:47 - all right then so let's start the
66:49 - starting off point as author we'll keep
66:53 - the ideas one that we pass in we want
66:55 - the author name
66:58 - and then we'll get the reviews
66:59 - associated with the author so we'll
67:02 - press that and we can see Mario has
67:04 - these reviews right here these two
67:05 - awesome and then let's try author with
67:09 - the ID of two
67:11 - like so so we have Yoshi and these three
67:14 - reviews awesome so that's working now
67:16 - what I'm going to do is I'm going to
67:18 - copy this and I'm going to make a new
67:20 - query so we can come back to this and
67:23 - I'm going to paste it in here and just
67:24 - change it so we'll change this to
67:26 - review
67:28 - query and then we'll pass in an ID again
67:32 - so let me go back here and copy this
67:35 - like so paste it in and then we want a
67:38 - single review right here with the ID
67:40 - we're going to get the rating of that
67:44 - review but then also we want the
67:47 - associated game and for the game we will
67:50 - get the title and the platform like so
67:53 - oops
67:55 - platform
67:57 - press send and we can see now we get the
67:59 - review and the single game associated
68:02 - with that review which is awesome we
68:04 - also can get the author Remember so
68:06 - let's do that as well and for the author
68:08 - we want the name and also we'll get the
68:10 - verified
68:12 - property as well which is true or false
68:15 - so now we get the author as well awesome
68:17 - change the ID and those should change as
68:19 - well
68:20 - yep cool awesome so this is all working
68:23 - now not only this but
68:27 - what I could do is I could get a single
68:29 - review and the rating get the game that
68:32 - is associated with that review and I
68:34 - could also say well I'll tell you what
68:35 - get me all the other reviews
68:39 - associated with that game and from those
68:42 - I could just get the rating
68:44 - now the reason I can do this is because
68:46 - we have a resolver chain so the first
68:50 - one the entry point is for a single
68:52 - review right so we use that initial
68:54 - resolver function defined inside the
68:56 - query object
68:57 - to get that single review then we move
69:00 - on to the game resolver inside the
69:03 - review object so it gets the game
69:05 - associated with that review that's the
69:06 - quick that's the resolver function we
69:08 - just made
69:09 - and then since we're asking for reviews
69:11 - inside the game it goes to the resolver
69:15 - function for reviews inside the game
69:18 - object and this time the parent refers
69:21 - to this right here so we have this kind
69:24 - of resolver chain and we always have
69:25 - access to the previous resolver as the
69:27 - parents so we can Nest as much as we
69:29 - want here and this is going to work
69:30 - which is awesome so we'll get the review
69:33 - and the rating for that review the game
69:34 - associated with it and all the other
69:36 - reviews along with the rating for that
69:39 - particular game awesome
69:43 - all right then my friends so now we can
69:45 - do quite a lot in terms of making
69:46 - queries to fetch data and related data
69:49 - as well which is cool but at the moment
69:51 - all we can do is fetch the data we can't
69:53 - add new data or edit the current data or
69:56 - delete data or any of that jazz so I
69:58 - want to address that now by talking
70:00 - about mutations and the mutation is
70:03 - basically a generic term in graphql for
70:05 - any kind of change that we want to make
70:06 - to the data whether it be to add new
70:09 - data delete data or edit current data so
70:12 - the first thing we need to do is Define
70:14 - our allowed mutations in the schema by
70:16 - making a new type which is called
70:18 - mutation and it's inside this type that
70:21 - we can then decide how users can mutate
70:23 - any data for example I might want to
70:26 - expose a mutation called delete gain and
70:30 - for that mutation we need an ID argument
70:32 - to say what game should be deleted we
70:35 - also specify the return type as well
70:37 - after a user makes this mutation much
70:40 - like we did for the root queries so for
70:43 - example once a user deletes a game from
70:45 - the data I might want to send back an
70:47 - updated list of all the games after that
70:50 - one has been removed so I'd use an array
70:52 - of game objects right here okay so
70:56 - that's the mutation defined but we also
70:58 - need to make a resolver for the mutation
71:00 - as well inside our resolvers object
71:03 - called mutation so right at the bottom
71:07 - down here comma and then mutation
71:10 - which is an object and we just make
71:12 - resolvers in much the same way as we did
71:13 - for these for these Etc so we want to
71:16 - make a resolver called delete game right
71:19 - here so let's do that
71:20 - delete
71:22 - game like so and it also takes in the
71:25 - same arguments so we have the parent we
71:27 - also have the args over here and then
71:29 - context if we want it so we don't
71:30 - actually need the first one which is
71:32 - parents to delete a game but we do need
71:34 - the arguments because we want the ID of
71:36 - the game that we want to delete so
71:38 - inside here oops
71:40 - inside here what we want to do is
71:42 - basically update the value of the games
71:46 - array because that's what we're editing
71:47 - right here we're deleting a game so we
71:49 - want to remove one right so let's say
71:52 - that DB
71:54 - dot games is equal to something new and
71:56 - that's going to be DB
71:58 - dot games dot filter
72:01 - and by the way in a real application you
72:03 - probably use a database right like maybe
72:05 - mongodb or something like that so you
72:07 - would use the library for mongodb to
72:10 - connect to that and just delete a game
72:12 - this way we're just using local
72:14 - variables as data because then it's
72:16 - easier for me to keep the focus on
72:18 - graphql all right anyway so dot filter
72:21 - so we want to go through this array and
72:23 - we fire a function for each game which
72:25 - I'm referring to as G inside this array
72:27 - and we want to return false
72:32 - whereby the ID is equal to the ID on
72:37 - here and we're returning false in that
72:40 - scenario because if we return false it
72:42 - filters it out of the array and
72:43 - therefore the filter array is not going
72:45 - to include that game that we want to
72:46 - delete so we say g dot ID is not equal
72:50 - to args.id so where they're not equal it
72:54 - returns true and it keeps that in the
72:56 - array where they are equal that's the
72:58 - game we want to delete it returns false
73:00 - and therefore we filter out the array
73:02 - all right
73:03 - so now we also need to return something
73:06 - and we specified the return type to be a
73:08 - list of games so the updated games array
73:10 - so all we need to do then is return DB
73:13 - dot games like so all right so let's
73:16 - save this and give it a whirl so how do
73:19 - we actually make a mutation from the
73:20 - front end because when we make a query
73:22 - we use this query keyword give it a name
73:24 - and then specify what we want now with a
73:26 - mutation it's a very similar we just
73:28 - specified that it's a mutation not a
73:30 - query it anymore then we can give this a
73:32 - name so I could call it delete mutation
73:37 - we can specify any variables that need
73:40 - to go into this query and we do need a
73:42 - variable that's going to be the ID
73:44 - and that's going to be of ID type
73:46 - and then inside here we can specify what
73:49 - mutation we want to make and that was
73:50 - called delete game so let me get rid of
73:53 - this because it's automatically created
73:55 - it for us
73:56 - and this should be ID instead to refer
73:59 - to this
74:01 - so now we need to pass in the ID
74:03 - variable down here and that is going to
74:06 - be
74:07 - 2. so we're deleting the game with the
74:10 - ID of two and remember we get back as a
74:13 - return an array of games with that game
74:17 - deleted so an updated version of it so
74:19 - we can specify now what fields we want
74:21 - back so I could say we want the ID of
74:23 - the game back the title and the platform
74:27 - so let's give this a whirl delete
74:28 - mutation all right so now we can see ID
74:31 - 1 and 3 and 4 and 5 but no two because
74:35 - it's been deleted
74:36 - now obviously when the server restarts
74:39 - that is going to be there again because
74:41 - we reinitialize the variables and all
74:43 - that jazz this is not permanent this
74:45 - deletion it's only while you know this
74:48 - current session is going on if you like
74:49 - but as soon as we restart the server
74:52 - that's going to return but like I said
74:54 - you'll probably use a database where
74:55 - you'll have a bit more persistence than
74:57 - this so anyway now we've deleted a game
74:59 - Let's also try adding a new game okay so
75:03 - now we've made this delete game mutation
75:05 - next I want to try making a mutation
75:07 - whereby a user can add a new game so how
75:09 - do we do that well first of all we need
75:12 - to go to the mutation type in the schema
75:14 - and we need to add the mutation which
75:16 - I'm going to call add game and it's
75:19 - going to accept some arguments so we do
75:20 - need parentheses but we'll come back to
75:22 - those in a second now as a return value
75:25 - we're going to send a single game object
75:27 - back to the user the one that we just
75:29 - created
75:30 - so for the arguments of this mutation we
75:33 - need to basically grab all of the fields
75:36 - that make up a new game minus one of
75:38 - them the ID because we don't want the
75:40 - user to decide the ID of the new game
75:43 - that they add instead we're going to
75:45 - generate a random ID in the resolver
75:47 - later for this mutation but we still
75:50 - need the game title and maybe the game
75:53 - platform
75:54 - maybe the game price if there is one
75:56 - basically any property that makes up a
75:59 - new game so we could add each of those
76:01 - fields as different arguments inside
76:04 - here or we could make a new special
76:07 - input type in our schema which allows us
76:09 - to group together several arguments into
76:12 - one type and then that can be used as a
76:15 - single argument elsewhere like in this
76:17 - mutation so the way we do that is by
76:20 - coming down here and first of all saying
76:22 - input instead of type which says to
76:25 - graphql that this isn't an actual type
76:27 - of data but more of a collection of
76:29 - fields that we can use in a mutation as
76:32 - a single argument for example
76:34 - so inside this then we can choose What
76:36 - fields we want this input to have and
76:39 - also the type of those fields
76:46 - so I've said right here we need two
76:48 - properties the title which is a string
76:50 - and also the platform which is a
76:52 - collection of strings or a list of
76:53 - strings and they're both required we
76:55 - don't want to add in the reviews because
76:57 - we're not making a review we're just
76:59 - making a game and then later if you were
77:01 - to have a review you would associate it
77:03 - with a particular game we don't need to
77:05 - do that right here when we're adding a
77:06 - game for the first time but now what we
77:08 - can do is we can say okay this mutation
77:10 - takes in a variable called game and that
77:14 - is going to be of type add game input
77:17 - and it's required so when we're making
77:18 - this mutation from the front end it's
77:20 - going to require us to add a game
77:23 - variable which looks something like this
77:25 - an object with these two properties okay
77:28 - so now we have that mutation sorted we
77:30 - can go back to the index file and we can
77:32 - add that mutation right here after
77:34 - delete game so I will call this add game
77:37 - and we're going to take in the args
77:40 - argument so we don't need the first one
77:42 - which is parent so underscore for that
77:43 - then args and the reason we need that is
77:45 - because the game property is going to be
77:47 - on the arguments because we're sending
77:49 - that from the front end and on that game
77:50 - it's going to be the title and platform
77:52 - properties so what do we want to do here
77:54 - well we want to make a new game object
77:56 - and add it to the game array right
78:00 - so we can make the object first of all
78:02 - by saying let's game equal to an object
78:05 - then we're going to spread out so dot
78:07 - dot dot args dot game and it's dot game
78:10 - because that is the name of this
78:12 - variable and on that will be those two
78:14 - properties the title and the platform so
78:16 - we're adding those two properties to the
78:18 - new object and then the reason I'm
78:20 - spreading that is because we also need
78:22 - an ID property which we need to randomly
78:24 - generate now you might be better off
78:26 - using some kind of random uid generator
78:29 - library or something like that I'm going
78:31 - to use the mass object to generate this
78:33 - for the sake of our tutorial but we're
78:35 - going to say math.flor then math dot
78:37 - random and this generates a random
78:39 - number between 0 and 1 in decimal format
78:41 - and then we'll times that by 10 000 so
78:45 - what this will do is generate a random
78:47 - number between one and ten thousand and
78:49 - it will have decimal points as well but
78:51 - then what we're doing is flooring that
78:52 - so it becomes an integer okay and then
78:55 - we'll convert it to string like so
78:58 - so we have our ID property we also have
79:01 - the other arguments that we passed along
79:02 - and we have the new game object now we
79:04 - just need to push that to the games
79:07 - array so we can say let me come back up
79:09 - a line DB dot push and then we're going
79:11 - to push on in fact not
79:15 - db.db.games.push to push onto the games
79:17 - array and we push on the new game
79:19 - awesome and then finally we return
79:22 - that new game that we created because if
79:24 - we go to the schema we can see we return
79:26 - a game type all right so that is pretty
79:29 - much it my friends so let's try this
79:31 - from the front end okay then so let me
79:34 - just copy this and then we'll go over
79:36 - here and paste it in and we're going to
79:38 - call this one add mutation
79:42 - we also need to pass in the ID no we
79:44 - don't in fact do well we need to pass in
79:46 - a game object and that is a type
79:52 - add
79:53 - game
79:54 - input like so all right so now we need
79:58 - to specify that the game is required
80:01 - here
80:02 - like so and then this is called
80:05 - add game instead
80:07 - alright so now down here we need to pass
80:09 - the variables in
80:10 - so remember we need a game
80:14 - property and that is an object and
80:16 - inside the object we have the title so
80:19 - we'll just say a new game
80:22 - very original right and then we also
80:24 - need a platform and that platform is
80:27 - going to be an array and inside here we
80:30 - will say switch and PS5
80:35 - like so so remember it Returns the new
80:39 - game back and we're requiring D3 feels
80:42 - from The Returned game so let's try this
80:44 - add mutation and you can see now we get
80:46 - this random ID 263 the title and the
80:49 - platform awesome so that's worked and
80:52 - now I'm going to go back over here and
80:55 - I'm going to just require all of the
80:56 - games right here so games like so we
80:59 - don't need these anymore just so we can
81:02 - see an updated list of games and we'll
81:03 - get the title of each one and we don't
81:06 - need these parentheses let's run this
81:09 - and you can see now a new game so it's
81:12 - been pushed on to the array awesome so
81:14 - in the next lesson we're going to look
81:16 - at one more mutation and that is to
81:18 - update existing data
81:22 - all right then so in the last lesson we
81:24 - made our first two mutations want to add
81:25 - the game and one two delete a game and
81:27 - for adding a game we made this ad game
81:30 - input where we collated two Fields
81:32 - together so that could be our variable
81:35 - right here just this one variable called
81:36 - gain which has this kind of structure so
81:39 - we're gonna do one more mutation now and
81:41 - that is going to be for editing a game
81:43 - so I'm going to come down to the bottom
81:45 - and I will make a new one called update
81:48 - game like so now in here we need some
81:52 - arguments now what do we need we need
81:54 - the ID of the game that we want to
81:55 - update and we didn't need an ID here
81:58 - remember because we're adding a new game
82:00 - that doesn't have an idea yet but when
82:01 - we're updating existing data we need the
82:03 - ID of the game that we want to update so
82:06 - let's put that in but we also need any
82:09 - kind of edits that we want to make all
82:11 - right so what I'm going to do is make
82:13 - another argument called edits and for
82:15 - this I'm going to create a new input so
82:17 - let me copy this
82:19 - and paste it down here and I'm gonna
82:21 - call this
82:23 - edit game input and then we'll set that
82:26 - here edit game input like so and we're
82:31 - not going to make this yeah in fact we
82:32 - will make this required
82:34 - okay and this is going to return
82:36 - game now these things right here these
82:39 - two Fields they are the same so you
82:41 - might be thinking well why didn't we
82:43 - just reuse this one here and the
82:46 - difference is that I'm not going to make
82:47 - these two required because if you go to
82:50 - update a game
82:52 - you might just want to update one of the
82:54 - fields like title so I don't want to
82:55 - make there for the platform required if
82:57 - you don't want to update that and
82:59 - likewise if you just update the platform
83:00 - you might not want to update the title
83:02 - so therefore I don't want to make this
83:04 - required so if I reuse this we would
83:06 - have to basically update both of the
83:08 - fields in order for this to work but I
83:10 - don't want to make a user do that
83:13 - so by making a new one where they're not
83:15 - required it's a bit more flexible and
83:18 - also I'm not putting the ID in here
83:22 - like so and instead of specifying it
83:25 - here and the reason for that is because
83:27 - it's not really an edit is it so I don't
83:30 - want to group the ID into some kind of
83:32 - edits object I'd like that to be its own
83:34 - separate argument so let me
83:37 - delete that save it and now we can
83:40 - create a resolver function for this
83:42 - update game mutation all right then so
83:45 - let's add this in down here update
83:48 - game like so and we don't need the first
83:50 - argument the parent but we do need the
83:52 - arcs because the edits and also the ID
83:54 - are going to be on that and then down
83:55 - here what I'm going to do is just paste
83:57 - in a bit of code and this is what we're
83:59 - using to basically update the games
84:02 - array so we're taking the games on DB
84:05 - and we're setting it equal to
84:07 - db.games.map so we're mapping through
84:09 - the array and basically creating a new
84:12 - array out of it so we fire a function
84:14 - for each item in the array and for each
84:16 - item we check does that particular game
84:19 - that we're currently iterating have an
84:21 - ID that is equal to the ID on the
84:24 - arguments because remember we're going
84:26 - to have an ID property on this right
84:29 - here
84:30 - and if it does match then we're going to
84:33 - return
84:33 - this thing right here G so the current
84:36 - objective you like and spread those so
84:39 - whatever properties it currently has
84:40 - we're adding right here and I'm also
84:42 - spreading args.edits so if for example
84:46 - we update the title then it's going to
84:47 - override the title that's over here that
84:49 - we're spreading does that make sense
84:51 - so that's the returned object right here
84:54 - and that's going to go inside the array
84:56 - then if these don't match then we don't
84:58 - need to change it and we just return the
84:59 - original object to the array so I hope
85:01 - that all makes sense
85:02 - now at the end of this update game
85:05 - mutation we need to return something
85:07 - back to the user so if we take a look at
85:08 - the schema we return the game that we
85:11 - just edited so we shall say return and
85:15 - then we'll say db.games dot find to find
85:18 - a particular game and we can cycle
85:21 - through those and we want to return the
85:23 - game where the ID is equal to
85:26 - args.id because again remember we have
85:29 - the ID argument right here okay
85:33 - cool so now we have that mutation let's
85:36 - try it out okay then so back over here
85:38 - I'm going to create a new tab and I'm
85:41 - going to copy this mutation which is for
85:42 - adding a game I'm going to paste it over
85:44 - here and then I will call this edit
85:47 - mutation and this right here needs to be
85:50 - edit
85:52 - game input and this is called edits
85:56 - this and this right here is edits and
86:01 - dollar sign edits but also remember we
86:03 - need to pass in the ID so we can say the
86:05 - ID is equal to oops I need dollar sign
86:08 - first of all ID is of ID type like so we
86:12 - need the ID right here
86:14 - so let's say the ID
86:17 - is
86:18 - the ID variable awesome okay this is not
86:23 - ad game it's updates game like so and we
86:27 - don't pass in the ID we can pass in a
86:30 - title and a platform
86:32 - or imagine these are what we're going to
86:33 - get back so we can pass in the ID here
86:35 - if we want to for the variables let's
86:37 - copy this again
86:39 - because it's going to be very similar
86:41 - and paste it right here so we're going
86:43 - to have an edits property
86:46 - and we also need an ID property so let's
86:49 - do the ID down here oops done that
86:51 - incorrectly comma here and then ID
86:56 - or set that equal to two
86:58 - and we'll change this to
87:03 - I don't know Dark Souls
87:05 - like so
87:06 - and then we don't need to pass in an
87:08 - update for this
87:09 - so let's just do that
87:12 - so then we're going to get these fields
87:13 - back so what we're doing is we're
87:15 - passing in the edits right here of which
87:17 - we just have won the title and then the
87:19 - ID of the game we want to edit so we're
87:21 - passing both of those in here and then
87:23 - we're using those inside this mutation
87:25 - and we're saying look once you've made
87:27 - this mutation this edit send back the
87:29 - game and give us the title and platform
87:31 - so the title should be updated now so
87:34 - let's do that
87:35 - and we can see now the title is Dark
87:37 - Souls the platform is unchanged if I
87:40 - change instead
87:42 - platform
87:44 - and this needs to be an array of strings
87:45 - now doesn't it
87:47 - and we'll just change this to be
87:50 - I don't know um XBox whatever let's edit
87:54 - that again and now it's just Xbox I can
87:56 - change this now to PS5 if I wanted to
87:58 - and we'll do switch as well
88:02 - and also if we wanted to change the
88:04 - title as well we can do so we'll just
88:08 - say I don't know some other game can't
88:10 - think off the top of my head edit and we
88:13 - can see now we've made those edits
88:15 - awesome all right then gang so that's
88:16 - pretty much it for this series then I
88:18 - really hope you enjoyed it and hopefully
88:20 - you feel comfortable now with the basics
88:22 - of graphql in terms of making a graphql
88:25 - server but also in terms of the query
88:27 - syntax and actually making queries from
88:29 - the front end and if not then I guess
88:32 - thanks anyway for wasting the last two
88:33 - hours of your life watching my videos
88:35 - but yeah hopefully not and fingers
88:37 - crossed it wasn't a complete waste of
88:38 - time but anyway in the future I will do
88:41 - more courses to incorporate graphql like
88:43 - how to use graphql in a next JS site or
88:46 - maybe with super bass or something like
88:48 - that and that's one of the main reasons
88:49 - I wanted to make this course right here
88:51 - so that it serves as a jumping in point
88:53 - to learn the basics of graphql quickly
88:55 - so we can do more advanced stuff in the
88:58 - future

Cleaned transcript:

welcome to this comprehensive video course on graphql The Cutting Edge query language designed to empower your data retrieval needs for modern web applications throughout this course you'll learn its core principles explores advantages over traditional rest apis and gain the practical skills to design and Implement robust datadriven applications this beginner's course was developed by the net ninja he is one of the most popular graphql instructors on the internet so you're in good hands hey there gang and welcome to your very first graphql tutorial thank you okay then so although I do already have a graphql course it's about five years old now and I wanted to make a fresh uptodate one with less bloat so that anyone wanting to get up and running with graphql quickly can do here before diving into more advanced tutorials and projects using it so in this series we'll be learning what graphql is and why we use it and then we'll build a graphql server from scratch using node.js and the Apollo server package we'll also look at how to make queries to that server using Apollo Explorer which is a free tool for testing different kinds of queries now before you start I would already expect you to have a basic understanding of node.js because we'll be using that to make our graphql server so if you want to learn that a little bit more first of all which I highly recommend then you can check out my node.js crash course on netninja Pro and also on YouTube so I'm going to leave a link to that course down below the video you're also going to need a recent version of node installed on your computer which you can get from nodejs.org just click on this download button and then go through the installation steps that easy and then finally before we start I've made course files for this entire series you can get them from this repo on GitHub graphql crash course the link to that is also going to be down below the video now each lesson has its own Branch so if you want the code for a specific lesson you can head to the branch drop down and select that branch that corresponds to that lesson then to download the code just hit the green code button and download a zip folder or if you prefer you can clone the entire repo to your machine so then let's get started by talking about exactly what graphql is and why we'd want to use it so graphql is what's known as a query language which is what the ql in the name stands for query language and by query language we mean a specific syntax that we can use to query a server to request or mutate data so it's kind of like an alternative to the more traditional approach of sending standard requests to a rest API using endpoints but whereas using a rest API is more of an architectural style an approach to serve and fetching data graphql differs in that it's an actual query language with its own syntax and rules and it still uses HTTP requests under the HUD like we'd normally send to a rest API it's just that we have this nice query language sitting on top of that to give us more flexibility and control about how we make them and what data we want to fetch or mutate and also the way a graphql server handles those requests is very different to how a typical rest API would handle them as well so let's take a quick look at those differences and see why in some cases graphql has the edge so when we use a rest API we typically send HTTP requests to specific endpoints like this to interact with a certain type of data right for example we might send a get request to this endpoint to fetch a list of Pokemon and we could also send a post request to that endpoint to add a new Pokemon to the data set we might send a get request to an endpoint like this with an ID on the end of it to fetch a single Pokemon with the ID and we might also send a delete or put request to this endpoint to delete the data or update it and the server would handle requests to those endpoints by connecting to a database probably where the data was stored and either fetching the data and sending it back to the client the browser or updating or deleting the data from the database instead so this is your traditional rest API and for the most part it's really effective and a good way to expose data to clients but there are sometimes some drawbacks when it comes to using a rest API when your application scales and your data gets a little bit more complex now the first drawback is something called over fetching another fetching is when we request some data from an end point and the server sends back too much data so much more data than we actually need for example I might have an endpoint which is forward slash courses and that gets all the courses so that request goes to the server the server gets the courses from the database and sends the whole list of them back to us in Json format now each course object might have a ton of different properties like an ID the title the author property which contains author name and the author ID maybe the price a thumbnail URL a description a video URL and so forth and it might actually be that in this case we only need the ID the title and the thumbnail for each one because that's all we're going to be showing on this particular page and so the rest of this data for each course is pretty much Obsolete and we don't need it for anything which means that we've over fetched what we do need so that's the first drawback of fetching the second drawback is the polar opposite under fetching and under fetching is when we don't get back all the data that we need from a single request and it could lead to making multiple requests to different endpoints to collate everything that we need together for example we might send a get request for a single course the server handles that request by getting the course from a database and sending it back in Json format and it might look something like this with an ID title thumbnail URL description the author property which contains the author name and the author ID price video URL Etc and in this case we need all of those things that's great so we show all of those on our course page on our website but we also want to show additional stuff on the page about the author of that course as well for example the other course is that this author has made and information about those courses such as the title the thumbnail the ID the price and so forth and we don't have all of that deeply nested data here in the course object that we got back so we've actually under fetched what we need in that single request and that could mean we now need to make additional requests to the server to different endpoints to get back that additional data so these are two potential drawbacks of using a rest API when your data layer gets a little bit more complex and these are two things that can easily be solved by using graphql instead so now let's look at how graphql works and how it combats both over fetching and under fetching so first of all when we send a request using graphql to a server we typically do that to a single endpoint which might be forward slash graphql and this is totally different to when we used a rest API where each resource typically has its own set of endpoints for get post delete and put requests Etc so whenever we send a query using graphql to the server it's always going to be sent to probably that single end point and then the server can handle it now the way that we send a query to the server is by using a special graphql syntax that looks something like this and we're going to talk more about this syntax later on in the course but essentially this syntax allows us to specify exactly what data and what fields we need back from the server so in the example from before if we want maybe the call courses data then we can send a query that looks something like this so we'd specify that we want the courses resource and for each course we can also specify which properties we want back as well so in this case that would be the ID the title and the thumbnail URL so it's send that query and the server would respond with a Json array of courses where each one of those courses would only have those properties that we need so there's absolutely no fetching going on there whatsoever which is really good the other thing graphql allows us to do is fetch nested related data within a single query so again for the example before where we needed a single course we'd send a query like this one and specify whatever properties we need from that course but we also said that we wanted extra information about the author of that course along with any related data or any related courses rather that author made and we can do that in graphql by nesting those properties inside the query so I can say get the author Name ID and then also get the courses of the author where for each course I want to get the ID the title and the thumbnail URL and all this is done in a single request or query so we're no longer under fetching the data that we need which is really cool and this right here is one of the really good things about using graphql the ability to Nest any related data we need into a single query instead of making multiple queries as you might do when you're using a rest API so that's the basics of why graphql might be beneficial to you and your application especially as like I said before you scale up the app and the data layer becomes a bit more complex now at the moment you've only seen how to retrieve data here and we'll look at this more closely later on but you can also perform something called mutations to do things like ask the graphql server to add new data or update it or delete it I'm watching the same way a post request might ask a rest API to add new data or a delete request would ask the server to delete some data so we're going to talk much more about that later on in the course as well so in this course then we'll be making a graphql server from scratch using node.js and a package called Apollo server and that server is going to be responsible for handling all the queries and mutations that we send to it now to send the queries we'll be using Apollo Explorer which is a graphql client that we can run in the browser you can kind of think of this as a bit like Postman but it's the graphql equivalent and postman by the way is a free tool to test out rest apis so you're going to learn how to set up a graphql server and also how to make queries and mutations from the front end using this kind of graphql syntax so my friends that's the introduction out of the way now in the next lesson we're going to go over the basic syntax of making queries so then before we get started actually making a graphql server that can handle all of our queries I wanted to go over the basics of this query language right here and show you how I typically structure these queries from the front end now to do this we're going to be using Apollo Explorer which I showed you briefly in the first video of the series an Apollo Explorer is a way for us to send test queries to a graphql server and see the responses that we get back from it now you might have worked with something called Postman before which is for rest apis and it's basically a graphql version of Postman what we're using here it allows us to test and sync queries as we would from a frontend application without having to actually build a front end so the way we're going to be making and sending queries from here is essentially the same way we'd be sending them from a clientside application like a react app for example so this window right here is where we're going to be making the queries and then to send them we'd press this button right here and the response from the server is going to show over on the right now for this lesson I'm connecting Apollo Explorer to a backend graphql server I've already made and it's the one that we're going to be making through the rest of this series but you can also use something called the Apollo sandbox which you can find on the Apollo docs right here I'm going to leave this link down below and when you open the sandbox it connects to a dummy graphql server so you can play around with requests without having to worry about making a server yourself but for now I'm going to go back to the Explorer connected to my own graphql server because that's more pertinent to the rest of this course that we're doing so then how do we make a query using graphql well first off we'd use this word query and then after that we can give our query a name if we want it for example I'm calling this one reviews query because I'm going to be fetching reviews from the server makes sense right so you can call this whatever you want then we open the curly braces and inside these we specify what data resource we want to get back now a graphql server can expose multiple different resources to the clients for example they might expose the reviews resource and author's resource a user's resource games resource Etc and we can specify any of those resources right here as our entry points for the query so right now we're saying we want to jump into the graph on this resource entry point in essence we want to fetch the reviews data to begin with now on its own that's not going to do much for us because although we've said we want to get the reviews data we've not specified which fields from each review that we want to retrieve now this is one of the major differences between graphql and using a rest API because when we send a request for a resource to a rest API endpoint we don't then specify which parts of that resource we want to get back we just get the whole lot back but in graphql we can manually choose which field from this resource that we want to fetch and the way we do that is by opening curly braces again and then writing down whatever fields we want so I could just say get me the rating field of each review and if I press send now I'll see the response is a bunch of review objects each one with just the rating field awesome now if I want more Fields I can just list them inside these curly braces right here so I could say that I want the content of each review and also the ID of each review as well and now if I hit send you're going to see this time I get back all of those fields in each review object so this is a really cool feature of graphql only getting back the fields from the data that we actually need now before we go any further I want to just jump to some slides to quickly explain from a bird's eye perspective how we query the graph and move around it to navigate data so when we make a graphql server or API we're making something called a graph right and a graph in visual terms is basically a bunch of connected data that looks something like this so in this case we've got three different data types we've got reviews authors and games and we can choose to jump into the graph at any point that's exposed to us by the server when we make a query and from there the graphql layout allows us to Traverse or walk through this graph to also fetch any related data to that starting point right so we just made a simple query whereby we requested all of the reviews data and specified which fields we wanted back for each review right so the reviews resource was our jumping in points we landed right there and from there I could say okay also get me the author of each review that I got back and I could also specify which fields of the authors that I want to get back as well and the query would look something like this and the reason I could do this is because when I made the graphql server I connected these data resources I said that each review was related to an author who wrote that review and the author is a separate resource and all of this data would be brought back from a single request we've only made one query and sent that one query to the server we didn't have to first get the reviews and then make a second request for the authors of each of those reviews even though it's a separate resource that we're getting right here another example could be that my initial entry point to the graph would be a specific game with a certain ID and the query for that would look something like this where we specify the ID of the game that we want as a variable now we'll learn more about query variables later on so don't worry too much about that for now but then having jumped in at these points on that game I could also say get me any review related to that game and from those reviews just get me the rating field and to take it one step further I could also say then get me the author of each of those reviews and just give me their name so you can see how this general idea of a graph allows us to initially jump in somewhere and then navigate between related data and fetch it all in a single query and that is the Crux of graphql so let's try one of these queries with nested related data again in Apollo Explorer all right so we saw before that we had this reviews query where we fetched all the reviews and we got the rating content and ID for each one so we got those back right but now we can also get nested content so say for example I want the author of each review now this author is actually a separate resource so they don't have author properties these reviews they're a separate resource but they're linked to reviews so the related data and we've specified that or I've specified that in the graphql server we'll see how to do that later on but let me just show you how we can fetch this stuff now so from the author I could get the name and the ID of the author we also have a verified property to say whether they're a verified author now if I click on this we're going to get all of the same stuff here plus the author details so it's grabbing that as well for each different review now we could also get the game associated with each of you so down here I could say game and then inside parentheses or rather curly braces we can say which properties we want back for the game so I could say the title of the game the price of the game and also the platform of the game and it looks here like we don't actually have a price property so let me get rid of that I mustn't have added that so let me just leave it with the title and platform press that and we can see now we get the title of each game and the platform of each game as well which is an array of different platforms so these are three separate resources author game and reviews but we're getting them all back from the same aquarium and we can take this one step further if we wanted to we could say okay well get me all the reviews now associated with each author for example so let's do it right here we can say we want the reviews from each author and from that we just want the rating and we want the ID of each of you click on that and now you can see nested inside the author we can see the other reviews they've done and again we can take this one step further we can say we also want the game for each one and we want the title for each one now this is getting a bit complex it probably wouldn't make a query this complex I just wanted to show you how we can work with this related nested data all right and how flexible it is that's really cool isn't it all in one query so like I said before we can also have mutations to add new games if we want to delete games or reviews whatever it might be to update different records so we're going to see all of that later on as well so now hopefully you can understand a little bit more about how these queries are made and how we can fetch related data within a single query now there is much more to graphql than making queries like this but for now I think that's probably enough to get us started I just wanted to make sure we all have a little bit of an understanding of this General syntax so in the next lesson we're going to start making our very own graphql server on the back end all right the gang so now we want to make a brand new graphql API and to do that we'll be using node.js and a library called Apollo server an Apollo server is one of many different libraries that you can use to easily spin up a graphql server and each library has their own kind of take on it but the nice thing about using Apollo server is that it automatically spins up an instance of the Apollo Explorer for us on localhost which we can use then to test out our API so when we use Apollo server it's going to create a graphql server for us that then allows us to easily set up resolver functions that can respond to incoming queries it also lets us easily model our different data types like authors blogs reviews Etc and decide how they're all connected on the graph by making something called a schema so we'll talk more about that in the next lesson but for now let's go ahead and make a new node project and install Apollo server alright so I'm on the Apollo docs right here Apollo server and I will leave this link down below just click on get started and this is going to show us how to make a new project with Apollo server so the first step is to make a new directory then see the internet and then we initialize a new project a new node project using npm we also set the type to be module and that allows us to use es6 modules so we can say import something from something rather than require and it also allows us to use top level awaits as well once we've done that we have to install a couple of dependencies graphql which is the meat and bones of graphql we need to install that but also Apollo server and that's the graphql library that we're going to use which makes it really easier to spin up a graphql server make schemas types respond to queries using resolver functions and all that jazz so it just makes working with graphql so so easy so we're going to install both of those right here now if you're using typescript then you can follow these directions we're going to be using JavaScript and basically we're just opening up the index.js file or rather we're making one and then opening the the file up and notice here we have that type set to module inside package.json as well so once we've done that it's all set up and we can go ahead and start defining the schema the resolver functions and all that stuff so to begin with let us go up here I'm just going to copy the installs up here so these two things so we can use them in our project alright so I've opened the terminal right here and navigated to this directory where I want to make the project then I'm going to say npm init and then hyphen Y and that's going to create our package.json file for us I also want to say npm PKG and then we want to set the type to be equal to module that allows us to use es6 modules we'll see that inside package.json in a second then I'm going to open up this director written Visual Studio code so codes and a space then full stop press enter and it's going to open up this project for us so inside package.json we can see that the type is module awesome okay so now we need to install those dependencies so open up a new terminal and you want to paste in that npm install that we grabbed from the Apollo docs so it should be at Apollo forward slash server and also graphql so press enter to install those dependencies all right and now that's done the next thing I'm going to do is create an index .js file and this is where we're going to set up our Apollo server for graphql so the way we do this is we first of all import a couple of things so I'm going to paste these in we import Apollo server from at Apollo forward slash server that was the package we just installed and then also we import this thing start Standalone server from ad Apollo forward slash server forward slash Standalone so basically this Apollo server is first to set up the server and configure it and tell Apollo how to handle all of our different types of data and respond to queries and things like that this one right here this is just to start up the server so we can start listing for requests so after we've imported both of those things I remember for this to work these import statements we need to be saying the type is module over here anyway after we've done that we can do our server setup so we can say const server is equal to new Apollo server like so so that's this thing right here all right like so and then down here I'm going to come back to that in a minute but down here I'm going to say const and then URL a destruction here is equal to a weight and then starts standalone server so that's the other thing we imported and then we pass in this Apollo server we just created and then as a second argument an object to say right here we want to listen to a particular port number so we're passing object as the value here and we say the port is four thousand and then down at the bottom I'll just do a little console log console.log and then in here I'll say server ready at Port and then it was four thousand Okay so we've got the basic setup sorted now we're using Apollo to create a new Apollo server and we start the server using this method down here now the Apollo server takes in an object as an argument and that object expects two properties the first is one called type defs which is short for type definitions and these are basically descriptions of our data types and the relationship they have with other data types so that's what we're going to be looking at in the next lesson but the other property is a resolver's property which is basically a bunch of resolver functions that determine how we respond to queries for different data on the graph so in the next lesson we're going to look at that first property type Deft and we're going to make up our own schema all right then my friends so now we're going to make some type definitions and then later on as well some resolver functions which we can then pass into the Apollo server so it can do its magic with them so let's start with the type defs what are type defs well type defs are definitions of the different types of data we want to expose on our graph for example we might make a type def for an author data type and specify the different fields that author might have like a name an avatar URL a bio Etc and we might have one for a game which is a title a price a platform Etc so these would be the different types of data that we want to make available on the graph that a user can then eventually query and the combination of all of these different types and the relationship to other types and the kinds of queries that can be made combine up to make something called a schema so the schema is something that describes the shape of the graph and the data available on it and normally your graphqbal schema the data that's available on the graph will be fairly similar to the data you're storing in your application database now it can be different they don't have to fully match or anything because graphql is a layer between your database and clientside queries but generally speaking the schema will probably look fairly similar to the kind of data that you have in your database so let's try making a schema then with a few different types of data that we want to add to the graph now to do this I'm going to make a new file called schema.js and inside this is where I'm going to Define all of my different types of data now before we do anything inside here I want to show you a package I've got installed so just typing up here graphql and it's this one graphql syntax highlighting so what this does is it allows us to have syntax highlighting for our different types in our schema because without this we wouldn't get that so if we scroll down it might show you an example you can see down here if we keep on going this is how we're going to be using it using a template string and then we start the template string with hash graphql and if we do that when we're making our types inside that template string we're going to get syntax highlighting on them so definitely install this package first of all or a similar one then if we go back to the schema file the way we're going to do this is by first of all exporting a constant because we're going to use this schema inside this index file over here so we need to import it later so make sure you export it first we'll call this type defs and we set this equal to a template string and like we just saw we started with hash graphql and notice when I press L now it goes green to Signal we are going to get syntax highlighting for this now inside here we're going to Define our different types and built into graphql there are five basic scalar types that we can use so they are ins which are just basically whole numbers floats which are decimal numbers we have strings we have Boolean types and also we have a special ID type as well now the ID type is something that graphql uses as a key for data objects now the basically serialized as strings and that's how we're going to declare the IDS in our data when we make it later but they are their own unique type in graphql and these five types right here are going to be the ones you find yourself using pretty much 99 of the time you can make your own types to build on top of this and use them which we'll see kind of later on but yeah these are the types we're going to be using so let's delete that and then go up here now we want to make different data types for our different types of data that we're going to have later on now we're going to have three types of data we're going to have game objects we're going to have review objects and also auth objects so they're the three different types we need to Define inside this template string now the way we make a type is by saying type first of all then the name of the type so we'll start with game and then inside here we'll Define the different properties that a game data type should have so it should have an ID property and then we do a colon and we say what data type is that using the five different types that we just saw well this is going to be of type ID then the second property is going to be a title because every game needs a title that's going to be a string and then the third one will be a platform now that could be a string as well however it might have multiple platforms so ideally we want this to be an array of strings and we can say that something is an array of a certain type by just putting square brackets around it so now we're saying the type of this property should be an array of strings all right so at the beginning if we were to make a new game using this type later on there's nothing to say that these are required Fields now we can make a field required by adding on the exclamation mark at the end of something if we don't have that then we're basically saying this is allowed to be null if we have the exclamation mark we're saying it's not allowed to be null so I want all of these to be required so this one this one and also this one now right here this exclamation mark is outside of the square brackets meaning we must have a value for platform which is an array of strings but the arrays sorry the elements inside that array can be nullable at the minute because we don't have an exclamation mark after this so we need it there as well to say that this string can't be nullable all right so we need two here one at the end of the entire value type and then one for the type inside the array as well okay so that's the first type done let's do another one I'm going to say type or review this time and then inside here we also want an ID which is of type ID required and then we also need the second property and by the way you don't need commas here the second property inside the review which is going to be the rating and that's going to be an integer also required and then the third one will be the content of the review and that is going to be a string also required so that's the second type the third one is author so type author and inside here again we need an ID which is required we also need a name for the author which is a string also required and get rid of the commas this is just habit and then the third one is going to be the verified property and that is going to be a Boolean and this is just basically to say whether an author is verified on a sign we don't need that I just want to demonstrate the different types that we can use okay then so now we've made three different types Game author and review now there's one more special tag that we need to make and that's the type we're going to call query now the query type is something that every graphql schema that you make needs to have it's not optional and its job is to define the entry points to the graph and specify the return types of those entry points so for example if I want users to be able to query the review data that we have and get back a list of reviews then I need to specify that inside this query type so I could make a field called reviews and then tell graphql that we expect the return type of this entry point to be a list of reviews and now if we left the query type like this we're essentially saying we only want to expose that one single entry point to the graph meaning a user would only be able to enter the graph at this point and then they'd be free to navigate around the graph to eventually get related data but they wouldn't be able to jump in at any other point whether that be a single review instead of a list of reviews or an author or game because we've not specified those entry points right here so this query type is our way of gatekeeping Entry onto the graph if you like and deciding where a user can jump into it initially so let's make some more entry points for our users so after reviews we shall say games and when a user lands on this when they request all the games we're going to send back a list of Game objects and the final one for now is going to be authors and same again it's going to be a list this time of auth objects now eventually we're going to allow Landing points for single reviews single authors and single games at the minute we're just allowing the user to land on a list of reviews to grab them all we'll see how to land on a single one later on so then now we've defined our types and we've also made a query type to say where a user can essentially land on the graph or where queries can start from the next thing we need to do is pass all these type definitions into the Apollo server that we made in the previous lesson so first off make sure these type defs are exported from this file so that we can then go ahead and import them in the index file somewhere near the top so do that first of all and then once you've done that we can then pass them into the Apollo server that we created as the first argument so that Apollo server knows about our different types and query entry points and I just said as our first argument I meant the first property in the object argument but anyway that's our first step completed making our type defs to map out what the graph looks like I also said that we need to pass another property into this Apollo server and that was a resolver's object which basically contains a bunch of resolver functions and the resolver functions are there for us to handle any incoming requests and return data to the client because at the moment all we've done is Define what the graph looks like in terms of the data types that we have and the entry points but we've not yet said how we want to handle requests or queries for that data and that's what the resolver functions are for so you can kind of think of the schema and the type definitions that we set up as like a map for Apollo to structure the graph but they don't actually handle any queries and then we make resolver functions to handle the queries based on our schema and type so I hope that makes sense so in the next lesson we're going to take a look at that and we're going to try making some resolvers for the different types of data that we're making available we're also going to set up some domain local data that we can use on the server as well so that we've got something to send back to the client so that's coming in the next lesson right then so in the last lesson we made our type definitions to describe the data on the graph and also specify the entry points to the graph using the special query type and we pass those into the Apollo server so it knows how to set the graph up next up we need to make some resolver functions which allow us to decide how we respond two queries to the graph so it might be that if a query comes in for all the games then we could maybe fetch all the games records from a database and return those as a response now in our case we don't have a database setup for this and instead I'm just going to use some local data stored in a variable in another file but you could quite easily hook this up to whatever database you prefer and work with that data instead so for now what I'm doing is making a new file called underscore db.js which stands for database and this underscore thing isn't necessary it's just a little naming convention I sometimes use when I'm making a data file but anyway inside this file I'm going to paste in a bunch of data which is essentially just three arrays stored in variables one array for the reviews one for the games and one for the authors and we can see the different properties that these objects inside the arrays have are the same ones that we defined in the types that we made in the last lesson the only difference is that the reviews objects we have a game ID property and also an author ID property and this is for later when we start to talk about how data is related but the rest of the properties match up to the ones that we defined in our different types so if you want to grab this data as well you can do it's all up on my repo I'm going to leave the exact link to that file to grab this data down below the video anyway now we have our data let's start making some resolver functions for the three entry points that we defined in our query type because we need to send a response for queries to each of those so then to make our resolver functions we'll first make a new constant called resolvers and then we're going to set that equal to an object and inside this we can make resolver functions for each different type that we defined now to begin with we want to make resolver functions for the query type because that root query type is where we Define entry points to the graph and specify what data should be returned for them we'll also be making resolver functions for other types later on as well like the review type and author type when we start talking about related nested data but for now we just want to make resolver functions for every field defined in the root query type so that's one for reviews one for games and one for authors and to do that we make a property called query capital Q which matches exactly the type name and this property is going to be an object as well and now we can Define in this object resolver functions for each of the properties defined on our root query type so the way this is going to work is that we need basically a resolver function for reviews called reviews one for games called games and one for authors called authors and the names need to match so if we go over here our first one is going to be for games and then this is a function which returns some data and basically we want to return the data to a user that they've requested now they've requested games so we need to send back an array of game objects now in order to do this we need access to this DB file so let me import that at the top I'm going to come to the top and say DB and then just paste in this import so import DB from dot forward slash underscore db.js and then down here we can use this to say DB Dot and then whatever the property is down here so we've got games authors and reviews that match up to this data so what you want to send back DB dot games and that's all there is to it we're sending back the array of games now remember when a user makes a query they can do so like this so let me just do some comments like this and if they make a query they might make a query that looks like this games and then inside here they want specific properties like just the title now if we're returning the full array right here you'd think well we're returning the ID the title the platform as well however Apollo handles that for us all it needs to know is where to grab the data and then if we're just requesting the title from each of the games it will do its magic on this data to take out any of the other stuff like the platform and the ID and it will just return the title property for each one so we don't have to worry about which fields are returned Apollo server is going to do that for us okay which is really cool so let's get rid of that that's the first resolver function done that's simple so the second one is going to be for reviews let's do that come back to index and we'll say reviews and this is also a function we need to return DB dot reviews and then the final one is going to be for authors so let's do that authors and then inside here we need to return DB dot authors all right and that's it we've made our three now basic resolver functions for this data over here and that's pretty much all we need to do so before this works we need to pass this resolvers object into here as the second property on this argument so let's do that we'll say resolvers and that's it so now what we want to do is start up this server so that we can test it from the front end so let me do that by opening up the terminal and if you've got node one installed you could type node Mon and then the name of the file which is what I'm going to do and basically what node mod does is it restarts the server every time you make a change to the server otherwise if you're just using node and then the file name you need to manually cancel the server every time you make a change and rerun it to pick up that change so we're going to say nerdman and then the name of the file we want to run which is index and hopefully oops we get an error so what's the error so refuse did you mean review let me have a look at this so we've got reviews down here let's go to schema oops there it is okay so this shouldn't be plural because it's a singular type Insider list all right so save that and now hopefully this is gonna work I'm going to cancel out this process and run it again and okay the app crashed again we have another error so let's have a look what this one is okay address is already in use okay so that's because I've got another instance of a graphql server up and running so let me just close that down first of all okay so I've just done that I'm going to cancel out of this again and try running it third time hopefully this is going to work now Okay cool so now the server is ready at Port 4000 awesome all right so now if you visit localhost Port 4000 in the browser you're gonna see Apollo Explorer so it automatically spins this up for us so we can test out our graphql server and let me just take you on a quick tour of this first of all if you go to schema then you're going to see the different queries that we can currently make so you can see it's looked at our code and it's seen the different queries we can make the different entry points our authors games and reviews right here and it also shows the data type so if we click on this it's going to show the different fields that that data type has and it shows what we can base get back all right so we have those three data types right here also if we look at scalar types it's going to come down here show us the different things we're using directives okay we don't really need to worry about directors for now if you go back to Explorer this panel on the left is where we're going to make the queries this is where we're going to get the response down here you might see another panel as well this is for variables which we're going to look at later on so let's make our first query you can name this something different if you want so I could say something like games query to get the games you don't have to name it that it doesn't really matter what it's called but now I want to get the games so I can click on that and remember we have to open up our curly braces and specify What fields we want from this particular resource so I could say that I want the title of each game and also the platform of each game so now if I click on this we can see we get an array of all the games inside a data object so we have this one the title and the platform title and platform and so forth so we're getting all of the games awesome all right so let's change this to something else let's try the authors and from each one we want the name and we also want the verified status click on this and it's going to fetch those for us Mario verified true Yoshi Falls Peach true awesome final one let us try the other resource which is reviews and then from here we can get for example the ID the rating and the content I'm going to click on this and we can see all those reviews now like I said you can just request some of the field so I could get rid of content and I could get rid of ID and just say that I want the rating click on this and now it still fetches all the reviews but we only get that rating property so we're not over fetching which is awesome so even though we explicitly return the full array of data Apollo is using our resolver function and the data we return to automatically filter out any of the fields the user doesn't need which is awesome so this is all working now but what if we wanted to fetch just a single review or a single author or a single game well for that we need to use something called query variables and we'll talk about those in the next lesson all right then gang so now we have some type definitions which describe the data we have on the graph and also specify the entry points to the graph which are to query all the reviews all the games and all the authors and we also have resolver functions for each of those queries too which return the data so it can be sent to the client but what if a user just wants to send a query for a single review or a single author or a single game well currently that wouldn't work for two reasons first we don't specify that a user can enter the graph in that way in the root query the only three entry points that we have are queries for other reviews all the games or all the authors and secondly we don't have any resolver functions to handle queries for single items we only have them to match these three entry points for lists of data so we need to address both of those things starting with this root query type and the way we do that is by just adding more entry points to the graph so underneath reviews I'm going to make another query available called review singular for a user to fetch a single review and that query is going to return a single review object now we need to add one more thing to this and that's a query variable to say that when a user makes this query we expect them to send a variable along with it as well and that variable would be the ID of the review that they want to fetch because we need the ID to find the review in our data in order to send it back to them so to do that we just add parentheses after the query name and then we can add a variable name which I'm going to call ID and we also need to specify the type of this variable that we expect as well which is going to be the ID type and finally we want to say that this variable is required when someone makes this query so it can't be null and we know to do that we can just add the exclamation mark at the end of it so now we're seeing a user can make an initial query for a single review but they must pass in this variable to the query which must be an ID so now we just need to make a resolver function for this query as well so back in the index file we can add a new function inside the query property of the resolvers object and that function is going to be called review singular again and inside this function we basically need to return a single review based on the ID variable that a user passes into the query so how do we get that ID in this resolver function well we automatically get three arguments available to us in these functions that we can use the first one is something called appearance which refers to the parent resolver in a resolver chain that probably doesn't make much sense at the minute but hopefully it will do later on when we start working with related data and nested queries I'm going to rename this first one to underscore because we don't need that in this function the second one which we do need is called args which stands for arguments and it's on here that we can access any query variable since with the query the third one is a context object which we can use for supplying context values across all of our resolvers such as authentication information or something like that but we don't need that third argument right now so we can get any query variables that a user sends in the query from this args object and what we want is the ID variable so we can just say args.id to get that and we can use the ID now to find whatever review has the ID in our data and then return it so the way I'm going to do this is by just taking db.reviews again and then I'm going to use the find method to find a single review so this find method basically finds a function for every item inside the reviews array and for each item we can take in a review as an argument so if we go back to the data if we're cycling through this it will refer to this first then this then this then this okay so each time we cycle through one of these items we can check the ID property of it now if the ID property matches the ID on this argument then we want to return true inside this function and when we return true it no longer needs to cycle through the rest of the array and it just returns that value for us right here okay so we need to say get the review dot ID and see if it's triple equal to args.id so when that is true that is the review that we want to return to the user hope that makes sense and that's pretty much all there is to it so now we can save this and test it out in the browser okay so how do we actually send a query variable from the front end when we're making a query well first of all after the query name we can use parentheses to declare any variables that can be passed into this query as a whole now that can be multiple variables in the future but for now it's just going to be one variable the ID and if you were using something like react to make this query you could pass those variables into the whole query from a react component and then within the query we can use those variables for different parts of the query so first of all let's declare what variables can be passed into the query as a whole so inside parentheses we declare each variable that can be passed in using a dollar sign and then the variable name so we can say dollar sign and then ID and then after that we use a colon and specify what type of data this variable should be in our case that's the ID type for all intents and purposes it's going to be a string that we pass in but it's an ID type now in order to pass that variable into the query from Apollo sandbox you can come down here to the bottom and select variables and then you can make a Json object of key value pairs one for each variable so we can add the ID one and set it to be one in quotations so now these variables are going to get passed into the query and populate the arguments inside the parentheses right up here so this variable will now have the value that we passed in from down here and we can use that variable when we request a single review inside this query so let's do that let's ask for a single review and then passing the ID of the review that we want to find so we can say ID is equal to the ID variable which in turn is equal to one and that's all we have to do to say that we want that one single review we can also specify which fields we want back as well though for example the rating and also the content properties so now we're asking for one single review with the ID of one and we just want these two fields for that review and if we hit send we should see the response from the server which contains that review and inside it the two fields that we asked for awesome so that's how we use Query variables from the front end now let's try and do something similar for the other two data types that we've got or rather than so back in a schema let's define our different entry points so underneath games I'm going to do a single one so game and that's going to return a single game object now again we need to declare that this needs an ID argument or variable which is of type ID and that's required and same for this down here author and again we need to define the query variable which is of type ID and required and that returns a single author so that's the schema done back over in index we need to basically do the same thing for author and game that we did for review so I'm just going to copy this and I'm going to paste it up here change the name of this to game and we still need the args the whole logic is the same however we just need to rename this to game and this to game as well so we're basically returning the game where the IDS match and then down here we need a comma first of all and we have authors so let's paste this in again do a comma change this to author singular and we'll change this to author and change this to author and also we need to change this one right here because we want to look inside the games array and this one should be the author's array I think that's pretty much it so now they should all work for the other two types as well but let's check it out in Apollo Explorer so let's give this a whirl I'm not going to change the name because it doesn't really matter but we're always still passing in the ID and we'll just pass in one it doesn't have to change I mean we'll change it to two just to have a look and then this time instead of review in fact let's try and review first of all to see if we can get a different one back which we do okay now let's change this to game with the ID of two now we need different fields for the game I think we have a title and also a platform I'm also going to return the ID just to make sure it's getting the correct one and we can see the ideas too the title and also the platforms uh let's try a different one so we'll say three here send that okay yeah that works and then finally let's try the authors so singular author I'm gonna go back to one and we want the name and we'll also get the verified status that's it verified like so and the ID press this send button and we can see this works as well let's change the variable to two and yeah it brings back the Yoshi one the different one awesome so this is all working now that's how we can send query variables in our queries all right then so things are starting to take shape now we can query lists of data and also we can query single data items as well using query variables and now I want to take this one step further and talk about related data in graphql so if we open up the DB data file and look at the reviews data we can see that each of you has an auth ID property and also a game ID property and that's the way in our data we're relating these different things so that every review has an Associated author an Associated game as well so if I was to pluck out a random review I would then be able to try and find the author and the game associated with that review and likewise if I was to pick out a random game I could look at the ID of that game and then run through the reviews array to find any review where the game ID matches that meaning I could pick out all the reviews associated with a single game now that's how this looks on the data side of things but currently in our schema we don't really Define any relationships between the data so when Apollo makes our graph based on this schema it won't know that every game has a list of related reviews at the moment and that every review has a related author and game and also that every author has a list of reviews that they wrote so we need a way of defining those relationships in our schema so that Apollo knows to make our graph that way with those relationships alright so let's start with the review type right here so we know that every review is associated with a game and an author so I could say that the game is going to be of type game like so and that's required right because we can't have a review for no game that's not going to exist also we have the author property which is going to be of type auth again required because every review needs an author alright so down here every game is going to have a list of reviews so we'll say reviews it's a list so square brackets and then inside the type is review now the types inside this can't be nullable the data inside it so we need exclamation mark right here but that's not to say that we have to have reviews we're not going to put exclamation mark right here this can be nullable as a whole if the game doesn't have any reviews but if we have some data inside this list it has to be a tight review that is required it can't be null okay so same down here for the author let's say the reviews by this author are going to be a list of review objects again exclamation mark but none at the end because there can be authors that haven't written any reviews yet all right okay so now we've made those connections in our different types we also need to make some resolver functions to resolve any nested queries for the related data for example I might query it for a single game and then make a nested query for all the reviews for that game and that query would look something like this where the initial jumping in point is for a single game but then we also ask for the reviews related to that game along with the rating and content for each review so at the moment Apollo doesn't really know how to handle that nested query for the reviews inside a specific game the only way it knows how to resolve reviews currently is either by grabbing all of them or just by grabbing one of them based on the ID and these are both root queries defined in the query type in our schema so it doesn't know how to get a subset of reviews based on the ID of a particular game we don't have a resolver for that so the way we make this resolver is not by making it inside this query object because these are resolvers for entry points to the graph as defined by the query type that we made in the schema so instead because this nested request is associated with a game object we make a new property inside the resolvers object called game which is also an object and then inside this we can make a resolver function called reviews where we can tell Apollo how to get all the reviews based on the pair inquiry for the single game so I'm going to make a function called reviews to do this and it's going to take in that first argument called parents now remember I mentioned this one in a previous video but we didn't need it back then however now we do need it so the way this is going to work is because our entry point for the query is a single game Apollo will run that initial resolver function inside the query object to get that single game then to resolve the reviews for that game it's going to look to the game object since that's what we just grabbed right again and then it's going to look for the reviews resolver inside that to grab the reviews so it's inside this function that we tell Apollo how to do that but how do we know what game we're getting reviews for well we can access the ID of the game via the parent argument because the parent argument is a reference to the value returned by the previous or parent resolver now in our case that's going to be the game one so the initial one inside the query object so that parent argument will basically be a game object and that game object is going to have an ID which we can then use so we can use the ID now to return all the reviews associated with that game ID and the way we're going to do this is by first of all returning DP which is the data remember that we imported and then we want the reviews array on that then we're going to use the filter method so what we're going to do is filter out any review that doesn't have the same game ID as the ID on the parent because if they are the same and we return true for each of those then it's going to keep those in the filtered array and that's what we want any review associated with the game where the IDS match if they don't match it's going to filter them out and they're not returned in that array so we fire a function for each item inside the array I'm going to refer to each review item as R and then we want to return r dot game underscore ID remember that is the property if we go over here each of you has a game underscore ID to associate it with a particular game and we want to check if that matches with a particular game the game we've just queried so we'll say triple equal to the parent which has the ID property because that is essentially the game object so where they match they're going to stay in The Returned array because they're associated with each other and that's what we want we want to return all the reviews associated with that game where they don't match the filtered out so we don't return those okay so let's save this and give it a whirl okay then so I've got this query already set up so we're using a query variable ID which we're passing right here so id2 we ask for the game with the ID and grab the title but also all the reviews associated with that particular game ID and we'll get the rating and the content from each one so let's give this a whirl and yep cool so we can see we get the game title and two reviews right here and what I'm gonna do is also put in here the game ID let me do commas here like so and then I'll say the game underscore ID that should be two oh in fact we can't do that and the reason we can't do that is because we didn't specify that on our schema all right so I'm not going to do that but if you remember in our different types on the review object we didn't add the game ID that is something you could do if you wanted to but it's not going to work here because I didn't add it but either way we can see that this works and if I put in a different ID like three and try that out we can see now we get a different game with one review I'm gonna put in an idea of one here and yeah that's working as well awesome Okay so we've sorted out related data when it comes to finding reviews for a game but reviews can also be associated with an author can't so if we take a look at author they could have a list of reviews as well so let's do the same thing for author so like we had a game property this time we need an author property like so which is an object and then we want the reviews resolver for this where we're taking the parents and then inside there we're going to do essentially the same thing as this so let's return reviews.filter this time we want to check the author ID is equal to the parent ID all right so the author ID on the review remember we have that right here we're checking this against the ID of the author we selected and then we're only returning the reviews where if this was the author for example one we'd return this one and this review okay so let's save that I'm not going to test it just yet because there's one more set of resolvers I want to do and that's for the review so imagine we select a single review if we go to our schema we can see that each review has an Associated game and author so they would be nested queries so we need to make a resolver function to get the game associated with that review and also the author so two resolver functions right here so let's do the auth first of all and we're taking the parents so the pair at this time is going to be a single review and we're going to return DB dot authors and then we're going to find a single author because this isn't a list of authors associated with a single review we only have one author per review so we're finding a single one so we fire a function for each element in the array and I'm going to call each element a for author and then what we want to do is grab the ID of that so a DOT ID and we want to return true when it's equal to the parent which is the review object dot author ID so where they match it means that author is associated with this review and we're returning that single author now we need to do the same thing but this time it's going to be for the game because again a single game is associated with a particular review so game and then we'll change this to G change this to G for game and then this is going to be game underscore ID and that's all there is to it oops this needs to be games right here cool so now we have our resolver functions for nested authors and games inside a review object and also for reviews inside an author alright cool so let's save this and try it out again all right then so let's start the starting off point as author we'll keep the ideas one that we pass in we want the author name and then we'll get the reviews associated with the author so we'll press that and we can see Mario has these reviews right here these two awesome and then let's try author with the ID of two like so so we have Yoshi and these three reviews awesome so that's working now what I'm going to do is I'm going to copy this and I'm going to make a new query so we can come back to this and I'm going to paste it in here and just change it so we'll change this to review query and then we'll pass in an ID again so let me go back here and copy this like so paste it in and then we want a single review right here with the ID we're going to get the rating of that review but then also we want the associated game and for the game we will get the title and the platform like so oops platform press send and we can see now we get the review and the single game associated with that review which is awesome we also can get the author Remember so let's do that as well and for the author we want the name and also we'll get the verified property as well which is true or false so now we get the author as well awesome change the ID and those should change as well yep cool awesome so this is all working now not only this but what I could do is I could get a single review and the rating get the game that is associated with that review and I could also say well I'll tell you what get me all the other reviews associated with that game and from those I could just get the rating now the reason I can do this is because we have a resolver chain so the first one the entry point is for a single review right so we use that initial resolver function defined inside the query object to get that single review then we move on to the game resolver inside the review object so it gets the game associated with that review that's the quick that's the resolver function we just made and then since we're asking for reviews inside the game it goes to the resolver function for reviews inside the game object and this time the parent refers to this right here so we have this kind of resolver chain and we always have access to the previous resolver as the parents so we can Nest as much as we want here and this is going to work which is awesome so we'll get the review and the rating for that review the game associated with it and all the other reviews along with the rating for that particular game awesome all right then my friends so now we can do quite a lot in terms of making queries to fetch data and related data as well which is cool but at the moment all we can do is fetch the data we can't add new data or edit the current data or delete data or any of that jazz so I want to address that now by talking about mutations and the mutation is basically a generic term in graphql for any kind of change that we want to make to the data whether it be to add new data delete data or edit current data so the first thing we need to do is Define our allowed mutations in the schema by making a new type which is called mutation and it's inside this type that we can then decide how users can mutate any data for example I might want to expose a mutation called delete gain and for that mutation we need an ID argument to say what game should be deleted we also specify the return type as well after a user makes this mutation much like we did for the root queries so for example once a user deletes a game from the data I might want to send back an updated list of all the games after that one has been removed so I'd use an array of game objects right here okay so that's the mutation defined but we also need to make a resolver for the mutation as well inside our resolvers object called mutation so right at the bottom down here comma and then mutation which is an object and we just make resolvers in much the same way as we did for these for these Etc so we want to make a resolver called delete game right here so let's do that delete game like so and it also takes in the same arguments so we have the parent we also have the args over here and then context if we want it so we don't actually need the first one which is parents to delete a game but we do need the arguments because we want the ID of the game that we want to delete so inside here oops inside here what we want to do is basically update the value of the games array because that's what we're editing right here we're deleting a game so we want to remove one right so let's say that DB dot games is equal to something new and that's going to be DB dot games dot filter and by the way in a real application you probably use a database right like maybe mongodb or something like that so you would use the library for mongodb to connect to that and just delete a game this way we're just using local variables as data because then it's easier for me to keep the focus on graphql all right anyway so dot filter so we want to go through this array and we fire a function for each game which I'm referring to as G inside this array and we want to return false whereby the ID is equal to the ID on here and we're returning false in that scenario because if we return false it filters it out of the array and therefore the filter array is not going to include that game that we want to delete so we say g dot ID is not equal to args.id so where they're not equal it returns true and it keeps that in the array where they are equal that's the game we want to delete it returns false and therefore we filter out the array all right so now we also need to return something and we specified the return type to be a list of games so the updated games array so all we need to do then is return DB dot games like so all right so let's save this and give it a whirl so how do we actually make a mutation from the front end because when we make a query we use this query keyword give it a name and then specify what we want now with a mutation it's a very similar we just specified that it's a mutation not a query it anymore then we can give this a name so I could call it delete mutation we can specify any variables that need to go into this query and we do need a variable that's going to be the ID and that's going to be of ID type and then inside here we can specify what mutation we want to make and that was called delete game so let me get rid of this because it's automatically created it for us and this should be ID instead to refer to this so now we need to pass in the ID variable down here and that is going to be 2. so we're deleting the game with the ID of two and remember we get back as a return an array of games with that game deleted so an updated version of it so we can specify now what fields we want back so I could say we want the ID of the game back the title and the platform so let's give this a whirl delete mutation all right so now we can see ID 1 and 3 and 4 and 5 but no two because it's been deleted now obviously when the server restarts that is going to be there again because we reinitialize the variables and all that jazz this is not permanent this deletion it's only while you know this current session is going on if you like but as soon as we restart the server that's going to return but like I said you'll probably use a database where you'll have a bit more persistence than this so anyway now we've deleted a game Let's also try adding a new game okay so now we've made this delete game mutation next I want to try making a mutation whereby a user can add a new game so how do we do that well first of all we need to go to the mutation type in the schema and we need to add the mutation which I'm going to call add game and it's going to accept some arguments so we do need parentheses but we'll come back to those in a second now as a return value we're going to send a single game object back to the user the one that we just created so for the arguments of this mutation we need to basically grab all of the fields that make up a new game minus one of them the ID because we don't want the user to decide the ID of the new game that they add instead we're going to generate a random ID in the resolver later for this mutation but we still need the game title and maybe the game platform maybe the game price if there is one basically any property that makes up a new game so we could add each of those fields as different arguments inside here or we could make a new special input type in our schema which allows us to group together several arguments into one type and then that can be used as a single argument elsewhere like in this mutation so the way we do that is by coming down here and first of all saying input instead of type which says to graphql that this isn't an actual type of data but more of a collection of fields that we can use in a mutation as a single argument for example so inside this then we can choose What fields we want this input to have and also the type of those fields so I've said right here we need two properties the title which is a string and also the platform which is a collection of strings or a list of strings and they're both required we don't want to add in the reviews because we're not making a review we're just making a game and then later if you were to have a review you would associate it with a particular game we don't need to do that right here when we're adding a game for the first time but now what we can do is we can say okay this mutation takes in a variable called game and that is going to be of type add game input and it's required so when we're making this mutation from the front end it's going to require us to add a game variable which looks something like this an object with these two properties okay so now we have that mutation sorted we can go back to the index file and we can add that mutation right here after delete game so I will call this add game and we're going to take in the args argument so we don't need the first one which is parent so underscore for that then args and the reason we need that is because the game property is going to be on the arguments because we're sending that from the front end and on that game it's going to be the title and platform properties so what do we want to do here well we want to make a new game object and add it to the game array right so we can make the object first of all by saying let's game equal to an object then we're going to spread out so dot dot dot args dot game and it's dot game because that is the name of this variable and on that will be those two properties the title and the platform so we're adding those two properties to the new object and then the reason I'm spreading that is because we also need an ID property which we need to randomly generate now you might be better off using some kind of random uid generator library or something like that I'm going to use the mass object to generate this for the sake of our tutorial but we're going to say math.flor then math dot random and this generates a random number between 0 and 1 in decimal format and then we'll times that by 10 000 so what this will do is generate a random number between one and ten thousand and it will have decimal points as well but then what we're doing is flooring that so it becomes an integer okay and then we'll convert it to string like so so we have our ID property we also have the other arguments that we passed along and we have the new game object now we just need to push that to the games array so we can say let me come back up a line DB dot push and then we're going to push on in fact not db.db.games.push to push onto the games array and we push on the new game awesome and then finally we return that new game that we created because if we go to the schema we can see we return a game type all right so that is pretty much it my friends so let's try this from the front end okay then so let me just copy this and then we'll go over here and paste it in and we're going to call this one add mutation we also need to pass in the ID no we don't in fact do well we need to pass in a game object and that is a type add game input like so all right so now we need to specify that the game is required here like so and then this is called add game instead alright so now down here we need to pass the variables in so remember we need a game property and that is an object and inside the object we have the title so we'll just say a new game very original right and then we also need a platform and that platform is going to be an array and inside here we will say switch and PS5 like so so remember it Returns the new game back and we're requiring D3 feels from The Returned game so let's try this add mutation and you can see now we get this random ID 263 the title and the platform awesome so that's worked and now I'm going to go back over here and I'm going to just require all of the games right here so games like so we don't need these anymore just so we can see an updated list of games and we'll get the title of each one and we don't need these parentheses let's run this and you can see now a new game so it's been pushed on to the array awesome so in the next lesson we're going to look at one more mutation and that is to update existing data all right then so in the last lesson we made our first two mutations want to add the game and one two delete a game and for adding a game we made this ad game input where we collated two Fields together so that could be our variable right here just this one variable called gain which has this kind of structure so we're gonna do one more mutation now and that is going to be for editing a game so I'm going to come down to the bottom and I will make a new one called update game like so now in here we need some arguments now what do we need we need the ID of the game that we want to update and we didn't need an ID here remember because we're adding a new game that doesn't have an idea yet but when we're updating existing data we need the ID of the game that we want to update so let's put that in but we also need any kind of edits that we want to make all right so what I'm going to do is make another argument called edits and for this I'm going to create a new input so let me copy this and paste it down here and I'm gonna call this edit game input and then we'll set that here edit game input like so and we're not going to make this yeah in fact we will make this required okay and this is going to return game now these things right here these two Fields they are the same so you might be thinking well why didn't we just reuse this one here and the difference is that I'm not going to make these two required because if you go to update a game you might just want to update one of the fields like title so I don't want to make there for the platform required if you don't want to update that and likewise if you just update the platform you might not want to update the title so therefore I don't want to make this required so if I reuse this we would have to basically update both of the fields in order for this to work but I don't want to make a user do that so by making a new one where they're not required it's a bit more flexible and also I'm not putting the ID in here like so and instead of specifying it here and the reason for that is because it's not really an edit is it so I don't want to group the ID into some kind of edits object I'd like that to be its own separate argument so let me delete that save it and now we can create a resolver function for this update game mutation all right then so let's add this in down here update game like so and we don't need the first argument the parent but we do need the arcs because the edits and also the ID are going to be on that and then down here what I'm going to do is just paste in a bit of code and this is what we're using to basically update the games array so we're taking the games on DB and we're setting it equal to db.games.map so we're mapping through the array and basically creating a new array out of it so we fire a function for each item in the array and for each item we check does that particular game that we're currently iterating have an ID that is equal to the ID on the arguments because remember we're going to have an ID property on this right here and if it does match then we're going to return this thing right here G so the current objective you like and spread those so whatever properties it currently has we're adding right here and I'm also spreading args.edits so if for example we update the title then it's going to override the title that's over here that we're spreading does that make sense so that's the returned object right here and that's going to go inside the array then if these don't match then we don't need to change it and we just return the original object to the array so I hope that all makes sense now at the end of this update game mutation we need to return something back to the user so if we take a look at the schema we return the game that we just edited so we shall say return and then we'll say db.games dot find to find a particular game and we can cycle through those and we want to return the game where the ID is equal to args.id because again remember we have the ID argument right here okay cool so now we have that mutation let's try it out okay then so back over here I'm going to create a new tab and I'm going to copy this mutation which is for adding a game I'm going to paste it over here and then I will call this edit mutation and this right here needs to be edit game input and this is called edits this and this right here is edits and dollar sign edits but also remember we need to pass in the ID so we can say the ID is equal to oops I need dollar sign first of all ID is of ID type like so we need the ID right here so let's say the ID is the ID variable awesome okay this is not ad game it's updates game like so and we don't pass in the ID we can pass in a title and a platform or imagine these are what we're going to get back so we can pass in the ID here if we want to for the variables let's copy this again because it's going to be very similar and paste it right here so we're going to have an edits property and we also need an ID property so let's do the ID down here oops done that incorrectly comma here and then ID or set that equal to two and we'll change this to I don't know Dark Souls like so and then we don't need to pass in an update for this so let's just do that so then we're going to get these fields back so what we're doing is we're passing in the edits right here of which we just have won the title and then the ID of the game we want to edit so we're passing both of those in here and then we're using those inside this mutation and we're saying look once you've made this mutation this edit send back the game and give us the title and platform so the title should be updated now so let's do that and we can see now the title is Dark Souls the platform is unchanged if I change instead platform and this needs to be an array of strings now doesn't it and we'll just change this to be I don't know um XBox whatever let's edit that again and now it's just Xbox I can change this now to PS5 if I wanted to and we'll do switch as well and also if we wanted to change the title as well we can do so we'll just say I don't know some other game can't think off the top of my head edit and we can see now we've made those edits awesome all right then gang so that's pretty much it for this series then I really hope you enjoyed it and hopefully you feel comfortable now with the basics of graphql in terms of making a graphql server but also in terms of the query syntax and actually making queries from the front end and if not then I guess thanks anyway for wasting the last two hours of your life watching my videos but yeah hopefully not and fingers crossed it wasn't a complete waste of time but anyway in the future I will do more courses to incorporate graphql like how to use graphql in a next JS site or maybe with super bass or something like that and that's one of the main reasons I wanted to make this course right here so that it serves as a jumping in point to learn the basics of graphql quickly so we can do more advanced stuff in the future
