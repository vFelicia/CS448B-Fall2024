With timestamps:

00:00 - you're about to learn how to program in
00:02 - Java from Farhan hassin children Farhan
00:06 - is an experienced software developer
00:07 - here at free code camp and he is great
00:10 - at breaking down concepts for beginners
00:12 - this is a great course if you want to
00:14 - learn Java and you can follow along with
00:17 - the whole course from within your web
00:19 - browser Farhan will teach you the basics
00:21 - of java using replit replit is an online
00:24 - IDE that allows people to write all
00:27 - sorts of programming languages right
00:29 - within their web browser and repl
00:31 - provided a grant that made this course
00:32 - possible so it's time to learn Java
00:36 - hello everyone welcome to the Java for
00:38 - beginners course I am Farhan Hassan
00:40 - chodri and in this course I will teach
00:43 - you all the fundamental concepts around
00:45 - Java now ideally a programming course
00:48 - usually starts by downloading and
00:51 - installing a lot of sdks or Ides or
00:55 - whatnot but since we will be using
00:57 - rapidly throughout the entire course we
00:59 - don't need to do any of those replete is
01:02 - an online collaborative IDE that you can
01:06 - use right from your browser to start go
01:09 - to
01:10 - www.reply.com and you should land on the
01:13 - page you can create an account on
01:16 - replete or if you already have an
01:18 - account just go ahead and log into that
01:20 - I will just use my Google account to log
01:23 - in once you have logged in you will land
01:25 - on your home page from here you can
01:28 - create a new Ripple by using this create
01:30 - button
01:32 - now from the list of language we will
01:34 - pick Java but just so that you know
01:37 - refleet supports a long list of
01:39 - languages make sure you are giving your
01:42 - new Rebels some descriptive names such
01:45 - as hello world
01:48 - finally hit the create triple button and
01:50 - wait until the process finishes
02:01 - now if you have worked with some other
02:03 - code editors such as Visual Studio code
02:06 - the look of replete should not be very
02:08 - different to you you can change its
02:11 - default layout by going to settings
02:14 - and default layout by default it should
02:17 - be side by side
02:19 - but you can also pick stacked if you
02:23 - like that layout Now the default Java
02:25 - Ripple usually comes with a bunch of
02:27 - code and you may have already guessed
02:30 - that this is the famous hello world
02:32 - program written in Jaffa to run this
02:34 - code click on this run button here
02:37 - and you will see the code's output on
02:40 - the console
02:46 - there you go congratulations on creating
02:49 - and running your first Rebel on the next
02:52 - lesson I will explain what's going on
02:55 - just before we leave
02:58 - remember you can always run replay dark
03:01 - by clicking on this Moon icon and if you
03:04 - prefer dark themes over the lighter ones
03:07 - please go ahead
03:10 - the hello world program is probably the
03:12 - simplest executable Java program that
03:14 - you can write yet it's very important
03:16 - that you understand each part of this
03:18 - program
03:19 - as you may have already guessed source
03:21 - files in Java end with the dot Java
03:24 - extension and compiled byte codes
03:26 - usually end with the dot class extension
03:28 - to see the compiled byte codes on replay
03:31 - click on these three dots on the files
03:34 - menu and click on show hidden files
03:38 - the program starts with a class
03:40 - declaration a class is a collection of
03:43 - related code in Java in every Java
03:46 - source file that is the file with the
03:48 - dot Java extension you can have one top
03:51 - level public class and that class has to
03:54 - match the name of the source file this
03:57 - is because if you have multiple classes
04:00 - in your program like this
04:10 - you will see that the Java compiler
04:13 - produces individual byte cores for each
04:15 - class
04:16 - to avoid any confusion about which of
04:19 - these classes is the entry point to the
04:21 - program the jvm is designed to treat the
04:24 - bytecode that matches the name of the
04:27 - source file as the entry point
04:30 - inside the class there is a main method
04:33 - those of you familiar with C C plus plus
04:36 - or go may already know that the main
04:39 - method or function serves as the NG
04:42 - point to your program
04:44 - the jvm is programmed in a way that it
04:48 - will specifically look for a static
04:50 - method that is named main has Public
04:53 - Access takes an array of string as a
04:58 - parameter and doesn't return any value
05:01 - so you will have to write your main
05:03 - method as public static void main string
05:07 - arcs and nothing else
05:09 - one thing that you can change however is
05:13 - the name of the args array
05:16 - to something like
05:18 - arguments
05:22 - the array holds the command line
05:24 - arguments passed to the program upon
05:27 - execution
05:29 - the
05:30 - system.out.print element method prints
05:33 - out whatever string you pass to it as an
05:36 - argument unlike python or JavaScript
05:39 - semicolons are mandatory in Java so if
05:43 - you leave it out the program will fail
05:44 - to compile
05:46 - that's pretty much it about the hello
05:48 - world program don't worry if you didn't
05:50 - understand all the terms used in this
05:53 - lesson you will have a much better idea
05:56 - about topics like public and private
05:58 - access modifiers Statics classes methods
06:02 - in later lessons
06:05 - now if you try to run the program using
06:07 - the Run button
06:12 - everything works out just as expected
06:16 - another thing that you can change is the
06:18 - entry point
06:22 - this will make sure that replit opens
06:26 - the correct Java source file whenever
06:29 - you decide to return to this project
06:32 - now there are a lot of other options in
06:35 - this dot replete file but those are not
06:38 - important right now
06:39 - the hello world program you have been
06:41 - seeing so far is pretty simple if you
06:44 - want to write more complex programs you
06:46 - will at least need some understanding of
06:48 - the different types of data and
06:50 - variables variable is any entity that
06:53 - can take on different values for example
06:55 - if you want to store your age inside a
06:58 - variable you can do so like this
07:03 - first you will have to write the type of
07:06 - the variable age is an integer or int
07:11 - then you will have to write the name of
07:13 - the variable which is age in this case
07:16 - then you can finish off by putting a
07:18 - semicolon
07:19 - you just declared a variable declaring
07:22 - means the compiler will know that this
07:24 - variable exists however you will also
07:28 - need to Define it you can do so by
07:30 - assigning a value to this variable like
07:33 - this
07:34 - write the name of the variable then an
07:37 - equal sign followed by your desired
07:40 - value
07:41 - in this case the equal sign is known as
07:45 - an assignment operator we'll learn about
07:47 - operator in lot more detail in lateral
07:50 - lessons now you can print out the
07:53 - variable to the console like this
08:14 - and just in case you are wondering using
08:17 - a plus sign is one of the many ways to
08:20 - print out a dynamic value in between
08:23 - sentences
08:25 - keep in mind you cannot use an
08:27 - uninitialized variable in Java so if you
08:30 - remove this line
08:31 - and try to run the code
08:38 - the code will fail with the error
08:40 - message variable age might not have been
08:43 - initialized
08:46 - instead of declaring and initializing
08:49 - the variable in different lines you can
08:51 - do it in one go like this
08:54 - on the line of Declaration
08:56 - after the name of the variable put an
08:59 - assignment operator followed by your
09:01 - desired value
09:02 - now if you try to run the code again
09:10 - see everything's back to normal
09:12 - you can change the value of a variable
09:14 - as many times as you want so if you set
09:17 - the value of the age variable to 28
09:21 - instead of 27 just before printing it
09:24 - out you will see that the value has
09:28 - changed in the output
09:30 - although you can assign new values to
09:33 - the variable multiple times you cannot
09:35 - declare the same variable twice so if
09:38 - you do something like this
09:41 - and try to run the code the code will
09:45 - fail
09:46 - with the error message variable age is
09:50 - already defined in method Main
09:53 - if you look closely you will see two
09:55 - different sets of curly braces in this
09:57 - code the first set marks the start and
10:01 - end of the hello world class the second
10:04 - set is inside the class and marks the
10:08 - start and end of the main method
10:11 - code inside a set of curly braces is
10:14 - known as a code block
10:16 - since the main method is inside the
10:19 - hello world class any variable you
10:22 - declare inside the method will be only
10:25 - available inside the method
10:28 - these are local variables however you
10:32 - can also declare variables outside the
10:34 - method like here in the hello world
10:37 - class code block
10:50 - if you do that the variable will be
10:52 - available within the entire class to use
10:55 - this variable inside the main method you
10:58 - will have to declare it as a static
11:03 - we will discuss the reason behind this
11:05 - in a later lesson for now just remember
11:09 - that is static method can only work with
11:12 - static variables
11:14 - moving out the Declaration of the age
11:16 - variable and marking it as a static has
11:20 - not made any difference whatsoever but
11:23 - if you remove the value of the variable
11:25 - and attempt to rerun the program
11:34 - you will see the program runs without
11:37 - any issues this time and prints out 0 as
11:41 - the value of age
11:43 - this is because whenever you declare a
11:46 - variable in the class level the Java
11:49 - compiler will assign a default value to
11:51 - it for numbers it's always zero now
11:55 - another thing that I'd like to show you
11:57 - is
11:59 - if you redeclare the age variable inside
12:02 - the main method now
12:13 - there will be no problem whatsoever
12:15 - because the initial Declaration of the
12:18 - age variable is not local to the main
12:21 - method
12:22 - so as long as you do not re-declare a
12:26 - variable within the same code block you
12:29 - will be good to go
12:31 - when it comes to naming your variables
12:33 - you can name them anything as long as
12:35 - the names don't start with a number and
12:37 - don't have any spaces in them there are
12:40 - also around 50 words reserved by Java
12:43 - itself as keywords and you cannot use
12:46 - any of them either you can start a
12:49 - variable name with a dollar sign or an
12:51 - underscore but excessive usage of these
12:54 - signs can make your code unreadable in
12:56 - case of multi-word names always follow
12:59 - camel casing when naming your variables
13:01 - if you want to learn about different
13:03 - programming naming conventions I leave
13:05 - the link to this article in the
13:07 - description finally avoid naming your
13:10 - variables using single letters
13:16 - now that you know about variables we
13:18 - will discuss the different types of data
13:20 - keep in mind I have reorganized the
13:23 - source file to better reflect what I
13:25 - will be talking about at a high level
13:27 - there are two types of data in Java
13:28 - there are the Primitive types and the
13:30 - non-primitive or reference types
13:34 - primitive types store values for example
13:37 - int is a primitive type and it stores an
13:40 - integer value a reference type on the
13:43 - other hand stores the reference to a
13:45 - memory location where a dynamic object
13:47 - is being stored we will discuss
13:49 - reference types later
13:51 - there are eight primitive data types in
13:54 - Java six out of those eight types deals
13:56 - with different types of numbers first
13:58 - there are the bytes these are small
14:01 - numbers within the range of -128 to 127.
14:05 - then there are the shorts with a much
14:08 - larger range than bytes and the integers
14:11 - with an even larger range if you ever
14:14 - need to store a value so large that it
14:16 - doesn't fit in an INT you can use the
14:19 - long type by default any number with no
14:23 - decimal point is treated as an integer
14:26 - by the compiler to let the compiler know
14:29 - that a number is actually a long you
14:31 - have to append the letter L at the end
14:34 - of the number you can also use a small l
14:37 - in instead of the capital L if you want
14:40 - for numbers with decimal points in them
14:43 - there are double and Float types doubles
14:46 - are double Precision 64-bit floating
14:49 - Point numbers with a very long range
14:51 - floats on the other hand are single
14:54 - position 32-bit floating Point numbers
14:57 - with a smaller range by default any
15:00 - number with a decimal point is treated
15:01 - as a double by the compiler to let the
15:04 - compiler know that a number is actually
15:06 - a float you have to append the letter if
15:09 - at the end of the number like the lungs
15:12 - you can use a small If instead of the
15:14 - Capital One here
15:15 - Boolean data type can have only two
15:18 - values true or false at the moment usage
15:22 - of a data type that can only hold true
15:25 - or false as values may not seem that
15:28 - useful to you but once you learn about
15:30 - conditional statements you will see
15:32 - their usefulness
15:34 - finally the character type can hold any
15:37 - valid Unicode character the Unicode is
15:40 - kept sequence for the copyright symbol
15:42 - is backslash u00 A9 so if you store this
15:47 - value in a car variable and print it out
15:50 - on the console like this we have
15:55 - you will see
15:57 - that the copyright symbol has been
16:00 - printed on the console instead of the
16:01 - value we have saved of course you can
16:05 - also save any standard character from
16:08 - your keyboard instead of this kind of
16:10 - Unicode subsequences for example if we
16:13 - remove the name Copyright symbol and
16:15 - change it to something like percent
16:18 - symbol
16:20 - and replace these Unicode Escape
16:22 - character with the percent sign
16:26 - and update our code accordingly
16:34 - you will see
16:37 - the percentage symbol printed out on
16:39 - Console instead of the copyright symbol
16:41 - there you go
16:43 - now for the most part when working with
16:46 - integers
16:47 - the in-type should suffice and for
16:50 - numbers with decimal points the double
16:53 - type should suffice but you should also
16:55 - know about the other types
16:57 - although you cannot store one type of
16:59 - data inside another type of variable
17:01 - conversion between the different types
17:03 - is absolutely possible type conversion
17:06 - in Java can be either implicit or
17:08 - explicit when the compiler converts a
17:11 - smaller type of data
17:12 - for example an integer to a larger one
17:15 - like a double automatically it's known
17:19 - as an implicit or narrowing type
17:21 - conversion
17:22 - let's see an example
17:24 - first get rid of all the old code in our
17:27 - project
17:30 - then Begin by declaring a new integer
17:33 - you can call call it anything
17:36 - then declare a double
17:40 - and for the value of the double type
17:42 - assign number one like this
17:46 - is essentially doing is first taking an
17:50 - integer with a value of Phi and then
17:53 - taking a double and assigning number one
17:56 - as its value
17:58 - let's try to print it out using the
18:01 - standard
18:02 - system.out.print Ln function
18:06 - number two
18:08 - and run
18:12 - so as you can see the compiler has
18:15 - successfully converted the integer to a
18:18 - double
18:19 - this is because a w is larger than an
18:22 - integer but what will happen if you try
18:24 - to do the reverse let's try out
18:28 - this time start with a double
18:32 - 5.8 Maybe
18:34 - then an INT
18:41 - okay I missed the two here
18:44 - now
18:46 - system.out.print Ln
18:49 - number two
18:51 - and drop
18:56 - so as you can see
18:58 - the program immediately fails saying
19:02 - incompatible types possible lossy
19:04 - conversion from double to in
19:06 - what the compiler is saying that an
19:10 - integer to double con conversion is not
19:13 - possible automatically although
19:16 - conversion from an in to a double is not
19:18 - possible automatically you can still do
19:21 - it explicitly by letting the compiler
19:23 - know that you want this to happen
19:26 - the cast operator can be of help here
19:29 - first inside a set of parentheses right
19:33 - end this will tell the compiler that you
19:37 - want to convert this double to an it
19:39 - let's try to run the program once again
19:44 - and this time the program works without
19:46 - any issues but you have lost the point
19:50 - eight part after 5. if you are doing
19:53 - explicit type conversion in Java be
19:55 - extremely careful whether the type you
19:58 - are converting to will be able to hold
20:00 - the entire value or not in this case I
20:03 - knew that an integer will never be able
20:06 - to hold the entire 5.8 value and I will
20:09 - lose the second part but I went with it
20:12 - anyway
20:12 - so as long as you know what you are
20:15 - doing you should be all right but at any
20:18 - given moment if you perform an explicit
20:21 - conversion and lose a bit of data
20:24 - accidentally the results can be
20:27 - catastrophic now that you know about
20:29 - variables and the different types of
20:31 - data you can work with in Java you will
20:34 - have to learn about operators keep in
20:37 - mind I have made some changes to our
20:39 - code to better explain our topic in hand
20:42 - and since our code has become much
20:45 - longer than before I suggest that you go
20:48 - to settings
20:49 - and change the default layout from
20:52 - stacked to side by side and then hit the
20:56 - reset layout button to apply the new
20:58 - layout
20:59 - this will give you a lot of vertical
21:01 - space and make the code easier to read
21:04 - operators in Java or programming in
21:07 - general are certain symbols that tell
21:10 - the compiler to perform certain
21:12 - operations such as arithmetic relational
21:15 - or logical operations although there are
21:18 - six types of operators in Java I will
21:21 - only discuss four bitwise operator are a
21:25 - little bit more complex than the other
21:27 - ones and I don't think they fit well in
21:30 - a beginner's course like this we will
21:32 - begin our discussion with arithmetic
21:35 - operators arithmetic operators are the
21:37 - ones that you can use to perform
21:40 - arithmetic operations such as addition
21:42 - subtraction multiplication or division
21:45 - or so on there are five arithmetic
21:48 - operators in Java and these are the
21:50 - addition operator the subtraction
21:52 - operator the multiplication operator the
21:55 - division operator and the remainder
21:57 - operator the remainder operator is also
22:00 - known as modulo or modulus operator
22:04 - addition subtraction multiplication and
22:06 - division these four are pretty
22:08 - self-explanatory you can have a look at
22:11 - our code example here
22:13 - and you should be able to understand
22:15 - what they do and how they do it if you
22:18 - have used a calculator in real life the
22:21 - arithmetic operators in programming work
22:24 - similarly in our code we have two
22:27 - integer numbers number one and number
22:28 - two with the values 12 and 6
22:30 - respectively so if you add number one
22:34 - and number two together the result will
22:36 - be 18. if you subtract number two from
22:39 - number one the result will be six if you
22:42 - multiply number one with number two the
22:45 - result will be 72 and finally if you
22:47 - divide number one by number two the
22:49 - result will be two we will talk about
22:52 - the remainder or modulo operator later
22:54 - the addition and multiplication
22:56 - operations in this code are pretty
22:58 - simple but the subtraction and division
23:00 - operation needs some more discussion so
23:04 - we'll get rid of our addition
23:07 - and multiplication code here
23:12 - we'll comment out the division code
23:14 - and the remainder code and focus solely
23:18 - on the subtraction part as you can see
23:20 - the value of number one is 12 and number
23:22 - two is six which means the number one is
23:25 - greater than number two
23:27 - as a result the result of the
23:29 - subtraction operator comes out as
23:31 - positive but if we change the order of
23:34 - the operation here so if we make number
23:37 - two the first operand and number one the
23:41 - second operand
23:42 - you will see
23:44 - that the result of the operation changes
23:47 - from 6 to -6 again if you have used
23:52 - calculator cngl live before you should
23:55 - already be aware of this situation
24:01 - now the division operation since
24:04 - dividing 12 by 6 yields the result 2
24:07 - this operation is perfectly fine but if
24:12 - we change 6 with something like
24:15 - maybe five
24:17 - then the result will not be a whole
24:20 - number as you can see according to this
24:22 - program the result will be 2 but if we
24:26 - perform the same operation in a
24:28 - calculator or by hand we will know that
24:31 - the result of this operation should have
24:33 - been 2.4 now this happens because if you
24:38 - divide an integer with another integer
24:40 - the result will always be an integer so
24:44 - let's try by changing this integer type
24:49 - to a double
24:52 - for both operands
24:55 - and run the program once again
25:01 - as you can see this time the result is
25:03 - 2.4 but what happens if we divide a
25:07 - double by an integer
25:16 - again the result is 2.4 and if we change
25:20 - the first operand to an end and the
25:22 - second to a double the result will still
25:24 - be 2.4 which means if you divide an
25:27 - integer by another integer the result
25:30 - will always be an integer but if you
25:33 - divide a double or float by an integer
25:36 - or divide an integer by a double or
25:39 - float the result will always be another
25:42 - double
25:43 - now let's get rid of our division code
25:46 - as well and focus solely on the
25:48 - remainder or the modulus operation
25:52 - now for this example I would like to go
25:55 - back to our original verus which are 12
25:57 - and 6 in the beginning
26:00 - and I'd like to go back to integer
26:03 - let's run the program and see what is
26:06 - the output
26:08 - compiling a program may take some time
26:12 - but we just need to be patient here
26:15 - so as you can see the result of this
26:19 - operation is zero
26:21 - first we need to understand what is a
26:23 - remainder now you may or may not already
26:25 - know that a reminder is the value that
26:29 - remains after you have divided a number
26:32 - with another one so if you divide 12 by
26:35 - 6 the result will be 2 and there will be
26:38 - nothing left you can always divide a 12
26:41 - into two sixes
26:43 - but if I change 6 to something like
26:47 - maybe
26:50 - um
26:50 - eight
26:52 - and run the program once again
26:58 - as you can see the value has changed
27:01 - from 0 to 4 this is because if you try
27:04 - to divide 12 by 8 there will always be 4
27:07 - left I hope you got the idea
27:11 - you have already seen examples of the
27:13 - assignment operators in previous lessons
27:16 - it's pretty simple you can use the equal
27:19 - sign to assign a value to any variable
27:22 - in your code but you can also combine
27:26 - the assignment operator with the five
27:28 - arithmetic operators you just learned
27:30 - about
27:31 - for example
27:33 - here we have a integer with a value of
27:37 - 12. now if I tell you that you will have
27:41 - to add 5 with this value and Save in the
27:46 - same variable
27:47 - you can do that like this
27:51 - [Music]
27:55 - now the output of number should be 17
27:59 - instead of 12.
28:04 - very simple but instead of doing this in
28:08 - such a verbose manner you can do it far
28:11 - more easily
28:13 - let's just remove the second part here
28:16 - and instead of using the assignment
28:18 - operator use a plus sign
28:22 - then the assignment operator and then
28:25 - five
28:26 - this small line of code is actually
28:28 - equivalent to number equals number
28:32 - plus pi
28:35 - let's comment this out and see if this
28:38 - gives the same result as before or not
28:44 - okay
28:45 - yeah 70.
28:48 - so you can use all the five arithmetic
28:50 - operators similarly say for example if
28:54 - you want to take out 6 from 12 you can
28:57 - do so by saying number minus equals 6.
29:02 - and this will turn the value of number
29:05 - from 12 to 6.
29:10 - there you can also do modulus operation
29:13 - like this like if you say
29:17 - modulus equals and then
29:20 - 2
29:27 - the result of this operation is 0
29:29 - because when you divide 12 by 2 there
29:33 - will be 2 6s as a result and
29:36 - nothing left I hope you got the idea of
29:39 - using assignment operator with all the
29:41 - five arithmetic operators and I would
29:43 - suggest that you try out usage of the
29:46 - other ones like the multiplication sign
29:48 - and the division sign with the
29:50 - assignment Operator by yourself and see
29:53 - how the result varies from time to time
29:56 - so far in this course you have learned
29:58 - about the arithmetic operators and the
30:01 - assignment operators the arithmetic
30:03 - operators usually lets you perform
30:05 - different types of arithmetic operations
30:07 - on your numbers and the assignment
30:11 - operator usually lets you assign
30:14 - different kinds of value to variables
30:16 - relational operators on the other hand
30:19 - usually check the relation among
30:22 - multiple operands by relation what I
30:25 - mean is for example in this code we have
30:29 - two integer numbers number one and
30:31 - number two with the values 12 and 15
30:34 - respectively now you may want to know
30:36 - whether number one or number two is
30:39 - equal to each other or maybe number one
30:42 - is greater than number two or maybe
30:44 - number one is less than number two or
30:46 - not these are the relation between these
30:49 - two numbers
30:50 - so in Java
30:53 - there are six types of relational
30:55 - operators the first one is the equality
30:59 - operator
31:00 - now keep in mind each relational
31:02 - operator in Java or in other programming
31:05 - languages as well usually returns true
31:08 - or false as a result of an operation for
31:11 - example on line 7 I have written
31:16 - system.out.printellent number one equals
31:18 - equals number two the usage of this
31:21 - double equal sign here is the equality
31:23 - operator now if I run the code
31:26 - since the value of number 1 and number 2
31:30 - is not equal the output will be false
31:33 - which is correct in this case now you
31:36 - may also want to check whether number
31:37 - one is different from number two or not
31:40 - for that you can use the not equal to
31:44 - operator instead of putting two equal
31:47 - signs side by side you will have to put
31:50 - an exclamation sign followed by an equal
31:53 - sign
31:54 - now if I run the code again you will see
31:58 - that the second operation gives us a
32:01 - true
32:01 - because indeed number one is not equal
32:04 - to number two
32:06 - then you can also use the greater than
32:09 - operator to check whether number one is
32:12 - greater than number two or not since 12
32:15 - is smaller than 15 the output of this
32:18 - line will be false
32:24 - there you go there is also the opposite
32:26 - of the greater than operator which is
32:28 - the less than operator and this
32:31 - operation in this case will give us true
32:34 - because number one is actually smaller
32:37 - than number two
32:41 - finally there are the greater than or
32:44 - equal operators
32:46 - and
32:47 - the less than or equal operator now the
32:50 - greater than or equal operator will give
32:53 - us true only if number one is greater
32:57 - than number 2 or equal to number two the
33:00 - less than or equal to operator on the
33:02 - other hand will give us true only and
33:05 - only if number one is less than number
33:08 - two or equals to number two
33:18 - since number one is actually less than
33:20 - number two the greater than or equal
33:23 - operation will give us false and the
33:26 - less than or equal operation will give
33:29 - us the result true now the usage of
33:32 - these relational operators may not seem
33:34 - uh that much fun to you at the moment
33:37 - but once you start working with things
33:39 - like relational statements you will
33:42 - start to understand how important these
33:44 - operators are The Logical operators in
33:47 - Java or in programming in general lets
33:50 - you make logical decision based on
33:52 - multiple conditions for example imagine
33:56 - you are writing a program that can only
33:59 - be used by people within the age limit
34:01 - of 18 years old to 40 years old here we
34:06 - have an integer number with a value of
34:09 - 25. now we will have to make two checks
34:14 - first we will have to check whether age
34:18 - is greater than or equal to 18 or not
34:21 - and then we will have to check whether
34:24 - age is less than or equal to 40 or not
34:28 - so you have already learned about the
34:30 - greater than or equal and less than or
34:32 - equal operators in the previous lesson
34:35 - here I will teach you how you can
34:37 - combine these two operators using a
34:40 - logical and operator to make a connected
34:44 - decision okay so let's write system dot
34:48 - out dot print Ln because we want to
34:51 - print out the result of our operation
34:53 - here
34:54 - and start with the graded then or equal
34:57 - operation age is greater than or equal
35:01 - 18
35:03 - then you will have to put double M
35:04 - person sign and this is the logical and
35:07 - operator in Java
35:09 - and then
35:12 - age is less than or equal to 40.
35:21 - let's run the code and see what the
35:23 - output is
35:28 - as you can see the output is true here
35:32 - let me explain the logical and operator
35:35 - in Java or in other programming
35:37 - languages as well works
35:40 - in this way if the left side of the
35:43 - logical and operator and the right side
35:45 - of the logical and operator yields true
35:48 - as a result then the whole operation
35:51 - will give the result true
35:53 - here the value of age is 25 which is
35:57 - larger than 18 which means the left side
36:00 - is true
36:02 - and it's also less than 40 which means
36:05 - the right side is also true that's why
36:08 - the result of this end operation will be
36:12 - true
36:13 - but if you change this value to maybe
36:16 - something like 45 which is clearly over
36:20 - 40 years old and run the program once
36:23 - again
36:27 - you will see that the output becomes
36:30 - false because
36:32 - although the left side is true the right
36:35 - side is not
36:38 - so in case of a logical and operator
36:41 - both side of the operator has to be true
36:44 - I apart from The Logical and operator
36:47 - there is also a logical or operator okay
36:51 - let's imagine another scenario
36:54 - maybe you are writing a program for your
36:57 - school's library
36:59 - and to be able to borrow books from the
37:02 - library
37:03 - a person either has to be a student of
37:06 - your school or a member of the library
37:10 - so we can have two booleans here
37:14 - is
37:16 - a student
37:18 - which is false maybe this person is not
37:21 - a student of your school
37:23 - and
37:25 - is the library
37:28 - member is equals true maybe he is a
37:32 - member of your library
37:33 - [Music]
37:34 - now to check whether this person is a
37:38 - student or is a library member you can
37:41 - use the logical or operator like this
37:44 - system dot out
37:48 - Dot println
37:51 - and first we will check if this is a
37:55 - student or not
37:57 - student
37:59 - or unlike the logical and operator you
38:02 - have to use two pipe characters to
38:04 - express the logical or operator and then
38:07 - we will check
38:09 - is Library member
38:13 - I hope you remember that in order for
38:16 - the operation to be true in case of a
38:19 - logical and operation both sides of the
38:22 - operator had to be true but in case of
38:25 - the or operation if either side of the
38:28 - operator is true the entire operation
38:31 - will be true
38:36 - so as you can see although easy student
38:39 - is false given is Library member is true
38:43 - the operation gives us the result true
38:47 - so if if you turn both of these booleans
38:50 - to true
38:52 - the result will still be true
38:59 - and the only case when you will get a
39:01 - false result
39:03 - is if both of these booleans are false
39:15 - yes false
39:17 - and finally there is another type of
39:20 - logical operator in Java which is the
39:22 - not operator
39:23 - the not operator in programming usually
39:26 - reverses
39:28 - a Boolean value for example here
39:31 - the value of the easy student Boolean is
39:34 - clearly false right if if you run the
39:37 - program it will surely print out false
39:41 - but
39:42 - if we put a not operator in front of
39:46 - this this this exclamation sign is
39:49 - actually the not operator and run the
39:51 - program
39:56 - you will see that it it turns out as
39:59 - true so instead of using the not
40:02 - operator over a single Boolean value you
40:05 - can actually reverse the value of an
40:07 - entire and or or a person in Java like
40:11 - this let's go back a few steps
40:14 - and I I hope you remember that in this
40:18 - case we got the result false because
40:21 - both of these booleans are false
40:28 - now if you put a not operator in front
40:32 - of the Esky student Boolean this will be
40:35 - turned to true
40:38 - so now if I run the program the result
40:41 - of the entire operation will be true
40:44 - yes there you go the different types of
40:46 - operators that you have learned about so
40:49 - far easily work with multiple operands
40:51 - at a time
40:53 - except the not operator it usually works
40:56 - on a single value or variable at a time
41:00 - now these kind of operators that usually
41:03 - work with a single operand is usually
41:05 - called
41:06 - unary operators apart from the not
41:09 - operator there are also two more
41:12 - operators
41:13 - that are unary in nature and very
41:15 - commonly used in programming these are
41:18 - the increment operator and decrement
41:20 - operators
41:21 - assume that you are trying to make a
41:24 - game where you have to store the score
41:26 - of the player and the number of turns
41:29 - left now you can store these values in
41:32 - two different integer numbers maybe
41:34 - named score and turns
41:37 - now whenever you have to increase the
41:40 - value of score by 1 you can do so by
41:44 - saying score plus equals one you have
41:49 - already learned about the usage of the
41:51 - arithmetic operators along with the
41:53 - assignment operator in previous lessons
41:55 - well this is one way to do this using
41:58 - this method you can actually add any
42:02 - number pre-score
42:04 - but since here in this code you will
42:07 - only increase the score by one
42:10 - well you may think that what kind of
42:13 - gain that is that gives you one in every
42:16 - term well that's just for the example
42:19 - okay just very good
42:21 - you can do it like plus plus
42:24 - so putting two double plus signs after
42:28 - an integer or maybe float or double or
42:31 - any number kind out there will increase
42:34 - its value by one similarly you can put
42:40 - 2 minus signs to decrease or decrement
42:44 - the value of a number time now if we
42:48 - print out the values of these two
42:50 - variable with
42:52 - system dot out Dot println
42:56 - score
42:58 - and we will just
43:02 - make a copy of this line
43:05 - and change it to terms
43:10 - you will see
43:13 - that the value of score
43:16 - is now 1
43:17 - and the value of turns is now 9. so this
43:21 - is pretty simple incrementing and
43:23 - decrementing values there is nothing
43:25 - fancy until I I make it a bit complex
43:29 - let me show you something let's get rid
43:32 - of all this code and declare a new
43:35 - integer it's called number
43:37 - and maybe its value is 55.
43:41 - now if I say system dot out dot print Ln
43:47 - a number
43:49 - plus plus
43:51 - you may think that this will print out
43:54 - 56 because
43:57 - you know the
43:58 - EU increment 55 by 1 and it becomes 56
44:02 - well let's see if if that's true or not
44:08 - hmm
44:10 - seems like that the value has not
44:12 - incremented at all okay let's make a
44:15 - copy of this line
44:17 - foreign
44:20 - and run the program again
44:28 - this time the value has changed but
44:32 - at line 5 where you have used the plus
44:34 - plus or the increment operator the value
44:38 - remained unchanged but on line 6 while
44:41 - you have haven't used any uh operator at
44:44 - all the value seems to be incremented or
44:48 - you see when the compiler reads your
44:51 - code it usually goes from left to right
44:53 - so when it comes to
44:56 - system.out.println and sees the number
44:58 - variable here it immediately prints out
45:01 - its value
45:02 - so at that point the value of number
45:05 - will be 55.
45:07 - then it sees that there is
45:10 - an increment operator here and it goes
45:13 - like Oh that means I have to increase
45:15 - the value by 1 as well
45:17 - then the compiler increases the value of
45:19 - number 256 and keeps that in memory so
45:25 - if you ever print out the value of
45:27 - number later on it will actually print
45:30 - out 56.
45:32 - now this is same for the minus minus
45:34 - sign or the decrement operator
45:42 - initially the value will be 55 even
45:44 - though the value has changed in the
45:46 - memory and on the second pretty
45:48 - statement it prints out 54.
45:51 - so far I have showed you only one way of
45:55 - writing the increment or decrement
45:57 - operator instead of writing it at the
46:00 - end you can also put it in front like
46:03 - this
46:04 - and let's see what output we get in this
46:07 - case
46:11 - as you can see this time we are getting
46:13 - 56 because when the compiler reads your
46:17 - code from left to right it goes like
46:20 - system.out.printellin and it immediately
46:22 - encounters the increment operator and
46:24 - then it sees the number and goes like
46:26 - okay so I have to increase the value of
46:29 - number and then print it out so it
46:31 - prints out 56 on line 5 and on line 6 as
46:35 - well
46:36 - same goes for the decrement operator
46:46 - 54 and 54. so this is something that you
46:49 - should be aware of when using the
46:51 - increment or decrement operator inside
46:53 - other statements like in this case the
46:56 - println method call
46:59 - if you are just incrementing or
47:01 - decrementing the number outside of
47:04 - anything like this method called like
47:07 - this number plus plus
47:09 - then you shouldn't have any problem at
47:13 - all
47:20 - see so if you ever get like unexpected
47:23 - values after using the incremental
47:25 - decrement operator in your program just
47:28 - make sure that you are using it
47:30 - correctly or you are using it in the
47:32 - right place I hope that you remember in
47:35 - a previous lesson I have taught you
47:36 - about the character type it is one of
47:39 - the Primitive types in Java and you can
47:41 - store any Unicode character in it like
47:45 - in this example I have stored the
47:47 - percentage sign in a character variable
47:50 - called the percent sign and I have
47:52 - printed out the character on my console
47:55 - using the standard
47:57 - system.out.printlend method
47:59 - now the character type is good and
48:02 - everything but if you want to store
48:04 - multiple characters together for example
48:07 - your name or a sentence you cannot use a
48:12 - character for that
48:13 - for this type of scenarios we have
48:16 - string in Java there are multiple ways
48:20 - of declaring a new string
48:22 - let's see the literal way first
48:25 - so instead of
48:27 - car
48:28 - you will need to type a string
48:32 - with a capital s
48:34 - and then name of the string in this case
48:37 - name
48:39 - and then the value
48:43 - so this is my name you can put any
48:45 - string right here and then you can print
48:47 - it out like
48:49 - any other variable in Java
48:52 - let's run the code
48:57 - foreign
49:00 - to declare a string in Java is by using
49:04 - the new keywords the new keyword in Java
49:08 - can be used to create new objects from
49:10 - classes now we have not discussed
49:14 - classes at all in this course yet but we
49:18 - will get into classes and objects and
49:20 - object rendered programming later on for
49:22 - now just remember that the new keyword
49:24 - can be used to create a new object from
49:27 - a class
49:29 - Now to create a string using the new
49:32 - keyword you will have to write string
49:35 - then the name of the string
49:38 - equals new
49:41 - string and the value
49:49 - like if you run the program there should
49:52 - be no change whatsoever because
49:55 - essentially declaring the string this
49:57 - way or that way it doesn't make any uh
50:00 - visible changes to the program but there
50:03 - is a slight difference in in these two
50:05 - techniques now the jvm or the Java
50:08 - virtual machine usually uses a portion
50:11 - of your computer's memory to store
50:13 - strings now this little portion of
50:16 - memory is usually called the string pull
50:19 - now whenever you create a new string in
50:22 - the literal way
50:24 - Java will first check whether this
50:27 - string Farhan has injury already exists
50:31 - in the string pull or not
50:33 - if it does then the jvm will simply
50:37 - reuse that previously string with a new
50:40 - name
50:41 - but in case of the new keyword the gvm
50:45 - will create a new object regardless of
50:48 - whether this value already exists in the
50:51 - pool or not
50:53 - I think this can be demonstrated with an
50:56 - example very well
51:00 - for this I will create four strings
51:05 - first one string
51:07 - literal E string 1 equals to A B C
51:16 - and I'll create another literally string
51:18 - with the same value but different name
51:24 - there you go
51:26 - now I will create two object string
51:30 - I mean don't get me wrong these strings
51:32 - are actually same but I am just naming
51:35 - them as literally string and object D
51:37 - string to make clear that
51:40 - which is what
51:42 - now object
51:44 - string
51:46 - equals to new string
51:50 - maybe e f g
51:55 - or XYZ
51:56 - [Music]
51:59 - so I'll make a copy of this string
52:06 - change its name to object string 2 with
52:09 - the same value
52:11 - now if I compare these four strings with
52:14 - each other like this
52:18 - print Ln
52:21 - literal
52:23 - string one
52:24 - equals equals literal string two
52:30 - and I'll make a copy of this line
52:34 - and use object string instead of literal
52:38 - ones
52:40 - sorry
52:44 - let's make this wider so that the code
52:47 - becomes easier to read and now if you if
52:51 - we run the code
52:57 - as you can see when declaring a new
52:59 - string using the literal format
53:02 - since the value ABC was already present
53:06 - in the string pool that jvm actually
53:09 - reused the older value with literally
53:12 - shrink to but when using the new keyword
53:15 - even though the same value has been
53:18 - assigned to the two string variables
53:20 - they are not same you have already
53:23 - learned that the W equals sign checks
53:25 - for the two objects are same or not and
53:28 - in this case the literally strings are
53:31 - actually same since they are using the
53:34 - same value from the pool
53:36 - and the objective strings are different
53:38 - entities because they are not reusing
53:40 - the same values from the pool
53:42 - now depending on your Necessities you
53:45 - may go with either of these techniques
53:46 - but I'd suggest that you go with the
53:49 - literally string
53:51 - technique if there is no problem with
53:53 - that because this will not only make
53:56 - your code easier to read there is no new
53:58 - or there is no duplicate is string
54:01 - written in the code but also it will let
54:04 - the compiler optimize your code a little
54:07 - bit
54:08 - but the strings in Java are not
54:11 - primitive types these are object types
54:14 - and the strings are literally one of the
54:16 - most powerful types in Java you will use
54:20 - strings a lot throughout your entire
54:22 - programming carrier and there are a lot
54:26 - of methods that we can use with this
54:28 - Stream So now I will demonstrate a few
54:30 - of those essential method that you can
54:33 - use on strings and do fancy things with
54:36 - this depending on the type of software
54:39 - you are working on you may or may not
54:41 - have to work a lot with string
54:44 - formatting
54:45 - now let me explain this topic with an
54:48 - example
54:50 - first I would suggest that
54:53 - you go back to the Stacked layout from
54:55 - side by side because now our code will
54:59 - get a lot longer sideways and not
55:03 - vertically
55:07 - okay let's begin by removing everything
55:10 - and writing a single system Dot
55:16 - out dot print as an statement and in
55:21 - here we will write a pretty long
55:23 - sentence this time
55:24 - Chase hello
55:27 - world I am sorry
55:33 - I am
55:35 - from Bangladesh and
55:39 - I am 26 years old
55:45 - very simple program
55:47 - if we run it
55:54 - here so you're getting the entire line
55:57 - without any changes
55:59 - now we can take out a bunch of stuff
56:03 - from this line such as my name
56:17 - then uh my country name
56:22 - [Music]
56:29 - finally my age
56:36 - now to use these variables inside this
56:40 - string you can use the plus sign you you
56:43 - may have already seen example of using
56:46 - the plus sign to like slotting Dynamic
56:49 - variables inside the strings
56:51 - you can do the same here so I'll get rid
56:54 - of farhanasan Chaudhary and in the
56:57 - string here
56:58 - [Music]
56:59 - so now
57:03 - the first string starts here and ends
57:06 - here
57:07 - the second one is starts here and ends
57:12 - right here
57:13 - and in between the two strings I put my
57:17 - name
57:19 - next I can take out the country name as
57:23 - well
57:24 - so I will separate the strings put two
57:28 - plus signs and put country in here
57:32 - nice finally the AIDS
57:37 - same drill
57:39 - separate the string to
57:41 - plus signs and the variable name
57:45 - okay let's save the code cross our
57:48 - fingers and run it
57:55 - yeah as you can see the output is fine
57:59 - but I hope you are getting a sense of
58:01 - how complicated this string can get once
58:05 - you start adding more variable sites
58:07 - such as if I add my company name the
58:11 - company word for
58:14 - uh company girls let's say free code
58:19 - camp
58:20 - a really nice place to work at
58:24 - so I can change it to I work or
58:30 - and then
58:31 - plus plus
58:35 - company
58:39 - now you can put plus and a DOT
58:52 - yeah works just fine so the point I'm
58:55 - trying to get through is the fact that
58:58 - Azure string grows and you start to use
59:01 - more and more variables in it using the
59:04 - plus sign to concatenate strings or add
59:07 - them together becomes really clumsy
59:09 - there is a better way to do this
59:13 - and that's formatting your restraints
59:16 - so let's declare another string called
59:21 - formatted string equals then we will
59:25 - write
59:26 - is string Dot
59:29 - format
59:31 - so my name
59:34 - is modulus
59:36 - s
59:39 - I am from
59:42 - modulus is
59:45 - [Music]
59:47 - I am
59:49 - modulus T years old
59:51 - [Music]
59:53 - and I work or modulus s so once we have
59:59 - written this line we will say comma
60:03 - so my name is modulus s so this modulus
60:08 - is
60:09 - or modulus D these characters are called
60:13 - format specifier so when the Java
60:16 - compiler comes and reads your line like
60:19 - this my name is modulus is the compiler
60:23 - knows that there will be a certain
60:26 - string here and when it reads I am
60:30 - modulus D years old the compiler will
60:33 - know that there will be an integer
60:35 - number here but the compiler doesn't
60:37 - know yet what is string or what integer
60:41 - value will replace this format
60:43 - specifiers
60:45 - so once you have finished writing your
60:47 - string along with the format is
60:49 - specifiers you will have to put a comma
60:52 - and then put in the variables in the
60:55 - same order of the formatting specifiers
60:58 - for example we have my name is modulus s
61:01 - and we want to replace this part with a
61:04 - name variable so we will put name
61:08 - then we will put a comma
61:11 - and then I am from modulus s and we want
61:15 - to replace this format specifier with
61:18 - the country name so country
61:22 - comma then we have modulus D which we
61:26 - want to replace with the h
61:29 - finally we have one more modulus s that
61:33 - we want to replace with the company name
61:38 - that's full stop here
61:40 - there you go now we have a formatted
61:43 - string so instead of writing this a long
61:47 - string with plus signs and variable
61:49 - names and what not in it we can just
61:52 - write
61:53 - for method
61:56 - string
62:00 - let's run the code
62:06 - and as you can see it works out just
62:09 - fine
62:11 - so far you have seen the format
62:14 - specifiers or strings and integers there
62:20 - are also certain formative specifiers
62:22 - for floating Point numbers and booleans
62:26 - so the format is specifier for a
62:29 - floating Point number B it a float or a
62:32 - double in Java is modulus f
62:36 - so if I put in a double here like
62:41 - Maybe by GPA
62:43 - equals
62:45 - uh
62:47 - three point
62:49 - eight
62:50 - and this is not real
62:54 - and I can write
62:57 - my GPA is modulus F and we can replace
63:03 - this modulus if
63:05 - with the value of GPA
63:10 - foreign
63:17 - excellent
63:20 - finally
63:21 - the format is specifier for a character
63:24 - is modulus C and A Boolean is modulus B
63:29 - now I can't think of any fun example to
63:34 - demonstrate modulus B and modulus C
63:38 - but I'll just go with it okay
63:41 - maybe character
63:44 - percent sign equals to put the percent
63:49 - sign here
63:50 - and I can say I have attended
63:57 - 100
64:00 - percent
64:03 - of my University classes
64:08 - excellent and after the GPA I can just
64:13 - use a comma and put percent sign here
64:19 - cool
64:21 - then
64:22 - let's put a Boolean as well
64:25 - Boolean
64:27 - m i telling the
64:30 - truth
64:32 - equals false now I'm not reading the
64:35 - truth I I haven't added 100 of my
64:38 - classes and my GPA is also not 3.8
64:42 - so
64:43 - [Music]
64:44 - um
64:48 - am I telling the truth yeah right these
64:52 - are all modulus B planes
64:57 - and I can put a comma here
65:01 - and then am I telling the truths yeah
65:05 - that's a really horrible name to be
65:07 - honest
65:09 - let's run the program again
65:15 - excellent my name is Farhan Hassan
65:17 - Chaudhary I'm from Bangladesh I am 26
65:20 - years old I work for free code Camp my
65:23 - GPS 3.8 I have attended 100 of my
65:27 - University classes these are all false
65:29 - claims
65:32 - so as you can see the string dot format
65:35 - method returns a formatted string by
65:39 - replacing all the specified format
65:42 - specifiers with your given values now
65:46 - instead of saving this formatted string
65:49 - in a separate variable like I have done
65:52 - here you can actually just copy the
65:55 - entire thing
65:57 - and paste it inside the println call
66:11 - although it works and you can do this if
66:14 - you want but I would not suggest doing
66:16 - this because
66:18 - there is something called the printf
66:20 - function that you will learn later on in
66:23 - this course that actually lets you uh
66:26 - use the formative specifiers right in
66:28 - the print function
66:29 - so for now I would suggest that you save
66:33 - your formatted string in a different
66:36 - variable and then print that out using
66:39 - println or use that however you see fit
66:43 - so remember the format is specifier for
66:46 - a string is
66:48 - modulus
66:50 - s
66:52 - for an integer number also for shorts
66:56 - and Longs is for modulus d
67:00 - for floating Point numbers both floats
67:03 - and doubles
67:05 - modulus f
67:07 - or characters
67:09 - modulus C
67:11 - and finally for booleans
67:14 - modulus B
67:16 - while working with strings in Java it's
67:19 - really common to check the length of a
67:22 - string or you may want to check whether
67:24 - a string is empty or not like a lot of
67:27 - things in Java doing these two tasks is
67:31 - really easy
67:32 - let's start with a single string okay
67:37 - so extreme
67:39 - name
67:43 - Farhan has seen
67:49 - I have to check the length of this
67:51 - string you can write
67:53 - first the name of the string which is
67:55 - name then Dot
67:58 - length
68:00 - the length is a method that remains
68:03 - inside every string that you create in
68:05 - Java now if you run the code
68:12 - as you can see the length of the string
68:14 - is 22 which means there are 22
68:17 - characters in the entire name including
68:20 - the spaces in between okay
68:22 - now you can also check whether a string
68:25 - is empty or not
68:27 - to do so you can just write the name of
68:30 - the string which is name in this case
68:32 - and then Dot and is
68:36 - empty this is another method that
68:40 - returns either true or false if the
68:43 - string is not empty then it will return
68:46 - false and if it's empty then it will
68:48 - return true let's run the code and the
68:52 - output in this case should be false
68:55 - since the string actually contains some
68:58 - characters in it now if I get rid of the
69:01 - name inside the string and just
69:05 - put two quotation marks with nothing in
69:08 - between them and run the code again this
69:11 - time the string will be treated as an
69:14 - empty string and the output will be true
69:17 - now the length and is empty methods can
69:21 - be pretty useful in certain scenarios so
69:24 - I would suggest that you remember them
69:26 - and practice their usage as you go along
69:28 - you can also convert strings from
69:31 - lowercase to uppercase or uppercase to
69:35 - lowercase in Java to do so first you
69:38 - will need a string
69:45 - then to convert this string to uppercase
69:48 - you just need to write the name of this
69:51 - string which in this case is same then a
69:54 - DOT and two upper
69:57 - case
70:00 - this is a method and
70:03 - if you run this program
70:08 - you will see that the name has become
70:11 - uppercase however you may think that
70:14 - these two uppercase method has actually
70:17 - changed the original string which is not
70:20 - true
70:21 - so if we add another println here
70:24 - printing out the original name you will
70:27 - see
70:30 - foreign
70:33 - variable is actually unchanged
70:37 - you can also convert the name to lower
70:39 - guess by using the
70:42 - two lowercase method
70:45 - and this will convert the entire string
70:47 - to lowercase
70:53 - there you go in a previous lesson I have
70:57 - taught you two ways to declare new
70:59 - strings in Java there was the literal
71:02 - way that usually reuses the string value
71:04 - if it's found in the string pool and
71:07 - then there was the usage of the new
71:10 - keyword and I hope that you also
71:13 - remember that when you created a string
71:15 - using the new keyword like this
71:19 - difficult to new string and the value
71:22 - can be something like a b c
71:26 - then make a copy of it
71:31 - and put a string two
71:35 - with the same value
71:37 - and try to compare them using the equals
71:40 - equals operator or the equality operator
71:43 - like this
71:44 - stem dot out dot print Ln is string 1 is
71:51 - equals equals string
71:54 - you will see
71:57 - that the output of this operation
72:00 - comes out as false
72:02 - this is because even though the value of
72:05 - the two string is same these are not the
72:08 - same object and the equality operator
72:10 - usually checks whether
72:13 - the object on the left side is same as
72:16 - the object on the right side or the
72:18 - object on the right side is same as the
72:20 - object on the left side now to compare
72:22 - strings you will have to instead use the
72:26 - equals method so we'll first write the
72:30 - name of one of the strings
72:32 - then equals
72:35 - and string two
72:38 - let's run the program once again
72:44 - and this time the output is true
72:47 - however if you change the second value
72:50 - of ABC to Capital ABC
72:55 - sure the output will be false this time
72:58 - since the values are not same
73:01 - but there can be cases where you want to
73:03 - check whether a string is equal to
73:05 - another string or not ignoring their
73:08 - cases
73:10 - so for those scenarios you can use the
73:13 - equals
73:15 - ignore
73:17 - case method instead of the regular
73:20 - equals method
73:25 - so as you can see even though the two
73:28 - strings have different casing the output
73:32 - is still true you can also replace a
73:35 - part of a string in Java to do so first
73:38 - you will need a string
73:41 - such as
73:43 - the sky is blue
73:46 - [Music]
73:48 - and then say for example we would like
73:52 - to replace the word blue with the red
73:55 - hair
73:56 - system dot out
73:59 - Dot println
74:02 - uh string which is the name of our
74:05 - string right now and then replace
74:10 - you'd like to replace the word blue
74:14 - three great
74:18 - then run the program and see what the
74:21 - output is
74:24 - as you can see the word blue has indeed
74:28 - been replaced with red now you may think
74:31 - that the replace method changes the
74:34 - original string but it doesn't
74:46 - there you go what it actually does is it
74:50 - replaces the white blue with red in the
74:52 - string and Returns the updated string as
74:56 - a new one
74:58 - so instead of putting it directly into
75:01 - the println method you can also do
75:04 - something like a string
75:07 - updated string equals to
75:11 - this
75:12 - and then put updated string inside the
75:17 - println method
75:19 - so this will give us the same result as
75:21 - before
75:25 - foreign
75:29 - you may not always want to replace a
75:32 - substring within a string but you may
75:34 - want to check whether a string contains
75:37 - a certain word or substring or not
75:40 - you can do so in Java as follows
75:45 - so we will use our previous string which
75:48 - says the sky is blue and we'll check
75:51 - whether this string contains the word
75:53 - sky or not to do so you will say string
75:57 - which is the name of our string here
75:59 - then a DOT and then contains
76:05 - and you will need to pass the string
76:08 - that you want to check for to the
76:10 - contains method in this case it's sky
76:15 - save the code and run it
76:22 - since the string contains the word Sky
76:24 - the output is true but if you put
76:27 - something that is not present within the
76:30 - string such as free quote cam
76:34 - and run the code
76:40 - the output is false
76:42 - back when I was learning to code for the
76:45 - first time one of the things that I
76:48 - learned and it gave me a sense of
76:50 - achievement was being able to take input
76:53 - from the user so far in this course you
76:56 - have learned about different types of
76:58 - data operators and outputting text on
77:00 - the console in this lesson I will show
77:03 - you how you can take different types of
77:05 - inputs from the user as well as print
77:08 - out text on the console in some other
77:12 - formats if you are familiar with
77:14 - programming languages like python where
77:17 - taking input is a matter of a single
77:20 - line you may be disappointed to learn
77:23 - that in Java you have to write quite a
77:26 - bit of code to take an input from the
77:28 - user now the first thing that you need
77:30 - to take input from the user is something
77:34 - called an scanner object now scanner is
77:37 - one of the classes in Java and you can
77:39 - use the new keyword to create a new
77:41 - scanner object from the class
77:43 - so you begin by writing scanner
77:47 - since the type of the object will be
77:49 - scanner and you can name it anything but
77:52 - I prefer naming it something simple like
77:55 - scanner
77:57 - then equals new
78:01 - scanner
78:03 - and you will have to let it know from
78:06 - where you are getting the input so since
78:09 - you will get the input from the console
78:11 - or The Terminal you will have to write
78:14 - system dot in
78:18 - now this scanner class that you are
78:21 - seeing here it doesn't exist in your
78:24 - program yet
78:25 - you will have to import it first so
78:29 - before the first line where you declare
78:32 - the class you will have to write import
78:37 - Java dot util dot scanner
78:44 - now you may be seeing this import
78:48 - statement for the first time here but
78:50 - it's nothing complicated there will be
78:52 - scenarios where a certain class will not
78:55 - be a part of your current program or
78:58 - your current class and you will have to
79:00 - import it from somewhere else
79:02 - so the Java language comes with a lot of
79:06 - such classes that can be really useful
79:09 - in different scenarios this scanner
79:11 - class is one of them
79:13 - so once you have defined the new scanner
79:16 - object you can take input from the user
79:19 - so first I would like to speed out
79:22 - something informative on the screen like
79:25 - system dot out Dot print Ln
79:31 - what is your name
79:35 - and then I'll in the line here and I
79:39 - will say
79:41 - scanner
79:43 - Dot next line
79:47 - that's it
79:49 - now the scanner dot next line method can
79:52 - be used to take strings as input from
79:56 - the user
79:57 - you will have to save this input
79:59 - somewhere though so you can say
80:03 - a string name equals scanner dot next
80:07 - line
80:09 - then you can print it out
80:17 - just let's print out the name for now
80:21 - okay let's run the program and and see
80:25 - if it works or not
80:29 - okay as you can see there is this
80:31 - quickly line under scanner and if you
80:33 - hover over it it says resource link
80:35 - scanner is never closed well what it
80:39 - essentially says is once you are done
80:42 - with the scanner you will have to close
80:44 - it it's like an Open Door so if you if
80:47 - you do not close it it will be active on
80:50 - the memory so you will have to go like
80:53 - scanner Dot close and this quickly line
80:57 - should go away
80:58 - yes it did
81:00 - yeah now the programming's fine let's
81:03 - run it
81:09 - yeah what is your name okay
81:14 - enter and yeah it prints out my name
81:17 - pretty nicely now
81:19 - you may notice
81:21 - that
81:23 - inputting my name after the prompt like
81:27 - what is your name then inputting my name
81:29 - in the next line may look a bit little
81:32 - bit weird so instead of using the
81:35 - println method what we can use here is
81:39 - the print method so the print method is
81:43 - actually similar to the println method
81:45 - but the main difference is that it
81:48 - doesn't have a new line character at the
81:51 - end of the line
81:52 - let me show you
81:59 - so as you can see now the text prompt is
82:02 - right after the question marks
82:05 - so I can say for huh
82:07 - yeah enter and yeah that's nice
82:10 - now in case of a println method there is
82:14 - usually a new line character at the end
82:16 - so this causes the text cursor to go to
82:20 - the next line
82:21 - let's run the code to see how it changes
82:24 - our output
82:26 - yeah as you can see now it mimics the
82:28 - behavior of the print element
82:32 - okay
82:34 - now apart from the print method there is
82:37 - another useful cousin of this print
82:40 - alone method called the printf
82:42 - in a previous lesson I have showed you
82:45 - how you can create formatted strings
82:48 - using different types of format
82:50 - specifiers and I also told you that
82:53 - there is a variation of the print Ln
82:56 - method that lets you use this format
83:00 - specifiers right within the print method
83:03 - okay that's that's the printf method or
83:06 - print formatted now instead of just
83:10 - printing out the name like this we can
83:13 - say
83:15 - hello
83:17 - modulus s
83:19 - [Music]
83:20 - how are you
83:25 - and then we will put a comma
83:28 - and we would like to replace the modulus
83:31 - with the name so we put name I hope you
83:34 - remember all the different affirmative
83:36 - specifiers that you have already learned
83:38 - about if not you can just go back and
83:41 - re-watch that lesson let's run the
83:44 - program again
83:49 - foreign
83:55 - treats me and also asks how am I okay
84:00 - let's
84:01 - do something more
84:04 - so you have learned that the next line
84:06 - method usually gives back a string from
84:09 - the user but you can also ask for
84:12 - specific data types such as maybe an
84:15 - integer
84:16 - so to do so let's modify the next print
84:20 - Affair so hello Farhan
84:23 - how old are you okay
84:28 - and then we would say int age equals to
84:34 - scanner Dot
84:36 - next Clint okay
84:39 - yeah nice
84:41 - and we would like to print out
84:48 - yeah and sorry not printed on print f
84:53 - modulus D is an excellent age to start
85:01 - programming okay
85:04 - like any age is like accidental learn
85:07 - programming so
85:09 - you know
85:10 - and we will put age here so this modulus
85:15 - D part will eventually be replaced by
85:18 - the age
85:19 - variables
85:21 - okay let's run it
85:27 - what is your name okay my name is Farhan
85:33 - how old are you 26 maybe yeah
85:37 - 26 is an excellent age to start
85:39 - programming nice I like it
85:44 - okay now so far so good like the next
85:48 - line method and next int method there
85:51 - are also methods for double like scanner
85:54 - dot next Double and next float and all
86:00 - those different types that you can think
86:01 - of
86:03 - but one thing that I would like to draw
86:06 - your attention to and something that
86:09 - catches a lot of uh Java beginners or
86:12 - card is a little quirk so as you can see
86:16 - I am asking for the name using the next
86:19 - line method then I'm asking for the age
86:22 - using the next int method and it works
86:25 - out just fine but let me show you what
86:28 - happens if I try to use another next
86:31 - line method after this next int method
86:33 - okay
86:35 - so if I say system dot out dot print Ln
86:44 - or PDF
86:46 - okay let's just reuse this line okay
86:49 - some excellent cage just start
86:51 - programming
86:52 - what language
86:55 - do we pray for
87:03 - yeah
87:04 - and after that we'll say
87:10 - string language equals to scanner dot
87:16 - next line
87:19 - okay
87:21 - Extreme Dot out Dot printf
87:26 - modulus is is a very
87:30 - popular programming
87:34 - language
87:36 - will stop
87:39 - close here now
87:43 - sorry I I missed the language here
87:48 - yeah
87:49 - now look carefully what happens when I
87:52 - run the program okay so I run the
87:53 - program
87:57 - so first it asks for my name Chase
88:01 - Farhan
88:02 - sure ask how old am I so 26
88:08 - and then it skips the last prompt where
88:13 - I'm asking about the programming
88:15 - language preference and just insta
88:17 - program abruptly and the worst part is
88:20 - there is no error or no failure at all
88:24 - which can help you to debug this problem
88:27 - well this is something uh this has to do
88:31 - with the way the next end and the next
88:33 - line method works so let me explain
88:37 - so when you are saying a string name
88:40 - equals to scanner dot next line and I'm
88:43 - inputting my name then I'm pressing
88:45 - enter
88:47 - the next line method is actually taking
88:50 - the entire name along with my enter or
88:54 - my new line character at the end or the
88:56 - character when I press enter that goes
88:59 - as an input
89:00 - but when it comes to the next int method
89:03 - it only takes the number or 26 as an
89:08 - input and leaves the new line character
89:10 - or carriage return in the buffer in the
89:13 - input buffer so what happens is when I
89:18 - say at 26 and then I press enter
89:24 - this part will be consumed by this
89:27 - method next end but the enter will be
89:30 - left in the input buffer
89:33 - so
89:35 - so when the second next line call comes
89:38 - it sees that there is already an enter
89:43 - in the input buffer and mistakes it as a
89:47 - Enter key press from me
89:49 - so it assumes that the user has already
89:52 - inputted the text they wanted to input
89:54 - and
89:56 - insta call right there okay I hope it
89:59 - makes sense
90:01 - now there are multiple ways to like deal
90:05 - with this problem and
90:07 - one of the ways is whenever you put a
90:11 - next in call or next Double call or next
90:15 - float call whatever it is except next
90:18 - line then you will have to put
90:23 - okay
90:24 - an extra scanner dot next line here so
90:28 - this just like cleans up the input
90:31 - buffer
90:34 - so this next line method eats up the
90:37 - enter that was left
90:39 - by the next int and cleans the input
90:41 - buffer so if we run the program now
90:48 - okay let's say forehan
90:51 - and how about am i 26
90:54 - what language do you prefer well Java
90:57 - yeah
91:02 - so this is something that you should
91:04 - keep in mind that whenever you are using
91:07 - a next ink call anything but a next line
91:10 - call and you want to put another next
91:13 - line call after that like we have here
91:15 - an extent and the next line you will
91:18 - have to put an extra scanner dot next
91:21 - line call just to clean up the input
91:23 - buffer just to get get rid of that uh
91:26 - leftover Enterprise okay otherwise your
91:30 - program May skip the next call okay
91:33 - another way to
91:35 - deal with this situation is instead of
91:38 - using methods like next end or next
91:41 - float you can just use next line for
91:44 - taking all the inputs and then once you
91:47 - have taken an input you can just
91:50 - like convert it to something else okay
91:53 - for example uh instead of using the next
91:56 - ink if we use the next line method here
92:06 - and
92:07 - this will give us a string
92:10 - so what we can do is we can say integer
92:14 - dot parse int
92:17 - and then put the scanner dot next line
92:20 - in there
92:22 - okay
92:24 - and let's run the program and see what
92:27 - happens
92:34 - on 86
92:38 - um Java yeah it works out just fine and
92:41 - we do not have to use any extra scanner
92:45 - objects as well now if you had like
92:48 - instead of int you may have like uh
92:52 - double here you can do so a double say
92:56 - for example if we uh want to take the
92:59 - GPA of the user equals to to be the
93:04 - double
93:05 - Dot
93:06 - first double
93:10 - and then scanner Dot next one
93:14 - and this will work out too okay so uh
93:17 - all of the first method that we have in
93:20 - these classes like integer.parsing
93:22 - double dot purse double we can use all
93:25 - of this now you may think that how would
93:27 - I know uh which method to use when you
93:30 - are trying to purse a number from a
93:32 - string well uh one way that I suggest
93:35 - everyone is you can just Google it uh
93:39 - saying how to purse integer from a
93:43 - string in Java or maybe how to purse a
93:46 - double from a string in Java and so on
93:49 - or this is something that I would leave
93:51 - up to you to figure out because this is
93:54 - something that you do not learn in
93:56 - courses
93:58 - okay so I hope you have learned about
94:01 - taking inputs from the user the main
94:04 - thing you need is a scanner object and
94:07 - you will have to let it know from where
94:09 - you are getting your input
94:11 - uh you can also take input from a file
94:14 - and some other places but those are a
94:17 - bit of advanced
94:19 - for what you know at the moment and you
94:23 - will also have to remember to import the
94:25 - scanner class first otherwise the code
94:28 - will just fail okay if I comment this
94:31 - out and run the code you will see the
94:34 - program simply fails to find the scanner
94:36 - class
94:37 - it says cannot find symbol so make sure
94:40 - that you have imported the class at the
94:43 - top here
94:44 - and the rest is pretty simple I guess so
94:48 - now that you have learned about taking
94:50 - input from the user and outputting text
94:52 - on Console using printf print and
94:56 - println
94:57 - uh in the next lessons we will learn
95:00 - about something called the conditional
95:02 - statements and we'll make a very simple
95:05 - calculator project that will just show
95:08 - you how much you can do
95:10 - with what you have already learned
95:13 - now you have already learned about The
95:15 - Logical operators and taking input from
95:18 - user to all the most important things in
95:21 - programming in this lesson I will teach
95:23 - you something called conditionally
95:25 - statements that lets you make logical
95:28 - decision based on some conditions and
95:32 - Branch out your code in different ways
95:35 - for example we will make a calculator in
95:38 - this lesson and we will let the user
95:40 - perform addition subtraction
95:42 - multiplication and division operations
95:44 - uh based on their inputs
95:49 - so first we will need a scanner of
95:52 - course
95:53 - and let's
95:56 - get rid of all this code
95:59 - okay yeah so you need to close the
96:01 - scanner as well okay let's begin with a
96:03 - double
96:05 - double
96:06 - number one
96:08 - equals to scanner dot next Double
96:15 - and then we will also do
96:19 - number two
96:21 - scanner dot next w
96:23 - we need to output something on this
96:26 - screen as well
96:29 - print is on
96:32 - sorry let's use print here
96:36 - enter the first number
96:42 - and then
96:45 - we'll put enter the second number
96:49 - it's
96:50 - and let's just output the numbers to
96:53 - make sure that the input is working fine
96:59 - number one
97:01 - and then let's make a copy of this line
97:06 - number two
97:09 - yes let's run the code
97:16 - five
97:18 - and ten
97:20 - yeah looks like the input is working
97:22 - fine
97:23 - now we'll need to ask the user what
97:27 - operations they want to perform for that
97:30 - let's
97:32 - speed out
97:34 - what operation
97:36 - do you want to
97:39 - perform
97:41 - and okay we will use print instead of
97:44 - print alone and then we will have to
97:48 - take a string input
97:51 - it's a string
97:53 - operation equals to scanner dot next
97:58 - line
97:59 - so as I have already told you that this
98:03 - next Double calls will leave two next
98:06 - line characters in the input buffer so
98:09 - we will need to clear them out first so
98:11 - let's just put this extra calls here
98:15 - and once we have taken the string
98:19 - operation
98:21 - then we can check what it is okay
98:25 - so the if statements in Java or in
98:28 - programming in general lets you check uh
98:31 - whether a certain value meets a certain
98:34 - condition or not for our case we can say
98:37 - if
98:39 - then a set of parentheses operation
98:46 - Dot
98:48 - equals
98:51 - sum
98:52 - so if the user has written some as the
98:55 - name of the operation then
98:58 - what you want to do is system dot out
99:02 - Dot println and we will say not println
99:08 - printf
99:09 - modulus D plus modulus T equals to
99:14 - modulus D comma so we want to replace
99:19 - the first modulus D with number
99:23 - one
99:26 - this should have been F actually since
99:29 - you're working with double sir and not
99:31 - integers
99:32 - then
99:33 - number two finally number one plus
99:37 - number two
99:40 - space them out in the line with the
99:44 - semicolon
99:45 - excellent now
99:47 - let's check out our simple calculator
99:49 - and see if we can do the summation
99:51 - correctly or not
99:55 - so the first input will be five you can
99:58 - put anything you want the second number
100:00 - will be 10.
100:01 - what operation do you want to perform
100:04 - okay sum
100:06 - yeah 5 plus 10 equals 15. now what
100:10 - happens if I put anything but sum okay
100:13 - for now we are checking if
100:15 - the operation is equals to sum or not
100:18 - and this will return true
100:20 - if it returns true then the line inside
100:23 - the if statement will be executed but
100:26 - what happens if we input something else
100:30 - let's check it out
100:36 - ten two
100:39 - maybe subtraction or sub you see nothing
100:42 - happens so for situations where an if
100:46 - statement fails to fulfill the condition
100:49 - we can put an else statement
100:53 - and we can print out system dot out Dot
100:58 - println
101:00 - print F
101:03 - modulus s is not a supported operation
101:10 - and you can put a semicolon here and we
101:13 - can say comma operation let's see how it
101:17 - turns out
101:23 - okay five
101:26 - ten
101:28 - what's up
101:30 - sub is not a supported operation
101:33 - excellent
101:34 - now I have already said that we will
101:36 - Implement a summation subtraction
101:40 - multiplication and division
101:43 - for that what we can do is we can put
101:46 - lcv statement here so
101:48 - if this condition fails
101:52 - we can say
101:54 - else
101:56 - if
101:57 - and we can put another condition here so
102:00 - operation
102:02 - dot equals
102:06 - sub
102:08 - then what do you want
102:10 - copy this line
102:13 - put it here
102:15 - change the plus sign with minus and also
102:19 - change the operation here
102:22 - minus then we'd want to close this Gap
102:27 - make it look good
102:30 - so now what will happen the program will
102:33 - ask for the first number then the second
102:35 - number then ask for what kind of
102:39 - operation the user wants to perform and
102:41 - then first it will check if the
102:43 - operation is equal to sum or not
102:46 - if it's equal to sum then it will print
102:48 - out the sum of the two numbers
102:51 - if it's not the sum then the ladder will
102:54 - check
102:55 - whether the operation is equals to sub
102:58 - or not if it's sub then it will perform
103:01 - the subtraction operation and give out
103:04 - the value and if the operation is not
103:08 - sun and also not sub then it will go
103:13 - into the else block and print out that
103:15 - this is not a supported operation let's
103:17 - check it out
103:22 - foreign
103:32 - Ty is larger than the first one
103:36 - the value is negative similarly we can
103:38 - just implement the multiplication and
103:40 - division operations so let's just do
103:42 - them else if
103:48 - operation Dot equals
103:54 - multiplication then
103:57 - and just copy this entire line
104:02 - and
104:05 - yep
104:06 - [Music]
104:08 - yeah that's it
104:10 - finally the division operation
104:14 - is a little different operation equals
104:16 - to div
104:18 - then first we will have to check
104:22 - we put another if inside this lcf and
104:25 - this is called a nested if block so we
104:28 - will check if
104:32 - number two
104:35 - is
104:36 - equals equals zero
104:41 - then we want to print out
104:46 - system dot out dot print Ln
104:53 - okay
104:57 - cannot divide by zero because you just
105:03 - cannot divide a number by zero and then
105:06 - you will put else and
105:08 - we'll perform the division inside
105:18 - and we'll bring up the else block here
105:22 - and now let's let's check out the
105:25 - Division and multiplication operations
105:27 - as well
105:34 - let's put 10
105:37 - 0
105:38 - and div
105:40 - cannot divide by 0 excellent
105:43 - let's rerun the program
105:49 - enter the first number then
105:52 - do
105:54 - gives
105:56 - five excellent finally the
105:59 - multiplication operations
106:05 - then
106:07 - a mul a multiplication via 80. excellent
106:12 - so we have already managed to create a
106:15 - very simple calculator here capable of
106:18 - Performing the basic arithmetic
106:19 - operations using IF else
106:22 - now I'm not saying that this is the only
106:25 - way to implement a calculator you can
106:27 - actually uh find even much better ways
106:30 - of making calculators but so far what
106:33 - you have learned this is a pretty good
106:36 - implementation of all your knowledge
106:38 - now when it comes to branching out your
106:41 - code based on one or more conditions if
106:44 - else's statements are pretty common but
106:47 - this is not the only way of doing things
106:51 - there is another statement called switch
106:54 - case statement that can do the same
106:58 - thing as a complicated if else ladder in
107:01 - this lesson we will convert our
107:03 - calculator application to use a switch
107:06 - case statement instead of ifills
107:08 - statements now before we dive into our
107:11 - code I would like to go to settings and
107:14 - change our layout
107:16 - from stack to side by side because
107:19 - as I'm seeing our code is becoming much
107:22 - longer vertically and it's becoming
107:25 - harder to read we can also make the
107:27 - console smaller for now because we need
107:30 - to focus on our code
107:32 - now we can retain most of our code from
107:34 - our previous example we can keep the
107:36 - scanner the inputs for number one and
107:40 - number two the input for the operation
107:42 - and the only thing that we need to get
107:44 - rid of is the Ifill statements
107:47 - now instead of removing the code
107:50 - entirely what I would do is
107:53 - I will just comment it out
107:57 - now
107:59 - to write switch case statement in Java
108:02 - you will have to begin by writing
108:05 - switch
108:06 - and then within a set of parentheses you
108:09 - will have to put the variable that you
108:12 - are trying to test
108:15 - so if you remember from our efels
108:17 - statement we are testing out the value
108:20 - of the operation variable and see
108:22 - whether it matches one of the four
108:24 - operations or not so inside the switch
108:28 - put operation
108:31 - then we will put a set of curly braces
108:34 - now you may have already guessed from
108:37 - the name of switch case statements that
108:39 - there will be multiple cases inside a
108:42 - switch
108:43 - now these cases are like this individual
108:46 - if statements where you are checking the
108:49 - value of the operation variable against
108:51 - something
108:53 - so in the first case of this statement
108:56 - we will check whether the value of the
108:58 - operation is some or not to do so you
109:00 - will have to write case
109:03 - and then the value you want to check
109:05 - against which is sum in this case
109:09 - then you will put a colon here
109:12 - and on the next line you can put the
109:15 - logic
109:16 - for the summation
109:18 - so I will just copy the code from our
109:21 - previous evil slider and put it here
109:26 - okay
109:27 - let's run the code and see what happens
109:39 - okay Enter the first number I
109:41 - and put five into the second number 10
109:46 - and stop
109:49 - okay it says 15 which means it works now
109:53 - try to put a value that is not defined
109:56 - within the switches statement like sub
109:59 - let's rerun the program
110:06 - 5 10
110:08 - sub
110:10 - and as you can see just like the if
110:12 - statement when you didn't have an ill
110:15 - server
110:16 - it doesn't print out anything at all
110:20 - now in case of switch cases statements
110:22 - you do not have else but you will have a
110:25 - default guess which you can write as
110:29 - default
110:30 - [Music]
110:31 - and then you can just print out that
110:35 - this is not a supportive operation
110:40 - let's run the program and see what
110:42 - happens
110:48 - first number five
110:50 - then
110:52 - and
110:55 - okay savvy's not a supported operation
110:57 - fine now so far this looks okay but let
111:01 - me show you a problem here
111:03 - if I run the program
111:09 - if I put the numbers
111:11 - and then say sum
111:14 - you will see the program not only prints
111:17 - out the summation of the two numbers but
111:19 - it also prints out is not a supported
111:22 - operation
111:24 - well the way switch cases are designed
111:27 - that if one of the cases match then the
111:31 - program will not only execute that case
111:34 - but also the cases that comes after that
111:38 - to stop the program from going through
111:41 - all the cases here what you'll need to
111:44 - do is you will
111:45 - need to use the break step
111:49 - so when the program comes and it sees
111:52 - that the sum case has been matched it
111:55 - will execute the logic here and then it
111:59 - will encounter the break statement and
112:02 - breakout of this entire switch case
112:04 - statement okay and it will go directly
112:07 - to scanner.close Let's test it out once
112:10 - again
112:18 - sorry
112:20 - let's put five
112:21 - then
112:23 - and some
112:25 - so as you can see it prints out the sum
112:27 - and breaks the program right there
112:30 - okay that that's cool
112:33 - now
112:34 - you can actually Define the other cases
112:36 - such as
112:38 - case
112:40 - sub
112:42 - and we will of course take the
112:45 - subtraction logic from our previous efl
112:48 - slider
112:49 - put it here put the break statement in
112:53 - let's just copy this
112:57 - best okay so the third case would be the
113:01 - multiplication case and
113:04 - we'll change the minus sign so if the
113:07 - multiplication sign
113:09 - and finally the division case
113:15 - [Music]
113:19 - now I hope that you remembered that we
113:23 - also had a check to make sure that the
113:26 - user is not trying to divide by zero
113:29 - we will have to do that as well and for
113:33 - that we do not have anything fancy we
113:36 - will just need to rely on plain old if
113:40 - else step map so we will write
113:43 - if
113:45 - number two is equals equals zero
113:51 - then we would like to print out
113:55 - cannot divide by zero
114:00 - else we would like to perform the
114:04 - division operations
114:08 - keep in mind that you should write the
114:11 - break statement outside of both the if
114:15 - and else block otherwise if you put the
114:18 - break inside the if or the else then it
114:21 - will only work if
114:22 - one of them are active but if you put it
114:26 - out here no matter what happens in DC
114:30 - fills block the break will always work
114:34 - let's try it out and see if it works or
114:36 - not save the code
114:39 - and run it again
114:47 - okay then
114:49 - zero
114:51 - and div
114:52 - cannot divide by zero okay let's rerun
114:55 - the program and check if the normal
114:57 - division function works or not
115:00 - then
115:02 - two
115:04 - give
115:07 - yeah it works finally let's check the
115:09 - multiplication
115:14 - [Music]
115:16 - 10 5 multiplication
115:21 - 50 yeah it works just fine
115:24 - now you can get rid of the commented out
115:27 - if it's a statements
115:32 - now although e-fills statements and
115:34 - switch cases statements are more or less
115:37 - do the same thing in the context of Java
115:41 - or in the context of other programming
115:42 - languages as well
115:44 - a switch case statement is actually
115:46 - faster than an if else letter in Java so
115:51 - if you can put your logic within a
115:53 - switch case statement instead of a
115:55 - really elaborate if else statement try
115:58 - to do that so far in this course you
116:01 - have only stored single values in single
116:04 - variables but there is a way to put
116:07 - multiple values within a single variable
116:09 - these are called arrays
116:12 - now before I start working on arrays
116:15 - let's do some cleanup
116:19 - you can get rid of more or less
116:21 - everything in our code you can also get
116:24 - rid of the Java util.scanner
116:28 - now to declare a new array for example
116:31 - if I want to declare an array of
116:34 - characters and I want to store all the
116:37 - vowels in English alphabets you can do
116:41 - so like this
116:43 - first you will have to type out the type
116:45 - of the array which in this case is car
116:49 - or character
116:51 - space then the name of the array which
116:54 - will be files
116:57 - and
116:58 - two square braces
117:00 - then you will put an equal sign and new
117:05 - car then you will put another set of
117:08 - square braces and inside of these Square
117:11 - braces you will have to put the length
117:13 - of the array now we know that there are
117:16 - five vowels in the English alphabet so
117:18 - you will put five
117:22 - now we have an array of characters but
117:26 - it's completely empty to insert a new
117:28 - value to this array you will have to
117:31 - write
117:32 - files
117:34 - and then an index of the array which in
117:39 - this case 0
117:41 - then equals then the value you want to
117:45 - save in the array
117:47 - a
117:49 - now I have already told you that this
117:52 - array is of 5 length which means it can
117:56 - store five characters in it
117:59 - now these characters here can be stored
118:02 - like a e i o u and each of this
118:08 - character will have a number associated
118:11 - with them this number is called the
118:14 - index
118:15 - now the first index of an array in Java
118:19 - is always zero so by putting vowels and
118:24 - 0 inside a set of square braces you are
118:28 - essentially addressing the first place
118:31 - in this array
118:34 - then you put equals a and you fill it up
118:38 - now the other spaces are still blank
118:49 - now you can copy this line
118:54 - and paste it to insert the other values
118:57 - as well so 0
119:00 - then 1
119:04 - .
119:09 - then index 2 will be I
119:18 - index 3
119:24 - will be o
119:29 - and finally index 4
119:35 - will be you
119:37 - you
119:39 - now you have completely filled this
119:42 - array with the five vowels of English
119:46 - alphabet
119:48 - you can also print out these individual
119:50 - files using the same square brace syntax
119:54 - so if I copy files to
119:58 - from here
120:00 - and write system dot out Dot println and
120:07 - put files and two inside Square braces
120:09 - and print it out you will see I printed
120:13 - out on the console
120:15 - yeah as you can see there is I
120:18 - you can also print out an entire array
120:21 - but
120:22 - that's not as simple as printing out a
120:25 - single character or number or a string
120:28 - as you may have already guessed the
120:31 - print printf or println function prints
120:34 - out stuff on the console as strings
120:37 - so before you can print out the array
120:40 - you will have to convert it is string
120:44 - to do so
120:46 - import the arrays class like this import
120:51 - java.util Dot erase
120:55 - and then inside the println method call
120:58 - you will write arrays
121:05 - Dot
121:07 - to string
121:09 - and in the name of the array which in
121:12 - this case
121:13 - is vowels
121:20 - see we have printed out the entire array
121:23 - now you can also print out an array
121:26 - using Loops which you will learn in
121:28 - later lessons for now just be informed
121:32 - that there is also other ways of
121:34 - printing out an entire array to the
121:36 - console
121:40 - so I have already mentioned that this
121:43 - array has a length of 5. and since its
121:47 - index count starts from 0 it will
121:49 - obviously end at 4. now if you try to
121:54 - put something in an index that doesn't
121:57 - exist
121:58 - like five
122:01 - and maybe put X here
122:05 - run the program
122:09 - you will see that it fails with an
122:12 - exception saying index 5 out of bounds
122:16 - for length 5 which means for an array of
122:20 - length 5 you cannot have an index 5.
122:25 - let's get rid of that line
122:30 - and our code should be back to normal
122:38 - now instead of declaring and defining
122:41 - your arrays separately you can actually
122:43 - declare and Define your array in one
122:46 - line
122:47 - to do so after you have written car
122:51 - files
122:53 - the pair of square braces and equal get
122:56 - rid of the new keyword
122:59 - and put a set of curly braces here
123:03 - then you can actually put the values
123:08 - [Music]
123:16 - and in the line with the same colon
123:20 - get rid of these lines here
123:23 - and run the code
123:29 - there you go
123:31 - now you can also replace any of these
123:35 - values from the array at any moment for
123:38 - example if you want to replace the I
123:40 - with any other character out there you
123:43 - can do so
123:44 - in this way
123:46 - vowels
123:49 - curly braces and the index of I is 0 1
123:53 - 2. so put 2 here
123:56 - equals and put X
123:59 - put a semicolon at the end run the
124:02 - program
124:05 - and as you can see the eye has indeed
124:09 - been replaced with x
124:11 - another thing that I forgot to mention
124:13 - is the fact that when you are declaring
124:16 - and defining your array in a single line
124:18 - the array will actually infer its length
124:22 - from the number of values you are
124:25 - defining it with
124:27 - so since there are five values in the
124:30 - definition the areas length will always
124:33 - be 5. the light strings arrays in Java
124:38 - are reference types and like strings
124:41 - arrays also have a bunch of useful
124:44 - methods in them for example if you ever
124:47 - want to know about the length of an
124:49 - array you can do so by saying that let's
124:53 - get rid of this line first
124:56 - and you can write the name of the array
124:59 - files and Dot left
125:03 - I hope you remember that in case of a
125:06 - string the length was actually a method
125:09 - but in case of an array it's a property
125:12 - so if we run the program
125:16 - and you can see the length of the array
125:19 - a one of the most common tasks regarding
125:22 - arrays that you may have to do again and
125:25 - again within your programs is sorting an
125:28 - unsorted array
125:30 - right now we have ordered our files
125:33 - array according to the order of the
125:36 - letter as they come in the English
125:38 - alphabet so a e i o u
125:41 - but if we change the order and kind of
125:44 - randomize it so I will put e first
125:48 - then u a
125:54 - and I so a e i o u then it's totally out
126:01 - of order
126:02 - now there is a method called sort within
126:05 - the arrays class that you can use to
126:09 - sort your arrays in order
126:11 - to do so you will have to write
126:14 - arrays Dot sort
126:17 - and then put the name of the array
126:20 - balance
126:22 - then let's bring back our
126:26 - arrays.goo string method
126:29 - and we'll save outs
126:32 - let's run the program and see
126:35 - if it works or not
126:38 - so turns out that the arrays.sort method
126:42 - takes an array as its parameter and it
126:47 - sorts the array in place so it actually
126:49 - changes the original Source array by
126:53 - default the arrays.sort method performs
126:57 - the Sorting on the entire array so it
127:00 - will begin from the first letter and go
127:04 - through the entire array until it
127:06 - reaches the last letter and sort them in
127:09 - order but if you want to perform the
127:12 - Sorting within a certain range of the
127:15 - array
127:15 - let's say for example if I want to keep
127:19 - the e and i as they are right now and I
127:24 - just want to sort the u a and o I can do
127:27 - so so after I have put the array name
127:32 - now to define the starting and ending
127:35 - index of the sort method
127:38 - you can let's just Define to integer
127:41 - cells so int
127:43 - starting index equals I'd like to start
127:48 - the Sorting from U so 0 1
127:51 - [Music]
127:53 - than in ending index
127:56 - I want to perform the Sorting until all
128:01 - but here is the thing
128:03 - if I put
128:04 - 0 1 0 1 2 3 3 as the ending index
128:11 - the O will be left out from the Sorting
128:14 - because the ending index is usually not
128:16 - inclusive in this case so I will have to
128:20 - write 4. which means the Sorting will
128:24 - take place from U to o n it will
128:27 - actually not affect I
128:29 - Let's test it out after I have written
128:32 - the name of the array I will put a comma
128:34 - here and I'll put the starting index
128:37 - then the ending
128:41 - index
128:44 - save my code and run it
128:51 - so as you can see
128:53 - the sort method has actually sorted aou
128:58 - in order and did not touch e and I at
129:02 - all
129:03 - so this is one of the useful things that
129:06 - you should know about sorting arrays in
129:08 - Java apart from sorting an array you may
129:11 - also want to search for a certain value
129:14 - within an array okay so for example we
129:18 - have e u a o i here and if you want to
129:23 - look for o in the entire array you can
129:27 - do so by using the arrays.binary search
129:30 - method
129:31 - now one thing that you will have to
129:33 - remember is that these areas.binary
129:36 - search method only works on sorted
129:39 - arrays so if you have an array that is
129:42 - not in order make sure you have sorted
129:45 - it before performing the search
129:48 - now to search for maybe o within this
129:52 - array I will say
129:54 - arrays Dot
129:57 - binary search
130:01 - and then I'll put the name of the array
130:04 - that I want to perform the search on so
130:07 - files
130:09 - and then the key or the item I am
130:12 - looking for so I'll write key
130:16 - and I create a new character here uh key
130:20 - equals to and I'm looking for what I'm
130:23 - looking for oh
130:27 - okay now this binary search method right
130:29 - here returns an integer which is the
130:32 - index
130:33 - of this key is found
130:37 - so I will write int
130:41 - found item index equals to errors dot
130:46 - binary search files excellent
130:48 - now first I would like to print out the
130:51 - entire array
130:53 - and then I would like to print out
130:58 - the found item index
131:00 - so found item
131:03 - index
131:05 - e
131:06 - let's save the code and
131:09 - test it out
131:13 - sorry I mistyped the name of the
131:15 - variable here you know mistakes like
131:17 - this can happen
131:24 - yeah
131:26 - so in the array a e i o u o is at index
131:31 - number three so we can verify that 0 1
131:36 - 2 and 3 o is at index number three like
131:40 - the sort method that you learned about
131:42 - just a few moments ago the arrays dot
131:46 - binary search method can also take an
131:49 - starting and an ending index
131:53 - to use them first we will need to define
131:55 - the index
131:58 - integers like int starting index I think
132:03 - I should have just kept them
132:04 - and I will start
132:07 - the search from one so I put one
132:12 - then I will also create an ending index
132:17 - equals to 4 because I want to perform
132:21 - the search within the middle three
132:23 - values and like the sort method
132:26 - the ending index is not inclusive in
132:29 - this case as well
132:30 - so once I have defined the two integer
132:32 - numbers I will say binary search vowels
132:37 - and then
132:39 - the starting index
132:44 - comma the ending index
132:48 - and finally the key I am looking for
132:51 - now let's see if it works or not
132:56 - run
133:00 - okay so it says 3 which is correct in
133:04 - this case as well I have found o at 0 1
133:08 - 2 3.
133:15 - now so far in this lesson I have shown
133:19 - you a bunch of searches and all of them
133:23 - has worked out fine but what will happen
133:27 - if one of your searches failed to find
133:30 - the value you're looking for for example
133:33 - we do not have an X in the entire array
133:38 - so if I get rid of the starting and
133:40 - ending index
133:44 - and look for an X within our array
133:55 - you will see that the output is -6 now
134:00 - instead of looking for an X if I look
134:04 - for a b within our
134:07 - array you will see
134:11 - that the output
134:14 - changes from -6 to -2
134:18 - so you may have already guessed that
134:20 - depending on the item you are looking
134:23 - for and if it doesn't exist within your
134:26 - array then the output can differ
134:30 - but one thing that's constant is if the
134:33 - search fails you will always get a
134:36 - negative output and if the search
134:38 - succeeds you will get a positive output
134:40 - and that positive number will be one of
134:43 - the indexes from your array where the
134:46 - item you are looking for exists now
134:49 - there is a way to actually calculate
134:52 - this value there is logic behind why the
134:56 - output is sometimes 2 and sometimes six
134:59 - but I will not get into that much
135:02 - details in this course if you are
135:04 - interested about learning this I will
135:06 - leave the link to this article on free
135:09 - code Camp under this video's description
135:11 - so you can follow that link and read
135:14 - more about it now being able to sort an
135:17 - unsorted array and look for any certain
135:20 - item within an array is useful now
135:24 - another small but useful thing that you
135:26 - can do with arrays is that you can fill
135:29 - them with a certain value
135:32 - for example we have five vowels listed
135:36 - out of order within our vowels array
135:39 - but maybe for some reason you want to
135:43 - fill the entire array with x
135:46 - or maybe empty characters
135:49 - now you can do that by using the
135:53 - arrays.fill method before that let's get
135:57 - rid of some of these codes
136:00 - and write arrays Dot
136:04 - feel
136:06 - then put the name of the array that you
136:09 - want to fill which is files
136:12 - and the character or the value that you
136:15 - want to fill the entire array with
136:18 - [Music]
136:20 - let's run the code and see if it works
136:23 - or not
136:27 - yeah as you can see the entire area has
136:29 - been filled with excess
136:32 - now you can also have starting and
136:34 - ending indices with this fill method
136:39 - starting index equals let's start from
136:43 - one
136:45 - and in end ending
136:48 - index equals to 4 this is the same drill
136:52 - with the other methods as well the
136:54 - ending index is never inclusive
136:56 - so if you want to perform the field from
137:00 - 1 2 3 upon these three values make sure
137:05 - to include the last one as well or the
137:08 - item that's just after the one you want
137:11 - to end the field action act okay now
137:16 - arrays.fill comma vowels then we will
137:19 - put the starting index
137:23 - the ending index
137:26 - finally the value that you want to fill
137:29 - the array with
137:31 - okay so rs.2 string valves let's see if
137:34 - it works or not
137:38 - yeah it does uh the E and I is untouched
137:42 - and the U and O and A has been replaced
137:45 - with x's I have already said that arrays
137:48 - in Java are reference types and one of
137:52 - the complexities that we get with any
137:54 - reference types out there is making
137:57 - copies of them
138:00 - for example if we have an array of
138:03 - integers this time just for changing our
138:06 - test a bit I will write
138:09 - int
138:10 - numbers
138:13 - same thing equals then inside of a pair
138:17 - of curly braces I will put one two three
138:21 - four and five
138:24 - then I will create another array saying
138:27 - int
138:29 - copy of numbers which is an array
138:34 - equals to
138:36 - the number sorry okay
138:39 - so ideally the copy of numbers array
138:43 - should be a copy of the original numbers
138:45 - right
138:46 - let's see if that's true or not
138:51 - print Ln
138:54 - arrays dot two string numbers
139:01 - let's make a copy of this line and put
139:05 - copy of numbers
139:10 - sorry
139:12 - let's run the code and see what happens
139:18 - turns out I have made another typo here
139:21 - I have Mr T
139:23 - let's put it back
139:25 - and run the program
139:30 - so it seems like that the copy of
139:32 - numbers array is indeed a copy of the
139:35 - original number setting
139:37 - but I'm not convinced let's do another
139:40 - thing okay
139:42 - let's make some changes to the original
139:45 - area so we can say
139:48 - arrays Dot
139:50 - fill
139:52 - numbers and I'll fill the original array
139:55 - with zeros
139:56 - and then run the code let's see what
139:58 - happens
140:02 - but this is unexpected isn't it
140:05 - I have actually made some changes to the
140:08 - source arrays and the changes have
140:11 - somehow applied to the copy as well
140:15 - but the reason for this is the fact that
140:19 - arrays in Java are reference types and
140:22 - when you use an assignment operator to
140:25 - make a copy of an array or any other
140:28 - reference type
140:30 - for that matter
140:32 - it doesn't actually makes an entirely
140:35 - new copy of the source material what it
140:38 - does is it creates a new variable and
140:41 - points that variable to the original
140:43 - Source array
140:45 - so although the second array has a
140:48 - different name it's still pointing to
140:50 - the same values so you can treat this
140:53 - copy of numbers array as kind of an
140:56 - alias for the original numbers area
141:00 - so how do you make a copy of an array
141:03 - correctly then now to copy an array
141:06 - properly you will have to use
141:08 - the arrays dot copy of method the method
141:14 - takes the name of the original array as
141:18 - its first argument and at the second
141:21 - argument
141:22 - it asks for the length of the new array
141:27 - so the length of the original array as
141:29 - we can see is one two three four five
141:34 - so you can count that by hand or you can
141:37 - be a little bit clever and put numbers
141:40 - dot length as the length for the new
141:44 - array
141:45 - let's run the code and see whether the
141:49 - copy gets affected by the field call or
141:51 - not this time
141:56 - so as you can see that the original
141:59 - Source material and the copy of it are
142:03 - now two separate entities which we want
142:07 - now instead of putting the same length
142:10 - as the original array you can also make
142:12 - the array larger or smaller let's say
142:17 - if you make it larger with 10
142:21 - indexes you can do so
142:27 - so as you can see the first five
142:31 - elements of the copied array are from
142:34 - the original array and the rest of the
142:36 - indexes has been filled with 0 which is
142:39 - the default value for integers you can
142:42 - also make it smaller so 2
142:50 - .
142:53 - and the copy array can hold only two
142:57 - values while the original array could
142:59 - hold five
143:01 - now like the sword
143:04 - and the search method you can also
143:06 - Define the starting and ending indexes
143:10 - for the areas.copy of method but for
143:13 - that instead of using the copy off
143:16 - method you will have to use copy of
143:20 - range now inside this method you will
143:24 - have to first give it the name of the
143:26 - source array
143:28 - then and starting index and and ending
143:33 - index
143:34 - and just like before we will have to
143:37 - Define this integers here and the
143:40 - starting index
143:41 - equals to Let's uh 0 1 let's start the
143:45 - copy from one
143:46 - and in
143:50 - ending index equals to
143:53 - r 4.
143:56 - let's run the code and see what happens
144:14 - so as you can see
144:17 - the method has successfully copied 2 3
144:21 - and 4 from The Source area now one thing
144:24 - that you may have already noticed that
144:26 - in case of the copy of range method you
144:29 - do not need to use a link for the newly
144:32 - copied array
144:34 - so how can you increase the length of
144:37 - the new array if you want to
144:39 - well right now we are performing the
144:43 - copy from
144:45 - index number one to index number four
144:49 - right
144:50 - so if we put a larger value than the
144:53 - original length of the array like
144:57 - then let's see what happens
145:04 - so as you can see the copy works out
145:08 - fine the method copies 2 3 and 4 from
145:13 - the original array also 5 and 10 fills
145:16 - up the rest of the space with zeros
145:20 - so although you cannot explicitly Define
145:23 - a new length for your copied array you
145:26 - can change the length of the new array
145:28 - by
145:30 - changing the ending index of the copy of
145:33 - range method
145:35 - just like copying a reference type is
145:38 - more complex than copying A Primitive
145:41 - type comparing preference style is also
145:45 - a bit complicated I hope you remember
145:47 - from our lessons on string we couldn't
145:51 - compare two strings simply using the
145:54 - equal SQL signs we had to actually use
145:57 - the equals method
145:59 - so it's kind of similar in case of
146:02 - arrays say for example we have the
146:07 - original numbers array
146:10 - then we have a copy of the numbers array
146:14 - let's just use
146:16 - copy off instead
146:20 - numbers dot length x length
146:25 - and get rid of the field method
146:30 - and try to compare our arrays using the
146:35 - equality operator so we'll send numbers
146:37 - equal equals
146:39 - copy of numbers
146:44 - let's run the code and see what happens
146:51 - as you can see it says false but we know
146:55 - for sure that the copy of numbers array
146:57 - is an identical copy of the original
146:59 - Source material
147:01 - now to compare to identical arrays like
147:04 - this or maybe two different arrays
147:06 - what you'll have to do is you will have
147:09 - to write
147:10 - arrays dot equals
147:15 - then inside this method you'll have to
147:19 - pass the two arrays copy of numbers
147:24 - let's run the code and see what happens
147:31 - yeah this time it comes out as true
147:34 - since there is no such thing as casing
147:38 - in case of an array
147:40 - there is no equals ignore case method
147:44 - for arrays like we had for strings in
147:48 - programming you may want to repeat a
147:50 - certain set of instructions again and
147:53 - again for your projects you can do that
147:56 - by using loops now there are four kinds
147:59 - of Loops in Java and we will start our
148:03 - discussion with a for Loop first I will
148:07 - write out the code
148:08 - for a very simple for Loop in Java that
148:11 - can print out the number from 1 to 10.
148:14 - for that I will write
148:18 - for this is the starting of our for Loop
148:22 - then inside I will take an integer int
148:27 - number equals to 1. now after the
148:30 - semicolon I will write
148:33 - number
148:35 - is less than or equals
148:39 - 10.
148:42 - and then number plus plus
148:47 - then I will put
148:50 - a set of curly braces here and inside
148:53 - this block of code I will write
148:56 - system dot out
148:59 - Dot println
149:01 - number
149:03 - we do not need the arrays class import
149:07 - right now so we will get rid of that
149:10 - and let's run the code and see what
149:14 - happens then I will explain each line of
149:16 - this for Loop to you
149:19 - as you can see the program successfully
149:22 - prints out
149:23 - all the numbers from 1 to 10. so what's
149:27 - going on here well every single for Loop
149:30 - usually has
149:32 - four parts the first part
149:36 - is the initialization where we are
149:39 - initializing a certain variable in this
149:42 - case an integer with the initial value
149:45 - of 1.
149:46 - then there is a condition that we are
149:49 - checking against so we are checking
149:52 - whether the number is less than or equal
149:56 - to 10 or not
149:58 - and if the number is less than or equal
150:00 - to 10 we will print out the number so
150:03 - this is the loop body system.out dot
150:06 - println anything that you write inside
150:08 - this set of curly braces will be the
150:11 - loop body
150:12 - then once we are done with the loop body
150:15 - we will go to the third part here inside
150:18 - the set of parentheses and this is
150:21 - called the update and we will update the
150:24 - value of the number variable
150:28 - so I will repeat
150:30 - every single for Loop will have four
150:32 - parts there is the initialization where
150:34 - we initialize a variable with a value
150:37 - then there is a condition that we will
150:40 - check in every iteration there is the
150:43 - loop body and then there is the object
150:46 - so when this Loop runs for the first
150:49 - time the value of number will be 1.
150:53 - and this condition will be true since 1
150:57 - is indeed less than 10. so the loop will
151:00 - print out the value of number which in
151:02 - this case is 1.
151:04 - then the loop will increase the value of
151:07 - number by 1 and go back to the condition
151:10 - part and check whether the updated value
151:14 - is less than or equal to 10 or not well
151:16 - 2 is less than 10
151:19 - so it will again go inside the loop body
151:21 - and print out 2 on the console
151:24 - so like this the loop will keep printing
151:27 - out all this number until it reaches 10.
151:31 - when the loop has printed out 10 on the
151:34 - screen it will go back to the update
151:36 - part and increase the value of number
151:39 - from 10 to 11. and it will go back to
151:43 - the condition once again and check
151:45 - whether 11 is less than or equal to 10
151:48 - or not
151:49 - in this case the condition will come out
151:52 - as false and the loop will stop
151:54 - iterating
151:56 - the program ends here and we get all the
152:00 - numbers between 1 to 10 printed out on
152:03 - our console
152:04 - I hope that makes sense you can also use
152:08 - a for Loop to Loop over an array
152:11 - for example if we create an array here
152:15 - int
152:16 - numbers
152:19 - equals to
152:22 - 1 2 3 4 5 6 7 8 9 and 10.
152:34 - then we can use this for Loop to Loop
152:37 - over this array and print out each of
152:40 - this number
152:41 - to do so we will need an integer and we
152:45 - can call that the index
152:49 - so we want to run this loop as long as
152:52 - the index
152:56 - is less than
152:58 - the length of this array so
153:01 - numbers
153:04 - dot length
153:10 - numbers dot length
153:12 - finally we will increase the value of
153:15 - index by 1 on every iteration
153:21 - finally inside the println call we will
153:24 - send numbers
153:25 - and then we will put the index here
153:29 - let's see if it works or not
153:37 - so as you can see the program actually
153:40 - brings out all the numbers from 2 to 10
153:43 - and doesn't print out to 1 because
153:47 - since the index count starts from 1
153:51 - which
153:52 - is its initial value it starts accessing
153:56 - the array elements from index one so if
154:01 - you change the value of index from 1 to
154:03 - 0 then you should get all the numbers
154:06 - from 1 to 10.
154:11 - so what's happening here is you are
154:14 - initializing an integer with a value of
154:16 - 0
154:17 - and then inside the condition part you
154:20 - are checking whether the value of the
154:22 - index is less than the length of the
154:25 - numbers array or not if it's less than
154:28 - the length of the numbers array then you
154:31 - go inside the loop body and print out
154:34 - whatever number is in the current index
154:37 - so it starts from index 0 which means
154:40 - one
154:41 - then index 1 which is 2 then 3 4 5 6 and
154:47 - so on
154:49 - you can also do some interesting things
154:51 - within this Loop instead of printing out
154:54 - all the values
154:56 - you can add them all together and print
154:58 - out the sum to the screen
155:00 - to do that what you will need is you
155:03 - will need another integer here
155:07 - goes to zero
155:09 - initially the sum will be zero
155:11 - and then inside the loop what we are
155:14 - going to do is we will say sum plus
155:18 - equals
155:20 - numbers
155:22 - and then the index
155:25 - okay finally we'll move out this system
155:28 - dot out Dot println outside of this Loop
155:32 - and print the sum on the screen
155:37 - let's see what happens when you run the
155:39 - code I forgot the semicolon here yeah
155:48 - so the sum of all the numbers from 1 to
155:52 - 10 is 55. now let me show you two more
155:56 - interesting programs that you can write
155:59 - using a for Loop
156:01 - the first one is that you can print out
156:03 - multiplication tables of any number
156:08 - using nested for loops
156:11 - for that what we need is a number so we
156:16 - will Begin by taking a new integer in
156:19 - number
156:22 - pi
156:26 - then inside the for Loop let's get rid
156:29 - of all this code and rewrite the for
156:32 - loop from scratch so we will say for
156:37 - then another integer the multiplier we
156:40 - will begin from one then if the
156:43 - multiplier
156:45 - is less than 10 we will keep going
156:49 - and we'll also increase the value of
156:54 - multiplier by 1.
156:57 - then inside the loop body we can say
157:00 - system dot out Dot
157:03 - print F in this case
157:06 - modulus D into modulus D is equals
157:11 - modulus t
157:14 - now we will say number
157:17 - then the second part would be the
157:20 - multiplier
157:21 - and finally number into multiplier
157:28 - now I hope you remember that the printf
157:32 - method doesn't have any new line
157:34 - character at the end
157:36 - so if you run the program at its current
157:39 - state let's see what happens
157:44 - as you can see it prints out the entire
157:47 - multiplication table in a single line
157:49 - which we do not want
157:51 - so what we can do is we can put a
157:54 - backslash n at the end of the line which
157:58 - will print out each row in a new line
158:01 - run the program
158:07 - excellent
158:10 - now we can take it a bit further to the
158:13 - audience
158:14 - let's get rid of the current code
158:20 - and let's begin with the new for Loop
158:22 - okay
158:24 - for inch number
158:27 - equals one
158:29 - number is less than 10.
158:33 - and number
158:35 - plus plus
158:36 - then inside the for Loop we will have a
158:40 - nested for loop I hope you remember that
158:42 - we have worked with nested if statements
158:45 - in the past we can also nest for Loops
158:48 - within each other so we can do 4
158:51 - into multiplier equals one
158:57 - multiplier is less than 10 and
159:01 - multiplier
159:03 - plus plus
159:05 - now inside the loop body we will say
159:07 - system dot out Dot
159:11 - printf
159:13 - modulus T into modulus T equals to
159:17 - modular state
159:19 - so the first thing would be the number
159:21 - so
159:23 - since
159:25 - the nested for Loop is inside the outer
159:28 - for Loop any variable declared within
159:31 - the outer for Loop will be accessible
159:33 - inside the nested folder but any
159:35 - variable that you declare inside the
159:37 - nested Loop such as this multiplier here
159:40 - will not be visible to the Outer Loop so
159:44 - we can send number so we will replace
159:47 - the first modulus D with a number
159:51 - then we will say
159:53 - multiplier
159:55 - and finally number into multiplier
160:00 - in the line
160:02 - save our code
160:05 - and let's run it
160:12 - okay just like before we have to add a
160:16 - new line character at the end
160:19 - to make it look a bit nicer
160:24 - so as you can see now we have
160:27 - successfully printed out the
160:29 - multiplication table for all the numbers
160:31 - from one
160:34 - to nine
160:36 - but if you would like to include 10 here
160:39 - you can say less than or equal
160:45 - and then run the code
160:51 - yeah it works fine and I also just
160:54 - noticed that we are missing again here
160:58 - and
161:00 - you can fix that by saying multiplier is
161:03 - less than or equal to 10. right
161:11 - so let me explain what happens here
161:17 - first inside the outer for Loop you are
161:21 - initializing a number with one and you
161:24 - are continuing to Loop until the value
161:27 - of number exceeds 10 so less than or
161:30 - equal 10
161:32 - and then inside the loop body you have
161:35 - another loop
161:36 - so first it comes and says okay number
161:38 - is equals one it's less than 10 then it
161:41 - goes inside the inner for Loop and it
161:44 - sees that there is a multiplier with the
161:46 - value of one multipliers value is less
161:49 - than 10 then it goes inside the body
161:52 - once a body has been executed
161:55 - it prints out one into one equals one
161:59 - and then it goes back to the update part
162:02 - of the inner loop and it checks again
162:04 - then it keeps looping within the inner
162:08 - loop once the value of multiplier has
162:11 - exceeded 10
162:13 - the inner loop breaks and the program
162:16 - goes back to the outer loop it increases
162:19 - the value of number by 1 which becomes 2
162:22 - now and it goes inside the inner loop
162:25 - again and prints out the multiplication
162:26 - table for two then it goes on to print
162:30 - out three
162:32 - four five six seven eight nine and ten
162:36 - so if you're having difficulty
162:38 - deciphering this complicated code here I
162:42 - would suggest that you write this code
162:44 - yourself and use a notebook to
162:48 - understand
162:48 - how these values changes in each
162:52 - iteration okay so finally I would like
162:55 - to show you an example of using an if
162:58 - else statement within afford for example
163:01 - if I tell you to print out all the odd
163:05 - numbers from 1 to 50 you can do that by
163:09 - using a for Loop and a single if else
163:12 - statement let's begin
163:16 - for
163:19 - int number equals one
163:24 - number is less than or equals to 50.
163:29 - number plus plus so this Loop will begin
163:32 - at one and end at 50.
163:36 - then inside the loop body what we want
163:39 - to do is we want to check
163:42 - if
163:44 - number
163:47 - modulus 2
163:49 - is equals equals one
163:53 - then system dot r dot println
163:58 - number
164:00 - [Music]
164:02 - so if you divide a number by 2 and the
164:05 - remainder is 1 it's pretty sure that
164:08 - the number is an odd number we all know
164:12 - that
164:13 - so what we are doing is inside the for
164:15 - Loop we are taking whatever the value of
164:17 - number is we are dividing that by 2 and
164:20 - checking if the remainder is one or not
164:23 - that's what the modular operator is for
164:26 - I hope you remember and if the number is
164:29 - an odd number we will print it out and
164:32 - if it is an even number we will skip
164:35 - that let's run the code and see what
164:37 - happens
164:40 - so as you can see we have successfully
164:42 - printed out all the on odd numbers from
164:46 - 1 to 50 so 1 3 5 7 9 11 13 15 and it
164:51 - goes on to 45 47 and 49.
164:55 - there is another variant of the for Loop
164:57 - that makes looping over collections such
165:00 - as array is much easier
165:03 - now for that first we'll need an array
165:08 - numbers
165:10 - equals uh I'll just put the regular
165:14 - numbers here
165:19 - there you go
165:21 - now
165:22 - to use this special type of for Loop you
165:25 - will have to write
165:27 - for
165:29 - then inside you will say int number this
165:33 - type has to match with the type of the
165:36 - array
165:37 - and then you will put a colon here and
165:40 - then you will put the name of the array
165:44 - then inside the area body you can say
165:48 - system dot out dot print Ln number
165:55 - let's see what happens
166:03 - so as you can see the loop successfully
166:06 - goes through the entire array and prints
166:09 - out each element to the console now
166:11 - What's Happening Here is uh you are
166:14 - saying for every single integer number
166:17 - in the numbers array you want to print
166:20 - them out so instead of using an integer
166:24 - as an index and accessing the elements
166:27 - individually you are kind of taking a
166:30 - shortcut
166:31 - and extracting each value from the
166:34 - numbers array and putting them in the
166:38 - number variable on each iteration now
166:41 - you can do anything that you could have
166:43 - done in a regular for Loop such as if
166:45 - you want the sum of all these numbers
166:48 - you can do so like this
166:55 - some classicals number
166:58 - [Music]
167:00 - and then system dot out Dot println
167:06 - it's so make sure you are putting the
167:09 - printerland call outside of the loop
167:12 - otherwise this will be printed every
167:15 - single time the loop iterates let's run
167:18 - the code and see what happens
167:22 - there you go other than the for Loop
167:25 - there is also the while loop and do
167:28 - while loop in Java these are two
167:30 - different kinds of Loops that can more
167:33 - or less do the same thing as a for Loop
167:36 - but the for Loops are a lot more common
167:40 - in the wild than the while Loops now I
167:43 - will show you two examples of using a
167:45 - while and two while loop first let's
167:48 - begin with the while loop
167:53 - we will simply print out the
167:55 - multiplication table like we did in the
167:58 - case of the for Loop but this time we
168:00 - will use a while now first you will need
168:03 - a number
168:06 - just like before
168:09 - then you will need the multiplier
168:18 - now to write a while loop you will have
168:20 - to say while
168:24 - multiplier is less than or equals 10
168:29 - then inside the loop body you will say
168:32 - system dot out Dot printf
168:36 - modulus T into modulus T equals modulus
168:41 - T since all of the variables are
168:43 - integers in this case then you will put
168:46 - number
168:47 - then the multiplier finally the number
168:50 - into multiplier
168:53 - excellent then once you have printed out
168:57 - the row in the multiplication table you
168:59 - will have to
169:01 - increase the multiplier by 1.
169:04 - multiplier plus plus
169:07 - let's run the code and see what happens
169:15 - so here looks like the program works
169:18 - just fine we have to just put a new line
169:20 - character to make the output a bit more
169:23 - readable
169:25 - foreign
169:28 - there you go
169:30 - now the main difference between a while
169:32 - loop and a for Loop is the fact that the
169:36 - while loop only has one component which
169:40 - is
169:40 - the condition in case of a for Loop we
169:44 - had the initialization we had the
169:46 - condition we had the loop body and we
169:49 - also had the update part but in this
169:51 - case there is just the condition and of
169:54 - course we have the loop body so you will
169:57 - have to do the initializations
169:59 - outside of the loop and you will have to
170:03 - perform the update or
170:06 - the incrementation of the multiplier or
170:10 - maybe counter or whatever you are
170:12 - working with
170:13 - inside the loops body
170:15 - so this is how a while loop looks like
170:19 - now a do while loop
170:23 - Works similarly but in a different order
170:26 - and also looks a bit different so in
170:29 - case of a do while loop you will have to
170:31 - write do
170:33 - then you will have the loop body
170:37 - which in our case is these two lines we
170:40 - want to print out the multiplication
170:42 - table once again and also increase the
170:44 - multiplier
170:45 - and after the loop body you will say
170:48 - while
170:51 - multiplier is less than or equals 10.
170:57 - let's comment out our old while loop
171:04 - make our console bigger and run the code
171:08 - foreign
171:16 - output now the main difference between a
171:20 - regular while loop and a two white Loop
171:23 - is the fact that in this case first the
171:28 - loop body will be executed and then the
171:31 - condition will be checked whereas in
171:34 - case of a while loop the condition gets
171:37 - evaluated and then the loop body gets
171:39 - executed so you will surely find usage
171:43 - of both kind of Loops if you worked long
171:47 - enough
171:48 - but I can say from experience that for
171:52 - Loops are a lot more common than whites
171:55 - or do vials
171:57 - let's just clean up our code before we
172:01 - leave from this lesson yeah
172:03 - so far in this course you have learned
172:06 - about only one way of putting a bunch of
172:10 - values together and that is the arrays
172:14 - but arrays have some limitation and the
172:17 - biggest one of them is the fact that you
172:20 - cannot resize an array the only way to
172:24 - make an area larger or smaller than it
172:27 - already is to copy it and change its
172:31 - length during the copy but there is
172:34 - another type and error list which is
172:38 - like a dynamic array you can create an
172:41 - arraylist you can put item in it or you
172:44 - can take away items from it and it will
172:48 - also adjust its length depending on how
172:51 - many elements it's holding
172:54 - now to use an error list in your code
172:58 - you will have to first import the error
173:02 - list class to do so you will have to
173:05 - write import
173:08 - java.util Dot
173:11 - errorist
173:18 - then
173:19 - to create an array list you will have to
173:23 - write
173:26 - array list
173:28 - then you will have to put a less than
173:31 - sign and inside you will have to write
173:34 - the type of the data you want to store
173:37 - in this array list
173:40 - now I know so far you have been only
173:43 - seeing int and this is the first time
173:46 - you are seeing something called an
173:48 - integer used as a type I will explain
173:51 - what this is but let's just keep on
173:55 - typing and finish creating our new error
173:58 - list okay so error list integer then
174:01 - name of the error list which in this
174:03 - case will be number
174:05 - equals
174:07 - new
174:09 - error list
174:13 - integer
174:15 - that's it we now have an empty error
174:18 - list of integers
174:21 - I forgot the is there
174:25 - now what's this integer class here
174:28 - I have taught you that data types such
174:32 - as int
174:35 - or double or float
174:39 - Boolean these are all primitive types
174:42 - but in Java you can also make them as
174:46 - reference types using the wrapper
174:48 - classes
174:50 - so this integer class share integer is
174:53 - actually a wrapper class
174:56 - for the Primitive type INT in other
174:59 - words
175:01 - integer is the reference type form of
175:05 - the regular inch type so just like
175:08 - integer you also have double
175:12 - float Boolean and so on
175:15 - and when you are creating an array list
175:18 - you cannot use the Primitive in type you
175:21 - have to use the integer wrapper class
175:24 - I hope that makes sense
175:27 - since we have an in the error list in
175:30 - our hand let's put some item in it
175:34 - now to insert a new item in an error
175:37 - list you cannot just use the old Curly
175:40 - braces syntax rather you will have to
175:43 - use the add method
175:45 - in this way you will have to write
175:47 - numbers then dot add
175:51 - then the value that you are trying to
175:53 - add which in this case will be one
175:58 - and a semicolon
176:01 - you can make a bunch of copies of this
176:04 - line and just
176:06 - add other numbers as well
176:10 - there you go
176:13 - now to print out an error list to the
176:16 - console you will have to write system
176:19 - dot out Dot println
176:25 - numbers which is the name of our error
176:28 - list in this case then Dot
176:30 - to a string
176:34 - now the two string is a method that is
176:37 - present in every single reference type
176:40 - in Java and later on when you will learn
176:43 - about object oriented programming you
176:45 - will also learn about creating your own
176:47 - twisting methods within your custom
176:49 - classes
176:50 - for now just remember that to print out
176:53 - an error list you will have to write out
176:55 - the name of the error list first and
176:57 - then the method to history
177:00 - let's run the code and see if it runs
177:03 - fine or not
177:10 - so as you can see the error list looks
177:13 - like an array in the console
177:16 - now you can also print out a single
177:19 - value
177:20 - from the arraylist if you want to
177:23 - but for that you will have to use
177:26 - the get method so you'll subdoc then get
177:33 - then the git method actually takes an
177:36 - integer
177:38 - which will be the index of the value you
177:41 - are trying to print
177:43 - like arrays error listers are also zero
177:47 - based so the first index of an error
177:50 - list will always be zero
177:52 - so the index of one in this case is 0
177:56 - to 1. 2
178:01 - three and four so if you want to print
178:04 - out three on the console you will have
178:06 - to send numbers dot get and then two
178:09 - here
178:10 - let's run the code
178:18 - beautiful we have three printed out on
178:21 - the console
178:23 - I have already said that analysts are
178:26 - Dynamic so you can add as many elements
178:30 - as you want using the add method and you
178:33 - can also remove elements from an error
178:35 - list
178:36 - so if you say numbers
178:39 - dot remove
178:42 - and it will take a number which will be
178:45 - the index of the element you are trying
178:47 - to delete so if you want to remove 3
178:50 - from our error list we will say numbers
178:54 - dot remove and pass2
178:58 - then let's print out the entire error
179:01 - list and see if she exists or not
179:05 - question
179:07 - okay
179:08 - let's run the code
179:15 - yeah three has been successfully removed
179:18 - but you can also remove items by value
179:23 - so for example if I want to get rid of 4
179:27 - I can do so but
179:30 - instead of passing and primitive 4 if
179:34 - you write 4 here this will be a
179:36 - primitive integer Type 4 it will work as
179:40 - an index but if you pass
179:43 - a reference Type 4 like this integer
179:50 - dot value of
179:53 - and then pass the Primitive type which
179:56 - in this case is 4
179:58 - and if we run the code
180:05 - you will see that we have successfully
180:08 - removed four from our error list now an
180:13 - error list can store anything starting
180:15 - from integers booleans characters
180:18 - strings and your custom class objects
180:21 - anything that you can think of we will
180:24 - work with much more complex at least
180:28 - in later lessons for now just let's get
180:31 - hang of the basics okay now you can also
180:34 - remove all the items from an error list
180:37 - by saying the name of the earliest Dot
180:42 - clear
180:43 - this will clear out the entire error
180:45 - list and make it empty
180:50 - there you go so I have already showed
180:53 - you how you can add new items to an
180:55 - error list how you can get them remove
180:57 - them clear an entire analyst now let me
181:01 - show you how you can update an element
181:04 - inside an error list
181:06 - for that there is the set method
181:09 - so you will type out the name of the
181:11 - error list then Dot
181:14 - and is a set
181:17 - and you will have to put an index here
181:20 - so again let's update
181:24 - the 3 here and its index is 2 we'll put
181:27 - 2 here comma then you will have to put
181:31 - the value that you want to replace three
181:34 - with
181:35 - and since the the error list is of
181:39 - reference types you will have to use the
181:42 - integer Dot
181:45 - value of method once again and we will
181:50 - say 30 so we will replace
181:53 - 3 with 30. let's run the code and see
181:56 - what happens
182:01 - excellent it it works out just fine
182:04 - so like an array you can also sort your
182:06 - array list
182:08 - right now we have added the numbers in a
182:13 - sequential order here but
182:16 - if we randomize them like for example if
182:20 - we put five
182:22 - at the top then one after three
182:28 - then two at the end
182:35 - okay let's get rid of this indices
182:37 - because
182:39 - now these are getting
182:43 - misleading
182:45 - okay let's run the code and see what
182:47 - happens
182:52 - so as you can see the numbers are all
182:55 - jumbled around now to sort this error
182:58 - list you will have to write the name of
183:00 - the arraylist the DOT
183:02 - and then
183:05 - sort
183:08 - in the method now you can see that there
183:11 - is a small squiggly line under the sort
183:14 - method name and this is because the sort
183:17 - method will actually take a parameter
183:21 - which is known as a comparator okay so
183:25 - as you can see it says comparator in the
183:28 - parameter list
183:31 - let me explain what this is first let's
183:33 - import the comparator class so it's a
183:37 - import
183:38 - Java
183:40 - dot util
183:43 - Dot comparator
183:46 - and then inside the sort method we will
183:49 - say
183:51 - comparator dot natural
183:56 - order which which is a method inside the
183:59 - comparator class
184:00 - and what we are saying is that sort this
184:04 - error list in its natural order okay
184:08 - let's run the code and see if it works
184:11 - or not
184:15 - yeah it works just fine we have
184:18 - successfully sorted our error list now
184:21 - you can also reverse the order of this
184:24 - error list by saying
184:26 - compared to Dot
184:29 - reverse order
184:32 - which is similar to Natural order but
184:34 - this time all the values will be sorted
184:37 - in a reverse manner
184:42 - there you go we have five four three two
184:45 - one liftoff now three very small but
184:49 - useful methods that the allergies have
184:52 - is the size method the contains method
184:55 - and the intimator
184:58 - first let's see what the size method
185:01 - does so if you ever want to know how
185:04 - many elements are there inside an error
185:07 - list you can just say the name of the
185:10 - error list and then
185:12 - size
185:15 - now this size method will return an
185:18 - integer after counting all the elements
185:23 - in the error list you can also check
185:26 - whether an error list contains a certain
185:29 - value or not and to do that you will
185:32 - have to write contains and since
185:37 - these are all reference type numbers
185:39 - we'll have to use the integer Dot
185:44 - value of method and we will have to put
185:47 - for example one let's check if the error
185:50 - list contains one or not
185:56 - see it says true which means it contains
185:59 - one and if we put 10 here the output
186:01 - should be false
186:07 - and yes it does
186:10 - now there is another method that checks
186:12 - whether an error list contains anything
186:14 - at all or not and it's
186:18 - the
186:21 - is
186:22 - empty method
186:25 - and since our analyst here actually
186:27 - contains some elements the output should
186:30 - be false
186:34 - and yes it is but if we clear our list
186:39 - just be before checking for emptiness we
186:44 - will see
186:47 - yeah it says true
186:50 - now the final thing that I would like to
186:53 - show you is the for each Loop
186:57 - now you have learned about the for Loop
186:59 - already in a previous lesson and you
187:01 - know that you can use it to Loop over
187:04 - regular arrays
187:06 - but when it comes to an arraylist there
187:09 - is another kind of loop let me show you
187:12 - how it works now keep in mind the forage
187:16 - Loop looks and works a lot differently
187:19 - than the for Loops but I'll try my best
187:23 - to explain them as lucidly as I can
187:27 - foreign
187:31 - list that you want to Loop over such as
187:35 - numbers and then
187:38 - for each
187:41 - then here it says action what you will
187:44 - say is
187:47 - number
187:49 - then you will make an arrow like this
187:52 - and then a set of curly braces
187:56 - now inside the set of curly braces you
187:59 - will say something like system
188:02 - Dot out
188:06 - dot print Ln
188:10 - and let's multiply each number with two
188:12 - just as an example so you'll send number
188:16 - into two
188:19 - and in our line
188:24 - now let's also print out the entire
188:28 - arraylist at the end so numbers dot to
188:34 - string
188:35 - yeah let's run the code for now and then
188:38 - I will explain what's happening inside
188:40 - the for each Loop
188:42 - run
188:48 - so as you can see we have successfully
188:50 - multiplied each value in this error list
188:53 - and we have also printed out the
188:55 - original arraylist here now let me
188:58 - explain the forage Loop for you so when
189:00 - you are saying numbers dot for each
189:03 - number you are saying that for each
189:07 - number in the numbers arraylist
189:11 - you want to perform the actions within
189:15 - this set of curly braces or within this
189:17 - block of code
189:19 - so imagine this Arrow like we are
189:23 - ordering the compiler like for each
189:26 - number perform this action that I am
189:30 - pointing towards
189:31 - now technically it's called a Lambda
189:34 - expression it's it's like a method that
189:38 - doesn't have any name
189:40 - now of course I'm over simplifying stuff
189:43 - here but for now this is enough to
189:46 - understand now as you can see that
189:49 - although you are multiplying each value
189:51 - of the numbers I released we do inside
189:55 - the forage Loop body the original error
189:59 - list remains unchanged
190:02 - now let's just for practice uh update
190:06 - the original error list and replace each
190:10 - value with their multiplied counterparts
190:13 - okay
190:15 - now to do that what we can do is
190:19 - let's first print out the original
190:23 - error list we will say
190:27 - uh B4
190:31 - and plus yeah we are going to use the
190:34 - plus sign once again in this case
190:37 - because it's a simple program
190:40 - and then we will take this out and we
190:44 - will say after
190:49 - plus and then
190:51 - number start doing string okay now
190:53 - inside the for each Loop what we want to
190:56 - do is we want to say
190:59 - numbers
191:01 - dot set and inside the set of
191:04 - parentheses we will say numbers Dot
191:09 - index of which is another method that
191:12 - can return the index of a given value so
191:17 - will bus number here
191:21 - comma number
191:24 - into two
191:26 - so you are essentially
191:29 - using the index of method to get the
191:32 - index of the current value of the number
191:34 - variable and then we are updating its
191:38 - element with the multiplied value okay
191:40 - let's get rid of the println call here
191:46 - and let's keep our fingers crossed and
191:50 - try to run the program
191:58 - yeah seems like it has worked out we
192:01 - have successfully overwritten all the
192:04 - values of the error list with their
192:07 - multiplied counterparts now this is one
192:10 - of the many fun programs that you can
192:13 - write to practice your skills I would
192:15 - suggest that you go around the internet
192:17 - find interesting problems that feels
192:20 - challenging to you and solve them to
192:24 - flex those Java muscles okay
192:27 - now that you have learned about air
192:28 - release let me show you another kind of
192:31 - collection that's pretty common and
192:33 - pretty useful in some scenarios these
192:36 - are called hash Maps now hash maps are
192:40 - actually key value Pairs and if you want
192:43 - to compare it python then python
192:46 - dictionaries are kind of similar to Hash
192:49 - Maps
192:50 - now to work with hash Maps first you
192:53 - will have to import the hashmap class
192:57 - to do so you will just write import
193:00 - java.util Dot hashmap
193:04 - let's get rid of all the early code and
193:09 - start working on hashmap okay
193:12 - Now to create a new hash map in Java you
193:15 - will have to write hash map
193:19 - and then just like the add list you will
193:22 - have to first put the type of the key
193:27 - so in my case I am making a hash map
193:30 - where I'll be storing the scores for my
193:34 - different subjects maybe at my school or
193:36 - summer
193:38 - so the key will be string
193:43 - and the value will be the scores of the
193:46 - subject so maybe English 98 maths 85 and
193:52 - so on so this will be integers
193:56 - and then I will name the hash map
193:59 - something maybe uh
194:03 - exams course
194:06 - equals to new
194:09 - hash map
194:12 - string integer
194:17 - that's it
194:19 - we have successfully created an empty
194:22 - hash map and since I have already
194:23 - discussed
194:25 - these wrapper classes in a previous
194:27 - lesson I will not repeat
194:31 - now to put something in this new hash
194:33 - map you can use the put method
194:38 - so exams course
194:42 - dot put
194:44 - and first we will need to put the name
194:47 - of the subject so it will be a string
194:50 - and
194:52 - maybe a math
194:55 - and then a comma and then this course
194:58 - I'm not that good at math so maybe 75
195:03 - then we will say exam
195:10 - scores
195:12 - dot put
195:14 - another subject may be a sociology
195:20 - and 85
195:23 - exams scores dot put English
195:33 - 95 and so on
195:36 - now to print out a hash map to the
195:39 - console you can say system dot out Dot
195:44 - println
195:46 - exam discourse dot to string just like
195:51 - you did with the error list
195:53 - okay let's run the code and see if
195:56 - everything works or not run
196:04 - excellent the hash map prints out
196:07 - uh so my score for English is 95
196:10 - sociology 85 and math 75. uh I hope you
196:15 - have already guessed that the item you
196:18 - are putting into the hash map is not
196:21 - sorted so even though I have put math at
196:25 - first it comes out in the end so if I
196:28 - put some more subjects
196:31 - foreign
196:46 - and let's see
196:48 - what ordered this show up in the console
196:54 - see as they're actually showing up in
196:56 - random order but that's how hash maps
196:59 - are you don't have to worry about them
197:01 - now you can also print out a single
197:05 - value from a hash map to do so you will
197:08 - have to write
197:10 - the name of the hash map then a DOT and
197:13 - get
197:15 - then you will have to pass a key in our
197:20 - case the keys are all strings so I will
197:24 - write
197:25 - let's get the score for
197:28 - English
197:32 - run
197:37 - and yeah we are getting the score of
197:40 - English now apart from the put method
197:43 - there is also another method put if
197:46 - absent that first checks if a value
197:50 - already exists in the hash map or not
197:53 - and if it doesn't then it will put it
197:55 - otherwise it will just skip it now you
197:59 - can
198:00 - write exam scores Dot
198:05 - put if absent
198:08 - and let's try out with math
198:13 - math and let's put a new value here
198:17 - maybe 70.
198:21 - and then I would print out the entire
198:24 - hash map here
198:26 - string
198:28 - nice
198:36 - so as you can see the value of math is
198:39 - still 75 even though I have tried to put
198:42 - a new value for it but since the put if
198:45 - absent method actually checks whether
198:47 - math already exists or not in the hash
198:50 - map it didn't override the original
198:52 - value now if you want to replace one of
198:55 - the values however you can use the
198:57 - replace method
199:00 - and it will take a key in this case we
199:02 - are still working with math and we are
199:05 - updating its value from 75 to 70. what a
199:09 - shame
199:13 - so as you can see the value of math has
199:17 - been changed to 70. now just like the
199:20 - put if absent method there is another
199:23 - method called get or default
199:27 - for example
199:29 - if I try to get
199:33 - a key that doesn't exist let's say for
199:37 - example religion
199:44 - we know that it doesn't exist in our
199:46 - hash map let's see what the output is
199:53 - as you can see it says null but if we
199:57 - say get or default
200:02 - and we give it a default value of 0.
200:07 - or maybe -1
200:08 - and run the code
200:16 - so the program will return -1 if the
200:19 - given key is not bound
200:22 - now like an error list you can clear a
200:26 - hash map by saying
200:28 - exams course
200:31 - Dot
200:33 - clear
200:35 - and this should clear out the entire
200:37 - hash map
200:49 - there you go and now if you want to
200:52 - check the number of elements that exist
200:55 - on the hash map you can do so by saying
200:59 - the name of the hashmap dot size
201:03 - this will return an integer after
201:06 - counting all the elements present in the
201:08 - hash map right now which is 0 because we
201:10 - have just cleared it out
201:12 - but if we get rid of that line it should
201:15 - be back to five
201:21 - excellent to remove an item from the
201:25 - hash map you can use the remove method
201:27 - like this exam scores dot remove and
201:33 - then you should put a name of this one
201:37 - of these keys so let's get rid of
201:39 - sociology
201:41 - and I'll put it here semicolon then exam
201:45 - score start to be string
201:49 - let's run the code
202:02 - as you can see sociology is not present
202:05 - here now you may also want to check
202:08 - whether a certain item exists on the
202:11 - hatch map or not and you can do that in
202:14 - two OS
202:15 - either you can check for a key
202:18 - or you can check for a value for example
202:22 - if I want to check if the math key
202:25 - exists or no I can do so by saying the
202:29 - name of the hashmap exam scores dot
202:33 - contains
202:35 - key and then the key I want to check
202:39 - against which is math in the this case
202:50 - and it comes out as true
202:53 - now if I want to check if I have this
202:57 - code 100 in any of the subjects or not I
203:01 - can do so by saying examscores Dot
203:05 - contains
203:07 - value and then the value I'm looking for
203:10 - which in this case is 100.
203:19 - now you can also put a reference type
203:22 - 100 here if you want to do that
203:26 - the value of and
203:30 - it shouldn't make any difference
203:37 - yeah it just works and I have also
203:40 - taught you that in case of at least when
203:43 - you are trying to update one of the
203:45 - values you need to pass the integer as
203:48 - in reference type you can actually pass
203:50 - a primitive type as well the set method
203:53 - will convert it to a reference type
203:55 - automatically but it's up to you what
203:58 - you would like to do and what you want
204:00 - finally you can check if a hash map is
204:03 - empty or Not by using
204:07 - the name of the hash map which is
204:09 - examsforce Dot
204:12 - is empty and since our hashmap is not
204:17 - indeed this should return false
204:22 - yeah it returns as false
204:25 - cache Maps also have for each Loop just
204:29 - like arraylist and now I will show you
204:32 - an example of using them with hashmaps
204:35 - to do so first you will need to write
204:37 - out the name of the hashmap which is the
204:40 - exams course in this case then you will
204:42 - set Dot
204:44 - for each
204:47 - just like at least you will create a new
204:50 - Lambda method here but in this case it
204:54 - will say
204:55 - the key
204:57 - comma the value then the arrow and
205:02 - the curly braces now the key here is the
205:06 - subject and the value
205:09 - is this Force so I'll just do it like
205:12 - this
205:13 - and then system dot out dot print Ln
205:19 - name of the subject
205:23 - Plus
205:26 - Dash plus the associated score let's put
205:31 - a semicolon at the end
205:33 - get rid of these empty call
205:38 - and see if it works or not okay I just
205:40 - noticed that there is a small squiggly
205:43 - line here that's because I didn't
205:47 - enclose the two variables within a set
205:49 - of parentheses here
205:51 - in case of an error list we had only one
205:55 - variable so it didn't need this
205:56 - parenthesis but since we have multiple
205:58 - variables here subject and score we will
206:01 - need a set of parentheses around them
206:03 - let's run the code and see if it works
206:06 - or not
206:10 - okay seems like it works now what we are
206:14 - going to do we will Loop over the entire
206:17 - hash map just like we did in case of the
206:19 - error list and we will update the value
206:22 - of each subject score just for the
206:25 - purpose of practice now to do that
206:29 - we already have the name of the subject
206:32 - which is the key and we also have the
206:34 - value which is the score
206:37 - to update the values we will say exam
206:41 - score start replace you have already
206:45 - learned about this then we will subject
206:48 - which is the key and then we will take
206:51 - away 10.
206:54 - from each subject maybe for bad behavior
206:57 - or something
206:59 - then we will say system dot out Dot
207:03 - println
207:05 - and exam scores dot blue string
207:13 - okay I hope everything works out fine
207:15 - and I cannot spot any mistakes let's hit
207:18 - the Run button
207:25 - yeah so I have indeed taken out 10 from
207:29 - each subject so English was 95 and now
207:32 - it's 85 Bengali was 100 and now it's 90
207:36 - sociology is 75 from 85 computer
207:40 - programming has become 90 from 100 and
207:42 - finally math has become 65 from 75.
207:47 - again I would suggest that you go into
207:49 - the internet looking for problems that
207:51 - you can solve to just practice all the
207:54 - things you are learning in this course
207:55 - this will really make you confident in
207:58 - Java now that you have learned most of
208:01 - the basics of java it's time that we
208:04 - start discussing about object oriented
208:06 - programming now the concept of
208:08 - object-oriented programming in itself is
208:10 - really huge and to be very honest you
208:14 - cannot learn how to make good
208:16 - object-oriented programs from a course
208:19 - or a book what I can do is I can teach
208:23 - you the basic concepts around
208:25 - object-oriented programming
208:27 - and once you have learned them you will
208:29 - have to learn the rest from experience
208:32 - by making larger and larger software
208:35 - following good practices and so on
208:39 - now at a higher level object-oriented
208:41 - programming is about modeling your
208:44 - software around real life objects for
208:47 - example maybe we can build a book
208:50 - borrowing system where a user can come
208:53 - register and login check for a book's
208:56 - availability borrow it if it's available
208:59 - and they can also return it on time they
209:03 - can also check the list of the books
209:05 - they have borrowed so far now in this
209:08 - aforementioned system there can be two
209:10 - objects one the user and two the book
209:15 - we can store information such as the
209:18 - user's name and birthday and in case of
209:22 - a book we can store the book's title and
209:24 - maybe the name of its authors and so on
209:28 - so let's begin by creating a user class
209:30 - in our software and as we keep working
209:34 - on this simple program we will learn
209:36 - about the different concepts around
209:39 - object-oriented programming so first
209:42 - open up the files menu by clicking on
209:45 - the file icon here and
209:48 - click on the add file button name your
209:51 - new file user Dot
209:54 - Java in this file you will need to
209:58 - create a new class like we have done
210:00 - with the hello world file so write
210:04 - public class
210:07 - user now we are declaring this class as
210:11 - public because we want this class to be
210:13 - available within our entire program
210:17 - now inside the class we will store the
210:19 - user's name which can be string so
210:23 - public
210:24 - string name
210:26 - and we will also store the user's date
210:30 - of birth
210:32 - so we will say public
210:34 - local date which is a reference type for
210:38 - storing dates in Java
210:40 - and we'll say birthday
210:44 - now to use the local Red class within
210:47 - our user class we will have to first
210:49 - import it so import Java dot time dot
210:54 - local date
210:55 - uh by the way do not get intimidated
210:58 - about the amount of classes that Java
211:01 - has built into it as you will keep
211:04 - working with Java for months or maybe
211:07 - for years you will eventually learn
211:09 - about a lot of them
211:12 - now we have a new user class let's go
211:15 - back to our hello world class and create
211:17 - a new user object now creating a custom
211:20 - object like a user object is not very
211:24 - different from creating a string
211:26 - so you will have to write user which
211:29 - will be the type of our object
211:31 - then you will have to name the object
211:33 - maybe let's name it younger user because
211:37 - we will have a older user as well later
211:40 - on
211:41 - equals new
211:44 - user and a set of parentheses now we
211:48 - have a user but this user at its current
211:51 - state doesn't have any name or date of
211:54 - birth
211:56 - since these variables are declared in
211:59 - the class level of the user class this
212:02 - will be initialized as null by default
212:06 - so they will get default values
212:09 - now variables like these at a class
212:12 - level are called properties
212:14 - and since these properties are tagged as
212:16 - public we can actually access them from
212:20 - outside of the user class and give some
212:23 - value to them
212:25 - so we will say
212:28 - younger user dot name equals
212:32 - [Music]
212:33 - Farhan hasin Junior
212:37 - excellent then younger
212:41 - user Dot
212:43 - birth J equals
212:46 - local date Dot
212:49 - purse and inside the purse method we
212:53 - will pass
212:56 - 1995
212:58 - 0 1
213:00 - 31 which means 31st January 1995.
213:06 - now the local date.burst method can pass
213:09 - a date from a given string and convert
213:12 - it to local date type again for using
213:15 - the local date class here we will have
213:17 - to first import it so import Java dot
213:21 - time dot local dates then we would also
213:26 - like to print something out on the
213:28 - screen and for that we'll say system dot
213:33 - out Dot printf
213:36 - and inside the printf method
213:40 - we will say that modulus
213:45 - s was born back in modulus s
213:51 - then after the comma we will replace the
213:54 - first format specifier here with the
213:56 - names so we will say younger user
214:00 - dot name
214:04 - and then after that we would like to
214:06 - replace the second format specified with
214:09 - the birthday
214:10 - but since the birthday is not a string
214:13 - you will have to first convert deep
214:16 - string by calling the twisting method
214:18 - and I have already said that the
214:20 - twisting method usually exists in all
214:23 - the reference types and
214:26 - any local date object is actually
214:28 - reference type
214:29 - let's try running our program and see if
214:32 - it works or not
214:37 - so yeah it works just fine Farhan hasin
214:40 - Junior was warning back in 1995 c131
214:44 - now I have already said once that using
214:48 - something called Methods we can actually
214:51 - Implement some Dynamic behaviors to our
214:53 - classes
214:54 - for example since we have the per day of
214:58 - the user we can use it to calculate
215:00 - their current age
215:02 - so we will create a new public method
215:04 - public because we want this method to be
215:09 - accessible throughout our entire program
215:11 - and then we will have to write the
215:13 - return type of our method which in this
215:16 - case is integer because age is always an
215:19 - integer
215:20 - then we will put the name of the method
215:23 - which is age
215:26 - and put a pair of curly braces
215:29 - now from inside the method we will
215:31 - calculate the age into H equals
215:36 - and for that Java actually has a pretty
215:39 - nifty class
215:41 - so in import
215:43 - Java dot time dot period
215:48 - now this period class has some method
215:51 - that you can use to calculate the
215:54 - difference between two local date types
215:58 - so we will say
216:01 - period
216:03 - dot between
216:06 - and inside this method called we will
216:10 - put a starting date which is the
216:12 - birthday so we will say this Dot
216:16 - birthday I will explain this this later
216:20 - on and then we'll put
216:24 - local date dot now now this period dot
216:29 - between method call will actually
216:32 - calculate the difference between the
216:34 - user's birthday and our current day and
216:37 - then we would like to return age dot get
216:42 - years because we want to return the age
216:45 - in years okay we do not want anything
216:48 - else
216:49 - let's go back to our hello world class
216:52 - and change this string to something like
216:57 - was born back in and he is now modulus
217:03 - is
217:04 - a module does d ears port
217:08 - so you say
217:10 - that user was born back in the birthday
217:14 - and he is now X years old so we'll put a
217:18 - comma after the twisting call and say
217:21 - younger user dot h and we will put a set
217:26 - of parentheses because this is a method
217:28 - and you will need to put a set of
217:30 - parentheses to call any method in Java
217:33 - let's run the program and see if it
217:36 - works or not
217:43 - yeah looks like everything has worked
217:45 - out just fine it says foreign Junior was
217:49 - born back in 1995.
217:53 - 0131 and he is now 27 years old
217:56 - excellent
217:58 - now what is this blue this keyword here
218:02 - now to explain this we will actually
218:05 - need two users so let's create a new
218:09 - user
218:10 - user older user
218:14 - equals new user
218:18 - and we'll say holder user dot name
218:22 - equals
218:24 - senior
218:27 - and then you will say folder user Dot
218:32 - birthday equals local date Dot
218:38 - first
218:39 - and let's put
218:43 - 1975
218:45 - 0 1
218:48 - 15.
218:52 - okay now we'll put this system out Dot
218:57 - printf
219:00 - at line 10.
219:03 - and we'll make a copy of it at the end
219:06 - of our program postponed back in uh okay
219:10 - all right let's replace younger user
219:13 - with older user
219:16 - let's run the code and see what happens
219:23 - foreign
219:27 - ERS Engineers born 27 years old and this
219:31 - is 47 years old nice now
219:34 - you can see that we have two different
219:37 - users in our program and both of these
219:41 - users are actually created from the same
219:44 - user class
219:46 - so when we are trying to calculate the
219:48 - age of the user how would the computer
219:51 - know which user we are referring or
219:55 - which date of birth we are referring to
219:57 - this is where the this keyword comes in
220:01 - you see we have two instances of the
220:04 - user cluster and this keyword will refer
220:08 - to the current object being worked on so
220:12 - when we are saying younger user dot age
220:15 - then the value of this will be the
220:18 - younger user object
220:21 - and when you are saying older user.h the
220:25 - value of this would be the older user
220:28 - object okay so let's
220:31 - get rid of the extra user here
220:35 - change the younger user's name to just
220:38 - user
220:48 - and let's start working on the book
220:51 - class
220:52 - let's go back to the files menu create a
220:55 - new file with the name book Dot Java
221:02 - now let's declare a new class public
221:06 - Plus
221:08 - book and for a book we would like to
221:12 - store
221:14 - a public
221:16 - freeing
221:17 - title and public
221:20 - history author
221:23 - yeah that's pretty much it for the book
221:25 - class now let's go back to the hello
221:27 - world again
221:29 - and we will say book
221:35 - equals to new
221:38 - book
221:40 - and then book dot title equals to
221:45 - carmilla
221:48 - book dot author equals to
221:52 - Shelton
221:56 - let's put a semicolon at the end and now
221:58 - we have a new book
222:00 - so how about we implement the
222:03 - functionality of borrowing books I will
222:07 - put it in the user class so let's close
222:11 - this menu as we don't need that
222:14 - and we will create a new method here
222:18 - path leak
222:20 - borrow
222:23 - and this borrow method will actually
222:26 - accept a parameter because this method
222:29 - has to know which book the user is
222:32 - trying to borrow right
222:34 - so we will say book so this method is
222:39 - actually accepting variable of book type
222:43 - then
222:46 - let's create arraylist
222:50 - of type book
222:53 - let's call it books
222:56 - equals new array list
223:01 - and book
223:04 - closing and we will also have to import
223:07 - the error list class so import
223:11 - ant
223:12 - java.util dot arraylist okay then we can
223:16 - say
223:17 - this dot books dot add
223:23 - and book
223:27 - so you're adding the book we have
223:29 - received within the borrow method to our
223:33 - list of books okay
223:36 - let's go back to our hello world class
223:39 - and we will say
223:42 - user dot borrow
223:46 - and we will pass the book to it
223:49 - I think we have made a small mistake
223:52 - that is we haven't said what kind of
223:56 - data the borrow method is returning now
223:59 - as you can see the method actually
224:01 - returning nothing so we will have to say
224:05 - for it which means it doesn't return
224:07 - anything at all there is no return
224:09 - statement whatsoever it just makes some
224:13 - changes to the books error list
224:15 - okay let's go back to hello world and
224:18 - this looks all right so far let's update
224:23 - this printf method
224:25 - yeah and h
224:28 - okay let's let's write another one
224:31 - system dot out Dot printf
224:37 - and it will say modulus s has
224:41 - borrowed
224:43 - these books
224:46 - and with some modulus s okay let's put a
224:50 - comma here and we will say user dot name
224:55 - has borrowed
224:59 - user dot books
225:03 - dot two string
225:07 - okay
225:08 - uh let's also put a new line character
225:11 - at the end of our printf statements
225:15 - otherwise they may not look as good as
225:18 - we want them to be
225:20 - okay let's run the program and see what
225:22 - happens then we will go through what
225:24 - happening in this entire system once
225:27 - again
225:34 - foreign
225:36 - just as I expected so as you can see it
225:40 - says Farhan has engineer was born back
225:42 - in 1919 and so on and then it says
225:46 - Farhan has engineer has borrowed this
225:48 - book's book at and then a large number
225:52 - but we are expecting maybe the name of
225:55 - the book or maybe the name of the author
225:57 - or something like that right but that
225:59 - didn't happen let me tell you why
226:02 - you can see that we have been using the
226:06 - method to string a lot right by using
226:10 - the method twisting a lot and I have
226:13 - already said that this twist string
226:16 - method
226:17 - comes with every single reference types
226:22 - now our book here is a custom class and
226:26 - whatever book object we are working with
226:28 - are all reference types
226:30 - now since we have created the book class
226:33 - ourselves it doesn't have a built into a
226:37 - string method that's why we are getting
226:40 - some random values here
226:42 - now to solve this problem we will have
226:45 - to implement a twisting method we can do
226:49 - that by saying public
226:52 - string
226:53 - to string
226:55 - and then we will return a string
226:58 - representation of this book like return
227:02 - string dot format here and we'll say
227:06 - modulus s by
227:09 - modulus is then a full stop and after
227:12 - the comma we will say
227:14 - this dot title
227:18 - and this dot author so whenever we are
227:22 - trying to access one of the properties
227:24 - within a class from a method within the
227:27 - same class we can use that this keyword
227:32 - okay let's try to run the program once
227:35 - again and see if it solves our issue or
227:37 - not
227:38 - let's make our console bigger
227:43 - foreign
227:55 - I think that full stop there looks
227:58 - pretty bad because it's going to show up
228:00 - like a list of books
228:03 - let's get rid of that
228:06 - and also I think this is a good time to
228:09 - switch back to the Stacked layout once
228:12 - again since our codes are getting bigger
228:15 - horizontally and this gives us a better
228:18 - look at our lights
228:20 - okay so what have we done so far we have
228:23 - created two custom classes representing
228:25 - our users and the books we have created
228:30 - a new user object we have given him the
228:33 - ability to borrow books from us we have
228:37 - also calculated their age using method
228:40 - we have implemented title and author for
228:43 - our books and we have also implemented
228:46 - accustomed to string method so this is
228:49 - really a lot to be honest but we will do
228:52 - more now so far we have been declaring
228:55 - all our methods and our properties as
228:58 - public but to be very honest this is not
229:00 - something you should be doing a lot
229:04 - let's learn about something called a
229:08 - Constructor
229:10 - as you can see when you are trying to
229:12 - create a new user you are saying user
229:14 - then name of the user object equals new
229:17 - and then you are writing the name of the
229:20 - class once again and then a set of
229:22 - parentheses as if you are trying to call
229:25 - a method called user
229:28 - well that's kind of true
229:30 - every single class that we have in Java
229:33 - has a special method called Constructor
229:36 - this method is responsible for
229:40 - initializing all the properties with
229:43 - their default values so what we can do
229:46 - is we can customize these Constructor
229:49 - method and make it do things
229:52 - let's start by writing a Constructor for
229:56 - our user class okay
229:58 - we will say
230:01 - user and will not write anything like
230:04 - public or maybe some sort of return type
230:08 - nothing at all we will just start by
230:11 - writing what the name of the class is
230:14 - then we will put a set of parentheses
230:17 - and set of curly braces so this is our
230:20 - Constructor method now let's think about
230:23 - what we want from the user when they are
230:25 - creating a new user object right
230:29 - we want their name so we will receive or
230:33 - ask for their name and we will also ask
230:36 - for their birthday
230:39 - now this birthday
230:41 - can be taken as a local date but we will
230:44 - take it as a string
230:47 - I will tell you why
230:50 - but
230:51 - now inside this Constructor method we
230:54 - will say
230:55 - this dot name equals name
230:59 - and this Dot
231:03 - birthday equals local date dot purse
231:09 - birthday
231:12 - so what we are doing essentially is we
231:15 - are asking the user for a name and we
231:18 - are storing that name in the name
231:21 - variable or name property within the
231:24 - user class then we are also asking for a
231:26 - birthday and we are storing that
231:28 - birthday in the birthday property but
231:31 - since the birthday property is of type
231:34 - local date we will have to purse the
231:36 - birthday from a string format to local
231:39 - date format now let's go back to our
231:41 - hello world class and make the necessary
231:44 - changes here we will say user equals
231:47 - user and we will put the name
231:51 - inside this Constructor call and we'll
231:54 - put a comma here and we'll also put the
231:58 - birthday
232:00 - within the Constructor call because now
232:03 - the user class is capable of accepting
232:06 - these two values let's run the code and
232:09 - see if everything works just as before
232:11 - or not
232:17 - seems like I have made a small typo here
232:21 - the D should have been capital
232:26 - foreign
232:33 - just like before
232:36 - now
232:38 - since we can initialize the user with a
232:41 - name and a date of birth right at the
232:43 - creation process
232:45 - we can actually make the name and
232:48 - birthday private
232:50 - which means we can no longer do things
232:54 - like
232:57 - user dot birthday or user dot name
233:02 - but we still need to know the user's
233:05 - name and user part derived
233:07 - for that we have something called
233:10 - getters
233:12 - so we will create a new method
233:16 - somewhere in this user class public
233:21 - get name
233:24 - and the return type B string
233:28 - and we will say return this dot name
233:33 - and we will also say public string get
233:39 - birthday
233:41 - and you will say return this dot
233:45 - birthday dot to string
233:49 - now let's go back to the hello world
233:51 - class and make use of these two Getters
233:54 - we will come down to printf and we will
233:57 - say user dot get name
234:01 - how do you say
234:03 - user dot get
234:07 - birthday and we'll get rid of the two
234:09 - string calls since the birthday will
234:12 - come back as a string by default
234:14 - now let's run the code and see how it
234:17 - works
234:23 - okay we also have to replace this name
234:26 - here and as you can see since we have
234:28 - made the name properties private the
234:32 - hello world class actually fails to
234:34 - access the user's name which is a good
234:37 - thing
234:38 - I will explain why let's just make it
234:41 - working again
234:47 - so yeah it's it's back to normal now
234:51 - since
234:53 - the name and birthday properties have
234:56 - become private no one can change their
234:59 - values from outside the user class
235:03 - which means these are now much more
235:06 - secret than they were before another
235:09 - thing that is now we can pass the name
235:12 - of the user
235:14 - and the birthday as a strings the hello
235:18 - world class has no business in knowing
235:21 - what is the actual type of the birthday
235:24 - is
235:25 - all the Hello World Class needs to know
235:28 - that if it passes a user name and a
235:33 - birthday in string format a new user
235:35 - will be creative
235:37 - this is called abstraction
235:40 - so what we are doing is we are hiding
235:43 - the complexities of the user class
235:46 - behind this beautiful looking Gator
235:50 - methods Constructor methods you can
235:54 - already see how cleaner the user object
235:57 - creation looks compared to the book
236:00 - object creations
236:02 - let's make the same changes to the book
236:05 - class as well so we will go back to it
236:08 - and change the title
236:11 - and author to private
236:16 - then we will Implement to getter methods
236:18 - so public
236:21 - get title
236:25 - return this title the return type will
236:29 - be string
236:31 - and then we will say public
236:36 - a string
236:38 - get author and we say return this Dot
236:45 - author
236:47 - Etc
236:48 - let's also implement the Constructor so
236:51 - we will say book
236:53 - we will take the title as a string and
236:57 - then we will take the author name as a
236:59 - string
237:00 - then we will set this dot title equals
237:04 - title
237:07 - and this dot author
237:11 - equals author
237:13 - nice
237:15 - let's update the creation process so we
237:20 - will pass the title of the book and the
237:22 - name of the author
237:24 - with the new keyword and get rid of that
237:31 - excellent the program already looks much
237:34 - cleaner now another thing that I would
237:36 - like to change is I would like to make
237:39 - the books list private and Implement a
237:42 - getter for that as well so let's go back
237:44 - to the user class and let's say
237:48 - foreign
237:49 - public
237:52 - and this time we will be returning
237:57 - string
238:01 - borrowed books
238:06 - and we'll say return peace dot books dot
238:10 - history
238:12 - excellent
238:15 - now the hello world class doesn't know
238:17 - about the complexities of the books list
238:20 - either we'll just say
238:23 - borrowed volts
238:26 - did I meet it private yet no I didn't so
238:30 - we will make it private
238:33 - okay let's see if the program works just
238:37 - as before or not
238:44 - excellent the program works just as
238:46 - before
238:48 - now I hope you can already see the
238:51 - beauty of object rendered programming
238:53 - and how cleaner the program actually
238:55 - looks in reality
238:58 - we still have to learn a few more
239:02 - Concepts around object entry programming
239:05 - such as inheritance now assume that our
239:10 - book borrowing system has multiple types
239:12 - of booths there can be the regular books
239:15 - I mean the hardcover ones or the printed
239:18 - ones then there can be ebooks and there
239:22 - can be audio books now although they
239:25 - have some similarities they also have
239:28 - some differences such as
239:30 - the ebooks and the regular books have
239:34 - page counts where the audio books have
239:37 - run times
239:40 - also the ebooks have formats such as PDF
239:45 - or ePub or so on so trying to implement
239:49 - different kinds of books using the same
239:52 - class can be cumbersome
239:55 - now you may think that you will make
239:58 - copies of the book class and add or
240:01 - remove the necessary properties methods
240:03 - to them but that's not a very good idea
240:06 - this is why inheritance comes in
240:10 - so we can make a default book class with
240:14 - the most common properties and methods
240:17 - in it and then we can make
240:19 - child book classes that will inherit all
240:24 - the properties and methods from the
240:26 - parent book class and we can also add
240:29 - some new properties and methods to them
240:32 - let's see an example first we will add
240:35 - the page count property to the book so
240:38 - we will say private
240:42 - int page count
240:46 - and for that we will have to pass
240:51 - the page count to the Constructor here
240:54 - so we'll set this Dot Page count equals
240:58 - page count
241:00 - we'll go back to our hello world class
241:02 - and we will say
241:04 - I don't remember the actual page count
241:07 - of the book but let's put 270.
241:10 - nice everything should be normal let's
241:13 - run that code and make sure
241:20 - ah that was a silly mistake I didn't
241:22 - accept the parameter here
241:28 - let's run the program and make sure
241:34 - excellent
241:36 - now we will create a new audio book
241:40 - class
241:42 - audio book Dot
241:46 - Java
241:47 - yes
241:51 - and we will say public
241:54 - class audio book
241:57 - extends
241:59 - book now since we are declaring this
242:03 - audiobook class as an extension of the
242:06 - parent book class it already has
242:10 - all these properties and methods we have
242:13 - described here
242:15 - so what we need to add is a runtime so
242:19 - it's a private int
242:23 - front
242:26 - so runtime means
242:28 - how long these audio books run so the
242:31 - runtime will be in minutes
242:34 - then we will have to create
242:36 - a new Constructor here so we'll say
242:38 - audio book
242:41 - just like before and we will accept the
242:44 - runtime
242:45 - so it's a int
242:48 - runtime
242:49 - and then inside the pair of curly braces
242:52 - we will say
242:54 - this Dot
242:56 - runtime
243:00 - equals
243:02 - runtime now here is a problem I have
243:05 - already said that since this audiobook
243:07 - class is an extension of the book class
243:10 - it also inherits all these private
243:14 - properties which means we will still
243:17 - have to fill them up somehow
243:21 - but the audiobook Constructor
243:24 - doesn't accept any of these values
243:28 - okay let's see what we can do to solve
243:30 - this first we'll copy all these
243:33 - parameters from the book Constructor
243:36 - and add them to the audiobook
243:38 - Constructor
243:40 - one of the problems have been solved we
243:42 - are now accepting all the necessary
243:45 - information for the parent book class
243:48 - now we will say super
243:51 - and we will pass title
243:54 - author and pitch count
243:58 - now the super keyword here actually
244:01 - refers to the parent class of our
244:04 - current class so when you are calling
244:07 - the method super we are actually calling
244:10 - the Constructor of the parent book class
244:13 - so we have successfully filled up all
244:17 - the necessary properties of the parent
244:19 - class as well let's try out by creating
244:23 - a new audiobook
244:25 - let's go back to the hello world class
244:27 - and after book
244:30 - we will say
244:35 - audiobook
244:38 - equals
244:43 - new audio book
244:48 - and we will say Dracula
244:52 - foreign
244:54 - stalker
244:59 - and the page count
245:04 - actually we do not have to pass the page
245:06 - count here we can modify our Constructor
245:10 - a little bit we do not need to accept
245:12 - the page counter
245:14 - instead we can pass 0 as the page count
245:18 - yeah that would be better and we can
245:20 - just accept the runtime
245:22 - so for example maybe the Dracula book
245:25 - would run for 30 000 minutes so I put 30
245:30 - thousands here
245:32 - audiobook see I have made a mistake
245:37 - and I think we should
245:39 - start naming our books so carmilla
245:43 - [Music]
245:46 - okay so we have successfully created a
245:49 - new audio book here just for the sake of
245:52 - our codes Clarity let's get rid of all
245:55 - the code that we do not need so we will
245:58 - get rid of
245:59 - the user dot borrow call we have seen
246:03 - examples of that we will also get rid of
246:06 - the system.out.printf calls we will get
246:09 - rid of the user as well because for now
246:12 - we will be focusing strictly on books
246:14 - audio books and ebooks
246:17 - so let's create a new
246:20 - system.out.printf method here
246:23 - we will say
246:27 - sorry
246:29 - Dracula dot two string
246:33 - [Music]
246:34 - because remember that the audiobook
246:37 - class already inherits the two string
246:41 - method from the book class
246:43 - okay let's print out something on the
246:46 - screen so it's a system dot out dot
246:49 - print
246:51 - Ln
246:53 - and Dracula dot Google string
246:58 - let's run the code and see if it works
247:01 - or not
247:07 - yeah it works just fine okay now that we
247:11 - have a audiobook class let's create a
247:14 - new class called ebook
247:19 - chef
247:21 - okay King public
247:27 - class
247:28 - ebook extends
247:34 - and then within the set of curly braces
247:37 - uh actually we can copy a bunch of code
247:41 - from here let's
247:43 - copy everything to the ebook class
247:47 - and we will say
247:50 - private is string
247:53 - format
247:56 - and then we will accept
247:58 - everything and we will also accept the
248:01 - page count this time because ebooks have
248:05 - page count okay
248:07 - so input page account and then we will
248:11 - also accept the format so we'll say
248:14 - string format
248:17 - this dot format equals one CF
248:22 - nice uh yeah everything looks fine okay
248:27 - we have to change this to ebook
248:30 - let's go back to hello world and try to
248:33 - create a new ebook Okay so ebook
248:37 - so Jeeves I will create a Chiefs book
248:41 - new
248:43 - ebook
248:46 - carry
248:47 - on Chiefs
248:50 - written by PG
248:55 - old house I hope I'm spelling his name
248:58 - correctly
248:59 - then the page count would be 280 I guess
249:03 - and finally the format will be PDF
249:08 - let's put a semicolon there and let's
249:11 - see if the book has been created
249:14 - properly or not so Jeep stop to stream
249:23 - okay so carry on Jeeps by PG Port house
249:26 - so we have successfully created
249:28 - different kinds of books based on a
249:32 - parent class
249:34 - now this is what I had in store for this
249:38 - course in terms of object oriented
249:40 - programming I have taught you what are
249:43 - classes what are objects water
249:45 - properties and methods Constructor
249:48 - methods and you have also learned about
249:52 - inheritance
249:54 - now there are a lot of things that you
249:57 - will have to still learn like method
249:59 - overloading and overriding Abstract
250:03 - method and whatnot but I would not like
250:06 - to overwhelm you with all these Concepts
250:10 - in a single course
250:12 - what I would suggest that try to
250:16 - understand everything that I have taught
250:18 - you in this course uh as thoroughly as
250:21 - you can and then keep practicing make
250:25 - programs make bigger programs and try to
250:28 - understand whatever concept seems
250:32 - complex to you and as you keep working
250:35 - with Java as you keep making more and
250:38 - more fun projects you will start to
250:41 - understand a lot of the complex Concepts
250:43 - around object oriented programming and
250:46 - whatnot
250:47 - so I hope you have learned something
250:49 - good from this course and maybe someday
250:52 - I will see you in another course as well
250:54 - so till then stay safe and take care

Cleaned transcript:

you're about to learn how to program in Java from Farhan hassin children Farhan is an experienced software developer here at free code camp and he is great at breaking down concepts for beginners this is a great course if you want to learn Java and you can follow along with the whole course from within your web browser Farhan will teach you the basics of java using replit replit is an online IDE that allows people to write all sorts of programming languages right within their web browser and repl provided a grant that made this course possible so it's time to learn Java hello everyone welcome to the Java for beginners course I am Farhan Hassan chodri and in this course I will teach you all the fundamental concepts around Java now ideally a programming course usually starts by downloading and installing a lot of sdks or Ides or whatnot but since we will be using rapidly throughout the entire course we don't need to do any of those replete is an online collaborative IDE that you can use right from your browser to start go to www.reply.com and you should land on the page you can create an account on replete or if you already have an account just go ahead and log into that I will just use my Google account to log in once you have logged in you will land on your home page from here you can create a new Ripple by using this create button now from the list of language we will pick Java but just so that you know refleet supports a long list of languages make sure you are giving your new Rebels some descriptive names such as hello world finally hit the create triple button and wait until the process finishes now if you have worked with some other code editors such as Visual Studio code the look of replete should not be very different to you you can change its default layout by going to settings and default layout by default it should be side by side but you can also pick stacked if you like that layout Now the default Java Ripple usually comes with a bunch of code and you may have already guessed that this is the famous hello world program written in Jaffa to run this code click on this run button here and you will see the code's output on the console there you go congratulations on creating and running your first Rebel on the next lesson I will explain what's going on just before we leave remember you can always run replay dark by clicking on this Moon icon and if you prefer dark themes over the lighter ones please go ahead the hello world program is probably the simplest executable Java program that you can write yet it's very important that you understand each part of this program as you may have already guessed source files in Java end with the dot Java extension and compiled byte codes usually end with the dot class extension to see the compiled byte codes on replay click on these three dots on the files menu and click on show hidden files the program starts with a class declaration a class is a collection of related code in Java in every Java source file that is the file with the dot Java extension you can have one top level public class and that class has to match the name of the source file this is because if you have multiple classes in your program like this you will see that the Java compiler produces individual byte cores for each class to avoid any confusion about which of these classes is the entry point to the program the jvm is designed to treat the bytecode that matches the name of the source file as the entry point inside the class there is a main method those of you familiar with C C plus plus or go may already know that the main method or function serves as the NG point to your program the jvm is programmed in a way that it will specifically look for a static method that is named main has Public Access takes an array of string as a parameter and doesn't return any value so you will have to write your main method as public static void main string arcs and nothing else one thing that you can change however is the name of the args array to something like arguments the array holds the command line arguments passed to the program upon execution the system.out.print element method prints out whatever string you pass to it as an argument unlike python or JavaScript semicolons are mandatory in Java so if you leave it out the program will fail to compile that's pretty much it about the hello world program don't worry if you didn't understand all the terms used in this lesson you will have a much better idea about topics like public and private access modifiers Statics classes methods in later lessons now if you try to run the program using the Run button everything works out just as expected another thing that you can change is the entry point this will make sure that replit opens the correct Java source file whenever you decide to return to this project now there are a lot of other options in this dot replete file but those are not important right now the hello world program you have been seeing so far is pretty simple if you want to write more complex programs you will at least need some understanding of the different types of data and variables variable is any entity that can take on different values for example if you want to store your age inside a variable you can do so like this first you will have to write the type of the variable age is an integer or int then you will have to write the name of the variable which is age in this case then you can finish off by putting a semicolon you just declared a variable declaring means the compiler will know that this variable exists however you will also need to Define it you can do so by assigning a value to this variable like this write the name of the variable then an equal sign followed by your desired value in this case the equal sign is known as an assignment operator we'll learn about operator in lot more detail in lateral lessons now you can print out the variable to the console like this and just in case you are wondering using a plus sign is one of the many ways to print out a dynamic value in between sentences keep in mind you cannot use an uninitialized variable in Java so if you remove this line and try to run the code the code will fail with the error message variable age might not have been initialized instead of declaring and initializing the variable in different lines you can do it in one go like this on the line of Declaration after the name of the variable put an assignment operator followed by your desired value now if you try to run the code again see everything's back to normal you can change the value of a variable as many times as you want so if you set the value of the age variable to 28 instead of 27 just before printing it out you will see that the value has changed in the output although you can assign new values to the variable multiple times you cannot declare the same variable twice so if you do something like this and try to run the code the code will fail with the error message variable age is already defined in method Main if you look closely you will see two different sets of curly braces in this code the first set marks the start and end of the hello world class the second set is inside the class and marks the start and end of the main method code inside a set of curly braces is known as a code block since the main method is inside the hello world class any variable you declare inside the method will be only available inside the method these are local variables however you can also declare variables outside the method like here in the hello world class code block if you do that the variable will be available within the entire class to use this variable inside the main method you will have to declare it as a static we will discuss the reason behind this in a later lesson for now just remember that is static method can only work with static variables moving out the Declaration of the age variable and marking it as a static has not made any difference whatsoever but if you remove the value of the variable and attempt to rerun the program you will see the program runs without any issues this time and prints out 0 as the value of age this is because whenever you declare a variable in the class level the Java compiler will assign a default value to it for numbers it's always zero now another thing that I'd like to show you is if you redeclare the age variable inside the main method now there will be no problem whatsoever because the initial Declaration of the age variable is not local to the main method so as long as you do not redeclare a variable within the same code block you will be good to go when it comes to naming your variables you can name them anything as long as the names don't start with a number and don't have any spaces in them there are also around 50 words reserved by Java itself as keywords and you cannot use any of them either you can start a variable name with a dollar sign or an underscore but excessive usage of these signs can make your code unreadable in case of multiword names always follow camel casing when naming your variables if you want to learn about different programming naming conventions I leave the link to this article in the description finally avoid naming your variables using single letters now that you know about variables we will discuss the different types of data keep in mind I have reorganized the source file to better reflect what I will be talking about at a high level there are two types of data in Java there are the Primitive types and the nonprimitive or reference types primitive types store values for example int is a primitive type and it stores an integer value a reference type on the other hand stores the reference to a memory location where a dynamic object is being stored we will discuss reference types later there are eight primitive data types in Java six out of those eight types deals with different types of numbers first there are the bytes these are small numbers within the range of 128 to 127. then there are the shorts with a much larger range than bytes and the integers with an even larger range if you ever need to store a value so large that it doesn't fit in an INT you can use the long type by default any number with no decimal point is treated as an integer by the compiler to let the compiler know that a number is actually a long you have to append the letter L at the end of the number you can also use a small l in instead of the capital L if you want for numbers with decimal points in them there are double and Float types doubles are double Precision 64bit floating Point numbers with a very long range floats on the other hand are single position 32bit floating Point numbers with a smaller range by default any number with a decimal point is treated as a double by the compiler to let the compiler know that a number is actually a float you have to append the letter if at the end of the number like the lungs you can use a small If instead of the Capital One here Boolean data type can have only two values true or false at the moment usage of a data type that can only hold true or false as values may not seem that useful to you but once you learn about conditional statements you will see their usefulness finally the character type can hold any valid Unicode character the Unicode is kept sequence for the copyright symbol is backslash u00 A9 so if you store this value in a car variable and print it out on the console like this we have you will see that the copyright symbol has been printed on the console instead of the value we have saved of course you can also save any standard character from your keyboard instead of this kind of Unicode subsequences for example if we remove the name Copyright symbol and change it to something like percent symbol and replace these Unicode Escape character with the percent sign and update our code accordingly you will see the percentage symbol printed out on Console instead of the copyright symbol there you go now for the most part when working with integers the intype should suffice and for numbers with decimal points the double type should suffice but you should also know about the other types although you cannot store one type of data inside another type of variable conversion between the different types is absolutely possible type conversion in Java can be either implicit or explicit when the compiler converts a smaller type of data for example an integer to a larger one like a double automatically it's known as an implicit or narrowing type conversion let's see an example first get rid of all the old code in our project then Begin by declaring a new integer you can call call it anything then declare a double and for the value of the double type assign number one like this is essentially doing is first taking an integer with a value of Phi and then taking a double and assigning number one as its value let's try to print it out using the standard system.out.print Ln function number two and run so as you can see the compiler has successfully converted the integer to a double this is because a w is larger than an integer but what will happen if you try to do the reverse let's try out this time start with a double 5.8 Maybe then an INT okay I missed the two here now system.out.print Ln number two and drop so as you can see the program immediately fails saying incompatible types possible lossy conversion from double to in what the compiler is saying that an integer to double con conversion is not possible automatically although conversion from an in to a double is not possible automatically you can still do it explicitly by letting the compiler know that you want this to happen the cast operator can be of help here first inside a set of parentheses right end this will tell the compiler that you want to convert this double to an it let's try to run the program once again and this time the program works without any issues but you have lost the point eight part after 5. if you are doing explicit type conversion in Java be extremely careful whether the type you are converting to will be able to hold the entire value or not in this case I knew that an integer will never be able to hold the entire 5.8 value and I will lose the second part but I went with it anyway so as long as you know what you are doing you should be all right but at any given moment if you perform an explicit conversion and lose a bit of data accidentally the results can be catastrophic now that you know about variables and the different types of data you can work with in Java you will have to learn about operators keep in mind I have made some changes to our code to better explain our topic in hand and since our code has become much longer than before I suggest that you go to settings and change the default layout from stacked to side by side and then hit the reset layout button to apply the new layout this will give you a lot of vertical space and make the code easier to read operators in Java or programming in general are certain symbols that tell the compiler to perform certain operations such as arithmetic relational or logical operations although there are six types of operators in Java I will only discuss four bitwise operator are a little bit more complex than the other ones and I don't think they fit well in a beginner's course like this we will begin our discussion with arithmetic operators arithmetic operators are the ones that you can use to perform arithmetic operations such as addition subtraction multiplication or division or so on there are five arithmetic operators in Java and these are the addition operator the subtraction operator the multiplication operator the division operator and the remainder operator the remainder operator is also known as modulo or modulus operator addition subtraction multiplication and division these four are pretty selfexplanatory you can have a look at our code example here and you should be able to understand what they do and how they do it if you have used a calculator in real life the arithmetic operators in programming work similarly in our code we have two integer numbers number one and number two with the values 12 and 6 respectively so if you add number one and number two together the result will be 18. if you subtract number two from number one the result will be six if you multiply number one with number two the result will be 72 and finally if you divide number one by number two the result will be two we will talk about the remainder or modulo operator later the addition and multiplication operations in this code are pretty simple but the subtraction and division operation needs some more discussion so we'll get rid of our addition and multiplication code here we'll comment out the division code and the remainder code and focus solely on the subtraction part as you can see the value of number one is 12 and number two is six which means the number one is greater than number two as a result the result of the subtraction operator comes out as positive but if we change the order of the operation here so if we make number two the first operand and number one the second operand you will see that the result of the operation changes from 6 to 6 again if you have used calculator cngl live before you should already be aware of this situation now the division operation since dividing 12 by 6 yields the result 2 this operation is perfectly fine but if we change 6 with something like maybe five then the result will not be a whole number as you can see according to this program the result will be 2 but if we perform the same operation in a calculator or by hand we will know that the result of this operation should have been 2.4 now this happens because if you divide an integer with another integer the result will always be an integer so let's try by changing this integer type to a double for both operands and run the program once again as you can see this time the result is 2.4 but what happens if we divide a double by an integer again the result is 2.4 and if we change the first operand to an end and the second to a double the result will still be 2.4 which means if you divide an integer by another integer the result will always be an integer but if you divide a double or float by an integer or divide an integer by a double or float the result will always be another double now let's get rid of our division code as well and focus solely on the remainder or the modulus operation now for this example I would like to go back to our original verus which are 12 and 6 in the beginning and I'd like to go back to integer let's run the program and see what is the output compiling a program may take some time but we just need to be patient here so as you can see the result of this operation is zero first we need to understand what is a remainder now you may or may not already know that a reminder is the value that remains after you have divided a number with another one so if you divide 12 by 6 the result will be 2 and there will be nothing left you can always divide a 12 into two sixes but if I change 6 to something like maybe um eight and run the program once again as you can see the value has changed from 0 to 4 this is because if you try to divide 12 by 8 there will always be 4 left I hope you got the idea you have already seen examples of the assignment operators in previous lessons it's pretty simple you can use the equal sign to assign a value to any variable in your code but you can also combine the assignment operator with the five arithmetic operators you just learned about for example here we have a integer with a value of 12. now if I tell you that you will have to add 5 with this value and Save in the same variable you can do that like this now the output of number should be 17 instead of 12. very simple but instead of doing this in such a verbose manner you can do it far more easily let's just remove the second part here and instead of using the assignment operator use a plus sign then the assignment operator and then five this small line of code is actually equivalent to number equals number plus pi let's comment this out and see if this gives the same result as before or not okay yeah 70. so you can use all the five arithmetic operators similarly say for example if you want to take out 6 from 12 you can do so by saying number minus equals 6. and this will turn the value of number from 12 to 6. there you can also do modulus operation like this like if you say modulus equals and then 2 the result of this operation is 0 because when you divide 12 by 2 there will be 2 6s as a result and nothing left I hope you got the idea of using assignment operator with all the five arithmetic operators and I would suggest that you try out usage of the other ones like the multiplication sign and the division sign with the assignment Operator by yourself and see how the result varies from time to time so far in this course you have learned about the arithmetic operators and the assignment operators the arithmetic operators usually lets you perform different types of arithmetic operations on your numbers and the assignment operator usually lets you assign different kinds of value to variables relational operators on the other hand usually check the relation among multiple operands by relation what I mean is for example in this code we have two integer numbers number one and number two with the values 12 and 15 respectively now you may want to know whether number one or number two is equal to each other or maybe number one is greater than number two or maybe number one is less than number two or not these are the relation between these two numbers so in Java there are six types of relational operators the first one is the equality operator now keep in mind each relational operator in Java or in other programming languages as well usually returns true or false as a result of an operation for example on line 7 I have written system.out.printellent number one equals equals number two the usage of this double equal sign here is the equality operator now if I run the code since the value of number 1 and number 2 is not equal the output will be false which is correct in this case now you may also want to check whether number one is different from number two or not for that you can use the not equal to operator instead of putting two equal signs side by side you will have to put an exclamation sign followed by an equal sign now if I run the code again you will see that the second operation gives us a true because indeed number one is not equal to number two then you can also use the greater than operator to check whether number one is greater than number two or not since 12 is smaller than 15 the output of this line will be false there you go there is also the opposite of the greater than operator which is the less than operator and this operation in this case will give us true because number one is actually smaller than number two finally there are the greater than or equal operators and the less than or equal operator now the greater than or equal operator will give us true only if number one is greater than number 2 or equal to number two the less than or equal to operator on the other hand will give us true only and only if number one is less than number two or equals to number two since number one is actually less than number two the greater than or equal operation will give us false and the less than or equal operation will give us the result true now the usage of these relational operators may not seem uh that much fun to you at the moment but once you start working with things like relational statements you will start to understand how important these operators are The Logical operators in Java or in programming in general lets you make logical decision based on multiple conditions for example imagine you are writing a program that can only be used by people within the age limit of 18 years old to 40 years old here we have an integer number with a value of 25. now we will have to make two checks first we will have to check whether age is greater than or equal to 18 or not and then we will have to check whether age is less than or equal to 40 or not so you have already learned about the greater than or equal and less than or equal operators in the previous lesson here I will teach you how you can combine these two operators using a logical and operator to make a connected decision okay so let's write system dot out dot print Ln because we want to print out the result of our operation here and start with the graded then or equal operation age is greater than or equal 18 then you will have to put double M person sign and this is the logical and operator in Java and then age is less than or equal to 40. let's run the code and see what the output is as you can see the output is true here let me explain the logical and operator in Java or in other programming languages as well works in this way if the left side of the logical and operator and the right side of the logical and operator yields true as a result then the whole operation will give the result true here the value of age is 25 which is larger than 18 which means the left side is true and it's also less than 40 which means the right side is also true that's why the result of this end operation will be true but if you change this value to maybe something like 45 which is clearly over 40 years old and run the program once again you will see that the output becomes false because although the left side is true the right side is not so in case of a logical and operator both side of the operator has to be true I apart from The Logical and operator there is also a logical or operator okay let's imagine another scenario maybe you are writing a program for your school's library and to be able to borrow books from the library a person either has to be a student of your school or a member of the library so we can have two booleans here is a student which is false maybe this person is not a student of your school and is the library member is equals true maybe he is a member of your library now to check whether this person is a student or is a library member you can use the logical or operator like this system dot out Dot println and first we will check if this is a student or not student or unlike the logical and operator you have to use two pipe characters to express the logical or operator and then we will check is Library member I hope you remember that in order for the operation to be true in case of a logical and operation both sides of the operator had to be true but in case of the or operation if either side of the operator is true the entire operation will be true so as you can see although easy student is false given is Library member is true the operation gives us the result true so if if you turn both of these booleans to true the result will still be true and the only case when you will get a false result is if both of these booleans are false yes false and finally there is another type of logical operator in Java which is the not operator the not operator in programming usually reverses a Boolean value for example here the value of the easy student Boolean is clearly false right if if you run the program it will surely print out false but if we put a not operator in front of this this this exclamation sign is actually the not operator and run the program you will see that it it turns out as true so instead of using the not operator over a single Boolean value you can actually reverse the value of an entire and or or a person in Java like this let's go back a few steps and I I hope you remember that in this case we got the result false because both of these booleans are false now if you put a not operator in front of the Esky student Boolean this will be turned to true so now if I run the program the result of the entire operation will be true yes there you go the different types of operators that you have learned about so far easily work with multiple operands at a time except the not operator it usually works on a single value or variable at a time now these kind of operators that usually work with a single operand is usually called unary operators apart from the not operator there are also two more operators that are unary in nature and very commonly used in programming these are the increment operator and decrement operators assume that you are trying to make a game where you have to store the score of the player and the number of turns left now you can store these values in two different integer numbers maybe named score and turns now whenever you have to increase the value of score by 1 you can do so by saying score plus equals one you have already learned about the usage of the arithmetic operators along with the assignment operator in previous lessons well this is one way to do this using this method you can actually add any number prescore but since here in this code you will only increase the score by one well you may think that what kind of gain that is that gives you one in every term well that's just for the example okay just very good you can do it like plus plus so putting two double plus signs after an integer or maybe float or double or any number kind out there will increase its value by one similarly you can put 2 minus signs to decrease or decrement the value of a number time now if we print out the values of these two variable with system dot out Dot println score and we will just make a copy of this line and change it to terms you will see that the value of score is now 1 and the value of turns is now 9. so this is pretty simple incrementing and decrementing values there is nothing fancy until I I make it a bit complex let me show you something let's get rid of all this code and declare a new integer it's called number and maybe its value is 55. now if I say system dot out dot print Ln a number plus plus you may think that this will print out 56 because you know the EU increment 55 by 1 and it becomes 56 well let's see if if that's true or not hmm seems like that the value has not incremented at all okay let's make a copy of this line foreign and run the program again this time the value has changed but at line 5 where you have used the plus plus or the increment operator the value remained unchanged but on line 6 while you have haven't used any uh operator at all the value seems to be incremented or you see when the compiler reads your code it usually goes from left to right so when it comes to system.out.println and sees the number variable here it immediately prints out its value so at that point the value of number will be 55. then it sees that there is an increment operator here and it goes like Oh that means I have to increase the value by 1 as well then the compiler increases the value of number 256 and keeps that in memory so if you ever print out the value of number later on it will actually print out 56. now this is same for the minus minus sign or the decrement operator initially the value will be 55 even though the value has changed in the memory and on the second pretty statement it prints out 54. so far I have showed you only one way of writing the increment or decrement operator instead of writing it at the end you can also put it in front like this and let's see what output we get in this case as you can see this time we are getting 56 because when the compiler reads your code from left to right it goes like system.out.printellin and it immediately encounters the increment operator and then it sees the number and goes like okay so I have to increase the value of number and then print it out so it prints out 56 on line 5 and on line 6 as well same goes for the decrement operator 54 and 54. so this is something that you should be aware of when using the increment or decrement operator inside other statements like in this case the println method call if you are just incrementing or decrementing the number outside of anything like this method called like this number plus plus then you shouldn't have any problem at all see so if you ever get like unexpected values after using the incremental decrement operator in your program just make sure that you are using it correctly or you are using it in the right place I hope that you remember in a previous lesson I have taught you about the character type it is one of the Primitive types in Java and you can store any Unicode character in it like in this example I have stored the percentage sign in a character variable called the percent sign and I have printed out the character on my console using the standard system.out.printlend method now the character type is good and everything but if you want to store multiple characters together for example your name or a sentence you cannot use a character for that for this type of scenarios we have string in Java there are multiple ways of declaring a new string let's see the literal way first so instead of car you will need to type a string with a capital s and then name of the string in this case name and then the value so this is my name you can put any string right here and then you can print it out like any other variable in Java let's run the code foreign to declare a string in Java is by using the new keywords the new keyword in Java can be used to create new objects from classes now we have not discussed classes at all in this course yet but we will get into classes and objects and object rendered programming later on for now just remember that the new keyword can be used to create a new object from a class Now to create a string using the new keyword you will have to write string then the name of the string equals new string and the value like if you run the program there should be no change whatsoever because essentially declaring the string this way or that way it doesn't make any uh visible changes to the program but there is a slight difference in in these two techniques now the jvm or the Java virtual machine usually uses a portion of your computer's memory to store strings now this little portion of memory is usually called the string pull now whenever you create a new string in the literal way Java will first check whether this string Farhan has injury already exists in the string pull or not if it does then the jvm will simply reuse that previously string with a new name but in case of the new keyword the gvm will create a new object regardless of whether this value already exists in the pool or not I think this can be demonstrated with an example very well for this I will create four strings first one string literal E string 1 equals to A B C and I'll create another literally string with the same value but different name there you go now I will create two object string I mean don't get me wrong these strings are actually same but I am just naming them as literally string and object D string to make clear that which is what now object string equals to new string maybe e f g or XYZ so I'll make a copy of this string change its name to object string 2 with the same value now if I compare these four strings with each other like this print Ln literal string one equals equals literal string two and I'll make a copy of this line and use object string instead of literal ones sorry let's make this wider so that the code becomes easier to read and now if you if we run the code as you can see when declaring a new string using the literal format since the value ABC was already present in the string pool that jvm actually reused the older value with literally shrink to but when using the new keyword even though the same value has been assigned to the two string variables they are not same you have already learned that the W equals sign checks for the two objects are same or not and in this case the literally strings are actually same since they are using the same value from the pool and the objective strings are different entities because they are not reusing the same values from the pool now depending on your Necessities you may go with either of these techniques but I'd suggest that you go with the literally string technique if there is no problem with that because this will not only make your code easier to read there is no new or there is no duplicate is string written in the code but also it will let the compiler optimize your code a little bit but the strings in Java are not primitive types these are object types and the strings are literally one of the most powerful types in Java you will use strings a lot throughout your entire programming carrier and there are a lot of methods that we can use with this Stream So now I will demonstrate a few of those essential method that you can use on strings and do fancy things with this depending on the type of software you are working on you may or may not have to work a lot with string formatting now let me explain this topic with an example first I would suggest that you go back to the Stacked layout from side by side because now our code will get a lot longer sideways and not vertically okay let's begin by removing everything and writing a single system Dot out dot print as an statement and in here we will write a pretty long sentence this time Chase hello world I am sorry I am from Bangladesh and I am 26 years old very simple program if we run it here so you're getting the entire line without any changes now we can take out a bunch of stuff from this line such as my name then uh my country name finally my age now to use these variables inside this string you can use the plus sign you you may have already seen example of using the plus sign to like slotting Dynamic variables inside the strings you can do the same here so I'll get rid of farhanasan Chaudhary and in the string here so now the first string starts here and ends here the second one is starts here and ends right here and in between the two strings I put my name next I can take out the country name as well so I will separate the strings put two plus signs and put country in here nice finally the AIDS same drill separate the string to plus signs and the variable name okay let's save the code cross our fingers and run it yeah as you can see the output is fine but I hope you are getting a sense of how complicated this string can get once you start adding more variable sites such as if I add my company name the company word for uh company girls let's say free code camp a really nice place to work at so I can change it to I work or and then plus plus company now you can put plus and a DOT yeah works just fine so the point I'm trying to get through is the fact that Azure string grows and you start to use more and more variables in it using the plus sign to concatenate strings or add them together becomes really clumsy there is a better way to do this and that's formatting your restraints so let's declare another string called formatted string equals then we will write is string Dot format so my name is modulus s I am from modulus is I am modulus T years old and I work or modulus s so once we have written this line we will say comma so my name is modulus s so this modulus is or modulus D these characters are called format specifier so when the Java compiler comes and reads your line like this my name is modulus is the compiler knows that there will be a certain string here and when it reads I am modulus D years old the compiler will know that there will be an integer number here but the compiler doesn't know yet what is string or what integer value will replace this format specifiers so once you have finished writing your string along with the format is specifiers you will have to put a comma and then put in the variables in the same order of the formatting specifiers for example we have my name is modulus s and we want to replace this part with a name variable so we will put name then we will put a comma and then I am from modulus s and we want to replace this format specifier with the country name so country comma then we have modulus D which we want to replace with the h finally we have one more modulus s that we want to replace with the company name that's full stop here there you go now we have a formatted string so instead of writing this a long string with plus signs and variable names and what not in it we can just write for method string let's run the code and as you can see it works out just fine so far you have seen the format specifiers or strings and integers there are also certain formative specifiers for floating Point numbers and booleans so the format is specifier for a floating Point number B it a float or a double in Java is modulus f so if I put in a double here like Maybe by GPA equals uh three point eight and this is not real and I can write my GPA is modulus F and we can replace this modulus if with the value of GPA foreign excellent finally the format is specifier for a character is modulus C and A Boolean is modulus B now I can't think of any fun example to demonstrate modulus B and modulus C but I'll just go with it okay maybe character percent sign equals to put the percent sign here and I can say I have attended 100 percent of my University classes excellent and after the GPA I can just use a comma and put percent sign here cool then let's put a Boolean as well Boolean m i telling the truth equals false now I'm not reading the truth I I haven't added 100 of my classes and my GPA is also not 3.8 so um am I telling the truth yeah right these are all modulus B planes and I can put a comma here and then am I telling the truths yeah that's a really horrible name to be honest let's run the program again excellent my name is Farhan Hassan Chaudhary I'm from Bangladesh I am 26 years old I work for free code Camp my GPS 3.8 I have attended 100 of my University classes these are all false claims so as you can see the string dot format method returns a formatted string by replacing all the specified format specifiers with your given values now instead of saving this formatted string in a separate variable like I have done here you can actually just copy the entire thing and paste it inside the println call although it works and you can do this if you want but I would not suggest doing this because there is something called the printf function that you will learn later on in this course that actually lets you uh use the formative specifiers right in the print function so for now I would suggest that you save your formatted string in a different variable and then print that out using println or use that however you see fit so remember the format is specifier for a string is modulus s for an integer number also for shorts and Longs is for modulus d for floating Point numbers both floats and doubles modulus f or characters modulus C and finally for booleans modulus B while working with strings in Java it's really common to check the length of a string or you may want to check whether a string is empty or not like a lot of things in Java doing these two tasks is really easy let's start with a single string okay so extreme name Farhan has seen I have to check the length of this string you can write first the name of the string which is name then Dot length the length is a method that remains inside every string that you create in Java now if you run the code as you can see the length of the string is 22 which means there are 22 characters in the entire name including the spaces in between okay now you can also check whether a string is empty or not to do so you can just write the name of the string which is name in this case and then Dot and is empty this is another method that returns either true or false if the string is not empty then it will return false and if it's empty then it will return true let's run the code and the output in this case should be false since the string actually contains some characters in it now if I get rid of the name inside the string and just put two quotation marks with nothing in between them and run the code again this time the string will be treated as an empty string and the output will be true now the length and is empty methods can be pretty useful in certain scenarios so I would suggest that you remember them and practice their usage as you go along you can also convert strings from lowercase to uppercase or uppercase to lowercase in Java to do so first you will need a string then to convert this string to uppercase you just need to write the name of this string which in this case is same then a DOT and two upper case this is a method and if you run this program you will see that the name has become uppercase however you may think that these two uppercase method has actually changed the original string which is not true so if we add another println here printing out the original name you will see foreign variable is actually unchanged you can also convert the name to lower guess by using the two lowercase method and this will convert the entire string to lowercase there you go in a previous lesson I have taught you two ways to declare new strings in Java there was the literal way that usually reuses the string value if it's found in the string pool and then there was the usage of the new keyword and I hope that you also remember that when you created a string using the new keyword like this difficult to new string and the value can be something like a b c then make a copy of it and put a string two with the same value and try to compare them using the equals equals operator or the equality operator like this stem dot out dot print Ln is string 1 is equals equals string you will see that the output of this operation comes out as false this is because even though the value of the two string is same these are not the same object and the equality operator usually checks whether the object on the left side is same as the object on the right side or the object on the right side is same as the object on the left side now to compare strings you will have to instead use the equals method so we'll first write the name of one of the strings then equals and string two let's run the program once again and this time the output is true however if you change the second value of ABC to Capital ABC sure the output will be false this time since the values are not same but there can be cases where you want to check whether a string is equal to another string or not ignoring their cases so for those scenarios you can use the equals ignore case method instead of the regular equals method so as you can see even though the two strings have different casing the output is still true you can also replace a part of a string in Java to do so first you will need a string such as the sky is blue and then say for example we would like to replace the word blue with the red hair system dot out Dot println uh string which is the name of our string right now and then replace you'd like to replace the word blue three great then run the program and see what the output is as you can see the word blue has indeed been replaced with red now you may think that the replace method changes the original string but it doesn't there you go what it actually does is it replaces the white blue with red in the string and Returns the updated string as a new one so instead of putting it directly into the println method you can also do something like a string updated string equals to this and then put updated string inside the println method so this will give us the same result as before foreign you may not always want to replace a substring within a string but you may want to check whether a string contains a certain word or substring or not you can do so in Java as follows so we will use our previous string which says the sky is blue and we'll check whether this string contains the word sky or not to do so you will say string which is the name of our string here then a DOT and then contains and you will need to pass the string that you want to check for to the contains method in this case it's sky save the code and run it since the string contains the word Sky the output is true but if you put something that is not present within the string such as free quote cam and run the code the output is false back when I was learning to code for the first time one of the things that I learned and it gave me a sense of achievement was being able to take input from the user so far in this course you have learned about different types of data operators and outputting text on the console in this lesson I will show you how you can take different types of inputs from the user as well as print out text on the console in some other formats if you are familiar with programming languages like python where taking input is a matter of a single line you may be disappointed to learn that in Java you have to write quite a bit of code to take an input from the user now the first thing that you need to take input from the user is something called an scanner object now scanner is one of the classes in Java and you can use the new keyword to create a new scanner object from the class so you begin by writing scanner since the type of the object will be scanner and you can name it anything but I prefer naming it something simple like scanner then equals new scanner and you will have to let it know from where you are getting the input so since you will get the input from the console or The Terminal you will have to write system dot in now this scanner class that you are seeing here it doesn't exist in your program yet you will have to import it first so before the first line where you declare the class you will have to write import Java dot util dot scanner now you may be seeing this import statement for the first time here but it's nothing complicated there will be scenarios where a certain class will not be a part of your current program or your current class and you will have to import it from somewhere else so the Java language comes with a lot of such classes that can be really useful in different scenarios this scanner class is one of them so once you have defined the new scanner object you can take input from the user so first I would like to speed out something informative on the screen like system dot out Dot print Ln what is your name and then I'll in the line here and I will say scanner Dot next line that's it now the scanner dot next line method can be used to take strings as input from the user you will have to save this input somewhere though so you can say a string name equals scanner dot next line then you can print it out just let's print out the name for now okay let's run the program and and see if it works or not okay as you can see there is this quickly line under scanner and if you hover over it it says resource link scanner is never closed well what it essentially says is once you are done with the scanner you will have to close it it's like an Open Door so if you if you do not close it it will be active on the memory so you will have to go like scanner Dot close and this quickly line should go away yes it did yeah now the programming's fine let's run it yeah what is your name okay enter and yeah it prints out my name pretty nicely now you may notice that inputting my name after the prompt like what is your name then inputting my name in the next line may look a bit little bit weird so instead of using the println method what we can use here is the print method so the print method is actually similar to the println method but the main difference is that it doesn't have a new line character at the end of the line let me show you so as you can see now the text prompt is right after the question marks so I can say for huh yeah enter and yeah that's nice now in case of a println method there is usually a new line character at the end so this causes the text cursor to go to the next line let's run the code to see how it changes our output yeah as you can see now it mimics the behavior of the print element okay now apart from the print method there is another useful cousin of this print alone method called the printf in a previous lesson I have showed you how you can create formatted strings using different types of format specifiers and I also told you that there is a variation of the print Ln method that lets you use this format specifiers right within the print method okay that's that's the printf method or print formatted now instead of just printing out the name like this we can say hello modulus s how are you and then we will put a comma and we would like to replace the modulus with the name so we put name I hope you remember all the different affirmative specifiers that you have already learned about if not you can just go back and rewatch that lesson let's run the program again foreign treats me and also asks how am I okay let's do something more so you have learned that the next line method usually gives back a string from the user but you can also ask for specific data types such as maybe an integer so to do so let's modify the next print Affair so hello Farhan how old are you okay and then we would say int age equals to scanner Dot next Clint okay yeah nice and we would like to print out yeah and sorry not printed on print f modulus D is an excellent age to start programming okay like any age is like accidental learn programming so you know and we will put age here so this modulus D part will eventually be replaced by the age variables okay let's run it what is your name okay my name is Farhan how old are you 26 maybe yeah 26 is an excellent age to start programming nice I like it okay now so far so good like the next line method and next int method there are also methods for double like scanner dot next Double and next float and all those different types that you can think of but one thing that I would like to draw your attention to and something that catches a lot of uh Java beginners or card is a little quirk so as you can see I am asking for the name using the next line method then I'm asking for the age using the next int method and it works out just fine but let me show you what happens if I try to use another next line method after this next int method okay so if I say system dot out dot print Ln or PDF okay let's just reuse this line okay some excellent cage just start programming what language do we pray for yeah and after that we'll say string language equals to scanner dot next line okay Extreme Dot out Dot printf modulus is is a very popular programming language will stop close here now sorry I I missed the language here yeah now look carefully what happens when I run the program okay so I run the program so first it asks for my name Chase Farhan sure ask how old am I so 26 and then it skips the last prompt where I'm asking about the programming language preference and just insta program abruptly and the worst part is there is no error or no failure at all which can help you to debug this problem well this is something uh this has to do with the way the next end and the next line method works so let me explain so when you are saying a string name equals to scanner dot next line and I'm inputting my name then I'm pressing enter the next line method is actually taking the entire name along with my enter or my new line character at the end or the character when I press enter that goes as an input but when it comes to the next int method it only takes the number or 26 as an input and leaves the new line character or carriage return in the buffer in the input buffer so what happens is when I say at 26 and then I press enter this part will be consumed by this method next end but the enter will be left in the input buffer so so when the second next line call comes it sees that there is already an enter in the input buffer and mistakes it as a Enter key press from me so it assumes that the user has already inputted the text they wanted to input and insta call right there okay I hope it makes sense now there are multiple ways to like deal with this problem and one of the ways is whenever you put a next in call or next Double call or next float call whatever it is except next line then you will have to put okay an extra scanner dot next line here so this just like cleans up the input buffer so this next line method eats up the enter that was left by the next int and cleans the input buffer so if we run the program now okay let's say forehan and how about am i 26 what language do you prefer well Java yeah so this is something that you should keep in mind that whenever you are using a next ink call anything but a next line call and you want to put another next line call after that like we have here an extent and the next line you will have to put an extra scanner dot next line call just to clean up the input buffer just to get get rid of that uh leftover Enterprise okay otherwise your program May skip the next call okay another way to deal with this situation is instead of using methods like next end or next float you can just use next line for taking all the inputs and then once you have taken an input you can just like convert it to something else okay for example uh instead of using the next ink if we use the next line method here and this will give us a string so what we can do is we can say integer dot parse int and then put the scanner dot next line in there okay and let's run the program and see what happens on 86 um Java yeah it works out just fine and we do not have to use any extra scanner objects as well now if you had like instead of int you may have like uh double here you can do so a double say for example if we uh want to take the GPA of the user equals to to be the double Dot first double and then scanner Dot next one and this will work out too okay so uh all of the first method that we have in these classes like integer.parsing double dot purse double we can use all of this now you may think that how would I know uh which method to use when you are trying to purse a number from a string well uh one way that I suggest everyone is you can just Google it uh saying how to purse integer from a string in Java or maybe how to purse a double from a string in Java and so on or this is something that I would leave up to you to figure out because this is something that you do not learn in courses okay so I hope you have learned about taking inputs from the user the main thing you need is a scanner object and you will have to let it know from where you are getting your input uh you can also take input from a file and some other places but those are a bit of advanced for what you know at the moment and you will also have to remember to import the scanner class first otherwise the code will just fail okay if I comment this out and run the code you will see the program simply fails to find the scanner class it says cannot find symbol so make sure that you have imported the class at the top here and the rest is pretty simple I guess so now that you have learned about taking input from the user and outputting text on Console using printf print and println uh in the next lessons we will learn about something called the conditional statements and we'll make a very simple calculator project that will just show you how much you can do with what you have already learned now you have already learned about The Logical operators and taking input from user to all the most important things in programming in this lesson I will teach you something called conditionally statements that lets you make logical decision based on some conditions and Branch out your code in different ways for example we will make a calculator in this lesson and we will let the user perform addition subtraction multiplication and division operations uh based on their inputs so first we will need a scanner of course and let's get rid of all this code okay yeah so you need to close the scanner as well okay let's begin with a double double number one equals to scanner dot next Double and then we will also do number two scanner dot next w we need to output something on this screen as well print is on sorry let's use print here enter the first number and then we'll put enter the second number it's and let's just output the numbers to make sure that the input is working fine number one and then let's make a copy of this line number two yes let's run the code five and ten yeah looks like the input is working fine now we'll need to ask the user what operations they want to perform for that let's speed out what operation do you want to perform and okay we will use print instead of print alone and then we will have to take a string input it's a string operation equals to scanner dot next line so as I have already told you that this next Double calls will leave two next line characters in the input buffer so we will need to clear them out first so let's just put this extra calls here and once we have taken the string operation then we can check what it is okay so the if statements in Java or in programming in general lets you check uh whether a certain value meets a certain condition or not for our case we can say if then a set of parentheses operation Dot equals sum so if the user has written some as the name of the operation then what you want to do is system dot out Dot println and we will say not println printf modulus D plus modulus T equals to modulus D comma so we want to replace the first modulus D with number one this should have been F actually since you're working with double sir and not integers then number two finally number one plus number two space them out in the line with the semicolon excellent now let's check out our simple calculator and see if we can do the summation correctly or not so the first input will be five you can put anything you want the second number will be 10. what operation do you want to perform okay sum yeah 5 plus 10 equals 15. now what happens if I put anything but sum okay for now we are checking if the operation is equals to sum or not and this will return true if it returns true then the line inside the if statement will be executed but what happens if we input something else let's check it out ten two maybe subtraction or sub you see nothing happens so for situations where an if statement fails to fulfill the condition we can put an else statement and we can print out system dot out Dot println print F modulus s is not a supported operation and you can put a semicolon here and we can say comma operation let's see how it turns out okay five ten what's up sub is not a supported operation excellent now I have already said that we will Implement a summation subtraction multiplication and division for that what we can do is we can put lcv statement here so if this condition fails we can say else if and we can put another condition here so operation dot equals sub then what do you want copy this line put it here change the plus sign with minus and also change the operation here minus then we'd want to close this Gap make it look good so now what will happen the program will ask for the first number then the second number then ask for what kind of operation the user wants to perform and then first it will check if the operation is equal to sum or not if it's equal to sum then it will print out the sum of the two numbers if it's not the sum then the ladder will check whether the operation is equals to sub or not if it's sub then it will perform the subtraction operation and give out the value and if the operation is not sun and also not sub then it will go into the else block and print out that this is not a supported operation let's check it out foreign Ty is larger than the first one the value is negative similarly we can just implement the multiplication and division operations so let's just do them else if operation Dot equals multiplication then and just copy this entire line and yep yeah that's it finally the division operation is a little different operation equals to div then first we will have to check we put another if inside this lcf and this is called a nested if block so we will check if number two is equals equals zero then we want to print out system dot out dot print Ln okay cannot divide by zero because you just cannot divide a number by zero and then you will put else and we'll perform the division inside and we'll bring up the else block here and now let's let's check out the Division and multiplication operations as well let's put 10 0 and div cannot divide by 0 excellent let's rerun the program enter the first number then do gives five excellent finally the multiplication operations then a mul a multiplication via 80. excellent so we have already managed to create a very simple calculator here capable of Performing the basic arithmetic operations using IF else now I'm not saying that this is the only way to implement a calculator you can actually uh find even much better ways of making calculators but so far what you have learned this is a pretty good implementation of all your knowledge now when it comes to branching out your code based on one or more conditions if else's statements are pretty common but this is not the only way of doing things there is another statement called switch case statement that can do the same thing as a complicated if else ladder in this lesson we will convert our calculator application to use a switch case statement instead of ifills statements now before we dive into our code I would like to go to settings and change our layout from stack to side by side because as I'm seeing our code is becoming much longer vertically and it's becoming harder to read we can also make the console smaller for now because we need to focus on our code now we can retain most of our code from our previous example we can keep the scanner the inputs for number one and number two the input for the operation and the only thing that we need to get rid of is the Ifill statements now instead of removing the code entirely what I would do is I will just comment it out now to write switch case statement in Java you will have to begin by writing switch and then within a set of parentheses you will have to put the variable that you are trying to test so if you remember from our efels statement we are testing out the value of the operation variable and see whether it matches one of the four operations or not so inside the switch put operation then we will put a set of curly braces now you may have already guessed from the name of switch case statements that there will be multiple cases inside a switch now these cases are like this individual if statements where you are checking the value of the operation variable against something so in the first case of this statement we will check whether the value of the operation is some or not to do so you will have to write case and then the value you want to check against which is sum in this case then you will put a colon here and on the next line you can put the logic for the summation so I will just copy the code from our previous evil slider and put it here okay let's run the code and see what happens okay Enter the first number I and put five into the second number 10 and stop okay it says 15 which means it works now try to put a value that is not defined within the switches statement like sub let's rerun the program 5 10 sub and as you can see just like the if statement when you didn't have an ill server it doesn't print out anything at all now in case of switch cases statements you do not have else but you will have a default guess which you can write as default and then you can just print out that this is not a supportive operation let's run the program and see what happens first number five then and okay savvy's not a supported operation fine now so far this looks okay but let me show you a problem here if I run the program if I put the numbers and then say sum you will see the program not only prints out the summation of the two numbers but it also prints out is not a supported operation well the way switch cases are designed that if one of the cases match then the program will not only execute that case but also the cases that comes after that to stop the program from going through all the cases here what you'll need to do is you will need to use the break step so when the program comes and it sees that the sum case has been matched it will execute the logic here and then it will encounter the break statement and breakout of this entire switch case statement okay and it will go directly to scanner.close Let's test it out once again sorry let's put five then and some so as you can see it prints out the sum and breaks the program right there okay that that's cool now you can actually Define the other cases such as case sub and we will of course take the subtraction logic from our previous efl slider put it here put the break statement in let's just copy this best okay so the third case would be the multiplication case and we'll change the minus sign so if the multiplication sign and finally the division case now I hope that you remembered that we also had a check to make sure that the user is not trying to divide by zero we will have to do that as well and for that we do not have anything fancy we will just need to rely on plain old if else step map so we will write if number two is equals equals zero then we would like to print out cannot divide by zero else we would like to perform the division operations keep in mind that you should write the break statement outside of both the if and else block otherwise if you put the break inside the if or the else then it will only work if one of them are active but if you put it out here no matter what happens in DC fills block the break will always work let's try it out and see if it works or not save the code and run it again okay then zero and div cannot divide by zero okay let's rerun the program and check if the normal division function works or not then two give yeah it works finally let's check the multiplication 10 5 multiplication 50 yeah it works just fine now you can get rid of the commented out if it's a statements now although efills statements and switch cases statements are more or less do the same thing in the context of Java or in the context of other programming languages as well a switch case statement is actually faster than an if else letter in Java so if you can put your logic within a switch case statement instead of a really elaborate if else statement try to do that so far in this course you have only stored single values in single variables but there is a way to put multiple values within a single variable these are called arrays now before I start working on arrays let's do some cleanup you can get rid of more or less everything in our code you can also get rid of the Java util.scanner now to declare a new array for example if I want to declare an array of characters and I want to store all the vowels in English alphabets you can do so like this first you will have to type out the type of the array which in this case is car or character space then the name of the array which will be files and two square braces then you will put an equal sign and new car then you will put another set of square braces and inside of these Square braces you will have to put the length of the array now we know that there are five vowels in the English alphabet so you will put five now we have an array of characters but it's completely empty to insert a new value to this array you will have to write files and then an index of the array which in this case 0 then equals then the value you want to save in the array a now I have already told you that this array is of 5 length which means it can store five characters in it now these characters here can be stored like a e i o u and each of this character will have a number associated with them this number is called the index now the first index of an array in Java is always zero so by putting vowels and 0 inside a set of square braces you are essentially addressing the first place in this array then you put equals a and you fill it up now the other spaces are still blank now you can copy this line and paste it to insert the other values as well so 0 then 1 . then index 2 will be I index 3 will be o and finally index 4 will be you you now you have completely filled this array with the five vowels of English alphabet you can also print out these individual files using the same square brace syntax so if I copy files to from here and write system dot out Dot println and put files and two inside Square braces and print it out you will see I printed out on the console yeah as you can see there is I you can also print out an entire array but that's not as simple as printing out a single character or number or a string as you may have already guessed the print printf or println function prints out stuff on the console as strings so before you can print out the array you will have to convert it is string to do so import the arrays class like this import java.util Dot erase and then inside the println method call you will write arrays Dot to string and in the name of the array which in this case is vowels see we have printed out the entire array now you can also print out an array using Loops which you will learn in later lessons for now just be informed that there is also other ways of printing out an entire array to the console so I have already mentioned that this array has a length of 5. and since its index count starts from 0 it will obviously end at 4. now if you try to put something in an index that doesn't exist like five and maybe put X here run the program you will see that it fails with an exception saying index 5 out of bounds for length 5 which means for an array of length 5 you cannot have an index 5. let's get rid of that line and our code should be back to normal now instead of declaring and defining your arrays separately you can actually declare and Define your array in one line to do so after you have written car files the pair of square braces and equal get rid of the new keyword and put a set of curly braces here then you can actually put the values and in the line with the same colon get rid of these lines here and run the code there you go now you can also replace any of these values from the array at any moment for example if you want to replace the I with any other character out there you can do so in this way vowels curly braces and the index of I is 0 1 2. so put 2 here equals and put X put a semicolon at the end run the program and as you can see the eye has indeed been replaced with x another thing that I forgot to mention is the fact that when you are declaring and defining your array in a single line the array will actually infer its length from the number of values you are defining it with so since there are five values in the definition the areas length will always be 5. the light strings arrays in Java are reference types and like strings arrays also have a bunch of useful methods in them for example if you ever want to know about the length of an array you can do so by saying that let's get rid of this line first and you can write the name of the array files and Dot left I hope you remember that in case of a string the length was actually a method but in case of an array it's a property so if we run the program and you can see the length of the array a one of the most common tasks regarding arrays that you may have to do again and again within your programs is sorting an unsorted array right now we have ordered our files array according to the order of the letter as they come in the English alphabet so a e i o u but if we change the order and kind of randomize it so I will put e first then u a and I so a e i o u then it's totally out of order now there is a method called sort within the arrays class that you can use to sort your arrays in order to do so you will have to write arrays Dot sort and then put the name of the array balance then let's bring back our arrays.goo string method and we'll save outs let's run the program and see if it works or not so turns out that the arrays.sort method takes an array as its parameter and it sorts the array in place so it actually changes the original Source array by default the arrays.sort method performs the Sorting on the entire array so it will begin from the first letter and go through the entire array until it reaches the last letter and sort them in order but if you want to perform the Sorting within a certain range of the array let's say for example if I want to keep the e and i as they are right now and I just want to sort the u a and o I can do so so after I have put the array name now to define the starting and ending index of the sort method you can let's just Define to integer cells so int starting index equals I'd like to start the Sorting from U so 0 1 than in ending index I want to perform the Sorting until all but here is the thing if I put 0 1 0 1 2 3 3 as the ending index the O will be left out from the Sorting because the ending index is usually not inclusive in this case so I will have to write 4. which means the Sorting will take place from U to o n it will actually not affect I Let's test it out after I have written the name of the array I will put a comma here and I'll put the starting index then the ending index save my code and run it so as you can see the sort method has actually sorted aou in order and did not touch e and I at all so this is one of the useful things that you should know about sorting arrays in Java apart from sorting an array you may also want to search for a certain value within an array okay so for example we have e u a o i here and if you want to look for o in the entire array you can do so by using the arrays.binary search method now one thing that you will have to remember is that these areas.binary search method only works on sorted arrays so if you have an array that is not in order make sure you have sorted it before performing the search now to search for maybe o within this array I will say arrays Dot binary search and then I'll put the name of the array that I want to perform the search on so files and then the key or the item I am looking for so I'll write key and I create a new character here uh key equals to and I'm looking for what I'm looking for oh okay now this binary search method right here returns an integer which is the index of this key is found so I will write int found item index equals to errors dot binary search files excellent now first I would like to print out the entire array and then I would like to print out the found item index so found item index e let's save the code and test it out sorry I mistyped the name of the variable here you know mistakes like this can happen yeah so in the array a e i o u o is at index number three so we can verify that 0 1 2 and 3 o is at index number three like the sort method that you learned about just a few moments ago the arrays dot binary search method can also take an starting and an ending index to use them first we will need to define the index integers like int starting index I think I should have just kept them and I will start the search from one so I put one then I will also create an ending index equals to 4 because I want to perform the search within the middle three values and like the sort method the ending index is not inclusive in this case as well so once I have defined the two integer numbers I will say binary search vowels and then the starting index comma the ending index and finally the key I am looking for now let's see if it works or not run okay so it says 3 which is correct in this case as well I have found o at 0 1 2 3. now so far in this lesson I have shown you a bunch of searches and all of them has worked out fine but what will happen if one of your searches failed to find the value you're looking for for example we do not have an X in the entire array so if I get rid of the starting and ending index and look for an X within our array you will see that the output is 6 now instead of looking for an X if I look for a b within our array you will see that the output changes from 6 to 2 so you may have already guessed that depending on the item you are looking for and if it doesn't exist within your array then the output can differ but one thing that's constant is if the search fails you will always get a negative output and if the search succeeds you will get a positive output and that positive number will be one of the indexes from your array where the item you are looking for exists now there is a way to actually calculate this value there is logic behind why the output is sometimes 2 and sometimes six but I will not get into that much details in this course if you are interested about learning this I will leave the link to this article on free code Camp under this video's description so you can follow that link and read more about it now being able to sort an unsorted array and look for any certain item within an array is useful now another small but useful thing that you can do with arrays is that you can fill them with a certain value for example we have five vowels listed out of order within our vowels array but maybe for some reason you want to fill the entire array with x or maybe empty characters now you can do that by using the arrays.fill method before that let's get rid of some of these codes and write arrays Dot feel then put the name of the array that you want to fill which is files and the character or the value that you want to fill the entire array with let's run the code and see if it works or not yeah as you can see the entire area has been filled with excess now you can also have starting and ending indices with this fill method starting index equals let's start from one and in end ending index equals to 4 this is the same drill with the other methods as well the ending index is never inclusive so if you want to perform the field from 1 2 3 upon these three values make sure to include the last one as well or the item that's just after the one you want to end the field action act okay now arrays.fill comma vowels then we will put the starting index the ending index finally the value that you want to fill the array with okay so rs.2 string valves let's see if it works or not yeah it does uh the E and I is untouched and the U and O and A has been replaced with x's I have already said that arrays in Java are reference types and one of the complexities that we get with any reference types out there is making copies of them for example if we have an array of integers this time just for changing our test a bit I will write int numbers same thing equals then inside of a pair of curly braces I will put one two three four and five then I will create another array saying int copy of numbers which is an array equals to the number sorry okay so ideally the copy of numbers array should be a copy of the original numbers right let's see if that's true or not print Ln arrays dot two string numbers let's make a copy of this line and put copy of numbers sorry let's run the code and see what happens turns out I have made another typo here I have Mr T let's put it back and run the program so it seems like that the copy of numbers array is indeed a copy of the original number setting but I'm not convinced let's do another thing okay let's make some changes to the original area so we can say arrays Dot fill numbers and I'll fill the original array with zeros and then run the code let's see what happens but this is unexpected isn't it I have actually made some changes to the source arrays and the changes have somehow applied to the copy as well but the reason for this is the fact that arrays in Java are reference types and when you use an assignment operator to make a copy of an array or any other reference type for that matter it doesn't actually makes an entirely new copy of the source material what it does is it creates a new variable and points that variable to the original Source array so although the second array has a different name it's still pointing to the same values so you can treat this copy of numbers array as kind of an alias for the original numbers area so how do you make a copy of an array correctly then now to copy an array properly you will have to use the arrays dot copy of method the method takes the name of the original array as its first argument and at the second argument it asks for the length of the new array so the length of the original array as we can see is one two three four five so you can count that by hand or you can be a little bit clever and put numbers dot length as the length for the new array let's run the code and see whether the copy gets affected by the field call or not this time so as you can see that the original Source material and the copy of it are now two separate entities which we want now instead of putting the same length as the original array you can also make the array larger or smaller let's say if you make it larger with 10 indexes you can do so so as you can see the first five elements of the copied array are from the original array and the rest of the indexes has been filled with 0 which is the default value for integers you can also make it smaller so 2 . and the copy array can hold only two values while the original array could hold five now like the sword and the search method you can also Define the starting and ending indexes for the areas.copy of method but for that instead of using the copy off method you will have to use copy of range now inside this method you will have to first give it the name of the source array then and starting index and and ending index and just like before we will have to Define this integers here and the starting index equals to Let's uh 0 1 let's start the copy from one and in ending index equals to r 4. let's run the code and see what happens so as you can see the method has successfully copied 2 3 and 4 from The Source area now one thing that you may have already noticed that in case of the copy of range method you do not need to use a link for the newly copied array so how can you increase the length of the new array if you want to well right now we are performing the copy from index number one to index number four right so if we put a larger value than the original length of the array like then let's see what happens so as you can see the copy works out fine the method copies 2 3 and 4 from the original array also 5 and 10 fills up the rest of the space with zeros so although you cannot explicitly Define a new length for your copied array you can change the length of the new array by changing the ending index of the copy of range method just like copying a reference type is more complex than copying A Primitive type comparing preference style is also a bit complicated I hope you remember from our lessons on string we couldn't compare two strings simply using the equal SQL signs we had to actually use the equals method so it's kind of similar in case of arrays say for example we have the original numbers array then we have a copy of the numbers array let's just use copy off instead numbers dot length x length and get rid of the field method and try to compare our arrays using the equality operator so we'll send numbers equal equals copy of numbers let's run the code and see what happens as you can see it says false but we know for sure that the copy of numbers array is an identical copy of the original Source material now to compare to identical arrays like this or maybe two different arrays what you'll have to do is you will have to write arrays dot equals then inside this method you'll have to pass the two arrays copy of numbers let's run the code and see what happens yeah this time it comes out as true since there is no such thing as casing in case of an array there is no equals ignore case method for arrays like we had for strings in programming you may want to repeat a certain set of instructions again and again for your projects you can do that by using loops now there are four kinds of Loops in Java and we will start our discussion with a for Loop first I will write out the code for a very simple for Loop in Java that can print out the number from 1 to 10. for that I will write for this is the starting of our for Loop then inside I will take an integer int number equals to 1. now after the semicolon I will write number is less than or equals 10. and then number plus plus then I will put a set of curly braces here and inside this block of code I will write system dot out Dot println number we do not need the arrays class import right now so we will get rid of that and let's run the code and see what happens then I will explain each line of this for Loop to you as you can see the program successfully prints out all the numbers from 1 to 10. so what's going on here well every single for Loop usually has four parts the first part is the initialization where we are initializing a certain variable in this case an integer with the initial value of 1. then there is a condition that we are checking against so we are checking whether the number is less than or equal to 10 or not and if the number is less than or equal to 10 we will print out the number so this is the loop body system.out dot println anything that you write inside this set of curly braces will be the loop body then once we are done with the loop body we will go to the third part here inside the set of parentheses and this is called the update and we will update the value of the number variable so I will repeat every single for Loop will have four parts there is the initialization where we initialize a variable with a value then there is a condition that we will check in every iteration there is the loop body and then there is the object so when this Loop runs for the first time the value of number will be 1. and this condition will be true since 1 is indeed less than 10. so the loop will print out the value of number which in this case is 1. then the loop will increase the value of number by 1 and go back to the condition part and check whether the updated value is less than or equal to 10 or not well 2 is less than 10 so it will again go inside the loop body and print out 2 on the console so like this the loop will keep printing out all this number until it reaches 10. when the loop has printed out 10 on the screen it will go back to the update part and increase the value of number from 10 to 11. and it will go back to the condition once again and check whether 11 is less than or equal to 10 or not in this case the condition will come out as false and the loop will stop iterating the program ends here and we get all the numbers between 1 to 10 printed out on our console I hope that makes sense you can also use a for Loop to Loop over an array for example if we create an array here int numbers equals to 1 2 3 4 5 6 7 8 9 and 10. then we can use this for Loop to Loop over this array and print out each of this number to do so we will need an integer and we can call that the index so we want to run this loop as long as the index is less than the length of this array so numbers dot length numbers dot length finally we will increase the value of index by 1 on every iteration finally inside the println call we will send numbers and then we will put the index here let's see if it works or not so as you can see the program actually brings out all the numbers from 2 to 10 and doesn't print out to 1 because since the index count starts from 1 which is its initial value it starts accessing the array elements from index one so if you change the value of index from 1 to 0 then you should get all the numbers from 1 to 10. so what's happening here is you are initializing an integer with a value of 0 and then inside the condition part you are checking whether the value of the index is less than the length of the numbers array or not if it's less than the length of the numbers array then you go inside the loop body and print out whatever number is in the current index so it starts from index 0 which means one then index 1 which is 2 then 3 4 5 6 and so on you can also do some interesting things within this Loop instead of printing out all the values you can add them all together and print out the sum to the screen to do that what you will need is you will need another integer here goes to zero initially the sum will be zero and then inside the loop what we are going to do is we will say sum plus equals numbers and then the index okay finally we'll move out this system dot out Dot println outside of this Loop and print the sum on the screen let's see what happens when you run the code I forgot the semicolon here yeah so the sum of all the numbers from 1 to 10 is 55. now let me show you two more interesting programs that you can write using a for Loop the first one is that you can print out multiplication tables of any number using nested for loops for that what we need is a number so we will Begin by taking a new integer in number pi then inside the for Loop let's get rid of all this code and rewrite the for loop from scratch so we will say for then another integer the multiplier we will begin from one then if the multiplier is less than 10 we will keep going and we'll also increase the value of multiplier by 1. then inside the loop body we can say system dot out Dot print F in this case modulus D into modulus D is equals modulus t now we will say number then the second part would be the multiplier and finally number into multiplier now I hope you remember that the printf method doesn't have any new line character at the end so if you run the program at its current state let's see what happens as you can see it prints out the entire multiplication table in a single line which we do not want so what we can do is we can put a backslash n at the end of the line which will print out each row in a new line run the program excellent now we can take it a bit further to the audience let's get rid of the current code and let's begin with the new for Loop okay for inch number equals one number is less than 10. and number plus plus then inside the for Loop we will have a nested for loop I hope you remember that we have worked with nested if statements in the past we can also nest for Loops within each other so we can do 4 into multiplier equals one multiplier is less than 10 and multiplier plus plus now inside the loop body we will say system dot out Dot printf modulus T into modulus T equals to modular state so the first thing would be the number so since the nested for Loop is inside the outer for Loop any variable declared within the outer for Loop will be accessible inside the nested folder but any variable that you declare inside the nested Loop such as this multiplier here will not be visible to the Outer Loop so we can send number so we will replace the first modulus D with a number then we will say multiplier and finally number into multiplier in the line save our code and let's run it okay just like before we have to add a new line character at the end to make it look a bit nicer so as you can see now we have successfully printed out the multiplication table for all the numbers from one to nine but if you would like to include 10 here you can say less than or equal and then run the code yeah it works fine and I also just noticed that we are missing again here and you can fix that by saying multiplier is less than or equal to 10. right so let me explain what happens here first inside the outer for Loop you are initializing a number with one and you are continuing to Loop until the value of number exceeds 10 so less than or equal 10 and then inside the loop body you have another loop so first it comes and says okay number is equals one it's less than 10 then it goes inside the inner for Loop and it sees that there is a multiplier with the value of one multipliers value is less than 10 then it goes inside the body once a body has been executed it prints out one into one equals one and then it goes back to the update part of the inner loop and it checks again then it keeps looping within the inner loop once the value of multiplier has exceeded 10 the inner loop breaks and the program goes back to the outer loop it increases the value of number by 1 which becomes 2 now and it goes inside the inner loop again and prints out the multiplication table for two then it goes on to print out three four five six seven eight nine and ten so if you're having difficulty deciphering this complicated code here I would suggest that you write this code yourself and use a notebook to understand how these values changes in each iteration okay so finally I would like to show you an example of using an if else statement within afford for example if I tell you to print out all the odd numbers from 1 to 50 you can do that by using a for Loop and a single if else statement let's begin for int number equals one number is less than or equals to 50. number plus plus so this Loop will begin at one and end at 50. then inside the loop body what we want to do is we want to check if number modulus 2 is equals equals one then system dot r dot println number so if you divide a number by 2 and the remainder is 1 it's pretty sure that the number is an odd number we all know that so what we are doing is inside the for Loop we are taking whatever the value of number is we are dividing that by 2 and checking if the remainder is one or not that's what the modular operator is for I hope you remember and if the number is an odd number we will print it out and if it is an even number we will skip that let's run the code and see what happens so as you can see we have successfully printed out all the on odd numbers from 1 to 50 so 1 3 5 7 9 11 13 15 and it goes on to 45 47 and 49. there is another variant of the for Loop that makes looping over collections such as array is much easier now for that first we'll need an array numbers equals uh I'll just put the regular numbers here there you go now to use this special type of for Loop you will have to write for then inside you will say int number this type has to match with the type of the array and then you will put a colon here and then you will put the name of the array then inside the area body you can say system dot out dot print Ln number let's see what happens so as you can see the loop successfully goes through the entire array and prints out each element to the console now What's Happening Here is uh you are saying for every single integer number in the numbers array you want to print them out so instead of using an integer as an index and accessing the elements individually you are kind of taking a shortcut and extracting each value from the numbers array and putting them in the number variable on each iteration now you can do anything that you could have done in a regular for Loop such as if you want the sum of all these numbers you can do so like this some classicals number and then system dot out Dot println it's so make sure you are putting the printerland call outside of the loop otherwise this will be printed every single time the loop iterates let's run the code and see what happens there you go other than the for Loop there is also the while loop and do while loop in Java these are two different kinds of Loops that can more or less do the same thing as a for Loop but the for Loops are a lot more common in the wild than the while Loops now I will show you two examples of using a while and two while loop first let's begin with the while loop we will simply print out the multiplication table like we did in the case of the for Loop but this time we will use a while now first you will need a number just like before then you will need the multiplier now to write a while loop you will have to say while multiplier is less than or equals 10 then inside the loop body you will say system dot out Dot printf modulus T into modulus T equals modulus T since all of the variables are integers in this case then you will put number then the multiplier finally the number into multiplier excellent then once you have printed out the row in the multiplication table you will have to increase the multiplier by 1. multiplier plus plus let's run the code and see what happens so here looks like the program works just fine we have to just put a new line character to make the output a bit more readable foreign there you go now the main difference between a while loop and a for Loop is the fact that the while loop only has one component which is the condition in case of a for Loop we had the initialization we had the condition we had the loop body and we also had the update part but in this case there is just the condition and of course we have the loop body so you will have to do the initializations outside of the loop and you will have to perform the update or the incrementation of the multiplier or maybe counter or whatever you are working with inside the loops body so this is how a while loop looks like now a do while loop Works similarly but in a different order and also looks a bit different so in case of a do while loop you will have to write do then you will have the loop body which in our case is these two lines we want to print out the multiplication table once again and also increase the multiplier and after the loop body you will say while multiplier is less than or equals 10. let's comment out our old while loop make our console bigger and run the code foreign output now the main difference between a regular while loop and a two white Loop is the fact that in this case first the loop body will be executed and then the condition will be checked whereas in case of a while loop the condition gets evaluated and then the loop body gets executed so you will surely find usage of both kind of Loops if you worked long enough but I can say from experience that for Loops are a lot more common than whites or do vials let's just clean up our code before we leave from this lesson yeah so far in this course you have learned about only one way of putting a bunch of values together and that is the arrays but arrays have some limitation and the biggest one of them is the fact that you cannot resize an array the only way to make an area larger or smaller than it already is to copy it and change its length during the copy but there is another type and error list which is like a dynamic array you can create an arraylist you can put item in it or you can take away items from it and it will also adjust its length depending on how many elements it's holding now to use an error list in your code you will have to first import the error list class to do so you will have to write import java.util Dot errorist then to create an array list you will have to write array list then you will have to put a less than sign and inside you will have to write the type of the data you want to store in this array list now I know so far you have been only seeing int and this is the first time you are seeing something called an integer used as a type I will explain what this is but let's just keep on typing and finish creating our new error list okay so error list integer then name of the error list which in this case will be number equals new error list integer that's it we now have an empty error list of integers I forgot the is there now what's this integer class here I have taught you that data types such as int or double or float Boolean these are all primitive types but in Java you can also make them as reference types using the wrapper classes so this integer class share integer is actually a wrapper class for the Primitive type INT in other words integer is the reference type form of the regular inch type so just like integer you also have double float Boolean and so on and when you are creating an array list you cannot use the Primitive in type you have to use the integer wrapper class I hope that makes sense since we have an in the error list in our hand let's put some item in it now to insert a new item in an error list you cannot just use the old Curly braces syntax rather you will have to use the add method in this way you will have to write numbers then dot add then the value that you are trying to add which in this case will be one and a semicolon you can make a bunch of copies of this line and just add other numbers as well there you go now to print out an error list to the console you will have to write system dot out Dot println numbers which is the name of our error list in this case then Dot to a string now the two string is a method that is present in every single reference type in Java and later on when you will learn about object oriented programming you will also learn about creating your own twisting methods within your custom classes for now just remember that to print out an error list you will have to write out the name of the error list first and then the method to history let's run the code and see if it runs fine or not so as you can see the error list looks like an array in the console now you can also print out a single value from the arraylist if you want to but for that you will have to use the get method so you'll subdoc then get then the git method actually takes an integer which will be the index of the value you are trying to print like arrays error listers are also zero based so the first index of an error list will always be zero so the index of one in this case is 0 to 1. 2 three and four so if you want to print out three on the console you will have to send numbers dot get and then two here let's run the code beautiful we have three printed out on the console I have already said that analysts are Dynamic so you can add as many elements as you want using the add method and you can also remove elements from an error list so if you say numbers dot remove and it will take a number which will be the index of the element you are trying to delete so if you want to remove 3 from our error list we will say numbers dot remove and pass2 then let's print out the entire error list and see if she exists or not question okay let's run the code yeah three has been successfully removed but you can also remove items by value so for example if I want to get rid of 4 I can do so but instead of passing and primitive 4 if you write 4 here this will be a primitive integer Type 4 it will work as an index but if you pass a reference Type 4 like this integer dot value of and then pass the Primitive type which in this case is 4 and if we run the code you will see that we have successfully removed four from our error list now an error list can store anything starting from integers booleans characters strings and your custom class objects anything that you can think of we will work with much more complex at least in later lessons for now just let's get hang of the basics okay now you can also remove all the items from an error list by saying the name of the earliest Dot clear this will clear out the entire error list and make it empty there you go so I have already showed you how you can add new items to an error list how you can get them remove them clear an entire analyst now let me show you how you can update an element inside an error list for that there is the set method so you will type out the name of the error list then Dot and is a set and you will have to put an index here so again let's update the 3 here and its index is 2 we'll put 2 here comma then you will have to put the value that you want to replace three with and since the the error list is of reference types you will have to use the integer Dot value of method once again and we will say 30 so we will replace 3 with 30. let's run the code and see what happens excellent it it works out just fine so like an array you can also sort your array list right now we have added the numbers in a sequential order here but if we randomize them like for example if we put five at the top then one after three then two at the end okay let's get rid of this indices because now these are getting misleading okay let's run the code and see what happens so as you can see the numbers are all jumbled around now to sort this error list you will have to write the name of the arraylist the DOT and then sort in the method now you can see that there is a small squiggly line under the sort method name and this is because the sort method will actually take a parameter which is known as a comparator okay so as you can see it says comparator in the parameter list let me explain what this is first let's import the comparator class so it's a import Java dot util Dot comparator and then inside the sort method we will say comparator dot natural order which which is a method inside the comparator class and what we are saying is that sort this error list in its natural order okay let's run the code and see if it works or not yeah it works just fine we have successfully sorted our error list now you can also reverse the order of this error list by saying compared to Dot reverse order which is similar to Natural order but this time all the values will be sorted in a reverse manner there you go we have five four three two one liftoff now three very small but useful methods that the allergies have is the size method the contains method and the intimator first let's see what the size method does so if you ever want to know how many elements are there inside an error list you can just say the name of the error list and then size now this size method will return an integer after counting all the elements in the error list you can also check whether an error list contains a certain value or not and to do that you will have to write contains and since these are all reference type numbers we'll have to use the integer Dot value of method and we will have to put for example one let's check if the error list contains one or not see it says true which means it contains one and if we put 10 here the output should be false and yes it does now there is another method that checks whether an error list contains anything at all or not and it's the is empty method and since our analyst here actually contains some elements the output should be false and yes it is but if we clear our list just be before checking for emptiness we will see yeah it says true now the final thing that I would like to show you is the for each Loop now you have learned about the for Loop already in a previous lesson and you know that you can use it to Loop over regular arrays but when it comes to an arraylist there is another kind of loop let me show you how it works now keep in mind the forage Loop looks and works a lot differently than the for Loops but I'll try my best to explain them as lucidly as I can foreign list that you want to Loop over such as numbers and then for each then here it says action what you will say is number then you will make an arrow like this and then a set of curly braces now inside the set of curly braces you will say something like system Dot out dot print Ln and let's multiply each number with two just as an example so you'll send number into two and in our line now let's also print out the entire arraylist at the end so numbers dot to string yeah let's run the code for now and then I will explain what's happening inside the for each Loop run so as you can see we have successfully multiplied each value in this error list and we have also printed out the original arraylist here now let me explain the forage Loop for you so when you are saying numbers dot for each number you are saying that for each number in the numbers arraylist you want to perform the actions within this set of curly braces or within this block of code so imagine this Arrow like we are ordering the compiler like for each number perform this action that I am pointing towards now technically it's called a Lambda expression it's it's like a method that doesn't have any name now of course I'm over simplifying stuff here but for now this is enough to understand now as you can see that although you are multiplying each value of the numbers I released we do inside the forage Loop body the original error list remains unchanged now let's just for practice uh update the original error list and replace each value with their multiplied counterparts okay now to do that what we can do is let's first print out the original error list we will say uh B4 and plus yeah we are going to use the plus sign once again in this case because it's a simple program and then we will take this out and we will say after plus and then number start doing string okay now inside the for each Loop what we want to do is we want to say numbers dot set and inside the set of parentheses we will say numbers Dot index of which is another method that can return the index of a given value so will bus number here comma number into two so you are essentially using the index of method to get the index of the current value of the number variable and then we are updating its element with the multiplied value okay let's get rid of the println call here and let's keep our fingers crossed and try to run the program yeah seems like it has worked out we have successfully overwritten all the values of the error list with their multiplied counterparts now this is one of the many fun programs that you can write to practice your skills I would suggest that you go around the internet find interesting problems that feels challenging to you and solve them to flex those Java muscles okay now that you have learned about air release let me show you another kind of collection that's pretty common and pretty useful in some scenarios these are called hash Maps now hash maps are actually key value Pairs and if you want to compare it python then python dictionaries are kind of similar to Hash Maps now to work with hash Maps first you will have to import the hashmap class to do so you will just write import java.util Dot hashmap let's get rid of all the early code and start working on hashmap okay Now to create a new hash map in Java you will have to write hash map and then just like the add list you will have to first put the type of the key so in my case I am making a hash map where I'll be storing the scores for my different subjects maybe at my school or summer so the key will be string and the value will be the scores of the subject so maybe English 98 maths 85 and so on so this will be integers and then I will name the hash map something maybe uh exams course equals to new hash map string integer that's it we have successfully created an empty hash map and since I have already discussed these wrapper classes in a previous lesson I will not repeat now to put something in this new hash map you can use the put method so exams course dot put and first we will need to put the name of the subject so it will be a string and maybe a math and then a comma and then this course I'm not that good at math so maybe 75 then we will say exam scores dot put another subject may be a sociology and 85 exams scores dot put English 95 and so on now to print out a hash map to the console you can say system dot out Dot println exam discourse dot to string just like you did with the error list okay let's run the code and see if everything works or not run excellent the hash map prints out uh so my score for English is 95 sociology 85 and math 75. uh I hope you have already guessed that the item you are putting into the hash map is not sorted so even though I have put math at first it comes out in the end so if I put some more subjects foreign and let's see what ordered this show up in the console see as they're actually showing up in random order but that's how hash maps are you don't have to worry about them now you can also print out a single value from a hash map to do so you will have to write the name of the hash map then a DOT and get then you will have to pass a key in our case the keys are all strings so I will write let's get the score for English run and yeah we are getting the score of English now apart from the put method there is also another method put if absent that first checks if a value already exists in the hash map or not and if it doesn't then it will put it otherwise it will just skip it now you can write exam scores Dot put if absent and let's try out with math math and let's put a new value here maybe 70. and then I would print out the entire hash map here string nice so as you can see the value of math is still 75 even though I have tried to put a new value for it but since the put if absent method actually checks whether math already exists or not in the hash map it didn't override the original value now if you want to replace one of the values however you can use the replace method and it will take a key in this case we are still working with math and we are updating its value from 75 to 70. what a shame so as you can see the value of math has been changed to 70. now just like the put if absent method there is another method called get or default for example if I try to get a key that doesn't exist let's say for example religion we know that it doesn't exist in our hash map let's see what the output is as you can see it says null but if we say get or default and we give it a default value of 0. or maybe 1 and run the code so the program will return 1 if the given key is not bound now like an error list you can clear a hash map by saying exams course Dot clear and this should clear out the entire hash map there you go and now if you want to check the number of elements that exist on the hash map you can do so by saying the name of the hashmap dot size this will return an integer after counting all the elements present in the hash map right now which is 0 because we have just cleared it out but if we get rid of that line it should be back to five excellent to remove an item from the hash map you can use the remove method like this exam scores dot remove and then you should put a name of this one of these keys so let's get rid of sociology and I'll put it here semicolon then exam score start to be string let's run the code as you can see sociology is not present here now you may also want to check whether a certain item exists on the hatch map or not and you can do that in two OS either you can check for a key or you can check for a value for example if I want to check if the math key exists or no I can do so by saying the name of the hashmap exam scores dot contains key and then the key I want to check against which is math in the this case and it comes out as true now if I want to check if I have this code 100 in any of the subjects or not I can do so by saying examscores Dot contains value and then the value I'm looking for which in this case is 100. now you can also put a reference type 100 here if you want to do that the value of and it shouldn't make any difference yeah it just works and I have also taught you that in case of at least when you are trying to update one of the values you need to pass the integer as in reference type you can actually pass a primitive type as well the set method will convert it to a reference type automatically but it's up to you what you would like to do and what you want finally you can check if a hash map is empty or Not by using the name of the hash map which is examsforce Dot is empty and since our hashmap is not indeed this should return false yeah it returns as false cache Maps also have for each Loop just like arraylist and now I will show you an example of using them with hashmaps to do so first you will need to write out the name of the hashmap which is the exams course in this case then you will set Dot for each just like at least you will create a new Lambda method here but in this case it will say the key comma the value then the arrow and the curly braces now the key here is the subject and the value is this Force so I'll just do it like this and then system dot out dot print Ln name of the subject Plus Dash plus the associated score let's put a semicolon at the end get rid of these empty call and see if it works or not okay I just noticed that there is a small squiggly line here that's because I didn't enclose the two variables within a set of parentheses here in case of an error list we had only one variable so it didn't need this parenthesis but since we have multiple variables here subject and score we will need a set of parentheses around them let's run the code and see if it works or not okay seems like it works now what we are going to do we will Loop over the entire hash map just like we did in case of the error list and we will update the value of each subject score just for the purpose of practice now to do that we already have the name of the subject which is the key and we also have the value which is the score to update the values we will say exam score start replace you have already learned about this then we will subject which is the key and then we will take away 10. from each subject maybe for bad behavior or something then we will say system dot out Dot println and exam scores dot blue string okay I hope everything works out fine and I cannot spot any mistakes let's hit the Run button yeah so I have indeed taken out 10 from each subject so English was 95 and now it's 85 Bengali was 100 and now it's 90 sociology is 75 from 85 computer programming has become 90 from 100 and finally math has become 65 from 75. again I would suggest that you go into the internet looking for problems that you can solve to just practice all the things you are learning in this course this will really make you confident in Java now that you have learned most of the basics of java it's time that we start discussing about object oriented programming now the concept of objectoriented programming in itself is really huge and to be very honest you cannot learn how to make good objectoriented programs from a course or a book what I can do is I can teach you the basic concepts around objectoriented programming and once you have learned them you will have to learn the rest from experience by making larger and larger software following good practices and so on now at a higher level objectoriented programming is about modeling your software around real life objects for example maybe we can build a book borrowing system where a user can come register and login check for a book's availability borrow it if it's available and they can also return it on time they can also check the list of the books they have borrowed so far now in this aforementioned system there can be two objects one the user and two the book we can store information such as the user's name and birthday and in case of a book we can store the book's title and maybe the name of its authors and so on so let's begin by creating a user class in our software and as we keep working on this simple program we will learn about the different concepts around objectoriented programming so first open up the files menu by clicking on the file icon here and click on the add file button name your new file user Dot Java in this file you will need to create a new class like we have done with the hello world file so write public class user now we are declaring this class as public because we want this class to be available within our entire program now inside the class we will store the user's name which can be string so public string name and we will also store the user's date of birth so we will say public local date which is a reference type for storing dates in Java and we'll say birthday now to use the local Red class within our user class we will have to first import it so import Java dot time dot local date uh by the way do not get intimidated about the amount of classes that Java has built into it as you will keep working with Java for months or maybe for years you will eventually learn about a lot of them now we have a new user class let's go back to our hello world class and create a new user object now creating a custom object like a user object is not very different from creating a string so you will have to write user which will be the type of our object then you will have to name the object maybe let's name it younger user because we will have a older user as well later on equals new user and a set of parentheses now we have a user but this user at its current state doesn't have any name or date of birth since these variables are declared in the class level of the user class this will be initialized as null by default so they will get default values now variables like these at a class level are called properties and since these properties are tagged as public we can actually access them from outside of the user class and give some value to them so we will say younger user dot name equals Farhan hasin Junior excellent then younger user Dot birth J equals local date Dot purse and inside the purse method we will pass 1995 0 1 31 which means 31st January 1995. now the local date.burst method can pass a date from a given string and convert it to local date type again for using the local date class here we will have to first import it so import Java dot time dot local dates then we would also like to print something out on the screen and for that we'll say system dot out Dot printf and inside the printf method we will say that modulus s was born back in modulus s then after the comma we will replace the first format specifier here with the names so we will say younger user dot name and then after that we would like to replace the second format specified with the birthday but since the birthday is not a string you will have to first convert deep string by calling the twisting method and I have already said that the twisting method usually exists in all the reference types and any local date object is actually reference type let's try running our program and see if it works or not so yeah it works just fine Farhan hasin Junior was warning back in 1995 c131 now I have already said once that using something called Methods we can actually Implement some Dynamic behaviors to our classes for example since we have the per day of the user we can use it to calculate their current age so we will create a new public method public because we want this method to be accessible throughout our entire program and then we will have to write the return type of our method which in this case is integer because age is always an integer then we will put the name of the method which is age and put a pair of curly braces now from inside the method we will calculate the age into H equals and for that Java actually has a pretty nifty class so in import Java dot time dot period now this period class has some method that you can use to calculate the difference between two local date types so we will say period dot between and inside this method called we will put a starting date which is the birthday so we will say this Dot birthday I will explain this this later on and then we'll put local date dot now now this period dot between method call will actually calculate the difference between the user's birthday and our current day and then we would like to return age dot get years because we want to return the age in years okay we do not want anything else let's go back to our hello world class and change this string to something like was born back in and he is now modulus is a module does d ears port so you say that user was born back in the birthday and he is now X years old so we'll put a comma after the twisting call and say younger user dot h and we will put a set of parentheses because this is a method and you will need to put a set of parentheses to call any method in Java let's run the program and see if it works or not yeah looks like everything has worked out just fine it says foreign Junior was born back in 1995. 0131 and he is now 27 years old excellent now what is this blue this keyword here now to explain this we will actually need two users so let's create a new user user older user equals new user and we'll say holder user dot name equals senior and then you will say folder user Dot birthday equals local date Dot first and let's put 1975 0 1 15. okay now we'll put this system out Dot printf at line 10. and we'll make a copy of it at the end of our program postponed back in uh okay all right let's replace younger user with older user let's run the code and see what happens foreign ERS Engineers born 27 years old and this is 47 years old nice now you can see that we have two different users in our program and both of these users are actually created from the same user class so when we are trying to calculate the age of the user how would the computer know which user we are referring or which date of birth we are referring to this is where the this keyword comes in you see we have two instances of the user cluster and this keyword will refer to the current object being worked on so when we are saying younger user dot age then the value of this will be the younger user object and when you are saying older user.h the value of this would be the older user object okay so let's get rid of the extra user here change the younger user's name to just user and let's start working on the book class let's go back to the files menu create a new file with the name book Dot Java now let's declare a new class public Plus book and for a book we would like to store a public freeing title and public history author yeah that's pretty much it for the book class now let's go back to the hello world again and we will say book equals to new book and then book dot title equals to carmilla book dot author equals to Shelton let's put a semicolon at the end and now we have a new book so how about we implement the functionality of borrowing books I will put it in the user class so let's close this menu as we don't need that and we will create a new method here path leak borrow and this borrow method will actually accept a parameter because this method has to know which book the user is trying to borrow right so we will say book so this method is actually accepting variable of book type then let's create arraylist of type book let's call it books equals new array list and book closing and we will also have to import the error list class so import ant java.util dot arraylist okay then we can say this dot books dot add and book so you're adding the book we have received within the borrow method to our list of books okay let's go back to our hello world class and we will say user dot borrow and we will pass the book to it I think we have made a small mistake that is we haven't said what kind of data the borrow method is returning now as you can see the method actually returning nothing so we will have to say for it which means it doesn't return anything at all there is no return statement whatsoever it just makes some changes to the books error list okay let's go back to hello world and this looks all right so far let's update this printf method yeah and h okay let's let's write another one system dot out Dot printf and it will say modulus s has borrowed these books and with some modulus s okay let's put a comma here and we will say user dot name has borrowed user dot books dot two string okay uh let's also put a new line character at the end of our printf statements otherwise they may not look as good as we want them to be okay let's run the program and see what happens then we will go through what happening in this entire system once again foreign just as I expected so as you can see it says Farhan has engineer was born back in 1919 and so on and then it says Farhan has engineer has borrowed this book's book at and then a large number but we are expecting maybe the name of the book or maybe the name of the author or something like that right but that didn't happen let me tell you why you can see that we have been using the method to string a lot right by using the method twisting a lot and I have already said that this twist string method comes with every single reference types now our book here is a custom class and whatever book object we are working with are all reference types now since we have created the book class ourselves it doesn't have a built into a string method that's why we are getting some random values here now to solve this problem we will have to implement a twisting method we can do that by saying public string to string and then we will return a string representation of this book like return string dot format here and we'll say modulus s by modulus is then a full stop and after the comma we will say this dot title and this dot author so whenever we are trying to access one of the properties within a class from a method within the same class we can use that this keyword okay let's try to run the program once again and see if it solves our issue or not let's make our console bigger foreign I think that full stop there looks pretty bad because it's going to show up like a list of books let's get rid of that and also I think this is a good time to switch back to the Stacked layout once again since our codes are getting bigger horizontally and this gives us a better look at our lights okay so what have we done so far we have created two custom classes representing our users and the books we have created a new user object we have given him the ability to borrow books from us we have also calculated their age using method we have implemented title and author for our books and we have also implemented accustomed to string method so this is really a lot to be honest but we will do more now so far we have been declaring all our methods and our properties as public but to be very honest this is not something you should be doing a lot let's learn about something called a Constructor as you can see when you are trying to create a new user you are saying user then name of the user object equals new and then you are writing the name of the class once again and then a set of parentheses as if you are trying to call a method called user well that's kind of true every single class that we have in Java has a special method called Constructor this method is responsible for initializing all the properties with their default values so what we can do is we can customize these Constructor method and make it do things let's start by writing a Constructor for our user class okay we will say user and will not write anything like public or maybe some sort of return type nothing at all we will just start by writing what the name of the class is then we will put a set of parentheses and set of curly braces so this is our Constructor method now let's think about what we want from the user when they are creating a new user object right we want their name so we will receive or ask for their name and we will also ask for their birthday now this birthday can be taken as a local date but we will take it as a string I will tell you why but now inside this Constructor method we will say this dot name equals name and this Dot birthday equals local date dot purse birthday so what we are doing essentially is we are asking the user for a name and we are storing that name in the name variable or name property within the user class then we are also asking for a birthday and we are storing that birthday in the birthday property but since the birthday property is of type local date we will have to purse the birthday from a string format to local date format now let's go back to our hello world class and make the necessary changes here we will say user equals user and we will put the name inside this Constructor call and we'll put a comma here and we'll also put the birthday within the Constructor call because now the user class is capable of accepting these two values let's run the code and see if everything works just as before or not seems like I have made a small typo here the D should have been capital foreign just like before now since we can initialize the user with a name and a date of birth right at the creation process we can actually make the name and birthday private which means we can no longer do things like user dot birthday or user dot name but we still need to know the user's name and user part derived for that we have something called getters so we will create a new method somewhere in this user class public get name and the return type B string and we will say return this dot name and we will also say public string get birthday and you will say return this dot birthday dot to string now let's go back to the hello world class and make use of these two Getters we will come down to printf and we will say user dot get name how do you say user dot get birthday and we'll get rid of the two string calls since the birthday will come back as a string by default now let's run the code and see how it works okay we also have to replace this name here and as you can see since we have made the name properties private the hello world class actually fails to access the user's name which is a good thing I will explain why let's just make it working again so yeah it's it's back to normal now since the name and birthday properties have become private no one can change their values from outside the user class which means these are now much more secret than they were before another thing that is now we can pass the name of the user and the birthday as a strings the hello world class has no business in knowing what is the actual type of the birthday is all the Hello World Class needs to know that if it passes a user name and a birthday in string format a new user will be creative this is called abstraction so what we are doing is we are hiding the complexities of the user class behind this beautiful looking Gator methods Constructor methods you can already see how cleaner the user object creation looks compared to the book object creations let's make the same changes to the book class as well so we will go back to it and change the title and author to private then we will Implement to getter methods so public get title return this title the return type will be string and then we will say public a string get author and we say return this Dot author Etc let's also implement the Constructor so we will say book we will take the title as a string and then we will take the author name as a string then we will set this dot title equals title and this dot author equals author nice let's update the creation process so we will pass the title of the book and the name of the author with the new keyword and get rid of that excellent the program already looks much cleaner now another thing that I would like to change is I would like to make the books list private and Implement a getter for that as well so let's go back to the user class and let's say foreign public and this time we will be returning string borrowed books and we'll say return peace dot books dot history excellent now the hello world class doesn't know about the complexities of the books list either we'll just say borrowed volts did I meet it private yet no I didn't so we will make it private okay let's see if the program works just as before or not excellent the program works just as before now I hope you can already see the beauty of object rendered programming and how cleaner the program actually looks in reality we still have to learn a few more Concepts around object entry programming such as inheritance now assume that our book borrowing system has multiple types of booths there can be the regular books I mean the hardcover ones or the printed ones then there can be ebooks and there can be audio books now although they have some similarities they also have some differences such as the ebooks and the regular books have page counts where the audio books have run times also the ebooks have formats such as PDF or ePub or so on so trying to implement different kinds of books using the same class can be cumbersome now you may think that you will make copies of the book class and add or remove the necessary properties methods to them but that's not a very good idea this is why inheritance comes in so we can make a default book class with the most common properties and methods in it and then we can make child book classes that will inherit all the properties and methods from the parent book class and we can also add some new properties and methods to them let's see an example first we will add the page count property to the book so we will say private int page count and for that we will have to pass the page count to the Constructor here so we'll set this Dot Page count equals page count we'll go back to our hello world class and we will say I don't remember the actual page count of the book but let's put 270. nice everything should be normal let's run that code and make sure ah that was a silly mistake I didn't accept the parameter here let's run the program and make sure excellent now we will create a new audio book class audio book Dot Java yes and we will say public class audio book extends book now since we are declaring this audiobook class as an extension of the parent book class it already has all these properties and methods we have described here so what we need to add is a runtime so it's a private int front so runtime means how long these audio books run so the runtime will be in minutes then we will have to create a new Constructor here so we'll say audio book just like before and we will accept the runtime so it's a int runtime and then inside the pair of curly braces we will say this Dot runtime equals runtime now here is a problem I have already said that since this audiobook class is an extension of the book class it also inherits all these private properties which means we will still have to fill them up somehow but the audiobook Constructor doesn't accept any of these values okay let's see what we can do to solve this first we'll copy all these parameters from the book Constructor and add them to the audiobook Constructor one of the problems have been solved we are now accepting all the necessary information for the parent book class now we will say super and we will pass title author and pitch count now the super keyword here actually refers to the parent class of our current class so when you are calling the method super we are actually calling the Constructor of the parent book class so we have successfully filled up all the necessary properties of the parent class as well let's try out by creating a new audiobook let's go back to the hello world class and after book we will say audiobook equals new audio book and we will say Dracula foreign stalker and the page count actually we do not have to pass the page count here we can modify our Constructor a little bit we do not need to accept the page counter instead we can pass 0 as the page count yeah that would be better and we can just accept the runtime so for example maybe the Dracula book would run for 30 000 minutes so I put 30 thousands here audiobook see I have made a mistake and I think we should start naming our books so carmilla okay so we have successfully created a new audio book here just for the sake of our codes Clarity let's get rid of all the code that we do not need so we will get rid of the user dot borrow call we have seen examples of that we will also get rid of the system.out.printf calls we will get rid of the user as well because for now we will be focusing strictly on books audio books and ebooks so let's create a new system.out.printf method here we will say sorry Dracula dot two string because remember that the audiobook class already inherits the two string method from the book class okay let's print out something on the screen so it's a system dot out dot print Ln and Dracula dot Google string let's run the code and see if it works or not yeah it works just fine okay now that we have a audiobook class let's create a new class called ebook chef okay King public class ebook extends and then within the set of curly braces uh actually we can copy a bunch of code from here let's copy everything to the ebook class and we will say private is string format and then we will accept everything and we will also accept the page count this time because ebooks have page count okay so input page account and then we will also accept the format so we'll say string format this dot format equals one CF nice uh yeah everything looks fine okay we have to change this to ebook let's go back to hello world and try to create a new ebook Okay so ebook so Jeeves I will create a Chiefs book new ebook carry on Chiefs written by PG old house I hope I'm spelling his name correctly then the page count would be 280 I guess and finally the format will be PDF let's put a semicolon there and let's see if the book has been created properly or not so Jeep stop to stream okay so carry on Jeeps by PG Port house so we have successfully created different kinds of books based on a parent class now this is what I had in store for this course in terms of object oriented programming I have taught you what are classes what are objects water properties and methods Constructor methods and you have also learned about inheritance now there are a lot of things that you will have to still learn like method overloading and overriding Abstract method and whatnot but I would not like to overwhelm you with all these Concepts in a single course what I would suggest that try to understand everything that I have taught you in this course uh as thoroughly as you can and then keep practicing make programs make bigger programs and try to understand whatever concept seems complex to you and as you keep working with Java as you keep making more and more fun projects you will start to understand a lot of the complex Concepts around object oriented programming and whatnot so I hope you have learned something good from this course and maybe someday I will see you in another course as well so till then stay safe and take care
