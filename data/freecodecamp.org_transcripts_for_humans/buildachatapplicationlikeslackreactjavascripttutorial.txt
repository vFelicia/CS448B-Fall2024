With timestamps:

00:01 - hey how's it going my name's booker and
00:03 - in this video i'm going to show you how
00:05 - to build a group chat similar to slack
00:08 - using react.js and chat kits which is a
00:11 - developer tool that my team and i are
00:13 - building here at pusher
00:15 - in the end we'll have an app where users
00:17 - can send and receive messages see who's
00:20 - typing with nifty typing indicators and
00:22 - to top it all off a real time who's
00:25 - online list
00:27 - the app we're going to build is going to
00:28 - resemble slack and it could well be used
00:30 - for team communication but i realized
00:33 - having built the project and recorded
00:34 - the video yesterday but the concepts and
00:37 - techniques we're going to look at could
00:39 - be used for most types of chat
00:41 - applications be that a customer
00:43 - messaging app maybe for a crm maybe a
00:45 - group chat for your community or even
00:48 - in-game chat if you're a game developer
00:50 - i wanted to quickly mention that all the
00:53 - code is on github the link is in the
00:55 - description and i even took the liberty
00:57 - of writing up a step-by-step tutorial
01:00 - based on the exact same code you're
01:02 - going to see in this video so if you
01:04 - want to follow along you can maybe watch
01:06 - the video and reference the code on
01:08 - github it's up to you
01:10 - if at any point you find yourself
01:12 - enjoying the video please drop a like on
01:14 - the youtube video you can also follow me
01:16 - on twitter i'm at booker currents but
01:18 - yeah i'm excited let's dive in
01:22 - instead of starting from complete
01:24 - scratch we're going to download a
01:26 - starter template i created earlier we'll
01:29 - have a poke around the code in just a
01:30 - second to see exactly what's happening
01:33 - but first off download this repository
01:35 - which you can do by coming here and
01:36 - clicking on download zip or by copying
01:39 - the link and heading to the terminal but
01:41 - we can run git clone
01:43 - followed by the link to the repository
01:45 - followed by the name of the local folder
01:47 - you want to download that code into if
01:49 - we navigate into that folder we can run
01:52 - npm install to bring in those local
01:53 - dependencies
01:56 - pretty standard stuff if we open the
01:58 - project up we can see that there aren't
02:00 - really that many files in this public
02:03 - folder we have an index.html file this
02:06 - mainly exists just to give us something
02:07 - to mount our react application onto we
02:10 - won't be touching this html file going
02:12 - forward instead of source we have some
02:14 - basic react application files including
02:17 - an empty components directory where
02:19 - we'll be creating some of our components
02:21 - as we go forward the real meat here is
02:23 - this app.js file which we'll add more
02:25 - code to as we go forward but right now
02:28 - just renders a simple component with the
02:30 - text slack
02:32 - if we look at package.json you can see
02:34 - that we're using react scripts to run
02:36 - the react application and we also have a
02:39 - start script where we can run both the
02:41 - server which i'll show you in a second
02:43 - as well as the clients all with one
02:45 - command
02:47 - the server is actually the main reason
02:49 - this template exists i didn't want to
02:51 - spend too much time explaining how to
02:53 - set up a simple express js server
02:55 - because if you already know express this
02:58 - here is going to look super familiar to
03:00 - you it does need explaining if you don't
03:02 - know express very well which is totally
03:04 - okay then it doesn't really matter too
03:06 - much we're not going to spend very much
03:08 - time on the server
03:10 - now the first thing we're going to want
03:12 - to do when the user loads our
03:13 - application is ask them what is your
03:16 - username we'll use this username to
03:18 - create a chat kit user
03:20 - to capture that username we're going to
03:23 - create a username form component and
03:25 - we're going to create that component
03:27 - inside of the components directory i
03:29 - just showed you
03:33 - first we'll import react
03:35 - then we'll create our username form
03:37 - components
03:42 - inside the username form we'll create a
03:44 - constructor but take some props
03:47 - and we'll immediately pass those props
03:49 - to the super function
03:51 - we'll also set some initial state for
03:52 - our application
03:54 - [Applause]
03:57 - next we'll create a render function
03:59 - we'll return a simple form
04:01 - [Music]
04:03 - whenever this input here is updated
04:06 - or changed we're going to call vista on
04:09 - change
04:13 - [Music]
04:15 - and then whenever the form is submitted
04:18 - we're going to call vista on submit
04:24 - we'll also need to go back up to the
04:25 - constructor and bind both of those
04:28 - functions
04:29 - to this
04:36 - nice so this is a pretty standard react
04:38 - form what we're doing is we're creating
04:40 - a controlled component
04:42 - but whenever the user enters some inputs
04:45 - we update our component state whenever
04:49 - the form is submitted we take that
04:52 - component state
04:53 - up here and we pass it to the on submit
04:57 - prop which we expect whoever's
04:59 - referencing this form to pass
05:01 - in fact let's reference this form now
05:03 - just to make sure everything is in order
05:05 - so we'll go to app.js and import
05:08 - username form from components
05:12 - slash username form
05:14 - and then instead of returning just the
05:16 - text slack let's return the username
05:18 - form specify that on submit prop and
05:21 - we'll just say when we get the username
05:23 - let's alert it just to make sure things
05:25 - are in order
05:26 - so that now if i create a new split and
05:29 - run the application using npm run start
05:33 - or actually we can just do npm start for
05:35 - short
05:36 - that should spin up a server so that we
05:38 - can go to
05:39 - localhost 3000
05:42 - enter a username like booker and when we
05:45 - hit submit we can capture that username
05:47 - and show it in an alert
05:49 - but actually we don't want to just show
05:51 - it in a in an alert whenever this user
05:54 - enters their username we want to send
05:56 - that to our server application and
05:58 - create a chat kit user but before we can
06:01 - do that we must first create a chat kit
06:04 - application or a chat kit instance
06:07 - so head to pusher.com
06:10 - chat kit
06:11 - and click sign up
06:14 - you'll have to create a new account i
06:15 - already have one so i'll log into an
06:17 - existing account real quick
06:19 - once you're at the dashboard and the
06:21 - chat kit click create new and create a
06:23 - new chat kit instance i'm going to call
06:25 - mine slack clone
06:29 - the way chat kit works essentially is
06:32 - that you install a chat kit client sdk
06:35 - there are sdks for javascript swift and
06:37 - android we'll be using javascript and
06:40 - then you can subscribe to a room where
06:41 - you'll receive an event every time a new
06:43 - message is sent on the same client you
06:46 - can also send messages you can send
06:48 - plain text or you can send files so you
06:50 - can send video messages audio messages
06:53 - whatever you like once you have this
06:55 - kind of fundamental chat in place it
06:57 - becomes quite easy to add things like
06:59 - typing indicators and online user
07:01 - presence which i'll show you how to do
07:03 - later in this video
07:05 - right now i just want you to take notes
07:07 - of the keys tab in the dashboard where
07:09 - you can see your instance locator and
07:11 - secret key we'll need these in just a
07:13 - second now most interactions in chat kit
07:17 - they happen on the clients like i just
07:20 - showed you there are client sdks for
07:22 - javascript swift and android and you can
07:24 - even use these libraries together so you
07:26 - could build a web application as well as
07:28 - an android application and they can both
07:30 - communicate using chat kit which is kind
07:32 - of cool but if you head to the docs you
07:35 - can see that there are both client sdks
07:38 - and server sdks
07:40 - most interactions with chat kit happen
07:42 - on the clients that's the same most code
07:45 - will write will use the client sdks but
07:48 - we'll also need to use the node.js
07:50 - server sdk to create and manage users so
07:54 - what i'll do is i'll copy this
07:55 - installation command
07:57 - head to the terminal
07:59 - and install
08:01 - pusher chat kit server
08:06 - now we have that sdk installed we can
08:08 - open up server.js and import chat kit
08:13 - from pusher dash chat kit dash server
08:16 - and then we can create our own local
08:18 - chat kit instance by calling new chat
08:21 - kit.default and we pass to this
08:23 - constructor function firstly our
08:25 - instance locator and secondly our secret
08:28 - key both of which we can access from the
08:31 - dashboard so let's copy that instance
08:33 - locator
08:34 - and paste it in
08:36 - and then let's copy that secret key and
08:38 - paste it in like so
08:41 - now the main purpose behind this server
08:44 - is to accept a post request from the
08:46 - client with the user's username when we
08:50 - receive that username we want to create
08:52 - a chat kit user with that username we
08:56 - have to do this on the client because it
08:57 - needs to happen securely you can only
08:59 - create a user if you have this secret
09:02 - key and in order for it to be secret it
09:05 - has to remain on the server
09:07 - so what we'll do is we'll come down here
09:08 - and create a new route handler called
09:10 - users that takes a post request and as
09:13 - soon as that endpoint gets hit
09:15 - we're going to bring out the username
09:17 - from the request body
09:21 - once we have that username
09:23 - we're going to call chat kits
09:26 - dot create user
09:28 - specify the user's name to the username
09:30 - and we're also going to specify their id
09:32 - to be equal to the username
09:35 - when that function is finished executing
09:38 - we're going to send a status of 201 to
09:40 - the client to indicate that the user has
09:42 - been created successfully
09:44 - it's possible that an error will occur
09:48 - and in this particular case
09:50 - it's particularly possible that the user
09:53 - enters a username that already exists a
09:56 - username which is already in use by
09:58 - another chat kit user for this
10:00 - particular chat kit instance in that
10:02 - case we're going to get a specific error
10:05 - um and for our application that's
10:07 - actually okay we don't mind if somebody
10:09 - enters a username but already exists
10:11 - because we're going to assume they're
10:13 - kind of revisiting the application so
10:15 - what we're going to do is we're going to
10:16 - check the error type and check if it's
10:18 - equal to services slash chat kit slash
10:21 - user user
10:23 - underscore already underscore exists and
10:26 - if the user already exists we're going
10:28 - to send a status of 200 to indicate that
10:31 - the request was still successful
10:34 - otherwise we're going to send a status
10:36 - equal to the error status code we're
10:38 - going to relay that from chat kit to our
10:40 - client and we're also going to pass down
10:42 - the error json uh just in case we need
10:44 - to use to do some debugging later down
10:46 - the line
10:48 - let's test this out real quick let's
10:50 - create a new split and run the server
10:53 - and then in another split i'm going to
10:55 - run curl specified that we want to send
10:58 - a json request a post request and we'll
11:01 - specify here the
11:03 - username to be equal to foo
11:07 - and we want to send this post request to
11:09 - http
11:10 - localhost 3001 slash users and we should
11:14 - see when we run this that the user is
11:16 - created and indeed the user is created
11:19 - now imagine that the user just entered
11:21 - that username on the form and they
11:23 - created their account then maybe they
11:24 - closed the tab and they came back later
11:26 - they're going to enter the same username
11:29 - we don't need to create the user because
11:30 - it already exists but we don't expect an
11:32 - error so if we rerun this command
11:35 - now we shouldn't be seeing an error but
11:36 - we are let's debug this real quick we
11:38 - can see that the error type is equal to
11:40 - services slash chat kit slash user
11:43 - already exists now what i tried to do
11:45 - earlier is make sure that if the error
11:47 - was equal to that that we didn't
11:49 - actually um relay the error and i think
11:52 - what i've done is actually mistyped the
11:55 - error type so let's save that real quick
11:58 - restart the server
12:00 - and then we'll try this again this time
12:02 - with a different username just to make
12:03 - sure
12:04 - in fact actually we can use the username
12:06 - foo again if we run this we should see
12:08 - that we get an okay response
12:10 - you'll notice that when we created the
12:12 - user for the first time it said created
12:14 - when we kind of re-log in we just see
12:16 - okay as successful but we have some
12:18 - indication that the user wasn't created
12:21 - the request was successful
12:25 - next we can go back to app.js and
12:28 - instead of just alerting the username
12:30 - like we do here we can send it to the
12:32 - server via post request first let's
12:35 - create a function to handle the
12:36 - submission
12:40 - and then update the on submit prop
12:47 - we'll also need to create a constructor
12:52 - make sure to bind this.on username
12:54 - submitted
12:56 - to this
13:00 - when the form is submitted we're going
13:02 - to use the fetch function to send a post
13:05 - request to localhost for 3001 slash
13:08 - users
13:10 - fetch takes a second argument which lets
13:12 - us specify the request method we'll be
13:14 - sending a post request as well as any
13:16 - headers and of course the body of the
13:19 - request which is going to be
13:21 - the username
13:23 - when this function's finished executing
13:25 - we're going to get the response for now
13:27 - we'll just write to the console success
13:30 - if an error happens
13:34 - we'll console.error the error
13:37 - [Music]
13:39 - we'll also need to call super in the
13:41 - constructor
13:43 - and then if we run the server
13:49 - and we should see if we return to the
13:51 - application reload the page and open the
13:54 - developer tools
13:56 - but under the network tab when we submit
13:58 - a username like
14:00 - bar a post request is sent to the server
14:04 - and we get like a status code of 201
14:06 - created imagine the user closes the tab
14:09 - and comes back and tries to
14:12 - answer their username again we should
14:14 - see this time that we get 200 okay so
14:16 - this is the exact same result we saw in
14:18 - the terminal earlier but now we're
14:20 - seeing in the browser which is one step
14:21 - closer to completing our application
14:24 - you know right now when the user submits
14:26 - their username nothing visibly happens
14:29 - really when they send their username
14:31 - after we send that post request
14:33 - successfully we want to transition them
14:35 - to a different screen we want to show
14:38 - them the chat application so let's
14:40 - create another container component for
14:42 - that chat screen right now we're going
14:44 - to create it in the source directory and
14:46 - it's going to be called chatscreen.js
14:49 - this is going to be a component like the
14:50 - ones we've defined before so let's
14:52 - import react
14:56 - and then create a simple component
15:02 - within app.js
15:06 - we'll want to import the chat screen
15:11 - and then in the constructor we're going
15:13 - to set some initial states we're going
15:15 - to set a current screen property and by
15:19 - default that's going to be equal to what
15:21 - is your username screen while we're here
15:25 - we're also going to create another
15:26 - property for the current username
15:28 - basically when the request has been
15:30 - successfully sent we're going to want to
15:33 - come here and set the current username
15:35 - equal to the username submitted by the
15:38 - user we need to store it in our
15:40 - application state so we can pass it to
15:42 - the chat screen component in just a
15:44 - second
15:45 - we're also going to want to say that
15:47 - once the form has been successfully
15:49 - submitted we're going to update the
15:51 - current screen to be the chat screen
15:53 - that way if we come down here to the
15:55 - render method we can say if this dot
15:58 - state dot
16:00 - current screen
16:02 - is equal to what is your username screen
16:04 - then we're going to return the username
16:06 - form otherwise
16:08 - if this dot state dot current screen is
16:10 - equal to the chat screen
16:13 - we're going to return the chat screen
16:17 - and we're going to pass down the current
16:18 - username which will be equal to
16:20 - this.state.com username
16:23 - if i
16:24 - run the application
16:28 - oh and excuse me i've made a typo
16:34 - here we can enter a username like bob
16:38 - and when we hit submit we'll see that
16:41 - after the request has been sent we get
16:43 - rendered the chat screen
16:45 - in fact what we can do which is kind of
16:46 - cool
16:48 - is go to the chat screen component
16:52 - and we can access
16:57 - this.props.current username
16:59 - and we could say something like uh hello
17:01 - current username
17:04 - so that now if i sign in as like booker
17:06 - and hit submit you can see it says hello
17:08 - booker moving on we're going to need to
17:11 - install the chat kit client sdk
17:19 - and then import it
17:22 - inside of our chat screen component
17:28 - within
17:29 - component did mounts
17:33 - we're going to create a new chat manager
17:40 - just like when we instantiate a chat kit
17:42 - on the server we have to specify our
17:45 - instance locator which again we can
17:47 - access from the chat kit dashboard
17:54 - we also need to specify the user id
17:57 - which is going to be equal to
17:58 - this.props.current username just like we
18:01 - referenced down here
18:04 - we'll also need to provide a chat kit
18:06 - token provider
18:12 - and we're going to specify the url to be
18:15 - http
18:16 - localhost 3001 slash authenticate
18:20 - now as you can probably discern this is
18:22 - pointing to the server we've been
18:24 - working on earlier but we haven't
18:25 - created this authenticate routes i'm
18:28 - going to do this really quick but i'm
18:30 - actually going to paste it from my
18:31 - clipboard as i'm not going to explain it
18:33 - in too much detail if you're following
18:35 - along copy this code exactly
18:37 - authentication is basically the act of
18:40 - proving a user is who he or she says she
18:43 - is in a real application on your server
18:45 - you would typically have some logic to
18:47 - kind of verify that the user is who he
18:49 - or she says she is in our case we're
18:52 - just going to assume everybody is who
18:54 - they say they are and return a chat kit
18:56 - token no matter what the jacket token is
18:59 - returned by this authenticate function
19:01 - but that's all we really need to
19:02 - understand right now let's save that and
19:04 - go back to our chat screen
19:08 - here now we have our chat manager
19:11 - we can call chat manager
19:13 - dot connect so you connect to chat kit
19:16 - once we've connected we should get back
19:18 - the current chat kit user which right
19:20 - now i'm just going to print to the
19:23 - console if something goes wrong which
19:25 - isn't likely in this case
19:27 - i'll write the error to the console just
19:29 - so we can do some debugging let's run
19:31 - this now to see what happens
19:34 - what we should see is that when we
19:36 - reload the application
19:38 - and open the developer tools if i
19:40 - connect as booker hit submit
19:43 - we actually do get an error we get a
19:46 - status code of 401
19:49 - user id mismatch what
19:53 - if something goes wrong which isn't
19:55 - likely in this case which isn't likely
19:57 - in this case
19:58 - isn't likely in this case
20:00 - hmm i think what's likely here
20:03 - is that we have a problem with the
20:05 - authenticate endpoint which is ironic
20:07 - because i copy and pasted it
20:10 - i think what we need to do actually is
20:12 - specify a user id property here and not
20:14 - pass an additional argument
20:17 - if i save that and quickly restart the
20:19 - server
20:21 - hopefully now we'll see when we reload
20:22 - the page
20:24 - and try and create an account
20:27 - and connect to chat kit
20:29 - that we get the current user awesome you
20:32 - can poke around here and kind of get a
20:34 - look at the stuff available to you when
20:35 - you're using chat kit
20:37 - um
20:38 - but the basic idea now is that when we
20:40 - have this current user we can start to
20:42 - perform actions in our chat
20:44 - what we'll do firstly actually is head
20:47 - to the dashboard and to the inspector
20:49 - tab the inspector is a simple tool to
20:51 - help you kind of do basic development
20:54 - and basic testing with chat care what
20:56 - we're going to do is we're going to
20:57 - create a room to create a room we
20:59 - firstly have to create a user it doesn't
21:01 - really matter we're not going to
21:02 - actually use that user and then we're
21:05 - going to create a room called general
21:07 - when we create the room we're going to
21:09 - see the room id which we should copy or
21:11 - at least keep open in this tab so we can
21:13 - reference it afterwards
21:15 - i'm using the inspector to create a room
21:18 - for this tutorial just to keep things
21:20 - simple but realistically you are likely
21:23 - to create your rooms programmatically if
21:25 - you look at the docs for the node sdk or
21:28 - even the um
21:29 - client-side javascript sdk there are
21:31 - functions you can call to create rooms
21:34 - i just want to keep things simple so i'm
21:36 - using the dashboard right here
21:38 - now in a second we're going to make it
21:40 - so that we can subscribe to messages
21:42 - that are sent in that room but first i'm
21:44 - going to create a new component in the
21:46 - components directory called
21:48 - messagelist.js and this is going to be
21:50 - the component responsible for rendering
21:52 - a list of messages for a particular
21:55 - conversation or room
22:05 - the basic idea here is that in the
22:07 - render function
22:10 - i'm going to return a container
22:12 - and then we're going to take a messages
22:14 - prop that we expect whoever's
22:16 - referencing this component to pass down
22:18 - and we're going to map each message
22:24 - to a list item elements
22:35 - actually let's make this a ul
22:38 - instead of a div
22:41 - all right now i'm going to go back to
22:43 - chat screen
22:44 - and i'm going to create a constructor
22:47 - for this component
22:49 - where i'll set some initial states in
22:51 - particular we want to create a messages
22:53 - property
22:55 - then once we've successfully connected
22:57 - to chat care
22:59 - rather than just print out the um
23:01 - current user
23:03 - we're actually going to write current
23:04 - user dot subscribe to
23:07 - room
23:08 - we'll specify the room id to be the room
23:11 - id that we copied just a second ago from
23:13 - the dashboard
23:15 - we'll specify the message limits
23:18 - to the 100 and i'll explain this
23:20 - property a bit more in a second
23:22 - and then we're going to create a hooks
23:24 - property
23:25 - excuse me hooks not books
23:29 - where when a new message is received
23:33 - we're going to call this dot set state
23:38 - and we're going to take that new message
23:40 - and we're going to essentially
23:43 - add it to the existing messages array
23:46 - i'm going to quickly make sure that i
23:49 - the promise returned by subscribe to
23:51 - room
23:52 - so that down here i can call
23:55 - um then and access the current room
23:58 - we'll need this in just a little bit
23:59 - most likely
24:01 - next what i'm going to do is go down to
24:03 - the render function
24:04 - and i'm going to render the message list
24:06 - in fact let's import it real quick from
24:10 - components
24:12 - message list
24:14 - and then down here i can reference the
24:16 - message list and say the messages are
24:17 - equal to this.messages
24:20 - now what we should see if we save this
24:22 - file and run the application
24:24 - is that after i reference super which i
24:27 - always forget for some reason
24:29 - we should be able to go to the app
24:32 - reload the page
24:34 - create a new user or sign in with an
24:36 - existing user
24:39 - and then from even the chat kit
24:41 - dashboard we can actually send some test
24:43 - messages so if i send the text hello
24:45 - right here and go back to this tab you
24:48 - can see that the user called chat kit
24:50 - dashboard has written the text hello
24:53 - in fact if i open up these windows side
24:56 - by side
24:57 - you can see that as i type messages and
24:59 - hit save this interface is updated in
25:01 - real time the next step is to enable the
25:04 - user to enter the message rather than
25:06 - using the dashboard this inspector is
25:08 - handy just as a kind of sanity check we
25:10 - want to make sure that we are
25:11 - subscribing to messages successfully so
25:14 - we can send a test message and make sure
25:15 - it registers the formatting is a bit
25:17 - weird but we'll fix that in just a
25:19 - little bit
25:21 - let's give our user
25:23 - a way to send a message before they can
25:26 - send a message we need to kind of
25:27 - capture the text which we'll do using a
25:30 - form so let's create a new component in
25:33 - the components folder called sand
25:35 - message form dot js and actually this is
25:39 - going to be incredibly similar to the
25:41 - username form we defined earlier so to
25:43 - save some time i'm actually going to
25:46 - open up that username form
25:48 - copy the contents paste this into the
25:51 - send message form and then just do a bit
25:52 - of refactoring
26:05 - [Music]
26:06 - if i then go to app or sorry
26:09 - chatscreen.js
26:10 - i can import vsan message form
26:13 - and then at the bottom here in the
26:15 - render function
26:16 - i can render that send message form and
26:19 - we'll say on submit let's take the text
26:21 - and let's alert it just to make sure
26:23 - things are working fine
26:29 - so if i sign in as booker
26:31 - you'll notice quickly that as i
26:33 - reconnect i get to see all the previous
26:36 - chat kit messages you might recall that
26:39 - earlier inside of the
26:41 - chat screen file
26:42 - we specified a message limit of 100.
26:46 - i just want to use this opportunity to
26:47 - mention that whenever you
26:49 - connect to a chat kit room you have the
26:52 - option to see retroactive messages or
26:54 - sorry to see old historical messages for
26:57 - which the on new message function is
26:59 - called retroactively that's kind of cool
27:02 - but yeah you can see here that we have
27:04 - this what is your text form if we type
27:05 - some text and hit submit we get to see
27:07 - our text
27:09 - but yeah let's actually send this text
27:12 - to chat kit
27:13 - now before we do that let me quickly
27:15 - make a few tweaks to our application
27:17 - states
27:21 - [Music]
27:23 - i'm going to create two new state
27:25 - properties current room and current user
27:28 - once we successfully connect i want to
27:30 - say this dot set state
27:32 - and set the current user on our state
27:35 - down here you might recall that earlier
27:38 - i deliberately created this event
27:40 - function so then now i can come here and
27:42 - say set state current room this will
27:44 - give us wider access to the current room
27:46 - and current user properties so that in
27:48 - this case i can replace the arrow
27:51 - function here with a call to this dot
27:53 - send message
27:54 - i can then create a send message
27:56 - function that takes some text and say
27:58 - this dot state dot current user dot send
28:01 - message we can access current user now
28:04 - you can see
28:06 - we can also say that the room id should
28:07 - be equal to this or state dot current
28:09 - room which we now have access to
28:12 - the id
28:13 - and then we'll specify the text to be
28:15 - equal to the tags submitted by the form
28:17 - before this will run we need to come up
28:19 - here and save this
28:21 - it'll send message equals this or send
28:23 - message dot buying best we're pretty
28:26 - used to doing this by now
28:28 - let's save that run the application and
28:32 - see what happens
28:36 - if i type the text hello and hit submit
28:39 - you can see that the message shows up
28:41 - right here
28:42 - what's kind of cool is if i open up two
28:43 - windows
28:44 - and create another user called ham
28:49 - we can see the text i wrote previously
28:52 - and we can start to talk with each other
28:53 - it's like hi
28:54 - i'm ham
28:57 - oh hey um
28:59 - nice to meet you you get the idea
29:02 - the next thing we'll want to add to our
29:04 - chat application is typing indicators
29:07 - now adding typing indicators with chat
29:09 - kit is actually pretty straightforward
29:12 - it really boils down to two distinct
29:15 - steps
29:16 - firstly whenever the user starts typing
29:18 - so if i'm typing in this field
29:20 - we need to broadcast an event that tells
29:23 - chat kit that a user is typing the
29:26 - second distinct step is to essentially
29:28 - subscribe to that event so that if for
29:30 - example i'm typing in this left-hand
29:33 - window the other clients application
29:35 - will receive an event to say hey
29:37 - booker's typing based on that we can
29:39 - update our ui to show the user who else
29:42 - is typing in a particular room or
29:44 - conversation
29:45 - we'll integrate with chat kit in just a
29:48 - second and things will come together
29:50 - quite swiftly
29:52 - but first we need to make a small tweak
29:54 - to our send message form we need a way
29:57 - to be notified whenever the user types a
29:59 - character in other words whenever the
30:01 - input value is changed we can't do that
30:04 - right now this unchanged prop doesn't
30:06 - exist so we'll quickly add it by going
30:08 - to the components folder and the send
30:11 - message form components and then inside
30:14 - of this unchange function we're going to
30:16 - call this.prop store and change every
30:18 - time the input is updated
30:21 - such for now if i go back to the chat
30:23 - screen
30:24 - and back to the uh render function right
30:26 - here
30:27 - just the test things are working i can
30:29 - pass an arrow function which just writes
30:32 - to the console updated you'll notice
30:34 - that we're not actually capturing the
30:36 - value of the um text input simply
30:39 - because we don't really need it for this
30:41 - and we can always access it via the uh
30:44 - on submit property function anyway but
30:47 - yeah let me just quickly test this
30:48 - before we go any further we've seen a
30:49 - few errors today it's always good to do
30:51 - a little sanity check
30:53 - if i just pop open the developer tools
30:55 - here
30:56 - and quickly enter my username we should
30:59 - see that whenever i type this updated uh
31:02 - messages written to the console that's a
31:03 - great first step
31:06 - but actually we're not too interested in
31:07 - just writing some text to the console
31:10 - what we actually want to do is every
31:11 - time the value is updated we're going to
31:14 - want to send a typing advance which
31:17 - we'll do by this function
31:21 - from here we can access the current user
31:24 - and we call a function called is typing
31:27 - n and we specify the room id the user is
31:30 - typing in which of course we can access
31:32 - viabis.state.currentroom.id
31:36 - and really that's all we have to do
31:38 - fundamentally once we have the events
31:41 - this really boils down to one
31:42 - significant line of code which is pretty
31:45 - cool
31:46 - in fact we'll also just catch an error
31:49 - just in case we need to do some
31:50 - debugging
31:54 - oh and of course as ever we need to come
31:56 - up to the constructor and bind the
31:58 - function we just defined namely sense
32:01 - hyping events
32:03 - to this
32:06 - so yeah that's the first significant
32:09 - step and as you can see it's not even
32:11 - that significant the next thing we need
32:13 - to do is to be notified when another
32:16 - user is typing so we can update our user
32:18 - interface now it's very possible that
32:21 - there will be multiple users typing at
32:23 - the same time and to keep track of this
32:25 - i'm going to create a new state property
32:27 - called users who are typing and that's
32:30 - going to be an array
32:32 - we will update this state in just a
32:34 - second but first we need a way to be
32:37 - notified whenever a user starts or stops
32:40 - typing and the way we do that with chat
32:42 - kit is by specifying a hook
32:45 - earlier we specified an on new message
32:47 - event handler essentially that's called
32:50 - whenever a new messages sends we can
32:52 - also specify an event handler for when a
32:55 - user started typing this event handler
32:58 - receives the user that's currently
33:00 - started typing we can also specify an on
33:02 - user stop typing event handler where
33:06 - again this is the user that stopped
33:07 - typing basically
33:09 - to kind of test this out real quick we
33:11 - can just write to the console and
33:13 - let's just write user
33:17 - started typing
33:21 - and in this case users stopped typing if
33:24 - we save this
33:26 - and quickly run the application
33:29 - in fact let me quickly change this from
33:32 - user to user.name
33:37 - [Music]
33:40 - what we can see is that if i reload the
33:42 - app and then in one window sign in as
33:44 - booker and then this other window is
33:46 - signed in as
33:48 - um
33:49 - let's just call it test user to avoid
33:51 - any kind of confusion
33:54 - as i start to type as test user you can
33:57 - see in the left hand window there in the
33:58 - console the test user started typing
34:01 - i've not stopped typing yet as soon as i
34:03 - move my hand from the keyboard we get an
34:06 - event that says test users stop typing
34:10 - conversely if i open up the console as
34:12 - test user and i start typing as myself
34:15 - as booker you can see the exact same
34:16 - event for the other user however we do
34:19 - not see that event for the current user
34:21 - because there's no benefit really in
34:23 - notifying the current user that they are
34:25 - currently typing of course they know
34:27 - they're typing they're the ones typing
34:29 - with their keyboard the other kind of
34:31 - interesting thing which you might have
34:32 - noticed is that there was and is no need
34:35 - to kind of broadcast an event that says
34:37 - hey the user has stopped typing uh chat
34:40 - kit can figure it out based on how long
34:42 - it's been since it received an event to
34:44 - say that a user is typing which is kind
34:46 - of neat but yeah these events are
34:49 - clearly hooked up correctly that's
34:51 - awesome it's now up to us to update our
34:53 - application state so we can update the
34:56 - user interface for example in this case
34:58 - when the user starts typing what we
35:00 - essentially want to do is add their
35:02 - username to the users who are typing
35:05 - array which we can do using the same
35:07 - technique we saw earlier with the
35:09 - message list
35:13 - when the user stops typing we're going
35:15 - to want to remove their username from
35:17 - that array
35:20 - [Music]
35:21 - what we should be able to do now
35:24 - is go to the render function
35:26 - and then just above the send message
35:29 - form we can say
35:30 - this.state.users who are typing and if
35:33 - we serialize it using json.stringify
35:37 - we should be able to just preview this
35:39 - really quickly in our user interface and
35:41 - before we move on to creating an actual
35:43 - typing indicator component where we can
35:45 - render it in a more proper way
35:48 - [Music]
35:55 - um so yeah let's test this real quick
35:58 - just log in as booker
36:00 - and then as test
36:03 - yeah we can see the bottom here these
36:04 - kind of empty parentheses that's being
36:06 - rendered by react because right now
36:08 - there are no users typing as soon as i
36:10 - start typing his tasks you can see the
36:12 - left window there the test is typing
36:14 - i can start typing you can see the right
36:16 - window what book is typing same kind of
36:17 - thing we saw before but now it's in our
36:20 - ui
36:21 - and what we really want to do is create
36:23 - a new component called typing
36:25 - indicator.js we can pass that um users
36:29 - who are typing
36:30 - object down to and render it properly
36:37 - what we'll do is we'll say if
36:40 - this.props.users who are typing
36:42 - dot length is equal to zero then we know
36:45 - that there is no one typing and we can
36:47 - just return an empty dev otherwise if
36:50 - this.props.users who are typing dot
36:52 - length
36:53 - is equal to one we know that there's
36:55 - currently one user typing and we can
36:57 - return a paragraph tag which is like
37:00 - this.props but users who are typing will
37:03 - bring out that first username
37:06 - and then just concatenate is typing dot
37:09 - dots
37:10 - if there are more than one users more
37:12 - than one user's typing
37:15 - what we'll want to do is a little bit
37:16 - more tricky but still very simple we'll
37:19 - say this.props like users who are typing
37:22 - don't join and what we'll do is we'll
37:24 - just join them what this join function
37:26 - does basically is it takes the array and
37:28 - it returns back a string with each
37:30 - element in the array
37:32 - joined with this particular text so if
37:33 - two users are typing say if bob and jim
37:36 - are typing it will say bob and jim
37:39 - are typing you won't really get to
37:41 - experience this in this screencast it'll
37:43 - be quite hard to demonstrate um
37:47 - i'm pretty sure it'll work fine
37:50 - now if we go back to chatscreen.js
37:53 - and import typing indicator
37:56 - instead of just rendering the text we
37:59 - can render the typing indicator
38:01 - component specify users who are typing
38:04 - is equal to
38:05 - this.state.users who are typing
38:07 - and what we should see when we run this
38:09 - application uh is a much more
38:12 - proper formatting for the list of type a
38:15 - list of users who are typing instead of
38:17 - just an array basically
38:23 - oh i forgot to run the survey
38:33 - [Music]
38:38 - all right so if i start typing
38:40 - we can see ham is typing
38:42 - if i start typing his booker we can see
38:45 - the book is typing um it's really hard
38:47 - to demonstrate but if because i can't
38:49 - really type at the same time with one
38:51 - keyboard but if there were multiple
38:52 - users typing we should see that you know
38:55 - bob and jim are typing
38:58 - you know looking at the application in
38:59 - front of us from a visual standpoint
39:02 - there's clearly a bit of work left to do
39:04 - but from a feature point of view there's
39:06 - only really one more feature we need to
39:08 - add and that's a who's online list where
39:10 - we can see a list of users who've ever
39:12 - joined this chat as well as their online
39:14 - status let's add that next
39:18 - you know i'm not going to spend too much
39:20 - time on nitty gritty styling but i think
39:23 - it might be useful to create a basic
39:24 - layout for our application after all
39:27 - what we really want to see is a sidebar
39:29 - on the left here where we can show a
39:31 - list of online users and on the right
39:33 - hand side we can show the uh chat
39:35 - messages as well as the chat send
39:37 - message form
39:40 - so before integrating with chat care
39:42 - let's set up a basic ui layout
39:45 - what i'm going to do is create a style
39:48 - property
39:50 - on this container dev i'm going to set
39:52 - the display property to flag so i'll be
39:54 - using flexbox to set up the layout of
39:56 - our application
39:58 - within that container i'm going to
39:59 - create a new kind of sub container for
40:02 - all of the elements that i want to be on
40:04 - the right hand side of the page
40:06 - above that i'll create another container
40:08 - this time for the who's online list
40:11 - which i'm going to style very simply by
40:13 - specifying but i want the width to be 30
40:17 - of the width of the viewports and just
40:19 - to kind of uh give us some visual
40:21 - indication of what's happening i'm gonna
40:23 - set background curly hair and see what
40:25 - happens
40:26 - so if i log in now
40:28 - we can see that we have this who's
40:29 - online list on the left and then our
40:31 - chat messages on the right the first
40:33 - thing that comes to mind is that
40:34 - obviously this isn't filling the full
40:36 - height of the page we can fix that
40:38 - really easily by setting the height
40:40 - property to 100
40:43 - vh
40:49 - that looks good to me one more small ui
40:52 - layout thing i'll fix is obviously this
40:54 - text input should probably be anchored
40:57 - to the bottom
40:58 - and the way we can do that
41:00 - is by coming down here
41:04 - wrapping the message list in its own
41:06 - container
41:10 - with a style property and we're just
41:12 - gonna set the uh flex property to one
41:22 - well clearly that didn't work
41:24 - that's because i actually need to make
41:26 - sure that um
41:27 - on the container here
41:30 - i set the display to flex and i set the
41:32 - flex direction
41:34 - it's a column
41:40 - there we go you can see that it's pushed
41:41 - down to the bottom
41:43 - obviously you need some padding and some
41:44 - additional styles we'll tackle that
41:46 - afterwards what that flex one property i
41:49 - just added does basically is it tells
41:51 - the browser to make the message list
41:54 - occupy all the space it can while still
41:56 - leaving room for any other elements and
41:59 - because it has that flex one property
42:00 - kind of dominates
42:03 - as you might have guessed by this point
42:05 - we're going to create a new component
42:06 - called who's online list.js
42:13 - the idea here is that we're going to
42:15 - pass down a list of users we're going to
42:17 - check if that user's property exists if
42:20 - it does we'll return the list but
42:22 - otherwise
42:23 - we're going to
42:25 - return the text
42:27 - loading we could return nothing and just
42:29 - render an empty screen but it might be
42:31 - nice to show the loading status
42:33 - and then what we're going to do if there
42:35 - are some users is we're going to return
42:37 - a list
42:38 - inside that list we're going to take
42:40 - each user
42:43 - and map that user to a list item
42:51 - i expect we'll want to make some tweaks
42:52 - to this component but for now let's head
42:55 - back to chat screen and import the
42:58 - who's online list component
43:01 - then down here in the render function
43:04 - instead of just rendering the text who's
43:06 - on my list let's actually render the
43:08 - who's online list and we're going to
43:10 - pass down the user's property which is
43:13 - going to be equal to
43:14 - this.state.currentroom.users
43:18 - and this is actually quite a magical
43:20 - property
43:22 - the reason i say that is that normally
43:24 - in our react application
43:26 - for example when it comes to a list of
43:29 - users who are currently typing we have
43:31 - to manage that state ourselves we're
43:33 - always adding or removing items from an
43:35 - array or an object when it comes to
43:37 - managing users there's no need to manage
43:39 - that state ourselves because the chat
43:42 - kit client sdk does that for us this
43:45 - user's property is always up to date it
43:48 - always reflects the up-to-date state of
43:51 - your chat application so whenever
43:53 - someone get joins they get added to this
43:55 - property
43:56 - if their online status changes whether
43:58 - they go offline or come back online um
44:01 - it's completely reflected by this
44:03 - property
44:04 - which means that when it comes to
44:05 - updating our user interface all we
44:08 - really have to do
44:10 - you know because obviously when someone
44:11 - uh
44:12 - comes online or goes offline we want to
44:14 - update our user interface um we can use
44:17 - hooks like we did for the typing events
44:20 - so we can say when a user
44:22 - comes online
44:25 - rather than updating any kind of state
44:27 - all we really have to do is call
44:28 - this.force update and what that's going
44:31 - to do in turn the same for when a user
44:33 - um
44:36 - went offline or whenever a user joined
44:39 - for that matter whenever any of these
44:41 - events happen we're going to call force
44:43 - updates and what that really translates
44:45 - to in react speakers
44:48 - call this render function again and when
44:50 - this render function gets called again
44:52 - the user's property gets evaluated again
44:55 - and that should reflect the state of our
44:56 - application in fact one thing and like i
44:59 - said we probably were going to end up
45:00 - tweaking that um who's online list one
45:03 - thing we can do is we can come back down
45:05 - here where we return the list item of
45:07 - the username and in parentheses
45:10 - we can render the user.presence.state
45:13 - which is either going to be online or
45:15 - offline
45:18 - we just made a lot of changes at once so
45:20 - we'll see what happens when we run the
45:21 - application
45:25 - yeah i kind of expected after writing
45:26 - that much code i probably made a typo
45:29 - uh which is a quite easy quite an easy
45:31 - fix if i go to chat screen and i think i
45:33 - just need to
45:37 - add commas at the end of each of these
45:39 - uh statements
45:42 - but once that's up and running
45:43 - successfully
45:44 - oops and again i need to call super
45:46 - always always always forget to do that
45:50 - [Music]
45:51 - actually this component doesn't even
45:53 - have a constructor
45:56 - it's because i mistyped components here
45:59 - i think
46:01 - cool let's see what happens if i log in
46:04 - and we see that loading text once we're
46:06 - connected now this is cool um we see a
46:09 - list of all the users who've ever joined
46:10 - this room like throughout this tutorial
46:12 - i connected as then his test then as
46:14 - test user if i open another window real
46:16 - quick
46:17 - now watch this take a look at um test
46:20 - user right here currently test users
46:22 - offline but as soon as i join
46:26 - that offline tags changes to online
46:28 - which is super cool
46:30 - the other cool thing is that if i hit
46:31 - back here basically closing the chat app
46:34 - pay attention to test users online
46:35 - status
46:36 - boom test user goes offline and one more
46:39 - thing i want to test is that if i create
46:41 - a new user
46:43 - and i join the room we should see that
46:45 - new user
46:47 - yes gets added to the list of online
46:49 - users and that pretty much integrates
46:51 - with the same kind of system you know if
46:53 - we close the tab that user appears
46:55 - offline
46:56 - wicked and that looks awesome to me i'm
46:59 - going to pause the screencast and i'm
47:01 - going to take a bit of time off camera
47:03 - making this chat application look a bit
47:05 - better but all the basic functionality
47:07 - is there which i'm really excited about
47:10 - all right i made some updates if i run
47:13 - the application
47:16 - and log back in
47:21 - you can see it looks a lot better now
47:24 - trust me you might think it would have
47:26 - been nice to see me add the style step
47:28 - by step but it was fiddly a bit boring
47:32 - and really a bit outside the scope of
47:34 - this tutorial
47:36 - besides the complete code is on github
47:38 - where you can browse it download it
47:41 - adapt it maybe even use it as the
47:43 - foundation for your next app
47:47 - chat kit is a tool i'm helping to build
47:49 - a pusher i'm really excited about it if
47:52 - you think it can save you time and help
47:54 - you build a better product faster the
47:56 - team and i would love to help you are
47:58 - very very welcome to join our slack
48:00 - channel where you can reach the team and
48:02 - i directly with your questions there'll
48:04 - be a link in the description as well on
48:06 - all of our documentation pages we have a
48:08 - chat if you want to pop up there
48:11 - of course i would love to hear your
48:12 - thoughts about this video or indeed
48:14 - check it in the comments section as well
48:16 - thank you so much for watching i really
48:18 - hope you found it interesting i've been
48:20 - like booker goodbye

Cleaned transcript:

hey how's it going my name's booker and in this video i'm going to show you how to build a group chat similar to slack using react.js and chat kits which is a developer tool that my team and i are building here at pusher in the end we'll have an app where users can send and receive messages see who's typing with nifty typing indicators and to top it all off a real time who's online list the app we're going to build is going to resemble slack and it could well be used for team communication but i realized having built the project and recorded the video yesterday but the concepts and techniques we're going to look at could be used for most types of chat applications be that a customer messaging app maybe for a crm maybe a group chat for your community or even ingame chat if you're a game developer i wanted to quickly mention that all the code is on github the link is in the description and i even took the liberty of writing up a stepbystep tutorial based on the exact same code you're going to see in this video so if you want to follow along you can maybe watch the video and reference the code on github it's up to you if at any point you find yourself enjoying the video please drop a like on the youtube video you can also follow me on twitter i'm at booker currents but yeah i'm excited let's dive in instead of starting from complete scratch we're going to download a starter template i created earlier we'll have a poke around the code in just a second to see exactly what's happening but first off download this repository which you can do by coming here and clicking on download zip or by copying the link and heading to the terminal but we can run git clone followed by the link to the repository followed by the name of the local folder you want to download that code into if we navigate into that folder we can run npm install to bring in those local dependencies pretty standard stuff if we open the project up we can see that there aren't really that many files in this public folder we have an index.html file this mainly exists just to give us something to mount our react application onto we won't be touching this html file going forward instead of source we have some basic react application files including an empty components directory where we'll be creating some of our components as we go forward the real meat here is this app.js file which we'll add more code to as we go forward but right now just renders a simple component with the text slack if we look at package.json you can see that we're using react scripts to run the react application and we also have a start script where we can run both the server which i'll show you in a second as well as the clients all with one command the server is actually the main reason this template exists i didn't want to spend too much time explaining how to set up a simple express js server because if you already know express this here is going to look super familiar to you it does need explaining if you don't know express very well which is totally okay then it doesn't really matter too much we're not going to spend very much time on the server now the first thing we're going to want to do when the user loads our application is ask them what is your username we'll use this username to create a chat kit user to capture that username we're going to create a username form component and we're going to create that component inside of the components directory i just showed you first we'll import react then we'll create our username form components inside the username form we'll create a constructor but take some props and we'll immediately pass those props to the super function we'll also set some initial state for our application next we'll create a render function we'll return a simple form whenever this input here is updated or changed we're going to call vista on change and then whenever the form is submitted we're going to call vista on submit we'll also need to go back up to the constructor and bind both of those functions to this nice so this is a pretty standard react form what we're doing is we're creating a controlled component but whenever the user enters some inputs we update our component state whenever the form is submitted we take that component state up here and we pass it to the on submit prop which we expect whoever's referencing this form to pass in fact let's reference this form now just to make sure everything is in order so we'll go to app.js and import username form from components slash username form and then instead of returning just the text slack let's return the username form specify that on submit prop and we'll just say when we get the username let's alert it just to make sure things are in order so that now if i create a new split and run the application using npm run start or actually we can just do npm start for short that should spin up a server so that we can go to localhost 3000 enter a username like booker and when we hit submit we can capture that username and show it in an alert but actually we don't want to just show it in a in an alert whenever this user enters their username we want to send that to our server application and create a chat kit user but before we can do that we must first create a chat kit application or a chat kit instance so head to pusher.com chat kit and click sign up you'll have to create a new account i already have one so i'll log into an existing account real quick once you're at the dashboard and the chat kit click create new and create a new chat kit instance i'm going to call mine slack clone the way chat kit works essentially is that you install a chat kit client sdk there are sdks for javascript swift and android we'll be using javascript and then you can subscribe to a room where you'll receive an event every time a new message is sent on the same client you can also send messages you can send plain text or you can send files so you can send video messages audio messages whatever you like once you have this kind of fundamental chat in place it becomes quite easy to add things like typing indicators and online user presence which i'll show you how to do later in this video right now i just want you to take notes of the keys tab in the dashboard where you can see your instance locator and secret key we'll need these in just a second now most interactions in chat kit they happen on the clients like i just showed you there are client sdks for javascript swift and android and you can even use these libraries together so you could build a web application as well as an android application and they can both communicate using chat kit which is kind of cool but if you head to the docs you can see that there are both client sdks and server sdks most interactions with chat kit happen on the clients that's the same most code will write will use the client sdks but we'll also need to use the node.js server sdk to create and manage users so what i'll do is i'll copy this installation command head to the terminal and install pusher chat kit server now we have that sdk installed we can open up server.js and import chat kit from pusher dash chat kit dash server and then we can create our own local chat kit instance by calling new chat kit.default and we pass to this constructor function firstly our instance locator and secondly our secret key both of which we can access from the dashboard so let's copy that instance locator and paste it in and then let's copy that secret key and paste it in like so now the main purpose behind this server is to accept a post request from the client with the user's username when we receive that username we want to create a chat kit user with that username we have to do this on the client because it needs to happen securely you can only create a user if you have this secret key and in order for it to be secret it has to remain on the server so what we'll do is we'll come down here and create a new route handler called users that takes a post request and as soon as that endpoint gets hit we're going to bring out the username from the request body once we have that username we're going to call chat kits dot create user specify the user's name to the username and we're also going to specify their id to be equal to the username when that function is finished executing we're going to send a status of 201 to the client to indicate that the user has been created successfully it's possible that an error will occur and in this particular case it's particularly possible that the user enters a username that already exists a username which is already in use by another chat kit user for this particular chat kit instance in that case we're going to get a specific error um and for our application that's actually okay we don't mind if somebody enters a username but already exists because we're going to assume they're kind of revisiting the application so what we're going to do is we're going to check the error type and check if it's equal to services slash chat kit slash user user underscore already underscore exists and if the user already exists we're going to send a status of 200 to indicate that the request was still successful otherwise we're going to send a status equal to the error status code we're going to relay that from chat kit to our client and we're also going to pass down the error json uh just in case we need to use to do some debugging later down the line let's test this out real quick let's create a new split and run the server and then in another split i'm going to run curl specified that we want to send a json request a post request and we'll specify here the username to be equal to foo and we want to send this post request to http localhost 3001 slash users and we should see when we run this that the user is created and indeed the user is created now imagine that the user just entered that username on the form and they created their account then maybe they closed the tab and they came back later they're going to enter the same username we don't need to create the user because it already exists but we don't expect an error so if we rerun this command now we shouldn't be seeing an error but we are let's debug this real quick we can see that the error type is equal to services slash chat kit slash user already exists now what i tried to do earlier is make sure that if the error was equal to that that we didn't actually um relay the error and i think what i've done is actually mistyped the error type so let's save that real quick restart the server and then we'll try this again this time with a different username just to make sure in fact actually we can use the username foo again if we run this we should see that we get an okay response you'll notice that when we created the user for the first time it said created when we kind of relog in we just see okay as successful but we have some indication that the user wasn't created the request was successful next we can go back to app.js and instead of just alerting the username like we do here we can send it to the server via post request first let's create a function to handle the submission and then update the on submit prop we'll also need to create a constructor make sure to bind this.on username submitted to this when the form is submitted we're going to use the fetch function to send a post request to localhost for 3001 slash users fetch takes a second argument which lets us specify the request method we'll be sending a post request as well as any headers and of course the body of the request which is going to be the username when this function's finished executing we're going to get the response for now we'll just write to the console success if an error happens we'll console.error the error we'll also need to call super in the constructor and then if we run the server and we should see if we return to the application reload the page and open the developer tools but under the network tab when we submit a username like bar a post request is sent to the server and we get like a status code of 201 created imagine the user closes the tab and comes back and tries to answer their username again we should see this time that we get 200 okay so this is the exact same result we saw in the terminal earlier but now we're seeing in the browser which is one step closer to completing our application you know right now when the user submits their username nothing visibly happens really when they send their username after we send that post request successfully we want to transition them to a different screen we want to show them the chat application so let's create another container component for that chat screen right now we're going to create it in the source directory and it's going to be called chatscreen.js this is going to be a component like the ones we've defined before so let's import react and then create a simple component within app.js we'll want to import the chat screen and then in the constructor we're going to set some initial states we're going to set a current screen property and by default that's going to be equal to what is your username screen while we're here we're also going to create another property for the current username basically when the request has been successfully sent we're going to want to come here and set the current username equal to the username submitted by the user we need to store it in our application state so we can pass it to the chat screen component in just a second we're also going to want to say that once the form has been successfully submitted we're going to update the current screen to be the chat screen that way if we come down here to the render method we can say if this dot state dot current screen is equal to what is your username screen then we're going to return the username form otherwise if this dot state dot current screen is equal to the chat screen we're going to return the chat screen and we're going to pass down the current username which will be equal to this.state.com username if i run the application oh and excuse me i've made a typo here we can enter a username like bob and when we hit submit we'll see that after the request has been sent we get rendered the chat screen in fact what we can do which is kind of cool is go to the chat screen component and we can access this.props.current username and we could say something like uh hello current username so that now if i sign in as like booker and hit submit you can see it says hello booker moving on we're going to need to install the chat kit client sdk and then import it inside of our chat screen component within component did mounts we're going to create a new chat manager just like when we instantiate a chat kit on the server we have to specify our instance locator which again we can access from the chat kit dashboard we also need to specify the user id which is going to be equal to this.props.current username just like we referenced down here we'll also need to provide a chat kit token provider and we're going to specify the url to be http localhost 3001 slash authenticate now as you can probably discern this is pointing to the server we've been working on earlier but we haven't created this authenticate routes i'm going to do this really quick but i'm actually going to paste it from my clipboard as i'm not going to explain it in too much detail if you're following along copy this code exactly authentication is basically the act of proving a user is who he or she says she is in a real application on your server you would typically have some logic to kind of verify that the user is who he or she says she is in our case we're just going to assume everybody is who they say they are and return a chat kit token no matter what the jacket token is returned by this authenticate function but that's all we really need to understand right now let's save that and go back to our chat screen here now we have our chat manager we can call chat manager dot connect so you connect to chat kit once we've connected we should get back the current chat kit user which right now i'm just going to print to the console if something goes wrong which isn't likely in this case i'll write the error to the console just so we can do some debugging let's run this now to see what happens what we should see is that when we reload the application and open the developer tools if i connect as booker hit submit we actually do get an error we get a status code of 401 user id mismatch what if something goes wrong which isn't likely in this case which isn't likely in this case isn't likely in this case hmm i think what's likely here is that we have a problem with the authenticate endpoint which is ironic because i copy and pasted it i think what we need to do actually is specify a user id property here and not pass an additional argument if i save that and quickly restart the server hopefully now we'll see when we reload the page and try and create an account and connect to chat kit that we get the current user awesome you can poke around here and kind of get a look at the stuff available to you when you're using chat kit um but the basic idea now is that when we have this current user we can start to perform actions in our chat what we'll do firstly actually is head to the dashboard and to the inspector tab the inspector is a simple tool to help you kind of do basic development and basic testing with chat care what we're going to do is we're going to create a room to create a room we firstly have to create a user it doesn't really matter we're not going to actually use that user and then we're going to create a room called general when we create the room we're going to see the room id which we should copy or at least keep open in this tab so we can reference it afterwards i'm using the inspector to create a room for this tutorial just to keep things simple but realistically you are likely to create your rooms programmatically if you look at the docs for the node sdk or even the um clientside javascript sdk there are functions you can call to create rooms i just want to keep things simple so i'm using the dashboard right here now in a second we're going to make it so that we can subscribe to messages that are sent in that room but first i'm going to create a new component in the components directory called messagelist.js and this is going to be the component responsible for rendering a list of messages for a particular conversation or room the basic idea here is that in the render function i'm going to return a container and then we're going to take a messages prop that we expect whoever's referencing this component to pass down and we're going to map each message to a list item elements actually let's make this a ul instead of a div all right now i'm going to go back to chat screen and i'm going to create a constructor for this component where i'll set some initial states in particular we want to create a messages property then once we've successfully connected to chat care rather than just print out the um current user we're actually going to write current user dot subscribe to room we'll specify the room id to be the room id that we copied just a second ago from the dashboard we'll specify the message limits to the 100 and i'll explain this property a bit more in a second and then we're going to create a hooks property excuse me hooks not books where when a new message is received we're going to call this dot set state and we're going to take that new message and we're going to essentially add it to the existing messages array i'm going to quickly make sure that i the promise returned by subscribe to room so that down here i can call um then and access the current room we'll need this in just a little bit most likely next what i'm going to do is go down to the render function and i'm going to render the message list in fact let's import it real quick from components message list and then down here i can reference the message list and say the messages are equal to this.messages now what we should see if we save this file and run the application is that after i reference super which i always forget for some reason we should be able to go to the app reload the page create a new user or sign in with an existing user and then from even the chat kit dashboard we can actually send some test messages so if i send the text hello right here and go back to this tab you can see that the user called chat kit dashboard has written the text hello in fact if i open up these windows side by side you can see that as i type messages and hit save this interface is updated in real time the next step is to enable the user to enter the message rather than using the dashboard this inspector is handy just as a kind of sanity check we want to make sure that we are subscribing to messages successfully so we can send a test message and make sure it registers the formatting is a bit weird but we'll fix that in just a little bit let's give our user a way to send a message before they can send a message we need to kind of capture the text which we'll do using a form so let's create a new component in the components folder called sand message form dot js and actually this is going to be incredibly similar to the username form we defined earlier so to save some time i'm actually going to open up that username form copy the contents paste this into the send message form and then just do a bit of refactoring if i then go to app or sorry chatscreen.js i can import vsan message form and then at the bottom here in the render function i can render that send message form and we'll say on submit let's take the text and let's alert it just to make sure things are working fine so if i sign in as booker you'll notice quickly that as i reconnect i get to see all the previous chat kit messages you might recall that earlier inside of the chat screen file we specified a message limit of 100. i just want to use this opportunity to mention that whenever you connect to a chat kit room you have the option to see retroactive messages or sorry to see old historical messages for which the on new message function is called retroactively that's kind of cool but yeah you can see here that we have this what is your text form if we type some text and hit submit we get to see our text but yeah let's actually send this text to chat kit now before we do that let me quickly make a few tweaks to our application states i'm going to create two new state properties current room and current user once we successfully connect i want to say this dot set state and set the current user on our state down here you might recall that earlier i deliberately created this event function so then now i can come here and say set state current room this will give us wider access to the current room and current user properties so that in this case i can replace the arrow function here with a call to this dot send message i can then create a send message function that takes some text and say this dot state dot current user dot send message we can access current user now you can see we can also say that the room id should be equal to this or state dot current room which we now have access to the id and then we'll specify the text to be equal to the tags submitted by the form before this will run we need to come up here and save this it'll send message equals this or send message dot buying best we're pretty used to doing this by now let's save that run the application and see what happens if i type the text hello and hit submit you can see that the message shows up right here what's kind of cool is if i open up two windows and create another user called ham we can see the text i wrote previously and we can start to talk with each other it's like hi i'm ham oh hey um nice to meet you you get the idea the next thing we'll want to add to our chat application is typing indicators now adding typing indicators with chat kit is actually pretty straightforward it really boils down to two distinct steps firstly whenever the user starts typing so if i'm typing in this field we need to broadcast an event that tells chat kit that a user is typing the second distinct step is to essentially subscribe to that event so that if for example i'm typing in this lefthand window the other clients application will receive an event to say hey booker's typing based on that we can update our ui to show the user who else is typing in a particular room or conversation we'll integrate with chat kit in just a second and things will come together quite swiftly but first we need to make a small tweak to our send message form we need a way to be notified whenever the user types a character in other words whenever the input value is changed we can't do that right now this unchanged prop doesn't exist so we'll quickly add it by going to the components folder and the send message form components and then inside of this unchange function we're going to call this.prop store and change every time the input is updated such for now if i go back to the chat screen and back to the uh render function right here just the test things are working i can pass an arrow function which just writes to the console updated you'll notice that we're not actually capturing the value of the um text input simply because we don't really need it for this and we can always access it via the uh on submit property function anyway but yeah let me just quickly test this before we go any further we've seen a few errors today it's always good to do a little sanity check if i just pop open the developer tools here and quickly enter my username we should see that whenever i type this updated uh messages written to the console that's a great first step but actually we're not too interested in just writing some text to the console what we actually want to do is every time the value is updated we're going to want to send a typing advance which we'll do by this function from here we can access the current user and we call a function called is typing n and we specify the room id the user is typing in which of course we can access viabis.state.currentroom.id and really that's all we have to do fundamentally once we have the events this really boils down to one significant line of code which is pretty cool in fact we'll also just catch an error just in case we need to do some debugging oh and of course as ever we need to come up to the constructor and bind the function we just defined namely sense hyping events to this so yeah that's the first significant step and as you can see it's not even that significant the next thing we need to do is to be notified when another user is typing so we can update our user interface now it's very possible that there will be multiple users typing at the same time and to keep track of this i'm going to create a new state property called users who are typing and that's going to be an array we will update this state in just a second but first we need a way to be notified whenever a user starts or stops typing and the way we do that with chat kit is by specifying a hook earlier we specified an on new message event handler essentially that's called whenever a new messages sends we can also specify an event handler for when a user started typing this event handler receives the user that's currently started typing we can also specify an on user stop typing event handler where again this is the user that stopped typing basically to kind of test this out real quick we can just write to the console and let's just write user started typing and in this case users stopped typing if we save this and quickly run the application in fact let me quickly change this from user to user.name what we can see is that if i reload the app and then in one window sign in as booker and then this other window is signed in as um let's just call it test user to avoid any kind of confusion as i start to type as test user you can see in the left hand window there in the console the test user started typing i've not stopped typing yet as soon as i move my hand from the keyboard we get an event that says test users stop typing conversely if i open up the console as test user and i start typing as myself as booker you can see the exact same event for the other user however we do not see that event for the current user because there's no benefit really in notifying the current user that they are currently typing of course they know they're typing they're the ones typing with their keyboard the other kind of interesting thing which you might have noticed is that there was and is no need to kind of broadcast an event that says hey the user has stopped typing uh chat kit can figure it out based on how long it's been since it received an event to say that a user is typing which is kind of neat but yeah these events are clearly hooked up correctly that's awesome it's now up to us to update our application state so we can update the user interface for example in this case when the user starts typing what we essentially want to do is add their username to the users who are typing array which we can do using the same technique we saw earlier with the message list when the user stops typing we're going to want to remove their username from that array what we should be able to do now is go to the render function and then just above the send message form we can say this.state.users who are typing and if we serialize it using json.stringify we should be able to just preview this really quickly in our user interface and before we move on to creating an actual typing indicator component where we can render it in a more proper way um so yeah let's test this real quick just log in as booker and then as test yeah we can see the bottom here these kind of empty parentheses that's being rendered by react because right now there are no users typing as soon as i start typing his tasks you can see the left window there the test is typing i can start typing you can see the right window what book is typing same kind of thing we saw before but now it's in our ui and what we really want to do is create a new component called typing indicator.js we can pass that um users who are typing object down to and render it properly what we'll do is we'll say if this.props.users who are typing dot length is equal to zero then we know that there is no one typing and we can just return an empty dev otherwise if this.props.users who are typing dot length is equal to one we know that there's currently one user typing and we can return a paragraph tag which is like this.props but users who are typing will bring out that first username and then just concatenate is typing dot dots if there are more than one users more than one user's typing what we'll want to do is a little bit more tricky but still very simple we'll say this.props like users who are typing don't join and what we'll do is we'll just join them what this join function does basically is it takes the array and it returns back a string with each element in the array joined with this particular text so if two users are typing say if bob and jim are typing it will say bob and jim are typing you won't really get to experience this in this screencast it'll be quite hard to demonstrate um i'm pretty sure it'll work fine now if we go back to chatscreen.js and import typing indicator instead of just rendering the text we can render the typing indicator component specify users who are typing is equal to this.state.users who are typing and what we should see when we run this application uh is a much more proper formatting for the list of type a list of users who are typing instead of just an array basically oh i forgot to run the survey all right so if i start typing we can see ham is typing if i start typing his booker we can see the book is typing um it's really hard to demonstrate but if because i can't really type at the same time with one keyboard but if there were multiple users typing we should see that you know bob and jim are typing you know looking at the application in front of us from a visual standpoint there's clearly a bit of work left to do but from a feature point of view there's only really one more feature we need to add and that's a who's online list where we can see a list of users who've ever joined this chat as well as their online status let's add that next you know i'm not going to spend too much time on nitty gritty styling but i think it might be useful to create a basic layout for our application after all what we really want to see is a sidebar on the left here where we can show a list of online users and on the right hand side we can show the uh chat messages as well as the chat send message form so before integrating with chat care let's set up a basic ui layout what i'm going to do is create a style property on this container dev i'm going to set the display property to flag so i'll be using flexbox to set up the layout of our application within that container i'm going to create a new kind of sub container for all of the elements that i want to be on the right hand side of the page above that i'll create another container this time for the who's online list which i'm going to style very simply by specifying but i want the width to be 30 of the width of the viewports and just to kind of uh give us some visual indication of what's happening i'm gonna set background curly hair and see what happens so if i log in now we can see that we have this who's online list on the left and then our chat messages on the right the first thing that comes to mind is that obviously this isn't filling the full height of the page we can fix that really easily by setting the height property to 100 vh that looks good to me one more small ui layout thing i'll fix is obviously this text input should probably be anchored to the bottom and the way we can do that is by coming down here wrapping the message list in its own container with a style property and we're just gonna set the uh flex property to one well clearly that didn't work that's because i actually need to make sure that um on the container here i set the display to flex and i set the flex direction it's a column there we go you can see that it's pushed down to the bottom obviously you need some padding and some additional styles we'll tackle that afterwards what that flex one property i just added does basically is it tells the browser to make the message list occupy all the space it can while still leaving room for any other elements and because it has that flex one property kind of dominates as you might have guessed by this point we're going to create a new component called who's online list.js the idea here is that we're going to pass down a list of users we're going to check if that user's property exists if it does we'll return the list but otherwise we're going to return the text loading we could return nothing and just render an empty screen but it might be nice to show the loading status and then what we're going to do if there are some users is we're going to return a list inside that list we're going to take each user and map that user to a list item i expect we'll want to make some tweaks to this component but for now let's head back to chat screen and import the who's online list component then down here in the render function instead of just rendering the text who's on my list let's actually render the who's online list and we're going to pass down the user's property which is going to be equal to this.state.currentroom.users and this is actually quite a magical property the reason i say that is that normally in our react application for example when it comes to a list of users who are currently typing we have to manage that state ourselves we're always adding or removing items from an array or an object when it comes to managing users there's no need to manage that state ourselves because the chat kit client sdk does that for us this user's property is always up to date it always reflects the uptodate state of your chat application so whenever someone get joins they get added to this property if their online status changes whether they go offline or come back online um it's completely reflected by this property which means that when it comes to updating our user interface all we really have to do you know because obviously when someone uh comes online or goes offline we want to update our user interface um we can use hooks like we did for the typing events so we can say when a user comes online rather than updating any kind of state all we really have to do is call this.force update and what that's going to do in turn the same for when a user um went offline or whenever a user joined for that matter whenever any of these events happen we're going to call force updates and what that really translates to in react speakers call this render function again and when this render function gets called again the user's property gets evaluated again and that should reflect the state of our application in fact one thing and like i said we probably were going to end up tweaking that um who's online list one thing we can do is we can come back down here where we return the list item of the username and in parentheses we can render the user.presence.state which is either going to be online or offline we just made a lot of changes at once so we'll see what happens when we run the application yeah i kind of expected after writing that much code i probably made a typo uh which is a quite easy quite an easy fix if i go to chat screen and i think i just need to add commas at the end of each of these uh statements but once that's up and running successfully oops and again i need to call super always always always forget to do that actually this component doesn't even have a constructor it's because i mistyped components here i think cool let's see what happens if i log in and we see that loading text once we're connected now this is cool um we see a list of all the users who've ever joined this room like throughout this tutorial i connected as then his test then as test user if i open another window real quick now watch this take a look at um test user right here currently test users offline but as soon as i join that offline tags changes to online which is super cool the other cool thing is that if i hit back here basically closing the chat app pay attention to test users online status boom test user goes offline and one more thing i want to test is that if i create a new user and i join the room we should see that new user yes gets added to the list of online users and that pretty much integrates with the same kind of system you know if we close the tab that user appears offline wicked and that looks awesome to me i'm going to pause the screencast and i'm going to take a bit of time off camera making this chat application look a bit better but all the basic functionality is there which i'm really excited about all right i made some updates if i run the application and log back in you can see it looks a lot better now trust me you might think it would have been nice to see me add the style step by step but it was fiddly a bit boring and really a bit outside the scope of this tutorial besides the complete code is on github where you can browse it download it adapt it maybe even use it as the foundation for your next app chat kit is a tool i'm helping to build a pusher i'm really excited about it if you think it can save you time and help you build a better product faster the team and i would love to help you are very very welcome to join our slack channel where you can reach the team and i directly with your questions there'll be a link in the description as well on all of our documentation pages we have a chat if you want to pop up there of course i would love to hear your thoughts about this video or indeed check it in the comments section as well thank you so much for watching i really hope you found it interesting i've been like booker goodbye
