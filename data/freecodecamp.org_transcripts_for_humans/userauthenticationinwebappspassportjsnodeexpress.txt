With timestamps:

00:01 - welcome to my complete beginners course
00:03 - on user authentication in web apps
00:06 - in this course we're going to be talking
00:08 - about how do you actually
00:10 - write that register form or the login
00:12 - form for your users
00:14 - using node.js express and
00:17 - passport.js and then later in the course
00:20 - we'll actually go into how do we apply
00:22 - these strategies to
00:24 - an angular application and then even
00:26 - further
00:27 - how do we write our own custom jwt
00:30 - authentication option but before we get
00:33 - into that i want to just
00:34 - introduce myself i'm zach and i'm a full
00:37 - stack developer
00:38 - i've got a smaller youtube channel where
00:40 - i cover a lot of these topics
00:42 - and i've been writing code for about
00:43 - four and a half years pretty much every
00:45 - day at this point
00:46 - and i'm super excited to share this
00:49 - particular series because it was one of
00:51 - the biggest struggles that i had
00:53 - when i was first learning to code i
00:54 - struggled with it for
00:56 - two main reasons number one i was scared
00:58 - of it
00:59 - i was scared to write a user
01:01 - authentication option because
01:03 - you know everyone talks about you know
01:05 - infosec and
01:07 - trying to secure your web apps as
01:10 - strongly as possible and how there's
01:11 - always
01:12 - you know loopholes and bugs and you know
01:14 - exploits and stuff like that
01:16 - and so this whole user authentication
01:18 - topic
01:19 - was very intimidating to me the second
01:21 - reason that it was really tough for me
01:24 - is because everyone made it look so easy
01:27 - i would watch tutorials where we'd get
01:29 - through the user authentication section
01:31 - in about 10 minutes and i was left
01:35 - just scratching my head because i had no
01:37 - idea what had just happened
01:39 - i had copied the code in the tutorial
01:41 - but i had no idea what was going on
01:43 - behind the scenes
01:44 - in this tutorial i want to solve both of
01:47 - those problems
01:48 - so with the security side of things
01:51 - this all gets easier when you realize
01:53 - that you know when you're first building
01:55 - your apps
01:56 - the the prototype version it's not
01:59 - important to
02:00 - you know secure your app on a grand
02:02 - scale like a corporation would have to
02:05 - the methods i'm going to teach within
02:06 - this course are perfect for someone
02:09 - who's just trying to get a basic
02:11 - auth strategy implemented and put it
02:14 - into their you know prototype
02:16 - app or even a small scale business it's
02:18 - going to be secure enough
02:20 - for something like that and on the
02:21 - second point in terms of
02:23 - understanding what's going on behind the
02:25 - scenes i really hope that this tutorial
02:28 - is the most in-depth user authentication
02:31 - tutorial that you have ever seen
02:33 - as you can see by the length of this
02:34 - video it is very
02:36 - long and the reason being is not because
02:39 - it takes us
02:40 - you know this many hours to implement
02:42 - authentication
02:43 - but because it takes us this many hours
02:45 - to understand all of the different
02:47 - components
02:48 - that go into an authentication scheme
02:50 - for example
02:51 - if we're using passport js we have to
02:54 - understand middlewares in express
02:56 - because passport.js
02:57 - is a middleware and not only that but
02:59 - it's actually
03:00 - a little bit more complex middleware
03:02 - than you're probably
03:03 - using on a normal basis on the actual
03:05 - authentication side of things
03:07 - there's a ton of topics that we don't
03:09 - really you know associate with user
03:11 - authentication when we're just trying to
03:13 - implement it
03:14 - for example do we understand cookies in
03:17 - the browser do we understand
03:18 - http headers that allow us to set those
03:20 - cookies
03:21 - do you understand how a json web token
03:24 - works
03:25 - what's in the payload of that json web
03:27 - token and furthermore in the payload
03:29 - of that json web token we're using
03:32 - techniques
03:32 - like hashing algorithms and cryptography
03:35 - these are not simple topics
03:37 - there are universities that have entire
03:39 - curriculums on just cryptography
03:42 - and concepts associated with it so as
03:45 - you can imagine
03:46 - talking through all of these things is
03:48 - going to take some time
03:49 - but i can assure you i'm going to walk
03:51 - you from point a to point b
03:53 - and i'm not going to leave you hanging
03:55 - on any part of this tutorial
03:57 - i genuinely hope that you enjoy it as
03:59 - much as i enjoyed making it
04:01 - and at this point i think we're ready to
04:03 - jump in today we're going to be talking
04:05 - about
04:05 - how you can implement user
04:08 - authentication
04:09 - in your web applications using node.js
04:12 - express.js and passport.js
04:16 - and we're first going to kind of jump
04:18 - into
04:19 - what are your authentication options in
04:22 - general i know that's
04:23 - a question that i had for a long time
04:25 - you know what do we have i hear stuff
04:27 - about jwt
04:29 - username and password and then you've
04:31 - got all this other stuff like
04:32 - oauth and even some custom
04:36 - strategies that you can use to
04:37 - authenticate your users so we'll go
04:40 - through that
04:41 - then we'll talk a little bit about the
04:43 - passport js
04:44 - framework what it is what kind of
04:47 - structure
04:48 - does it use to authenticate users into
04:51 - the apps
04:52 - and then what are some of the different
04:53 - strategies that
04:55 - you can use within it and then finally
04:58 - we'll actually go into the
05:00 - implementation of
05:02 - the passport local strategy in the
05:04 - passport jwt strategy
05:07 - although we'll talk about which
05:09 - strategies we might use in
05:11 - different situations both of these
05:13 - strategies are going to be really good
05:15 - for
05:16 - anyone who is just trying to get their
05:19 - app
05:19 - off the ground and their primary focus
05:23 - is not necessarily on authentication but
05:26 - they actually
05:27 - need authentication to get it off the
05:29 - ground so
05:30 - these are kind of like the the bare
05:32 - bones um
05:34 - most basic way to authenticate users
05:37 - into an application and it's going to be
05:39 - great for
05:40 - you know individuals small teams
05:42 - startups
05:44 - anyone that is building their
05:46 - application from scratch
05:48 - there are a few prerequisites for this
05:51 - tutorial series
05:52 - i've pretty much assumed that you
05:55 - already know the basics of coding
05:58 - within the node.js ecosystem so
06:01 - that means you know you have a pretty
06:03 - good understanding
06:04 - of node.js modules and
06:08 - package.jsons all of that kind of stuff
06:11 - as well as things like the express
06:13 - framework
06:14 - also things like asynchronous
06:16 - programming so promises and callbacks
06:19 - hopefully you're at least a little bit
06:22 - familiar with all of the topics here on
06:24 - the screen
06:25 - if not you can still get through the
06:26 - tutorial but i would highly suggest
06:30 - kind of brushing up on anything that
06:31 - you're not
06:33 - you don't have a very basic
06:34 - understanding of the first thing that i
06:36 - want to cover
06:37 - is what are your authentication
06:40 - options here before we get into any
06:43 - coding it's pretty
06:44 - important to take a look at what's
06:47 - available to us
06:48 - and deciding what is my use case and
06:51 - what's going to be best for that use
06:53 - case
06:54 - so on the screen i've laid out all of
06:57 - the
06:57 - authentication options that you might
06:59 - find
07:00 - if you are in the node.js ecosystem
07:03 - or any other ecosystem for that matter
07:07 - and they are listed from least complex
07:10 - to most complex but that does not mean
07:13 - that the least complex option
07:15 - is the worst option it just means that
07:19 - as you kind of move up that chain it's
07:20 - going to require a little bit
07:22 - more understanding
07:26 - more pieces that you have to understand
07:28 - to implement the strategy itself
07:31 - in the scope of this tutorial series
07:33 - we're just going to be sticking with the
07:35 - left two
07:36 - so the session based authentication
07:39 - aka the passport local strategy and
07:43 - the json web token or jwt
07:46 - authentication or aka the
07:49 - passport jwt strategy now you also have
07:53 - a little bit more complex
07:54 - authentication that you'll see
07:57 - especially if you're trying to use
07:59 - um a large api like maybe the youtube
08:03 - api
08:03 - or any google api um even github's api
08:08 - these big companies rely on oauth
08:11 - it's just a protocol to give
08:14 - different access rights to
08:17 - users trying to access resources within
08:20 - their api
08:21 - so you'll kind of get the
08:25 - gist of what that is as we get into the
08:28 - jwt authentication but
08:31 - i'm going to stay away from completely
08:34 - diving into the oauth
08:37 - although we're not going to actually get
08:39 - into the the coding
08:41 - implementation of solutions like oauth
08:44 - or even
08:45 - custom solutions it's definitely
08:47 - important to at least touch on it
08:50 - so what oauth is all about it's
08:53 - it's just a protocol and i know that can
08:56 - get pretty confusing when you have
08:58 - um software as a service providers such
09:01 - as
09:01 - auth0 and octa among others
09:05 - that actually provide this oauth
09:08 - protocol as a service so you
09:11 - it's really confusing if you look at
09:14 - those companies
09:15 - you know namely one that's named off
09:17 - zero which sounds like a protocol
09:19 - it gets really jumbled in your head like
09:21 - what's the protocol what's the company
09:24 - you know how is all this working so
09:26 - really what oauth what the oauth
09:28 - protocol
09:29 - aims to do is separate out
09:32 - the two components of
09:36 - we'll call user authentication i got to
09:38 - be careful with the terminology here
09:40 - because
09:41 - there's a big difference between
09:43 - authorization
09:45 - and authentication so on the left with
09:48 - the jwts
09:50 - and the local logins the session based
09:53 - authentication that is all about
09:56 - knowing who the user is and that is what
09:59 - we would call
10:00 - authentication now on the other side of
10:03 - things
10:04 - if you have seen things like social
10:06 - logins
10:07 - like sign in with google or sign in with
10:09 - facebook
10:10 - that's a little bit more about
10:13 - authorization
10:14 - so that's kind of it's not as much who
10:17 - who we're
10:18 - talking about but instead who has
10:21 - access to what resources so in other
10:24 - words you'll get into things like
10:25 - scopes you know what does this
10:28 - particular
10:29 - subject or user have
10:32 - authorization to access does it have
10:34 - authorization to make
10:36 - just get requests against the api or
10:39 - does it also have
10:41 - authorization to edit certain resources
10:44 - within the api so as you might guess
10:47 - using the oauth protocol and you'll also
10:50 - hear things like
10:51 - open id connect is closely related
10:55 - that is going to be used with these
10:57 - bigger services
10:58 - where you know maybe one company such as
11:01 - google
11:02 - allows users that have
11:05 - varying authorizations to access the api
11:10 - in the same way so if i or you
11:14 - wanted to access resources from say
11:17 - google's youtube data api so if we
11:20 - wanted to get youtube analytics
11:22 - or something like that we don't have
11:25 - authorization
11:26 - to do certain things within that api
11:30 - and that is defined by the scopes that
11:33 - we
11:34 - are basically provided in our access
11:36 - token
11:37 - that's related to the oauth protocol now
11:40 - i know all that sounds
11:42 - very complex and it's definitely not
11:44 - something
11:45 - that you can even begin to understand
11:49 - completely in just a few minutes but i
11:52 - did want to talk about that
11:53 - um and kind of just mention what it is
11:56 - and why we're not going to
11:57 - get into all the details of it i think
12:00 - we have plenty on our plate
12:02 - with the session based authentication
12:04 - and the jwt based authentication
12:07 - to even start talking about that so
12:10 - those are your options
12:12 - we're going to stick with the two on the
12:13 - left the least complex ones
12:16 - and probably the most common
12:18 - implementations that you'll see
12:20 - for startups and people who are just
12:22 - trying to get their application
12:24 - off the ground and worry about the
12:26 - complex authentication of it a little
12:28 - bit later down the road
12:30 - when they have either more resources
12:32 - more money
12:33 - or both that can actually spend the time
12:36 - to implement something
12:38 - a little bit more complex like the oauth
12:40 - protocol
12:41 - to wrap up this introductory video i
12:44 - wanted to
12:45 - give a brief overview of what the
12:48 - passport.js
12:49 - framework is and the reason being
12:52 - is we're actually going to be
12:55 - implementing
12:56 - two different strategies within the
12:58 - passport framework
12:59 - but that just basically means that we
13:02 - have
13:03 - two different middlewares that are
13:05 - connecting into the bigger
13:07 - passport js middleware so you might ask
13:10 - what is a middleware
13:12 - for those that are not familiar what
13:14 - middlewares are in express
13:16 - or are just a little bit fuzzy on how
13:18 - they work
13:19 - i have created a video that will be
13:21 - included in this playlist so that you
13:23 - can brush up on that
13:24 - and get yourself up to speed but
13:27 - basically
13:28 - all that passport js is is a middleware
13:31 - that integrates within your express.js
13:35 - application and handles all of the
13:38 - authentication logic
13:39 - using the specific strategy that you
13:43 - choose
13:44 - to plug into the passport.js framework
13:48 - now the strategies that are included if
13:50 - we go to
13:51 - passport js
13:55 - we can go to the home page and see that
13:57 - there are plenty of different strategies
13:59 - here
14:00 - so we can do anything from the passport
14:03 - local
14:04 - and passport jwt like we're doing and we
14:07 - can also do something a lot more
14:09 - complex you can see that we have stuff
14:12 - like the passport oauth 2 which is what
14:14 - we just talked about
14:16 - or even you know something more specific
14:20 - passport instagram we can use the
14:22 - instagram login to authenticate our
14:25 - and delegate access to our users
14:28 - so there's a lot of different strategies
14:30 - and all of these strategies have been
14:32 - created by
14:34 - independent developers that basically
14:36 - say okay
14:37 - here's the passport.js framework it's
14:40 - just a middleware
14:41 - and it allows me to kind of use
14:44 - that framework as a starting point and
14:47 - then we can just build in the
14:49 - the specific pieces of authentication
14:53 - in our own middleware which we call a
14:55 - strategy
14:56 - so in summary passport js is just
15:00 - a framework that is a middleware that
15:03 - also
15:03 - allows individual developers to develop
15:06 - other middlewares called strategies that
15:08 - connect in with this bigger
15:10 - middleware that we call the passport.js
15:13 - framework
15:13 - and then all of that gets wrapped up
15:16 - into a bundle
15:17 - and put into your express app and it
15:20 - works seamlessly
15:21 - with your express routes we'll see
15:24 - in a lot more detail how each of these
15:27 - strategies the local
15:28 - and jwt strategy work as we go through
15:31 - the series but it is important to just
15:34 - understand the basics
15:35 - of what this is if i had to sum up the
15:38 - code logic of passport.js in a few
15:42 - sentences
15:43 - it would basically be this so
15:45 - passport.js
15:46 - is a middleware as we just talked about
15:49 - and on every http request
15:52 - that a user calls to our express
15:56 - server the passport framework is going
15:59 - to
15:59 - first pick up okay what strategy are we
16:02 - using here
16:03 - and then it will use that strategy to
16:05 - say
16:06 - hey is that user that just requested
16:08 - that resource
16:09 - authenticated if that user is
16:12 - authenticated
16:13 - then passport is going to let that user
16:17 - access the resource it's going to you
16:18 - know go into the express route
16:20 - if that user is not authenticated based
16:23 - on the strategy we're using
16:25 - then passport is going to return a 401
16:29 - http status which is basically the
16:32 - unauthorized status
16:34 - so that's kind of passport.js in a
16:37 - nutshell again
16:38 - it's going to get a lot easier as we see
16:40 - the actual code flow
16:41 - of what's going on with this middleware
16:44 - congratulations you made it through the
16:46 - first part
16:47 - of this super long tutorial on user
16:49 - authentication
16:50 - now we talked about all the different
16:52 - options here and we're not going to be
16:54 - covering some of those delegated
16:56 - authentication options but there's
16:58 - plenty to cover with the other ones
17:00 - and particularly with the passport local
17:02 - authentication strategy where we're
17:04 - going to be using the express session
17:06 - middleware
17:07 - having a solid understanding of http
17:10 - headers and http cookies is going to be
17:14 - absolutely essential as a web developer
17:17 - you go on a bunch of different sites and
17:18 - you click that accept button when they
17:20 - say
17:21 - you know we use cookies on this website
17:23 - but you actually
17:24 - know what that means i think you're
17:26 - going to find this section
17:27 - interesting but let's go ahead and dive
17:30 - in what
17:31 - is an http header i think it's something
17:34 - that we
17:35 - know in the back of our heads kind of
17:37 - what it is
17:38 - especially if we program a lot of web
17:40 - apps but
17:41 - it's also something that we don't spend
17:44 - a lot of time
17:45 - trying to learn and we frankly don't
17:48 - need to learn
17:49 - a whole lot about them that said we do
17:52 - need to specifically learn
17:54 - about an http header called the set
17:57 - cookie
17:58 - and the cookie header in order to
18:00 - understand how
18:01 - server-side sessions work and kind of
18:04 - interact with the browser
18:06 - so if we come to google.com right here
18:10 - i always use this as an example just
18:12 - because it's pretty arbitrary spot
18:14 - if you open up your developer
18:17 - console here in google chrome and go to
18:21 - the network tab
18:22 - you'll see that it is pretty much empty
18:24 - right now but if we click refresh
18:27 - on the google search and we're basically
18:30 - doing a get request
18:31 - to google.com and you'll see a bunch of
18:34 - stuff loading a lot of these are the
18:36 - resources that run the page
18:38 - or scripts but at the top you see this
18:42 - www.google.com if we click on this
18:45 - you'll see that there are some headers
18:48 - here
18:49 - and you'll see that the headers come in
18:51 - three basic categories
18:53 - first you have the general headers then
18:56 - you have the response headers
18:58 - and finally the request headers
19:01 - what we're specifically interested in
19:04 - in this case to understand what a cookie
19:07 - is and how it works
19:08 - is the request and the response headers
19:12 - but we can also kind of explore the rest
19:16 - you can go on to mdn is a great place to
19:19 - look and you can see there's
19:21 - you know a link to all sorts of
19:23 - different headers
19:24 - so we can go down here into security
19:28 - and these are all the different security
19:30 - headers that you could set
19:31 - in either the general response or
19:34 - request
19:35 - headers now let's take a step back and
19:37 - really think about what just happened
19:39 - when we pressed the refresh button
19:41 - in our browser to load google.com
19:44 - if you think about it a http client
19:48 - could be
19:48 - anything from an iot device
19:52 - someone like me sitting at my desk or at
19:55 - a coffee shop
19:57 - you could think of it as just a laptop
19:59 - or a phone
20:00 - pretty much anything that connects to
20:02 - the internet is considered
20:04 - an http client now on the other side of
20:08 - things
20:08 - is all of the http servers and those
20:12 - servers
20:13 - google in this case is going to house
20:15 - the information
20:17 - that the clients want to access or
20:20 - update or do other operations on
20:23 - so in our case what we did was do
20:26 - a get request to google.com in other
20:29 - words we want the resources
20:32 - at that web page so if you look at the
20:34 - headers here
20:35 - in the chrome tools you'll see
20:39 - as we talked about we have these three
20:40 - categories so let's just go ahead and
20:43 - walk through each of them
20:44 - and see what was relevant to our request
20:47 - so in the the first one the general
20:50 - headers
20:51 - these can be either request or response
20:54 - related
20:55 - they're just kind of general metadata
20:57 - about the request
20:59 - such as what is the url that we're
21:01 - requesting
21:03 - what type of method are we using so this
21:05 - is a get request
21:07 - those were both probably those are in
21:09 - the request
21:11 - side of things now if we go to the
21:13 - response side of things
21:14 - you'll see that we got a status code of
21:16 - 200
21:17 - which means that we requested data from
21:20 - google
21:21 - and it sent back the data successfully
21:24 - so you can see that we have several you
21:27 - know
21:27 - things that kind of mix between the
21:29 - request and response
21:31 - now in our particular situation when we
21:34 - searched google
21:35 - we formed or we didn't form but the
21:39 - browser that we were using
21:41 - created a request header which is
21:44 - basically
21:44 - instructions for the server in
21:48 - what data you know the request wants so
21:51 - i'm the client here sitting at my
21:53 - computer so the the browser on my behalf
21:56 - is going to say
21:57 - hey whoever i'm trying to get these
22:00 - resources from
22:01 - i'm going to put in the request headers
22:04 - what kind of data i
22:06 - accept so you can see that we have
22:08 - things like the accept
22:10 - encoding except language and then just
22:12 - the accept
22:13 - http header and we're basically saying
22:16 - that we
22:16 - accept html we
22:20 - accept xml and a couple other different
22:23 - options
22:23 - but you can just think of this request
22:25 - header as the instructions for
22:28 - the server that you're requesting
22:29 - resources from or
22:31 - trying to modify what type of data that
22:34 - the client
22:34 - myself will accept in the browser is not
22:38 - the only thing that you can put in this
22:39 - request header
22:41 - you can put all sorts of other things
22:43 - you see there's a cookie in here we'll
22:45 - talk about that in a few minutes
22:47 - but you also have things like the user
22:49 - agent tells us what browser is
22:51 - requesting this data
22:53 - and then if again you can go to the mdn
22:56 - site
22:57 - and look at a broad variety of different
23:00 - things that you could put
23:01 - in the request header so you can click
23:04 - on the request
23:04 - context and you can kind of see some of
23:08 - the things that you can put in that
23:10 - so we know that http headers are
23:12 - basically
23:13 - metadata about our our http
23:17 - request so we can also do that
23:20 - on the response which would be set by
23:23 - the server
23:23 - which in this case is google so one of
23:26 - google's servers whichever
23:28 - gave us the content that we're viewing
23:30 - on the web right now
23:31 - is going to set these response headers
23:34 - and these response headers are going to
23:36 - give
23:36 - additional instructions to the client
23:39 - that requested the data in the first
23:41 - place
23:42 - so you can go through a couple of these
23:44 - and see
23:46 - you can see the content type so if you
23:48 - remember in the request header
23:50 - our you know the client which is the
23:52 - browser i'm sitting in
23:53 - and using right now said i only accept a
23:57 - certain type of data
23:58 - and then the response is going to say
24:01 - okay you only accept that type of data
24:03 - here's the data and here is what type it
24:06 - is
24:07 - so this is useful if you know we're
24:10 - trying to figure out how to display that
24:12 - data in the browser
24:13 - of course there are other things that
24:15 - that you'll see here but
24:16 - i want to direct your attention to
24:18 - something very relevant to what we're
24:20 - talking about right now
24:21 - which is the set cookie header
24:24 - now you can see that the set cookie
24:27 - header is basically giving
24:28 - key value pairs and you can see
24:32 - you know right here it says expires
24:34 - equals friday the 31st of january 2020
24:38 - at this specific time so you might be
24:42 - asking
24:42 - well there's a cookie header in the
24:45 - request
24:46 - object and there was a cookie header in
24:48 - the response
24:49 - object how can that be what is the
24:52 - difference between the two and how do
24:53 - they work
24:54 - over the next few minutes i'm going to
24:56 - walk you through exactly how
24:58 - the set cookie and the cookie headers
25:01 - kind of work together
25:03 - and then in another video we'll actually
25:05 - talk about how this all plays
25:07 - into what we call a server-side session
25:10 - the easiest way to understand what a
25:12 - cookie is and how it works
25:14 - is to remember that http protocol
25:18 - is a stateless protocol in other words
25:21 - it's going to constantly forget what the
25:24 - user has done
25:26 - on the site unless we have a way to
25:28 - remember that
25:29 - so in other words if we go to google
25:32 - let's just imagine the scenario
25:34 - we go to google and we sign in to google
25:38 - and we'll just assume they actually
25:40 - probably don't use this method but
25:43 - we'll just assume that they're using
25:45 - cookies and server side sessions to
25:48 - authenticate us
25:50 - so what happens is google the server
25:54 - is going to say okay the client that
25:57 - just
25:58 - you know signed in gave us valid
26:00 - credentials
26:02 - and so what we want to do is you know
26:05 - send
26:05 - something back that allows the browser
26:08 - to remember that this user has logged in
26:11 - if we don't have anything like cookies
26:14 - or
26:14 - local storage probably more modern way
26:17 - to do it
26:18 - if we don't have these types of
26:20 - persistent storage
26:22 - then every time we refresh the page
26:25 - our the state that we had previously
26:28 - where google said okay
26:30 - we logged you in is going to have to be
26:32 - redone
26:33 - so every time you refresh the page
26:36 - you're going to have to enter your login
26:38 - credentials which of course is a
26:40 - terrible user experience
26:42 - and any site that does that is going to
26:44 - lose their users immediately because
26:46 - they're going to get
26:47 - completely tired of typing in their
26:49 - login credentials so this is where the
26:51 - set cookie and cookie headers come in
26:55 - so let's do a little experiment here and
26:57 - i know this is not a perfect example but
27:00 - i think
27:00 - it will do for what we're trying to
27:03 - accomplish here so let's click on the
27:05 - application
27:07 - and open up cookies for google you'll
27:10 - see that there's all sorts of cookies
27:12 - you know google knows everything about
27:14 - everyone so
27:16 - we can just go ahead and delete these it
27:18 - doesn't hurt anything to delete all
27:20 - these cookies
27:22 - so at the moment our browser has no
27:25 - cookie set
27:26 - whatsoever so we can come back to the
27:30 - network tab
27:32 - and let's go ahead and refresh the page
27:34 - once more
27:38 - you'll see that we had this google.com
27:40 - here and we can open up the response
27:43 - and request headers and you'll see that
27:46 - the request headers it's pretty much
27:48 - the same as what we had looked at before
27:50 - and then in the response headers
27:52 - we once again have these set cookie
27:55 - headers
27:56 - and what these are doing is basically
27:58 - saying
27:59 - okay or the the google server is saying
28:02 - okay client i want to set this
28:05 - information
28:06 - about you so we'll just assume maybe we
28:08 - just logged in
28:10 - and google wants to tell the browser
28:13 - that
28:14 - i the client is logged in and we don't
28:16 - need to
28:17 - re-authenticate every single time that
28:19 - we've refreshed the page
28:21 - so what happens here is we have these
28:24 - set cookie
28:25 - headers and let's just pick a very
28:27 - specific
28:29 - key value pair here just to see what's
28:32 - actually happening
28:33 - so let's get a pretty easy one
28:36 - we'll just say the 1p jar
28:40 - it gives us a date of 2020 1-21
28:45 - i'm not exactly sure what that means but
28:48 - keep this in mind this is what we're
28:50 - going to be looking for
28:52 - so if you go to the application
28:56 - you'll see that now these are set
28:59 - in the cookies field so we have the 1p
29:01 - jar and then the value that was set
29:04 - in this response header
29:08 - so now what our browser will do
29:11 - is it says okay now we have a cookie set
29:14 - so
29:14 - every request that we make within this
29:17 - domain
29:18 - so google.com i want to attach
29:21 - those cookies that were set based on
29:24 - this set
29:24 - cookie http header in the response
29:27 - header
29:28 - so what's going to happen is when we
29:31 - press
29:32 - refresh again it's going to actually put
29:35 - these cookies in the request headers
29:39 - so right here in this cookie request
29:42 - header we should see
29:43 - something like these set cookies that
29:46 - google
29:46 - the server had put into our browser so
29:49 - let's click refresh
29:50 - once more go to thegoogle.com
29:54 - and look at the request headers and you
29:56 - can see that now this
29:58 - cookie header right here has that 1p
30:01 - underscore jar cookie key
30:04 - value pair so just to recap what just
30:07 - happened
30:08 - we had a client me refreshing or
30:13 - doing a get request against google.com
30:16 - and whatever google server that gave me
30:19 - that data
30:20 - said i want to set a cookie
30:24 - in this client's browser so it uses the
30:27 - response header to do that
30:29 - it assigns these values in the set
30:32 - cookie
30:33 - header and then when we reload the page
30:37 - our google chrome browser or any browser
30:40 - for that matter
30:41 - is going to say okay my default behavior
30:43 - is this
30:44 - is to look up what cookies are currently
30:47 - set in my browser
30:48 - and i'm going to attach those cookies to
30:50 - every single request
30:52 - for the domain context that it is
30:55 - applicable to which is google.com in
30:58 - this matter
30:59 - if you really think about it this method
31:02 - of setting
31:03 - and then the browser just attaching the
31:05 - cookie to each request
31:07 - is a really powerful thing when it comes
31:10 - to user authentication
31:12 - you could say hey maybe my server can do
31:15 - some sort of logic
31:16 - and say okay is that user valid
31:19 - invalid did they give me the right
31:21 - password if they authenticated correctly
31:24 - then i do the set cookie header
31:28 - in the response object and then now the
31:30 - user or the client
31:32 - that is using my web application
31:36 - now has that cookie that says yes this
31:39 - user has already been authenticated and
31:42 - then the browser every time it reloads
31:45 - will
31:45 - attach that cookie and you don't have to
31:47 - re-log in that user
31:49 - now the real question is how long do we
31:52 - keep that user logged in
31:55 - and that's a totally arbitrary question
31:57 - but we can do that with the expires
32:00 - piece
32:00 - of this set cookie http header
32:04 - if we come over to the network tab
32:07 - and look at the response headers from
32:09 - google
32:10 - you'll see that there's the cookie
32:13 - that's being set
32:14 - so 1p jar it looks like this is actually
32:17 - set on every
32:18 - get request to google but you'll notice
32:21 - that it has an expires piece to it
32:24 - so this is what tells the browser how
32:28 - long to store that cookie key value pair
32:31 - within the the client so we can actually
32:35 - go through this
32:36 - exercise on our own using some simple
32:38 - javascript
32:39 - to see exactly how it's working so let's
32:42 - go to the console
32:43 - and type in a few quick commands so
32:46 - first we're going to create a new date
32:49 - which is going to represent the date and
32:50 - time
32:51 - right when i click enter so we'll say
32:54 - enter and then we're going to say
32:57 - we want to set the time 20 seconds later
33:00 - so let's do that and then finally let's
33:03 - set
33:03 - a cookie to the browser with the an
33:05 - expires header
33:07 - at that time so we really only have a
33:09 - few seconds
33:11 - but you can see that we have a custom
33:13 - cookie
33:14 - that's going to be there for about 20
33:15 - seconds so if we reload right now
33:18 - it shows that it's gone so let's go
33:20 - ahead and do that one more time
33:22 - a little bit quicker this time so here's
33:26 - our cookie
33:26 - go over to application you'll see that
33:29 - we have the custom cookie
33:30 - and every time we refresh the browser
33:33 - you're going to see that cookie is going
33:34 - to stay there
33:36 - but then in about 20 seconds which is
33:38 - coming up here in a few seconds i think
33:41 - you'll see that that cookie actually
33:43 - will drop off
33:45 - and it will no longer be attached to the
33:47 - http request
33:49 - so if we refresh you'll see it's gone
33:52 - and
33:52 - that user will say that that was a
33:55 - cookie that
33:56 - gave a user or the client's
33:58 - authentication status
34:00 - that's gone the user has to re-login now
34:03 - obviously you're not going to set
34:05 - a cookie to last for 20 seconds you
34:07 - might more realistically say
34:09 - that you want the cookie to last for two
34:11 - weeks
34:12 - and that is a really powerful way to
34:15 - keep some sort of persistent state
34:18 - within the browser
34:19 - and not require users to log in
34:22 - every time they refresh the page the
34:25 - next part
34:26 - of this tutorial is all about express
34:28 - middleware
34:29 - in order for us to implement the
34:31 - passport local strategy which
34:34 - utilizes express session we're going to
34:37 - have to understand middleware and that's
34:38 - because both passport.js
34:41 - and express session are both middlewares
34:43 - if you don't understand this concept
34:45 - really well
34:46 - then both of those libraries are going
34:48 - to be confusing to you
34:49 - furthermore i'd consider this one of the
34:52 - most essential topics of programming in
34:54 - the express framework while the official
34:56 - express documentation
34:58 - does cover express middlewares in some
35:01 - capacity and it's relatively clear
35:03 - when i was a beginner i'd never
35:05 - understood it fully
35:06 - and even to the point you know two years
35:09 - into my programming journey
35:11 - i still did not have a solid grasp on
35:14 - this express middleware
35:15 - after learning it in depth for the first
35:17 - time i can really
35:18 - confidently say that this is going to be
35:21 - one of the most important lessons that
35:23 - you learn
35:24 - you know as a node.js developer using
35:26 - that express framework
35:27 - so without further ado let's dive into
35:29 - this express middleware
35:31 - overview when you start out using
35:34 - express.js as a framework
35:36 - it's an entirely middleware based
35:39 - framework but
35:40 - generally when you first learn it you're
35:43 - just copying
35:44 - in you know the different pieces and you
35:46 - know that there's
35:47 - kind of something working behind the
35:49 - scenes but you don't know exactly how
35:51 - it's working
35:52 - so in this video we're going to talk
35:54 - about how exactly does this middleware
35:57 - work
35:58 - and how does the request response and
36:01 - next or callback object as well as even
36:05 - the air object work in express
36:08 - application in order to do this we need
36:11 - to
36:12 - spin up a really quick basic application
36:16 - um what i'm working in here again this
36:18 - is part of the passport.js series so i'm
36:21 - in the repository that we're using for
36:23 - that
36:24 - but don't worry this is just a basic
36:27 - express app
36:28 - so we first need to require in
36:31 - express i've already installed this with
36:35 - npm
36:36 - so i don't need to do that and then we
36:39 - say
36:40 - app equals express and then we just say
36:44 - app.listen on port 3000
36:48 - so right there is the most basic form
36:51 - of an express server that you can spin
36:54 - up
36:54 - and if we were to visit localhost 3000
36:59 - we're not going to get anything
37:00 - but if we just throw in one simple route
37:03 - app.get
37:05 - and then we pass in the request
37:08 - response and next objects
37:12 - and then we send some sort of data
37:21 - we can now run this in the browser so
37:24 - let's
37:24 - use nodemon which is going to
37:26 - automatically update
37:28 - on every time i save and we'll run
37:31 - app.js
37:33 - so we're running app.js it's listening
37:36 - on
37:36 - port 3000 and it'll be listening on
37:39 - localhost
37:40 - so if we go to the browser and visit
37:42 - localhost 3000
37:44 - port 3000 you should see the hello world
37:48 - so we have a basic server running and
37:51 - that's all we need to do to start
37:53 - understanding how middleware works
37:55 - in express so we come back to the code
37:58 - here
37:59 - and the first thing that you need to
38:00 - understand is
38:02 - this right here so with our app.get
38:06 - this is just a route that we've
38:09 - established in our express
38:10 - application we are passing in
38:13 - a route string and a callback function
38:17 - usually you'll see it in this syntax but
38:20 - to better understand it we can just
38:23 - basically write
38:24 - a function where we say request
38:28 - response and next now to make this even
38:31 - more
38:32 - transparent what i'm going to do is name
38:34 - these
38:35 - custom properties so
38:38 - normally you're going to just see it r r
38:40 - e q
38:41 - r e s for request and response and then
38:44 - next
38:45 - but you don't need to call them that
38:46 - it's just always going to be passed in
38:48 - you can call them whatever you want so
38:51 - we can say request
38:52 - object response
38:56 - object and callback function
39:01 - so well actually we probably shouldn't
39:03 - call it the callback function
39:06 - we should say maybe next
39:10 - middleware or something like that
39:12 - because the purpose of
39:14 - this last parameter is if we call it as
39:17 - a function it will pass it to the next
39:19 - middleware in the chain
39:21 - so we'll understand that a little bit
39:23 - better in a second
39:24 - but first let's go ahead and write our
39:26 - function so we need to give it a
39:28 - function name so we'll just say
39:31 - standard express callback
39:35 - and we pass in these three parameters
39:38 - and then we can say res.send
39:42 - and hello world
39:49 - so basically we've got the same exact
39:51 - thing that we had below
39:53 - in the app.git route to implement this
39:56 - let's just delete what we
39:57 - wrote here and let's just pass in
40:01 - our standard express callback so we've
40:04 - defined it up here
40:06 - we know that express as a framework is
40:09 - going to pass
40:10 - in these three parameters
40:13 - and so there we can just throw it into
40:15 - our route
40:16 - and click save and then if we come to
40:19 - the browser again
40:21 - if we refresh the page it's going to say
40:24 - res is not defined and the reason being
40:26 - is because i
40:28 - was dumb and forgot to update that so
40:31 - now that we're passing in request and
40:33 - response object we obviously need to
40:36 - also use that in the body of the
40:38 - function
40:40 - so that was just a silly mistake but now
40:43 - if we come to the browser and do it
40:45 - again
40:45 - we should get hello world as we expected
40:49 - so that's the most basic way that an
40:51 - express route works
40:53 - and we're using this function that we
40:56 - had defined
40:58 - so just like we could define this
41:00 - function
41:01 - we can also define other functions which
41:03 - we call
41:04 - middleware so the way that we do that
41:07 - is pretty simple we'll just say
41:10 - middleware one and
41:14 - what we need to do is pass in those same
41:17 - three objects
41:19 - that we were using before so the request
41:21 - object response object
41:22 - in next middleware or whatever you want
41:25 - to call them
41:26 - in this case i'll just say record req
41:29 - res and next like you would normally see
41:32 - it
41:33 - and then we can do whatever we want in
41:36 - this middleware
41:37 - so maybe we'll just say console.log
41:40 - i am a middleware
41:44 - and then in this one this is the
41:47 - standard express callback
41:48 - this is where we return some data we can
41:51 - say console.log
41:54 - i am the standard express
41:58 - function so
42:01 - if we just define that function up here
42:03 - and we don't do anything with it
42:05 - it's not going to do anything obviously
42:07 - but we can pass that
42:09 - into our route to make it work
42:12 - for us so let's pass in the middleware
42:14 - one
42:15 - and a comma so you can see that
42:18 - express as a framework allows you to
42:21 - pass in pretty much as many parameters
42:23 - to the different route functions as you
42:26 - want
42:28 - let's go ahead and save this real quick
42:30 - um let me open up the terminal a little
42:32 - bit more so that we can
42:34 - see what's going on and let's go to the
42:37 - browser
42:38 - and visit that same route we'll go ahead
42:40 - and click refresh here
42:42 - and you're gonna see that this is gonna
42:44 - just keep loading
42:46 - it's not gonna ever return us data and
42:49 - if we were to
42:50 - you know copy this into a new tab and
42:53 - click enter
42:54 - it's not gonna actually return us
42:56 - anything and that
42:58 - brings up a very good point with express
43:00 - middleware
43:01 - if we come back to our code that we
43:04 - wrote
43:04 - you'll notice that in this middleware
43:07 - that we passed into
43:09 - our route that we were visiting
43:12 - we haven't actually called this next
43:15 - parameter
43:16 - so in the express framework the next
43:19 - parameter is going to be
43:21 - actually a function and all we have
43:24 - to do is call it at the bottom
43:27 - of our middleware and what that's going
43:29 - to do is it's going to say
43:32 - for this route right here we first run
43:35 - middleware middleware number one or
43:38 - middleware one and in middleware one
43:41 - we call the next function that was
43:44 - passed in as a parameter by default by
43:46 - express and when we call that it's going
43:49 - to basically say
43:50 - okay now we get to go to the next
43:53 - middleware or
43:54 - in this case it's the last one it's the
43:56 - standard express
43:58 - callback so if we don't put that
44:02 - next function and call it it's never
44:04 - going to get to this
44:05 - last function and we're not going to
44:08 - ever return
44:09 - any data so now that we've called this
44:12 - next function
44:13 - we should be able to go back to the
44:15 - browser
44:16 - and see a response so if we refresh
44:21 - we'll see that it should return hello
44:24 - world
44:25 - and you see that it did return it and if
44:28 - we come back to
44:29 - our code again you'll see in the console
44:32 - that we printed i actually ran this
44:34 - route twice so we printed i am a
44:37 - middleware and then i am the standard
44:39 - express function
44:40 - and the order of this is very important
44:43 - because
44:44 - first in the route we run this
44:47 - middleware
44:48 - and then we run the standard express
44:50 - callback
44:51 - so first we're going to console.log i am
44:54 - a middleware
44:54 - second we're going to console.log i am
44:56 - an express function
44:58 - so that is the basics of how this
45:00 - middleware works
45:02 - but we also have a few other things to
45:04 - understand
45:05 - so what we've been using so far by
45:08 - passing the middleware
45:09 - into the route itself is a route
45:11 - specific middleware
45:13 - now this is kind of i just think of it
45:16 - this way i don't know if it's the exact
45:17 - term that you would use
45:19 - but i call this a route specific
45:21 - middleware but you also can have
45:23 - global middleware so if i took this out
45:26 - of the route
45:28 - and i came up to the top right under the
45:31 - definition for the app
45:33 - and i say app.use
45:36 - what this function built into express
45:39 - expects
45:40 - is a function or a middleware that it
45:43 - can execute
45:44 - so in this case i'm going to just take
45:47 - middleware number one or middleware one
45:50 - and say app.use middleware1
45:54 - so what's going to happen is the express
45:57 - app
45:57 - is going to initialize and then
46:00 - it's going to initialize the middleware
46:03 - one
46:03 - so let's go ahead and see what happens
46:06 - in the console
46:07 - when we do this so i'll let me make sure
46:10 - i got this right so we've got
46:12 - our middleware defined here we call next
46:14 - and we're
46:15 - initializing it with the app.use up here
46:18 - so let's save that
46:20 - and you'll see that nothing has happened
46:23 - in the console yet
46:24 - you might expect since we did this
46:26 - outside of a route
46:28 - that it would just automatically print i
46:31 - am a middleware
46:32 - and go to the next something but that's
46:35 - not the case when we
46:36 - say app.use it's basically just
46:40 - adding a piece to that chain of
46:44 - functions or middlewares that we're
46:45 - going to be calling
46:47 - so once again we have to come back to
46:49 - google chrome
46:51 - and execute this git route so let's
46:54 - enter and so it loads correctly and then
46:57 - if we come back to the code again
46:59 - now you're going to see i am a
47:01 - middleware and i am the standard express
47:03 - function
47:04 - so what just happened here well first
47:07 - off
47:08 - we defined that this is the first
47:10 - middleware that we want to use
47:12 - in all of our routes it's not just
47:15 - specific to
47:16 - this particular route it's going to
47:18 - happen in any route that we define
47:20 - within our application
47:22 - next we have the standard express
47:25 - callback
47:26 - which is in this specific route so first
47:29 - the route's going to call middleware 1
47:31 - then it's going to com
47:32 - call whatever we had defined as the
47:34 - callback to that route
47:36 - so the order of the middleware that we
47:39 - define
47:40 - in the scope whether it's a global or a
47:42 - route specific middleware
47:44 - really matters so let's go ahead and see
47:46 - what happens if we switch up the order
47:49 - of the middleware and maybe even add
47:51 - another middleware into
47:53 - this equation so let's say we have
47:56 - another middleware called middleware
47:58 - 2 and again we pass in the default
48:02 - objects that we are provided by
48:06 - or provided with by the express
48:08 - framework
48:09 - and we'll say console.log
48:12 - i am middleware number two
48:17 - and maybe we should just update this one
48:19 - up here
48:22 - to number one so we've got middleware
48:24 - number one and middleware number two
48:27 - and what i'm going to do is say app.use
48:31 - middleware to okay
48:34 - so we are using two middlewares and then
48:37 - we have the standard express callback
48:39 - which at this point i'm just going to go
48:41 - ahead and put it
48:42 - in a form that we're used to seeing
48:45 - so we'll just use request res and next
48:49 - this is what you'll see in most
48:50 - tutorials so i want to keep it
48:51 - consistent
48:53 - so let's copy that in there delete the
48:56 - function declaration
48:57 - and then of course since we changed the
48:59 - name of the parameter we need to also
49:02 - change the name of the object that we're
49:05 - using to send the data
49:07 - all right so let's just quickly recap
49:09 - what we got
49:10 - we have one route in our application
49:13 - which has a very standard syntax
49:15 - all we're doing is we're sending back an
49:17 - h1 tag with hello world in it
49:20 - so far in this route we haven't defined
49:22 - any route specific middleware
49:24 - but we have defined global middleware
49:28 - so let's see what happens go ahead and
49:30 - kind of make your guess as to what's
49:32 - going to happen here
49:34 - but if i had to guess we're probably
49:36 - going to print
49:37 - i middleware number one and then i am
49:40 - middleware number two
49:41 - when we call that route and then finally
49:44 - we'll
49:44 - you know console.log i am the standard
49:46 - express function
49:48 - all right so we've saved it let's go
49:50 - back to the browser
49:53 - click refresh
49:56 - and i don't know why it hangs sometimes
49:58 - here
49:59 - try it again maybe we have some sort of
50:01 - air did a little bit of refactoring
50:04 - nope it was doing just fine we've got
50:08 - all the things that we expected so if
50:10 - you could guess what's actually
50:11 - happening here
50:13 - is again we forgot to call the next
50:15 - function
50:16 - in the middleware 2 so it never reached
50:18 - this final function
50:20 - save it once more come to the browser
50:24 - once more and refresh we should get a
50:26 - good response
50:27 - come back to the code and you'll see i
50:31 - am middleware number one
50:32 - i am middleware number two and i am the
50:35 - standard express function
50:37 - all right so everything is as expected
50:40 - and now
50:41 - is where the real you know understanding
50:43 - comes into play
50:45 - because oftentimes when we're using an
50:47 - express application
50:49 - we've got all sorts of middleware
50:51 - working together in most
50:52 - express applications you're going to
50:54 - have several
50:55 - app.use statements so you might say
50:58 - app.use course cross-origin resource
51:02 - sharing
51:03 - that's a pretty common one or app.use
51:06 - body parser and then whatever the
51:09 - configuration for that was
51:11 - so you might have up to like 10 15 even
51:14 - 20 different
51:15 - middlewares that you are adding to your
51:18 - express application
51:19 - and so it's really important to
51:21 - understand that the order
51:23 - that we put these in matters so if we
51:27 - were to put middleware 1 after
51:30 - middleware 2 all we did was change the
51:33 - order of those statements
51:34 - if we save and then go to the browser
51:37 - and
51:38 - call that route you're going to notice
51:40 - that when we come back to the code
51:42 - we now have things out of order so we
51:44 - have i am middleware number two coming
51:47 - before
51:47 - number one so that's really important to
51:50 - understand
51:51 - and then of course if you put one of
51:54 - these within the route itself
51:56 - it affects the order as well so let's
51:59 - add one more middleware to this equation
52:02 - and it's just let's just copy this do
52:04 - the same thing
52:06 - so we'll call this one number three
52:10 - number three right there and then we're
52:13 - gonna take middleware number three
52:16 - and put it in the route itself so let's
52:19 - copy it right there
52:21 - give it a comma and now what's going to
52:23 - happen
52:24 - is we should have middleware 2 called
52:26 - first
52:27 - then middleware 1 then it goes into the
52:29 - route specific middleware
52:31 - so then we have middleware three and
52:33 - then finally this last function which
52:36 - we technically could call middleware as
52:38 - well
52:39 - so let's see if that worked we should
52:41 - have
52:42 - middleware two one then three
52:45 - so let's go to the browser
52:48 - run the route come back to our code
52:52 - and you see that we have two one and
52:56 - three exactly how we defined it two
52:59 - 1 and then the route specific middleware
53:02 - there are two more things that i want to
53:04 - talk about when
53:06 - covering the topic of express middleware
53:09 - and one of those is air handling because
53:13 - an air handler in express is also just
53:16 - another middleware
53:17 - but it's actually a special type of
53:19 - middleware
53:21 - so in order to define an air handling
53:24 - middleware what we have to do is define
53:26 - a function with a fourth
53:28 - parameter so let's go ahead and define a
53:31 - function
53:32 - called air handler
53:36 - and you'll see that in this app i've
53:38 - kind of simplified it a little bit so we
53:40 - only have one middleware we got rid of
53:42 - all the rest of the stuff
53:44 - but this time we're going to pass in an
53:46 - error
53:47 - parameter then the request res and next
53:52 - parameters so this is how we define
53:55 - an error handling function and we can
53:58 - you know this is basically a middleware
54:00 - so we can do as many error handlers as
54:02 - we want
54:03 - so if we wanted to catch specific types
54:06 - of errors
54:06 - so we say if air dot
54:10 - status equals something then
54:13 - we want to you know handle it in this
54:16 - one and then we could come down and
54:18 - do another error handler and say this is
54:21 - error handler number two and if error
54:25 - air dot status is number two number one
54:28 - you kind of get the point we can define
54:30 - as many of these as we want
54:32 - and handle different types of errors
54:34 - depending on the application that we're
54:36 - doing
54:37 - but what is going to happen here is
54:40 - this error parameter will be populated
54:42 - with an error if it exists
54:44 - so what we can do is we can say
54:48 - something like
54:49 - [Music]
54:51 - maybe instead of throwing the air
54:53 - explicitly we'll say
54:54 - if there's an error what we can do is
54:57 - res.send
54:59 - and we can say there was
55:02 - an error please try again
55:06 - so something more friendly than a
55:08 - default error that you would
55:10 - you might get in the browser that would
55:11 - crash the entire application
55:14 - so let's go ahead and comment this out
55:16 - for one second and see what happens
55:19 - if we don't have an air handler so right
55:22 - now we don't have an air handler
55:24 - and maybe in this middleware up here
55:28 - instead of console logging i'm a
55:32 - middleware and continuing to the next
55:35 - we can say that we have an air object
55:38 - which is a new node.js air so
55:41 - i am an air and what we can do with this
55:45 - is we can pass it
55:46 - in the next function
55:49 - so normally we just call next and it
55:52 - goes to the next middleware
55:54 - this case we're going to actually pass
55:55 - the air object so this would be
55:58 - common you know this would be more
56:00 - common in a scenario where maybe our
56:02 - middleware was doing something complex
56:05 - we were making a database call and we
56:07 - were just
56:08 - catching any errors that happened with
56:10 - the database
56:11 - something that we cannot control so we
56:14 - always want to catch these
56:16 - errors and if we do catch them we want
56:18 - to pass them in the next
56:19 - function so when we do that
56:23 - we're going to go back to the browser
56:25 - real quick
56:27 - and if we refresh this it's going to say
56:30 - i am an heir
56:31 - and you're going to get the entire stack
56:33 - trace which
56:35 - you don't want because this is where the
56:38 - users will see
56:39 - what's going on and you obviously don't
56:41 - want to send
56:42 - this type of error to a user you want to
56:45 - handle it in a more graceful way
56:47 - and not to mention if we do it like this
56:51 - you can see down in the console or in
56:54 - the terminal
56:54 - that we've crashed our application so if
56:57 - this is running
56:58 - out on a server somewhere and we don't
57:00 - know that this has happened
57:02 - our application could be down for hours
57:04 - without us even knowing
57:06 - so it's really really important that we
57:08 - use an error handler in our express
57:10 - application
57:12 - to catch these errors and handle them
57:14 - gracefully without crashing
57:16 - the express application so again
57:20 - air handler just another middleware with
57:22 - one extra parameter
57:24 - so let's uncomment this air handler
57:27 - function
57:28 - and normally you'd set this up a little
57:31 - bit
57:31 - more complex than what i've done but
57:35 - we'll just go with this for now just to
57:36 - demonstrate the point
57:38 - so we've got the error handler and so
57:40 - now we're going to say
57:42 - app.use air handler
57:45 - now we'll go to the browser again we'll
57:48 - refresh
57:50 - and now we're getting a more friendly
57:52 - error message
57:54 - now that we've defined this error
57:56 - handler let's go ahead
57:57 - and put it in as a middleware so let's
58:00 - just say
58:00 - app.use air handler
58:04 - and click save now let's come back to
58:07 - the browser
58:08 - real quick and refresh
58:11 - you're going to see this dreaded error
58:14 - message in the browser
58:16 - you're going to ask yourself why we
58:18 - defined our
58:19 - air handling middleware so we should
58:22 - have a friendly message here
58:25 - well what's happening is we have done
58:27 - this out of order
58:29 - and like i said earlier in this video
58:31 - the order that you put
58:32 - express middleware in matters and in
58:35 - this case
58:36 - we need to throw our air handler at the
58:39 - very
58:40 - end of our app so after all of our
58:43 - routes and all of our middleware
58:45 - we need to put our air handler and the
58:47 - reason being
58:48 - is because if there is an air in any of
58:52 - our middlewares
58:52 - or our routes which are basically just
58:55 - middlewares
58:56 - then the air is going to be passed
58:58 - directly to
59:00 - the final air handler so
59:03 - in this case we have the air happening
59:06 - up in our first
59:07 - middleware so what's going to happen
59:09 - when we say
59:10 - next and then air express is going to
59:13 - pick up on this and say
59:14 - oh there's an error let's send it past
59:17 - you know let's skip the route here
59:19 - we don't need to go into this we need to
59:21 - just go straight to the air handler
59:24 - and handle it appropriately so this is
59:27 - kind of how
59:28 - express middleware works and
59:31 - you can see that this will more
59:33 - gracefully
59:34 - handle the air if we come back to the
59:36 - browser and refresh
59:38 - now we're getting a much used more
59:40 - user-friendly message
59:42 - in many cases you might do something
59:45 - instead of
59:46 - actually sending data like this we could
59:48 - just say
59:49 - res.json and then we could say
59:52 - air and then our front end
59:56 - application could handle this error on
59:59 - the front end rather than
60:00 - you know the server handling it alright
60:03 - so we have covered how to handle
60:05 - errors using air handling middleware and
60:08 - finally the last thing that i think is
60:10 - important to cover when it comes to
60:12 - express middleware
60:13 - is the fact that we can actually mutate
60:16 - or kind of append different
60:20 - properties and objects and functions
60:23 - to these parameters that we're passing
60:25 - through each of the middlewares
60:27 - so what we could do here is let's
60:30 - once again let's get rid of the error in
60:33 - this middleware
60:34 - let's also get rid of the console.log we
60:37 - just want to
60:38 - have a basic middleware let's call this
60:41 - number one again
60:42 - then let's say number two
60:46 - and let's put these in as global
60:50 - middlewares
60:51 - so here's middleware one and two so
60:54 - first our route's going to call
60:55 - middleware one
60:56 - then two and then the actual callback
60:59 - for the route
61:00 - so to demonstrate this let's go ahead
61:03 - come up to middleware one
61:05 - and say something like request
61:08 - dot custom property equals
61:12 - 100. all right so we just created a
61:16 - variable that is attached to the request
61:18 - object now since we're passing since
61:21 - express
61:22 - as a framework passes this request and
61:25 - response
61:26 - object through each of the middlewares
61:29 - it will actually
61:30 - be available to us in later middlewares
61:33 - so what we can do is we can say we
61:35 - define it up in middleware 1
61:38 - then in middleware 2 we say console.log
61:43 - the custom property value is
61:47 - and then let's put in that custom
61:50 - property
61:53 - so in middleware number two we should
61:56 - print
61:56 - the custom property value is 100
62:00 - but then we want to reassign it
62:03 - so let's say custom property equals
62:07 - 600 just a random number
62:10 - and then finally down in our routes
62:12 - we'll say
62:14 - the value is
62:18 - and then we'll put in request dot custom
62:21 - property
62:28 - and in this case it's probably going to
62:30 - print or not probably
62:31 - it will print 600 because we have
62:34 - modified the property in middleware
62:35 - number two
62:37 - so let's save that go to the browser and
62:40 - see what we get
62:43 - so we see we see that the value is 600
62:46 - and that is because we set it in our
62:50 - second middleware which was the last
62:51 - middleware that modified that property
62:54 - now you might be asking what is the
62:57 - point of this
62:58 - why did you show me that well the reason
63:00 - being is because it
63:02 - helps you to understand how a lot of the
63:05 - middlewares that we use on a daily basis
63:07 - in express are actually working so if
63:11 - you're following along this series
63:13 - the passport.js series for user
63:16 - authentication
63:17 - this is exactly how passport js
63:20 - which is in express middleware is going
63:23 - to keep track
63:24 - of users whether they're authenticated
63:26 - or not
63:27 - they the passport middleware is going to
63:30 - take that request
63:31 - object and it's going to actually append
63:34 - different properties to it
63:36 - and also if you watched the previous
63:39 - video
63:40 - in this series on the express sessions
63:43 - middleware
63:44 - you also know that the request.session
63:46 - object
63:47 - is where the session is stored so you
63:49 - can see how
63:51 - powerful this is and how we can actually
63:53 - store
63:54 - data within the request object and
63:57 - you know each of our middlewares can
63:59 - have access to that data
64:01 - even if they come way after the
64:03 - middleware that
64:04 - first modified the data so that's just
64:07 - kind of a brief explainer
64:09 - of how middleware works in express
64:12 - and how air handling middleware works in
64:15 - express
64:16 - hopefully it kind of um broadens your
64:20 - express horizons a little bit i know
64:21 - when i first learned it it did
64:23 - um and it made me a lot better express
64:27 - developer
64:27 - i now write middleware for all of my
64:30 - applications to do just
64:32 - ad hoc things anywhere from
64:35 - you know authentication guards so maybe
64:37 - we're checking
64:39 - a value of a user that we've received
64:43 - maybe we're checking if they have
64:45 - administrative rights
64:47 - and we use a middleware to do that so
64:49 - the middleware would basically
64:51 - look up the user in the database check
64:53 - the admin property
64:55 - if the admin property is true then we
64:58 - pass it to the next middleware
64:59 - if it's false then we might return
65:02 - something like
65:03 - 401 or 403 unauthorized
65:06 - http statuses all right after this last
65:10 - section on express middleware we are now
65:13 - set up to really understand the express
65:15 - session library
65:16 - when you're implementing the passport
65:18 - local strategy
65:19 - it uses express session under the hood
65:22 - which can be
65:23 - extremely confusing and when you read
65:25 - through the passport documentation
65:27 - it doesn't make it abundantly clear that
65:29 - this is happening
65:30 - in this section i'm going to teach you
65:32 - exactly how this express session
65:34 - middleware is working behind the scenes
65:37 - kind of independent of the passport js
65:40 - middleware itself and then we're going
65:42 - to talk a little bit more about how that
65:44 - express session
65:45 - is being looped in to our passport
65:48 - authentication middleware
65:49 - now the really cool thing about this
65:51 - section is that learning the express
65:53 - session
65:54 - middleware is not only going to help you
65:56 - implement a passport local strategy
65:58 - but it can also be really useful for
66:00 - other purposes within your web app
66:02 - well state management is often handled
66:05 - on the front end
66:06 - with frameworks like angular vue.js or
66:09 - react
66:10 - there is the possibility of handling
66:13 - some sort of
66:14 - state or application state on the back
66:16 - end in the form of a session that is
66:18 - what the express session library aims to
66:21 - do
66:21 - but enough talk let's dive in and
66:23 - understand all about this library
66:25 - so in this case we're going to be
66:27 - looking at a very simple express app
66:30 - and i'm going to take you through how
66:33 - the session
66:34 - is working how the cookies kind of work
66:36 - with the session
66:38 - and some of the configuration that you
66:39 - have to do to set up
66:41 - the express session middleware what i've
66:44 - got open right now
66:45 - is the repository that goes along with
66:47 - this passport.js
66:49 - tutorial series and we just have a
66:52 - folder
66:52 - for little one-off tutorials like this
66:55 - one
66:56 - i've already created an application
66:59 - which is an express
67:00 - application and i'm just going to
67:02 - quickly walk you through what i've done
67:04 - and then we'll go through what's
67:06 - actually happening what are some of
67:08 - these configuration options
67:10 - so the first thing that i've done i've
67:12 - already installed my dependencies
67:14 - we've got express mongoose for the
67:16 - database and then
67:18 - express session which is an npm module
67:21 - we then have something called connect
67:25 - which we'll get to in a few minutes it's
67:27 - what we're going to actually use
67:29 - for the session store then
67:32 - of course we set up our express app
67:35 - pretty familiar to most people
67:37 - we connect to our database right here so
67:40 - i'm just using a completely
67:42 - unauthenticated
67:44 - localhost database i've got that running
67:47 - in the background already
67:48 - so if you're trying to follow along be
67:51 - sure that you
67:52 - get the mongodb server or that process
67:55 - running before you try to run this app
67:58 - so we're just going to use the tutorial
68:00 - database
68:02 - and then these options here are just set
68:04 - because when you run
68:06 - the application is going to
68:09 - complain about it if you don't put these
68:12 - so that is all we've got and we create
68:14 - the connection
68:16 - right here so the connection represents
68:19 - um our database connection and then down
68:22 - here we
68:23 - have some pretty familiar json and url
68:26 - encoded middleware which is going to
68:28 - allow the
68:30 - express server to parse the different
68:32 - request
68:34 - types so that just pertains to the type
68:37 - of
68:38 - responses that we're getting in on the
68:41 - server
68:42 - and then finally we have things related
68:45 - to
68:46 - the session itself which we're going to
68:48 - dive in a little bit deeper
68:50 - and at the bottom we've just got we're
68:52 - listening on localhost 3000
68:55 - and we have one simple route for the
68:57 - home page
68:58 - just says hello world sessions so that
69:01 - is our app
69:02 - this is the only file we're working with
69:04 - and so it should be pretty
69:06 - straightforward
69:07 - like i said this tutorial is not an
69:10 - express tutorial
69:11 - and i assume that you already have a
69:13 - decent understanding of how the express
69:16 - framework works i'm trying to stick
69:18 - primarily to
69:20 - how the express session middleware works
69:23 - so if you don't understand how
69:25 - express works or how middleware works be
69:28 - sure to check out some
69:29 - of my other videos or just read some of
69:32 - the documentation online
69:34 - before we get into any of the
69:36 - configuration
69:37 - and understanding how the express
69:39 - session works
69:40 - we need to answer the question what is
69:42 - the difference between
69:43 - a session and a cookie you'll see that
69:46 - in the configuration
69:48 - i've got a cookie set and in a previous
69:50 - video that i did
69:51 - again link is in the description um
69:55 - we talked about what a cookie was so
69:58 - basically a session in a cookie are
70:00 - different
70:01 - in the places that their data is stored
70:05 - so a cookie has its data stored in the
70:07 - browser
70:08 - and that browser is going to attach that
70:11 - cookie key value pair
70:13 - to every http request that it does
70:17 - a session on the other hand is going to
70:19 - be stored
70:20 - on the server side so when i say server
70:23 - side just the express js
70:24 - application and so this
70:28 - express session is going to store a
70:31 - little bit
70:31 - bigger types of data so in a cookie you
70:34 - can't put a whole lot of data
70:36 - and it gets very tedious if we're
70:38 - constantly adding more and more data to
70:40 - the cookie that we're attaching to each
70:42 - request so
70:44 - it would make sense to put that in a
70:46 - server-side session
70:48 - where we can store much larger amounts
70:51 - of data
70:52 - in addition a server-side session is
70:55 - advantageous because with a cookie we
70:58 - cannot store
70:59 - any sort of user credentials
71:02 - or secret information if we did that
71:05 - then
71:06 - a hacker could easily get a hold of that
71:08 - information
71:10 - and steal personal data so the benefit
71:13 - of a session
71:14 - is basically the fact that we have it on
71:16 - our server side
71:18 - and we're actually authenticating into
71:20 - the session
71:21 - with a secret key so with that said
71:25 - that is the main difference between a
71:27 - cookie and a session
71:28 - i want you to keep that in mind as we're
71:30 - talking about the two
71:31 - in this video now that that's covered
71:35 - we have some time to get into the actual
71:37 - code
71:38 - and configuration of an express session
71:41 - and then i'm going to show you kind of
71:42 - how it works in real time
71:45 - so what we've got on the screen right
71:46 - now is the express session documentation
71:49 - it's just an npm module a pretty popular
71:53 - one at that
71:54 - and you can see on npmjs.com
71:58 - there's all the documentation that you
72:00 - would need to learn how to use this
72:03 - but i'll just point you towards a few of
72:05 - the common things that you'll see
72:08 - first off of course we require in the
72:11 - express session
72:12 - and then these options right here
72:15 - are what are going to be included in
72:17 - that options object so if you look at
72:20 - the
72:20 - code here you'll see that for our
72:23 - session
72:24 - we're saying app.use so that's just we
72:26 - want to use the session
72:28 - middleware and then we've passed into
72:31 - the session
72:32 - middleware an object right here which
72:35 - represents
72:36 - our options so if we go back to the
72:39 - documentation
72:40 - really quickly you'll see that all of
72:43 - these options are documented
72:45 - right here under the options section
72:49 - now the one thing that i wanted to point
72:50 - out you get through the options that's
72:52 - great fine
72:54 - but then you get to the bottom somewhere
72:56 - down here
72:58 - and it talks about a session store
73:00 - implementation
73:02 - so if you're unfamiliar with what that
73:04 - is it's basically
73:06 - deciding what um persistent memory are
73:11 - we going to
73:12 - store our sessions in if you remember
73:14 - from a few minutes ago i said that a
73:16 - session
73:17 - is used to store information about a
73:20 - particular user moving throughout the
73:22 - browser or a client
73:24 - and so we can potentially get up to a
73:26 - decent amount of information
73:28 - and therefore in a production
73:30 - environment it would be
73:32 - useful to have an actual database
73:34 - storing that information
73:36 - now by default the express session
73:38 - middleware just comes with
73:41 - its own implementation of a session
73:43 - store but it's not using a database it's
73:46 - just using
73:46 - in memory or memory that's local to your
73:50 - application
73:51 - and it's not going to be a scalable
73:53 - solution
73:54 - so what we need to do is set up an
73:57 - actual session store
73:59 - which is a fancy way of saying we need
74:02 - to connect
74:03 - our database to the express session
74:05 - middleware
74:07 - so there's going to be a lot of options
74:11 - for what session stores we can use and
74:13 - they're documented here at the bottom
74:16 - the one that we're using particularly is
74:18 - the connect
74:19 -  session store which is probably
74:22 - one of the most popular ones
74:24 - and it allows us right here to connect
74:27 - to
74:28 - the mongodb database that we have
74:30 - running
74:31 - in our express app so let's go back to
74:34 - our app real quick and see
74:35 - what i mean so to do this session store
74:39 - to connect it up
74:40 - we first have to have our database
74:42 - connection
74:43 - so we talked about this a few minutes
74:45 - ago here's our connection we're just
74:47 - using
74:48 - a tutorial database on localhost
74:52 - nothing you know you'd obviously want to
74:55 - change this if you're in production
74:57 - but we've got this running on my
74:59 - computer and i can actually come down to
75:01 - the terminal here
75:02 - and run the shell and you'll see
75:06 - that we can
75:07 - show dbs and you'll see that we have
75:10 - a tutorial db set up when we connected
75:14 - to this database
75:15 - now what we want to do is we want to
75:17 - tell
75:18 - the express session middleware that we
75:21 - want to use that mongodb database
75:24 - for its session store so you'll see that
75:27 - that happens
75:29 - right here in the store option of the
75:32 - session middleware
75:33 - and so what we've done is we've passed
75:35 - in the session store object
75:38 - into this store option and the session
75:41 - store object
75:42 - is set up right here and it is basically
75:45 - just using that connect
75:46 -  right here the connect
75:49 - package
75:50 - and we're configuring a few options
75:53 - we're saying that the connection
75:54 - equals the connection that we just set
75:56 - up and
75:58 - the collection that we'll be putting our
76:00 - sessions in
76:01 - is going to be called sessions pretty
76:04 - standard
76:05 - pretty standard option that we have here
76:07 - you can obviously customize it a little
76:09 - bit
76:10 - and if you went to the documentation of
76:12 - connect there's a few other
76:14 - options that you can set
76:16 - but what i want to show you is what is
76:18 - happening
76:19 - when we connect everything up so in my
76:22 - first terminal
76:23 - i will run this application so let me go
76:27 - to
76:29 - the path here and we're going to run the
76:32 - application
76:34 - so we are listening on localhost 3000
76:38 - and if we come into the browser here
76:42 - i've got this queued up so that we
76:45 - currently have localhost 3000
76:48 - ready to go but i have not clicked
76:50 - refresh yet
76:52 - the reason being is because i want to
76:55 - show you exactly what this
76:57 - middleware the session middleware is
76:59 - doing
77:00 - so let's first come back to our
77:03 - code and what we want to do
77:06 - is go to the shell and
77:10 - we want to use the tutorial database
77:14 - so now we've switched to the tutorial
77:15 - database let me clear the screen
77:18 - and we're going to show the collections
77:20 - that exist
77:21 - in that database when i ran the app
77:24 - it initialized this sessions collection
77:28 - in my database but if i say
77:31 - db.sessions.find
77:34 - there's going to only be a couple
77:36 - objects in here
77:38 - let me just go ahead and drop this
77:39 - really quick because i think i had some
77:41 - stuff from previously
77:43 - so let's just say db.sessions.drop
77:48 - so we dropped the database if we show
77:50 - the collections now
77:52 - there's nothing but if we were to come
77:54 - here
77:55 - and refresh the app so we're using
77:58 - nodemon so if we click save
78:00 - it's going to refresh the app we're
78:02 - going to go into
78:04 - show collections
78:07 - and you see again that the sessions have
78:09 - been established
78:10 - and if we say db.sessions.find
78:14 - we shouldn't find any documents
78:16 - whatsoever
78:17 - in this collection so
78:20 - we have a completely clean slate
78:23 - and in order to establish a new session
78:28 - all we have to do is make some sort of
78:30 - http request
78:32 - to our application so if i came to the
78:35 - browser
78:36 - and i clicked refresh here what's going
78:39 - to happen
78:40 - is that session middleware is going to
78:42 - kind of fire
78:43 - it's going to create a session and then
78:46 - what it's going to do
78:47 - is create a session id which is going to
78:50 - be stored in a cookie
78:52 - in this browser so like you know just
78:55 - like we don't have any
78:57 - sessions in the database yet we also
78:59 - don't have any cookies
79:01 - in the browser yet so let's go back to
79:04 - our code and what i'm going to do
79:09 - is just walk you through a few the
79:10 - options and then we'll finally see
79:12 - exactly how it's working
79:14 - so when we set up our session middleware
79:16 - we have a secret
79:18 - pretty self-explanatory but this secret
79:20 - is going to
79:22 - well usually it's going to be stored in
79:24 - an environment variable
79:26 - and you don't want to expose this to the
79:28 - public
79:29 - because it basically says if the secret
79:32 - is invalid then the session is invalid
79:35 - too but in this case
79:36 - i just put some secret just so that we
79:39 - can have it all in front of us
79:41 - then we have a couple options here
79:43 - resave and save
79:44 - uninitialized and these are just options
79:48 - relating to
79:49 - what does the session do if nothing has
79:52 - changed
79:53 - what does the session do you know if
79:55 - something has changed
79:57 - and basically tells the middleware
80:00 - how to react to different events in the
80:03 - browser
80:04 - you can read up on the documentation a
80:06 - little bit more on these options
80:08 - but the thing that we're interested in
80:10 - we already talked about the session
80:11 - store
80:12 - but what we're doing is we're setting a
80:14 - cookie max age
80:16 - so in other words like we talked about
80:18 - in a previous video
80:20 - a cookie can have an expires header and
80:24 - or not
80:24 - a header but an expires property which
80:27 - says
80:28 - after a certain amount of time the
80:30 - browser is going to delete the cookie
80:32 - and it's not going to attach to any of
80:34 - the requests in the future
80:36 - so in this case we're setting our cookie
80:39 - equal to one day
80:41 - and you can see the math that we're
80:42 - doing here in the comment
80:44 - we're basically just saying one day 24
80:46 - hours in a day
80:48 - 60 minutes in an hour 60 seconds in a
80:50 - minute and a thousand milliseconds
80:52 - in a second and so that's the math that
80:55 - we're doing right here to get to
80:56 - a full day for that expires property
81:00 - so basically what's going to happen when
81:02 - i
81:04 - send an http get request
81:07 - to our sole route right here is the
81:10 - session middleware
81:11 - is going to initialize a session
81:15 - and then it's going to take that session
81:17 - id and set it equal to this
81:19 - or set the cookie equal to that session
81:22 - id
81:23 - the cookie is then going to be put in
81:25 - the set cookie header
81:27 - http header and then that is going to
81:31 - be in the response header it's going to
81:32 - go in the browser the browser is going
81:35 - to receive it
81:36 - and say oh you want me to set this
81:38 - cookie i'll set the cookie
81:40 - and now every time we refresh that
81:42 - cookie will be
81:43 - a part of that request so let's go ahead
81:47 - and do this
81:47 - we're going to visit our only route in
81:50 - the application
81:51 - and to do that we need to go to google
81:53 - chrome
81:55 - and we're going to click refresh
81:58 - so when we clicked well now we it did
82:01 - not load so let me go ahead
82:03 - and do that one more time we refreshed
82:05 - it
82:06 - we get our response it says hello world
82:08 - sessions
82:10 - and what you'll notice is now we have
82:12 - this cookie
82:13 - which is by default called connect dot
82:15 - sid
82:16 - in the express session middleware and we
82:19 - have some sort of value here which
82:21 - somehow corresponds to our session id
82:25 - so basically what's happening is the
82:27 - express session middleware
82:29 - is going to get this cookie on every
82:31 - request
82:32 - it's going to take the value of that
82:34 - cookie it's going to say
82:37 - okay look up this session id in the
82:39 - session store
82:40 - which is the database and then it's
82:42 - going to say is the session valid
82:44 - if so let's use the information from the
82:47 - session
82:48 - to either authenticate our user
82:51 - find out some data about our user maybe
82:54 - like how many times that user has
82:56 - visited
82:56 - our site anything of that sort
83:00 - is what's going to happen when the user
83:03 - loads a different route you'll also see
83:06 - that we have an expires
83:09 - property right here that says tomorrow
83:11 - this cookie is going to delete from the
83:13 - browser
83:14 - but for now since it's still valid
83:17 - it's going to attach to every single
83:19 - request
83:20 - so if we go to the network and look at
83:22 - that last request
83:24 - we'll see that in the response header
83:27 - this came from our express server
83:29 - using the express session middleware
83:32 - we have the setcookie header and
83:35 - we set the connect.sid header and we
83:38 - gave it an
83:39 - expires now in the request headers
83:42 - since we only did this once you won't
83:45 - see any cookie
83:47 - but if i click refresh one more time
83:50 - and we look at the request headers and
83:53 - response headers
83:55 - you'll see that in the request headers
83:57 - we have the cookie
83:58 - that was set previously so in other
84:01 - words the browser is saying
84:02 - okay i have a cookie that is still valid
84:05 - let me attach it to every ques
84:07 - request within this localhost domain
84:11 - all right so we have this cookie on
84:13 - every request now
84:14 - let's see what's happening on the back
84:16 - end so let's go back to our code
84:20 - and we're in the shell so we're
84:23 - looking at our database right now
84:26 - and we're going to type in db oh let me
84:29 - clear this real quick
84:32 - db.sessions.find
84:34 - and that's going to look in the sessions
84:37 - collection for any documents in that
84:40 - collection
84:42 - and you'll see that we have one and only
84:44 - one document
84:45 - which represents the session that we
84:48 - just
84:48 - established in the browser so you'll see
84:51 - that the id
84:53 - is right here which you can also see in
84:55 - that cookie
84:57 - that we have in the browser so let's see
84:59 - the first couple letters were
85:00 - capital a y yj
85:04 - so let's go back to the browser and
85:06 - you'll see that the
85:09 - cookie right here is has got that id
85:12 - set in it so that's how we kind of
85:14 - connect the
85:15 - back end to the front end and then let's
85:18 - once again come back to our code
85:22 - so we also have the expires header
85:25 - within here
85:26 - so we can also validate it on the back
85:28 - end and
85:29 - basically what this is going to do is
85:32 - every time
85:33 - the server gets that specific cookie
85:36 - with that session id
85:37 - attached to it it's going to come to
85:40 - this sessions collection in the database
85:42 - it's going to grab that document out of
85:45 - the database
85:46 - or the session store and it's going to
85:48 - get information
85:50 - that we have set on to that session and
85:53 - use it to
85:54 - do whatever we want to do with our
85:56 - application
85:57 - now this is great and all but what do we
85:59 - actually use this
86:00 - express session middleware for well
86:03 - in another video in this passport.js
86:07 - series
86:08 - you'll see how passport.js actually
86:10 - connects in
86:11 - to the express session middleware and
86:14 - uses the session
86:15 - to actually authenticate the user but
86:18 - since this is kind of a standalone video
86:20 - i'm not going to get into that all i'm
86:22 - going to show you before we kind of
86:23 - conclude
86:24 - is where this session is being set
86:27 - now we know that the cookie in the
86:30 - browser
86:30 - has the session id and we use that
86:33 - session id
86:34 - to look up the session in the database
86:36 - or the session store
86:38 - now we can also come to our routes
86:41 - and get information about the session so
86:44 - if we said console.log
86:46 - request dot session
86:51 - you'll get to see exactly what that
86:54 - session looks like
86:55 - and we can actually set properties to
86:58 - that session
86:59 - so again i'm connected using nodemon
87:02 - so we'll automatically refresh when we
87:05 - save this app so let me click control
87:07 - s to save you'll see that something
87:10 - happens here
87:11 - so we reset and now if we visit this
87:14 - route again in the browser
87:16 - in the console we should see the session
87:18 - object
87:19 - so let's quickly switch over to the
87:21 - browser
87:22 - we'll refresh refresh this page
87:26 - and then we'll come back to our code
87:27 - window
87:29 - and you'll see that our session object
87:31 - has been printed to the console
87:33 - right now all we have is a
87:36 - expires header and a couple other
87:40 - metadata properties but what we could
87:42 - also
87:43 - and this is set to the cookie object but
87:46 - we could also set other information
87:49 - so we could set something like how many
87:52 - visits a user has made to our page
87:55 - so let's go ahead and do something
87:57 - really simple like that
88:00 - in our only route that we have for this
88:02 - application
88:04 - let's just say
88:05 - [Music]
88:07 - if request dot session
88:11 - dot view count
88:14 - we want to say request dot session
88:18 - dot view count equals
88:23 - request dot session dot view count
88:26 - plus one or you could just do the plus
88:29 - plus syntax
88:30 - at the end you could just do something
88:32 - like that and be done with it but
88:34 - we'll be really explicit here and we'll
88:36 - set a value
88:41 - okay so if we have that property on the
88:43 - session we're going to increment it by
88:45 - one
88:46 - and then what we're going to do is we're
88:48 - going to say in
88:49 - the response instead of hello world
88:53 - we're going to say you have visited this
88:56 - page x amount of time so
88:59 - we'll use a little javascript syntax
89:04 - and we need to change these to backticks
89:07 - to get this to work
89:10 - and let's see we can just put in
89:15 - request.session.view
89:16 - count and now it should tell us how many
89:19 - times we've visited this page
89:22 - when we visit that page now we also have
89:24 - to say
89:25 - else because in this first occurrence
89:28 - we're not going to have this property
89:30 - set
89:31 - so if that does not exist then we're
89:33 - going to say request dot session
89:36 - dot view count equals one
89:40 - all right so we have set a property to
89:42 - the session object
89:44 - and let's go ahead and save this
89:46 - application
89:47 - and go to the browser and visit it
89:52 - so we're in the browser now and we will
89:55 - reload
89:56 - and it says you have visited this page
89:59 - one times
90:00 - it should be time but now
90:03 - every time we refresh we're going to get
90:06 - that number to increment
90:07 - because of the logic that we've put into
90:09 - our route
90:11 - so you can see how this session object
90:14 - could be very useful
90:16 - for tracking information about a
90:18 - specific user or client
90:21 - one last thing i want to show you if we
90:22 - go back to the code
90:26 - you can look it up in the database again
90:28 - so let's go back to
90:30 - and let's find that session once more
90:34 - you'll see we still have just one object
90:37 - one
90:38 - document in the database but now we have
90:41 - this little property down here
90:43 - so when we set the view count property
90:47 - on the request.session object that
90:50 - actually persisted in the session store
90:52 - or our mongodb database under the view
90:55 - count property
90:57 - so again you can see how powerful this
90:59 - is and you could
91:00 - also kind of extrapolate out and start
91:04 - to foreshadow
91:05 - how something like a passport js
91:07 - middleware
91:08 - could kind of connect into this middle
91:11 - this express session middleware
91:13 - to keep its own sort of data you came
91:16 - here to learn user authentication
91:18 - and it took us about two hours to get to
91:20 - the part where we're actually
91:22 - writing it for the first time i hope the
91:24 - prerequisite lessons that we just
91:26 - covered were really helpful to get us
91:28 - set up to this point
91:29 - and now we're ready to actually
91:31 - implement the passport local strategy
91:33 - within your web app
91:34 - your users are going to have the
91:36 - expectation
91:37 - that you have the option to do a
91:39 - username or email based
91:41 - authentication you have to have this
91:43 - because what if your user doesn't have a
91:46 - google account or a facebook account to
91:48 - use that
91:49 - you know other authentication option
91:51 - that you're offering
91:52 - you've got to have this most basic
91:54 - option for them and the passport local
91:56 - strategy is one way to do it
91:58 - equipped with our knowledge of http
92:01 - headers
92:02 - cookies the express session library and
92:05 - express middleware we are fully ready to
92:08 - jump into this strategy
92:10 - my goal in this video is to get the
92:13 - passport.js
92:15 - library imported into our express.js
92:18 - application and can start to configure
92:22 - it
92:23 - to help us with this i've set up a
92:26 - repository on my github that will
92:29 - basically give you
92:30 - a starter template to work from and what
92:34 - this is going to do
92:35 - is kind of eliminate all of that stuff
92:37 - that we don't want to focus on
92:39 - such as setting up a basic express
92:42 - application
92:43 - setting up a very basic database with
92:45 - mongodb
92:47 - and even setting up something like a
92:50 - express
92:50 - session which we talked about in one of
92:52 - the prerequisite videos
92:54 - for this tutorial series in this
92:57 - repository
92:58 - i've got three branches but the master
93:01 - branch is going to have
93:02 - your starter template so if you don't
93:05 - know
93:06 - how to use branches in git that's
93:08 - totally fine
93:10 - if you do want to learn more about that
93:11 - i actually have a full
93:13 - tutorial series on using git but
93:16 - anyways you can see if you come into
93:19 - github
93:20 - you don't have to actually know any
93:22 - commands to do this you just drop down
93:24 - and you can see that the different
93:25 - branches will have
93:27 - the final branch is kind of the final
93:29 - implementation
93:31 - um no promises that will get you know
93:34 - line by line
93:35 - character by character to the same
93:37 - implementation here
93:39 - during the video but will come very
93:42 - close
93:43 - the overall structure will be exactly
93:45 - the same
93:46 - and then we have the final all-in-one
93:50 - which is basically just one js file or
93:54 - javascript file
93:55 - that has everything that you need
93:58 - to run this with tons of comments so
94:01 - that you can really figure out what is
94:03 - going on
94:04 - so that's what the repository is you can
94:07 - go ahead and fork it
94:08 - or clone it whatever you want to do
94:11 - [Music]
94:12 - and then download it to your computer
94:15 - and once you've done that you should
94:17 - land to a screen
94:19 - like the one i've got right here
94:23 - and i've got open the readme which kind
94:25 - of gives you
94:26 - basic instructions on how to use it we
94:28 - went through most of this
94:29 - already so let's go ahead and close that
94:33 - out
94:33 - and take a quick tour of what's going on
94:36 - in this repository and then we will go
94:40 - into the configuration
94:42 - of the passport local strategy let's
94:45 - take a quick look
94:47 - at what i've got for you already set up
94:50 - in the template
94:50 - application it's pretty similar to what
94:54 - you probably have seen before i tried to
94:57 - make it
94:58 - a similar structure to what you might
95:00 - find in a lot of
95:02 - online express node.js tutorials so
95:05 - hopefully this looks a little bit
95:07 - familiar
95:08 - but anyways we start with our app.js
95:13 - which is going to set up our basic
95:15 - express app
95:17 - so the imports at the top let's just go
95:18 - through them real quick if you haven't
95:20 - installed them
95:22 - after cloning the repo just type npm
95:25 - install to get those installed
95:27 - we have express pretty straightforward
95:30 - mongoose which is the odm
95:32 - for mongodb i will mention
95:35 - um while we're on this line i've already
95:37 - got my
95:39 -  d service running
95:42 - in the background so you'll have to do
95:45 - that
95:46 - when you're running this app and i i
95:49 - don't even know if i have this
95:50 - in the readme so maybe i will
95:54 - put that in here right now
95:58 - we'll just say make sure to run
96:03 - the mongod service
96:07 - before running the app locally
96:10 - all right so now that we got that
96:12 - covered
96:14 - just make sure that you have that
96:15 - running and then you should be able to
96:17 - run this app
96:18 - just fine um all right so moving on
96:21 - we have express session which i've
96:24 - covered in a separate video
96:26 - how this works and how to set it up so
96:29 - i've already implemented it here for you
96:31 - if you want to learn more about that go
96:33 - to that video again
96:35 - that is in the description just click on
96:37 - the playlist and you'll
96:38 - you'll find it so next up is passport
96:42 - this is what most of this video in the
96:44 - next couple videos is going to be about
96:47 - will require in the built-in node.js
96:50 - crypto library which is going to allow
96:51 - us to
96:53 - create and verify passwords
96:56 - we require in the routes which is the
96:59 - routes folder we'll get there in just a
97:01 - second
97:02 - and also we have a database
97:05 - configuration
97:06 - in the config directory now coming down
97:09 - we have store
97:11 - directly related to the express session
97:13 - middleware
97:14 - again that's another video we have
97:17 - this little line right here most people
97:20 - probably have seen it but if you haven't
97:22 - all this is doing is giving us access to
97:26 - the dot env file that we have defined
97:29 - over here
97:30 - that by default is not going to be
97:34 - imported when you clone this repository
97:37 - because it's got secret keys in it so
97:40 - you will need to create the dot
97:41 - env file and in the
97:45 - env file i think you only need two
97:47 - things you need the db string
97:49 - and the secret and for
97:53 - my case i'm just using a very simple db
97:56 - string
97:56 - i don't even have a user or a password
98:00 - just to keep things simple for now but
98:02 - in production you'd obviously want to
98:05 - um have a user and password in the
98:08 - actual database that you would connect
98:09 - to
98:11 - so and then the secret is going to be i
98:13 - think for the express session module
98:15 - so let's close that and then you can see
98:18 - you can actually get access to those
98:21 - variables
98:21 - anywhere within this app.js file
98:25 - with this syntax the
98:28 - process.env.variablename
98:30 - all right so moving on we have the
98:32 - express application
98:34 - pretty simple this is some middleware
98:36 - for parsing
98:37 - http responses
98:40 - most of you would probably have seen
98:43 - app.use
98:46 - bodyparser.json
98:48 - but i've just used the built-in express
98:51 - parsers because i think these actually
98:54 - came in a little bit recently
98:56 - in like a recent release i could be
98:58 - wrong on that
98:59 - um but you no longer need to use body
99:02 - parser
99:03 - all right session setup again this was
99:06 - covered in a different video but let's
99:07 - just take a
99:08 - very very quick look at what is going on
99:11 - here
99:12 - we have our session store which is going
99:14 - to say
99:15 - hey express session middleware i want
99:18 - you to use the mongodb
99:19 - database for the
99:22 - session storage and
99:26 - in that i want you to use the sessions
99:28 - table
99:29 - or not table but collection in
99:32 - that mongodb database so that's the
99:36 - session store
99:37 - down here in the configuration options
99:39 - for the session middleware
99:41 - we are telling it to use that store then
99:44 - we have some other
99:47 - options here so the secret we just
99:48 - talked about that
99:50 - that's going to help the express session
99:52 - middleware
99:53 - validate the session that it has looked
99:57 - up
99:57 - it's going to check to see if it matches
99:59 - that secret
100:01 - these two options have to do with you
100:03 - know how does the session treat
100:05 - or how does the session react when
100:07 - there's actually no changes
100:09 - in the browser you can read up about
100:12 - that on your own
100:13 - and then finally the cookie this is the
100:17 - this is also another separate video in
100:20 - this series
100:22 - but basically what we're doing is we're
100:23 - storing the session id
100:25 - in a cookie in the browser and this
100:28 - right here
100:29 - is just going to kind of tell the
100:32 - express session middleware
100:33 - hey i want you to it basically set an
100:37 - expires header
100:38 - um not header but an expires property
100:41 - of one day so this cookie will expire in
100:44 - one day and a new session will have to
100:46 - be
100:47 - reestablished when it does expire
100:50 - alright that was just a quick overview
100:52 - if you want more you have to check out
100:54 - the other video
100:56 - next up we have passport authentication
100:58 - i've just put in this basic require
101:00 - statement
101:02 - to show you where it is so it's in the
101:04 - config directory we'll get to that
101:06 - in just a moment we are using our routes
101:10 - so this is pretty standard in express
101:12 - you put your routes
101:13 - after the other middleware but before
101:15 - your air handler
101:17 - in this case we don't have an error
101:19 - handler
101:20 - you might want to do that for a
101:22 - production application
101:23 - finally we are listening on port 3000
101:27 - localhost pretty straightforward so
101:30 - that is the basic app let's go ahead and
101:32 - look at some of
101:34 - the other pieces so let me save that
101:37 - we'll first start in the config so we
101:40 - have passport.js
101:42 - all i've done here is imported the
101:46 - relevant modules that we'll will need to
101:48 - set it up
101:50 - and then i've imported some database
101:52 - configurations
101:54 - uh well the connection and then the user
101:56 - model that we'll be
101:58 - um using so going straight over to the
102:01 - database
102:02 - configuration this is a pretty standard
102:06 - mongodb
102:07 - database setup we're requiring in
102:09 - mongoose
102:10 - again we got this access to the env file
102:15 - we're going to grab the db string from
102:19 - that file
102:20 - and we're going to create a connection
102:22 - with it so we pass in
102:24 - the string to the create connection
102:27 - method on the mongoose object
102:30 - and then we pass in these options which
102:32 - will just suppress
102:33 - any warning messages finally
102:37 - we have a user schema it's very simple
102:40 - we just have a username hash and salt
102:43 - you will see
102:44 - what the hash and salt mean a little bit
102:46 - later
102:47 - so we create a model for that user based
102:51 - on the schema
102:52 - and we export the connection so that we
102:54 - can use it in other files
102:56 - so pretty straightforward with that
102:59 - let's see what else we've got
103:01 - we have the password utils which should
103:04 - just have the
103:05 - validate password and create password
103:09 - functions so let's check that out
103:14 - and you can see that i've already kind
103:16 - of templated out
103:17 - what the functions will look like all we
103:19 - have to do is jump in there and actually
103:21 - implement them let's see if i'm missing
103:24 - anything
103:25 - else okay i've got the routes just one
103:27 - route file
103:29 - and i know there's a lot of stuff in
103:31 - here but really there's
103:33 - not much of anything
103:36 - we pass in the express router uh
103:39 - passport because we're going to actually
103:41 - use passport in our routes
103:44 - we have some past password utils we just
103:46 - looked at the database connection
103:48 - and user model and really what we're
103:51 - going to be
103:52 - doing the only thing we're going to be
103:53 - doing in this file is these two routes
103:56 - so the login and register route we're
103:59 - going to have to implement
104:00 - the logic behind these in the git routes
104:04 - below
104:05 - all i've done is create a super simple
104:09 - flow that will go through as we
104:11 - implement this passport authentication
104:14 - so you'll see the home page is just
104:17 - going to tell you to please register you
104:20 - click the link
104:21 - goes to the register page which is right
104:24 - here
104:25 - that has just a really ugly looking form
104:28 - that we will type a username and
104:31 - password into to
104:32 - register that will submit to our custom
104:36 - implemented post request up here then it
104:39 - will
104:39 - if you're successful it will redirect
104:42 - you i think
104:43 - to the login page then you will
104:48 - log in with your username and password
104:51 - which will
104:52 - create a post request to the login post
104:55 - route which we have to implement
104:58 - and if you successfully log in i think
105:01 - it will redirect you
105:03 - we're going to have to write this logic
105:04 - but it will redirect you to
105:08 - i believe in the i believe the login
105:10 - success route
105:11 - so it'll say you've successfully logged
105:14 - in
105:14 - then we'll try to visit a protected
105:17 - route
105:18 - and that will be right here and we're
105:21 - going to check
105:22 - if we're authenticated and let you in if
105:25 - you are
105:26 - so basically you can look at this but
105:28 - it's just a flow
105:30 - of pages that we're loading the reason i
105:32 - did this
105:35 - without using something like ejs or
105:37 - another temple
105:38 - templating language is just to keep it
105:41 - as simple as possible
105:43 - all we're doing is passing basic html
105:46 - and html forms
105:48 - and using the built-in express
105:51 - methods like res.send in res.redirect
105:55 - so hopefully that makes sense if it
105:57 - doesn't take a look at this for
105:59 - a few minutes and i know it will before
106:02 - we get into the actual
106:03 - implementation and configuration of
106:05 - passport
106:06 - i wanted to show you again i know we
106:09 - already touched on this in the first
106:10 - video just for a few minutes but
106:13 - i want to show you how to find the
106:15 - documentation for this
106:17 - i personally had a very difficult time
106:20 - finding kind of an end to end
106:23 - tutorial and documentation for
106:27 - passport and i think since all the
106:29 - strategies
106:31 - are developed by different developers
106:33 - there's not really
106:35 - you know a one size fits all
106:37 - documentation for it
106:39 - now if you go to the passport.js website
106:42 - you'll first find that you can click
106:45 - strategies
106:46 - and browse through all the different
106:48 - strategies you'll be able to go to those
106:50 - pages
106:51 - but in our case we're using the passport
106:54 - local strategy
106:55 - so if we click this we should be
106:58 - redirected to the passport local
107:01 - strategy
107:02 - it's going to give us some basic usage
107:05 - instructions
107:06 - so we install it we configure it with
107:10 - a verify function and
107:13 - then we can use it in the route here but
107:16 - that's pretty much
107:17 - all that it gives us there's actually a
107:20 - couple more steps that you need to do
107:22 - to use the um local strategy
107:26 - which is kind of weird why it's not in
107:29 - this on this page
107:30 - and if you click on the examples it goes
107:33 - to a 404 page
107:36 - i think maybe that was recent i don't
107:38 - know
107:39 - whatever the case this is actually not
107:42 - where you're going to want to go
107:43 - for documentation on the passport local
107:46 - strategy
107:47 - the passport local strategy is actually
107:51 - better documented in the general
107:54 - documentation of the passport.js
107:56 - middleware so if you go to documentation
107:59 - right here
108:00 - and you click username and password
108:03 - this is where you're going to get a
108:05 - little bit more verbose
108:07 - documentation on the passport local
108:09 - module
108:10 - so here we have the same thing install
108:13 - passport local
108:15 - but here we're getting a little bit more
108:17 - detailed
108:18 - implementation of this verify callback
108:21 - and how you would use the form how you
108:24 - would
108:25 - use it on the route what kind of
108:27 - parameters you can pass
108:28 - to the verify callback so this is a
108:31 - little bit better documentation
108:33 - but it still kind of misses some of the
108:36 - configuration that you have to do
108:38 - for this module so
108:42 - i'm going to show you exactly how to use
108:43 - it but
108:45 - you can kind of peruse the passport.js
108:47 - documentation
108:49 - you'll find a few things for example
108:52 - if we click on configure it's going to
108:56 - tell us how to configure a strategy
108:59 - because
109:01 - being a framework for the middleware
109:03 - passport has kind of a standardized way
109:06 - to
109:06 - integrate different strategies so on
109:10 - every single strategy that we use we're
109:12 - going to need
109:13 - a verify callback so in this section
109:16 - kind of talks about that verify callback
109:19 - and what the different responses
109:22 - are required based on how the user
109:25 - you know whether the user entered the
109:27 - correct or incorrect
109:29 - credentials whether we got an error
109:31 - message
109:32 - whatever the case it tells you that and
109:35 - then we also have documentation on
109:38 - the authenticate method so passport
109:42 - actually provides you with a built-in
109:45 - authenticate method on the passport
109:48 - object
109:49 - and all you need to do is provide it
109:51 - with
109:52 - the name of the strategy that you've
109:54 - defined
109:55 - and then passport figures out how to
109:58 - go find the verify callback that you've
110:00 - configured
110:01 - for that specific strategy i know this
110:04 - sounds like a lot and i know this
110:06 - documentation is a little bit sporadic
110:08 - it's not necessarily you know a b c d
110:12 - one two three four it's it's a little
110:15 - bit confusing so
110:16 - let's just get into the implementation
110:18 - and i'll do my best to
110:20 - kind of document the passport local
110:22 - strategy for you
110:24 - like we saw in the documentation the
110:26 - first thing we need to do
110:27 - is define the verify callback for the
110:30 - passport local strategy
110:32 - so we'll do this in the passport config
110:35 - file
110:36 - and all we need to do is comment this
110:39 - out
110:39 - the passport.use method and pass in
110:44 - the strategy and the verify callback
110:47 - so i'm just going to paste in the full
110:49 - thing real quick
110:51 - and you'll see that this looks pretty
110:54 - similar to what we saw in the
110:56 - documentation
110:57 - it's also going to be pretty similar to
110:58 - what you'll see in a lot of tutorials
111:01 - but i personally find this a bit
111:03 - confusing when we're looking
111:05 - at it all at once so let's go ahead and
111:08 - deconstruct
111:10 - what's going on in this configuration
111:13 - put it in some variables so that we know
111:15 - exactly what's going on all right so the
111:18 - first thing that we need to do
111:20 - is define the strategy itself
111:23 - so let's say strategy
111:26 - equals and then in this case it's going
111:29 - to be the new
111:30 - local strategy all right so that is the
111:34 - most basic
111:35 - way to create a strategy and then this
111:38 - strategy is going to require
111:40 - that verify callback so let's define
111:44 - that above here
111:51 - and the verify callback is going to
111:54 - take a couple parameters it's going to
111:57 - take a username
112:00 - password and done function
112:04 - in this case down here i just called it
112:06 - callback
112:07 - but you it doesn't really matter what
112:09 - you call this
112:11 - all you need to know is that this
112:13 - represents a function that you will
112:15 - eventually
112:16 - pass the results of your authentication
112:18 - to
112:19 - so those are the parameters and
112:22 - they will actually be populated by the
112:26 - passport framework
112:27 - based on how you implement this so we
112:30 - expect the username
112:32 - to be the value that we received
112:35 - from the request body of some sort of
112:40 - login form so if we
112:43 - were to create a login form type in our
112:46 - username and password
112:47 - and then make a post request to the
112:49 - express api
112:52 - that post request is going to have a
112:54 - username and password field
112:57 - and passport is going to automatically
112:59 - look for those two fields
113:01 - and grab the values of them and populate
113:04 - them
113:05 - in the verify callback now there's a
113:08 - little bit
113:08 - tricky part to this because if you don't
113:11 - name
113:12 - your username and password fields
113:15 - exactly this
113:16 - username and password the passport
113:20 - um framework is not going to or not the
113:22 - passport framework but the passport
113:24 - local strategy
113:26 - is not going to know what variable to
113:29 - look for
113:30 - so in order to prevent this we can
113:32 - actually define
113:34 - custom fields that we want passport to
113:36 - look in
113:38 - i'll show you how to include this in a
113:40 - few seconds but first let's just get it
113:42 - in a variable
113:43 - so we'll say custom fields
113:47 - is equal to an object and we'll say the
113:50 - username
113:51 - field is going to be
113:54 - uh you name we're just making this up
113:58 - making it custom so that we can see
114:00 - exactly how this works
114:02 - so our username field is you name and
114:04 - then our password
114:08 - field is just going to be something like
114:10 - pw
114:11 - so obviously these are some
114:13 - non-conventional
114:15 - ways to name the password and username
114:18 - fields
114:19 - but if we define them in our custom
114:21 - fields object
114:22 - then passport local will know where to
114:25 - look
114:26 - alright so we'll use that object in just
114:28 - a second but first let's come back to
114:30 - the verify callback
114:32 - so in the verify callback what we're
114:35 - doing is
114:37 - basically our own implementation of a
114:40 - password verification
114:42 - now this is where i think people get
114:44 - tripped up a little bit i know i did
114:46 - um thinking that the verify callback
114:50 - has to be a very specific structure
114:53 - and we have to use a certain database
114:55 - because of course the documentation
114:57 - online
114:58 - shows that we're using the mongodb
115:00 - database
115:01 - but in reality it doesn't matter what
115:04 - database you use
115:06 - and it really doesn't matter how you
115:08 - choose to verify
115:10 - the credentials all that matters is that
115:13 - the
115:13 - return values that you pass to this done
115:17 - callback
115:18 - are what passport expects
115:21 - so we can come in here and do whatever
115:24 - we want but
115:26 - for simplicity as we know i'm using the
115:29 - mongodb database so it's going to look
115:31 - pretty similar to
115:32 - what you saw in some of the examples so
115:36 - let's go ahead and copy this
115:39 - so i think we're done here with this
115:42 - copy paste
115:44 - and then we can put it right here
115:47 - and all we're doing is going to
115:50 - the mongodb database and we're looking
115:54 - for a user
115:55 - that has the username provided in this
115:59 - parameter
116:00 - so again what's going to happen we make
116:03 - a post request
116:05 - and we provide a json body with
116:08 - you name and password then passport as a
116:12 - middleware
116:12 - is going to look for these two fields
116:15 - finds them
116:16 - takes the value and populates these two
116:20 - parameters with those two values so
116:23 - at this time when we're executing this
116:26 - callback
116:27 - these represent the username and
116:29 - password so we can look up
116:30 - the username in the database and then
116:34 - just in a basic promise we are
116:37 - returning the user so we check if
116:40 - there's a user
116:42 - in the database you know if someone has
116:45 - actually registered already
116:47 - then or actually it's the opposite if
116:50 - there's not a user in the database
116:52 - then we're just going to return this
116:55 - should be updated to
116:56 - done to represent this done callback
117:00 - up here and what we're telling passport
117:03 - here
117:04 - is that no there was not an error in
117:07 - this
117:07 - operation but there was also not a user
117:10 - so
117:11 - go ahead and reject this and so passport
117:14 - will return
117:15 - i believe it's a 401 on unauthorized
117:19 - http status so that's the first check we
117:23 - need to do
117:24 - then um we need to check whether this
117:27 - is valid sorry for all these comments i
117:30 - had them in here
117:31 - before when i was writing this out
117:34 - so we have a variable here that says is
117:38 - valid and for right now we don't know
117:40 - how this works
117:42 - and this is not even a function that
117:44 - we've defined yet
117:46 - but basically what we're doing we can
117:48 - comment this out for
117:49 - well let's not comment it out yet what
117:52 - we're doing
117:52 - is we're putting the password through
117:56 - some sort of verification function which
117:59 - is going to
118:01 - um or we're also putting the hash in the
118:04 - salt stored in the
118:06 - user record in the database and
118:09 - we're verifying those two things against
118:11 - the password
118:12 - you'll see how that works in a minute
118:14 - but basically
118:15 - let's just assume that this returns true
118:18 - or false which it does
118:20 - and we say if the password if the login
118:23 - credentials are valid
118:25 - then we're going to return the callback
118:29 - let me update this real quick again
118:32 - these are just corresponding to this
118:34 - parameter that
118:35 - passport provides we're going to say
118:38 - nope there was no
118:39 - error and yep there was a user and this
118:42 - user was
118:43 - successfully authenticated based on my
118:46 - verification function so when we pass
118:50 - this to passport
118:51 - it's going to let us into the route and
118:54 - then finally
118:55 - if it's not valid we say nope there is
118:58 - no error
118:58 - but we did not verify this user
119:01 - correctly
119:02 - don't let them in the route and then
119:04 - finally
119:05 - we using the promise syntax we're just
119:08 - going to catch
119:09 - any of the errors that happen within the
119:12 - express application maybe on the
119:14 - database side of things
119:16 - and if we get an error we're just going
119:18 - to pass that to passport and it knows
119:20 - how to handle that
119:22 - so that is the basic verify callback
119:26 - and i'll show you really quickly what is
119:29 - actually going to happen here
119:31 - when we use it in a route so let me save
119:34 - that
119:35 - and come back to one of our routes
119:39 - so let's go down to the
119:43 - um the post login route
119:46 - so what we're going to do is include a
119:49 - middleware
119:50 - in the post login route called
119:53 - passport.authenticate
119:56 - and then in the authenticate we're going
119:59 - to say
120:00 - um the local strategy
120:04 - and we're going to pass in um
120:07 - well we can we can worry about the rest
120:10 - of this a little bit later
120:11 - all i wanted to show you here is that
120:14 - we're passing this middleware in the
120:16 - login post route
120:17 - and so basically what's going to happen
120:19 - is we make a post request to log
120:21 - in with our username and password
120:25 - and then that gets intercepted by the
120:27 - passport middleware
120:29 - and then we come in passport populates
120:32 - these two
120:32 - objects it runs this function so we're
120:35 - looking up the user in the database
120:37 - validating the credentials returning
120:39 - some sort of response
120:41 - and if we get this response right here
120:45 - where we populate a user then it's going
120:48 - to go to the next part of this function
120:50 - and it lets us in the route so that is
120:53 - the basic
120:54 - implementation of passport and now we're
120:57 - going to tie
120:58 - up some loose ends and make sure that it
121:01 - actually works and then we'll see
121:03 - it run live we just have a few more
121:07 - things we have to do
121:08 - to get this working um the first thing
121:12 - i forgot to do when we finish this up is
121:15 - actually
121:16 - complete this verify callback
121:19 - so we started with passport.views
121:23 - and then we passed in all of this stuff
121:25 - so we need to actually do this now
121:28 - um so the first thing that we need to do
121:31 - is
121:32 - let's see we have our custom fields and
121:35 - our verify
121:36 - callback so in our new local strategy
121:39 - we're going to pass in our custom fields
121:42 - and our verify callback
121:44 - and then we're going to say passport.use
121:48 - and then we're gonna pass it in that
121:51 - local strategy
121:52 - so now we actually have it configured
121:56 - and in app.js when we
121:59 - require it in somewhere
122:02 - um let's see where do we do this
122:07 - right here in the passport
122:08 - authentication we require
122:10 - in the configuration and what that's
122:13 - going to do
122:14 - is basically just take this line right
122:17 - here
122:18 - and include it in the app.js
122:21 - now that we've got our strategy
122:23 - configured we've done the bulk of the
122:25 - work
122:26 - there are a few extra things that we're
122:28 - going to have to put in here
122:30 - but i'm going to go ahead and just copy
122:32 - them in
122:33 - um and then we're going to come back to
122:35 - them a little bit later
122:37 - after we have everything working to
122:39 - understand them
122:40 - a little bit better so at the bottom of
122:42 - this configuration
122:44 - i'm just going to paste in two
122:46 - initializations
122:48 - and this is the passport.serialize user
122:51 - and deserialize user now this has to do
122:55 - with the express session
122:56 - and how we put a user into the session
123:00 - and grab a user out of the session
123:03 - basically
123:03 - what is happening is we're going to put
123:06 - the user id
123:07 - into the session and then we're going to
123:10 - when we want the user to come out of the
123:12 - session we will grab that user id that
123:15 - was stored there
123:16 - and find it in the database
123:20 - again we're going to come back to this
123:21 - so don't worry about it if you don't
123:23 - understand it
123:25 - i think this these two functions are a
123:26 - little bit tricky
123:28 - especially because there's not a whole
123:29 - lot of documentation around them
123:32 - so let's save that let me save this real
123:35 - quick
123:36 - let's come back to app.js and add in our
123:39 - last two lines that we're going to need
123:41 - before all of this is going to work so
123:45 - right after we require in the passport
123:47 - configuration
123:48 - we're going to say app.use
123:52 - passport.initialize
123:54 - and again what this is going to do is
123:57 - kind of initialize the
123:58 - passport middleware and um
124:02 - basically so that it doesn't get stale
124:05 - so we might be using
124:06 - different routes we might click to
124:09 - several different routes
124:11 - and if we don't reinitialize the
124:13 - passport
124:14 - middleware then there's a chance that
124:16 - hey maybe the user
124:18 - um maybe their session expired or
124:21 - something
124:22 - in the time that we're doing that it's
124:24 - just always safe to
124:25 - refresh the passport middleware every
124:28 - single time that we load a route
124:30 - and so that's what this is doing and
124:33 - then we need to put in passport.session
124:36 - which has to do a little bit with
124:39 - what we just talked about the serialize
124:41 - and deserialize user
124:43 - but um more so it has to do with the
124:46 - actual
124:47 - express session middleware so i know we
124:49 - talked about this a little bit
124:51 - earlier we also talked about it in a
124:53 - separate video
124:55 - but the express session gives us access
124:58 - to
124:58 - the request.session object and anything
125:02 - that we
125:02 - store on the request.session object
125:05 - inside
125:06 - any of the routes is going to be
125:09 - persisted to the database
125:11 - under the sessions collection so knowing
125:14 - this
125:15 - passport cleverly kind of
125:18 - plugs into that and bootstraps off it
125:21 - and uses it as a user authentication
125:24 - mechanism
125:25 - so we're going to actually go
125:28 - through this along with the serialize
125:31 - and deserialize
125:32 - user in a few minutes but for now let's
125:35 - see if we've got this working
125:37 - we still have a few things to do in the
125:39 - routes before it's going to work
125:42 - but let's save it and actually run the
125:44 - app
125:45 - i'm going to run this with nodemon so we
125:47 - have live updates
125:50 - so nodemon app.js
125:53 - and doesn't look like we have any errors
125:55 - at the moment so
125:57 - there is a chance that we have this
126:00 - working
126:01 - the first thing that we're going to have
126:03 - to do before the passport middleware
126:06 - is going to be effective is finish
126:09 - defining
126:10 - the password verification and generation
126:13 - functions
126:14 - so if you remember in the passport
126:16 - configuration
126:18 - in this verify callback that we had
126:20 - defined
126:22 - we called this method called valid
126:25 - password
126:26 - but in this module we haven't
126:29 - actually created this valid password
126:32 - function
126:32 - so it's not going to work as it stands
126:35 - right now
126:35 - we're going to have to go over to our
126:38 - password utils file
126:40 - and define both the valid password and
126:43 - the gen password
126:45 - functions before anything's going to
126:46 - work we're going to open up password
126:48 - utils
126:49 - in the lib folder and you'll see that i
126:52 - have basically templated out
126:54 - the two functions that we're going to
126:56 - need but to understand this
126:59 - i've actually put a slide together so
127:01 - that you can
127:02 - visualize which at what's actually
127:04 - happening with the generate
127:06 - and validate password functions
127:10 - we're going to be using the node.js
127:12 - crypto library to do this
127:14 - but before we get into the actual like
127:16 - what methods we're using
127:18 - it's better to have a conceptual
127:20 - understanding on the screen right now
127:22 - is a basic representation of
127:26 - how we generate and validate a password
127:29 - to
127:29 - a database now the cardinal rule here
127:34 - is that you're never going to store a
127:37 - plain text password in a database
127:40 - that's kind of web application 101
127:43 - i think everyone is pretty familiar with
127:45 - that but
127:47 - actually figuring out how to do that is
127:49 - a little bit more complicated
127:51 - now we talked about earlier how the
127:53 - passport.js
127:54 - middleware does not give you a
127:57 - specific way that you need to do this it
128:01 - gives you a lot of freedom
128:02 - as to how you might generate and
128:04 - validate
128:05 - the passwords that the users are
128:08 - providing
128:08 - in the login and register forms as we go
128:12 - through this
128:12 - just note that this is not the only way
128:15 - that you can
128:16 - go through this process there are other
128:18 - libraries
128:19 - other than the node.js built-in crypto
128:21 - library
128:23 - there's also different types of logic
128:26 - that you can go through
128:27 - but i've tried to keep it as standard as
128:29 - possible and kind of
128:31 - in line with what you would call best
128:34 - practice
128:35 - so anyways what's going on here is we
128:37 - have two steps
128:38 - in the process so we have the creation
128:41 - of the password
128:42 - and the verification of the password you
128:45 - can think of this
128:46 - as the register and the login so
128:50 - you're sitting there behind your
128:51 - computer you found this cool new web app
128:54 - and the first thing that the web app is
128:56 - going to ask you to do is register
128:58 - you need to give them a username and a
129:01 - password and then
129:02 - maybe a couple other things like an
129:04 - email
129:06 - first last name maybe even an address or
129:08 - something
129:10 - but what's important is that you are
129:12 - providing
129:13 - that web app with a plain text password
129:17 - you're just typing that into a field and
129:20 - when the web app receives that password
129:23 - it is still
129:24 - in plain text form we can't really avoid
129:26 - that
129:27 - that's fine but what happens is we need
129:30 - to transform that
129:32 - into something that we can actually
129:33 - store securely
129:35 - in the database without worrying about
129:37 - some hacker
129:39 - you know taking over a database and
129:41 - grabbing
129:42 - all the you know users passwords in that
129:45 - database
129:46 - once the user information is stored in
129:48 - the database we can move on to step two
129:51 - which is password verification now in
129:54 - step two you can think of this
129:56 - as the login process so when the user
129:59 - sits behind their computer
130:01 - and is typing in their username and
130:03 - password to log into your web app
130:06 - that's going to be the verification step
130:09 - and what's going to happen is they're
130:12 - going to provide you
130:13 - with their username which you're going
130:15 - to take
130:16 - and you're going to look up that user in
130:19 - your database
130:20 - using the username or maybe an email
130:24 - once you find that user in the database
130:27 - then you're going to have access
130:30 - to this password hash and the salt that
130:33 - we stored before
130:35 - so you're going to pull both of those
130:36 - values out
130:38 - and along with the password the plain
130:40 - text password that the user just
130:42 - provided you
130:43 - you're going to put those values through
130:45 - the same exact hash function
130:48 - so you pull the salt out of the database
130:51 - from that user
130:52 - and you put in the plain text password
130:55 - that they just typed in
130:56 - and so in this case we have the same
130:59 - exact
131:00 - values for these parameters as we did
131:02 - when we created the hash
131:04 - in the beginning and we know since a
131:07 - hash function
131:08 - is always going to give you the same
131:10 - exact value
131:11 - if you put the same parameters into it
131:14 - we know that we can
131:15 - generate a password hash and compare it
131:18 - to the hash that we stored in the user
131:21 - record in the database
131:23 - and if those two values match then we
131:26 - know
131:26 - that we have validated this user and
131:29 - that they have entered the correct
131:31 - credentials
131:32 - we've got a conceptual understanding of
131:34 - this process so let's go ahead and
131:36 - code it we're going to come back to vs
131:39 - code
131:40 - again i've set up the functions in the
131:43 - parameters that they require
131:45 - right here and we're going to start with
131:47 - the generate password function
131:49 - which is the step one of the process
131:52 - so this password argument is going to
131:56 - come from the user when they type
131:58 - their password into the register form
132:01 - and then here is our implementation
132:04 - now i'm going to walk you through this
132:06 - um we're using the node.js crypto
132:09 - library
132:10 - and the first thing that we're going to
132:11 - do with that is
132:13 - generate a salt which is just a
132:16 - pseudorandom value
132:18 - and it's going to add a bit of
132:20 - randomness to
132:22 - our generation of the hash
132:25 - so we have the salt then
132:28 - we pass in the plain text password
132:31 - and that salt to the pb kdf2
132:37 - method on the crypto library and then
132:40 - this last part sync just means
132:41 - synchronous
132:43 - for synchronous operation and then the
132:46 - 10
132:46 - 000 right here is going to represent how
132:48 - many iterations we're doing
132:50 - 64 is how long or how big this hash is
132:54 - going to be
132:56 - and then right here we specify which
132:59 - hashing function we're going to use
133:01 - finally we will convert this to a
133:03 - hexadecimal string
133:05 - now down here we just return those two
133:08 - values
133:09 - and we are done with this piece of the
133:12 - implementation
133:13 - to learn a little bit more about what we
133:16 - just did
133:17 - i'm going to pull up a document on
133:21 - google this is from the internet
133:23 - engineering task force
133:25 - and it's just basically a specification
133:28 - for different
133:29 - cryptography methods and
133:33 - or password-based cryptography methods
133:36 - and if we go down
133:37 - to the table of contents we can actually
133:40 - find
133:41 - the pbk
133:46 - specification which is what we were
133:48 - using from the node.js crypto library
133:50 - and you'll see that this is actually
133:52 - going to
133:54 - well we might actually be in the wrong
133:55 - spot here we're in the appendix
133:58 - see if we can get somewhere a little bit
134:00 - more straightforward
134:02 - okay we clicked on the wrong one here so
134:04 - we need to click on 5.2
134:07 - and this is going to show you kind of
134:09 - the template for
134:11 - implementing that kind of function so
134:13 - the node.js crypto library
134:14 - is just implementing this standard right
134:17 - here
134:18 - and we can actually come up and see some
134:21 - information about it
134:22 - so i think there's something on
134:24 - iteration count
134:26 - it says that they recommend at least a
134:28 - thousand
134:30 - we put in well you want to have 10
134:33 - million
134:33 - for a super secure implementation we are
134:36 - somewhere in the middle with 10 000
134:38 - which should be fine and then it also
134:41 - talks a little bit
134:42 - about the salt up here and you can read
134:45 - up about
134:45 - what that actually is a lot of this is
134:48 - just math so i don't want to get into it
134:52 - but this is kind of where the standard
134:54 - comes from so we're not just using some
134:56 - random crypto function
134:58 - this is kind of what the engine internet
135:00 - engineering
135:01 - task force has designated as this is how
135:05 - you should do it when
135:06 - you are verifying and generating
135:08 - passwords
135:10 - we can now come back and do the second
135:12 - function
135:13 - which is the valid password
135:16 - i'm not really sure why i called it
135:17 - valid password probably should be
135:19 - validate password
135:21 - but anyways here is the implementation
135:23 - for that
135:25 - all we're doing it this is basically the
135:27 - same exact thing
135:29 - remember what we went through on the
135:30 - slide we're just
135:32 - creating the same exact hash that we did
135:35 - up here except this time we're receiving
135:38 - the hash
135:39 - and the salt or well we're just passing
135:41 - the salt
135:42 - but we're getting that salt from the
135:44 - user record in the database
135:46 - and then we're getting this password
135:48 - when the user types
135:50 - it in in the login form so given the
135:53 - same
135:53 - inputs we should expect the same output
135:56 - and therefore we are going to return
135:58 - whether the hash that comes from the
136:00 - database is equal to the hash that we
136:04 - computed using the password that the
136:06 - user just provided us
136:08 - in the salt that was in the database for
136:10 - that user record
136:12 - so we're going to either receive true or
136:14 - false and this
136:15 - is what we're going to put in our
136:17 - passport js
136:19 - verify callback so let's save this
136:22 - and come back to our passport js
136:27 - configuration and you'll see that we're
136:30 - already using this right here we've
136:32 - already set it up how we want to
136:34 - we just need to import it so i'll do
136:37 - that right now
136:38 - so we'll say valid password equals
136:41 - require
136:43 - lib password utils dot
136:46 - valid password because we've exported
136:49 - them
136:50 - here at the bottom so now our
136:53 - passport.js
136:54 - implementation is complete and it should
136:58 - work
136:59 - with our application once we
137:02 - implement the two post routes for login
137:06 - and register so let's do that right now
137:09 - we'll come to the routes and you'll see
137:12 - that we have the login and register
137:14 - routes
137:15 - they're not implemented yet so we need
137:17 - to do that
137:19 - it's pretty simple so i'm just going to
137:20 - paste in the implementation
137:23 - most of this is just creating
137:26 - a user record in the database but we're
137:29 - also going to be
137:31 - implementing that first part the gen
137:33 - password function
137:35 - in this register route i think i have it
137:38 - yep i have this already imported but
137:42 - let's go ahead and rename it we'll just
137:44 - say gen password to stay consistent
137:47 - and then we need to grab the gen
137:48 - password function off of
137:51 - the import so now that we have that we
137:54 - can
137:54 - implement this so here's the
137:57 - implementation
137:59 - we'll walk through it really quickly i
138:02 - want to point out a few things
138:04 - before we get started we are grabbing
138:07 - the
138:07 - password and username values from the
138:11 - request.body.pw
138:13 - in unname fields if you remember from
138:16 - the passport configuration
138:18 - just to demonstrate the options you can
138:20 - do we went ahead and customized
138:23 - what we're expecting to see from that
138:25 - request.body object
138:28 - so we need to stay consistent and we
138:30 - need to use those
138:32 - to grab those values so you can see what
138:35 - we're doing here is we are
138:37 - generating that salt hash object so it's
138:40 - just an object
138:42 - with the salt in the hash so this one
138:45 - right here
138:46 - and that's coming from the gen password
138:49 - function
138:49 - that we just imported up here from the
138:52 - password utils
138:54 - then we are going to create a new
138:58 - user object for the database we're going
139:01 - to save that user
139:03 - we'll go ahead and just console log it
139:05 - to the terminal
139:07 - and then we are going to redirect to the
139:09 - login route
139:11 - all right so we have implemented
139:13 - register and we can go ahead
139:15 - and try that out in the browser so let's
139:18 - run it
139:20 - run the application looks like we don't
139:23 - have any errors so let's jump back to
139:25 - the browser
139:27 - type in localhost 3000
139:32 - slash register or actually we can just
139:34 - go to the home page
139:36 - and it gives us a link to the register
139:38 - we're going to enter our username
139:41 - and our password i'll just do one two
139:43 - three to keep it simple
139:45 - and we'll submit it looks like it
139:48 - properly
139:49 - did something let's come back to the
139:51 - terminal to verify that
139:55 - good news we see the object that we just
139:57 - created
139:58 - we put the username in there and then
140:00 - the hash and the salt
140:02 - that we got from the gen password
140:04 - function
140:05 - and then we can also check the database
140:08 - so let me just open the
140:10 - shell and we'll look it up so
140:13 - show databases
140:17 - we are using the tutorial db based on
140:20 - the dot env file
140:23 - so i will say use
140:26 - tutorial db and then
140:30 - we can say db dot
140:33 - users dot find and you should see
140:37 - the user that we just created
140:40 - so clearly we've got the user in the
140:42 - database and the last thing that we need
140:44 - to do
140:45 - in this entire flow is implement the
140:48 - login route
140:49 - so if we come back to what we're already
140:52 - in the file
140:53 - we have the login route that we've
140:55 - already kind of put this
140:56 - passport.authent method in a little bit
140:59 - earlier
141:00 - but i just want to add a few things to
141:02 - it
141:03 - and we'll actually simplify this a
141:05 - little bit as well
141:07 - the first thing i'm going to do is pass
141:09 - in a second
141:10 - argument to the authenticate method and
141:13 - this is just going to be an
141:14 - object that tells passport where to
141:17 - redirect
141:18 - based on the status of the login
141:22 - so if you remember the
141:24 - passport.authenticate method
141:26 - is literally just going to look in the
141:29 - passport configuration
141:31 - for this verify callback and it's going
141:34 - to
141:35 - call this function right here and
141:38 - this is going to return either a user
141:41 - if we are validating the user correctly
141:45 - and the user has provided the correct
141:47 - password
141:48 - or we're going to say false and in that
141:51 - case
141:51 - it's going to redirect to the login
141:53 - failure
141:54 - so really since we're adding conditions
141:57 - for both
141:58 - a success and a failure we don't need
142:01 - this last
142:02 - function right here so we've just
142:05 - included this
142:07 - normal callback that we see in most
142:10 - express routes
142:11 - but we don't need that in this
142:13 - implementation
142:15 - and we are pretty much done with the
142:17 - login
142:18 - post request so let's save this and give
142:21 - it a try
142:22 - in the browser we'll type in the
142:26 - same user that i did earlier one two
142:29 - three
142:29 - for the password and submit
142:33 - and it says that we have successfully
142:35 - logged in so something worked here
142:38 - now we can go to the protected route it
142:40 - says you are authenticated
142:42 - we can log out and reload now we're not
142:45 - authenticated
142:47 - and we can log in again so we can just
142:49 - go in this circle here
142:51 - it's kind of how i set it up so that we
142:52 - can see that flow
142:54 - but i'm going to be talking a lot more
142:57 - about how this is actually
142:59 - working and how you can use the passport
143:01 - middleware
143:03 - in your routes in the next video
143:06 - but let's come back one more time to the
143:09 - code
143:10 - and just kind of take a look at the
143:12 - routes that we just went through
143:14 - so we started at login
143:17 - login submitted the
143:20 - data that we put in there and the
143:24 - passport verify callback
143:26 - was called we successfully
143:30 - validated the user so we got to right
143:32 - here
143:33 - and then we come to the route the login
143:37 - post route
143:38 - and we had a success so
143:42 - we are going to come to the login
143:44 - success route
143:45 - you can see this success redirect login
143:48 - success
143:49 - so we'll come down here
143:52 - somewhere so we came to the login
143:56 - success
143:57 - then it said go to the protected routes
143:59 - we clicked that link
144:01 - and we came right here which you'll see
144:03 - a little bit of extra syntax
144:05 - we're going to go through this in the
144:06 - next video but this is how
144:09 - we would authenticate the user once
144:12 - we've
144:13 - run through that authentication flow in
144:15 - the login post route
144:17 - and then we can also log out so we've
144:20 - got a logout method
144:21 - on the request object and then
144:25 - the cycle kind of repeats
144:28 - we are officially done with the passport
144:31 - configuration
144:32 - we've got it working completely and this
144:35 - is all you're going to have to do for
144:37 - the passport local strategy
144:39 - to authenticate users into your web app
144:43 - now i did mention earlier that we were
144:45 - going to come back to something
144:47 - and it was in the passport configuration
144:49 - here at the bottom
144:51 - so these two methods the
144:53 - passport.serialize and deserialize
144:55 - and then also i think in app.js
144:59 - we have these two lines the initialize
145:02 - in session now we don't really know how
145:04 - those are working
145:06 - and i promise that we'll come back and
145:08 - explain how those are working and kind
145:10 - of see it
145:11 - for ourselves in code i would also like
145:14 - to go through
145:16 - some of these things like request that
145:19 - log out
145:19 - and request that is authenticated and
145:23 - understand what
145:24 - is going on there and also kind of
145:26 - understand
145:27 - you know you would intuitively think
145:30 - well we're probably just going to use
145:31 - the passport dot authenticate
145:34 - middleware on every single route that we
145:36 - want to authenticate
145:37 - but that's not the case for the passport
145:40 - local strategy
145:42 - so to start what we're going to have to
145:44 - understand
145:46 - is that passport.serialize and
145:49 - deserialize
145:51 - configurations so if we open up the
145:54 - passport
145:55 - file it's these two configurations
145:58 - right here that we need to understand to
146:00 - really grasp
146:02 - what passport is trying to do in order
146:05 - to understand this
146:06 - a little bit better i'm going to open up
146:08 - app.js
146:09 - and we're going to write a very basic
146:12 - middleware
146:13 - that is just going to give us it's not
146:16 - going to do anything but it's going to
146:17 - give us a little bit of debugging power
146:20 - so we've got these middlewares working
146:23 - so here's where we set up the session
146:25 - so we include that here then we include
146:28 - the passport.initialize
146:30 - and passport.sessionmiddlewares right
146:32 - here so after those have done their work
146:36 - these are happening on every single
146:38 - route request
146:39 - we'll put in our custom middleware so
146:42 - we'll say app.use
146:44 - and we're going to pass in a simple
146:46 - function
146:47 - we're just going to give it the standard
146:50 - parameters and then what we're going to
146:54 - do
146:54 - in the body of it is just console.log
146:58 - request dot session and
147:02 - then we will console.log
147:05 - request dot user so
147:09 - you'll see how this works the express
147:12 - session
147:12 - is going to create this object right
147:15 - here and the passport middleware
147:17 - should create this object here and then
147:20 - finally we have to call next
147:22 - so it doesn't crash our routes but
147:25 - basically
147:26 - every time we visit any route in this
147:28 - application
147:29 - this is going to run and we're going to
147:31 - see exactly how it's working
147:33 - so for starters let's just get this
147:36 - running
147:38 - and visit in in the browser so we'll
147:41 - come to google chrome
147:44 - we'll come back to what i've got on the
147:46 - screen here in a second
147:48 - [Music]
147:49 - let's just go to the base route so we're
147:53 - at the home page
147:54 - and you can see in the application here
147:57 - is
147:57 - our cookie that we've set which
148:00 - represents the
148:01 - express session id so that will
148:06 - we're going to just delete this really
148:08 - quick so that we refresh
148:09 - everything so now we have a clean slate
148:12 - and the express session middleware is
148:15 - going to recreate a new session
148:18 - for us to use when we press refresh
148:21 - so we pressed refresh it created a new
148:23 - session
148:24 - and in the console we should see that
148:27 - printed out
148:28 - because of the middleware that we just
148:30 - wrote right here
148:32 - so you see the session is going to show
148:35 - us the cookie
148:37 - and that's pretty much it you'll notice
148:39 - that the
148:40 - request.userobject is undefined right
148:43 - now
148:43 - and that is because we haven't yet
148:45 - authenticated our user
148:47 - using the passport.authenticate method
148:51 - so let's do that really quickly in the
148:53 - browser
148:56 - so we need to actually just visit the
148:59 - login route
149:00 - because we've already got this user in
149:01 - the database
149:03 - if you remember from last video so we
149:06 - will sign in
149:07 - and click submit and this is the same
149:10 - session id
149:12 - come back to the code and this time
149:15 - we've got a different story so this time
149:19 - let me expand this so we can see it
149:21 - so here was our
149:24 - first go around so this is what it
149:27 - printed
149:28 - and then this is the second time so
149:31 - now we have the session with the cookie
149:34 - but we
149:34 - also have this line right here and
149:37 - this was created by the passport
149:40 - middleware
149:41 - and when we executed the
149:43 - passport.authenticate
149:46 - method which is in the
149:50 - login post route so right here that's
149:53 - what we just did
149:55 - and what passport did behind the scenes
149:58 - was create this additional property
150:01 - on the express session and
150:04 - how we got this right here is through
150:07 - the passport.serialize
150:10 - user function so right here
150:13 - we ran the serialize user function we
150:16 - passed in the user id
150:19 - and we stored it under the user property
150:22 - so let's go ahead and check
150:24 - to see if this is the actual id of our
150:26 - user
150:27 - so it's 5e0f now let's go over to the
150:31 -  shell
150:32 - and we're already set up to query this
150:35 - so we'll say
150:37 - db.users.find
150:39 - and you'll see that we have the 5e0f
150:43 - user in the database so the serialize
150:46 - user function
150:48 - when we did the passport.authenticate
150:50 - method
150:51 - is going to grab that user from the
150:53 - database
150:54 - get the id of the user and then insert
150:57 - that
150:57 - into the passport.user
151:02 - or actually it would be the
151:06 - request.session.passport.user
151:08 - property so now when
151:11 - we need to grab this user from the
151:15 - the session we're going to use the
151:17 - deserialize user function
151:19 - so we're kind of seeing it all at once
151:22 - but
151:24 - to populate the request.user
151:28 - right here this is the middleware that
151:29 - we just wrote to
151:31 - print all this stuff to the terminal in
151:34 - order to populate the request.user
151:37 - we are going to grab the user from the
151:40 - database
151:41 - right here and based on the user id that
151:44 - was provided
151:46 - in the session object and then we are
151:48 - going to
151:49 - attach the found user
151:52 - to the request.user object
151:56 - so that was a mouthful and we've got
151:59 - a few more pieces to this puzzle
152:02 - so we'll come to app.js and
152:06 - these two lines are playing into this
152:08 - equation as well
152:10 - so when we say passport.initialize
152:13 - that's going to kind of re-run
152:15 - everything that we just did
152:17 - and then the passport.session is going
152:20 - to kind of work in the same way
152:22 - so every time we load a route
152:26 - these two middlewares are going to work
152:27 - together
152:29 - and what they're going to basically do
152:31 - is they're first going to check
152:33 - to see if this user property is not
152:37 - null so it would look something like
152:40 - this
152:41 - we would say if
152:47 - request.session.passport.user
152:49 - not equal to null then we are going to
152:53 - know that there is a logged in user and
152:56 - we're going to
152:57 - grab this user id from
153:00 - that property then once we grab that
153:03 - user id from the property
153:05 - we're going to use the deserialize user
153:07 - method
153:08 - pass in oops pass in the user id
153:11 - grab it from the database and then what
153:14 - we're going to do
153:15 - is populate the request.user
153:18 - and set it equal to whatever user we got
153:21 - from the database
153:22 - so that's basically what is happening on
153:25 - every single route request
153:27 - now if this user object is null
153:31 - then that means that the user is not
153:34 - currently logged in
153:36 - and we do not grab the user from the
153:39 - session
153:40 - and this property request that user is
153:43 - not
153:43 - populated if we go in the browser and we
153:47 - do the log out function or we visit the
153:50 - logout route
153:51 - you're going to notice the next time
153:53 - that we console.log
153:55 - these two properties that this user
153:57 - object is not going to exist
154:00 - so let's scroll to the scroll to the
154:02 - bottom save this
154:04 - um come up here so we're at the bottom
154:07 - let's go to the browser and
154:11 - first we've got to visit the protected
154:13 - route and when we click this button
154:15 - right here
154:16 - it's going to log us out so we click log
154:19 - out
154:19 - and reload and come back to the terminal
154:23 - and now you'll see that this passport
154:25 - object
154:26 - is going to not have this user property
154:30 - in other words we are not logged in
154:33 - now you might say okay this is a lot to
154:36 - look at
154:37 - and it's a lot of kind of funky logic to
154:40 - go through every time we want to figure
154:42 - out
154:42 - if our user is logged in or not and
154:45 - luckily
154:46 - we have some methods built onto this
154:49 - request
154:49 - object to kind of do this logic for us
154:54 - these methods were defined by the
154:56 - passport middleware
154:58 - or the passport local middleware and we
155:00 - can see this
155:01 - if we visit the repository so
155:04 - this module the request.js module is
155:07 - where this is going to kind of happen
155:09 - or where these are defined and you'll
155:12 - see a couple
155:13 - properties attached to the request
155:15 - object
155:16 - so the first one is the login property
155:19 - and
155:20 - this is actually called
155:23 - by default when we use the
155:26 - passport.authenticate method
155:28 - so we don't really have to ever use this
155:31 - on our own
155:31 - if we're using the passport.authenticate
155:33 - method
155:35 - now what's useful to us is the last
155:38 - three properties
155:39 - so first we have request.logout
155:43 - so anytime that we want to log our user
155:46 - out
155:46 - we just call this method and you'll see
155:49 - that i do this
155:50 - when we had clicked that logout button
155:54 - you'll see in the route for the log out
155:57 - route
155:58 - somewhere down here so here's my logout
156:01 - route and you can see that i have called
156:04 - that method right there which is
156:06 - basically going to delete
156:08 - the
156:12 - request.session.passport.userproperty
156:14 - from the session so that's all that
156:16 - that's doing and then next time
156:19 - we call the passport.initialize and
156:22 - passport.sessionmiddlewares
156:24 - which happens on every route it's going
156:26 - to check that property
156:28 - see that it's null and pretty much
156:30 - declare that the user has been logged
156:32 - out
156:34 - all right so the next one we have is the
156:37 - request
156:38 - dot is authenticated and this is a
156:41 - really common one we're going to use a
156:43 - lot
156:43 - and basically all this is doing is what
156:46 - we went through
156:47 - manually and there's a bunch of funky
156:51 - code here because it's part of the
156:52 - framework
156:53 - but basically all this code is doing
156:57 - is saying does the
157:02 - request.session.passport.userpropertyx
157:03 - property
157:04 - and is in it is not
157:06 - null and if that is the case then we
157:09 - declare that the user
157:10 - is authenticated because the only way
157:13 - that that
157:13 - property would have been populated is
157:17 - after we use the passport.authenticate
157:20 - method
157:21 - which is going to run the verify
157:23 - callback
157:24 - which is going to implement our custom
157:27 - login
157:27 - logic finally we have request that is
157:31 - unauthenticated i don't really use this
157:34 - it's just the opposite
157:35 - of the request that is authenticated so
157:38 - you can use it but
157:39 - it's not really all that complicated
157:43 - so we've got these methods unfortunately
157:46 - these are not documented very well
157:49 - in the passport documentation which is
157:52 - kind of a shame but
157:53 - anyways let's come back to our code
157:57 - and see how we might use these
157:59 - properties to our advantage
158:01 - so right now in our routes we are
158:04 - manually calling these things
158:07 - and right here we are manually
158:11 - checking whether the request is
158:13 - authenticated
158:14 - and then if it is we are doing something
158:17 - if it's not we're doing something else
158:20 - so in order to streamline this a little
158:23 - bit
158:24 - it would make a little bit more sense if
158:26 - we included this
158:27 - as middleware and all we're doing
158:30 - is checking if the user is authenticated
158:33 - and if the user is authenticated we just
158:36 - call the next
158:37 - callback and it goes into the route and
158:40 - if the user is not
158:42 - authenticated we return some sort of
158:45 - 401 unauthorized error so to make our
158:48 - lives a lot easier
158:50 - let's go in the routes folder you can
158:52 - really put this anywhere
158:54 - i'm just going to put it in the routes
158:55 - folder and we'll just say
158:58 - off middleware.js
159:02 - and in the off middleware js
159:05 - i'll just take you through two different
159:07 - middlewares that we could implement
159:10 - you can get as creative as you want with
159:12 - this
159:13 - but here are some pretty standard ones
159:15 - that you might use
159:16 - so we'll say module.exports
159:20 - dot is off
159:24 - equal to a middleware function
159:27 - so there's the standard middleware
159:30 - parameters or arguments
159:33 - and then we're going to do something in
159:35 - here to check whether the user is
159:37 - authenticated and if they're not we're
159:39 - going to return some sort of 401
159:42 - unauthorized error the second one we're
159:45 - going to do
159:47 - [Music]
159:48 - module dot exports dot
159:51 - is admin so currently
159:54 - we don't have an admin property
159:58 - on our user schema but we could
160:01 - easily add that and we could use this
160:04 - middleware to basically check
160:06 - whether the user is logged in and
160:09 - is an admin so that can help you kind of
160:11 - protect
160:12 - routes that are for admins only versus
160:15 - regular users we'll get to that in a
160:18 - second but first let's get this
160:20 - one done so all we're going to do is use
160:23 - that request
160:24 - dot is authenticated method that is
160:26 - attached
160:28 - from the passport middleware so we'll
160:30 - say if
160:32 - request dot is authenticated
160:36 - then we're going to just say
160:39 - next and pass it on to the next
160:42 - middleware
160:43 - in the chain if the user is not
160:46 - authenticated
160:47 - we'll just return a 401 unauthorized
160:51 - error so we'll just say
160:52 - res dot status 401
160:57 - dot json and we'll just
161:00 - put in a message that says you are
161:03 - not authorized to view this
161:07 - resource all right so that's pretty
161:10 - simple
161:12 - so if they're authenticated if they're
161:14 - logged in
161:15 - we're going to just pass it on to the
161:16 - next
161:18 - middleware in the chain if not we're
161:20 - going to just stop it right there
161:22 - and return an unauthorized error
161:25 - all right so let's test this out so we
161:27 - have the is off
161:28 - middleware if we come to our route
161:33 - let's do this let's kind of refactor
161:35 - this
161:36 - so in our protected route we're going to
161:40 - return res.send
161:43 - you made it to the route
161:46 - so something to indicate to us that we
161:50 - successfully made it into the route and
161:53 - within this route we could do whatever
161:55 - we want we could return some sort of
161:57 - data
161:58 - and to do this we will just pass in
162:02 - is off as the middleware right there
162:05 - and of course we need to import this at
162:07 - the top of this file
162:09 - so we will say is off
162:13 - equals require off middleware
162:17 - dot is off
162:20 - all right so we've got this set up and
162:23 - now
162:23 - if we try to visit the
162:26 - protected route we should hopefully see
162:30 - you made it to the route so let's try
162:32 - that
162:33 - go to google chrome and we're already at
162:36 - our protected route
162:38 - so oh it looks like we are not
162:40 - authenticated right now because we had
162:42 - logged out so let's
162:44 - log in really quick
162:48 - so we are logged in and when we click go
162:50 - to protected route we should see that
162:52 - message that we just
162:53 - put there it said you made it to the
162:56 - route so our middleware
162:57 - is working now let's visit the logout
163:00 - route
163:01 - so that we can log ourselves out and
163:03 - then see if that
163:04 - other status is going to work so
163:08 - now we went to the log out route
163:11 - and we were redirected to the protected
163:14 - route i'm
163:14 - not exactly sure how that worked but we
163:18 - got the error message that we were
163:19 - expecting and if we were using
163:22 - you know a front end we could kind of
163:25 - process
163:26 - this error in a clean manner and give a
163:29 - friendly message to the user
163:31 - so we've got our middleware working and
163:34 - now
163:34 - all we have to do is pass in
163:38 - this short variable before any route
163:41 - that we want to protect
163:43 - so the next thing is just kind of an
163:46 - added bonus
163:46 - it's not necessary for all applications
163:50 - but it's something that kind of just
163:52 - stretches your creativity a little bit
163:54 - it gets you thinking
163:56 - outside of the box and we're not just
163:58 - constrained by
164:00 - some framework that tells us that we
164:02 - need to do it this way
164:04 - so in order to implement the
164:07 - is admin we are going to come to
164:10 - the database and add one more thing
164:14 - to this user schema so we're going to
164:17 - add an admin property
164:19 - which is going to be a boolean and
164:22 - we'll save that and then we need to
164:26 - actually register a new user
164:28 - so that they have this admin property
164:32 - and we'll just by default put
164:35 - this new user as an admin um
164:38 - let's see where that happens is going to
164:41 - be
164:41 - in the register route
164:45 - um where are we okay so right here is
164:48 - where we're going to do this
164:49 - currently we're just passing in this
164:52 - data
164:53 - but i'm just going to hard code in the
164:55 - admin property
164:57 - and we're going to say true so save that
165:01 - we will come back to the browser
165:05 - and we need to go to the register route
165:10 - so let's go to register let me get rid
165:12 - of this and
165:14 - i'm going to say zack 2
165:18 - and we'll do the same password one two
165:20 - three just so i don't forget it
165:23 - submit we have put this user in the
165:25 - database
165:27 - let's go ahead and check that just
165:28 - really quickly to make sure
165:30 - so we'll come to the shell
165:34 - db.users.find
165:36 - now we have two users in the database
165:39 - let's kind of extend this
165:41 - and the second user zac2 has an
165:44 - admin property of true so
165:48 - zack the original zach is not an
165:51 - admin because we haven't added that
165:53 - property
165:55 - the second one is an admin so the first
165:57 - user
165:58 - should be able to visit an admin route
166:00 - while the second should not
166:03 - so let's test that out really quickly we
166:06 - need to make a route that will
166:08 - actually test it so let's come down to
166:11 - protected route
166:12 - just copy that and
166:15 - instead of protected we'll say admin
166:18 - route
166:19 - so the first thing we want to check is
166:21 - the is off
166:22 - we kind of have some freedom how we want
166:24 - to do this
166:26 - i'm going to go ahead and simplify
166:28 - things and just
166:30 - say is admin so we don't have to repeat
166:33 - it
166:33 - so we could do is off and then is
166:36 - admin and in the in in
166:40 - this middleware all we have to do is
166:42 - check whether that property exists
166:44 - but i'm going to go ahead and simplify
166:45 - that you'll see what i mean in a second
166:48 - so we'll say is admin we need to
166:51 - import that here at the top so
166:54 - i know this is you know not really good
166:57 - coding practice we could refactor this a
167:01 - little bit
167:02 - but we'll do it just for the sake of
167:04 - time so we've
167:06 - put the is admin middleware in there
167:09 - we've included it in the admin route
167:13 - and we'll say you made it to the
167:16 - admin route if they successfully make it
167:19 - through that
167:20 - middleware gate so now we come back to
167:23 - the auth middleware
167:24 - and let's just copy the same exact thing
167:29 - except this time we're going to say
167:32 - if request dot is authenticated
167:35 - and request.user.admin
167:40 - since this is a boolean property we can
167:42 - just say this
167:44 - so now we have two requirements to get
167:46 - through
167:47 - this authentication middleware and then
167:49 - we have the same
167:50 - exact um logic here maybe we'll change
167:54 - the message to say
167:56 - you are not authorized to view this
167:59 - resource
167:59 - because you are not an
168:03 - admin all right so we've got this
168:06 - set up and i think we should be able to
168:09 - visit the route that we just
168:13 - created so admin route let's just
168:16 - manually type that
168:17 - into here and since we haven't
168:21 - i don't think we've logged in with
168:24 - anyone yet so let's log
168:25 - in with the first user so this one
168:28 - should not be an admin
168:30 - and we'll go to the admin route
168:34 - and it'll say you are not authorized to
168:36 - view this because you're not an
168:37 - admin as we would expect now let's log
168:40 - this user out
168:41 - by just going to log out
168:44 - and then let's go to login
168:49 - we're going to log in that second user
168:52 - that does have
168:53 - admin privileges
168:56 - oh looks like we had some sort of login
168:59 - failure
169:00 - maybe i just typed it in wrong um oh
169:03 - it was because i put the wrong username
169:05 - in so it's not zac one it is zach2
169:09 - and one two three all right we are
169:12 - successfully logged in
169:14 - let's go to the admin route and this
169:16 - time we should get
169:17 - a success message you made it to the
169:20 - admin route
169:21 - so we've covered a good amount here but
169:24 - hopefully this kind
169:26 - of opens up your creativity
169:29 - into understanding how the passport
169:31 - local strategy works
169:33 - how we can use it to creatively
169:36 - authenticate and allow access to
169:39 - different resources
169:41 - based on whether a user is logged in or
169:43 - logged out
169:45 - based on whether a user has admin
169:47 - credentials
169:48 - and you could even go through some more
169:50 - complex logic
169:51 - if you wanted to by creating different
169:54 - types of middlewares
169:55 - i know it seems like we've already run a
169:57 - marathon just trying to get the
169:59 - passport local strategy implemented but
170:03 - again authentication user authentication
170:06 - is not an easy subject i think we kind
170:09 - of
170:10 - treat it as an easier subject because
170:13 - it's like okay there's only a few moving
170:15 - parts here
170:16 - it seems like on the surface but once
170:19 - you get into the implementation there
170:20 - are so many different things that you
170:22 - have to understand
170:24 - in order to debug and have
170:27 - a solid grasp around user authentication
170:31 - i want to take a minute to say congrats
170:33 - there's been a lot of content so far and
170:36 - you have finally
170:36 - implemented your first official you know
170:39 - user authentication scheme where you
170:41 - actually know what's going on behind the
170:43 - scenes
170:44 - you can walk away from this tutorial
170:46 - right now if you want to
170:48 - but there is a second part to all of
170:50 - this
170:51 - which is the jwt based authentication
170:54 - that i think
170:55 - is super super important to know and
170:57 - it's probably one of the more
170:59 - popular ways to do it as i mentioned in
171:01 - the first you know a few minutes of this
171:03 - video
171:04 - but as we saw with passport local
171:06 - strategy having all of these
171:08 - prerequisites
171:09 - we also have some prerequisites for
171:11 - implementing a jwt
171:13 - authentication strategy in this section
171:15 - we're going to be tackling
171:16 - one of those prerequisites which is
171:18 - public key cryptography
171:20 - now i will make the disclaimer that to
171:22 - implement the passport jwt strategy
171:25 - or a jwt strategy in general you don't
171:28 - need
171:29 - public key cryptography in reality you
171:31 - could very well just use
171:33 - a symmetric cryptography scheme which is
171:35 - basically where you just
171:36 - make a long secret string and store that
171:39 - in an environment variable
171:40 - and then use that to you know
171:42 - authenticate through jwt
171:44 - now i chose public key cryptography over
171:47 - something like
171:48 - you know symmetric secrets because
171:51 - of a couple reasons number one i think
171:53 - it's really cool
171:54 - um public key or asymmetric cryptography
171:58 - is a really fascinating subject and it's
172:00 - also kind of the basis
172:02 - of bitcoin in a lot of those
172:04 - cryptocurrency systems
172:05 - so not only are you getting an education
172:08 - on user authentication but you're
172:10 - getting
172:10 - a basic education on how
172:12 - cryptocurrencies work as well
172:14 - and the second reason is this is
172:16 - arguably more robust of a solution than
172:19 - a basic secret key
172:20 - but in all reality if you're still
172:22 - watching this course then you're
172:24 - probably the type of person
172:25 - that would be interested in these extra
172:28 - little details so
172:29 - let's go ahead and dive into a basic
172:31 - introduction to public key cryptography
172:34 - this is a widespread topic public key
172:37 - cryptography
172:38 - and cryptography in general can be used
172:40 - for
172:41 - several different things whether you're
172:43 - talking about user authentication
172:45 - cryptocurrency or even just secure
172:48 - transport
172:49 - over https so
172:52 - i'm going to in this video be talking
172:55 - about
172:56 - what is public key cryptography and how
172:59 - does it work from both a conceptual
173:01 - and practical level so we're going to
173:03 - walk through the basics of
173:05 - you know conceptually how it works but
173:07 - we're also going to
173:08 - look at some code and see it in action
173:12 - before i get into what public key
173:14 - cryptography is
173:16 - we need to distinguish between two terms
173:19 - so that would be asymmetric and
173:22 - symmetric
173:23 - cryptography so public key cryptography
173:26 - what you see on the screen
173:27 - is a form of asymmetric cryptography
173:30 - because you have a public and a private
173:33 - key associated with it
173:35 - now a more basic form in what is used
173:38 - for tls or transport secure layer or
173:41 - whatever
173:42 - i think that's what it is otherwise the
173:45 - protocol that we use
173:46 - to transport data securely over an
173:50 - insecure internet channel that is going
173:53 - to be symmetric cryptography
173:55 - and is identified by a single key
173:59 - so a great way to think about this is
174:03 - maybe in a classroom setting so say
174:05 - you're sitting in a classroom
174:07 - and you want to pass a secure note to
174:10 - some of you know one of your friends
174:12 - across the room
174:14 - but you want to make sure that if the
174:15 - teacher intercepts that
174:17 - message they can't read it so what you
174:20 - would do
174:21 - is before class you're going to connect
174:24 - with your friend or friends that will be
174:28 - basically interchanging notes and you
174:30 - need to come up with a secret
174:33 - key so you might just come up with a
174:36 - real simple secret key
174:38 - and that key is going to be okay we're
174:42 - going to take
174:43 - every letter in the message and we're
174:45 - going to
174:46 - increment it by two so an a
174:49 - becomes a c and then to decrypt it
174:53 - you just have to take that c and bring
174:56 - it
174:56 - down two letters to be an a so
174:59 - now that the people that are
175:02 - interchanging messages know what the
175:05 - secret key or the cipher algorithm
175:07 - is they can easily read what the teacher
175:11 - thinks is gibberish
175:13 - when the notes are passed so to encrypt
175:16 - the data
175:17 - one student is going to basically you
175:20 - know
175:21 - write something down write the message
175:23 - that they want and then they're going to
175:24 - transpose it using the cipher algorithm
175:27 - so once again an a becomes a c
175:30 - a b becomes a d and so forth then
175:34 - they'll have someone you know walk that
175:36 - note across the class or pass it from
175:38 - desk to desk
175:40 - and we'll say that the teacher
175:41 - intercepts it the teacher cannot figure
175:44 - out what the note says it just looks
175:46 - like gibberish
175:47 - but the student on the other end could
175:49 - have decrypted that message
175:51 - by using that secret cipher
175:55 - so that is what we call symmetric
175:58 - cryptography
175:59 - and obviously we need to protect that
176:03 - secret now this is again used in
176:06 - transporting messages over the internet
176:09 - it's also
176:09 - used a lot in web application
176:12 - development
176:13 - you'll commonly see something called a
176:16 - secret key
176:17 - and that is what you'll be using to
176:20 - encrypt some sort of data
176:22 - now on the other side of things we have
176:24 - public key or asymmetric
176:26 - cryptography which is a little bit more
176:29 - complicated
176:30 - and involves a private and a public key
176:33 - pair
176:34 - so these private and public key pairs
176:36 - are mathematically linked
176:38 - as we'll see a little bit later in this
176:40 - video
176:41 - but the basic gist of it is if you have
176:44 - a public key you can give this to anyone
176:48 - as long as you keep the private key
176:50 - secret and
176:52 - then we can do two things with that
176:54 - public private key pair
176:56 - the first use case is going to be
176:59 - exactly what we just talked about
177:01 - with encrypting some sort of data so
177:05 - you might think of this the way that i
177:07 - like to think of it
177:08 - is a padlock and a key so basically
177:12 - i mean this is kind of a contrived
177:14 - example but basically think about
177:17 - maybe we're sitting in that same
177:18 - classroom and we have
177:21 - some sort of lock box and so one student
177:24 - is going to write a note which is just
177:27 - going to be in plain text
177:29 - and they're going to put the note in the
177:30 - lock box so
177:32 - what they'll do now is they will
177:36 - close the lock box and lock it with
177:39 - a padlock so that padlock
177:42 - before class was actually given to the
177:45 - student by
177:46 - another student who actually owns the
177:49 - key to the padlock so just to level set
177:52 - here
177:53 - the student that's writing the message
177:54 - has the public key
177:57 - of the other student who will eventually
178:00 - receive that message
178:01 - and decrypt it with the private key that
178:04 - corresponds to that public key
178:07 - so in other words student writes the
178:09 - message puts it in the box
178:10 - locks it with the other students
178:14 - public key then we send the box across
178:16 - the room
178:17 - we'll say the teacher intercepts it
178:19 - tries to open it but of course
178:21 - they don't have the private key that
178:23 - corresponds to that padlock
178:25 - or just the physical key that will
178:27 - unlock it
178:28 - so they can't unlock it can't see the
178:30 - message but if it gets to the student
178:33 - who does have that private key
178:35 - they can just unlock the padlock open
178:37 - the box and see the message
178:40 - so that is your first use case now the
178:43 - second use case
178:44 - is a little more complicated and we're
178:46 - not going to be able to understand it
178:48 - in the form of the classroom setting
178:50 - we're going to have to get into a little
178:52 - bit more complicated math
178:54 - but that second use case is called a
178:57 - digital
178:57 - signature or identity verification
179:01 - and this comes in handy when we're
179:03 - talking about
179:04 - user authentication and is pretty much
179:07 - the entire reason
179:09 - for me making this video so again
179:12 - if you're following along the
179:13 - passport.js user authentication series
179:16 - what you're going to want to really
179:18 - focus on in this video is that second
179:20 - use case
179:21 - or identity verification as you'll see
179:25 - to use these two use cases all we're
179:28 - going to do
179:29 - is change which key we are encrypting
179:31 - and decrypting with
179:33 - so to encrypt some sort of data
179:36 - but not protect an identity we're going
179:39 - to encrypt with the public key
179:41 - and decrypt with the private key as with
179:44 - the padlock
179:45 - and key in the classroom now the second
179:48 - use case
179:49 - we're just going to flip that we're
179:50 - going to encrypt with the private key
179:52 - and decrypt decrypt with the public key
179:56 - now in order to understand this we have
179:58 - to
179:59 - understand what a trapdoor function is
180:03 - and this comes in several different
180:05 - forms but in the case
180:07 - of public key cryptography or asymmetric
180:10 - cryptography we're talking about
180:13 - elliptic curve multiplication
180:16 - we'll get to that in one second but
180:18 - first let's just
180:19 - generally understand what a trapdoor
180:21 - function is
180:23 - so basically what a trapdoor function is
180:26 - is a one-way
180:27 - function that takes some pretty big
180:30 - piece of data
180:31 - and compresses it into a deterministic
180:36 - small piece of data outcome so in other
180:39 - words
180:40 - we can have an infinitely large piece of
180:42 - data we could have
180:44 - let's say something as simple as what
180:46 - you see on the screen right now
180:48 - or we could have something as big as
180:51 - maybe an entire
180:52 - book and what we can do is we can take
180:55 - that infinitely large or small data
180:59 - and put it through what we call a trap
181:02 - door function
181:03 - in this case we're using a sha 256 hash
181:06 - function
181:07 - and that will always create
181:11 - a deterministic
181:14 - outcome so it's going to be the same
181:16 - length i think it's
181:18 - i don't remember off the top of my head
181:20 - exactly how many bytes this
181:22 - is but it's a hexadecimal representation
181:25 - of the data on the left so if we were to
181:28 - come to an
181:28 - online sha 256 hash
181:32 - calculator i've pasted in that exact
181:35 - value
181:36 - in json string form and we get out this
181:40 - hash
181:41 - value and so anytime we put this
181:44 - particular data into this sha-256 hash
181:47 - function
181:48 - we're going to get the same exact output
181:51 - every single time
181:52 - so it is deterministic you can try it
181:55 - for yourself
181:56 - now we also have to know about this that
182:00 - we cannot go backwards
182:02 - so from this data on the right there's
182:05 - no
182:05 - possible way that we can derive
182:09 - what the original data was in the first
182:12 - place
182:13 - even though we know that we're using the
182:15 - sha-256
182:16 - hash function we know that that's only
182:18 - one way you can't go the other way
182:20 - the last important thing to recognize
182:22 - about this
182:24 - is we have an infinite number space
182:28 - essentially now it's obviously not
182:31 - actually infinite but there are so many
182:34 - different combinations
182:36 - that the sha-256 hash function can
182:38 - produce
182:39 - that the chances of us having
182:43 - two different pieces of data that come
182:45 - to the same hash
182:46 - value is essentially impossible
182:50 - now there's plenty of stack overflow
182:53 - questions on this
182:54 - and you can read up on them on your own
182:56 - time
182:57 - but basically the probability of this
183:01 - guarantees that we're always going to
183:03 - get a unique hash value
183:05 - what we're interested in when it comes
183:07 - to public key cryptography or asymmetric
183:10 - cryptography
183:11 - is a one-way function or trapdoor
183:15 - function called
183:15 - elliptic curve multiplication now it's
183:18 - not actually multiplication
183:20 - it's a cryptographic function and
183:23 - basically all we need to know about this
183:26 - is that it mathematically links the
183:28 - private and public key
183:30 - so in other words using the using the
183:33 - private key
183:34 - we can derive the public key but
183:37 - having the public key we can never get
183:39 - back to that private key
183:41 - so in other words we can share the
183:43 - public key with
183:44 - anyone in the world and they'll never be
183:46 - able to figure out
183:48 - what private key corresponds to that
183:50 - public key
183:51 - this again is useful for those two use
183:54 - cases
183:55 - of either protecting some sort of data
183:58 - or verifying an identity
184:00 - we'll see a little bit more how this
184:02 - works when we actually get into the code
184:05 - but first let's kind of take a quick
184:07 - glance at
184:08 - how elliptic curve multiplication works
184:11 - so on the right you'll see the elliptic
184:14 - curve graph
184:15 - which is useful to us because given
184:18 - any point on kind of the on this graph
184:22 - we can take the tangent of that point
184:24 - and get to another point on the graph
184:27 - so say we're right here on the graph
184:31 - well this curve extends
184:34 - infinitely so we can just take the
184:35 - tangent all the way up to that curve
184:38 - so let's go to the next slide and first
184:40 - start out with what we call
184:43 - the generator point now the generator
184:46 - point is an arbitrary
184:48 - random value or coordinate that we will
184:52 - always start with
184:53 - now this point in many cases is going to
184:57 - be a fixed point that we use
184:59 - for a large private key
185:03 - i guess you could say number space so we
185:06 - always
185:07 - start with the same generator point but
185:09 - then
185:10 - the variable in the quick equation is
185:13 - the private key
185:14 - and we take that private key and we
185:16 - multiply
185:18 - the generator point by the value of the
185:21 - private key
185:22 - so again the private key is some
185:26 - infinitely well not infinitely but it's
185:28 - some
185:29 - small or large value and so we can
185:33 - just like we can take g times two and g
185:36 - times three
185:37 - we can also to do g times you know
185:40 - 10 trillion or whatever the total value
185:43 - of that private key is
185:45 - now you might ask how are we going to
185:48 - multiply
185:49 - g that doesn't make any sense this is
185:52 - a graph and how are we going to actually
185:54 - do multiplication
185:56 - well the way that that works in elliptic
185:58 - curve multiplication
186:00 - is by drawing tangents as we talked
186:02 - about
186:03 - so you start with the generator point
186:06 - and say that your private keys
186:08 - value is two now obviously
186:11 - it's never going to be two it's going to
186:13 - be a much much
186:14 - larger number and we're going to do this
186:18 - process many more times but essentially
186:21 - what's happening
186:22 - is we start with g we draw the tangent
186:25 - to that point on the curve which
186:29 - the tangent intersects this other point
186:32 - on the curve
186:33 - then from that other point we say okay
186:36 - what is the
186:36 - opposite side of the curve so we draw
186:38 - this completely vertical
186:41 - dotted line to get to this last point on
186:44 - the curve
186:44 - and that is essentially the
186:47 - multiplication
186:48 - value of our operation so
186:51 - g times 2 is going to equal this
186:55 - coordinate down here
186:56 - at the bottom so you can see how this is
186:59 - kind of it's not exactly the
187:01 - multiplication that we're used to
187:03 - but essentially what is happening is we
187:05 - start with this arbitrary generator
187:08 - point
187:08 - we multiply or we go through this
187:10 - process
187:11 - however many times the public or the
187:14 - private key value is
187:16 - and eventually we will reach a certain
187:18 - point
187:19 - on the elliptic curve and that is going
187:22 - to
187:22 - represent our public key now
187:26 - we cannot get back to the private key
187:30 - based on the public key coordinate but
187:32 - what we can do
187:34 - is we can derive that the
187:37 - private key that may be signed a message
187:40 - corresponds to the public key so if we
187:44 - so in other words what you need to
187:46 - understand is that
187:48 - using the complex math the elliptic
187:51 - curve cryptography does
187:53 - we can actually verify that a public key
187:57 - corresponds to a given private key
187:59 - mathematically
188:01 - without revealing the private key to the
188:04 - person trying to verify it
188:06 - so in other words we can decrypt a
188:09 - message
188:09 - using a public key you'll see how this
188:12 - applies a little bit later in the video
188:15 - just to recap before we get into the
188:17 - actual code
188:18 - if we want to do data encryption we're
188:21 - going to
188:22 - encrypt with the public key and decrypt
188:24 - with the private key
188:26 - if we want to do identity verification
188:28 - or a digital signature
188:30 - we are going to take the message that we
188:32 - want to sign
188:33 - and we are going to essentially sign it
188:35 - with our private key
188:37 - and then some random party you know some
188:40 - receiver of the message
188:42 - is going to have somewhere the public
188:46 - key that corresponds to the private key
188:48 - and using that public key as we just
188:51 - talked about
188:52 - we can use that elliptic curve algorithm
188:55 - to verify that yes indeed the person who
188:59 - signed it
189:00 - has the private key that corresponds to
189:03 - that public key
189:05 - okay so let's take a look at the actual
189:09 - code that will create this private and
189:11 - public key pair
189:12 - now there's of course command line
189:15 - utilities that you can use to do this
189:18 - but i wanted to kind of write it out so
189:20 - that we can explain it and understand it
189:22 - a little bit better
189:23 - let's go to vs code real quick and
189:27 - create a new file we're just going to
189:29 - call this create
189:32 - keypair.js we'll open up this file
189:38 - and i'm going to paste in some code that
189:41 - i already wrote
189:43 - so let's walk through this code really
189:45 - quick we're using
189:46 - the built-in nodejs crypto library
189:50 - and then the built-in node.js file
189:52 - system so that we can
189:54 - output the keys in this directory and
189:57 - you'll see what's happening
189:59 - is we have a single function that will
190:01 - generate a key pair
190:03 - all it's doing is using the crypto
190:05 - library to generate the private and
190:07 - public key
190:08 - using that elliptic curve multiplication
190:11 - under the hood
190:12 - and then we're going to write that
190:14 - private and public key to
190:16 - separate dot pem files in the current
190:19 - directory
190:20 - so you'll see that here is where the
190:22 - magic is actually happening
190:24 - and then down here is where we're taking
190:27 - those values and writing them to the
190:28 - files
190:30 - so you can see that we're using the
190:33 - rsa algorithm to generate the keys
190:37 - that's a pretty standard algorithm to
190:39 - use
190:40 - and then these you can just go ahead and
190:43 - look at them
190:43 - on your own if you want to pause the
190:45 - video to see what they represent
190:48 - but basically this is all the math that
190:51 - we just talked about
190:53 - and when we run this script by saying
190:57 - node create key pair it's going to
191:00 - finish
191:01 - and then you'll see on the left we have
191:04 - both
191:04 - a private key and a public key in other
191:08 - words
191:09 - this private key is something that we
191:10 - want to keep to ourself
191:12 - not share with anyone and the public key
191:15 - can be shared with
191:16 - absolutely anyone with full confidence
191:19 - that they will never be able to figure
191:21 - out
191:21 - what this private key is all right
191:24 - now that we have our private and public
191:27 - key let's go ahead and use that in both
191:29 - of those two
191:30 - use cases that we talked about earlier
191:33 - so to do this
191:35 - just remember we have the private key
191:37 - and public key saved in this current
191:39 - working directory
191:40 - so i'm going to close them i'm going to
191:43 - close the create key pair
191:45 - and then i'm going to create a new file
191:48 - called
191:48 - encrypt.js and in this new file
191:53 - we're going to write an encryption
191:56 - formula where we take some sort of data
191:59 - and we encrypt the data and we protect
192:02 - that data
192:03 - so i'll paste in the code you're going
192:05 - to see we require
192:07 - the crypto library again and then i've
192:10 - got a single function
192:11 - that's going to take a public key and a
192:15 - message
192:15 - as an argument so again if we want to
192:19 - protect data but not an identity we
192:22 - encrypt with the public key and decrypt
192:24 - with the private key
192:26 - so what this file is going to do is
192:29 - it's going to take the message that we
192:31 - give it it's going to create
192:33 - a node buffer with utf-8 formatting
192:38 - from that message and then it's going to
192:40 - pass that buffer
192:41 - into the built-in public key encrypt
192:45 - function that the node crypto library
192:47 - provides us with
192:49 - and then what we're going to do is we're
192:51 - going to export this function so that we
192:53 - can import it into
192:54 - another module so now that we have this
192:58 - we can save it and then create one more
193:01 - file called main.js
193:04 - where we're going to do a lot of the
193:06 - work let's go ahead and open up
193:08 - main.js and copy in some code
193:12 - that i already wrote a little bit
193:14 - earlier so again we're using the file
193:16 - system
193:17 - and then we're also importing this file
193:20 - right here that we just wrote
193:22 - so by importing this we have access to
193:25 - the encrypt
193:26 - with public key function and so what
193:29 - we're going to do in the main file
193:31 - is we're going to first get access to
193:34 - the public key that we created
193:36 - and stored in that pem file in the
193:38 - current working directory
193:40 - so we just use the file system to do
193:42 - that and then
193:44 - what we're going to do is create an
193:46 - encrypted message
193:47 - and store it in the encrypted message
193:49 - variable
193:50 - so you'll see that we're going to use
193:52 - the function that we defined
193:54 - in this other module we're going to pass
193:57 - in the public key that we got
193:59 - from the file system that we created
194:01 - earlier and
194:02 - here is our super secret message that we
194:05 - don't want
194:06 - anyone to be able to decrypt over a
194:09 - public channel
194:11 - so once we do that we can
194:14 - basically console log the encrypted
194:16 - message as
194:17 - a string and you'll see when i save
194:20 - and run this file that in the
194:23 - terminal you'll see some gibberish that
194:26 - we cannot decrypt
194:27 - so node main.js
194:31 - and of course we see a bunch of
194:34 - gibberish
194:35 - this means absolutely nothing to us and
194:37 - there's no chance that we figure out
194:40 - what this super secret message was based
194:42 - on this data
194:44 - so in other words this right here is
194:46 - what you're going to transport
194:48 - over any sort of insecure transport
194:51 - layer
194:52 - so to decrypt this we can do that
194:55 - with our private key so let's take a
194:58 - moment to see how that works
195:00 - we'll clear the terminal and create
195:03 - another file
195:04 - called decrypt dot
195:07 - js and when we open that
195:10 - up we can paste in a similar function to
195:14 - the encrypt
195:15 - file so we're going to require the node
195:18 - crypto library define a single function
195:21 - where we decrypt with the private key
195:24 - and then
195:24 - all this will take is our encrypted
195:26 - message
195:27 - and the private key and then it will use
195:30 - the built-in
195:31 - node crypto library private decrypt
195:34 - function
195:35 - so we're going to export this function
195:37 - so that we can import it in another
195:39 - module
195:40 - save it and then we're going to use the
195:43 - main module to actually decrypt this
195:45 - okay so you're going to have to use your
195:47 - imagination a little bit because
195:49 - we're both encrypting and decrypting in
195:51 - the same file
195:53 - but hopefully this will make a little
195:54 - bit of sense so
195:56 - at the top part of the file we have
195:58 - encrypted our super secret message right
196:01 - here
196:02 - at the bottom part we are going to
196:04 - import our private key
196:06 - and then we're going to use the decrypt
196:08 - function and we're passing that
196:10 - encrypted message
196:12 - into the decrypt function and finally
196:15 - we'll take that decrypted message
196:18 - and convert it to a string and print it
196:20 - to the console
196:21 - so what we should expect with this file
196:24 - now is that in the console we're going
196:26 - to get that gibberish message that is
196:28 - encrypted
196:29 - and then finally we will have the
196:30 - decrypted message which
196:32 - should say super secret message so let's
196:35 - run that real quick
196:37 - we'll say oop come down to the terminal
196:41 - we'll say node main.js
196:44 - and we have a problem so let's see what
196:47 - the problem is
196:49 - decrypt is not defined because i did not
196:53 - import it so let me import that real
196:56 - quick
197:00 - now that we've imported it we can use
197:02 - the function
197:03 - let's try one more time so we got the
197:07 - gibberish
197:08 - up top and then we finally got the
197:10 - decrypted message at
197:12 - the bottom so that is just a basic way
197:15 - that you can understand
197:16 - how we use private and public key pairs
197:19 - to
197:20 - protect data over an insecure transport
197:23 - layer
197:24 - in order to see how digital signatures
197:27 - work
197:27 - we're going to have to add a few things
197:29 - to our encrypt and decrypt
197:32 - modules because remember we are going to
197:35 - encrypt
197:35 - and decrypt with different keys based on
197:38 - which use case we want to
197:40 - use so let me do in the encrypt
197:43 - encrypt function or module i'm going to
197:46 - add another function
197:48 - called encrypt with private key so we
197:50 - can
197:51 - encrypt with the public key in case of
197:53 - data protection
197:54 - or we can encrypt with private key in
197:57 - case of a digital signature
197:59 - so let's go ahead and export that from
198:02 - this module real quick
198:04 - so encrypt with private key
198:14 - so now we have a module called encrypt
198:17 - which we can do both
198:18 - encryption with the private or the
198:20 - public key likewise we need to do this
198:22 - in the decrypt module
198:24 - so let me just highlight this whole part
198:26 - paste it in
198:27 - we've got an extra import here and we've
198:29 - got our function
198:31 - decrypt with public key so now that we
198:34 - have those components we can see how
198:36 - a digital signature actually works but
198:39 - mind you
198:40 - a digital signature is a little bit
198:42 - different
198:43 - than protecting data we're going to have
198:45 - to go through
198:46 - just a little bit extra work to do this
198:50 - because this is a little bit more
198:51 - complicated i'm actually going to
198:54 - make separate files for the steps of the
198:56 - process
198:58 - so with the digital signature we have
199:00 - some sort of data
199:02 - that we want to put our signature on so
199:05 - just think of it like a legal document
199:07 - you have the document itself with the
199:09 - data and you want to sign it
199:12 - and you want to make sure that the
199:13 - receiver of that data
199:15 - is assured that both the data that was
199:19 - on the document
199:20 - has not been tampered with we don't want
199:22 - someone intercepting it and changing
199:24 - some of the legal proceedings on that
199:26 - paper
199:27 - and we also want to make sure that the
199:29 - person
199:30 - we think signed it actually did sign it
199:33 - so that's step one we need to sign the
199:36 - message
199:37 - step two is actually verifying it as i
199:40 - just described
199:41 - so for step one let me go ahead and
199:43 - close all of these files
199:45 - you know what's you know what is in them
199:47 - so we will create
199:49 - a sign message dot js
199:53 - file and
199:56 - in this file let's go ahead and import
199:59 - some
200:00 - different modules so let me walk you
200:02 - through what's actually happening here
200:04 - starting from the top we have the node
200:07 - crypto library
200:08 - pretty familiar we also have the
200:11 - file system and then we have the
200:14 - encrypts and decrypt modules that we
200:16 - created ourselves
200:18 - now the last thing is this hash function
200:21 - and this is a sha 256 hash we talked
200:24 - about this a little bit earlier
200:27 - and it is a trapdoor function that takes
200:30 - a
200:30 - pretty much infinitely large or small
200:33 - piece of data
200:34 - and you put that data through the hash
200:36 - function
200:37 - and the output of that hash function
200:40 - is going to be every single time you do
200:44 - it it's going to be the same
200:45 - exact value and that value is going to
200:48 - be small enough that we can kind of
200:49 - transport
200:51 - to different places it's always going to
200:53 - be 64 characters long
200:56 - which each character is four bits so you
200:58 - have 260
201:00 - or 256 bit value that is always
201:04 - going to come out of that function no
201:06 - matter how big or small the data you put
201:08 - into it finally at the bottom
201:11 - you'll see that i have a piece of data
201:13 - this is going to be the data that we're
201:15 - going to
201:16 - sign now you'll see that i've got my
201:19 - first and last name
201:20 - and then in the social security number
201:23 - field
201:24 - we're never going to put that because
201:27 - remember
201:27 - this second use case of signing some
201:30 - sort of data
201:31 - does not protect the data itself if
201:34 - someone intercepted this data on an
201:37 - insecure channel
201:38 - they would be able to read everything
201:40 - that
201:41 - is contained in it so we never want to
201:44 - put
201:44 - any sort of confidential information
201:48 - in data that we are digitally signing
201:50 - all right so the first
201:52 - thing that we need to do is we need to
201:55 - take
201:55 - this data right here since it's pretty
201:57 - large and we need to compress it down
202:00 - into that sha-256 hash so
202:03 - to do that deleted it to do that
202:06 - i'm going to paste in some code that i
202:08 - wrote earlier
202:09 - and what this code is going to do is
202:12 - first
202:13 - store the json string value
202:16 - of this data right here
202:20 - and it's going to store that in a
202:21 - variable and what we're going to do
202:23 - is we're going to use that node crypto
202:26 - library hash function
202:28 - and we're going to hash the data that i
202:30 - just put in string form
202:32 - then we're going to convert that into
202:35 - hexadecimal format
202:37 - and this is important because the
202:40 - format that we're passing values between
202:43 - function in is actually really important
202:46 - when we're using
202:47 - the crypto library we are now ready to
202:50 - actually sign this data so let's paste
202:53 - in
202:54 - some more code first we're going to get
202:56 - access to the private key that we
202:58 - created earlier
203:00 - in second we are going to store the
203:03 - signed message
203:04 - in a variable we're going to use the
203:06 - encrypt with
203:07 - private key function that we created
203:10 - using the node built in crypto library
203:13 - we're going to pass in the the sender
203:16 - private key
203:17 - so in this case i am the sender of this
203:20 - data
203:21 - and i own a private key that i'm going
203:23 - to sign
203:24 - this message with so i will sign
203:28 - the data with my private key and
203:31 - this data is going to be in the form of
203:34 - the hash
203:34 - data so we're not just going to sign
203:37 - this big data
203:38 - object we're going to sign the hashed
203:41 - version
203:41 - of that data now the last thing that we
203:44 - have to do
203:45 - is kind of that extra step that i was
203:47 - talking about
203:48 - so if you just sent this signed message
203:52 - to someone they're not going to be able
203:54 - to do anything with it
203:56 - not only do we have to verify that
203:58 - nobody has tampered with
204:00 - our legal documents so to speak we also
204:03 - need to verify
204:05 - that the person that says they signed it
204:07 - actually did sign it
204:09 - to do that we need to provide the
204:11 - receiver of this data
204:12 - with a few additional pieces of
204:15 - information
204:16 - so those pieces of information is number
204:18 - one
204:19 - which hash function we used to hash the
204:23 - data
204:24 - number two we have to actually give them
204:26 - the
204:27 - original data so that they can
204:30 - take the hash function take the hash of
204:32 - it and then
204:33 - they can eventually take the signature
204:37 - that we provide them with
204:38 - and match it up with that hash data
204:42 - to make sure that the that i actually
204:45 - signed the data in the first place
204:47 - so let's go ahead and see what that
204:49 - looks like we'll go ahead
204:51 - and create a final piece of data so
204:53 - we'll say
204:55 - package of data
204:58 - to send to be very explicit
205:03 - and we'll paste in this data object
205:06 - so we've got an algorithm so this tells
205:08 - the receiver of data i want you to use
205:10 - the sha 256
205:12 - algorithm and what i want you to put in
205:15 - that algorithm
205:16 - is the original data that we created
205:19 - so you'll see that the original data is
205:22 - my data
205:23 - which is the original object of data
205:25 - that we will use
205:27 - and then of course we have the signed
205:30 - and encrypted data which we
205:34 - assign to the signed message right here
205:36 - so
205:37 - with this information a receiver of this
205:40 - data
205:40 - can verify using my public key
205:44 - that not only was the data not tampered
205:46 - with but i also
205:47 - signed it last let's go ahead and export
205:50 - this package of data
205:52 - so module dot exports dot
205:56 - data or let's just call it the same
205:58 - thing that we called it here
206:00 - package of data to send equals
206:04 - package of data to send so we can access
206:07 - this from
206:08 - another file to do this we're going to
206:11 - create another file
206:12 - called verify identity.js
206:17 - we'll open up that file and we'll
206:20 - put our imports in there so we need the
206:22 - crypto library
206:24 - we need that decrypt module that we had
206:27 - created on our own
206:28 - and then we need to import the data
206:32 - that we just exported from that other
206:35 - module
206:36 - so this is everything that we need to
206:38 - verify
206:39 - this message now we also need to
206:43 - bring in the public key of the sender
206:47 - so this will be made publicly available
206:50 - and we'll say that you know i sent this
206:52 - data in the first place but my friend
206:55 - jim whatever is going to be verifying it
206:59 - so jim will need my public key
207:02 - to do this which again public key
207:05 - is public and anyone can see it you can
207:07 - feel confident that they're never going
207:09 - to be able to figure out what the
207:10 - private key was
207:12 - and one thing you'll notice that i
207:14 - required this in but i
207:15 - need to grab the variable that we
207:18 - exported
207:19 - so require this module
207:23 - and the variable so our received data is
207:26 - equal to
207:27 - this object right here in the sign
207:30 - message
207:31 - file next we need to actually
207:35 - take our own hash of the data that we
207:37 - were provided
207:38 - so to do that we know that we're using
207:41 - the sha-256 hash
207:43 - and so we can use that hash function to
207:45 - hash the original data
207:47 - i'll paste this in here and you'll see
207:50 - that our hash function
207:51 - is going to be the built-in node hash
207:54 - function
207:55 - and it's going to be the algorithm that
207:58 - was in that
207:59 - data package so i know this is a little
208:02 - confusing
208:02 - but this line right here in the verify
208:05 - identity file
208:07 - is the same as this import right up here
208:11 - so where we said create hash sha 256
208:15 - we're also creating a hash and we're
208:17 - just using that
208:19 - algorithm that we've received in the
208:20 - data package
208:22 - like i said we also need the public key
208:24 - of the
208:25 - sender so we'll go ahead and get that in
208:28 - the public key variable
208:30 - the next step to doing this is we have
208:32 - to take
208:33 - that data that was signed and decrypt it
208:37 - so let's think about what this is
208:38 - actually doing
208:40 - i'm going to paste in the code and we're
208:42 - going to use our decrypt module
208:44 - we're going to pass in the public key
208:46 - right here this is the public key
208:48 - of the sender and then we're going to
208:51 - take the
208:52 - the data that we received and we're
208:55 - going to pass in the signed
208:57 - and encrypted data so if we come over
209:00 - back to the sign message let's figure
209:02 - out what this was
209:04 - so our signed and encrypted data was our
209:07 - signed
209:07 - message which basically if we
209:10 - decrypt that message what it's going to
209:13 - give us
209:14 - is the hash value that we derived from
209:18 - this
209:18 - original data so what we're going to get
209:21 - in this variable right here
209:23 - the decrypted message is simply
209:26 - a hash value so in order to verify that
209:30 - we can then take our own hash of the
209:34 - data that was provided
209:35 - in this object right here so this is the
209:39 - original data
209:40 - and if we take a hash of that and
209:42 - compare it to
209:43 - the decrypted message here they should
209:46 - match
209:47 - and if they do match we can know that
209:50 - not only was the data not tampered with
209:52 - but it was also
209:53 - signed by the person who said that they
209:56 - signed it
209:57 - one extra step we've got to do is we've
209:59 - got to turn that decrypted message
210:02 - into a string value to pass it into our
210:05 - function
210:06 - that's just a formatting thing finally
210:09 - we say
210:11 - we want to look at the hash of the
210:13 - original
210:14 - so we're going to actually take the hash
210:17 - of the data that was passed to us in
210:19 - that data package
210:21 - and then we're going to turn that into
210:24 - a hex value to verify it we'll just do a
210:27 - basic
210:28 - if then statement so we'll say if the
210:31 - hash of original hex so basically
210:34 - our own so this is the receiver of data
210:37 - jim is doing this he's taking
210:41 - a hash using the designated hash formula
210:44 - and just turning it into a hexadecimal
210:47 - value so that we
210:48 - are comparing apples to apples and then
210:50 - we're taking the decrypted message hex
210:53 - which is basically what came with that
210:57 - is what we decrypted in comparing them
211:00 - so
211:00 - if it is the same then we're going to
211:02 - say success the data has not been
211:04 - tampered with and the sender is valid
211:07 - so let's see if this works let's go down
211:10 - to our console and run
211:12 - node verify identity
211:16 - and you'll see that it says success data
211:18 - hasn't been tampered with we have the
211:20 - right sender
211:22 - so hopefully that makes sense that is
211:23 - the second
211:25 - use case of public key or asymmetric
211:27 - cryptography
211:28 - and is called a digital signature it's a
211:31 - very common way to
211:34 - verify data and identities and you'll
211:36 - see if you are following the passport.js
211:38 - series that this video is kind of
211:41 - associated with
211:42 - you'll see exactly how that works when
211:45 - we actually are
211:46 - authenticating users now just as a
211:49 - consolation
211:50 - for this video what we just did
211:54 - over the last few minutes when we were
211:56 - signing
211:57 - and verifying a message is the same
212:00 - exact process that is used with json web
212:04 - tokens
212:05 - so you might say wait a second there
212:08 - might be
212:08 - a better way to transport this package
212:11 - of data over the internet
212:13 - and you are right there is indeed a
212:16 - better way to do this
212:17 - if we were to send this package of data
212:21 - it's going to actually
212:23 - be a pretty large piece of data and it's
212:25 - going to slow
212:26 - all of our web searches down especially
212:28 - if we're using it for some sort of
212:30 - authentication
212:32 - so naturally the easier way to do this
212:35 - is to represent this piece of data in a
212:38 - much
212:38 - smaller form just like we took the
212:41 - original data and we took a hash of it
212:43 - to make it smaller
212:45 - and more transportable we can also do
212:47 - that with the data package
212:49 - that is sent to the receiver of data and
212:52 - is used to verify the original data
212:55 - let's jump into the browser real quick
212:58 - and what i have pulled up
212:59 - is jwt dot io
213:02 - which has a really simple jwt
213:07 - visualizer per se now don't focus on
213:11 - what is going on here because i have a
213:14 - separate video
213:15 - on that but just recognize
213:18 - the structure of what's going on so on
213:21 - the left
213:21 - this is our entire jwt token
213:25 - and you can see that it is pretty short
213:27 - and it would be very easy to transport
213:30 - over the internet
213:31 - in a quick and efficient manner but if
213:34 - we decode this jwt
213:37 - it has the same critical information
213:39 - that we
213:40 - saw when we were signing and verifying
213:43 - an identity
213:44 - in our code earlier so first we have
213:48 - the algorithm which is represented by
213:50 - this reg string
213:52 - and so this will tell us exactly what
213:56 - sha or sha 256 hash algorithm that we
214:00 - have to use to decrypt the data
214:03 - then we also have a payload which is
214:06 - represented by this purple string
214:08 - and you can see i guess i deleted
214:10 - something here but you can see that it
214:12 - has
214:13 - all of the information that we would
214:16 - need to include
214:17 - in that payload of data so this you
214:20 - could consider
214:20 - that legal document that we are signing
214:24 - and then finally at the bottom you have
214:26 - the actual
214:27 - signature and the signature is going to
214:31 - include um you'll see the public and
214:33 - private key here
214:34 - but this is actually just going to be
214:38 - the signature that we wrote in the code
214:40 - earlier and we can
214:42 - verify it with a public key all right
214:45 - now that you have a basic understanding
214:47 - of public key cryptography
214:49 - we can move on to understanding what is
214:51 - a json web token
214:53 - now i could of course go through a basic
214:55 - example and just show you the pieces and
214:57 - all that stuff
214:58 - but i want to take it even further as i
215:00 - promised this
215:01 - is you know hopefully one of the most
215:03 - detailed user authentication
215:05 - courses that you've ever taken and in
215:07 - that light
215:08 - i want to actually derive and sign our
215:11 - own
215:11 - implementation of a json web token using
215:14 - some of the
215:15 - internal node.js libraries the questions
215:18 - that i'm going to answer in this video
215:21 - is first what is a json web token
215:25 - we will then go into answering the
215:27 - question of
215:29 - how do we derive a json web token like
215:31 - what are the
215:32 - pieces of it and how would we actually
215:34 - create one
215:35 - using code and then finally i'll give
215:38 - you a little bit of context
215:40 - as to how it applies to user
215:42 - authentication
215:43 - among other use cases we'll start the
215:46 - video off by
215:47 - looking at the jwt or json web token
215:51 - spec
215:52 - on the internet engineering task force
215:56 - it is going let me switch to google
215:58 - chrome real quick
216:00 - you'll see that they have a write up on
216:02 - jwt's
216:04 - and the specification for using them
216:06 - we'll come back to this in a minute to
216:08 - look at a few things
216:10 - but um this is a very well established
216:13 - type of token per se i guess you could
216:16 - call it a token
216:17 - that we use to transport some sort of
216:21 - data
216:21 - on the web now something a little bit
216:24 - more friendly that we can look at
216:26 - is a website called jwt dot io
216:29 - and right here i am looking at the
216:32 - example
216:33 - jwt and we're going to be able to
216:35 - visualize
216:36 - what is going on a lot easier once we
216:39 - kind of understand what the jwt
216:41 - is we'll actually go into writing some
216:44 - code
216:45 - to kind of replicate this example right
216:48 - here
216:49 - so to understand jwt it's pretty simple
216:53 - there are three parts you have the
216:56 - header
216:56 - the payload and the signature now the
217:00 - header and the payload
217:01 - pretty easy to understand the signature
217:04 - not so much because there's actually
217:06 - multiple types of signatures that you
217:08 - can do
217:10 - and therefore it adds a little bit of
217:12 - complexity
217:13 - on top of that a signature is a digital
217:16 - signature and it has to do with public
217:18 - key cryptography
217:19 - or just symmetric cryptography depending
217:22 - on which algorithm you're using
217:24 - so it requires a little bit of
217:26 - background knowledge which is why i
217:28 - recommended
217:29 - watching that video that i had created
217:32 - on public key cryptography before this
217:34 - one
217:35 - now you'll see in the algorithm field up
217:38 - top
217:39 - we can kind of scroll through all the
217:41 - different choices that we have
217:44 - for writing a digital signature on a jwt
217:48 - but in our case since i had you watch
217:51 - the public key cryptography video
217:53 - we're going to do the rs 256 algorithm
217:57 - which is basically as you'll learn more
218:00 - when we get into the code
218:02 - is telling us two things so number one
218:05 - we're going to use rsa private and
218:08 - public keys
218:09 - that standard and then number two we're
218:12 - going to use the sha
218:13 - 256 hashing function to actually take a
218:16 - hash
218:17 - of the header and payload data
218:20 - i know that's a mouthful we haven't
218:22 - learned anything yet so
218:24 - just hold on to that knowledge in the
218:26 - back of your head we'll come back to it
218:28 - and understand it
218:29 - in a lot greater detail in a few minutes
218:32 - let's start out by getting a basic
218:35 - understanding of what a json web token
218:37 - is
218:38 - so i mentioned that it was made of three
218:40 - parts you have the header the payload
218:43 - and the signature and these are
218:45 - highlighted on the page here
218:47 - in the different colors and they are
218:50 - separated
218:51 - by a single period so the first part in
218:54 - red
218:54 - is the header then you have the pink
218:57 - part which is the payload
218:58 - and finally this turquoise part is
219:01 - the actual digital signature now
219:05 - what you're looking at right here is
219:07 - base64 url
219:09 - encoding and i'm not going to get super
219:12 - into it but just
219:13 - a few fun facts about base64 url
219:16 - encoding it's a encoding
219:20 - spec that basically aims to standardize
219:24 - character sets and it's derived from the
219:28 - base64 encoding
219:30 - which was originally created well before
219:33 - you know my time of learning to code but
219:38 - from what i understand the idea there
219:41 - was previously before the utf-8
219:44 - standard where we had you know
219:45 - standardized character sets
219:48 - there was debates over whether you know
219:51 - there should be
219:52 - four bits or five bits or seven bits or
219:54 - eight bits within a single byte
219:57 - of data and before that was standardized
220:00 - as eight
220:01 - bits per byte there was varying
220:05 - use cases and different you know
220:07 - protocols and applications would use
220:10 - different number of bits in a byte
220:13 - and so therefore you might have an
220:15 - application
220:17 - that actually cuts off the last two bits
220:20 - of data so what base64 was
220:24 - aiming to do was basically add this
220:27 - thing called
220:28 - padding into the data and so
220:31 - it makes it so that there's no chance
220:34 - that any of the data is going to get
220:36 - lost in transport and then the base 64
220:39 - url
220:40 - encoding is just one extra step because
220:43 - there were some characters within the
220:45 - base64
220:47 - encoding that are not exactly url
220:50 - friendly or file name friendly so
220:54 - converting base64 to base64 url just
220:57 - makes it safe to transport
220:59 - over the internet and we also know
221:02 - that this format in general is not going
221:05 - to
221:06 - lose any data which is obviously very
221:08 - important
221:09 - when we're talking about user
221:11 - authentication which is
221:12 - a very common use case for jwts i know
221:15 - that was a bit of a long-winded
221:17 - explanation of an encoding um not so
221:20 - interesting but
221:21 - as we actually derive this jwt
221:25 - with code you're going to see that we're
221:27 - kind of constantly having to shift
221:29 - between
221:30 - the different encodings and it's going
221:32 - to become a little bit more important
221:34 - later
221:35 - all right now that you know what you're
221:37 - looking at here on the left
221:39 - let's talk a little more conceptually
221:41 - what we're seeing here
221:42 - on the right side so on the right side
221:46 - all we've done is we've taken these
221:48 - base64 url
221:50 - encoded characters
221:53 - and we've decoded them into json
221:56 - objects and in the header you'll see
221:59 - that we just have a couple things
222:03 - we have an algorithm and a type
222:06 - and this is pretty self-explanatory but
222:09 - when you're transporting
222:11 - json web tokens over the web
222:14 - it's not always the case that the
222:16 - receiver of the json web token
222:18 - is going to know you know anything about
222:21 - the json web token to start with
222:24 - so in the header the sender of the json
222:27 - web token or the issuer
222:29 - is going to identify which algorithm
222:33 - they use to create the digital signature
222:37 - and then of course we say that the type
222:39 - of token
222:40 - is a jwt because there's actually other
222:42 - types of token
222:43 - tokens that we can use here aside from
222:46 - just json web tokens
222:48 - so we have again chosen the rs
222:51 - 256 algorithm which says we're using
222:55 - public key cryptography
222:56 - for the digital signature along with the
222:59 - sha-256
223:01 - hashing function and what we're going to
223:03 - do
223:04 - is well actually before i get into this
223:07 - let's cover what the payload is then
223:08 - we'll get into that signature
223:11 - so the payload is basically going to be
223:14 - metadata about some entity
223:18 - and in most cases it's going to be
223:21 - about a user because jwts are
223:25 - commonly used for user authentication
223:29 - so in this payload you're not going to
223:31 - see any sort of credentials
223:34 - if you see credentials in a jwt
223:37 - payload then you know that the developer
223:40 - has done something wrong
223:42 - because you should never ever put
223:44 - credentials or sensitive
223:46 - information in the payload it's publicly
223:49 - available
223:50 - anyone could decode this jwt
223:53 - just using a simple base64 url
223:56 - decoding algorithm so what this data
224:00 - gives us is just general information
224:03 - about the user so you'll see the sub
224:07 - or subject is going to tell us who the
224:09 - user is
224:11 - in many cases you'll see some sort of
224:13 - database
224:14 - id put in here so that when
224:17 - an application decodes the jwt
224:21 - they see okay here's the sub it is
224:24 - this id let me look up this id in my
224:27 - user table and retreat retrieve the full
224:30 - user
224:30 - object so that's what the sub is
224:33 - um name obviously just the name admin
224:37 - just another metadata
224:38 - property and then iat is
224:41 - issued at so it gives you the time stamp
224:44 - of when the jwt
224:46 - was issued now we also have additional
224:50 - um what they call claims that's kind of
224:52 - the proper term for these
224:54 - pieces of data we have additional um
224:58 - claims that we can define and if you go
225:01 - over to the
225:02 - specification for jwts
225:05 - you have all this information but down
225:07 - here at the bottom
225:09 - or somewhere in the middle we have the
225:11 - registered claim names
225:13 - so these are registered it says the
225:16 - following claim names are registered in
225:17 - the iana
225:18 - json web token claims registry
225:21 - established by section 10.1
225:23 - so in other words these are kind of the
225:26 - official
225:27 - claims that you'll be using and if you
225:29 - wanted to issue jwbts that would be
225:32 - interpreted by
225:34 - various applications you would want to
225:36 - use these standard claims
225:38 - so that everyone knows exactly what they
225:41 - mean
225:42 - so let's just go through the most common
225:43 - ones and then
225:45 - there's a few others at the bottom you
225:46 - can look through on your own
225:48 - so first is the issuer claim this is
225:51 - going to
225:51 - identify the issuer of the jwt
225:56 - now in our case we probably don't need
225:59 - this because
226:00 - we are both issuing and verifying a jwt
226:04 - within the same application
226:06 - but in many cases for more complex
226:09 - architectures
226:10 - you'll see a certificate authority
226:13 - who is actually being it's the
226:16 - certificate authority acts as
226:18 - the third party authority that is
226:21 - trusted
226:22 - to issue jwt tokens and that is
226:25 - literally
226:26 - all they do so we have we basically can
226:30 - establish
226:31 - a centralized authority that everyone
226:34 - trusts
226:35 - and that centralized authority will sign
226:38 - the jwts with their private key
226:41 - and because they sign it with their
226:44 - private key
226:45 - they'll say okay here's our public key
226:48 - and anyone in the world can say okay i
226:51 - trust that institution
226:53 - and i'm going to verify this jwt with
226:56 - their public key
226:57 - if it matches i know that this jwt
227:00 - was issued by a trusted authority so
227:03 - that's kind of where you'll see the
227:05 - issuer claim
227:06 - the subject claim we already covered the
227:08 - audience claim
227:10 - is going to generally be the
227:13 - resource that will accept this jwt
227:16 - so in other words um if the jwt is only
227:20 - intended to be used with
227:22 - a specific application um it would
227:25 - probably list some sort of url or base
227:27 - url
227:28 - that will identify which server the jwt
227:32 - is valid for
227:33 - so in other words if google issued a jwt
227:37 - token they might put in the audience
227:39 - claim www.google.com
227:42 - and if the jwt is attempted
227:46 - if if you attempt to use the jwt in a
227:49 - different
227:49 - context other than google.com it's going
227:52 - to be rejected
227:53 - then finally we have the expiration
227:56 - claim which basically tells you
227:58 - when or what point in time this jwt
228:01 - token
228:02 - is no longer valid there are additional
228:05 - claims that you can put in here we saw
228:07 - the iat
228:08 - issued at claim but you can also
228:12 - and this is important you can also make
228:14 - up your own claims
228:16 - this by no means has to be standardized
228:19 - you can put whatever metadata that you
228:22 - want
228:22 - in the payload and last but not least we
228:25 - have the
228:26 - signature at the bottom we've already
228:29 - kind of touched on it
228:30 - i talked a lot about how this actually
228:33 - works from
228:34 - a cryptography perspective in that video
228:37 - that i asked you to watch before this
228:39 - one
228:40 - again link is in the description for
228:42 - that
228:43 - but anyways i think it would be helpful
228:46 - to
228:47 - go through kind of a conversation
228:50 - between the server
228:51 - and the client to understand how this
228:54 - jwt is working
228:56 - in real life so i've put together a
228:59 - basic
229:01 - little representation of this and
229:04 - what we have here is what i kind of
229:07 - perceive
229:08 - as the conversation that the server and
229:10 - the client would have
229:12 - if they could talk to each other in
229:14 - human terms of course
229:16 - so the server just think of this as
229:20 - any application we're kind of removing
229:23 - the idea of certificate authorities from
229:26 - this
229:26 - basic equation we're just going to
229:29 - assume that the server
229:30 - will just say it's an expressjs
229:33 - application
229:34 - is both issuing and verifying the jwt
229:38 - tokens
229:38 - so we don't have that third party
229:40 - certificate authority in this equation
229:43 - so what's going to happen is our client
229:46 - or just
229:47 - basically our user someone sitting
229:49 - behind a computer who is
229:50 - visiting our application on the web is
229:53 - going to go to the login page
229:55 - and say hey server i want to log in to
229:58 - your application
229:59 - here's my username and my password
230:02 - then the server gets that information in
230:05 - the form of a post request
230:07 - and it's going to say okay let me check
230:09 - on that i want to go through my
230:11 - verification algorithm and look you up
230:15 - in my database to make sure that you
230:17 - exist
230:17 - and you entered valid credentials
230:22 - we'll assume that the user did so the
230:24 - server says
230:25 - okay your credentials look great i'm
230:28 - going to
230:29 - sign a jwt token or
230:32 - jwt with my private key
230:36 - that only i know about so the server
230:39 - is the only entity that has any
230:42 - knowledge of that private key
230:44 - they're going to sign it and send back
230:48 - the jwt
230:49 - in the response body so then the client
230:52 - or the user
230:54 - basically this this doesn't actually
230:56 - have any user interaction it's invisible
230:59 - to the actual person behind the computer
231:01 - but the browser
231:03 - or the frontend application is going to
231:06 - receive the
231:07 - the response and say hey thanks for the
231:10 - jwt
231:11 - i'll keep this stored in my browser's
231:13 - local storage
231:15 - until maybe it expires
231:18 - so then the client is going to
231:22 - once they're logged in they're going to
231:23 - want to do something so
231:25 - maybe this client wants to go edit their
231:28 - profile
231:29 - so they'll type in the url of the
231:31 - profile
231:32 - just say some site.com this is just an
231:35 - arbitrary value
231:37 - and then they're going to need to attach
231:40 - that jwt token
231:42 - or i keep saying jwt token
231:45 - but it's json web token to the
231:48 - http header that's called the
231:52 - authorization header
231:53 - and so in the authorization header is
231:56 - where that's going to be stored the
231:58 - server is going to receive that jwt
232:02 - in the request body and
232:05 - then we're going to say okay i just
232:08 - talked to you
232:09 - we're familiar but i still need to
232:11 - verify that jwt
232:13 - because i don't know if in the time that
232:16 - you
232:16 - chose to visit the profile did someone
232:18 - tamper with it
232:20 - so we're going to take the jwt and now
232:23 - the server says okay
232:24 - i signed it with my private key but now
232:27 - i'm going to take my public key
232:29 - that everyone knows about but i don't
232:32 - care because
232:33 - it doesn't actually matter i'm going to
232:35 - take that public key
232:36 - and verify the signature on that jwt
232:41 - and the server says okay that signature
232:44 - is indeed valid i know that
232:47 - you know you are actually you and the
232:50 - claims made
232:51 - on the body of this jwt are valid
232:54 - let me go ahead and look you up in the
232:55 - database load your user profile
232:58 - and give you the information required to
233:01 - actually edit that user profile
233:04 - so that is the basics of how a jwt
233:08 - works i'm going to in a few minutes go
233:11 - through the
233:12 - code for deriving a jwt but i will also
233:16 - mention
233:17 - again this video was intended to be kind
233:21 - of part of
233:22 - my node.js passport.js
233:25 - video series which the playlist is
233:28 - listed in the description below
233:30 - if you wanted to know more about what we
233:32 - just talked about
233:34 - how this actually works in practice
233:36 - written
233:37 - in code say for an angular application
233:41 - go ahead and follow that series through
233:43 - the end
233:44 - use the passport jwt authentication
233:48 - strategy
233:49 - and you'll see exactly how this works in
233:51 - practice
233:52 - but for now we're going to jump into the
233:55 - code editor
233:57 - and actually see this process written
233:59 - out
234:00 - how we issue a jwt and then how we
234:03 - verify
234:04 - that jwt just using the built-in
234:07 - nodejs crypto library to start off with
234:11 - we're going to go through this part
234:13 - where we issue
234:14 - a jwt to keep it as simple as possible
234:18 - i'm going to take the example off of
234:21 - jwt.io
234:23 - so if you visit this you should see the
234:24 - same thing
234:26 - and i'm going to actually be showing you
234:29 - how
234:29 - we get to this jwt how we actually issue
234:32 - this one
234:34 - and then how we verify it using the
234:37 - public and private key
234:39 - so you should be able to verify how this
234:41 - works by just coming to this site
234:44 - and you can actually follow along with
234:46 - the node.js crypto library
234:49 - so i'm going to go ahead and just copy
234:51 - this entire token
234:53 - again this is in base64 url format
234:57 - or encoding so i'm going to copy that
235:00 - and then we're going to come into the
235:01 - code editor and paste
235:04 - it in here so i first need to create a
235:07 - file
235:08 - so let's just say issue
235:12 - jwt.js
235:16 - and you can see that on the left here
235:18 - i've already pasted in the private and
235:20 - public key
235:21 - those came from that jwt.io website
235:25 - alright so i've copied in the key right
235:27 - here let me just put this
235:29 - as a string
235:32 - and store it in some sort of variable
235:38 - so we'll say const jwt equals
235:41 - that so this is the exact jwt that we
235:44 - saw from that
235:45 - example website now in order to
235:48 - properly do this we need one npm library
235:52 - and it's called base64 url so i've
235:55 - already installed it but you'll come
235:57 - down here
235:57 - to your terminal and install base64
236:02 - url to follow along with this
236:05 - so i'm going to go ahead and require
236:07 - that in real quick
236:09 - so we'll say base 64 url
236:17 - and now we can take this jwt right here
236:20 - and convert it into something that we
236:23 - can actually
236:24 - work with we now need to split up this
236:28 - jwt
236:28 - into its parts which if you remember is
236:32 - designated or delimited by this period
236:35 - so we can do that using some simple
236:37 - javascript
236:38 - so we'll say jwt parts equals
236:42 - jwt dot split and we'll specify
236:45 - that period so now if we were to
236:48 - console.log the jwt parts
236:52 - we should have an array of those three
236:54 - parts
236:55 - so let me go ahead and try that real
236:57 - quick
236:59 - and you can see that we have an array
237:01 - and the array contains the three
237:03 - different pieces of that jwt token
237:06 - again these are still in base64 url
237:09 - encoding
237:10 - let's go ahead and split these into
237:12 - variables
237:14 - so i've just written this code already
237:17 - we basically say
237:18 - header in base64 url url format
237:21 - is going to be the first one so in our
237:24 - array right here
237:25 - we're just grabbing that piece and then
237:27 - so on and so forth with the remaining
237:29 - two
237:30 - now what we have to do is we have to
237:32 - actually take this base64 url format
237:35 - and convert it to something else
237:39 - now that we have this in pieces we can
237:41 - decode this
237:42 - with the base64 url decoder
237:45 - the npm module we included up here
237:48 - and we can see the actual json objects
237:51 - that these represent
237:53 - so let me put those in variables real
237:55 - quick so we have the decoded header
237:57 - payload and signature
237:59 - and we're just using that base64 library
238:02 - and using the decode method and we're
238:05 - passing in
238:06 - the base64 url pieces
238:10 - and then finally we can console.log
238:13 - those to the terminal and you can see
238:14 - what they look like
238:16 - decoded so let's go ahead and
238:18 - console.log those
238:19 - we're just taking these three variables
238:21 - here and logging them
238:23 - save the file let's give us some space
238:26 - in the terminal here
238:28 - and let's run this again
238:31 - so you're going to see the first part is
238:35 - the same thing that we saw on google
238:38 - or on the in the browser at jwt.io
238:42 - and the second part also so these match
238:44 - perfectly
238:45 - as we would expect and then we have a
238:48 - bunch of gibberish at the bottom
238:50 - and the reason being is because we
238:53 - haven't
238:54 - actually um decrypted
238:57 - the signature yet so once we decrypt the
238:59 - signature
239:00 - then it will be in a format that we can
239:03 - understand
239:04 - a little bit better now that you've seen
239:06 - this decoded
239:07 - i'm going to actually comment all of
239:09 - this out for a second
239:11 - because we don't need this we're going
239:13 - to actually derive
239:15 - this jwt from scratch so commenting that
239:18 - out for a second we'll just space it
239:20 - down to the bottom
239:22 - and what we're going to do is actually
239:24 - create this from scratch
239:26 - by first creating the javascript objects
239:29 - that we want to
239:30 - put in the header and the payload so you
239:33 - can see that these are the exact same
239:35 - header and payload objects that we
239:38 - printed
239:38 - in json format below now obviously these
239:42 - are in
239:42 - javascript format so we will need to
239:45 - convert them
239:46 - into json format by saying using the
239:49 - json.stringify method
239:51 - so let's do that right now i pasted in
239:54 - the json.stringify method
239:56 - and stored these two objects as json
239:59 - strings
240:00 - in these two variables the next thing
240:03 - that we have to do
240:04 - because right now these are just in json
240:07 - format
240:08 - we need to actually convert that json
240:10 - format into the base64 url
240:14 - so to do that we'll use this base64 url
240:17 - library and we'll just put it through
240:19 - the basic function
240:21 - and convert it so here we go copy this
240:24 - in i'm just copying code that i wrote
240:27 - before to speed things up
240:29 - but anyways we have new variables
240:31 - hopefully these are labeled
240:33 - appropriately for you but we
240:36 - have a base64 url header and payload
240:40 - all we've done and we actually need to
240:43 - change this a little bit so we're going
240:46 - to just use our import here
240:48 - base64 url and the basic function that
240:52 - comes with that library
240:53 - is just a function to convert any sort
240:56 - of
240:56 - object into the base64 url format
241:00 - so these two variables store the correct
241:03 - format for our header and our payload
241:06 - now we have to actually sign
241:09 - and issue the jwt but first let's go
241:12 - ahead and check this
241:13 - we're just going to console log these
241:15 - two values
241:16 - to make sure that we have actually
241:19 - converted
241:20 - these original javascript objects
241:22 - correctly
241:24 - so let's go ahead and clear the terminal
241:27 - give us some space and run this again
241:32 - and you'll see these two values which we
241:34 - can actually
241:35 - check from the commented out code so
241:38 - here's our original jwt that we just
241:40 - took from the website and posted right
241:42 - in there
241:43 - and you'll see that this first value
241:45 - matches the first value
241:46 - of there and then the second one if you
241:49 - wanted to go out there and confirm that
241:51 - it also matches so we've got what we
241:54 - need
241:55 - again the last thing we have to do is
241:56 - actually take some sort of hash
241:59 - of these two pieces of data and then
242:02 - sign that hash
242:03 - and put that in the signature in order
242:06 - to sign this we need to import a few
242:08 - more libraries
242:10 - so at the top i've imported the built-in
242:12 - node.js crypto library
242:15 - and then from the crypto library we can
242:17 - also
242:19 - implement the algorithm that we're using
242:23 - for this jwt
242:24 - so this is going to allow us to sign the
242:27 - jwt
242:28 - using this specific algorithm and then
242:30 - we need the file system
242:32 - from the node.js framework so that we
242:35 - can access the private and public key
242:37 - that we have saved in this current
242:39 - directory
242:40 - now that we have our imports let's come
242:42 - down here get rid of these console logs
242:45 - and we're going to create the signature
242:48 - so the first step is to use this
242:51 - signature function
242:52 - and we want to write some sort of data
242:54 - into it so
242:56 - right here we're just passing in the
242:58 - header and the payload separated by this
243:00 - period
243:01 - and this is going to be the data that is
243:04 - actually
243:05 - hashed using the sha 256 hashing
243:08 - function
243:09 - this is all kind of done within this
243:11 - node crypto library
243:12 - but we're going to hash this data and
243:15 - then we're going to sign the hash
243:17 - so we've loaded the data in here the
243:20 - last thing that we have to do
243:21 - is load our private key which we're
243:23 - going to be signing it with
243:25 - and then use the signature function sign
243:28 - method
243:29 - to actually sign the jwt here is the
243:32 - code to do that
243:34 - copy it in first we need to load our
243:36 - private key
243:37 - that's literally just loading this
243:39 - private key pen
243:40 - file and i actually need to change the
243:43 - name for this
243:44 - to work correctly so private key dot
243:48 - pem and it's important to put this in
243:51 - utf-8
243:52 - encoding and then we are going to
243:55 - convert
243:55 - this is kind of an important part
243:59 - we are going to sign this data
244:02 - which is going to give us a base64
244:05 - encoded signature so then to actually
244:08 - derive the jwt
244:10 - we're going to have to convert base64
244:13 - to base64 url we can do that with this
244:17 - imported library right up here
244:20 - so i'll show you the code for that
244:22 - here's the code that we use to do that
244:24 - so we just basically take the signature
244:27 - that we got from the node crypto library
244:30 - and we convert it from base 64 to
244:33 - base64 url so now the signature should
244:37 - be
244:37 - in the same exact format that we were
244:40 - expecting
244:40 - earlier let's go ahead and
244:43 - verify that real quick so signature
244:47 - base64 url we'll print that out
244:51 - really quickly
244:57 - and you're going to see this value right
244:59 - here
245:00 - let's go ahead and just verify it real
245:02 - quick so here again is our jwt
245:05 - we need to come all the way out to the
245:07 - last piece of it
245:10 - and here we go there's the last piece
245:13 - and you can see that the first couple
245:15 - letters are matching up
245:16 - and if you were to go through all of it
245:18 - it's going to match
245:20 - to the character so right there
245:23 - we from scratch created a jwt token
245:28 - using the node.js crypto library
245:31 - now there is an easier way to do this
245:34 - and i will show you that in a few
245:36 - minutes
245:37 - but first we need to verify this jwt
245:40 - that we just
245:41 - issued since we already have a lot of
245:44 - the
245:45 - basics set up we're just going to
245:47 - uncomment some of this code to verify
245:49 - the signature
245:50 - so let me just make a comment for this
245:53 - first part
245:55 - probably should have just named this
245:56 - file jwt
245:58 - because we're doing both the issuance
246:00 - and the verification
246:01 - in the same file so here is the issuance
246:05 - part
246:06 - right here and then
246:10 - end of issuance
246:13 - and then here is the verification
246:18 - and we will go ahead and implement this
246:20 - now
246:21 - so when we verify at jwt
246:25 - we are basically receiving the jwt in
246:28 - the base64 url format
246:30 - in this case we just are going to use
246:33 - this one right here the one that we just
246:34 - created
246:35 - because we know that um it's exactly the
246:39 - same as that example online
246:41 - so to get the jwt parts we're going to
246:44 - uncomment that
246:47 - we will uncomment this part we don't
246:50 - need
246:50 - any of these things right here
246:54 - and i think we're set so now we can
246:57 - actually verify this jwt to do this
247:00 - we'll actually have to just create one
247:02 - more line in the imports
247:04 - and this is going to be the verify
247:07 - function
247:08 - from using the same exact algorithm
247:11 - so we've got the issue or the create jwt
247:14 - function and then the create verify or
247:17 - the verification function
247:19 - as the verifier of this jwt
247:23 - we have received the entire jwt
247:26 - right here we've split it into parts and
247:29 - now we have to actually do something
247:30 - with those parts
247:32 - so the first thing we'll do is we'll
247:34 - take the header
247:35 - and the payload and just like the
247:38 - signer of the or the issuer of the jwt
247:42 - did we're going to take the header and
247:44 - the payload
247:45 - and append them together separated or
247:48 - delimited by the period
247:50 - and since the the node.js crypto library
247:53 - only accepts base64
247:55 - encoding we need to take the base64
247:59 - url signature and convert it using the
248:02 - base64 url
248:04 - npm module to base64.
248:07 - so now that we have that we can finally
248:13 - i guess decrypt the signature so we're
248:16 - going to take our
248:17 - public key that corresponds to the
248:19 - issuer
248:20 - issuer's private key and we're going to
248:23 - decrypt
248:24 - the signature so the first thing we need
248:27 - to do
248:27 - is actually get the private or the
248:30 - public key in here
248:31 - so i'm going to just copy this line and
248:34 - use that we'll say
248:37 - public key and we just need
248:41 - public key dot pem so now that we've
248:44 - imported our public key that we're
248:46 - verifying with we are finally ready to
248:48 - verify this jwt
248:50 - so let's copy this in the signature is
248:54 - valid variable
248:55 - is basically going to run the node.js
248:59 - crypto library
249:00 - verify function that we imported
249:04 - right here so verify function
249:08 - dot verify we're going to pass in the
249:10 - public key
249:11 - that we imported from the file system
249:14 - we're going to
249:15 - pass in the jwt signature base64
249:19 - format and then the most important part
249:22 - this will really trip you up it took me
249:25 - honestly
249:26 - hours to actually get this to work
249:28 - because i
249:29 - had not included the base64
249:33 - format in the verify function so that's
249:36 - really important
249:37 - and once you've done that we should
249:39 - console.log the signature is valid
249:42 - and i think it returns a boolean whether
249:45 - it's valid or not
249:46 - so let's go ahead and try that really
249:49 - quickly
249:50 - node issue well it's not really issue
249:53 - jwt but bear with me
249:56 - we get first the signature that we were
249:59 - console logging
250:01 - right up here and then the signature is
250:04 - valid variable
250:05 - returns true so we have successfully
250:09 - verified this jwt and
250:12 - essentially we've gone through the whole
250:14 - process so we
250:15 - created the jwt from scratch and then we
250:18 - verified it from scratch
250:20 - now if you wanted you could use all the
250:22 - code that we just
250:23 - used in this example for your web
250:26 - applications to
250:27 - sign and verify jwt tokens
250:31 - but like i said earlier there is an
250:33 - easier way to do this
250:35 - and that easier way is using the json
250:38 - web token
250:40 - npm library and what this
250:43 - library is is basically an abstraction
250:47 - of the node.js crypto library and it
250:50 - gives you a little bit
250:51 - you know more options because in this
250:53 - example we were just using the rsa256
250:56 - algorithm and we didn't even get into
250:59 - okay what if we use a different jwt
251:01 - algorithm
251:02 - so the json web token library is going
251:05 - to give you a lot of flexibility
251:07 - and it also kind of abstracts away all
251:10 - of the things
251:11 - all of these you know when we have to
251:13 - convert from base64 url to base64
251:17 - you don't have to worry about doing that
251:19 - in this library
251:20 - so this would be the library that i
251:22 - would recommend using
251:24 - in any sort of web application where
251:25 - you're issuing and verifying
251:28 - jwts and in the next few minutes i will
251:31 - show you
251:31 - exactly how to use it to save us a
251:34 - little bit of time
251:35 - i've just copied in my implementation
251:39 - of the json web token library um
251:42 - if we wanted to accompl accomplish the
251:44 - same exact things that we did with the
251:46 - node
251:46 - crypto library now obviously since this
251:49 - is abstracted a little bit
251:51 - you're not going to get to see the
251:53 - little bits and pieces that are
251:54 - happening
251:55 - and you don't get to truly understand
251:57 - what is happening with the jwt
252:01 - but it does make your life a lot easier
252:04 - when you're actually coding
252:06 - so let me explain to you what's going on
252:08 - here the first thing you'll notice
252:10 - is i imported the json web token library
252:14 - i already installed it with npm install
252:17 - json web token so that is
252:20 - what that import represents we use the
252:22 - file system
252:23 - the node.js file system to grab the
252:26 - public key
252:26 - and the private key that we were using
252:29 - earlier
252:30 - so again this is the public key and
252:32 - private key from that example
252:34 - on jwt.io and then
252:37 - you'll notice this payload object is
252:39 - very similar
252:40 - we've seen it before because it's the
252:42 - exact same payload object
252:44 - but you might notice that you don't see
252:47 - the
252:48 - header and the reason being is that is
252:50 - one of the things that this library
252:52 - abstracts away all we have to do
252:56 - is provide the algorithm and the library
252:59 - creates the header on its own so you'll
253:02 - see
253:03 - in this next line we have a variable
253:05 - called the signed
253:07 - jwt which is a product
253:10 - of the json web token library
253:14 - sign method where all we have to do is
253:17 - pass in the payload object
253:19 - in javascript form so we don't have to
253:21 - do any of that json.stringify stuff and
253:24 - then
253:25 - convert it to base64 url none of that we
253:28 - can just pass in a
253:30 - javascript object then of course we pass
253:33 - in the private key that we want to
253:35 - actually
253:36 - sign it with as we know that's how
253:39 - jwts work and then finally in the
253:42 - options object
253:44 - we just have to give it the algorithm
253:46 - that we want to use
253:48 - and based on this algorithm the json web
253:51 - token library is going to
253:53 - figure out what the header needs to be
253:56 - so
253:56 - it will then combined that header and
253:59 - the payload
254:01 - just as we did with the node crypto
254:02 - library it's going to sign it
254:05 - with i actually think they use the node
254:08 - crypto library underneath the surface so
254:11 - they
254:11 - pretty much do exactly what we did
254:13 - earlier to sign this
254:15 - and then to verify it again just one
254:18 - simple line of code or
254:20 - a couple simple lines of code we just
254:22 - used the json web token
254:24 - verify method we passed it we pass in
254:27 - the signed
254:28 - jwt or this basically it's going to be
254:31 - received
254:31 - in the authorization http header
254:35 - for a web application so we take that
254:38 - jwt
254:39 - pass it into the verify function we use
254:42 - the public key that corresponds to the
254:44 - signer's private key
254:46 - in this case since we're doing the
254:48 - signing or the issuance
254:50 - and the verification it's just these two
254:54 - this key pair and then again we have to
254:57 - pass in the algorithms that
254:58 - it will accept in this case rs256
255:03 - and then we have a callback function
255:06 - in the callback function if there's an
255:08 - error we know that the
255:10 - verification has gone wrong and
255:13 - either we have the wrong public key to
255:15 - verify this jwt with or the jwt
255:19 - was tampered with and we don't want to
255:21 - use it so let's go ahead
255:23 - and just verify that this works really
255:25 - quick so you can see it in action
255:27 - i will console.log the signed jwt value
255:32 - so let's just do that first really
255:35 - quickly
255:37 - and you'll see this value right here
255:40 - which if you were to match with the
255:42 - value
255:43 - online it's going to be the same exact
255:46 - thing so um you can do that on your own
255:49 - time
255:50 - but just trust me that is the same exact
255:52 - jwt
255:53 - and then here we can go into the
255:55 - callback function
255:57 - and let's say console dot
256:01 - log air and we should expect
256:04 - that we don't see any error whatsoever
256:07 - because
256:08 - we verified this successfully so we get
256:11 - null as the air as expected and then
256:15 - we can also console.log
256:18 - the payload which is the second argument
256:21 - that it returns
256:23 - and you should get the same payload that
256:26 - we had defined
256:28 - right up here except this was when we
256:30 - issued it
256:31 - and then this is when we signed it so
256:34 - you can see how this might work
256:36 - in an actual application you might have
256:39 - a post route that is going to
256:42 - verify credentials and then it will sign
256:45 - and return a jwt in the response
256:49 - and then you might have another couple
256:52 - routes that are like authenticated
256:54 - routes
256:55 - and you might have some sort of
256:57 - middleware like passport.js
256:59 - that is going to underneath the hood use
257:02 - this jwt.verify method
257:05 - and use the public key to verify
257:08 - the jwts that are being passed through
257:11 - the authorization headers
257:13 - couple hours later and we're finally
257:15 - ready for our second form of user
257:18 - authentication
257:19 - which is the passport jwt strategy i
257:22 - think this next section is going to be
257:23 - really rewarding for you
257:25 - because we're about to take all of those
257:27 - prerequisite
257:29 - lessons that we went through whether
257:30 - that be the
257:32 - express middleware overview or
257:35 - you know the basics of cryptography
257:38 - we're going to combine those together
257:40 - and put it into our user authentication
257:42 - strategy
257:43 - this one's going to be fun so let's jump
257:45 - in the first part of this series we went
257:47 - through the passport local strategy
257:49 - and in doing so we talked a lot about
257:53 - the inner workings of the passport
257:55 - framework
257:56 - and in this second part since it's a
257:58 - little bit more advanced i'm going to be
258:00 - skipping over those details
258:04 - so if you find yourself lost
258:07 - for example in the process of
258:11 - generating and validating a username and
258:14 - password in a database
258:16 - or maybe the verify callback for the
258:19 - passport middleware
258:21 - i would suggest going back to the first
258:24 - part of this series
258:25 - and specifically just watching the
258:27 - configuration video for the passport
258:29 - local strategy
258:31 - now before we start to code i want to go
258:34 - through
258:34 - the options that we have here when
258:37 - implementing
258:38 - a jwt authentication strategy
258:41 - so we're working with the passport jwt
258:44 - middleware
258:45 - strategy but we don't necessarily
258:48 - need to and this is going to be the most
258:52 - confusing part for someone looking for a
258:54 - solution on the internet because
258:56 - there are all sorts of ways that you can
258:59 - actually implement
259:00 - a jwt strategy in your application
259:04 - and because of that you'll have people
259:06 - who understand
259:08 - json web tokens pretty well and they'll
259:10 - have their own custom strategy working
259:13 - but they won't explain kind of how they
259:15 - got to that strategy
259:17 - and it leaves you the reader of the
259:20 - tutorial
259:21 - just thinking to yourself well what's
259:22 - the actual correct way to do this
259:25 - and in this video i've stuck with the
259:28 - passport jwt middleware
259:31 - not because it's a hundred percent
259:32 - necessary but because i think it's kind
259:35 - of grounded
259:36 - and it gives us a framework to start
259:39 - with
259:39 - and then we can kind of customize on the
259:42 - fringes
259:43 - as we see fit if we were trying to
259:46 - be very complex about this and
259:50 - probably the reason you would do this if
259:52 - is if you were
259:53 - maybe trying to write your own
259:55 - authentication framework
259:57 - or you're building your own
259:59 - authentication server or something that
260:01 - you have to do that's extremely custom
260:04 - the most complex thing that you could do
260:07 - is you'd
260:08 - use the node.js crypto library and
260:11 - then pair that with your own express
260:13 - middleware
260:14 - that work together to authenticate your
260:17 - users
260:18 - now i have no interest in doing this
260:20 - because there's a lot of code that you'd
260:22 - have to write to do that
260:24 - but given the fact that we actually went
260:27 - through the process
260:28 - of issuing and verifying jwts with the
260:31 - node.js crypto library
260:33 - you already have a pretty good head
260:34 - start if you did choose to use this
260:37 - now the somewhat complex method for
260:41 - authenticating users via jwt would be
260:45 - to use something like the json web token
260:49 - npm library which is going to give you
260:53 - a little bit more abstraction you have a
260:56 - lot less things to think about when
260:57 - you're actually issuing and verifying
260:59 - the jwts
261:01 - but you're still left with writing your
261:03 - own
261:04 - custom middleware for your express
261:07 - application
261:08 - so that leads us to the least complex
261:11 - method which is what we are going to do
261:13 - and that is to use the json web token
261:16 - npm
261:16 - library so it's going to be really
261:19 - simple to
261:20 - issue and verify the jwts and then we'll
261:23 - use
261:24 - the already built framework passport.js
261:27 - and then plug in the passport jwt
261:30 - strategy into that framework
261:32 - so we have our middleware written for us
261:36 - but you don't need this like i said
261:38 - there's a lot of different ways that you
261:39 - can do jwt
261:41 - authentication the reason we're going to
261:43 - go with the passport jwt
261:45 - strategy is because it kind of just
261:48 - takes
261:48 - takes care of some of the tedious things
261:51 - like
261:52 - say air handling or extracting
261:56 - the token from the authorization http
261:59 - header
262:00 - like all of those things you have to
262:02 - write your own code for
262:03 - which is also going to be airprone and
262:06 - you've got to test it
262:08 - so we would prefer to kind of offload
262:11 - that to
262:12 - a framework that's already been tested
262:15 - and used by
262:16 - a lot of different use cases
262:19 - so that's kind of why we're starting
262:21 - with the passport jwt strategy but
262:23 - wanted to lay that out for you
262:26 - the last thing that i want to go through
262:28 - before we get into this
262:30 - is the basic conceptual flow of how
262:34 - jwt authentication is going to work
262:37 - now this slide right here assumes that
262:40 - you understand the issuance and
262:42 - verification process of
262:44 - a jwt which again was in that
262:46 - prerequisite video
262:47 - in this playlist but anyways what
262:50 - happens
262:51 - is a user is going to log into web app
262:54 - so we'll assume that they're already
262:56 - registered um they're already stored in
262:58 - the database
263:00 - our application is going to go through
263:03 - the basic password verification process
263:06 - i talked about that
263:07 - in the session based authentication or
263:09 - the passport
263:10 - local video but basically all we're
263:14 - doing is we're taking the
263:15 - the username that the user is going to
263:19 - log in with
263:20 - we look up that user in the database
263:23 - and then in the database we have a salt
263:25 - and a hash
263:26 - stored for that user then we're going to
263:29 - use some of the
263:30 - um node.js crypto library methods to
263:35 - actually take the plain text password
263:38 - that the user just passed to us
263:40 - and compare it against the salt in the
263:42 - hash that were stored for that user
263:44 - record in the database
263:46 - if the user has validated correctly
263:49 - based on our logic
263:50 - then we are going to use we'll say the
263:53 - json web token
263:55 - npm library to issue them a new jwt
263:59 - token
264:00 - now this jwt token has
264:03 - information about that user as well as a
264:06 - signature from the server itself
264:09 - so one of those pieces of information is
264:11 - probably going to be the database id
264:14 - of the user so then the user
264:17 - client which is usually a browser
264:21 - is going to store that jwt
264:24 - so back up just a second the server
264:28 - issues the jwt and sends it in the
264:30 - response body of the http request
264:33 - then the user client receives that http
264:36 - request
264:37 - and stores the jwt that it received
264:40 - there
264:41 - in local storage or maybe even a cookie
264:44 - it doesn't exactly matter where you
264:46 - store it it just has to be
264:48 - persistent storage in the browser then
264:51 - on
264:51 - every single http request that requires
264:54 - some sort of authentication
264:56 - so maybe you're trying to access a
264:58 - protected api
264:59 - the user is going to or the user client
265:02 - is going to attach that jwt in
265:06 - most commonly but not always the
265:09 - authorization
265:10 - http header the important thing is that
265:13 - you put that jwt in the correct header
265:17 - that the server is
265:18 - expecting and the authorization header
265:22 - is just
265:23 - the most common that you'll probably see
265:26 - then
265:26 - the server looks for that jwt in the
265:28 - authorization header
265:30 - because you've coded it to do so and
265:32 - it's going to use the json web token
265:35 - library to verify the signature of the
265:38 - jwt
265:39 - if the signature is verified we know two
265:42 - things
265:43 - we know that the jwt has not been
265:45 - tampered with none of the data in it has
265:47 - been tampered with
265:48 - we know that it also came from the
265:50 - person that we expected it to come from
265:53 - so if the signature is valid the server
265:56 - then will decode
265:57 - the jwt which is in base64
266:00 - url encoding so all we're doing is just
266:03 - taking that from base64
266:05 - url to json format
266:08 - then we will read the um the payload
266:12 - which is going to have information about
266:14 - the user so we're going to probably go
266:16 - for the payload.subfield
266:18 - that's the most common place to find
266:21 - this information
266:22 - and it's where we're going to implement
266:23 - it in this video
266:25 - and we're going to grab from that field
266:28 - is going to be the database id for the
266:30 - user
266:31 - so then the server is going to take that
266:33 - id look up the user in the database
266:37 - and then now it has the full user object
266:39 - it can do whatever it wants with that
266:41 - user object
266:42 - in our case it's going to attach it to
266:44 - the um
266:45 - express request object and then we can
266:49 - use it within our routes
266:51 - and then finally once all that has
266:53 - happened
266:54 - the user is going to have access to the
266:57 - resource
266:58 - that they requested and our flow
267:01 - is complete that's the process if you
267:04 - ever find yourself confused as to what
267:06 - we're doing
267:07 - with the code later in this video in the
267:09 - next couple videos
267:11 - i suggest that you kind of keep this you
267:13 - know pause the video on this slide take
267:15 - a screenshot of it
267:17 - maybe even print it out so that you know
267:18 - exactly the
267:20 - the pseudo code steps that we are going
267:22 - through
267:24 - okay so the next thing that we'll do is
267:27 - come back to our
267:28 - code and what i have open is
267:31 - a github repository that you can
267:33 - download yourself
267:35 - and how i've structured it is we have
267:38 - two branches
267:39 - on this repository let me see if i have
267:42 - it open in the browser we can just visit
267:44 - it there
267:46 - there we go so here's the repository
267:49 - that we
267:49 - that we have i just finished it up a few
267:51 - minutes ago
267:53 - but basically we have two branches to
267:55 - work with
267:56 - so the first branch that we have is
267:58 - going to be master
268:00 - and this is what you're going to have is
268:01 - the default
268:03 - when you clone this and it's going to
268:06 - give you
268:07 - a basic starter skeleton for
268:11 - implementing the jwt authentication
268:13 - strategy
268:15 - as i talked about in other videos my
268:17 - goal here is not to teach you how to
268:19 - write an
268:20 - angular app it's not to teach you how to
268:22 - write an express app
268:24 - and it's not to teach you how to use a
268:26 - database with express
268:27 - the goal here is to solely focus on the
268:30 - authentication piece
268:32 - so what i've done in this template is
268:34 - i've done
268:35 - all the implementation for all of those
268:38 - pieces that i don't want to cover
268:40 - and i've left blank the specific pieces
268:44 - that relate to the authentication
268:46 - alright so when you when you clone this
268:49 - and you
268:50 - come back to whatever code editor that
268:52 - you're using
268:54 - you'll go ahead and npm install in the
268:56 - base
268:57 - of the folder and then you also
269:00 - over here i'm in the angular folder so
269:03 - right here you'll go in the angular
269:06 - folder and also type
269:07 - npm install once you've done that then
269:10 - you'll go to the dot env file
269:13 - and you're going to enter these three
269:16 - variables
269:17 - now you don't necessarily have to do
269:19 - this but
269:20 - i guess if you're using this as like
269:22 - kind of a starter
269:24 - you'll eventually need to implement a
269:26 - production
269:27 - database string but this is going to be
269:30 - entirely sufficient right here
269:33 - and then you're also going to have to
269:35 - come over to
269:37 - this script right here generate key pair
269:41 - and we talked about this in the
269:43 - prerequisite video
269:45 - on public key cryptography and this is
269:48 - the exact
269:49 - file that i used in that video and all
269:52 - it's going to do
269:53 - is create an rsa
269:56 - public in private key pair and then it's
269:59 - going to save it to the current
270:00 - directory
270:02 - now our passport jwt strategy is going
270:04 - to use
270:05 - this public key pair public private key
270:08 - pair
270:08 - to issue and verify the jwts
270:12 - so you're going to need to generate this
270:15 - the one thing that i'll note about
270:16 - running this file if you run into an
270:19 - error um trying to run this then it's
270:21 - probably because your node.js version is
270:24 - not great enough
270:25 - i think there is some method here um
270:29 - i don't know which one exactly it might
270:31 - have been the generate key pair sync
270:34 - from the crypto library but it was only
270:37 - implemented
270:37 - in i think it was version um
270:40 - maybe 10 or something you can go ahead
270:44 - and find that we're in the master branch
270:45 - right here but in the final
270:48 - branch you'll see exactly how to start
270:50 - the app
270:52 - and it's it gives you the required
270:54 - node.js version i think it's like 10.
270:56 - let's go let's just verify this right
270:58 - now
270:59 - um so let's go skip over to the final
271:03 - branch which has the
271:04 - final implementation of everything and
271:08 - it's going to tell you that you need
271:09 - version
271:10 - 10 point x or greater to do this script
271:13 - right here
271:14 - all right so make sure that you have
271:16 - that
271:17 - [Music]
271:18 - set up and then you're going to just say
271:21 - node
271:22 - generate key pair and press enter and
271:25 - what this will do
271:26 - i might as well just do this right now
271:29 - so let's delete what i've got right
271:31 - here already and then say node generate
271:34 - key pair and you'll see in the left side
271:37 - here
271:38 - it's going to pop up in a second you
271:41 - should see
271:41 - the public and private key pair that i
271:43 - just created
271:45 - um let's refresh it there we go so we
271:47 - have the private key and the public key
271:50 - and you should be good there and then
271:52 - the last thing
271:53 - that you need to know about the setup i
271:56 - think
271:57 - hold on one second that was actually it
272:01 - so that's all you need to do to set up
272:03 - uh you also need to sorry you also need
272:05 - to run
272:06 - the mongodb database in the background
272:09 - um so go ahead and do that before you
272:12 - run the app
272:14 - and then when we actually run this app
272:16 - we're going to
272:17 - um it's not going to work here because i
272:20 - haven't implemented everything
272:21 - but we're going to run node app.js in
272:24 - the root
272:25 - and then ng serve in the angular
272:29 - application
272:29 - and then we're just going to visit the
272:31 - angular application
272:33 - to run the app but that angular
272:36 - implementation
272:37 - is the last video in the series if
272:39 - you're not interested in that
272:41 - then that's totally fine it's totally
272:43 - optional
272:44 - but it's just a common thing to see jwt
272:47 - authentication in a single page
272:49 - application
272:50 - they're pretty compatible so that's why
272:53 - i decided to include that last
272:55 - video that last optional video okay
272:58 - so you should be set up completely with
273:01 - the repository
273:02 - you've cloned it you've done your setup
273:03 - steps now let's take
273:05 - a very quick look at the code
273:08 - i'm going to perf purposely try to fly
273:11 - through this
273:12 - and i'll assume that you're going to go
273:14 - through on your own and get
273:16 - yourself familiar with what is here
273:18 - already
273:19 - but i definitely want to go through a
273:21 - few things
273:22 - here so we'll start with the express app
273:25 - because that is kind of the required
273:27 - piece
273:28 - let's open up app.js and you'll see that
273:31 - we already have kind of our skeleton app
273:33 - set up so of course we have express
273:36 - we're going to import the cores module
273:39 - and the reason being
273:41 - is because in the optional
273:44 - final video where we go through how to
273:46 - implement this with angular
273:48 - we're going to need to make http request
273:52 - from localhost 4200 to localhost 3000
273:56 - so from the angular app to the express
273:58 - app
273:59 - so you're going to need this course
274:01 - piece in here
274:02 - um path just going to give us access to
274:04 - the um
274:06 - the path that we want to save things in
274:07 - the file system node.js
274:10 - and then we're requiring in passport
274:14 - um the dot m configuration i talked
274:16 - about this in a previous video
274:18 - but basically gives us access to um
274:21 - the environment variables stored in the
274:24 - dot env
274:25 - file and we access those with process
274:28 - dot env dot variable
274:31 - name so that's how you will do that
274:35 - set up our basic express app we're going
274:38 - to import the configuration for the
274:41 - database
274:43 - which is right here um just scroll
274:45 - through here it's basically saying
274:47 - if we're in production environment
274:50 - connect to the production string
274:52 - if not connect to the development string
274:55 - which is just running on localhost and
274:58 - once it's connected we should just get a
275:00 - little message that says
275:01 - it's connected pretty simple there
275:04 - all right so then we require in our
275:07 - database models
275:08 - which is one model and it is the user
275:11 - so let's open up that real quick same
275:14 - exact user schema that we used in the
275:17 - first part of this
275:18 - with the passport local strategy and
275:21 - we're just having a username
275:23 - and then the hash and salt will
275:24 - represent the password in the database
275:28 - then we will require in the
275:32 - passport configuration which is where
275:34 - we're going to configure the passport
275:36 - jwt
275:37 - strategy now it's a little bit weird
275:39 - syntax
275:40 - but basically in the passport
275:43 - configuration
275:44 - we are exporting a function that takes
275:48 - the passport object
275:50 - so we're importing the
275:53 - passport library in app.js
275:57 - and then we're going to pass this
276:00 - variable
276:01 - right here into the configuration
276:04 - function
276:05 - which will then receive access to that
276:08 - and then in the body of the function it
276:10 - will actually do the configuration
276:12 - on that object so that's kind of how
276:15 - that's working
276:16 - we'll come back to that quite a bit so
276:18 - don't worry about it
276:19 - then we will initialize passport this is
276:22 - required for
276:23 - any passport strategy you always have to
276:27 - initialize it so that it runs every time
276:30 - that you make a route request these are
276:34 - pretty simple
276:35 - just body parser middleware except
276:38 - now express has their own implementation
276:41 - so we don't
276:42 - have to do the body parser
276:45 - middleware that you're used to seeing
276:46 - probably so something like app.use
276:50 - bodyparser.json we don't have to do that
276:53 - because express has their own
276:55 - implementation now here's the cores we
276:58 - talked about
276:59 - this line right here is going to allow
277:02 - you to
277:03 - kind of combine the angular and
277:06 - express apps since the angular thing is
277:08 - optional i'm not going to
277:10 - go through it too much but it's going to
277:12 - basically if we come over to angular
277:15 - and type ng build it's going to build
277:18 - all of the assets all the static assets
277:21 - for that
277:21 - application into this public folder and
277:24 - then
277:25 - express is going to use that public
277:27 - folder
277:28 - as the um static directory so in other
277:32 - words
277:32 - express is going to use the angular
277:35 - build
277:36 - as the front end for the application
277:39 - all right so that's what that's doing
277:41 - we're requiring requiring
277:43 - in our routes which should just be um
277:47 - okay so here's a basic route
277:50 - configuration if you wanted to extend it
277:52 - easily you could just add more route
277:54 - files and then
277:56 - add you know another line here that
277:58 - would say
277:59 - something like users will say
278:04 - i don't know something like courses
278:08 - maybe you're building some sort of
278:10 - course module
278:11 - and then you would have something
278:13 - similar to users right here where we
278:15 - have
278:15 - all of the user routes so that's kind of
278:18 - how you would extend that
278:20 - and then in the user routes we just have
278:22 - a protected route
278:24 - which is going to allow us to test
278:26 - whether we did the jwt
278:28 - authentication correctly then we have
278:31 - our standard login and register post
278:34 - routes
278:35 - which is going to allow us to issue the
278:38 - jwt
278:39 - and kind of validate the jwt
278:42 - and finally we have app.listen which
278:45 - will listen
278:45 - on localhost 3000.
278:48 - so that is the basic express app that
278:51 - we're working with
278:52 - and again i would hope that you would go
278:56 - through this and get yourself a little
278:57 - bit
278:58 - more familiar but if you built a lot of
279:00 - express apps
279:01 - in the past this probably looks like a
279:04 - pretty familiar structure
279:06 - now in the angular app i will go ahead
279:10 - and save that
279:11 - we're not going to go through what's
279:13 - happening in the angular app
279:15 - until you actually get to the video on
279:18 - angular so it kind of if you're not
279:20 - wanting to watch that we're not going to
279:22 - go through it and waste your time
279:24 - with that i think i've gone through
279:26 - everything that we need to
279:28 - to get started with the passport jwt
279:31 - user authentication strategy and
279:35 - like the passport local strategy that we
279:37 - did earlier in this series
279:39 - it's going to follow a pretty similar
279:41 - structure
279:42 - so just like we did in the passport
279:44 - local or
279:45 - pretty much any passport strategy we're
279:48 - going to need something called a verify
279:50 - callback so in other words when we're in
279:53 - our routes
279:55 - so say we're in our login route
279:59 - and we pass in a passport.authena
280:02 - method what that method is going to do
280:05 - is call the verify callback that we have
280:09 - defined
280:10 - in the passport configuration so if we
280:13 - open up config
280:15 - js it's going to be defined
280:18 - right here so whatever we define within
280:21 - these brackets
280:22 - is what is going to be called when we
280:25 - use the passport.authenticate method
280:28 - as with any new package let's go ahead
280:30 - and look at some of the documentation
280:33 - so the documentation for passport jwt
280:37 - i have it pulled up right here you could
280:39 - also
280:40 - go to strategies on the home page and
280:43 - click passport jwt
280:45 - to find it so the
280:49 - documentation like most strategies
280:52 - is not necessarily uniform all these
280:55 - strategies are coded by different
280:57 - developers so it's all
280:59 - based on how that developer is going to
281:02 - put it in there so
281:03 - you can see here it's a little bit
281:05 - jumbled up but it gives us
281:07 - most of what we need to know the first
281:09 - thing that i'll draw your
281:11 - attention to is going to be right here
281:15 - and you'll see that just like the
281:16 - passport local strategy
281:18 - the passport middleware as like a
281:21 - framework is going to expect the same
281:23 - three responses
281:25 - so if our callback returns some sort of
281:29 - error
281:29 - whether it be a database error or an
281:32 - express application error
281:34 - we pass in the done callback
281:37 - with the air parameter as the first
281:40 - parameter and then false
281:42 - for the user object then if we
281:45 - successfully authenticate the user we
281:48 - say that there's no error
281:49 - and here's the user object which will
281:51 - eventually be attached to the
281:54 - express request object and then finally
281:58 - if there is no error within our
282:02 - application
282:03 - but there's also an invalid user
282:06 - then we're going to say there's no error
282:08 - but there's also no user
282:10 - so these three responses to this
282:13 - verify callback is how passport knows
282:16 - what to do
282:18 - all right so now we got that covered
282:19 - let's look at some of the options that
282:21 - we're going to
282:22 - be dealing with when we're using the
282:26 - passport jwt strategy
282:28 - so as we know we're going to call
282:31 - passport.use
282:33 - and then we're going to pass in a new
282:35 - some sort of strategy
282:37 - in this case it's the jwt strategy and
282:40 - then that strategy is usually going to
282:42 - take
282:43 - options first and then the verify
282:45 - callback
282:46 - so those options here are going to be
282:50 - defined up here at the top and
282:53 - i will note that most of these options
282:56 - are related
282:58 - to the json web token npm library
283:01 - so if we open that up here's the json
283:04 - web token library
283:06 - this is actually what the passport jwt
283:10 - strategy is using to verify our jwt
283:14 - so all of the options that you see here
283:18 - so there's some examples here's the jwt
283:21 - dot verify method
283:22 - this is exactly what the passport jwt
283:27 - middleware is using and all this
283:29 - strategy is doing
283:31 - is passing in the token that it receives
283:34 - it's going to pass in the secret or
283:37 - public key
283:37 - so there's multiple ways that you can
283:40 - verify
283:41 - we're going to be using the public key
283:43 - since we're using asymmetric
283:44 - cryptography and then we have the
283:47 - options
283:48 - object which is literally going to be
283:50 - just passed straight through
283:52 - to this method from the passport
283:53 - middleware
283:55 - so you see down here we have all the
283:57 - options that we can put in here
283:58 - algorithms complete issuer ignore
284:02 - expiration
284:03 - all of these you'll also see well not
284:06 - all of them but you'll see most of them
284:08 - listed here in the strategy
284:11 - documentation
284:12 - now the way that we actually include
284:16 - these options
284:17 - is a little bit tricky and i
284:20 - actually could not based on this
284:22 - documentation figure out
284:24 - how to get all of these option passed to
284:26 - the verify callback
284:28 - so what i've done is just put together
284:30 - every single
284:31 - option that you could possibly ever need
284:34 - and i've put it in a single options
284:37 - object
284:38 - and then we'll kind of reduce to the
284:40 - only the stuff that we need
284:42 - going back to our code
284:45 - let me just paste in this like
284:48 - all-encompassing
284:49 - options object and i might as
284:53 - i might even leave this in the final
284:55 - implementation just comment it out
284:58 - but here is the full options object
285:01 - if you were to pass in this obviously
285:04 - you need to replace
285:06 - some of these things with valid values
285:08 - but if you were to pass this
285:10 - in it would be readable by the passport
285:13 - jwt middleware
285:15 - so you'll see at the bottom we have the
285:17 - json web token options
285:20 - and this is where it gets a little
285:21 - confusing because
285:23 - here are some of those json web token
285:25 - options that we saw in that library's
285:27 - documentation
285:29 - but there are also options from json web
285:32 - token
285:33 - that are that are passed up here and if
285:35 - you were to pass
285:36 - these down in the json web token options
285:39 - the passport jwt middleware as it's
285:42 - implemented
285:43 - would not actually read them correctly
285:45 - so it's really important that you put
285:48 - the options i have listed here exactly
285:50 - how you see them
285:51 - if you see them in the json web token
285:54 - options they need to stay there
285:56 - so that is the entire all-encompassing
286:00 - option object but we don't actually need
286:03 - that
286:03 - i'll go ahead and put this in the final
286:06 - branch
286:07 - of this repository but i'm going to
286:09 - delete it out for
286:11 - right now and we're only going to work
286:13 - on what we need
286:14 - the very first thing we'll do as with
286:16 - any
286:17 - module is import it so
286:20 - we need the passport jwt strategy
286:25 - and we're going to extract the strategy
286:28 - off that so that's going to be a class
286:30 - and then this extract jwt class
286:34 - which is basically a little subclass
286:37 - that is going to give you
286:38 - options as to how you extract the jwt
286:43 - from the http header if you look at the
286:46 - documentation online
286:48 - you'll see that this is detailed at the
286:51 - bottom
286:52 - so in the section extracting the jwt
286:55 - from the request
286:57 - this just has to do with that process
286:59 - where the server needs to know how
287:02 - and where that jwt is stored
287:06 - in the request usually it's going to be
287:08 - in the authorization
287:10 - http header but it isn't always there so
287:14 - this gives you some options as to where
287:17 - you can find this
287:19 - so we're going to just be using from
287:22 - authheader as bearer token this is
287:25 - probably one of the more common ways to
287:26 - do it
287:27 - but you could also pass it into
287:31 - like a post request body field
287:34 - you could put it in a url query param
287:38 - and if you were to do that you would use
287:39 - these different methods
287:41 - from this class you could also write
287:44 - your own extractor function
287:46 - so i know i mentioned earlier that you
287:48 - could put
287:49 - the jwt in a cookie and
287:52 - this right here just gives kind of that
287:54 - example this is how we would grab it
287:56 - from a cookie
287:58 - and so you can kind of have some freedom
288:00 - to implement whatever you would like
288:04 - so our options object is going to be
288:07 - pretty simple
288:12 - just going to replace this right here
288:16 - and this is what we're working with so
288:18 - this is the options object that we're
288:20 - going to need to implement
288:22 - the jwt strategy first is what we just
288:26 - talked about
288:27 - the extract jwt class comes with
288:29 - different methods for
288:31 - finding that jwt and parsing it
288:34 - so we're going to use the from auth
288:36 - header as bearer token
288:38 - so in other words it's going to expect
288:41 - that we have our jwt sitting like this
288:45 - so here's our authorization header and
288:48 - then we're going to say
288:49 - bearer and then a single space and then
288:52 - here
288:52 - is where our token is going to sit so it
288:55 - expects this exact syntax
288:57 - and if you were to maybe take the space
289:00 - out or just delete the bearer
289:02 - portion completely it's not going to be
289:04 - able to read it correctly
289:06 - you'll see how that works a little bit
289:07 - later the next thing
289:09 - is the secret or key
289:12 - property and you can either pass in a
289:15 - symmetric
289:17 - or key which would just be a secret that
289:20 - you stored in an environment variable
289:22 - but for us since we're using the rs256
289:26 - algorithm to issue and verify jwts
289:30 - we're going to pass in our public key
289:32 - that we generated with that
289:34 - script right here and we're reading that
289:37 - from the file system
289:39 - it says path to key id rsa pub
289:43 - and the reason that we're passing in the
289:45 - public rather than the private
289:47 - is because what we're configuring right
289:49 - here
289:50 - is the verify piece of the jwt
289:53 - so if you remember we have the issuance
289:56 - and then the verification
289:58 - with a digital signature we sign the
290:01 - issuance with the
290:02 - private key and then we verify the
290:05 - identify
290:06 - or we verify the identity with the
290:09 - public key
290:10 - so that's why we're passing in the
290:11 - public key because passport is the
290:14 - verification step
290:15 - of this process then finally we're just
290:18 - passing in the algorithms that it will
290:20 - accept
290:22 - and we should be done with it so that's
290:24 - our options object
290:26 - obviously we didn't include half of the
290:28 - options that were
290:30 - available to us but i just wanted you to
290:32 - know that those were available in case
290:34 - you were doing something
290:36 - a little bit different than me like i
290:38 - did with the passport local strategy i'm
290:41 - going to
290:42 - kind of deconstruct this configuration
290:46 - so that you're not just looking at a big
290:48 - blob of
290:49 - you know callback functions and options
290:51 - and all that stuff
290:52 - so we're going to keep it as modular as
290:55 - possible here
290:56 - the first thing that we do we have our
290:58 - options object already configured
291:00 - but we need to use the well jwt strategy
291:04 - right here
291:06 - so we're going to say const strategy
291:09 - equals new jwt strategy
291:12 - all right so that is going to take two
291:15 - arguments one being the options object
291:18 - that we defined
291:19 - right here and two being
291:22 - a callback function which is going to
291:26 - it's already telling us what it expects
291:28 - so it's going to
291:30 - take a payload and a done
291:33 - callback all right so that is the basic
291:36 - implementation right here and then
291:39 - we're going to actually configure it by
291:43 - saying
291:44 - passport.use
291:46 - strategy
291:50 - so again this passport object is being
291:53 - provided from app.js then we're taking
291:57 - that object
291:58 - we're saying use so similar to a
292:01 - middleware
292:02 - and then we're passing in the strategy
292:05 - which has the options configuration
292:07 - in the callback function or the verify
292:10 - callback
292:10 - that we are about to implement within
292:13 - the callback
292:14 - as i mentioned with the passport local
292:16 - strategy
292:18 - the great thing about passport and also
292:20 - the confusing part
292:21 - is you don't have a specific way that
292:24 - you're required to verify
292:26 - in authentication and in our case
292:29 - we can use whatever database we want we
292:31 - can use whatever
292:33 - you know code logic we want to do now
292:36 - since we're using mongodb
292:38 - we'll just use the find one method
292:42 - on the user model so we've imported this
292:45 - from our database configuration
292:48 - so we'll just say user dot find one
292:51 - and then we're going to pass in the id
292:54 - and
292:54 - where are we going to get this id from
292:57 - well if you remember
292:58 - from previously in this i think is in
293:00 - the
293:01 - first video we talked about how the jwt
293:04 - payload so the second part of a jwt
293:08 - is going to have a subfield well in our
293:11 - case it has a subfield and in many cases
293:13 - it has a subfield
293:15 - that will include some information or
293:18 - unique
293:18 - identifier about the user in our case
293:21 - when we implement
293:23 - the register and login functions or the
293:26 - routes we're going to issue a jwt
293:29 - and we're going to place the mongodb
293:33 - database id in the subfield
293:36 - so here's our payload this is in
293:39 - javascript object form so we can
293:42 - literally just say
293:43 - payload dot sub
293:46 - and that's going to pass in the id that
293:49 - we need to look up
293:50 - our user in the database
293:53 - we will then use promise syntax to grab
293:56 - the user
293:59 - and then we will catch any errors
294:02 - that happen and if you remember we need
294:05 - to pass
294:06 - in the error to the done callback if
294:09 - we um and no user
294:12 - if there's an error within this
294:14 - operation
294:16 - so the last thing we need to do is
294:18 - something in this
294:20 - area where we have access to the user
294:22 - that we just looked up
294:24 - now if you were watching the passport
294:26 - local strategy
294:28 - you'll probably remember that in this
294:30 - area we were doing all sorts of stuff we
294:33 - were verifying
294:34 - um you know using a crypto function we
294:37 - were verifying the username and password
294:40 - well in this jwt strategy it is much
294:43 - much simpler
294:44 - we are just we've already validated
294:47 - this jwt so this strategy has
294:50 - already gone through the process of
294:54 - using the json web token library to
294:57 - verify the jwt that it's received
295:00 - so at this point when we're sitting
295:02 - right here
295:03 - we already know that our jwt is valid so
295:06 - all we have to do is check if we found a
295:08 - user in the database
295:10 - and if we did we need to return it to
295:12 - passport so that it can
295:14 - attach that to the request object so
295:17 - we'll just say if there's a user
295:21 - we will return done
295:24 - and there's no error but there is a user
295:28 - otherwise we're going to return done
295:32 - and we're going to say no air
295:36 - and no user excuse me this is not null
295:40 - this is
295:40 - going to expect false so passport
295:44 - expects to see
295:45 - either a user object or false so
295:48 - that is the implementation that we need
295:51 - to do for this verify callback
295:53 - it seems like nothing really is
295:55 - happening
295:56 - but behind the scenes the passport
296:00 - jwt strategy is taking these options
296:04 - it's grabbing that jwt from the
296:06 - authorization header
296:07 - it's validating that jwt with the json
296:10 - web token library
296:12 - then once it's validated it it passes
296:14 - the payload
296:15 - object right here then we grab the
296:19 - id of the user from the payload sub
296:21 - object
296:22 - look it up in the database return it to
296:25 - passport and then passport attaches it
296:27 - to the request.user
296:30 - object within the express framework so
296:33 - that is all that we needed to do to
296:35 - implement
296:35 - passport jwt now i would try this out in
296:39 - the browser and you know
296:40 - see if it's working so far but the
296:43 - problem is we haven't issued any jwts
296:46 - so we could go generate a jwt
296:49 - or grab an example from online and see
296:52 - if it would work with this
296:54 - but it never will because we have
296:56 - generated
296:57 - exactly zero jwts
297:00 - using the private key that we generated
297:03 - in this repository
297:04 - so in other words when passport jwt
297:07 - strategy tries to verify
297:10 - the jw jwt we've included in the
297:12 - authorization header
297:13 - it's going to reject absolutely
297:15 - everything
297:16 - because there is no jwt in existence
297:20 - right now
297:21 - that corresponds to this private key so
297:23 - when we
297:24 - verify it with the public key it's just
297:26 - going to reject it
297:27 - so what we need to do is write some
297:30 - logic in our login route
297:33 - so that every time a user logs in we're
297:36 - going to
297:37 - issue them a new jwt that is signed with
297:40 - the private key
297:42 - that we are using from this server then
297:45 - the passport jwt middleware will use the
297:48 - public key that resides on this server
297:50 - and will successfully verify these new
297:53 - newly issued jwts
297:56 - so to do this we need to come to the
297:59 - routes so we're in the routes
298:01 - users.js file and the first thing that
298:05 - we'll
298:06 - need to do is the register function
298:09 - so if a user is going to come to our
298:12 - application they obviously need to first
298:14 - register
298:15 - and basically what's going to happen in
298:18 - both of these routes
298:20 - is we're going to issue a jwt
298:23 - regardless so the way that this flow is
298:26 - going to work is
298:27 - if a user comes to our application and
298:30 - has never been there before and
298:32 - registers they're just going to
298:34 - provide their username and password then
298:38 - we're going to store that
298:39 - new user in the database and issue them
298:42 - a new jwt
298:43 - and then we're just going to consider
298:44 - them logged in
298:47 - for as long as that jwt is valid
298:50 - and then the login is also going to
298:53 - issue
298:54 - a new jwt but it's just going to look up
298:57 - the existing user in the database
298:59 - and validate the user the username and
299:02 - password that that user
299:05 - put in there when they registered if you
299:07 - watch the passport local strategy
299:10 - videos you're going to be very familiar
299:12 - with what i'm about to paste in
299:15 - so what we're doing here in the register
299:17 - function
299:18 - is we are taking the plain text password
299:22 - that the user has provided us with
299:24 - and we're creating a salt in a hash
299:27 - based on that plain text password we're
299:30 - just using
299:31 - some crypto utils so if we go in lib
299:34 - you'll notice that these these two
299:36 - functions valid password
299:38 - and gen password are going to be the
299:41 - same exact
299:42 - um generation and validation functions
299:46 - that we used with the passport local
299:48 - strategy
299:49 - and so you might ask yourself for a
299:52 - second
299:52 - well wait a second isn't this jwt isn't
299:55 - this a jwt
299:56 - strategy like why are we working with
299:58 - like username and passwords and all that
300:00 - kind of stuff
300:02 - well you have to remember that the jwt
300:05 - is simply a result of
300:08 - a successful user authentication with a
300:11 - username and password
300:13 - so whether you're using the passport
300:15 - local or passport jwt
300:17 - authentication you're always going to
300:20 - need to
300:21 - know how to store a password in the
300:24 - database and then verify it out of the
300:26 - database
300:27 - i'm not going to go through that if you
300:29 - wanted to
300:31 - really understand how this works
300:34 - i do have a slide on that let me just
300:36 - pull it up really quickly
300:39 - so here is the basic password validation
300:42 - process since i talked about it in
300:45 - the passport local strategy a lot
300:48 - just go watch that video if this doesn't
300:50 - make sense otherwise just read through
300:52 - this
300:52 - really quickly all right so that's
300:55 - basically what's happening
300:56 - with the password generation and
300:59 - verification
301:00 - and in the register function we're doing
301:02 - part one of that
301:04 - so we're going to create the salt in the
301:06 - hash and store those
301:07 - in the user record in the database then
301:10 - we'll save the user in the database
301:12 - and just return a success message as
301:14 - well as the user object
301:16 - now i also mentioned that we're going to
301:18 - be issuing
301:19 - a jwt here which we will do in one
301:22 - second
301:23 - but i want to first look at the function
301:25 - that is creating that jwt
301:28 - so we go to the bottom of the utils
301:31 - and you see that we have exported this
301:34 - issue jwt function
301:36 - which is defined here and since the
301:39 - passport jwt middleware is using the
301:42 - json web token npm
301:44 - library we might as well use the same
301:46 - library to
301:47 - issue the jwt so what we're doing
301:50 - is we're taking in the user object that
301:54 - we
301:54 - have in the database we're going to take
301:57 - the id
301:59 - of that user in the database and we are
302:02 - going to assign it to a variable here
302:04 - we are going to say that we want this
302:07 - jwt to expire
302:09 - in one day usually you'd probably do
302:11 - this like
302:13 - two weeks or something but we're just
302:14 - going to do one day for now
302:16 - and then the payload of this jwt
302:20 - is going to be defined as the sub
302:23 - property we'll have the id
302:24 - as we talked about when we were
302:26 - configuring the passport object
302:29 - and then the issued at will just be
302:31 - whatever time stamp is
302:33 - right now then we will sign the token
302:37 - and we're going to do that using the dot
302:40 - sign method of json web token library
302:43 - we're going to sign it with the private
302:45 - key we imported this
302:47 - up here at the top so here's the private
302:49 - key that we imported
302:51 - and that private key corresponds to the
302:54 - public key that we're going to verify
302:55 - later with
302:57 - then we're going to pass in the expires
303:00 - in
303:00 - value and algorithm that we plan to
303:03 - eventually verify it with and that we
303:06 - will sign it with so
303:08 - once we've signed the token we will
303:10 - return
303:11 - a token which has the bearer string
303:15 - at the beginning and then the sign token
303:18 - and then the expires in
303:20 - property so we have this function that's
303:23 - going to issue a new jwt
303:25 - signing it with the private key living
303:28 - on the server
303:30 - and then we're going to come back to our
303:32 - users routes
303:34 - and then in the success message we're
303:36 - going to attach
303:37 - a token and then a expires in
303:40 - property and to do this we just need to
303:45 - um well actually we're going to want to
303:48 - do this down here because
303:50 - when we initially create the user we
303:52 - don't have the id
303:53 - that was stored in the database yet so
303:55 - we need to come down here in the
303:57 - callback
303:57 - to get that id so we'll say the id
304:01 - is equal to user dot id
304:05 - and then we're going to issue this jwt
304:09 - so i think i've already included the
304:10 - utils
304:12 - library so we've got the utils library
304:14 - up here
304:15 - so we're going to say the
304:19 - jwt is equal to utils
304:22 - dot issue jwt then we're going to
304:26 - pass in the user and actually i don't
304:30 - know why i did this right
304:32 - here the function itself is going to
304:35 - grab that id
304:36 - off of the user object so all we have to
304:38 - do is pass in the user
304:40 - and then if you remember it returns us
304:43 - an
304:44 - object with a token and expires property
304:48 - so we're just going to grab the jwt dot
304:51 - token
304:53 - and jwt dot expires
304:56 - and there we go we have a successful
304:59 - response
305:01 - and once we have saved this user in the
305:04 - database after registering
305:06 - the front end client will get this
305:08 - message
305:09 - right here so let's do that really
305:12 - quickly let's run this
305:14 - make sure that we don't have any errors
305:16 - going on
305:18 - looks like the database connected okay
305:21 - and i'm going to open up
305:23 - postman which is just an http
305:27 - um request application it's got a lot of
305:31 - other stuff i should probably be giving
305:32 - it more credit than that
305:34 - but let's go to register i've already
305:36 - got the post request
305:38 - set up and in the body we're just going
305:41 - to require
305:43 - um i think it was just a username and
305:45 - password
305:47 - so we'll say the username will be zach
305:50 - [Music]
305:52 - we'll say zack jwt just that we can
305:57 - distinguish from the passport local
305:59 - strategy i was doing in a previous video
306:03 - then the password will be just one two
306:05 - three my
306:07 - default debugging password here
306:10 - so i think that's all that we need for
306:12 - this request let me just check that
306:14 - really quick
306:16 - okay so this is all we need we should be
306:19 - able to run this and hopefully it works
306:22 - um let's see what we got for the
306:25 - response
306:26 - looks like we had some issues so let's
306:28 - go back and see what's going on
306:31 - um hmm
306:35 - oh of course we have the wrong
306:38 - route that we're using i just said
306:41 - register
306:41 - it's actually going to be i think users
306:44 - slash register or even maybe even api
306:47 - slash users we'll find that out real
306:50 - quick come back to the code
306:54 - let's look at our index.js okay so we're
306:57 - going to
306:58 - okay so it's the slash users route is
307:01 - what we're going to need
307:02 - so come back to postman get rid of this
307:05 - api
307:06 - we didn't include that now we should be
307:08 - able to send it
307:10 - and we get a successful response so
307:13 - here's our response
307:14 - success is true here's the user that we
307:17 - stored in the database
307:19 - and we'll verify that in a second and
307:22 - then
307:22 - here is the token and the expires in
307:24 - that we
307:25 - issued using the utils library that we
307:29 - wrote all right so this is what the
307:32 - frontend is going to receive as a
307:33 - response
307:34 - and then they're going to take this
307:36 - token and store it
307:38 - somewhere in local storage so that it
307:40 - can attach it to every single request
307:43 - in the future implementing the login
307:45 - post route is
307:46 - a little bit more complicated but i'll
307:49 - post in the implementation
307:52 - or paste in not post i'm looking at all
307:54 - these post requests
307:56 - and what we're doing it's it's pretty
307:59 - simple but
308:00 - there's a lot of code here so we'll
308:02 - start at the top
308:03 - the first thing that we're doing is
308:05 - we're going to take
308:06 - the username that we received from
308:09 - the login form whatever the user typed
308:12 - in
308:13 - and we're going to look in our database
308:14 - for that username
308:16 - if we then will assume that we find the
308:20 - user
308:20 - and we populate it in this user property
308:24 - we'll say first if there's no user so if
308:27 - this
308:27 - user in the database doesn't exist maybe
308:29 - this person is trying to log in and they
308:31 - haven't even registered
308:33 - we'll just return a 401 code
308:37 - with a message that says could not find
308:39 - the user
308:40 - pretty simple there this next line
308:44 - if you watch the passport local strategy
308:46 - you'll understand this exactly
308:48 - but if you didn't what this is doing is
308:51 - using that
308:52 - valid password function so up here
308:56 - the validate password function and it's
308:58 - basically going to check
309:00 - okay is the username um that you just
309:03 - gave me and the password you just gave
309:05 - me
309:05 - are they valid so it's going to take
309:07 - that plain text password
309:10 - that the user just typed into the login
309:12 - form and validate it with the node.js
309:15 - crypto library and that function that we
309:17 - already defined so this is going to
309:19 - either be true or false based on whether
309:21 - the user logged in
309:23 - successfully and mind you this is
309:26 - different from the jwt
309:28 - remember we have not issued the jwt
309:31 - yet we'll just assume that they're
309:33 - logged out so
309:34 - if this is valid we know okay this is a
309:37 - valid user we need to give them a jwt
309:40 - that they can attach to all of their
309:43 - future requests
309:44 - so that they don't they don't have to
309:45 - log in every single time
309:48 - so here's our issued jwt it's exactly
309:51 - how we issued it down here
309:55 - and then we will attach that with the
309:58 - same exact
310:00 - response body that we did earlier we
310:03 - also probably should just put in the
310:04 - user
310:05 - property here like we did in the
310:07 - register route
310:09 - and then finally if the user did not
310:12 - log in successfully they gave us the
310:14 - wrong password or the wrong username
310:16 - whatever then we will return
310:20 - this response where it says you entered
310:22 - the wrong password
310:23 - and it's just going to be a 401 response
310:25 - because that is like the unauthorized
310:27 - http code all right and then we're going
310:30 - to catch any errors just put it through
310:32 - standard express middleware and catch it
310:35 - in our air handler
310:36 - i don't even think we have one
310:38 - implemented for this but
310:40 - that's kind of what that's going to do
310:42 - all right so
310:43 - we've got both of our routes implemented
310:47 - and let's come back to postman
310:50 - just make sure that this is going to
310:52 - work alright
310:54 - so we'll go to login and
310:57 - let's just copy the body that we put for
311:01 - the register because it should be the
311:03 - same
311:05 - so here's the user that i already have
311:08 - registered in our database
311:10 - um here's the correct password for that
311:12 - user
311:13 - let's make sure that we have the right
311:17 - path here and click send
311:20 - and we get a success is true and we get
311:22 - the same exact response
311:24 - here is our jwt that we will store in
311:27 - the browser at some point
311:30 - all right so we are done with the bulk
311:33 - of our work here
311:34 - the last thing that we need to do is
311:36 - just test to see
311:37 - if our passport jwt middleware
311:40 - is working correctly so far we haven't
311:43 - even tested the passport jwt middleware
311:46 - we've just be been doing the basic
311:48 - username and password register
311:50 - and login and issuing the jwt
311:55 - all right so coming back to vs code the
311:58 - way that we're going to test this is in
312:00 - this first route
312:01 - which is the protected route and
312:04 - we are going to pass in the passport
312:06 - middleware
312:07 - right here so we'll say
312:10 - passport.authenticate
312:12 - and then we're going to say that we want
312:14 - the jwt strategy
312:16 - and we're going to pass in an object
312:19 - that says session
312:21 - false and the reason that we do that
312:25 - if you're familiar with the passport
312:26 - local strategy that we did in previous
312:28 - videos
312:29 - we were using the passport session
312:31 - middleware
312:32 - to actually interact with the express
312:34 - session middleware
312:35 - but we're not using this here because
312:37 - we're using jwts
312:39 - so we say that that's false all right so
312:42 - what this is going to do is execute that
312:44 - verify callback
312:46 - so this function right here and if we
312:49 - successfully validate the jwt that has
312:52 - attached the request
312:54 - it should let us into this route
312:57 - so we should be able to print something
313:00 - let's see if we can get in here all
313:02 - right so we'll just say
313:08 - res.status200.json.com
313:10 - will stay consistent here is true
313:13 - message
313:14 - is going to be you are
313:17 - authorized
313:21 - we are now ready to test this out so
313:24 - let's go to pat to postman
313:28 - and we'll come over to the protected
313:30 - route
313:31 - again we need to put in that path
313:34 - and here's where the magic comes in but
313:39 - also kind of
313:40 - gets really confusing we have to attach
313:43 - the jwt
313:45 - that this user owns to the authorization
313:48 - header
313:48 - now in postman you have the option to
313:51 - put it here
313:53 - in the authorization tab
313:56 - you could just do bearer token and you
313:58 - put the token here
313:59 - but we're not going to do that we're
314:01 - just going to stick with basic http
314:03 - headers
314:04 - to keep things simple so we're going to
314:07 - use the authorization header
314:11 - and then the value that we will pass in
314:13 - is that token that we received
314:16 - over when we registered or logged in
314:19 - so we just logged in so we're going to
314:22 - take this entire token
314:23 - including the bearer portion and we're
314:26 - going to
314:27 - copy that into the value right here
314:30 - so this value because it's in the
314:33 - authorization header
314:34 - and because it says bearer with the
314:36 - space and then the token
314:38 - which is exactly what the passport jwt
314:42 - middleware is expecting
314:44 - that middleware is going to take this
314:46 - value
314:47 - it's going to run it through the
314:48 - verification function using the json web
314:51 - token library
314:52 - and hopefully authenticate us correctly
314:55 - so we're just doing the get request
314:57 - let's send it and it says success true
315:01 - you are authorized so in this case we
315:04 - just
315:05 - copied in the bearer token here the jwt
315:08 - in postman but obviously if you're
315:10 - implant implementing an application
315:12 - you're going to do this on your front
315:14 - end client so for example angular
315:17 - and you're going to want a way to you
315:19 - you'll probably store it in local
315:21 - storage
315:21 - after you've been issued this and then
315:24 - you will
315:25 - write some sort of logic to attach it to
315:27 - every request
315:28 - but that's not the purpose of this video
315:31 - this video is just to show you how to
315:33 - configure
315:34 - the passport jwt strategy so if you
315:37 - wanted to watch that that'll be probably
315:39 - the
315:39 - one of the next videos or something like
315:42 - that
315:43 - but the last thing i wanted to do in
315:45 - this video
315:47 - is just kind of a quick recap to show
315:49 - you exactly how
315:51 - you're going to be using this alright so
315:54 - every time
315:55 - every route that you want to protect
315:58 - using
315:58 - jwt authentication you're going to use
316:02 - this syntax right here if you wanted to
316:05 - simplify it even further you could
316:07 - probably write
316:07 - write yourself a middleware that just
316:09 - calls this method
316:11 - and then you only have to pass in like a
316:13 - couple letters
316:14 - but if you wanted to you can pass in
316:16 - this exact syntax
316:18 - every single time now this
316:21 - is very different from the passport
316:24 - local strategy
316:25 - because if you remember when we did that
316:27 - if you watched that video
316:29 - we only called the passport.authenticate
316:32 - method
316:33 - one time and we called it in the login
316:36 - post route and then after that what we
316:40 - were doing to check whether this user
316:41 - was
316:42 - authenticated was saying if
316:49 - request.session.passport.user
316:51 - exist or i think we had a shorthand
316:53 - method
316:54 - if request dot is authenticated
316:57 - that's how we were validating whether a
317:00 - user was logged in
317:01 - but since jwts are by default stateless
317:05 - we're not using sessions we have to call
317:08 - this
317:09 - every single time so that the passport
317:11 - middleware can
317:12 - you know grab the jwt that's included in
317:15 - the request and verify it
317:17 - so it's pretty simple actually this all
317:19 - you're going to be using
317:20 - attach it to every request that you want
317:22 - to authenticate
317:24 - and you could even come over to your
317:27 - passport verification and have some sort
317:31 - of different
317:31 - logics you could say in this part of the
317:34 - body
317:35 - you could say if user.admin if you
317:38 - wanted to validate like an
317:39 - admin property or something you can get
317:42 - pretty creative with it
317:43 - but that is the basics of using the
317:45 - passport jwt strategy
317:48 - i just want to take a few moments to say
317:50 - congratulations
317:51 - if you've made it to this point the
317:53 - remainder of the video is completely
317:55 - optional for you you can fully say that
317:58 - you understand
317:59 - the basics of user authentication in
318:02 - node.js
318:03 - express and passport.js if this video
318:06 - has connected the dots for you in one
318:08 - way or another
318:10 - i'd really appreciate if you went and
318:11 - checked out my channel um much smaller
318:13 - channel
318:14 - than the one that i'm on right here but
318:16 - i make a lot of web dev related videos
318:19 - and post on a weekly basis at least at
318:21 - this point
318:22 - so go check it out subscribe like a
318:25 - video
318:26 - that would be extremely helpful to me
318:28 - and i'd really appreciate it
318:29 - alright the last part of this video as i
318:32 - said is completely optional and we're
318:34 - going to be covering
318:35 - two things number one we're going to be
318:37 - covering
318:38 - how do we actually take passport js out
318:41 - of the equation
318:42 - with the jwt strategy believe it or not
318:45 - the passport jwt strategy is just using
318:48 - the json web token library under the
318:50 - hood
318:51 - and we can do the same thing well
318:52 - passport js has a lot of strategies that
318:55 - really alleviate a lot of the work that
318:57 - you would have to do
318:58 - and i'd highly recommend using them the
319:01 - jwt strategy is a little bit unique in
319:03 - the fact that
319:04 - i don't think that the passport jwt
319:06 - strategy
319:07 - adds a whole lot of incremental value to
319:10 - you now that is of course if you
319:12 - understand
319:12 - what you're doing and since we just
319:14 - talked for many many hours
319:16 - to learn how all of this works and we
319:18 - actually do know what we're doing
319:20 - we can implement our own jwt strategy
319:23 - pretty easily and then in the final part
319:25 - of this video we're going to walk
319:27 - through the basic
319:28 - implementation of a jwt strategy
319:32 - with angular on the front end now of
319:34 - course this will not apply to all people
319:37 - not everyone is an angular developer or
319:39 - has an interest in that
319:41 - but i did want to tack it on to the end
319:43 - in case you are working within the
319:44 - angular framework and are confused
319:47 - how do you take all these concepts and
319:49 - translate it to
319:50 - you know the front end and use local
319:52 - storage to keep your users logged in
319:54 - and communicate with the backend that we
319:56 - just wrote all right
319:57 - let's go ahead and first jump into how
320:00 - do we write
320:01 - our own custom jwt authentication
320:04 - strategy
320:05 - so what you see on the screen here is
320:07 - our application it looks a little bit
320:08 - different
320:10 - got a slightly different environment as
320:12 - i'm recording this video which is kind
320:14 - of recorded a separate time
320:16 - as an addition to this course so
320:19 - everything is the same though don't
320:20 - worry about that
320:21 - let's go ahead and open up postman just
320:23 - so that i can prove that out to you
320:25 - so if we go to the register route we'll
320:27 - put in
320:28 - another test user and we'll send that
320:31 - request
320:33 - and it's not going to work because we're
320:34 - not actually running the server
320:36 - at the moment so let's go ahead and run
320:38 - the server
320:40 - try that again and we should get a
320:42 - successful creation of the user
320:44 - now let's copy these same credentials
320:47 - oops
320:48 - we'll copy the same credentials into the
320:49 - login right here
320:52 - click send and we should get a bearer
320:54 - token
320:55 - let's copy that bearer token go to our
320:58 - protected route
321:00 - and drop that into the authorization
321:03 - header value click send and it says you
321:06 - are successfully
321:07 - successfully authenticated to the route
321:10 - so as you can see it's the same exact
321:12 - thing
321:12 - nothing has changed but what i want to
321:14 - do now is
321:15 - close out of here and i want to create
321:19 - a new branch so we're going to create a
321:21 - new branch
321:22 - called custom jwt
321:25 - and what we're going to do on this
321:26 - branch is we're going to completely rip
321:28 - out
321:29 - the passport js implementation and add
321:32 - in our custom jwt
321:34 - implementation you might think that
321:36 - sounds really difficult but it's
321:37 - actually not
321:39 - and although there is a really good use
321:42 - case for passport
321:44 - passport as a middleware and framework
321:47 - such as the local strategy and a lot of
321:49 - the delegated
321:50 - authentication such as you know the
321:52 - social logins
321:53 - truthfully the passport jwt strategy
321:57 - does not really do a whole lot of heavy
321:59 - lifting for us
322:00 - quite honestly i prefer to do my own
322:02 - custom implementation when working with
322:05 - jwt
322:06 - so the most obvious place to start is
322:08 - going to be in the passport.js file
322:11 - where our implementation
322:12 - sits let's take a look at what we might
322:14 - have to change
322:16 - so the first thing that i see in the
322:18 - options is that we have this
322:20 - method called extract jwt from auth
322:23 - header
322:24 - as bearer token so we need to be able to
322:27 - take the off authorization http
322:30 - header and grab the correct token
322:35 - and parse it in our code as i mentioned
322:37 - earlier passport
322:39 - js is doing that for us so we don't have
322:41 - to do it on our own
322:42 - but as we're ripping passport out right
322:45 - here we're gonna have to write a custom
322:47 - function to do this
322:48 - furthermore in the main implementation
322:50 - this is just a middleware so
322:52 - we're just going to replace that with
322:55 - our own custom
322:56 - middleware function that's all it really
322:58 - is is just a function
323:00 - and we're basically going to verify the
323:02 - jwt that is passed through the request
323:05 - and then you know either authorize or
323:07 - deny access to
323:09 - that given route and then that's going
323:12 - to play out
323:13 - once we go to the routes over here where
323:16 - you see
323:17 - in the protected route we're using this
323:19 - passport.authenticate method
323:21 - we're just going to replace that with
323:23 - our custom
323:24 - middleware function that we're about to
323:26 - create so just to start us
323:28 - off let's go ahead and and start
323:31 - removing some things so let's comment
323:33 - out the passport declaration up here
323:36 - and let's also remove the authenticate
323:40 - method right here and see how that
323:43 - changes
323:44 - everything for us so we should still be
323:47 - able to
323:47 - start the application and then go over
323:51 - to postman
323:52 - go to the protected route and we can
323:55 - uncheck this authorization
323:57 - and click send and it says you are
323:59 - successfully authenticated now that's
324:01 - obviously not true
324:02 - because what we did was just remove the
324:04 - middleware that's authenticating us
324:06 - so we need to replace this with some
324:08 - other middleware
324:10 - and we're just going to throw this in
324:11 - the utils file
324:13 - because we've already got this being
324:14 - imported so
324:16 - let's open up utils and you can see we
324:18 - have a lot of our helper methods in here
324:20 - and what we can do is actually create
324:22 - our authentication middleware as well
324:26 - so let's go ahead and create a new
324:28 - function
324:29 - and we'll say this function will be
324:32 - called off middleware
324:35 - something like that and what we need to
324:37 - pass in
324:38 - as with any middleware is going to be
324:41 - the request
324:42 - object the response object and next
324:45 - and then of course we're going to create
324:48 - that as a function so we'll drop it down
324:50 - here
324:51 - by default let's go ahead and just
324:54 - send a 401 unauthorized error so the 401
324:58 - http status code is for unauthorized
325:02 - and if we were to um let's save this
325:06 - go back to our users right here and add
325:10 - back in the passport
325:11 - authenticate method and then uncomment
325:14 - or yeah uncomment the passport
325:18 - import this is going to put us back to
325:20 - where we were
325:21 - and if we go to this protected route and
325:24 - we've got the authorization removed
325:26 - and click send we should get this
325:28 - unauthorized
325:29 - response and if we click through this
325:33 - let's see we can look at the headers
325:37 - and it says the status is 401
325:39 - unauthorized
325:41 - and then it explains that error similar
325:43 - to 403 forbidden
325:44 - but specifically used for when
325:46 - authentication is possible but has
325:48 - failed
325:49 - or not yet been provided so that's a
325:52 - good
325:52 - just overview of the 401 error and we
325:55 - can also see that we're doing this
325:58 - in the res dot status right here uh in
326:01 - the login route so we're already
326:03 - a little bit familiar with this but by
326:05 - default we're going to make this off
326:07 - middleware just send that 401 and maybe
326:09 - we can even
326:10 - stay consistent with our login so
326:13 - instead of just
326:14 - sending it we'll say res.status
326:17 - and then give it a payload or a response
326:20 - body
326:21 - so we'll say res.status is 401 the
326:23 - success is false
326:25 - and the message is going to say you are
326:28 - not
326:28 - authorized to visit this route
326:32 - from this point let's go ahead and copy
326:35 - one of these down
326:36 - and replace our export so that we have
326:40 - the off middleware export so that's
326:43 - going to export it from this file
326:45 - and now we can actually use it over in
326:48 - users.js
326:50 - so we've got this import already so
326:53 - let's
326:53 - let's comment out passport again just
326:55 - that we're not we're not importing that
326:57 - anymore and we can
326:58 - we can go ahead and delete that because
327:00 - we're not going to toggle that back on
327:02 - yet
327:02 - or anymore so we'll go to utils.off
327:05 - middleware
327:06 - and that's really all you have to pass
327:08 - in you don't have to pass in any
327:10 - you know parameters or arguments or
327:12 - anything
327:13 - so let's go back to postman
327:16 - and try out our
327:20 - protected route so let's click send
327:24 - and see what the response is we get a
327:26 - success false
327:27 - you're not authorized to visit this
327:29 - route and the reason we're getting that
327:31 - is because when we run this route
327:33 - instead of getting
327:34 - what's in the body of the route we're
327:38 - passing through this
327:39 - off middleware that we just created and
327:42 - it's
327:42 - by default giving us an unauthorized
327:45 - status
327:45 - but that of course is not what we are
327:47 - wanting to do here we're wanting to
327:49 - get the jwt that was passed into the
327:51 - request
327:52 - and then pull out the token from that
327:56 - and validate that token using the json
327:59 - web token library
328:00 - because after all that's all that
328:01 - passport jwt is doing in the end
328:04 - what i have pulled up here is actually
328:06 - the passport jwt strategy
328:09 - implementation and you'll see that on
328:11 - the verify jwt
328:13 - this is all that's happening you're just
328:15 - using the json web token library
328:17 - to verify the token itself so that's not
328:21 - going to be all that difficult for us to
328:22 - do
328:23 - and then furthermore we have the extract
328:25 - jwt
328:26 - which is going to be if we come back
328:29 - here
328:30 - go to passport and see this method right
328:32 - here
328:33 - so the from off header as bearer token
328:36 - so if we were to go to that same
328:37 - repository we can go to the
328:39 - um off header or no the
328:43 - yeah the offheader.js which is going to
328:46 - have
328:46 - a parse offheader method which is going
328:49 - to basically call the extract
328:51 - jwt and then this has a bunch of
328:53 - different ways that we can do this
328:55 - depending on what our header looks like
328:58 - but in our case
328:59 - it's from auth header as bearer token as
329:02 - we saw
329:03 - right here and what that's doing is
329:05 - calling another method
329:06 - which has some utility functions so on
329:09 - and so forth
329:10 - so that's not all that difficult to
329:12 - implement either let's go ahead and see
329:14 - what that request header looks like so
329:17 - if we were to
329:18 - drop into the off middleware in
329:20 - console.log
329:21 - the request and then i believe we can
329:24 - just
329:24 - say the request.header if i'm
329:27 - remembering this correctly
329:29 - and then we came over to postman and we
329:32 - went to the headers
329:33 - turned back the authorization header and
329:36 - click send
329:37 - and then we'll see something printed
329:40 - here so maybe i did not
329:43 - uh print this correctly so i'm printing
329:45 - a function not
329:46 - the actual header so i think i have to
329:49 - say request.headers maybe instead
329:53 - so let's go back send this request again
329:56 - and now we're getting something a little
329:58 - bit better so we're seeing our header
330:00 - printed out now let's go back to postman
330:03 - and instead of this authorization header
330:06 - let's go ahead
330:07 - and copy the token itself and
330:10 - turn this one off and then go to
330:12 - authorization
330:13 - and click bearer auth so if we copy in
330:16 - this token
330:17 - and click send we should still get the
330:20 - same
330:21 - header so we we're always going to get
330:22 - this authorization property
330:25 - and that's kind of what it means when
330:26 - we're looking at the passport
330:28 - implementation
330:30 - and it says that we need to extract jwt
330:34 - from the auth header as bearer token
330:36 - that is
330:37 - us telling the passport library hey
330:41 - we expect this certain format so parse
330:43 - it accordingly
330:45 - so that's basically what we're saying is
330:47 - we always expect
330:49 - this exact format to be passed in and in
330:52 - our utility method we're going to have
330:54 - to take that into account
330:55 - so the next question is how do we
330:57 - actually parse through this token
331:00 - well we can actually split the token
331:02 - because
331:03 - as you see in the format down here
331:06 - there is no spaces other than between
331:09 - the bearer
331:10 - and the token itself so if we have a
331:12 - valid bearer token
331:14 - we can just split it with a javascript
331:16 - method
331:17 - so let's go ahead and make a variable
331:20 - called token
331:20 - parts and then what we're going to do is
331:23 - we're going to say request.headers.split
331:27 - and we're going to split it by a single
331:29 - space
331:30 - now if we console.log the token parts
331:33 - instead of just the entire header you're
331:36 - going to see
331:37 - something that we can work with a little
331:39 - bit easier so let's go ahead
331:41 - and remove this we'll go back to no off
331:44 - because i think it's a little bit more
331:45 - straightforward when we're just passing
331:47 - in
331:48 - the authorization header and let's go
331:51 - ahead and click send
331:52 - and it looks like we got some issues
331:55 - here
331:56 - it says request.headers.split is not a
332:02 - function
332:07 - and that is of course because i'm not
332:10 - thinking
332:10 - at all trying to talk and teach and code
332:13 - all at the same time it's a little bit
332:15 - difficult sometimes
332:16 - i don't want to split the headers i want
332:18 - to split the
332:20 - headers.authorization property
332:23 - let's try that that might work a little
332:25 - bit better
332:26 - and this time we should get an array so
332:29 - our array has the bearer and the token
332:33 - keywords and then from here we basically
332:36 - need to
332:37 - check to make sure that this is the
332:39 - correct format because what if
332:41 - what if we get something that's
332:43 - incorrectly formatted
332:44 - passed as an authorization key that
332:46 - would obviously be
332:48 - invalid so what we're going to do here
332:52 - is we're going to say if the token parts
332:56 - 0 is equal to the word bearer
333:00 - which is what we would expect and
333:03 - the token parts number one so
333:07 - the first index which would be the
333:09 - actual token
333:10 - if that matches a certain regular
333:12 - expression
333:13 - then it's going to be valid in that
333:15 - regular expression as we learned with
333:16 - the jwt
333:18 - portion of this course is always going
333:20 - to be a series of characters
333:23 - with a period and then another series of
333:25 - characters
333:26 - with another period somewhere here
333:29 - if i can track it down and find it
333:33 - so right here is the second period and
333:36 - then some more characters to follow
333:38 - so the way that we can validate that is
333:41 - with a regular
333:42 - expression that basically just looks
333:43 - like characters period
333:45 - characters period more characters if it
333:48 - doesn't follow that format then it's
333:49 - invalid we don't want to
333:51 - let the user into the route so we can
333:54 - actually use the string
333:57 - matching function and we can pass in a
334:00 - regular expression
334:02 - that i've already written so this course
334:05 - is not about regular expressions so
334:07 - you're just going to have to take my
334:08 - word on this this right here is going to
334:11 - basically say
334:12 - look at the string that we've got down
334:14 - here
334:15 - and ask you know whether it fits that
334:18 - format of characters
334:19 - dot characters dot characters and if it
334:23 - is then
334:23 - it's not going to equal a value of
334:26 - null so if it does match then
334:30 - it's going to give you a results array
334:33 - if it does not match it will return null
334:36 - so
334:36 - if we check and make sure that that does
334:38 - not return null
334:39 - then we know that we have a valid jwt
334:42 - format
334:43 - so we're basically saying if we make it
334:45 - into the body of this if statement
334:48 - then our token is valid we are now ready
334:51 - to actually
334:52 - write the verification portion of this
334:54 - with the json web token library
334:57 - now we've only imported our
335:00 - private key up here but we also need to
335:04 - import the public key in order to
335:06 - validate this
335:07 - so remember we sign it with the private
335:09 - key and we
335:10 - verify it with the public key so that's
335:12 - the order we're going in
335:14 - so let's go ahead and copy this down and
335:17 - we're going to grab instead of the
335:19 - private key we're going to grab
335:21 - the public key and then we're going to
335:25 - change the variable name copy this down
335:29 - change private key to public key
335:33 - and update the variable here let's make
335:36 - sure that we're getting that
335:37 - correctly first so if we get here and we
335:41 - have a valid token which we should
335:43 - we should be able to console.log the
335:45 - public key
335:46 - constant variable so we restarted
335:49 - let's try to visit the protected route
335:52 - and you can see that we're
335:53 - getting that public key printed out just
335:55 - fine so that's working
335:58 - now we just have to implement the json
336:00 - web token verify
336:02 - method that it comes pre-built with so
336:04 - if you were to go to the json web token
336:07 - documentation on npm and
336:10 - search for the jwt dot verify method
336:13 - you can see that it takes in a token
336:15 - which is going to be the jwt
336:18 - a secret or public key so that will be
336:20 - our public key
336:21 - and then of course we have some options
336:23 - and a optional callback function
336:25 - you can read through this but i'm going
336:27 - to go back and just implement it
336:29 - and show you exactly how to use it so
336:31 - we've got the imported json web token
336:34 - library
336:35 - and all we need to do is come down in
336:37 - here and say
336:40 - let's say verification variable equals
336:43 - json web token
336:45 - dot verify now it's going to ask us for
336:48 - a token
336:49 - which we're going to give it the token
336:51 - parts at index 1 which is the actual
336:53 - token
336:54 - we're then going to pass in the public
336:57 - key
336:58 - and then in the options it asks us
337:01 - whether we
337:02 - want to supply an algorithm so if i were
337:05 - to go back to this
337:06 - documentation we have an options
337:10 - and algorithms which is a list of
337:12 - strings with the names of the allowed
337:15 - algorithms for example hs256
337:18 - blah blah blah so all we have to do is
337:21 - pass in the algorithms and then in the
337:25 - array
337:26 - we need to pass in rs 256
337:30 - and you might ask how did i decide on
337:32 - that algorithm
337:34 - well if you remember from the
337:35 - passport.js
337:37 - file where we were given the options to
337:40 - the passport middleware
337:42 - we were basically saying i want to
337:44 - extract it as a bearer token
337:47 - which we did here in these lines right
337:50 - here
337:51 - then what we said is i want it to be
337:54 - using the public key
337:56 - so we passed in the actual public key
337:59 - just as we did
338:00 - right here and then finally we said that
338:04 - we wanted the rs256 algorithm which is
338:07 - basically the public
338:08 - private key pair or asymmetric
338:10 - cryptography
338:11 - so that's what we're doing here in the
338:14 - algorithms section
338:15 - so we're basically giving it the same
338:16 - options we're just doing it more
338:18 - directly
338:19 - so let's go ahead and console.log
338:22 - the verification and see what we're
338:25 - getting
338:26 - so let's go back to our postman if i can
338:29 - get there
338:30 - and click send so we sent the request
338:34 - we'll come back here and we're getting
338:37 - this value right here
338:39 - which is going to basically
338:42 - be an invalid value if it was not
338:45 - successful or will get this
338:47 - object if it was successful so let's go
338:50 - ahead and manually
338:51 - put in the wrong key to see what happens
338:54 - if it's not
338:55 - so we'll just remove this first
338:58 - e at the beginning of the bearer token
339:01 - and click send and now we're going to go
339:04 - back to
339:05 - our library here
339:08 - and it's going to say json web token air
339:11 - invalid token
339:13 - as you can see here this has thrown us
339:15 - an
339:16 - air and we don't want that in our
339:18 - application we want to handle all of our
339:20 - errors
339:21 - and if we were to go back to our
339:23 - documentation here for this
339:25 - method it's going to give us an
339:28 - asynchronous
339:29 - way to do it and a synchronous way to do
339:31 - it let me just get rid of this
339:34 - search so we don't see that and for the
339:36 - synchronous
339:37 - method it says if a callback is not
339:39 - supplied function
339:41 - acts synchronously returns the payload
339:43 - decoded if the signature is valid
339:45 - and optional expiration audience or
339:47 - issue issuer are valid if not
339:50 - it will throw the air so that's
339:52 - basically telling us that we need to
339:54 - handle
339:55 - an error if we're doing it synchronously
339:57 - which is how i want to do it here just
339:58 - to
339:59 - stay simple so we can use the built-in
340:02 - try catch block so we'll say try
340:06 - catch and then pass in the air and
340:09 - if we go ahead and run
340:12 - this method right here if i can copy it
340:15 - correctly
340:16 - if we run that right there it should
340:19 - pass and if it
340:20 - if it does not pass it will throw an
340:22 - error and at that point we can
340:24 - console.log the error just to see what
340:26 - we're dealing with
340:28 - so let's go ahead and see if we can
340:30 - verify it
340:31 - so basically if we don't make it to the
340:34 - error
340:35 - state then we know it was successful so
340:37 - we've reconnected
340:39 - let's send the request with an invalid
340:42 - request
340:43 - and you'll see that we have printed out
340:45 - the air now so it looks like it through
340:47 - the air but we're actually just printing
340:49 - it and handling it gracefully
340:51 - so based on this all we need to do now
340:54 - we've just kind of tested everything out
340:56 - let's get rid of this console log
340:58 - statement
340:59 - let's also not print a variable that we
341:03 - don't have anymore that's a problem
341:06 - and then we'll come down into the catch
341:07 - block and if we have an error
341:10 - that's where we're going to put this
341:12 - status
341:13 - of 401 so as of right now
341:16 - if it was successful it's not going to
341:18 - do anything it's not going to return
341:20 - anything
341:21 - if it's unsuccessful we're going to get
341:23 - this message right here
341:25 - so if we go back to postman we should
341:27 - expect
341:28 - to get the you are not authorized to
341:30 - visit this route message
341:31 - which is what just happened so that's
341:33 - working great
341:35 - and now what we need to do let's go
341:38 - ahead and assign
341:41 - this to a verification variable once
341:44 - again
341:45 - and now what we're going to do is pass
341:49 - the next callback in here so we'll just
341:52 - say next
341:53 - and that's going to pass us through to
341:55 - the
341:56 - next route at this point what we could
341:58 - do is we've got this verification stored
342:01 - and let's go ahead and console.log it
342:04 - one more time
342:05 - just to see what we're dealing with and
342:07 - at this point i need to add back in that
342:10 - uh e character that i just
342:13 - manually removed from this token so now
342:16 - it should be valid
342:17 - and when we send the request we're not
342:18 - going to get any response yet because we
342:20 - haven't done anything here
342:22 - but in the terminal if we scroll to the
342:24 - bottom we should get this little
342:26 - block of code which is some useful
342:28 - expiration date of the jwt token which
342:30 - we can then
342:31 - use on the front end to you know set
342:33 - expires headers
342:34 - or expires in local storage and stuff so
342:37 - it would be helpful to pass this along
342:40 - so all i'm going to do is say on the
342:42 - request object
342:44 - i'm going to going to assign the jwt
342:46 - equal to the verification
342:48 - and then i'm going to say next to pass
342:51 - it to the next
342:51 - middleware in the chain so at this point
342:54 - we're passing it to the next middleware
342:56 - in the chain
342:57 - and now we have this jwt property so
343:00 - we're going to drop into this route and
343:02 - now we should be able to
343:04 - console.log the request.jwt
343:07 - and if we console.log that successfully
343:10 - then we know that it was a successful
343:13 - verification
343:14 - and we should see the same object being
343:16 - printed despite the fact that we're not
343:18 - printing it in our middleware anymore
343:20 - let's go back to postman click send
343:24 - and it says you're successfully
343:26 - authenticated which is good
343:27 - good news and you'll also see this jwt
343:31 - that we had attached to the request
343:33 - object so believe it or not
343:34 - we are done ripping out passport.js and
343:37 - implementing our own strategy
343:40 - so if we were to come to the passport.js
343:42 - file and just click
343:45 - delete on this whole thing we should
343:47 - still be able to run our app so let's
343:49 - start it it's going to crash because
343:53 - we're currently importing that into
343:56 - app.js
343:57 - so if you remember we're configuring
343:59 - passport right here
344:02 - and do we do anything else yeah we're
344:05 - importing passport up at the top
344:07 - just want to make sure we're not using
344:09 - it anywhere else
344:11 - let's save that
344:14 - and see what else looks like i missed
344:16 - one so on line 22
344:19 - here's the initialization call we'll
344:21 - delete that out
344:22 - click save and it looks like we're
344:25 - compiling
344:26 - correctly now we've deleted passport
344:29 - entirely i don't think that we have any
344:31 - other references to
344:32 - passport let's go ahead and check so
344:35 - that's just in the package
344:37 - json and then the readme so we're
344:39 - looking good we have no more references
344:41 - to
344:42 - the passport library in our code and now
344:45 - we should be able to go through the
344:47 - entire flow that we went through
344:48 - previously
344:49 - with our custom strategy so let's go
344:52 - ahead and try it
344:53 - we'll start with the register route
344:55 - we'll put in a new user
344:57 - click send we've created the new user
345:00 - we will update our login route to
345:05 - log in our new user we'll click send
345:07 - there
345:08 - we've just been issued a new bearer
345:10 - token
345:11 - and then we'll come to the protected
345:13 - route copy in the bearer token
345:16 - and click send and it says you're
345:18 - successfully authenticated
345:20 - if we you know delete some stuff here
345:23 - and
345:24 - pass in an invalid bearer token and
345:26 - click send
345:28 - it's sending the request and not
345:31 - returning anything for some reason
345:33 - and i've actually got an error in my
345:35 - code that i forgot to
345:37 - account for because it's not returning a
345:39 - request
345:40 - so the reason that's happening is
345:42 - because
345:43 - remember we're verifying whether this is
345:45 - a valid token
345:47 - in the first place and only if it's a
345:50 - valid token
345:50 - are we trying the verification so we
345:53 - need to provide
345:54 - an else statement to catch any
345:58 - time where the the actual syntax of the
346:00 - bearer token
346:01 - is wrong and we'll return the same
346:05 - unauthorized status if that's the case
346:08 - so now if we come back and click send we
346:10 - should get an
346:11 - unauthorized response so i'm glad i
346:14 - caught that
346:15 - but basically that's just a
346:16 - demonstration of how we implement our
346:18 - own
346:19 - custom jwt strategy and it's what i use
346:22 - in a lot of my apps for when i'm just
346:24 - getting started and
346:25 - you know providing a basic
346:27 - authentication strategy
346:29 - once again you can check out the github
346:31 - repository associated with this course
346:35 - and go to the custom jwt
346:38 - branch to see the code that i just
346:40 - worked on and
346:41 - last but not least let's go through
346:44 - how do we implement this jwt strategy
346:48 - on the front end and sync it up with all
346:50 - the code that we've written on the back
346:52 - end in express
346:53 - today we're going to be talking about
346:56 - how do we
346:57 - take the passport jwt strategy that we
347:00 - implemented in our express application
347:03 - and
347:04 - kind of port that into a frontend that
347:07 - will handle the jwt
347:09 - and attach it to each of our http
347:12 - requests
347:13 - so we're going to do this with angular
347:16 - and
347:17 - the reason being is because i
347:20 - for one know angular better than most of
347:23 - the front-end frameworks
347:25 - and number two it is very compatible
347:28 - with jwts
347:30 - now if you were to um let's say
347:33 - make an express app and you used ejs
347:38 - as a templating language and that's how
347:42 - you built your front end
347:43 - now in that case sure you could
347:46 - you know somehow implement a jwt
347:49 - [Music]
347:50 - front end but it's going to be a little
347:52 - bit more difficult because
347:55 - the pages that we would be loading on
347:57 - the front end are going to be
347:58 - coming straight from the server well as
348:01 - in an angular application it's an spa or
348:05 - single page application
348:07 - which means everything happens in the
348:09 - browser
348:10 - so that includes the um the jwt stuff
348:14 - and so it's just very compatible for
348:17 - what we're doing here
348:19 - like i said in previous videos the goal
348:21 - of this one
348:22 - is not to teach you how to write an
348:25 - angular app
348:26 - so i'm assuming that you already know
348:29 - kind of the basics of angular we're not
348:31 - going to do anything
348:32 - too crazy but i'm not going to be
348:35 - walking you through the structure
348:37 - of how angular works and all that good
348:39 - stuff the goal here is to show you
348:41 - exactly how we take
348:43 - our express server that is issuing us
348:46 - jwts
348:48 - and translate that into the front end so
348:50 - to do that i want to first
348:52 - walk you through what i've already
348:54 - provided you with
348:56 - in the previous video i introduced the
348:59 - github repository
349:01 - it'll also be in the description here
349:04 - and
349:04 - when you download the repository on the
349:07 - master branch you're going to have
349:09 - a blank template we implemented the
349:12 - first part of that template in the
349:13 - express
349:14 - application in the last video and then
349:17 - the second part of the template is what
349:19 - we're going to be doing in this video
349:21 - and that is sitting in the angular
349:24 - directory
349:25 - and if we open up the main part of this
349:29 - application you'll see several folders
349:33 - already built for you and they're all
349:35 - connected up so
349:37 - this app kind of runs already even
349:39 - though we haven't implemented the actual
349:42 - methods
349:43 - so i'll walk you through it real quick
349:45 - let's start an app.module
349:49 - let's see what we've got here so i've
349:52 - already set up the routes for us
349:54 - so if we visit login register and
349:56 - protected
349:57 - it's going to load the login register
350:00 - and protected components
350:02 - so that's already set up for us in
350:04 - angular kind of gets that out of the way
350:08 - we are declaring those components here
350:11 - let's see here's the router module and
350:14 - this is important we have to
350:17 - implement the use hash option because
350:21 - we have our api from the express
350:24 - application
350:26 - and then we have the routes from the
350:28 - angular application and we don't want
350:29 - those to conflict
350:31 - now down here i kind of debated whether
350:34 - i was going to put this in here
350:36 - but this is the setup for
350:39 - our http interceptors and
350:43 - that is something that we're going to
350:44 - actually implement but i've left
350:46 - the the structure of it
350:49 - intact and it's already included in the
350:52 - main module so you don't have to worry
350:53 - about doing that but
350:55 - this right here is a very special syntax
350:58 - you're probably not used to seeing it if
351:00 - you don't work in angular
351:01 - a lot so that's the app module
351:05 - which is the base of the application
351:08 - app component just has three links
351:11 - so that you can load each of the routes
351:14 - and then
351:15 - i actually put the routes below so we're
351:17 - pretty much staying on one page the
351:19 - whole time
351:20 - and just toggling between the routes by
351:22 - clicking these buttons up here
351:25 - i can go ahead and run this just so we
351:27 - can see what that looks like
351:30 - i don't think we should get any errors
351:32 - so it loaded successfully
351:34 - let's visit in the browser
351:37 - and you can see that our application is
351:40 - very far from beautiful
351:42 - the goal here is not to style it up or
351:45 - anything
351:46 - we just want the functionality so as i
351:49 - said
351:50 - if you click each of these routes
351:52 - they're going to display below
351:54 - so right now we're at the home route so
351:55 - nothing is being displayed
351:57 - but if we click login you'll see a
352:00 - little
352:01 - ugly login form if we click register
352:04 - you'll get the register form and then
352:05 - the protected route
352:08 - is just going to give us a message and
352:10 - in this case we don't get a message
352:12 - because we're not authenticated
352:14 - so that's kind of the the entirety of
352:16 - this application
352:18 - obviously it's not something that you
352:20 - would show to any user but
352:22 - it does give you the setup and the
352:25 - the logic behind how you would start an
352:28 - application okay so let's come back to
352:31 - the code
352:33 - walk through a couple more things that
352:34 - we've got set up
352:36 - and i'll kind of show you what we're
352:37 - going to be doing in this video
352:40 - so the first thing we've got is the off
352:42 - service
352:43 - this is a service that we're going to be
352:46 - spending a good amount of time in
352:48 - as you can see we've got five different
352:50 - methods that we need to implement
352:53 - in order to kind of manage that jwt that
352:56 - was
352:56 - issued from the express server next up
352:59 - we have
353:00 - an auth interceptor which we have to
353:03 - implement the intercept method for this
353:06 - what this is going to do basically is
353:09 - take
353:10 - each http request and it's going to
353:14 - attach the jwt
353:15 - to it so this is kind of the magic
353:18 - behind the scenes
353:20 - then of course we have each of our
353:21 - components so the login
353:24 - protected and registered components
353:27 - let's see what i have implemented here
353:29 - we we basically just have
353:31 - the form functionality implemented so we
353:33 - don't have to walk through that logic
353:36 - so you see here we have a register form
353:39 - then
353:40 - when we submit the register form it's
353:41 - going to call this method
353:43 - which sits right here and in this
353:47 - on register submit we're just going to
353:49 - take the
353:50 - username and password we're going to
353:54 - make a post request to our express
353:57 - application which is on localhost 3000
354:01 - and then we're going to get a response
354:04 - and if it's successful then
354:06 - we're going to navigate back to the
354:07 - login so don't
354:09 - worry too much about what's going on
354:11 - here this is basically just making the
354:13 - request
354:14 - to get the jwt from the express server
354:18 - and then same with the login you're
354:20 - going to see something very similar
354:22 - you have a form here you have a method
354:25 - on submit
354:26 - and that method is going to make a post
354:28 - request to the login route
354:30 - of the express application so go ahead
354:34 - i know i didn't cover absolutely
354:36 - everything
354:37 - so go ahead on your own time and just
354:40 - pause the video
354:41 - and take a look through this angular app
354:44 - just get familiar enough with it and
354:46 - then we will get into
354:47 - actually implementing the jwt
354:51 - um strategy here i think the first thing
354:54 - that we should do
354:56 - is implement this service called off
354:58 - service
355:00 - now this is going to manage how we
355:03 - store and retrieve the jwt token or jwt
355:07 - that we have been
355:08 - issued from the express server before we
355:11 - do that though
355:13 - let's go and quickly review what we're
355:16 - getting
355:16 - from the express server so if you
355:19 - remember from the last video
355:21 - when we register a new user let me
355:25 - go ahead and register a new user real
355:27 - quick
355:28 - we send that oh and it's not going to
355:31 - work because the express app is not
355:33 - running yet
355:34 - so we need to first run the express app
355:40 - okay express app is running we can go
355:42 - back
355:43 - and actually let's how do we cancel this
355:46 - request
355:48 - um cancel all right so let's send it one
355:50 - more time
355:52 - this time we should get success true and
355:55 - here is our jwt so this is how we're
355:58 - getting information from the express
356:00 - server
356:01 - and then if i wanted to log in with that
356:03 - same exact user
356:05 - i could do that with the login route and
356:08 - it's going to give me the same exact
356:09 - data
356:10 - so this is the data that the angular
356:12 - application expects
356:14 - and once we get that data we're going to
356:17 - basically take this token
356:18 - and put it into local storage so
356:22 - that is what this auth service
356:25 - is doing it's basically saying okay once
356:27 - we get the response we want to set local
356:30 - storage
356:31 - then the logout method will basically
356:34 - delete stuff from local storage
356:36 - so on and so forth to help us out and
356:39 - kind of keep things straight
356:42 - um in our heads i'm going to copy in
356:44 - this response
356:46 - that we get from um
356:49 - the express application when we register
356:53 - or log in a user so i'm going to put
356:56 - this here
356:57 - and just comment it out so that we have
357:00 - a representation of what we are
357:02 - expecting to receive
357:04 - and this when we implement this first
357:07 - method here
357:08 - the response object should be this
357:12 - right here so the first thing that we
357:14 - need to do
357:15 - in the set local storage this is going
357:19 - to be
357:19 - when we receive our jwt and we need to
357:22 - put it in local storage
357:24 - so the first thing that we need to do is
357:27 - actually
357:27 - figure out when this jwt
357:31 - expires so in the response body up here
357:34 - we're going to get a value of one day
357:38 - to make things a little bit easier and
357:40 - not have to deal with javascript dates
357:42 - and stuff
357:43 - we're going to use a library called
357:44 - moment.js which is
357:47 - here's the documentation for that and
357:49 - it's pretty simple to be honest
357:52 - moment is the main function gives you
357:55 - the current moment
357:57 - and then you can do whatever you want
357:59 - with it you can format it
358:00 - here's like the live on the right side
358:03 - here is like the live
358:05 - updates to these pieces of code
358:08 - you can also do things like add
358:11 - certain amount of days so this is what
358:14 - we're going to be doing
358:15 - we're just going to be doing moment.add
358:18 - and then pass in
358:20 - that 1d which represents one day
358:23 - so come back to
358:27 - the angular application we're going to
358:30 - just store
358:31 - let's say expires equals
358:35 - moment
358:37 - [Music]
358:39 - dot add and then we're going to say the
358:41 - response
358:42 - object dot expires
358:45 - in alright so we've got the
358:49 - response object right here and then the
358:51 - expires in property
358:53 - so basically this right here equals 1d
358:56 - and if we add that to the current moment
358:58 - that's going to give us the
359:00 - time that this jwt expires
359:04 - after we've figured out when this jwt
359:06 - expires we need to set two things into
359:09 - local storage to do that we can just say
359:12 - local storage dot set
359:15 - item
359:18 - and this set item method is going to
359:21 - take
359:21 - two values so first is the name
359:24 - of or first is the key and second is the
359:27 - value
359:28 - so we'll say token is the key and then
359:32 - the value of that if we look up in
359:34 - the object that we should be getting
359:37 - here
359:38 - it's going to be dot token so
359:41 - we will say response object dot token
359:45 - and if you remember that token is has
359:48 - the bearer
359:49 - included so just keep that in mind as we
359:51 - go forward
359:53 - local storage dot set item and
359:57 - expires so that's going to be our second
359:59 - one
360:00 - and that is going to be
360:04 - the response object as well but we
360:06 - actually have to do
360:07 - a few things to this or excuse me this
360:11 - is not on the response object it is what
360:13 - we just set right here
360:15 - so we need to pass in expires and then
360:18 - we need to do a few things to it
360:20 - so first we need to get the value
360:23 - of this so this is just a javascript
360:26 - method
360:27 - that's going to take the primitive value
360:29 - of a string
360:30 - object and then we will say
360:33 - json.stringify
360:35 - and pass in that value so
360:38 - nothing too special going on here it's
360:41 - literally just to get us
360:42 - in the correct format and that's pretty
360:45 - much it for the set local storage method
360:48 - so we'll receive this object when we log
360:50 - in or register
360:52 - and then angular is going to take that
360:54 - object
360:55 - pass it into set local storage we'll see
360:58 - where this is actually
361:00 - used a little bit later but it's going
361:02 - to take
361:03 - that response object and set these two
361:06 - items in local storage
361:08 - now to log out we're just going to
361:10 - remove those two items
361:12 - so we can say localstorage.remove item
361:15 - and we just pass in the name of the item
361:18 - that we want to remove
361:20 - so once we remove these items from local
361:23 - storage
361:24 - when angular checks to see whether they
361:26 - exist it won't find them
361:28 - and it will make the user log in again
361:31 - so that's kind of what is going on here
361:36 - the next thing that we're going to do is
361:39 - this get expiration method and that is
361:42 - because
361:43 - this method is going to be required to
361:45 - see if a user is logged in
361:48 - now if we issue a jwt
361:51 - to a user then that means from
361:54 - um that the express application has
361:57 - already
361:59 - done all of the crypto cryptographic
362:01 - logic
362:02 - to decide whether the user is actually
362:04 - valid
362:06 - so if the angular application receives
362:09 - this
362:09 - response then we know that they are
362:12 - pretty much logged in so all we have to
362:15 - do is check whether the
362:17 - jwt is expired and if it is expired we
362:21 - need to delete it from local storage
362:23 - otherwise we can consider this user to
362:26 - be logged in
362:27 - so to grab that expires from
362:31 - the local storage we're just going to
362:33 - paste in a few lines here
362:36 - so first we're going to get the item
362:38 - it's not expires at it should be
362:40 - expires as we set it up here
362:44 - and then we're going to figure out um
362:47 - the so json parse is going to take the
362:50 - json our
362:50 - object and make it a javascript object
362:53 - this last return
362:54 - value is just going to calculate using
362:57 - the moment library
362:58 - it's going to just calculate the point
363:01 - in time
363:02 - which this jwt actually expires
363:06 - and then we'll come up in the is logged
363:08 - in
363:09 - route or not route but function and
363:12 - we're going to
363:12 - take this value the expiration value and
363:16 - see if the current time
363:18 - is before or after it to do that
363:21 - we just say return moment
363:25 - dot is before this is just a method that
363:28 - we have available to us
363:30 - and then we're going to pass in this dot
363:32 - get expiration
363:34 - which will return us the moment that
363:37 - this jwt
363:38 - expires and if
363:41 - it returns true then that means that the
363:44 - jwt is still valid
363:46 - and we should still be logged in then
363:48 - the last method here
363:50 - is just going to return the opposite
363:54 - of this dot is logged in pretty simple
363:58 - now that we've implemented this off
364:00 - service let's go ahead and see it in
364:03 - action before we do that i want to
364:05 - remind you what is happening
364:07 - when we register a user using the
364:10 - register component
364:12 - when the user presses submit
364:15 - on the register form this post request
364:18 - is going to be sent out to our express
364:20 - application which is running over here
364:23 - which will return that big
364:24 - object that we were talking about and
364:26 - looked at
364:28 - and then once we receive that response
364:30 - object we're going to pass it into the
364:32 - set local storage method
364:34 - which will set our token and expires
364:38 - properties in local storage
364:41 - let's test this out go to google chrome
364:46 - right now if i refresh the page you'll
364:48 - see that in the application
364:50 - we don't have anything in local storage
364:53 - for this
364:54 - application now let's go to
364:58 - the register route and let's put in
365:01 - something like jwt test
365:06 - and then a password of one two three and
365:09 - when we click register we should be
365:11 - redirected to the login route
365:13 - and you'll see that these two the token
365:16 - and the expires has been
365:18 - set to the local storage we also
365:21 - will console log the user object that we
365:25 - got
365:26 - back from the express server just to see
365:28 - that it was successful
365:30 - at this point we actually don't even
365:33 - need to log in
365:34 - necessarily because we've got these
365:36 - things set in the local storage
365:38 - but why don't we just go and do it jwt
365:41 - test
365:42 - one two three and then we're going to be
365:46 - redirected to the protected route
365:49 - but it says you are not authorized to
365:51 - visit this route
365:52 - no data is displayed and the reason
365:55 - being
365:56 - is because we have not yet implemented
365:58 - our
365:59 - interceptor which is going to take the
366:02 - jwt that is sitting
366:04 - right here in local storage and append
366:07 - it to every http request
366:10 - that we make in our express applica or
366:13 - our angular application
366:14 - in other words we need to find a way to
366:17 - when we click
366:18 - visit protected route while there is a
366:21 - token
366:22 - that is valid in local storage to get it
366:25 - to actually work
366:26 - looking at the protected component
366:30 - you can see that what this is doing when
366:33 - we
366:33 - click visit that route so ng
366:37 - on init so when this component is loaded
366:40 - the first thing that it will do
366:41 - is make a get request to
366:44 - this link right here which on our
366:48 - express application
366:49 - as you saw in the last video is only
366:51 - going to allow users to receive the
366:54 - correct data
366:55 - if they are authenticated with a jwt
366:59 - that the express server deems as valid
367:02 - right here is the protected route and if
367:05 - we
367:06 - are not authenticating correctly if our
367:08 - if we don't have a jwt attached to this
367:11 - get request or the jwt is invalid
367:14 - we should receive a 401 unauthorized
367:17 - error
367:18 - if we are valid then we should receive
367:20 - this message right here
367:21 - so here's the message you are authorized
367:25 - okay so let's close this out go back to
367:27 - the protected component
367:29 - and you'll see that if we get a response
367:32 - we're going to print
367:33 - the message attached that response so we
367:36 - should see
367:36 - what we were just looking at in the
367:39 - express application
367:41 - if it was successful but if we have an
367:44 - error which is going to be a status of
367:47 - 401
367:48 - or unauthorized the message is going to
367:51 - be you are not authorized to visit this
367:53 - route
367:53 - and we saw that earlier in the browser
367:57 - so let's go solve the last piece of the
367:59 - puzzle open up the auth
368:01 - interceptor which right now is empty
368:04 - i'm going to paste in the implementation
368:06 - here
368:07 - and then we're going to walk through it
368:09 - so let me indent this correctly
368:14 - okay so again this is not an angular
368:18 - tutorial you're going to have to read up
368:20 - on
368:20 - interceptors which you can find on their
368:23 - documentation it gives you a lot of
368:24 - examples
368:26 - but basically what this is doing is kind
368:28 - of intercepting
368:29 - every http request that angular
368:33 - is sending out and it's going to attach
368:37 - or it's going to run the intercept
368:38 - method so
368:40 - what we're doing here is first we're
368:42 - grabbing
368:44 - this should not be id token should be
368:46 - just token
368:47 - we're grabbing the token from local
368:50 - storage
368:52 - and then if there is an id token so if
368:55 - we get a token from local storage
368:57 - then so far we're good what we're going
369:00 - to do
369:01 - is clone the request so we're taking the
369:04 - current request
369:06 - that is going through the chain of
369:08 - interceptors
369:09 - it's kind of like middleware and express
369:11 - almost
369:12 - and we're going to take that and clone
369:14 - it but this time
369:16 - we're going to set the authorization
369:18 - header
369:19 - equal to the id token so that should set
369:23 - authorate authorization header equal to
369:26 - bearer and then a space
369:27 - and then the jwt then we say
369:30 - return next dot handle and pass in that
369:33 - cloned object
369:35 - so that should basically right here that
369:38 - should
369:38 - successfully attach the jwt
369:42 - if we don't find a token which is very
369:44 - possible if the user is not logged in
369:46 - then we just return next.handle the
369:49 - request
369:50 - and there's going to be no authorization
369:53 - header whatsoever
369:55 - we now have an auth interceptor which
369:57 - should attach
369:58 - this jwt token to our request
370:02 - now if we go to the browser to our
370:05 - application
370:06 - technically if we visit this protected
370:09 - route right now
370:11 - it should say that we are authorized
370:13 - because
370:14 - you remember we already logged in and
370:17 - you'll see that we have the token and
370:19 - the expires
370:20 - already in the browser so as long as we
370:24 - attach
370:24 - this to our next request it should
370:28 - authenticate us so let's try that
370:32 - if you remember from the last request
370:35 - there was no
370:36 - author authorization header but now if
370:39 - we visit the protected route
370:41 - it says you are authorized and if we go
370:44 - to the network tab
370:45 - this is a little bit tricky you're
370:47 - probably tempted to click on localhost
370:50 - but we need to click on protected
370:53 - and you'll see that down in the request
370:55 - headers
370:56 - there is this authorization header which
370:59 - has the jwt that we had stored in local
371:02 - storage
371:04 - so that is the basic flow and you can
371:07 - use this concept
371:09 - to basically manage your users within an
371:12 - angular application and obviously there
371:15 - could be
371:16 - users with different types of
371:17 - permissions and
371:19 - that would require you to come back to
371:22 - your interceptor and write in some
371:25 - custom logic to say
371:27 - okay hey based on what role this user
371:29 - has
371:30 - are we going to attach you know the jwt
371:34 - or not and also you might
371:37 - be you might have routes on the express
371:40 - application
371:41 - that may or may not require
371:43 - authentication
371:44 - but hopefully this implementation
371:47 - so the combination of this auth
371:49 - interceptor
371:51 - and the off service hopefully those two
371:54 - things
371:55 - along with the previous video where we
371:57 - talked about
371:58 - how do we actually issue that jwt have
372:02 - brought your understanding of user
372:04 - authentication
372:05 - um you know to a conclusion and
372:08 - hopefully this all makes sense
372:11 - this is just one way that we can
372:12 - implement user authentication
372:15 - in our front end or angular app
372:19 - you're going to see a lot of different
372:20 - implementations across
372:22 - a lot of different coding languages the
372:25 - most important thing
372:26 - is to understand how everything works
372:29 - how does the jwt work
372:31 - and how are we supposed to kind of pass
372:34 - it from the front end to the back end
372:36 - once you understand that it should be a
372:38 - breeze to implement
372:40 - your own authentication strategy you
372:42 - never thought that we'd make it to this
372:44 - point
372:44 - but we're here we're at the end of this
372:47 - super long
372:48 - user authentication crash course and i
372:50 - want to say a big thank you
372:52 - if you watched all the way through
372:54 - that's really an accomplishment to get
372:56 - through
372:56 - you know however many hours this took us
372:59 - to understand all these concepts
373:02 - and if you are one of those crazy people
373:03 - that went from the very beginning of
373:05 - this
373:05 - uh course all the way to the end here
373:08 - and didn't skip
373:09 - anything i'd love to hear from you i'm
373:11 - on twitter at zg
373:12 - underscore dev and i'd really love to
373:15 - hear from you so
373:16 - reach out tell me what you thought about
373:17 - this course or just say hi once again
373:19 - i'd really appreciate if you checked out
373:21 - my much smaller youtube channel and just
373:24 - gave it a look
373:25 - and until next time i will see you later

Cleaned transcript:

welcome to my complete beginners course on user authentication in web apps in this course we're going to be talking about how do you actually write that register form or the login form for your users using node.js express and passport.js and then later in the course we'll actually go into how do we apply these strategies to an angular application and then even further how do we write our own custom jwt authentication option but before we get into that i want to just introduce myself i'm zach and i'm a full stack developer i've got a smaller youtube channel where i cover a lot of these topics and i've been writing code for about four and a half years pretty much every day at this point and i'm super excited to share this particular series because it was one of the biggest struggles that i had when i was first learning to code i struggled with it for two main reasons number one i was scared of it i was scared to write a user authentication option because you know everyone talks about you know infosec and trying to secure your web apps as strongly as possible and how there's always you know loopholes and bugs and you know exploits and stuff like that and so this whole user authentication topic was very intimidating to me the second reason that it was really tough for me is because everyone made it look so easy i would watch tutorials where we'd get through the user authentication section in about 10 minutes and i was left just scratching my head because i had no idea what had just happened i had copied the code in the tutorial but i had no idea what was going on behind the scenes in this tutorial i want to solve both of those problems so with the security side of things this all gets easier when you realize that you know when you're first building your apps the the prototype version it's not important to you know secure your app on a grand scale like a corporation would have to the methods i'm going to teach within this course are perfect for someone who's just trying to get a basic auth strategy implemented and put it into their you know prototype app or even a small scale business it's going to be secure enough for something like that and on the second point in terms of understanding what's going on behind the scenes i really hope that this tutorial is the most indepth user authentication tutorial that you have ever seen as you can see by the length of this video it is very long and the reason being is not because it takes us you know this many hours to implement authentication but because it takes us this many hours to understand all of the different components that go into an authentication scheme for example if we're using passport js we have to understand middlewares in express because passport.js is a middleware and not only that but it's actually a little bit more complex middleware than you're probably using on a normal basis on the actual authentication side of things there's a ton of topics that we don't really you know associate with user authentication when we're just trying to implement it for example do we understand cookies in the browser do we understand http headers that allow us to set those cookies do you understand how a json web token works what's in the payload of that json web token and furthermore in the payload of that json web token we're using techniques like hashing algorithms and cryptography these are not simple topics there are universities that have entire curriculums on just cryptography and concepts associated with it so as you can imagine talking through all of these things is going to take some time but i can assure you i'm going to walk you from point a to point b and i'm not going to leave you hanging on any part of this tutorial i genuinely hope that you enjoy it as much as i enjoyed making it and at this point i think we're ready to jump in today we're going to be talking about how you can implement user authentication in your web applications using node.js express.js and passport.js and we're first going to kind of jump into what are your authentication options in general i know that's a question that i had for a long time you know what do we have i hear stuff about jwt username and password and then you've got all this other stuff like oauth and even some custom strategies that you can use to authenticate your users so we'll go through that then we'll talk a little bit about the passport js framework what it is what kind of structure does it use to authenticate users into the apps and then what are some of the different strategies that you can use within it and then finally we'll actually go into the implementation of the passport local strategy in the passport jwt strategy although we'll talk about which strategies we might use in different situations both of these strategies are going to be really good for anyone who is just trying to get their app off the ground and their primary focus is not necessarily on authentication but they actually need authentication to get it off the ground so these are kind of like the the bare bones um most basic way to authenticate users into an application and it's going to be great for you know individuals small teams startups anyone that is building their application from scratch there are a few prerequisites for this tutorial series i've pretty much assumed that you already know the basics of coding within the node.js ecosystem so that means you know you have a pretty good understanding of node.js modules and package.jsons all of that kind of stuff as well as things like the express framework also things like asynchronous programming so promises and callbacks hopefully you're at least a little bit familiar with all of the topics here on the screen if not you can still get through the tutorial but i would highly suggest kind of brushing up on anything that you're not you don't have a very basic understanding of the first thing that i want to cover is what are your authentication options here before we get into any coding it's pretty important to take a look at what's available to us and deciding what is my use case and what's going to be best for that use case so on the screen i've laid out all of the authentication options that you might find if you are in the node.js ecosystem or any other ecosystem for that matter and they are listed from least complex to most complex but that does not mean that the least complex option is the worst option it just means that as you kind of move up that chain it's going to require a little bit more understanding more pieces that you have to understand to implement the strategy itself in the scope of this tutorial series we're just going to be sticking with the left two so the session based authentication aka the passport local strategy and the json web token or jwt authentication or aka the passport jwt strategy now you also have a little bit more complex authentication that you'll see especially if you're trying to use um a large api like maybe the youtube api or any google api um even github's api these big companies rely on oauth it's just a protocol to give different access rights to users trying to access resources within their api so you'll kind of get the gist of what that is as we get into the jwt authentication but i'm going to stay away from completely diving into the oauth although we're not going to actually get into the the coding implementation of solutions like oauth or even custom solutions it's definitely important to at least touch on it so what oauth is all about it's it's just a protocol and i know that can get pretty confusing when you have um software as a service providers such as auth0 and octa among others that actually provide this oauth protocol as a service so you it's really confusing if you look at those companies you know namely one that's named off zero which sounds like a protocol it gets really jumbled in your head like what's the protocol what's the company you know how is all this working so really what oauth what the oauth protocol aims to do is separate out the two components of we'll call user authentication i got to be careful with the terminology here because there's a big difference between authorization and authentication so on the left with the jwts and the local logins the session based authentication that is all about knowing who the user is and that is what we would call authentication now on the other side of things if you have seen things like social logins like sign in with google or sign in with facebook that's a little bit more about authorization so that's kind of it's not as much who who we're talking about but instead who has access to what resources so in other words you'll get into things like scopes you know what does this particular subject or user have authorization to access does it have authorization to make just get requests against the api or does it also have authorization to edit certain resources within the api so as you might guess using the oauth protocol and you'll also hear things like open id connect is closely related that is going to be used with these bigger services where you know maybe one company such as google allows users that have varying authorizations to access the api in the same way so if i or you wanted to access resources from say google's youtube data api so if we wanted to get youtube analytics or something like that we don't have authorization to do certain things within that api and that is defined by the scopes that we are basically provided in our access token that's related to the oauth protocol now i know all that sounds very complex and it's definitely not something that you can even begin to understand completely in just a few minutes but i did want to talk about that um and kind of just mention what it is and why we're not going to get into all the details of it i think we have plenty on our plate with the session based authentication and the jwt based authentication to even start talking about that so those are your options we're going to stick with the two on the left the least complex ones and probably the most common implementations that you'll see for startups and people who are just trying to get their application off the ground and worry about the complex authentication of it a little bit later down the road when they have either more resources more money or both that can actually spend the time to implement something a little bit more complex like the oauth protocol to wrap up this introductory video i wanted to give a brief overview of what the passport.js framework is and the reason being is we're actually going to be implementing two different strategies within the passport framework but that just basically means that we have two different middlewares that are connecting into the bigger passport js middleware so you might ask what is a middleware for those that are not familiar what middlewares are in express or are just a little bit fuzzy on how they work i have created a video that will be included in this playlist so that you can brush up on that and get yourself up to speed but basically all that passport js is is a middleware that integrates within your express.js application and handles all of the authentication logic using the specific strategy that you choose to plug into the passport.js framework now the strategies that are included if we go to passport js we can go to the home page and see that there are plenty of different strategies here so we can do anything from the passport local and passport jwt like we're doing and we can also do something a lot more complex you can see that we have stuff like the passport oauth 2 which is what we just talked about or even you know something more specific passport instagram we can use the instagram login to authenticate our and delegate access to our users so there's a lot of different strategies and all of these strategies have been created by independent developers that basically say okay here's the passport.js framework it's just a middleware and it allows me to kind of use that framework as a starting point and then we can just build in the the specific pieces of authentication in our own middleware which we call a strategy so in summary passport js is just a framework that is a middleware that also allows individual developers to develop other middlewares called strategies that connect in with this bigger middleware that we call the passport.js framework and then all of that gets wrapped up into a bundle and put into your express app and it works seamlessly with your express routes we'll see in a lot more detail how each of these strategies the local and jwt strategy work as we go through the series but it is important to just understand the basics of what this is if i had to sum up the code logic of passport.js in a few sentences it would basically be this so passport.js is a middleware as we just talked about and on every http request that a user calls to our express server the passport framework is going to first pick up okay what strategy are we using here and then it will use that strategy to say hey is that user that just requested that resource authenticated if that user is authenticated then passport is going to let that user access the resource it's going to you know go into the express route if that user is not authenticated based on the strategy we're using then passport is going to return a 401 http status which is basically the unauthorized status so that's kind of passport.js in a nutshell again it's going to get a lot easier as we see the actual code flow of what's going on with this middleware congratulations you made it through the first part of this super long tutorial on user authentication now we talked about all the different options here and we're not going to be covering some of those delegated authentication options but there's plenty to cover with the other ones and particularly with the passport local authentication strategy where we're going to be using the express session middleware having a solid understanding of http headers and http cookies is going to be absolutely essential as a web developer you go on a bunch of different sites and you click that accept button when they say you know we use cookies on this website but you actually know what that means i think you're going to find this section interesting but let's go ahead and dive in what is an http header i think it's something that we know in the back of our heads kind of what it is especially if we program a lot of web apps but it's also something that we don't spend a lot of time trying to learn and we frankly don't need to learn a whole lot about them that said we do need to specifically learn about an http header called the set cookie and the cookie header in order to understand how serverside sessions work and kind of interact with the browser so if we come to google.com right here i always use this as an example just because it's pretty arbitrary spot if you open up your developer console here in google chrome and go to the network tab you'll see that it is pretty much empty right now but if we click refresh on the google search and we're basically doing a get request to google.com and you'll see a bunch of stuff loading a lot of these are the resources that run the page or scripts but at the top you see this www.google.com if we click on this you'll see that there are some headers here and you'll see that the headers come in three basic categories first you have the general headers then you have the response headers and finally the request headers what we're specifically interested in in this case to understand what a cookie is and how it works is the request and the response headers but we can also kind of explore the rest you can go on to mdn is a great place to look and you can see there's you know a link to all sorts of different headers so we can go down here into security and these are all the different security headers that you could set in either the general response or request headers now let's take a step back and really think about what just happened when we pressed the refresh button in our browser to load google.com if you think about it a http client could be anything from an iot device someone like me sitting at my desk or at a coffee shop you could think of it as just a laptop or a phone pretty much anything that connects to the internet is considered an http client now on the other side of things is all of the http servers and those servers google in this case is going to house the information that the clients want to access or update or do other operations on so in our case what we did was do a get request to google.com in other words we want the resources at that web page so if you look at the headers here in the chrome tools you'll see as we talked about we have these three categories so let's just go ahead and walk through each of them and see what was relevant to our request so in the the first one the general headers these can be either request or response related they're just kind of general metadata about the request such as what is the url that we're requesting what type of method are we using so this is a get request those were both probably those are in the request side of things now if we go to the response side of things you'll see that we got a status code of 200 which means that we requested data from google and it sent back the data successfully so you can see that we have several you know things that kind of mix between the request and response now in our particular situation when we searched google we formed or we didn't form but the browser that we were using created a request header which is basically instructions for the server in what data you know the request wants so i'm the client here sitting at my computer so the the browser on my behalf is going to say hey whoever i'm trying to get these resources from i'm going to put in the request headers what kind of data i accept so you can see that we have things like the accept encoding except language and then just the accept http header and we're basically saying that we accept html we accept xml and a couple other different options but you can just think of this request header as the instructions for the server that you're requesting resources from or trying to modify what type of data that the client myself will accept in the browser is not the only thing that you can put in this request header you can put all sorts of other things you see there's a cookie in here we'll talk about that in a few minutes but you also have things like the user agent tells us what browser is requesting this data and then if again you can go to the mdn site and look at a broad variety of different things that you could put in the request header so you can click on the request context and you can kind of see some of the things that you can put in that so we know that http headers are basically metadata about our our http request so we can also do that on the response which would be set by the server which in this case is google so one of google's servers whichever gave us the content that we're viewing on the web right now is going to set these response headers and these response headers are going to give additional instructions to the client that requested the data in the first place so you can go through a couple of these and see you can see the content type so if you remember in the request header our you know the client which is the browser i'm sitting in and using right now said i only accept a certain type of data and then the response is going to say okay you only accept that type of data here's the data and here is what type it is so this is useful if you know we're trying to figure out how to display that data in the browser of course there are other things that that you'll see here but i want to direct your attention to something very relevant to what we're talking about right now which is the set cookie header now you can see that the set cookie header is basically giving key value pairs and you can see you know right here it says expires equals friday the 31st of january 2020 at this specific time so you might be asking well there's a cookie header in the request object and there was a cookie header in the response object how can that be what is the difference between the two and how do they work over the next few minutes i'm going to walk you through exactly how the set cookie and the cookie headers kind of work together and then in another video we'll actually talk about how this all plays into what we call a serverside session the easiest way to understand what a cookie is and how it works is to remember that http protocol is a stateless protocol in other words it's going to constantly forget what the user has done on the site unless we have a way to remember that so in other words if we go to google let's just imagine the scenario we go to google and we sign in to google and we'll just assume they actually probably don't use this method but we'll just assume that they're using cookies and server side sessions to authenticate us so what happens is google the server is going to say okay the client that just you know signed in gave us valid credentials and so what we want to do is you know send something back that allows the browser to remember that this user has logged in if we don't have anything like cookies or local storage probably more modern way to do it if we don't have these types of persistent storage then every time we refresh the page our the state that we had previously where google said okay we logged you in is going to have to be redone so every time you refresh the page you're going to have to enter your login credentials which of course is a terrible user experience and any site that does that is going to lose their users immediately because they're going to get completely tired of typing in their login credentials so this is where the set cookie and cookie headers come in so let's do a little experiment here and i know this is not a perfect example but i think it will do for what we're trying to accomplish here so let's click on the application and open up cookies for google you'll see that there's all sorts of cookies you know google knows everything about everyone so we can just go ahead and delete these it doesn't hurt anything to delete all these cookies so at the moment our browser has no cookie set whatsoever so we can come back to the network tab and let's go ahead and refresh the page once more you'll see that we had this google.com here and we can open up the response and request headers and you'll see that the request headers it's pretty much the same as what we had looked at before and then in the response headers we once again have these set cookie headers and what these are doing is basically saying okay or the the google server is saying okay client i want to set this information about you so we'll just assume maybe we just logged in and google wants to tell the browser that i the client is logged in and we don't need to reauthenticate every single time that we've refreshed the page so what happens here is we have these set cookie headers and let's just pick a very specific key value pair here just to see what's actually happening so let's get a pretty easy one we'll just say the 1p jar it gives us a date of 2020 121 i'm not exactly sure what that means but keep this in mind this is what we're going to be looking for so if you go to the application you'll see that now these are set in the cookies field so we have the 1p jar and then the value that was set in this response header so now what our browser will do is it says okay now we have a cookie set so every request that we make within this domain so google.com i want to attach those cookies that were set based on this set cookie http header in the response header so what's going to happen is when we press refresh again it's going to actually put these cookies in the request headers so right here in this cookie request header we should see something like these set cookies that google the server had put into our browser so let's click refresh once more go to thegoogle.com and look at the request headers and you can see that now this cookie header right here has that 1p underscore jar cookie key value pair so just to recap what just happened we had a client me refreshing or doing a get request against google.com and whatever google server that gave me that data said i want to set a cookie in this client's browser so it uses the response header to do that it assigns these values in the set cookie header and then when we reload the page our google chrome browser or any browser for that matter is going to say okay my default behavior is this is to look up what cookies are currently set in my browser and i'm going to attach those cookies to every single request for the domain context that it is applicable to which is google.com in this matter if you really think about it this method of setting and then the browser just attaching the cookie to each request is a really powerful thing when it comes to user authentication you could say hey maybe my server can do some sort of logic and say okay is that user valid invalid did they give me the right password if they authenticated correctly then i do the set cookie header in the response object and then now the user or the client that is using my web application now has that cookie that says yes this user has already been authenticated and then the browser every time it reloads will attach that cookie and you don't have to relog in that user now the real question is how long do we keep that user logged in and that's a totally arbitrary question but we can do that with the expires piece of this set cookie http header if we come over to the network tab and look at the response headers from google you'll see that there's the cookie that's being set so 1p jar it looks like this is actually set on every get request to google but you'll notice that it has an expires piece to it so this is what tells the browser how long to store that cookie key value pair within the the client so we can actually go through this exercise on our own using some simple javascript to see exactly how it's working so let's go to the console and type in a few quick commands so first we're going to create a new date which is going to represent the date and time right when i click enter so we'll say enter and then we're going to say we want to set the time 20 seconds later so let's do that and then finally let's set a cookie to the browser with the an expires header at that time so we really only have a few seconds but you can see that we have a custom cookie that's going to be there for about 20 seconds so if we reload right now it shows that it's gone so let's go ahead and do that one more time a little bit quicker this time so here's our cookie go over to application you'll see that we have the custom cookie and every time we refresh the browser you're going to see that cookie is going to stay there but then in about 20 seconds which is coming up here in a few seconds i think you'll see that that cookie actually will drop off and it will no longer be attached to the http request so if we refresh you'll see it's gone and that user will say that that was a cookie that gave a user or the client's authentication status that's gone the user has to relogin now obviously you're not going to set a cookie to last for 20 seconds you might more realistically say that you want the cookie to last for two weeks and that is a really powerful way to keep some sort of persistent state within the browser and not require users to log in every time they refresh the page the next part of this tutorial is all about express middleware in order for us to implement the passport local strategy which utilizes express session we're going to have to understand middleware and that's because both passport.js and express session are both middlewares if you don't understand this concept really well then both of those libraries are going to be confusing to you furthermore i'd consider this one of the most essential topics of programming in the express framework while the official express documentation does cover express middlewares in some capacity and it's relatively clear when i was a beginner i'd never understood it fully and even to the point you know two years into my programming journey i still did not have a solid grasp on this express middleware after learning it in depth for the first time i can really confidently say that this is going to be one of the most important lessons that you learn you know as a node.js developer using that express framework so without further ado let's dive into this express middleware overview when you start out using express.js as a framework it's an entirely middleware based framework but generally when you first learn it you're just copying in you know the different pieces and you know that there's kind of something working behind the scenes but you don't know exactly how it's working so in this video we're going to talk about how exactly does this middleware work and how does the request response and next or callback object as well as even the air object work in express application in order to do this we need to spin up a really quick basic application um what i'm working in here again this is part of the passport.js series so i'm in the repository that we're using for that but don't worry this is just a basic express app so we first need to require in express i've already installed this with npm so i don't need to do that and then we say app equals express and then we just say app.listen on port 3000 so right there is the most basic form of an express server that you can spin up and if we were to visit localhost 3000 we're not going to get anything but if we just throw in one simple route app.get and then we pass in the request response and next objects and then we send some sort of data we can now run this in the browser so let's use nodemon which is going to automatically update on every time i save and we'll run app.js so we're running app.js it's listening on port 3000 and it'll be listening on localhost so if we go to the browser and visit localhost 3000 port 3000 you should see the hello world so we have a basic server running and that's all we need to do to start understanding how middleware works in express so we come back to the code here and the first thing that you need to understand is this right here so with our app.get this is just a route that we've established in our express application we are passing in a route string and a callback function usually you'll see it in this syntax but to better understand it we can just basically write a function where we say request response and next now to make this even more transparent what i'm going to do is name these custom properties so normally you're going to just see it r r e q r e s for request and response and then next but you don't need to call them that it's just always going to be passed in you can call them whatever you want so we can say request object response object and callback function so well actually we probably shouldn't call it the callback function we should say maybe next middleware or something like that because the purpose of this last parameter is if we call it as a function it will pass it to the next middleware in the chain so we'll understand that a little bit better in a second but first let's go ahead and write our function so we need to give it a function name so we'll just say standard express callback and we pass in these three parameters and then we can say res.send and hello world so basically we've got the same exact thing that we had below in the app.git route to implement this let's just delete what we wrote here and let's just pass in our standard express callback so we've defined it up here we know that express as a framework is going to pass in these three parameters and so there we can just throw it into our route and click save and then if we come to the browser again if we refresh the page it's going to say res is not defined and the reason being is because i was dumb and forgot to update that so now that we're passing in request and response object we obviously need to also use that in the body of the function so that was just a silly mistake but now if we come to the browser and do it again we should get hello world as we expected so that's the most basic way that an express route works and we're using this function that we had defined so just like we could define this function we can also define other functions which we call middleware so the way that we do that is pretty simple we'll just say middleware one and what we need to do is pass in those same three objects that we were using before so the request object response object in next middleware or whatever you want to call them in this case i'll just say record req res and next like you would normally see it and then we can do whatever we want in this middleware so maybe we'll just say console.log i am a middleware and then in this one this is the standard express callback this is where we return some data we can say console.log i am the standard express function so if we just define that function up here and we don't do anything with it it's not going to do anything obviously but we can pass that into our route to make it work for us so let's pass in the middleware one and a comma so you can see that express as a framework allows you to pass in pretty much as many parameters to the different route functions as you want let's go ahead and save this real quick um let me open up the terminal a little bit more so that we can see what's going on and let's go to the browser and visit that same route we'll go ahead and click refresh here and you're gonna see that this is gonna just keep loading it's not gonna ever return us data and if we were to you know copy this into a new tab and click enter it's not gonna actually return us anything and that brings up a very good point with express middleware if we come back to our code that we wrote you'll notice that in this middleware that we passed into our route that we were visiting we haven't actually called this next parameter so in the express framework the next parameter is going to be actually a function and all we have to do is call it at the bottom of our middleware and what that's going to do is it's going to say for this route right here we first run middleware middleware number one or middleware one and in middleware one we call the next function that was passed in as a parameter by default by express and when we call that it's going to basically say okay now we get to go to the next middleware or in this case it's the last one it's the standard express callback so if we don't put that next function and call it it's never going to get to this last function and we're not going to ever return any data so now that we've called this next function we should be able to go back to the browser and see a response so if we refresh we'll see that it should return hello world and you see that it did return it and if we come back to our code again you'll see in the console that we printed i actually ran this route twice so we printed i am a middleware and then i am the standard express function and the order of this is very important because first in the route we run this middleware and then we run the standard express callback so first we're going to console.log i am a middleware second we're going to console.log i am an express function so that is the basics of how this middleware works but we also have a few other things to understand so what we've been using so far by passing the middleware into the route itself is a route specific middleware now this is kind of i just think of it this way i don't know if it's the exact term that you would use but i call this a route specific middleware but you also can have global middleware so if i took this out of the route and i came up to the top right under the definition for the app and i say app.use what this function built into express expects is a function or a middleware that it can execute so in this case i'm going to just take middleware number one or middleware one and say app.use middleware1 so what's going to happen is the express app is going to initialize and then it's going to initialize the middleware one so let's go ahead and see what happens in the console when we do this so i'll let me make sure i got this right so we've got our middleware defined here we call next and we're initializing it with the app.use up here so let's save that and you'll see that nothing has happened in the console yet you might expect since we did this outside of a route that it would just automatically print i am a middleware and go to the next something but that's not the case when we say app.use it's basically just adding a piece to that chain of functions or middlewares that we're going to be calling so once again we have to come back to google chrome and execute this git route so let's enter and so it loads correctly and then if we come back to the code again now you're going to see i am a middleware and i am the standard express function so what just happened here well first off we defined that this is the first middleware that we want to use in all of our routes it's not just specific to this particular route it's going to happen in any route that we define within our application next we have the standard express callback which is in this specific route so first the route's going to call middleware 1 then it's going to com call whatever we had defined as the callback to that route so the order of the middleware that we define in the scope whether it's a global or a route specific middleware really matters so let's go ahead and see what happens if we switch up the order of the middleware and maybe even add another middleware into this equation so let's say we have another middleware called middleware 2 and again we pass in the default objects that we are provided by or provided with by the express framework and we'll say console.log i am middleware number two and maybe we should just update this one up here to number one so we've got middleware number one and middleware number two and what i'm going to do is say app.use middleware to okay so we are using two middlewares and then we have the standard express callback which at this point i'm just going to go ahead and put it in a form that we're used to seeing so we'll just use request res and next this is what you'll see in most tutorials so i want to keep it consistent so let's copy that in there delete the function declaration and then of course since we changed the name of the parameter we need to also change the name of the object that we're using to send the data all right so let's just quickly recap what we got we have one route in our application which has a very standard syntax all we're doing is we're sending back an h1 tag with hello world in it so far in this route we haven't defined any route specific middleware but we have defined global middleware so let's see what happens go ahead and kind of make your guess as to what's going to happen here but if i had to guess we're probably going to print i middleware number one and then i am middleware number two when we call that route and then finally we'll you know console.log i am the standard express function all right so we've saved it let's go back to the browser click refresh and i don't know why it hangs sometimes here try it again maybe we have some sort of air did a little bit of refactoring nope it was doing just fine we've got all the things that we expected so if you could guess what's actually happening here is again we forgot to call the next function in the middleware 2 so it never reached this final function save it once more come to the browser once more and refresh we should get a good response come back to the code and you'll see i am middleware number one i am middleware number two and i am the standard express function all right so everything is as expected and now is where the real you know understanding comes into play because oftentimes when we're using an express application we've got all sorts of middleware working together in most express applications you're going to have several app.use statements so you might say app.use course crossorigin resource sharing that's a pretty common one or app.use body parser and then whatever the configuration for that was so you might have up to like 10 15 even 20 different middlewares that you are adding to your express application and so it's really important to understand that the order that we put these in matters so if we were to put middleware 1 after middleware 2 all we did was change the order of those statements if we save and then go to the browser and call that route you're going to notice that when we come back to the code we now have things out of order so we have i am middleware number two coming before number one so that's really important to understand and then of course if you put one of these within the route itself it affects the order as well so let's add one more middleware to this equation and it's just let's just copy this do the same thing so we'll call this one number three number three right there and then we're gonna take middleware number three and put it in the route itself so let's copy it right there give it a comma and now what's going to happen is we should have middleware 2 called first then middleware 1 then it goes into the route specific middleware so then we have middleware three and then finally this last function which we technically could call middleware as well so let's see if that worked we should have middleware two one then three so let's go to the browser run the route come back to our code and you see that we have two one and three exactly how we defined it two 1 and then the route specific middleware there are two more things that i want to talk about when covering the topic of express middleware and one of those is air handling because an air handler in express is also just another middleware but it's actually a special type of middleware so in order to define an air handling middleware what we have to do is define a function with a fourth parameter so let's go ahead and define a function called air handler and you'll see that in this app i've kind of simplified it a little bit so we only have one middleware we got rid of all the rest of the stuff but this time we're going to pass in an error parameter then the request res and next parameters so this is how we define an error handling function and we can you know this is basically a middleware so we can do as many error handlers as we want so if we wanted to catch specific types of errors so we say if air dot status equals something then we want to you know handle it in this one and then we could come down and do another error handler and say this is error handler number two and if error air dot status is number two number one you kind of get the point we can define as many of these as we want and handle different types of errors depending on the application that we're doing but what is going to happen here is this error parameter will be populated with an error if it exists so what we can do is we can say something like maybe instead of throwing the air explicitly we'll say if there's an error what we can do is res.send and we can say there was an error please try again so something more friendly than a default error that you would you might get in the browser that would crash the entire application so let's go ahead and comment this out for one second and see what happens if we don't have an air handler so right now we don't have an air handler and maybe in this middleware up here instead of console logging i'm a middleware and continuing to the next we can say that we have an air object which is a new node.js air so i am an air and what we can do with this is we can pass it in the next function so normally we just call next and it goes to the next middleware this case we're going to actually pass the air object so this would be common you know this would be more common in a scenario where maybe our middleware was doing something complex we were making a database call and we were just catching any errors that happened with the database something that we cannot control so we always want to catch these errors and if we do catch them we want to pass them in the next function so when we do that we're going to go back to the browser real quick and if we refresh this it's going to say i am an heir and you're going to get the entire stack trace which you don't want because this is where the users will see what's going on and you obviously don't want to send this type of error to a user you want to handle it in a more graceful way and not to mention if we do it like this you can see down in the console or in the terminal that we've crashed our application so if this is running out on a server somewhere and we don't know that this has happened our application could be down for hours without us even knowing so it's really really important that we use an error handler in our express application to catch these errors and handle them gracefully without crashing the express application so again air handler just another middleware with one extra parameter so let's uncomment this air handler function and normally you'd set this up a little bit more complex than what i've done but we'll just go with this for now just to demonstrate the point so we've got the error handler and so now we're going to say app.use air handler now we'll go to the browser again we'll refresh and now we're getting a more friendly error message now that we've defined this error handler let's go ahead and put it in as a middleware so let's just say app.use air handler and click save now let's come back to the browser real quick and refresh you're going to see this dreaded error message in the browser you're going to ask yourself why we defined our air handling middleware so we should have a friendly message here well what's happening is we have done this out of order and like i said earlier in this video the order that you put express middleware in matters and in this case we need to throw our air handler at the very end of our app so after all of our routes and all of our middleware we need to put our air handler and the reason being is because if there is an air in any of our middlewares or our routes which are basically just middlewares then the air is going to be passed directly to the final air handler so in this case we have the air happening up in our first middleware so what's going to happen when we say next and then air express is going to pick up on this and say oh there's an error let's send it past you know let's skip the route here we don't need to go into this we need to just go straight to the air handler and handle it appropriately so this is kind of how express middleware works and you can see that this will more gracefully handle the air if we come back to the browser and refresh now we're getting a much used more userfriendly message in many cases you might do something instead of actually sending data like this we could just say res.json and then we could say air and then our front end application could handle this error on the front end rather than you know the server handling it alright so we have covered how to handle errors using air handling middleware and finally the last thing that i think is important to cover when it comes to express middleware is the fact that we can actually mutate or kind of append different properties and objects and functions to these parameters that we're passing through each of the middlewares so what we could do here is let's once again let's get rid of the error in this middleware let's also get rid of the console.log we just want to have a basic middleware let's call this number one again then let's say number two and let's put these in as global middlewares so here's middleware one and two so first our route's going to call middleware one then two and then the actual callback for the route so to demonstrate this let's go ahead come up to middleware one and say something like request dot custom property equals 100. all right so we just created a variable that is attached to the request object now since we're passing since express as a framework passes this request and response object through each of the middlewares it will actually be available to us in later middlewares so what we can do is we can say we define it up in middleware 1 then in middleware 2 we say console.log the custom property value is and then let's put in that custom property so in middleware number two we should print the custom property value is 100 but then we want to reassign it so let's say custom property equals 600 just a random number and then finally down in our routes we'll say the value is and then we'll put in request dot custom property and in this case it's probably going to print or not probably it will print 600 because we have modified the property in middleware number two so let's save that go to the browser and see what we get so we see we see that the value is 600 and that is because we set it in our second middleware which was the last middleware that modified that property now you might be asking what is the point of this why did you show me that well the reason being is because it helps you to understand how a lot of the middlewares that we use on a daily basis in express are actually working so if you're following along this series the passport.js series for user authentication this is exactly how passport js which is in express middleware is going to keep track of users whether they're authenticated or not they the passport middleware is going to take that request object and it's going to actually append different properties to it and also if you watched the previous video in this series on the express sessions middleware you also know that the request.session object is where the session is stored so you can see how powerful this is and how we can actually store data within the request object and you know each of our middlewares can have access to that data even if they come way after the middleware that first modified the data so that's just kind of a brief explainer of how middleware works in express and how air handling middleware works in express hopefully it kind of um broadens your express horizons a little bit i know when i first learned it it did um and it made me a lot better express developer i now write middleware for all of my applications to do just ad hoc things anywhere from you know authentication guards so maybe we're checking a value of a user that we've received maybe we're checking if they have administrative rights and we use a middleware to do that so the middleware would basically look up the user in the database check the admin property if the admin property is true then we pass it to the next middleware if it's false then we might return something like 401 or 403 unauthorized http statuses all right after this last section on express middleware we are now set up to really understand the express session library when you're implementing the passport local strategy it uses express session under the hood which can be extremely confusing and when you read through the passport documentation it doesn't make it abundantly clear that this is happening in this section i'm going to teach you exactly how this express session middleware is working behind the scenes kind of independent of the passport js middleware itself and then we're going to talk a little bit more about how that express session is being looped in to our passport authentication middleware now the really cool thing about this section is that learning the express session middleware is not only going to help you implement a passport local strategy but it can also be really useful for other purposes within your web app well state management is often handled on the front end with frameworks like angular vue.js or react there is the possibility of handling some sort of state or application state on the back end in the form of a session that is what the express session library aims to do but enough talk let's dive in and understand all about this library so in this case we're going to be looking at a very simple express app and i'm going to take you through how the session is working how the cookies kind of work with the session and some of the configuration that you have to do to set up the express session middleware what i've got open right now is the repository that goes along with this passport.js tutorial series and we just have a folder for little oneoff tutorials like this one i've already created an application which is an express application and i'm just going to quickly walk you through what i've done and then we'll go through what's actually happening what are some of these configuration options so the first thing that i've done i've already installed my dependencies we've got express mongoose for the database and then express session which is an npm module we then have something called connect which we'll get to in a few minutes it's what we're going to actually use for the session store then of course we set up our express app pretty familiar to most people we connect to our database right here so i'm just using a completely unauthenticated localhost database i've got that running in the background already so if you're trying to follow along be sure that you get the mongodb server or that process running before you try to run this app so we're just going to use the tutorial database and then these options here are just set because when you run the application is going to complain about it if you don't put these so that is all we've got and we create the connection right here so the connection represents um our database connection and then down here we have some pretty familiar json and url encoded middleware which is going to allow the express server to parse the different request types so that just pertains to the type of responses that we're getting in on the server and then finally we have things related to the session itself which we're going to dive in a little bit deeper and at the bottom we've just got we're listening on localhost 3000 and we have one simple route for the home page just says hello world sessions so that is our app this is the only file we're working with and so it should be pretty straightforward like i said this tutorial is not an express tutorial and i assume that you already have a decent understanding of how the express framework works i'm trying to stick primarily to how the express session middleware works so if you don't understand how express works or how middleware works be sure to check out some of my other videos or just read some of the documentation online before we get into any of the configuration and understanding how the express session works we need to answer the question what is the difference between a session and a cookie you'll see that in the configuration i've got a cookie set and in a previous video that i did again link is in the description um we talked about what a cookie was so basically a session in a cookie are different in the places that their data is stored so a cookie has its data stored in the browser and that browser is going to attach that cookie key value pair to every http request that it does a session on the other hand is going to be stored on the server side so when i say server side just the express js application and so this express session is going to store a little bit bigger types of data so in a cookie you can't put a whole lot of data and it gets very tedious if we're constantly adding more and more data to the cookie that we're attaching to each request so it would make sense to put that in a serverside session where we can store much larger amounts of data in addition a serverside session is advantageous because with a cookie we cannot store any sort of user credentials or secret information if we did that then a hacker could easily get a hold of that information and steal personal data so the benefit of a session is basically the fact that we have it on our server side and we're actually authenticating into the session with a secret key so with that said that is the main difference between a cookie and a session i want you to keep that in mind as we're talking about the two in this video now that that's covered we have some time to get into the actual code and configuration of an express session and then i'm going to show you kind of how it works in real time so what we've got on the screen right now is the express session documentation it's just an npm module a pretty popular one at that and you can see on npmjs.com there's all the documentation that you would need to learn how to use this but i'll just point you towards a few of the common things that you'll see first off of course we require in the express session and then these options right here are what are going to be included in that options object so if you look at the code here you'll see that for our session we're saying app.use so that's just we want to use the session middleware and then we've passed into the session middleware an object right here which represents our options so if we go back to the documentation really quickly you'll see that all of these options are documented right here under the options section now the one thing that i wanted to point out you get through the options that's great fine but then you get to the bottom somewhere down here and it talks about a session store implementation so if you're unfamiliar with what that is it's basically deciding what um persistent memory are we going to store our sessions in if you remember from a few minutes ago i said that a session is used to store information about a particular user moving throughout the browser or a client and so we can potentially get up to a decent amount of information and therefore in a production environment it would be useful to have an actual database storing that information now by default the express session middleware just comes with its own implementation of a session store but it's not using a database it's just using in memory or memory that's local to your application and it's not going to be a scalable solution so what we need to do is set up an actual session store which is a fancy way of saying we need to connect our database to the express session middleware so there's going to be a lot of options for what session stores we can use and they're documented here at the bottom the one that we're using particularly is the connect session store which is probably one of the most popular ones and it allows us right here to connect to the mongodb database that we have running in our express app so let's go back to our app real quick and see what i mean so to do this session store to connect it up we first have to have our database connection so we talked about this a few minutes ago here's our connection we're just using a tutorial database on localhost nothing you know you'd obviously want to change this if you're in production but we've got this running on my computer and i can actually come down to the terminal here and run the shell and you'll see that we can show dbs and you'll see that we have a tutorial db set up when we connected to this database now what we want to do is we want to tell the express session middleware that we want to use that mongodb database for its session store so you'll see that that happens right here in the store option of the session middleware and so what we've done is we've passed in the session store object into this store option and the session store object is set up right here and it is basically just using that connect right here the connect package and we're configuring a few options we're saying that the connection equals the connection that we just set up and the collection that we'll be putting our sessions in is going to be called sessions pretty standard pretty standard option that we have here you can obviously customize it a little bit and if you went to the documentation of connect there's a few other options that you can set but what i want to show you is what is happening when we connect everything up so in my first terminal i will run this application so let me go to the path here and we're going to run the application so we are listening on localhost 3000 and if we come into the browser here i've got this queued up so that we currently have localhost 3000 ready to go but i have not clicked refresh yet the reason being is because i want to show you exactly what this middleware the session middleware is doing so let's first come back to our code and what we want to do is go to the shell and we want to use the tutorial database so now we've switched to the tutorial database let me clear the screen and we're going to show the collections that exist in that database when i ran the app it initialized this sessions collection in my database but if i say db.sessions.find there's going to only be a couple objects in here let me just go ahead and drop this really quick because i think i had some stuff from previously so let's just say db.sessions.drop so we dropped the database if we show the collections now there's nothing but if we were to come here and refresh the app so we're using nodemon so if we click save it's going to refresh the app we're going to go into show collections and you see again that the sessions have been established and if we say db.sessions.find we shouldn't find any documents whatsoever in this collection so we have a completely clean slate and in order to establish a new session all we have to do is make some sort of http request to our application so if i came to the browser and i clicked refresh here what's going to happen is that session middleware is going to kind of fire it's going to create a session and then what it's going to do is create a session id which is going to be stored in a cookie in this browser so like you know just like we don't have any sessions in the database yet we also don't have any cookies in the browser yet so let's go back to our code and what i'm going to do is just walk you through a few the options and then we'll finally see exactly how it's working so when we set up our session middleware we have a secret pretty selfexplanatory but this secret is going to well usually it's going to be stored in an environment variable and you don't want to expose this to the public because it basically says if the secret is invalid then the session is invalid too but in this case i just put some secret just so that we can have it all in front of us then we have a couple options here resave and save uninitialized and these are just options relating to what does the session do if nothing has changed what does the session do you know if something has changed and basically tells the middleware how to react to different events in the browser you can read up on the documentation a little bit more on these options but the thing that we're interested in we already talked about the session store but what we're doing is we're setting a cookie max age so in other words like we talked about in a previous video a cookie can have an expires header and or not a header but an expires property which says after a certain amount of time the browser is going to delete the cookie and it's not going to attach to any of the requests in the future so in this case we're setting our cookie equal to one day and you can see the math that we're doing here in the comment we're basically just saying one day 24 hours in a day 60 minutes in an hour 60 seconds in a minute and a thousand milliseconds in a second and so that's the math that we're doing right here to get to a full day for that expires property so basically what's going to happen when i send an http get request to our sole route right here is the session middleware is going to initialize a session and then it's going to take that session id and set it equal to this or set the cookie equal to that session id the cookie is then going to be put in the set cookie header http header and then that is going to be in the response header it's going to go in the browser the browser is going to receive it and say oh you want me to set this cookie i'll set the cookie and now every time we refresh that cookie will be a part of that request so let's go ahead and do this we're going to visit our only route in the application and to do that we need to go to google chrome and we're going to click refresh so when we clicked well now we it did not load so let me go ahead and do that one more time we refreshed it we get our response it says hello world sessions and what you'll notice is now we have this cookie which is by default called connect dot sid in the express session middleware and we have some sort of value here which somehow corresponds to our session id so basically what's happening is the express session middleware is going to get this cookie on every request it's going to take the value of that cookie it's going to say okay look up this session id in the session store which is the database and then it's going to say is the session valid if so let's use the information from the session to either authenticate our user find out some data about our user maybe like how many times that user has visited our site anything of that sort is what's going to happen when the user loads a different route you'll also see that we have an expires property right here that says tomorrow this cookie is going to delete from the browser but for now since it's still valid it's going to attach to every single request so if we go to the network and look at that last request we'll see that in the response header this came from our express server using the express session middleware we have the setcookie header and we set the connect.sid header and we gave it an expires now in the request headers since we only did this once you won't see any cookie but if i click refresh one more time and we look at the request headers and response headers you'll see that in the request headers we have the cookie that was set previously so in other words the browser is saying okay i have a cookie that is still valid let me attach it to every ques request within this localhost domain all right so we have this cookie on every request now let's see what's happening on the back end so let's go back to our code and we're in the shell so we're looking at our database right now and we're going to type in db oh let me clear this real quick db.sessions.find and that's going to look in the sessions collection for any documents in that collection and you'll see that we have one and only one document which represents the session that we just established in the browser so you'll see that the id is right here which you can also see in that cookie that we have in the browser so let's see the first couple letters were capital a y yj so let's go back to the browser and you'll see that the cookie right here is has got that id set in it so that's how we kind of connect the back end to the front end and then let's once again come back to our code so we also have the expires header within here so we can also validate it on the back end and basically what this is going to do is every time the server gets that specific cookie with that session id attached to it it's going to come to this sessions collection in the database it's going to grab that document out of the database or the session store and it's going to get information that we have set on to that session and use it to do whatever we want to do with our application now this is great and all but what do we actually use this express session middleware for well in another video in this passport.js series you'll see how passport.js actually connects in to the express session middleware and uses the session to actually authenticate the user but since this is kind of a standalone video i'm not going to get into that all i'm going to show you before we kind of conclude is where this session is being set now we know that the cookie in the browser has the session id and we use that session id to look up the session in the database or the session store now we can also come to our routes and get information about the session so if we said console.log request dot session you'll get to see exactly what that session looks like and we can actually set properties to that session so again i'm connected using nodemon so we'll automatically refresh when we save this app so let me click control s to save you'll see that something happens here so we reset and now if we visit this route again in the browser in the console we should see the session object so let's quickly switch over to the browser we'll refresh refresh this page and then we'll come back to our code window and you'll see that our session object has been printed to the console right now all we have is a expires header and a couple other metadata properties but what we could also and this is set to the cookie object but we could also set other information so we could set something like how many visits a user has made to our page so let's go ahead and do something really simple like that in our only route that we have for this application let's just say if request dot session dot view count we want to say request dot session dot view count equals request dot session dot view count plus one or you could just do the plus plus syntax at the end you could just do something like that and be done with it but we'll be really explicit here and we'll set a value okay so if we have that property on the session we're going to increment it by one and then what we're going to do is we're going to say in the response instead of hello world we're going to say you have visited this page x amount of time so we'll use a little javascript syntax and we need to change these to backticks to get this to work and let's see we can just put in request.session.view count and now it should tell us how many times we've visited this page when we visit that page now we also have to say else because in this first occurrence we're not going to have this property set so if that does not exist then we're going to say request dot session dot view count equals one all right so we have set a property to the session object and let's go ahead and save this application and go to the browser and visit it so we're in the browser now and we will reload and it says you have visited this page one times it should be time but now every time we refresh we're going to get that number to increment because of the logic that we've put into our route so you can see how this session object could be very useful for tracking information about a specific user or client one last thing i want to show you if we go back to the code you can look it up in the database again so let's go back to and let's find that session once more you'll see we still have just one object one document in the database but now we have this little property down here so when we set the view count property on the request.session object that actually persisted in the session store or our mongodb database under the view count property so again you can see how powerful this is and you could also kind of extrapolate out and start to foreshadow how something like a passport js middleware could kind of connect into this middle this express session middleware to keep its own sort of data you came here to learn user authentication and it took us about two hours to get to the part where we're actually writing it for the first time i hope the prerequisite lessons that we just covered were really helpful to get us set up to this point and now we're ready to actually implement the passport local strategy within your web app your users are going to have the expectation that you have the option to do a username or email based authentication you have to have this because what if your user doesn't have a google account or a facebook account to use that you know other authentication option that you're offering you've got to have this most basic option for them and the passport local strategy is one way to do it equipped with our knowledge of http headers cookies the express session library and express middleware we are fully ready to jump into this strategy my goal in this video is to get the passport.js library imported into our express.js application and can start to configure it to help us with this i've set up a repository on my github that will basically give you a starter template to work from and what this is going to do is kind of eliminate all of that stuff that we don't want to focus on such as setting up a basic express application setting up a very basic database with mongodb and even setting up something like a express session which we talked about in one of the prerequisite videos for this tutorial series in this repository i've got three branches but the master branch is going to have your starter template so if you don't know how to use branches in git that's totally fine if you do want to learn more about that i actually have a full tutorial series on using git but anyways you can see if you come into github you don't have to actually know any commands to do this you just drop down and you can see that the different branches will have the final branch is kind of the final implementation um no promises that will get you know line by line character by character to the same implementation here during the video but will come very close the overall structure will be exactly the same and then we have the final allinone which is basically just one js file or javascript file that has everything that you need to run this with tons of comments so that you can really figure out what is going on so that's what the repository is you can go ahead and fork it or clone it whatever you want to do and then download it to your computer and once you've done that you should land to a screen like the one i've got right here and i've got open the readme which kind of gives you basic instructions on how to use it we went through most of this already so let's go ahead and close that out and take a quick tour of what's going on in this repository and then we will go into the configuration of the passport local strategy let's take a quick look at what i've got for you already set up in the template application it's pretty similar to what you probably have seen before i tried to make it a similar structure to what you might find in a lot of online express node.js tutorials so hopefully this looks a little bit familiar but anyways we start with our app.js which is going to set up our basic express app so the imports at the top let's just go through them real quick if you haven't installed them after cloning the repo just type npm install to get those installed we have express pretty straightforward mongoose which is the odm for mongodb i will mention um while we're on this line i've already got my d service running in the background so you'll have to do that when you're running this app and i i don't even know if i have this in the readme so maybe i will put that in here right now we'll just say make sure to run the mongod service before running the app locally all right so now that we got that covered just make sure that you have that running and then you should be able to run this app just fine um all right so moving on we have express session which i've covered in a separate video how this works and how to set it up so i've already implemented it here for you if you want to learn more about that go to that video again that is in the description just click on the playlist and you'll you'll find it so next up is passport this is what most of this video in the next couple videos is going to be about will require in the builtin node.js crypto library which is going to allow us to create and verify passwords we require in the routes which is the routes folder we'll get there in just a second and also we have a database configuration in the config directory now coming down we have store directly related to the express session middleware again that's another video we have this little line right here most people probably have seen it but if you haven't all this is doing is giving us access to the dot env file that we have defined over here that by default is not going to be imported when you clone this repository because it's got secret keys in it so you will need to create the dot env file and in the env file i think you only need two things you need the db string and the secret and for my case i'm just using a very simple db string i don't even have a user or a password just to keep things simple for now but in production you'd obviously want to um have a user and password in the actual database that you would connect to so and then the secret is going to be i think for the express session module so let's close that and then you can see you can actually get access to those variables anywhere within this app.js file with this syntax the process.env.variablename all right so moving on we have the express application pretty simple this is some middleware for parsing http responses most of you would probably have seen app.use bodyparser.json but i've just used the builtin express parsers because i think these actually came in a little bit recently in like a recent release i could be wrong on that um but you no longer need to use body parser all right session setup again this was covered in a different video but let's just take a very very quick look at what is going on here we have our session store which is going to say hey express session middleware i want you to use the mongodb database for the session storage and in that i want you to use the sessions table or not table but collection in that mongodb database so that's the session store down here in the configuration options for the session middleware we are telling it to use that store then we have some other options here so the secret we just talked about that that's going to help the express session middleware validate the session that it has looked up it's going to check to see if it matches that secret these two options have to do with you know how does the session treat or how does the session react when there's actually no changes in the browser you can read up about that on your own and then finally the cookie this is the this is also another separate video in this series but basically what we're doing is we're storing the session id in a cookie in the browser and this right here is just going to kind of tell the express session middleware hey i want you to it basically set an expires header um not header but an expires property of one day so this cookie will expire in one day and a new session will have to be reestablished when it does expire alright that was just a quick overview if you want more you have to check out the other video next up we have passport authentication i've just put in this basic require statement to show you where it is so it's in the config directory we'll get to that in just a moment we are using our routes so this is pretty standard in express you put your routes after the other middleware but before your air handler in this case we don't have an error handler you might want to do that for a production application finally we are listening on port 3000 localhost pretty straightforward so that is the basic app let's go ahead and look at some of the other pieces so let me save that we'll first start in the config so we have passport.js all i've done here is imported the relevant modules that we'll will need to set it up and then i've imported some database configurations uh well the connection and then the user model that we'll be um using so going straight over to the database configuration this is a pretty standard mongodb database setup we're requiring in mongoose again we got this access to the env file we're going to grab the db string from that file and we're going to create a connection with it so we pass in the string to the create connection method on the mongoose object and then we pass in these options which will just suppress any warning messages finally we have a user schema it's very simple we just have a username hash and salt you will see what the hash and salt mean a little bit later so we create a model for that user based on the schema and we export the connection so that we can use it in other files so pretty straightforward with that let's see what else we've got we have the password utils which should just have the validate password and create password functions so let's check that out and you can see that i've already kind of templated out what the functions will look like all we have to do is jump in there and actually implement them let's see if i'm missing anything else okay i've got the routes just one route file and i know there's a lot of stuff in here but really there's not much of anything we pass in the express router uh passport because we're going to actually use passport in our routes we have some past password utils we just looked at the database connection and user model and really what we're going to be doing the only thing we're going to be doing in this file is these two routes so the login and register route we're going to have to implement the logic behind these in the git routes below all i've done is create a super simple flow that will go through as we implement this passport authentication so you'll see the home page is just going to tell you to please register you click the link goes to the register page which is right here that has just a really ugly looking form that we will type a username and password into to register that will submit to our custom implemented post request up here then it will if you're successful it will redirect you i think to the login page then you will log in with your username and password which will create a post request to the login post route which we have to implement and if you successfully log in i think it will redirect you we're going to have to write this logic but it will redirect you to i believe in the i believe the login success route so it'll say you've successfully logged in then we'll try to visit a protected route and that will be right here and we're going to check if we're authenticated and let you in if you are so basically you can look at this but it's just a flow of pages that we're loading the reason i did this without using something like ejs or another temple templating language is just to keep it as simple as possible all we're doing is passing basic html and html forms and using the builtin express methods like res.send in res.redirect so hopefully that makes sense if it doesn't take a look at this for a few minutes and i know it will before we get into the actual implementation and configuration of passport i wanted to show you again i know we already touched on this in the first video just for a few minutes but i want to show you how to find the documentation for this i personally had a very difficult time finding kind of an end to end tutorial and documentation for passport and i think since all the strategies are developed by different developers there's not really you know a one size fits all documentation for it now if you go to the passport.js website you'll first find that you can click strategies and browse through all the different strategies you'll be able to go to those pages but in our case we're using the passport local strategy so if we click this we should be redirected to the passport local strategy it's going to give us some basic usage instructions so we install it we configure it with a verify function and then we can use it in the route here but that's pretty much all that it gives us there's actually a couple more steps that you need to do to use the um local strategy which is kind of weird why it's not in this on this page and if you click on the examples it goes to a 404 page i think maybe that was recent i don't know whatever the case this is actually not where you're going to want to go for documentation on the passport local strategy the passport local strategy is actually better documented in the general documentation of the passport.js middleware so if you go to documentation right here and you click username and password this is where you're going to get a little bit more verbose documentation on the passport local module so here we have the same thing install passport local but here we're getting a little bit more detailed implementation of this verify callback and how you would use the form how you would use it on the route what kind of parameters you can pass to the verify callback so this is a little bit better documentation but it still kind of misses some of the configuration that you have to do for this module so i'm going to show you exactly how to use it but you can kind of peruse the passport.js documentation you'll find a few things for example if we click on configure it's going to tell us how to configure a strategy because being a framework for the middleware passport has kind of a standardized way to integrate different strategies so on every single strategy that we use we're going to need a verify callback so in this section kind of talks about that verify callback and what the different responses are required based on how the user you know whether the user entered the correct or incorrect credentials whether we got an error message whatever the case it tells you that and then we also have documentation on the authenticate method so passport actually provides you with a builtin authenticate method on the passport object and all you need to do is provide it with the name of the strategy that you've defined and then passport figures out how to go find the verify callback that you've configured for that specific strategy i know this sounds like a lot and i know this documentation is a little bit sporadic it's not necessarily you know a b c d one two three four it's it's a little bit confusing so let's just get into the implementation and i'll do my best to kind of document the passport local strategy for you like we saw in the documentation the first thing we need to do is define the verify callback for the passport local strategy so we'll do this in the passport config file and all we need to do is comment this out the passport.use method and pass in the strategy and the verify callback so i'm just going to paste in the full thing real quick and you'll see that this looks pretty similar to what we saw in the documentation it's also going to be pretty similar to what you'll see in a lot of tutorials but i personally find this a bit confusing when we're looking at it all at once so let's go ahead and deconstruct what's going on in this configuration put it in some variables so that we know exactly what's going on all right so the first thing that we need to do is define the strategy itself so let's say strategy equals and then in this case it's going to be the new local strategy all right so that is the most basic way to create a strategy and then this strategy is going to require that verify callback so let's define that above here and the verify callback is going to take a couple parameters it's going to take a username password and done function in this case down here i just called it callback but you it doesn't really matter what you call this all you need to know is that this represents a function that you will eventually pass the results of your authentication to so those are the parameters and they will actually be populated by the passport framework based on how you implement this so we expect the username to be the value that we received from the request body of some sort of login form so if we were to create a login form type in our username and password and then make a post request to the express api that post request is going to have a username and password field and passport is going to automatically look for those two fields and grab the values of them and populate them in the verify callback now there's a little bit tricky part to this because if you don't name your username and password fields exactly this username and password the passport um framework is not going to or not the passport framework but the passport local strategy is not going to know what variable to look for so in order to prevent this we can actually define custom fields that we want passport to look in i'll show you how to include this in a few seconds but first let's just get it in a variable so we'll say custom fields is equal to an object and we'll say the username field is going to be uh you name we're just making this up making it custom so that we can see exactly how this works so our username field is you name and then our password field is just going to be something like pw so obviously these are some nonconventional ways to name the password and username fields but if we define them in our custom fields object then passport local will know where to look alright so we'll use that object in just a second but first let's come back to the verify callback so in the verify callback what we're doing is basically our own implementation of a password verification now this is where i think people get tripped up a little bit i know i did um thinking that the verify callback has to be a very specific structure and we have to use a certain database because of course the documentation online shows that we're using the mongodb database but in reality it doesn't matter what database you use and it really doesn't matter how you choose to verify the credentials all that matters is that the return values that you pass to this done callback are what passport expects so we can come in here and do whatever we want but for simplicity as we know i'm using the mongodb database so it's going to look pretty similar to what you saw in some of the examples so let's go ahead and copy this so i think we're done here with this copy paste and then we can put it right here and all we're doing is going to the mongodb database and we're looking for a user that has the username provided in this parameter so again what's going to happen we make a post request and we provide a json body with you name and password then passport as a middleware is going to look for these two fields finds them takes the value and populates these two parameters with those two values so at this time when we're executing this callback these represent the username and password so we can look up the username in the database and then just in a basic promise we are returning the user so we check if there's a user in the database you know if someone has actually registered already then or actually it's the opposite if there's not a user in the database then we're just going to return this should be updated to done to represent this done callback up here and what we're telling passport here is that no there was not an error in this operation but there was also not a user so go ahead and reject this and so passport will return i believe it's a 401 on unauthorized http status so that's the first check we need to do then um we need to check whether this is valid sorry for all these comments i had them in here before when i was writing this out so we have a variable here that says is valid and for right now we don't know how this works and this is not even a function that we've defined yet but basically what we're doing we can comment this out for well let's not comment it out yet what we're doing is we're putting the password through some sort of verification function which is going to um or we're also putting the hash in the salt stored in the user record in the database and we're verifying those two things against the password you'll see how that works in a minute but basically let's just assume that this returns true or false which it does and we say if the password if the login credentials are valid then we're going to return the callback let me update this real quick again these are just corresponding to this parameter that passport provides we're going to say nope there was no error and yep there was a user and this user was successfully authenticated based on my verification function so when we pass this to passport it's going to let us into the route and then finally if it's not valid we say nope there is no error but we did not verify this user correctly don't let them in the route and then finally we using the promise syntax we're just going to catch any of the errors that happen within the express application maybe on the database side of things and if we get an error we're just going to pass that to passport and it knows how to handle that so that is the basic verify callback and i'll show you really quickly what is actually going to happen here when we use it in a route so let me save that and come back to one of our routes so let's go down to the um the post login route so what we're going to do is include a middleware in the post login route called passport.authenticate and then in the authenticate we're going to say um the local strategy and we're going to pass in um well we can we can worry about the rest of this a little bit later all i wanted to show you here is that we're passing this middleware in the login post route and so basically what's going to happen is we make a post request to log in with our username and password and then that gets intercepted by the passport middleware and then we come in passport populates these two objects it runs this function so we're looking up the user in the database validating the credentials returning some sort of response and if we get this response right here where we populate a user then it's going to go to the next part of this function and it lets us in the route so that is the basic implementation of passport and now we're going to tie up some loose ends and make sure that it actually works and then we'll see it run live we just have a few more things we have to do to get this working um the first thing i forgot to do when we finish this up is actually complete this verify callback so we started with passport.views and then we passed in all of this stuff so we need to actually do this now um so the first thing that we need to do is let's see we have our custom fields and our verify callback so in our new local strategy we're going to pass in our custom fields and our verify callback and then we're going to say passport.use and then we're gonna pass it in that local strategy so now we actually have it configured and in app.js when we require it in somewhere um let's see where do we do this right here in the passport authentication we require in the configuration and what that's going to do is basically just take this line right here and include it in the app.js now that we've got our strategy configured we've done the bulk of the work there are a few extra things that we're going to have to put in here but i'm going to go ahead and just copy them in um and then we're going to come back to them a little bit later after we have everything working to understand them a little bit better so at the bottom of this configuration i'm just going to paste in two initializations and this is the passport.serialize user and deserialize user now this has to do with the express session and how we put a user into the session and grab a user out of the session basically what is happening is we're going to put the user id into the session and then we're going to when we want the user to come out of the session we will grab that user id that was stored there and find it in the database again we're going to come back to this so don't worry about it if you don't understand it i think this these two functions are a little bit tricky especially because there's not a whole lot of documentation around them so let's save that let me save this real quick let's come back to app.js and add in our last two lines that we're going to need before all of this is going to work so right after we require in the passport configuration we're going to say app.use passport.initialize and again what this is going to do is kind of initialize the passport middleware and um basically so that it doesn't get stale so we might be using different routes we might click to several different routes and if we don't reinitialize the passport middleware then there's a chance that hey maybe the user um maybe their session expired or something in the time that we're doing that it's just always safe to refresh the passport middleware every single time that we load a route and so that's what this is doing and then we need to put in passport.session which has to do a little bit with what we just talked about the serialize and deserialize user but um more so it has to do with the actual express session middleware so i know we talked about this a little bit earlier we also talked about it in a separate video but the express session gives us access to the request.session object and anything that we store on the request.session object inside any of the routes is going to be persisted to the database under the sessions collection so knowing this passport cleverly kind of plugs into that and bootstraps off it and uses it as a user authentication mechanism so we're going to actually go through this along with the serialize and deserialize user in a few minutes but for now let's see if we've got this working we still have a few things to do in the routes before it's going to work but let's save it and actually run the app i'm going to run this with nodemon so we have live updates so nodemon app.js and doesn't look like we have any errors at the moment so there is a chance that we have this working the first thing that we're going to have to do before the passport middleware is going to be effective is finish defining the password verification and generation functions so if you remember in the passport configuration in this verify callback that we had defined we called this method called valid password but in this module we haven't actually created this valid password function so it's not going to work as it stands right now we're going to have to go over to our password utils file and define both the valid password and the gen password functions before anything's going to work we're going to open up password utils in the lib folder and you'll see that i have basically templated out the two functions that we're going to need but to understand this i've actually put a slide together so that you can visualize which at what's actually happening with the generate and validate password functions we're going to be using the node.js crypto library to do this but before we get into the actual like what methods we're using it's better to have a conceptual understanding on the screen right now is a basic representation of how we generate and validate a password to a database now the cardinal rule here is that you're never going to store a plain text password in a database that's kind of web application 101 i think everyone is pretty familiar with that but actually figuring out how to do that is a little bit more complicated now we talked about earlier how the passport.js middleware does not give you a specific way that you need to do this it gives you a lot of freedom as to how you might generate and validate the passwords that the users are providing in the login and register forms as we go through this just note that this is not the only way that you can go through this process there are other libraries other than the node.js builtin crypto library there's also different types of logic that you can go through but i've tried to keep it as standard as possible and kind of in line with what you would call best practice so anyways what's going on here is we have two steps in the process so we have the creation of the password and the verification of the password you can think of this as the register and the login so you're sitting there behind your computer you found this cool new web app and the first thing that the web app is going to ask you to do is register you need to give them a username and a password and then maybe a couple other things like an email first last name maybe even an address or something but what's important is that you are providing that web app with a plain text password you're just typing that into a field and when the web app receives that password it is still in plain text form we can't really avoid that that's fine but what happens is we need to transform that into something that we can actually store securely in the database without worrying about some hacker you know taking over a database and grabbing all the you know users passwords in that database once the user information is stored in the database we can move on to step two which is password verification now in step two you can think of this as the login process so when the user sits behind their computer and is typing in their username and password to log into your web app that's going to be the verification step and what's going to happen is they're going to provide you with their username which you're going to take and you're going to look up that user in your database using the username or maybe an email once you find that user in the database then you're going to have access to this password hash and the salt that we stored before so you're going to pull both of those values out and along with the password the plain text password that the user just provided you you're going to put those values through the same exact hash function so you pull the salt out of the database from that user and you put in the plain text password that they just typed in and so in this case we have the same exact values for these parameters as we did when we created the hash in the beginning and we know since a hash function is always going to give you the same exact value if you put the same parameters into it we know that we can generate a password hash and compare it to the hash that we stored in the user record in the database and if those two values match then we know that we have validated this user and that they have entered the correct credentials we've got a conceptual understanding of this process so let's go ahead and code it we're going to come back to vs code again i've set up the functions in the parameters that they require right here and we're going to start with the generate password function which is the step one of the process so this password argument is going to come from the user when they type their password into the register form and then here is our implementation now i'm going to walk you through this um we're using the node.js crypto library and the first thing that we're going to do with that is generate a salt which is just a pseudorandom value and it's going to add a bit of randomness to our generation of the hash so we have the salt then we pass in the plain text password and that salt to the pb kdf2 method on the crypto library and then this last part sync just means synchronous for synchronous operation and then the 10 000 right here is going to represent how many iterations we're doing 64 is how long or how big this hash is going to be and then right here we specify which hashing function we're going to use finally we will convert this to a hexadecimal string now down here we just return those two values and we are done with this piece of the implementation to learn a little bit more about what we just did i'm going to pull up a document on google this is from the internet engineering task force and it's just basically a specification for different cryptography methods and or passwordbased cryptography methods and if we go down to the table of contents we can actually find the pbk specification which is what we were using from the node.js crypto library and you'll see that this is actually going to well we might actually be in the wrong spot here we're in the appendix see if we can get somewhere a little bit more straightforward okay we clicked on the wrong one here so we need to click on 5.2 and this is going to show you kind of the template for implementing that kind of function so the node.js crypto library is just implementing this standard right here and we can actually come up and see some information about it so i think there's something on iteration count it says that they recommend at least a thousand we put in well you want to have 10 million for a super secure implementation we are somewhere in the middle with 10 000 which should be fine and then it also talks a little bit about the salt up here and you can read up about what that actually is a lot of this is just math so i don't want to get into it but this is kind of where the standard comes from so we're not just using some random crypto function this is kind of what the engine internet engineering task force has designated as this is how you should do it when you are verifying and generating passwords we can now come back and do the second function which is the valid password i'm not really sure why i called it valid password probably should be validate password but anyways here is the implementation for that all we're doing it this is basically the same exact thing remember what we went through on the slide we're just creating the same exact hash that we did up here except this time we're receiving the hash and the salt or well we're just passing the salt but we're getting that salt from the user record in the database and then we're getting this password when the user types it in in the login form so given the same inputs we should expect the same output and therefore we are going to return whether the hash that comes from the database is equal to the hash that we computed using the password that the user just provided us in the salt that was in the database for that user record so we're going to either receive true or false and this is what we're going to put in our passport js verify callback so let's save this and come back to our passport js configuration and you'll see that we're already using this right here we've already set it up how we want to we just need to import it so i'll do that right now so we'll say valid password equals require lib password utils dot valid password because we've exported them here at the bottom so now our passport.js implementation is complete and it should work with our application once we implement the two post routes for login and register so let's do that right now we'll come to the routes and you'll see that we have the login and register routes they're not implemented yet so we need to do that it's pretty simple so i'm just going to paste in the implementation most of this is just creating a user record in the database but we're also going to be implementing that first part the gen password function in this register route i think i have it yep i have this already imported but let's go ahead and rename it we'll just say gen password to stay consistent and then we need to grab the gen password function off of the import so now that we have that we can implement this so here's the implementation we'll walk through it really quickly i want to point out a few things before we get started we are grabbing the password and username values from the request.body.pw in unname fields if you remember from the passport configuration just to demonstrate the options you can do we went ahead and customized what we're expecting to see from that request.body object so we need to stay consistent and we need to use those to grab those values so you can see what we're doing here is we are generating that salt hash object so it's just an object with the salt in the hash so this one right here and that's coming from the gen password function that we just imported up here from the password utils then we are going to create a new user object for the database we're going to save that user we'll go ahead and just console log it to the terminal and then we are going to redirect to the login route all right so we have implemented register and we can go ahead and try that out in the browser so let's run it run the application looks like we don't have any errors so let's jump back to the browser type in localhost 3000 slash register or actually we can just go to the home page and it gives us a link to the register we're going to enter our username and our password i'll just do one two three to keep it simple and we'll submit it looks like it properly did something let's come back to the terminal to verify that good news we see the object that we just created we put the username in there and then the hash and the salt that we got from the gen password function and then we can also check the database so let me just open the shell and we'll look it up so show databases we are using the tutorial db based on the dot env file so i will say use tutorial db and then we can say db dot users dot find and you should see the user that we just created so clearly we've got the user in the database and the last thing that we need to do in this entire flow is implement the login route so if we come back to what we're already in the file we have the login route that we've already kind of put this passport.authent method in a little bit earlier but i just want to add a few things to it and we'll actually simplify this a little bit as well the first thing i'm going to do is pass in a second argument to the authenticate method and this is just going to be an object that tells passport where to redirect based on the status of the login so if you remember the passport.authenticate method is literally just going to look in the passport configuration for this verify callback and it's going to call this function right here and this is going to return either a user if we are validating the user correctly and the user has provided the correct password or we're going to say false and in that case it's going to redirect to the login failure so really since we're adding conditions for both a success and a failure we don't need this last function right here so we've just included this normal callback that we see in most express routes but we don't need that in this implementation and we are pretty much done with the login post request so let's save this and give it a try in the browser we'll type in the same user that i did earlier one two three for the password and submit and it says that we have successfully logged in so something worked here now we can go to the protected route it says you are authenticated we can log out and reload now we're not authenticated and we can log in again so we can just go in this circle here it's kind of how i set it up so that we can see that flow but i'm going to be talking a lot more about how this is actually working and how you can use the passport middleware in your routes in the next video but let's come back one more time to the code and just kind of take a look at the routes that we just went through so we started at login login submitted the data that we put in there and the passport verify callback was called we successfully validated the user so we got to right here and then we come to the route the login post route and we had a success so we are going to come to the login success route you can see this success redirect login success so we'll come down here somewhere so we came to the login success then it said go to the protected routes we clicked that link and we came right here which you'll see a little bit of extra syntax we're going to go through this in the next video but this is how we would authenticate the user once we've run through that authentication flow in the login post route and then we can also log out so we've got a logout method on the request object and then the cycle kind of repeats we are officially done with the passport configuration we've got it working completely and this is all you're going to have to do for the passport local strategy to authenticate users into your web app now i did mention earlier that we were going to come back to something and it was in the passport configuration here at the bottom so these two methods the passport.serialize and deserialize and then also i think in app.js we have these two lines the initialize in session now we don't really know how those are working and i promise that we'll come back and explain how those are working and kind of see it for ourselves in code i would also like to go through some of these things like request that log out and request that is authenticated and understand what is going on there and also kind of understand you know you would intuitively think well we're probably just going to use the passport dot authenticate middleware on every single route that we want to authenticate but that's not the case for the passport local strategy so to start what we're going to have to understand is that passport.serialize and deserialize configurations so if we open up the passport file it's these two configurations right here that we need to understand to really grasp what passport is trying to do in order to understand this a little bit better i'm going to open up app.js and we're going to write a very basic middleware that is just going to give us it's not going to do anything but it's going to give us a little bit of debugging power so we've got these middlewares working so here's where we set up the session so we include that here then we include the passport.initialize and passport.sessionmiddlewares right here so after those have done their work these are happening on every single route request we'll put in our custom middleware so we'll say app.use and we're going to pass in a simple function we're just going to give it the standard parameters and then what we're going to do in the body of it is just console.log request dot session and then we will console.log request dot user so you'll see how this works the express session is going to create this object right here and the passport middleware should create this object here and then finally we have to call next so it doesn't crash our routes but basically every time we visit any route in this application this is going to run and we're going to see exactly how it's working so for starters let's just get this running and visit in in the browser so we'll come to google chrome we'll come back to what i've got on the screen here in a second let's just go to the base route so we're at the home page and you can see in the application here is our cookie that we've set which represents the express session id so that will we're going to just delete this really quick so that we refresh everything so now we have a clean slate and the express session middleware is going to recreate a new session for us to use when we press refresh so we pressed refresh it created a new session and in the console we should see that printed out because of the middleware that we just wrote right here so you see the session is going to show us the cookie and that's pretty much it you'll notice that the request.userobject is undefined right now and that is because we haven't yet authenticated our user using the passport.authenticate method so let's do that really quickly in the browser so we need to actually just visit the login route because we've already got this user in the database if you remember from last video so we will sign in and click submit and this is the same session id come back to the code and this time we've got a different story so this time let me expand this so we can see it so here was our first go around so this is what it printed and then this is the second time so now we have the session with the cookie but we also have this line right here and this was created by the passport middleware and when we executed the passport.authenticate method which is in the login post route so right here that's what we just did and what passport did behind the scenes was create this additional property on the express session and how we got this right here is through the passport.serialize user function so right here we ran the serialize user function we passed in the user id and we stored it under the user property so let's go ahead and check to see if this is the actual id of our user so it's 5e0f now let's go over to the shell and we're already set up to query this so we'll say db.users.find and you'll see that we have the 5e0f user in the database so the serialize user function when we did the passport.authenticate method is going to grab that user from the database get the id of the user and then insert that into the passport.user or actually it would be the request.session.passport.user property so now when we need to grab this user from the the session we're going to use the deserialize user function so we're kind of seeing it all at once but to populate the request.user right here this is the middleware that we just wrote to print all this stuff to the terminal in order to populate the request.user we are going to grab the user from the database right here and based on the user id that was provided in the session object and then we are going to attach the found user to the request.user object so that was a mouthful and we've got a few more pieces to this puzzle so we'll come to app.js and these two lines are playing into this equation as well so when we say passport.initialize that's going to kind of rerun everything that we just did and then the passport.session is going to kind of work in the same way so every time we load a route these two middlewares are going to work together and what they're going to basically do is they're first going to check to see if this user property is not null so it would look something like this we would say if request.session.passport.user not equal to null then we are going to know that there is a logged in user and we're going to grab this user id from that property then once we grab that user id from the property we're going to use the deserialize user method pass in oops pass in the user id grab it from the database and then what we're going to do is populate the request.user and set it equal to whatever user we got from the database so that's basically what is happening on every single route request now if this user object is null then that means that the user is not currently logged in and we do not grab the user from the session and this property request that user is not populated if we go in the browser and we do the log out function or we visit the logout route you're going to notice the next time that we console.log these two properties that this user object is not going to exist so let's scroll to the scroll to the bottom save this um come up here so we're at the bottom let's go to the browser and first we've got to visit the protected route and when we click this button right here it's going to log us out so we click log out and reload and come back to the terminal and now you'll see that this passport object is going to not have this user property in other words we are not logged in now you might say okay this is a lot to look at and it's a lot of kind of funky logic to go through every time we want to figure out if our user is logged in or not and luckily we have some methods built onto this request object to kind of do this logic for us these methods were defined by the passport middleware or the passport local middleware and we can see this if we visit the repository so this module the request.js module is where this is going to kind of happen or where these are defined and you'll see a couple properties attached to the request object so the first one is the login property and this is actually called by default when we use the passport.authenticate method so we don't really have to ever use this on our own if we're using the passport.authenticate method now what's useful to us is the last three properties so first we have request.logout so anytime that we want to log our user out we just call this method and you'll see that i do this when we had clicked that logout button you'll see in the route for the log out route somewhere down here so here's my logout route and you can see that i have called that method right there which is basically going to delete the request.session.passport.userproperty from the session so that's all that that's doing and then next time we call the passport.initialize and passport.sessionmiddlewares which happens on every route it's going to check that property see that it's null and pretty much declare that the user has been logged out all right so the next one we have is the request dot is authenticated and this is a really common one we're going to use a lot and basically all this is doing is what we went through manually and there's a bunch of funky code here because it's part of the framework but basically all this code is doing is saying does the request.session.passport.userpropertyx property and is in it is not null and if that is the case then we declare that the user is authenticated because the only way that that property would have been populated is after we use the passport.authenticate method which is going to run the verify callback which is going to implement our custom login logic finally we have request that is unauthenticated i don't really use this it's just the opposite of the request that is authenticated so you can use it but it's not really all that complicated so we've got these methods unfortunately these are not documented very well in the passport documentation which is kind of a shame but anyways let's come back to our code and see how we might use these properties to our advantage so right now in our routes we are manually calling these things and right here we are manually checking whether the request is authenticated and then if it is we are doing something if it's not we're doing something else so in order to streamline this a little bit it would make a little bit more sense if we included this as middleware and all we're doing is checking if the user is authenticated and if the user is authenticated we just call the next callback and it goes into the route and if the user is not authenticated we return some sort of 401 unauthorized error so to make our lives a lot easier let's go in the routes folder you can really put this anywhere i'm just going to put it in the routes folder and we'll just say off middleware.js and in the off middleware js i'll just take you through two different middlewares that we could implement you can get as creative as you want with this but here are some pretty standard ones that you might use so we'll say module.exports dot is off equal to a middleware function so there's the standard middleware parameters or arguments and then we're going to do something in here to check whether the user is authenticated and if they're not we're going to return some sort of 401 unauthorized error the second one we're going to do module dot exports dot is admin so currently we don't have an admin property on our user schema but we could easily add that and we could use this middleware to basically check whether the user is logged in and is an admin so that can help you kind of protect routes that are for admins only versus regular users we'll get to that in a second but first let's get this one done so all we're going to do is use that request dot is authenticated method that is attached from the passport middleware so we'll say if request dot is authenticated then we're going to just say next and pass it on to the next middleware in the chain if the user is not authenticated we'll just return a 401 unauthorized error so we'll just say res dot status 401 dot json and we'll just put in a message that says you are not authorized to view this resource all right so that's pretty simple so if they're authenticated if they're logged in we're going to just pass it on to the next middleware in the chain if not we're going to just stop it right there and return an unauthorized error all right so let's test this out so we have the is off middleware if we come to our route let's do this let's kind of refactor this so in our protected route we're going to return res.send you made it to the route so something to indicate to us that we successfully made it into the route and within this route we could do whatever we want we could return some sort of data and to do this we will just pass in is off as the middleware right there and of course we need to import this at the top of this file so we will say is off equals require off middleware dot is off all right so we've got this set up and now if we try to visit the protected route we should hopefully see you made it to the route so let's try that go to google chrome and we're already at our protected route so oh it looks like we are not authenticated right now because we had logged out so let's log in really quick so we are logged in and when we click go to protected route we should see that message that we just put there it said you made it to the route so our middleware is working now let's visit the logout route so that we can log ourselves out and then see if that other status is going to work so now we went to the log out route and we were redirected to the protected route i'm not exactly sure how that worked but we got the error message that we were expecting and if we were using you know a front end we could kind of process this error in a clean manner and give a friendly message to the user so we've got our middleware working and now all we have to do is pass in this short variable before any route that we want to protect so the next thing is just kind of an added bonus it's not necessary for all applications but it's something that kind of just stretches your creativity a little bit it gets you thinking outside of the box and we're not just constrained by some framework that tells us that we need to do it this way so in order to implement the is admin we are going to come to the database and add one more thing to this user schema so we're going to add an admin property which is going to be a boolean and we'll save that and then we need to actually register a new user so that they have this admin property and we'll just by default put this new user as an admin um let's see where that happens is going to be in the register route um where are we okay so right here is where we're going to do this currently we're just passing in this data but i'm just going to hard code in the admin property and we're going to say true so save that we will come back to the browser and we need to go to the register route so let's go to register let me get rid of this and i'm going to say zack 2 and we'll do the same password one two three just so i don't forget it submit we have put this user in the database let's go ahead and check that just really quickly to make sure so we'll come to the shell db.users.find now we have two users in the database let's kind of extend this and the second user zac2 has an admin property of true so zack the original zach is not an admin because we haven't added that property the second one is an admin so the first user should be able to visit an admin route while the second should not so let's test that out really quickly we need to make a route that will actually test it so let's come down to protected route just copy that and instead of protected we'll say admin route so the first thing we want to check is the is off we kind of have some freedom how we want to do this i'm going to go ahead and simplify things and just say is admin so we don't have to repeat it so we could do is off and then is admin and in the in in this middleware all we have to do is check whether that property exists but i'm going to go ahead and simplify that you'll see what i mean in a second so we'll say is admin we need to import that here at the top so i know this is you know not really good coding practice we could refactor this a little bit but we'll do it just for the sake of time so we've put the is admin middleware in there we've included it in the admin route and we'll say you made it to the admin route if they successfully make it through that middleware gate so now we come back to the auth middleware and let's just copy the same exact thing except this time we're going to say if request dot is authenticated and request.user.admin since this is a boolean property we can just say this so now we have two requirements to get through this authentication middleware and then we have the same exact um logic here maybe we'll change the message to say you are not authorized to view this resource because you are not an admin all right so we've got this set up and i think we should be able to visit the route that we just created so admin route let's just manually type that into here and since we haven't i don't think we've logged in with anyone yet so let's log in with the first user so this one should not be an admin and we'll go to the admin route and it'll say you are not authorized to view this because you're not an admin as we would expect now let's log this user out by just going to log out and then let's go to login we're going to log in that second user that does have admin privileges oh looks like we had some sort of login failure maybe i just typed it in wrong um oh it was because i put the wrong username in so it's not zac one it is zach2 and one two three all right we are successfully logged in let's go to the admin route and this time we should get a success message you made it to the admin route so we've covered a good amount here but hopefully this kind of opens up your creativity into understanding how the passport local strategy works how we can use it to creatively authenticate and allow access to different resources based on whether a user is logged in or logged out based on whether a user has admin credentials and you could even go through some more complex logic if you wanted to by creating different types of middlewares i know it seems like we've already run a marathon just trying to get the passport local strategy implemented but again authentication user authentication is not an easy subject i think we kind of treat it as an easier subject because it's like okay there's only a few moving parts here it seems like on the surface but once you get into the implementation there are so many different things that you have to understand in order to debug and have a solid grasp around user authentication i want to take a minute to say congrats there's been a lot of content so far and you have finally implemented your first official you know user authentication scheme where you actually know what's going on behind the scenes you can walk away from this tutorial right now if you want to but there is a second part to all of this which is the jwt based authentication that i think is super super important to know and it's probably one of the more popular ways to do it as i mentioned in the first you know a few minutes of this video but as we saw with passport local strategy having all of these prerequisites we also have some prerequisites for implementing a jwt authentication strategy in this section we're going to be tackling one of those prerequisites which is public key cryptography now i will make the disclaimer that to implement the passport jwt strategy or a jwt strategy in general you don't need public key cryptography in reality you could very well just use a symmetric cryptography scheme which is basically where you just make a long secret string and store that in an environment variable and then use that to you know authenticate through jwt now i chose public key cryptography over something like you know symmetric secrets because of a couple reasons number one i think it's really cool um public key or asymmetric cryptography is a really fascinating subject and it's also kind of the basis of bitcoin in a lot of those cryptocurrency systems so not only are you getting an education on user authentication but you're getting a basic education on how cryptocurrencies work as well and the second reason is this is arguably more robust of a solution than a basic secret key but in all reality if you're still watching this course then you're probably the type of person that would be interested in these extra little details so let's go ahead and dive into a basic introduction to public key cryptography this is a widespread topic public key cryptography and cryptography in general can be used for several different things whether you're talking about user authentication cryptocurrency or even just secure transport over https so i'm going to in this video be talking about what is public key cryptography and how does it work from both a conceptual and practical level so we're going to walk through the basics of you know conceptually how it works but we're also going to look at some code and see it in action before i get into what public key cryptography is we need to distinguish between two terms so that would be asymmetric and symmetric cryptography so public key cryptography what you see on the screen is a form of asymmetric cryptography because you have a public and a private key associated with it now a more basic form in what is used for tls or transport secure layer or whatever i think that's what it is otherwise the protocol that we use to transport data securely over an insecure internet channel that is going to be symmetric cryptography and is identified by a single key so a great way to think about this is maybe in a classroom setting so say you're sitting in a classroom and you want to pass a secure note to some of you know one of your friends across the room but you want to make sure that if the teacher intercepts that message they can't read it so what you would do is before class you're going to connect with your friend or friends that will be basically interchanging notes and you need to come up with a secret key so you might just come up with a real simple secret key and that key is going to be okay we're going to take every letter in the message and we're going to increment it by two so an a becomes a c and then to decrypt it you just have to take that c and bring it down two letters to be an a so now that the people that are interchanging messages know what the secret key or the cipher algorithm is they can easily read what the teacher thinks is gibberish when the notes are passed so to encrypt the data one student is going to basically you know write something down write the message that they want and then they're going to transpose it using the cipher algorithm so once again an a becomes a c a b becomes a d and so forth then they'll have someone you know walk that note across the class or pass it from desk to desk and we'll say that the teacher intercepts it the teacher cannot figure out what the note says it just looks like gibberish but the student on the other end could have decrypted that message by using that secret cipher so that is what we call symmetric cryptography and obviously we need to protect that secret now this is again used in transporting messages over the internet it's also used a lot in web application development you'll commonly see something called a secret key and that is what you'll be using to encrypt some sort of data now on the other side of things we have public key or asymmetric cryptography which is a little bit more complicated and involves a private and a public key pair so these private and public key pairs are mathematically linked as we'll see a little bit later in this video but the basic gist of it is if you have a public key you can give this to anyone as long as you keep the private key secret and then we can do two things with that public private key pair the first use case is going to be exactly what we just talked about with encrypting some sort of data so you might think of this the way that i like to think of it is a padlock and a key so basically i mean this is kind of a contrived example but basically think about maybe we're sitting in that same classroom and we have some sort of lock box and so one student is going to write a note which is just going to be in plain text and they're going to put the note in the lock box so what they'll do now is they will close the lock box and lock it with a padlock so that padlock before class was actually given to the student by another student who actually owns the key to the padlock so just to level set here the student that's writing the message has the public key of the other student who will eventually receive that message and decrypt it with the private key that corresponds to that public key so in other words student writes the message puts it in the box locks it with the other students public key then we send the box across the room we'll say the teacher intercepts it tries to open it but of course they don't have the private key that corresponds to that padlock or just the physical key that will unlock it so they can't unlock it can't see the message but if it gets to the student who does have that private key they can just unlock the padlock open the box and see the message so that is your first use case now the second use case is a little more complicated and we're not going to be able to understand it in the form of the classroom setting we're going to have to get into a little bit more complicated math but that second use case is called a digital signature or identity verification and this comes in handy when we're talking about user authentication and is pretty much the entire reason for me making this video so again if you're following along the passport.js user authentication series what you're going to want to really focus on in this video is that second use case or identity verification as you'll see to use these two use cases all we're going to do is change which key we are encrypting and decrypting with so to encrypt some sort of data but not protect an identity we're going to encrypt with the public key and decrypt with the private key as with the padlock and key in the classroom now the second use case we're just going to flip that we're going to encrypt with the private key and decrypt decrypt with the public key now in order to understand this we have to understand what a trapdoor function is and this comes in several different forms but in the case of public key cryptography or asymmetric cryptography we're talking about elliptic curve multiplication we'll get to that in one second but first let's just generally understand what a trapdoor function is so basically what a trapdoor function is is a oneway function that takes some pretty big piece of data and compresses it into a deterministic small piece of data outcome so in other words we can have an infinitely large piece of data we could have let's say something as simple as what you see on the screen right now or we could have something as big as maybe an entire book and what we can do is we can take that infinitely large or small data and put it through what we call a trap door function in this case we're using a sha 256 hash function and that will always create a deterministic outcome so it's going to be the same length i think it's i don't remember off the top of my head exactly how many bytes this is but it's a hexadecimal representation of the data on the left so if we were to come to an online sha 256 hash calculator i've pasted in that exact value in json string form and we get out this hash value and so anytime we put this particular data into this sha256 hash function we're going to get the same exact output every single time so it is deterministic you can try it for yourself now we also have to know about this that we cannot go backwards so from this data on the right there's no possible way that we can derive what the original data was in the first place even though we know that we're using the sha256 hash function we know that that's only one way you can't go the other way the last important thing to recognize about this is we have an infinite number space essentially now it's obviously not actually infinite but there are so many different combinations that the sha256 hash function can produce that the chances of us having two different pieces of data that come to the same hash value is essentially impossible now there's plenty of stack overflow questions on this and you can read up on them on your own time but basically the probability of this guarantees that we're always going to get a unique hash value what we're interested in when it comes to public key cryptography or asymmetric cryptography is a oneway function or trapdoor function called elliptic curve multiplication now it's not actually multiplication it's a cryptographic function and basically all we need to know about this is that it mathematically links the private and public key so in other words using the using the private key we can derive the public key but having the public key we can never get back to that private key so in other words we can share the public key with anyone in the world and they'll never be able to figure out what private key corresponds to that public key this again is useful for those two use cases of either protecting some sort of data or verifying an identity we'll see a little bit more how this works when we actually get into the code but first let's kind of take a quick glance at how elliptic curve multiplication works so on the right you'll see the elliptic curve graph which is useful to us because given any point on kind of the on this graph we can take the tangent of that point and get to another point on the graph so say we're right here on the graph well this curve extends infinitely so we can just take the tangent all the way up to that curve so let's go to the next slide and first start out with what we call the generator point now the generator point is an arbitrary random value or coordinate that we will always start with now this point in many cases is going to be a fixed point that we use for a large private key i guess you could say number space so we always start with the same generator point but then the variable in the quick equation is the private key and we take that private key and we multiply the generator point by the value of the private key so again the private key is some infinitely well not infinitely but it's some small or large value and so we can just like we can take g times two and g times three we can also to do g times you know 10 trillion or whatever the total value of that private key is now you might ask how are we going to multiply g that doesn't make any sense this is a graph and how are we going to actually do multiplication well the way that that works in elliptic curve multiplication is by drawing tangents as we talked about so you start with the generator point and say that your private keys value is two now obviously it's never going to be two it's going to be a much much larger number and we're going to do this process many more times but essentially what's happening is we start with g we draw the tangent to that point on the curve which the tangent intersects this other point on the curve then from that other point we say okay what is the opposite side of the curve so we draw this completely vertical dotted line to get to this last point on the curve and that is essentially the multiplication value of our operation so g times 2 is going to equal this coordinate down here at the bottom so you can see how this is kind of it's not exactly the multiplication that we're used to but essentially what is happening is we start with this arbitrary generator point we multiply or we go through this process however many times the public or the private key value is and eventually we will reach a certain point on the elliptic curve and that is going to represent our public key now we cannot get back to the private key based on the public key coordinate but what we can do is we can derive that the private key that may be signed a message corresponds to the public key so if we so in other words what you need to understand is that using the complex math the elliptic curve cryptography does we can actually verify that a public key corresponds to a given private key mathematically without revealing the private key to the person trying to verify it so in other words we can decrypt a message using a public key you'll see how this applies a little bit later in the video just to recap before we get into the actual code if we want to do data encryption we're going to encrypt with the public key and decrypt with the private key if we want to do identity verification or a digital signature we are going to take the message that we want to sign and we are going to essentially sign it with our private key and then some random party you know some receiver of the message is going to have somewhere the public key that corresponds to the private key and using that public key as we just talked about we can use that elliptic curve algorithm to verify that yes indeed the person who signed it has the private key that corresponds to that public key okay so let's take a look at the actual code that will create this private and public key pair now there's of course command line utilities that you can use to do this but i wanted to kind of write it out so that we can explain it and understand it a little bit better let's go to vs code real quick and create a new file we're just going to call this create keypair.js we'll open up this file and i'm going to paste in some code that i already wrote so let's walk through this code really quick we're using the builtin nodejs crypto library and then the builtin node.js file system so that we can output the keys in this directory and you'll see what's happening is we have a single function that will generate a key pair all it's doing is using the crypto library to generate the private and public key using that elliptic curve multiplication under the hood and then we're going to write that private and public key to separate dot pem files in the current directory so you'll see that here is where the magic is actually happening and then down here is where we're taking those values and writing them to the files so you can see that we're using the rsa algorithm to generate the keys that's a pretty standard algorithm to use and then these you can just go ahead and look at them on your own if you want to pause the video to see what they represent but basically this is all the math that we just talked about and when we run this script by saying node create key pair it's going to finish and then you'll see on the left we have both a private key and a public key in other words this private key is something that we want to keep to ourself not share with anyone and the public key can be shared with absolutely anyone with full confidence that they will never be able to figure out what this private key is all right now that we have our private and public key let's go ahead and use that in both of those two use cases that we talked about earlier so to do this just remember we have the private key and public key saved in this current working directory so i'm going to close them i'm going to close the create key pair and then i'm going to create a new file called encrypt.js and in this new file we're going to write an encryption formula where we take some sort of data and we encrypt the data and we protect that data so i'll paste in the code you're going to see we require the crypto library again and then i've got a single function that's going to take a public key and a message as an argument so again if we want to protect data but not an identity we encrypt with the public key and decrypt with the private key so what this file is going to do is it's going to take the message that we give it it's going to create a node buffer with utf8 formatting from that message and then it's going to pass that buffer into the builtin public key encrypt function that the node crypto library provides us with and then what we're going to do is we're going to export this function so that we can import it into another module so now that we have this we can save it and then create one more file called main.js where we're going to do a lot of the work let's go ahead and open up main.js and copy in some code that i already wrote a little bit earlier so again we're using the file system and then we're also importing this file right here that we just wrote so by importing this we have access to the encrypt with public key function and so what we're going to do in the main file is we're going to first get access to the public key that we created and stored in that pem file in the current working directory so we just use the file system to do that and then what we're going to do is create an encrypted message and store it in the encrypted message variable so you'll see that we're going to use the function that we defined in this other module we're going to pass in the public key that we got from the file system that we created earlier and here is our super secret message that we don't want anyone to be able to decrypt over a public channel so once we do that we can basically console log the encrypted message as a string and you'll see when i save and run this file that in the terminal you'll see some gibberish that we cannot decrypt so node main.js and of course we see a bunch of gibberish this means absolutely nothing to us and there's no chance that we figure out what this super secret message was based on this data so in other words this right here is what you're going to transport over any sort of insecure transport layer so to decrypt this we can do that with our private key so let's take a moment to see how that works we'll clear the terminal and create another file called decrypt dot js and when we open that up we can paste in a similar function to the encrypt file so we're going to require the node crypto library define a single function where we decrypt with the private key and then all this will take is our encrypted message and the private key and then it will use the builtin node crypto library private decrypt function so we're going to export this function so that we can import it in another module save it and then we're going to use the main module to actually decrypt this okay so you're going to have to use your imagination a little bit because we're both encrypting and decrypting in the same file but hopefully this will make a little bit of sense so at the top part of the file we have encrypted our super secret message right here at the bottom part we are going to import our private key and then we're going to use the decrypt function and we're passing that encrypted message into the decrypt function and finally we'll take that decrypted message and convert it to a string and print it to the console so what we should expect with this file now is that in the console we're going to get that gibberish message that is encrypted and then finally we will have the decrypted message which should say super secret message so let's run that real quick we'll say oop come down to the terminal we'll say node main.js and we have a problem so let's see what the problem is decrypt is not defined because i did not import it so let me import that real quick now that we've imported it we can use the function let's try one more time so we got the gibberish up top and then we finally got the decrypted message at the bottom so that is just a basic way that you can understand how we use private and public key pairs to protect data over an insecure transport layer in order to see how digital signatures work we're going to have to add a few things to our encrypt and decrypt modules because remember we are going to encrypt and decrypt with different keys based on which use case we want to use so let me do in the encrypt encrypt function or module i'm going to add another function called encrypt with private key so we can encrypt with the public key in case of data protection or we can encrypt with private key in case of a digital signature so let's go ahead and export that from this module real quick so encrypt with private key so now we have a module called encrypt which we can do both encryption with the private or the public key likewise we need to do this in the decrypt module so let me just highlight this whole part paste it in we've got an extra import here and we've got our function decrypt with public key so now that we have those components we can see how a digital signature actually works but mind you a digital signature is a little bit different than protecting data we're going to have to go through just a little bit extra work to do this because this is a little bit more complicated i'm actually going to make separate files for the steps of the process so with the digital signature we have some sort of data that we want to put our signature on so just think of it like a legal document you have the document itself with the data and you want to sign it and you want to make sure that the receiver of that data is assured that both the data that was on the document has not been tampered with we don't want someone intercepting it and changing some of the legal proceedings on that paper and we also want to make sure that the person we think signed it actually did sign it so that's step one we need to sign the message step two is actually verifying it as i just described so for step one let me go ahead and close all of these files you know what's you know what is in them so we will create a sign message dot js file and in this file let's go ahead and import some different modules so let me walk you through what's actually happening here starting from the top we have the node crypto library pretty familiar we also have the file system and then we have the encrypts and decrypt modules that we created ourselves now the last thing is this hash function and this is a sha 256 hash we talked about this a little bit earlier and it is a trapdoor function that takes a pretty much infinitely large or small piece of data and you put that data through the hash function and the output of that hash function is going to be every single time you do it it's going to be the same exact value and that value is going to be small enough that we can kind of transport to different places it's always going to be 64 characters long which each character is four bits so you have 260 or 256 bit value that is always going to come out of that function no matter how big or small the data you put into it finally at the bottom you'll see that i have a piece of data this is going to be the data that we're going to sign now you'll see that i've got my first and last name and then in the social security number field we're never going to put that because remember this second use case of signing some sort of data does not protect the data itself if someone intercepted this data on an insecure channel they would be able to read everything that is contained in it so we never want to put any sort of confidential information in data that we are digitally signing all right so the first thing that we need to do is we need to take this data right here since it's pretty large and we need to compress it down into that sha256 hash so to do that deleted it to do that i'm going to paste in some code that i wrote earlier and what this code is going to do is first store the json string value of this data right here and it's going to store that in a variable and what we're going to do is we're going to use that node crypto library hash function and we're going to hash the data that i just put in string form then we're going to convert that into hexadecimal format and this is important because the format that we're passing values between function in is actually really important when we're using the crypto library we are now ready to actually sign this data so let's paste in some more code first we're going to get access to the private key that we created earlier in second we are going to store the signed message in a variable we're going to use the encrypt with private key function that we created using the node built in crypto library we're going to pass in the the sender private key so in this case i am the sender of this data and i own a private key that i'm going to sign this message with so i will sign the data with my private key and this data is going to be in the form of the hash data so we're not just going to sign this big data object we're going to sign the hashed version of that data now the last thing that we have to do is kind of that extra step that i was talking about so if you just sent this signed message to someone they're not going to be able to do anything with it not only do we have to verify that nobody has tampered with our legal documents so to speak we also need to verify that the person that says they signed it actually did sign it to do that we need to provide the receiver of this data with a few additional pieces of information so those pieces of information is number one which hash function we used to hash the data number two we have to actually give them the original data so that they can take the hash function take the hash of it and then they can eventually take the signature that we provide them with and match it up with that hash data to make sure that the that i actually signed the data in the first place so let's go ahead and see what that looks like we'll go ahead and create a final piece of data so we'll say package of data to send to be very explicit and we'll paste in this data object so we've got an algorithm so this tells the receiver of data i want you to use the sha 256 algorithm and what i want you to put in that algorithm is the original data that we created so you'll see that the original data is my data which is the original object of data that we will use and then of course we have the signed and encrypted data which we assign to the signed message right here so with this information a receiver of this data can verify using my public key that not only was the data not tampered with but i also signed it last let's go ahead and export this package of data so module dot exports dot data or let's just call it the same thing that we called it here package of data to send equals package of data to send so we can access this from another file to do this we're going to create another file called verify identity.js we'll open up that file and we'll put our imports in there so we need the crypto library we need that decrypt module that we had created on our own and then we need to import the data that we just exported from that other module so this is everything that we need to verify this message now we also need to bring in the public key of the sender so this will be made publicly available and we'll say that you know i sent this data in the first place but my friend jim whatever is going to be verifying it so jim will need my public key to do this which again public key is public and anyone can see it you can feel confident that they're never going to be able to figure out what the private key was and one thing you'll notice that i required this in but i need to grab the variable that we exported so require this module and the variable so our received data is equal to this object right here in the sign message file next we need to actually take our own hash of the data that we were provided so to do that we know that we're using the sha256 hash and so we can use that hash function to hash the original data i'll paste this in here and you'll see that our hash function is going to be the builtin node hash function and it's going to be the algorithm that was in that data package so i know this is a little confusing but this line right here in the verify identity file is the same as this import right up here so where we said create hash sha 256 we're also creating a hash and we're just using that algorithm that we've received in the data package like i said we also need the public key of the sender so we'll go ahead and get that in the public key variable the next step to doing this is we have to take that data that was signed and decrypt it so let's think about what this is actually doing i'm going to paste in the code and we're going to use our decrypt module we're going to pass in the public key right here this is the public key of the sender and then we're going to take the the data that we received and we're going to pass in the signed and encrypted data so if we come over back to the sign message let's figure out what this was so our signed and encrypted data was our signed message which basically if we decrypt that message what it's going to give us is the hash value that we derived from this original data so what we're going to get in this variable right here the decrypted message is simply a hash value so in order to verify that we can then take our own hash of the data that was provided in this object right here so this is the original data and if we take a hash of that and compare it to the decrypted message here they should match and if they do match we can know that not only was the data not tampered with but it was also signed by the person who said that they signed it one extra step we've got to do is we've got to turn that decrypted message into a string value to pass it into our function that's just a formatting thing finally we say we want to look at the hash of the original so we're going to actually take the hash of the data that was passed to us in that data package and then we're going to turn that into a hex value to verify it we'll just do a basic if then statement so we'll say if the hash of original hex so basically our own so this is the receiver of data jim is doing this he's taking a hash using the designated hash formula and just turning it into a hexadecimal value so that we are comparing apples to apples and then we're taking the decrypted message hex which is basically what came with that is what we decrypted in comparing them so if it is the same then we're going to say success the data has not been tampered with and the sender is valid so let's see if this works let's go down to our console and run node verify identity and you'll see that it says success data hasn't been tampered with we have the right sender so hopefully that makes sense that is the second use case of public key or asymmetric cryptography and is called a digital signature it's a very common way to verify data and identities and you'll see if you are following the passport.js series that this video is kind of associated with you'll see exactly how that works when we actually are authenticating users now just as a consolation for this video what we just did over the last few minutes when we were signing and verifying a message is the same exact process that is used with json web tokens so you might say wait a second there might be a better way to transport this package of data over the internet and you are right there is indeed a better way to do this if we were to send this package of data it's going to actually be a pretty large piece of data and it's going to slow all of our web searches down especially if we're using it for some sort of authentication so naturally the easier way to do this is to represent this piece of data in a much smaller form just like we took the original data and we took a hash of it to make it smaller and more transportable we can also do that with the data package that is sent to the receiver of data and is used to verify the original data let's jump into the browser real quick and what i have pulled up is jwt dot io which has a really simple jwt visualizer per se now don't focus on what is going on here because i have a separate video on that but just recognize the structure of what's going on so on the left this is our entire jwt token and you can see that it is pretty short and it would be very easy to transport over the internet in a quick and efficient manner but if we decode this jwt it has the same critical information that we saw when we were signing and verifying an identity in our code earlier so first we have the algorithm which is represented by this reg string and so this will tell us exactly what sha or sha 256 hash algorithm that we have to use to decrypt the data then we also have a payload which is represented by this purple string and you can see i guess i deleted something here but you can see that it has all of the information that we would need to include in that payload of data so this you could consider that legal document that we are signing and then finally at the bottom you have the actual signature and the signature is going to include um you'll see the public and private key here but this is actually just going to be the signature that we wrote in the code earlier and we can verify it with a public key all right now that you have a basic understanding of public key cryptography we can move on to understanding what is a json web token now i could of course go through a basic example and just show you the pieces and all that stuff but i want to take it even further as i promised this is you know hopefully one of the most detailed user authentication courses that you've ever taken and in that light i want to actually derive and sign our own implementation of a json web token using some of the internal node.js libraries the questions that i'm going to answer in this video is first what is a json web token we will then go into answering the question of how do we derive a json web token like what are the pieces of it and how would we actually create one using code and then finally i'll give you a little bit of context as to how it applies to user authentication among other use cases we'll start the video off by looking at the jwt or json web token spec on the internet engineering task force it is going let me switch to google chrome real quick you'll see that they have a write up on jwt's and the specification for using them we'll come back to this in a minute to look at a few things but um this is a very well established type of token per se i guess you could call it a token that we use to transport some sort of data on the web now something a little bit more friendly that we can look at is a website called jwt dot io and right here i am looking at the example jwt and we're going to be able to visualize what is going on a lot easier once we kind of understand what the jwt is we'll actually go into writing some code to kind of replicate this example right here so to understand jwt it's pretty simple there are three parts you have the header the payload and the signature now the header and the payload pretty easy to understand the signature not so much because there's actually multiple types of signatures that you can do and therefore it adds a little bit of complexity on top of that a signature is a digital signature and it has to do with public key cryptography or just symmetric cryptography depending on which algorithm you're using so it requires a little bit of background knowledge which is why i recommended watching that video that i had created on public key cryptography before this one now you'll see in the algorithm field up top we can kind of scroll through all the different choices that we have for writing a digital signature on a jwt but in our case since i had you watch the public key cryptography video we're going to do the rs 256 algorithm which is basically as you'll learn more when we get into the code is telling us two things so number one we're going to use rsa private and public keys that standard and then number two we're going to use the sha 256 hashing function to actually take a hash of the header and payload data i know that's a mouthful we haven't learned anything yet so just hold on to that knowledge in the back of your head we'll come back to it and understand it in a lot greater detail in a few minutes let's start out by getting a basic understanding of what a json web token is so i mentioned that it was made of three parts you have the header the payload and the signature and these are highlighted on the page here in the different colors and they are separated by a single period so the first part in red is the header then you have the pink part which is the payload and finally this turquoise part is the actual digital signature now what you're looking at right here is base64 url encoding and i'm not going to get super into it but just a few fun facts about base64 url encoding it's a encoding spec that basically aims to standardize character sets and it's derived from the base64 encoding which was originally created well before you know my time of learning to code but from what i understand the idea there was previously before the utf8 standard where we had you know standardized character sets there was debates over whether you know there should be four bits or five bits or seven bits or eight bits within a single byte of data and before that was standardized as eight bits per byte there was varying use cases and different you know protocols and applications would use different number of bits in a byte and so therefore you might have an application that actually cuts off the last two bits of data so what base64 was aiming to do was basically add this thing called padding into the data and so it makes it so that there's no chance that any of the data is going to get lost in transport and then the base 64 url encoding is just one extra step because there were some characters within the base64 encoding that are not exactly url friendly or file name friendly so converting base64 to base64 url just makes it safe to transport over the internet and we also know that this format in general is not going to lose any data which is obviously very important when we're talking about user authentication which is a very common use case for jwts i know that was a bit of a longwinded explanation of an encoding um not so interesting but as we actually derive this jwt with code you're going to see that we're kind of constantly having to shift between the different encodings and it's going to become a little bit more important later all right now that you know what you're looking at here on the left let's talk a little more conceptually what we're seeing here on the right side so on the right side all we've done is we've taken these base64 url encoded characters and we've decoded them into json objects and in the header you'll see that we just have a couple things we have an algorithm and a type and this is pretty selfexplanatory but when you're transporting json web tokens over the web it's not always the case that the receiver of the json web token is going to know you know anything about the json web token to start with so in the header the sender of the json web token or the issuer is going to identify which algorithm they use to create the digital signature and then of course we say that the type of token is a jwt because there's actually other types of token tokens that we can use here aside from just json web tokens so we have again chosen the rs 256 algorithm which says we're using public key cryptography for the digital signature along with the sha256 hashing function and what we're going to do is well actually before i get into this let's cover what the payload is then we'll get into that signature so the payload is basically going to be metadata about some entity and in most cases it's going to be about a user because jwts are commonly used for user authentication so in this payload you're not going to see any sort of credentials if you see credentials in a jwt payload then you know that the developer has done something wrong because you should never ever put credentials or sensitive information in the payload it's publicly available anyone could decode this jwt just using a simple base64 url decoding algorithm so what this data gives us is just general information about the user so you'll see the sub or subject is going to tell us who the user is in many cases you'll see some sort of database id put in here so that when an application decodes the jwt they see okay here's the sub it is this id let me look up this id in my user table and retreat retrieve the full user object so that's what the sub is um name obviously just the name admin just another metadata property and then iat is issued at so it gives you the time stamp of when the jwt was issued now we also have additional um what they call claims that's kind of the proper term for these pieces of data we have additional um claims that we can define and if you go over to the specification for jwts you have all this information but down here at the bottom or somewhere in the middle we have the registered claim names so these are registered it says the following claim names are registered in the iana json web token claims registry established by section 10.1 so in other words these are kind of the official claims that you'll be using and if you wanted to issue jwbts that would be interpreted by various applications you would want to use these standard claims so that everyone knows exactly what they mean so let's just go through the most common ones and then there's a few others at the bottom you can look through on your own so first is the issuer claim this is going to identify the issuer of the jwt now in our case we probably don't need this because we are both issuing and verifying a jwt within the same application but in many cases for more complex architectures you'll see a certificate authority who is actually being it's the certificate authority acts as the third party authority that is trusted to issue jwt tokens and that is literally all they do so we have we basically can establish a centralized authority that everyone trusts and that centralized authority will sign the jwts with their private key and because they sign it with their private key they'll say okay here's our public key and anyone in the world can say okay i trust that institution and i'm going to verify this jwt with their public key if it matches i know that this jwt was issued by a trusted authority so that's kind of where you'll see the issuer claim the subject claim we already covered the audience claim is going to generally be the resource that will accept this jwt so in other words um if the jwt is only intended to be used with a specific application um it would probably list some sort of url or base url that will identify which server the jwt is valid for so in other words if google issued a jwt token they might put in the audience claim www.google.com and if the jwt is attempted if if you attempt to use the jwt in a different context other than google.com it's going to be rejected then finally we have the expiration claim which basically tells you when or what point in time this jwt token is no longer valid there are additional claims that you can put in here we saw the iat issued at claim but you can also and this is important you can also make up your own claims this by no means has to be standardized you can put whatever metadata that you want in the payload and last but not least we have the signature at the bottom we've already kind of touched on it i talked a lot about how this actually works from a cryptography perspective in that video that i asked you to watch before this one again link is in the description for that but anyways i think it would be helpful to go through kind of a conversation between the server and the client to understand how this jwt is working in real life so i've put together a basic little representation of this and what we have here is what i kind of perceive as the conversation that the server and the client would have if they could talk to each other in human terms of course so the server just think of this as any application we're kind of removing the idea of certificate authorities from this basic equation we're just going to assume that the server will just say it's an expressjs application is both issuing and verifying the jwt tokens so we don't have that third party certificate authority in this equation so what's going to happen is our client or just basically our user someone sitting behind a computer who is visiting our application on the web is going to go to the login page and say hey server i want to log in to your application here's my username and my password then the server gets that information in the form of a post request and it's going to say okay let me check on that i want to go through my verification algorithm and look you up in my database to make sure that you exist and you entered valid credentials we'll assume that the user did so the server says okay your credentials look great i'm going to sign a jwt token or jwt with my private key that only i know about so the server is the only entity that has any knowledge of that private key they're going to sign it and send back the jwt in the response body so then the client or the user basically this this doesn't actually have any user interaction it's invisible to the actual person behind the computer but the browser or the frontend application is going to receive the the response and say hey thanks for the jwt i'll keep this stored in my browser's local storage until maybe it expires so then the client is going to once they're logged in they're going to want to do something so maybe this client wants to go edit their profile so they'll type in the url of the profile just say some site.com this is just an arbitrary value and then they're going to need to attach that jwt token or i keep saying jwt token but it's json web token to the http header that's called the authorization header and so in the authorization header is where that's going to be stored the server is going to receive that jwt in the request body and then we're going to say okay i just talked to you we're familiar but i still need to verify that jwt because i don't know if in the time that you chose to visit the profile did someone tamper with it so we're going to take the jwt and now the server says okay i signed it with my private key but now i'm going to take my public key that everyone knows about but i don't care because it doesn't actually matter i'm going to take that public key and verify the signature on that jwt and the server says okay that signature is indeed valid i know that you know you are actually you and the claims made on the body of this jwt are valid let me go ahead and look you up in the database load your user profile and give you the information required to actually edit that user profile so that is the basics of how a jwt works i'm going to in a few minutes go through the code for deriving a jwt but i will also mention again this video was intended to be kind of part of my node.js passport.js video series which the playlist is listed in the description below if you wanted to know more about what we just talked about how this actually works in practice written in code say for an angular application go ahead and follow that series through the end use the passport jwt authentication strategy and you'll see exactly how this works in practice but for now we're going to jump into the code editor and actually see this process written out how we issue a jwt and then how we verify that jwt just using the builtin nodejs crypto library to start off with we're going to go through this part where we issue a jwt to keep it as simple as possible i'm going to take the example off of jwt.io so if you visit this you should see the same thing and i'm going to actually be showing you how we get to this jwt how we actually issue this one and then how we verify it using the public and private key so you should be able to verify how this works by just coming to this site and you can actually follow along with the node.js crypto library so i'm going to go ahead and just copy this entire token again this is in base64 url format or encoding so i'm going to copy that and then we're going to come into the code editor and paste it in here so i first need to create a file so let's just say issue jwt.js and you can see that on the left here i've already pasted in the private and public key those came from that jwt.io website alright so i've copied in the key right here let me just put this as a string and store it in some sort of variable so we'll say const jwt equals that so this is the exact jwt that we saw from that example website now in order to properly do this we need one npm library and it's called base64 url so i've already installed it but you'll come down here to your terminal and install base64 url to follow along with this so i'm going to go ahead and require that in real quick so we'll say base 64 url and now we can take this jwt right here and convert it into something that we can actually work with we now need to split up this jwt into its parts which if you remember is designated or delimited by this period so we can do that using some simple javascript so we'll say jwt parts equals jwt dot split and we'll specify that period so now if we were to console.log the jwt parts we should have an array of those three parts so let me go ahead and try that real quick and you can see that we have an array and the array contains the three different pieces of that jwt token again these are still in base64 url encoding let's go ahead and split these into variables so i've just written this code already we basically say header in base64 url url format is going to be the first one so in our array right here we're just grabbing that piece and then so on and so forth with the remaining two now what we have to do is we have to actually take this base64 url format and convert it to something else now that we have this in pieces we can decode this with the base64 url decoder the npm module we included up here and we can see the actual json objects that these represent so let me put those in variables real quick so we have the decoded header payload and signature and we're just using that base64 library and using the decode method and we're passing in the base64 url pieces and then finally we can console.log those to the terminal and you can see what they look like decoded so let's go ahead and console.log those we're just taking these three variables here and logging them save the file let's give us some space in the terminal here and let's run this again so you're going to see the first part is the same thing that we saw on google or on the in the browser at jwt.io and the second part also so these match perfectly as we would expect and then we have a bunch of gibberish at the bottom and the reason being is because we haven't actually um decrypted the signature yet so once we decrypt the signature then it will be in a format that we can understand a little bit better now that you've seen this decoded i'm going to actually comment all of this out for a second because we don't need this we're going to actually derive this jwt from scratch so commenting that out for a second we'll just space it down to the bottom and what we're going to do is actually create this from scratch by first creating the javascript objects that we want to put in the header and the payload so you can see that these are the exact same header and payload objects that we printed in json format below now obviously these are in javascript format so we will need to convert them into json format by saying using the json.stringify method so let's do that right now i pasted in the json.stringify method and stored these two objects as json strings in these two variables the next thing that we have to do because right now these are just in json format we need to actually convert that json format into the base64 url so to do that we'll use this base64 url library and we'll just put it through the basic function and convert it so here we go copy this in i'm just copying code that i wrote before to speed things up but anyways we have new variables hopefully these are labeled appropriately for you but we have a base64 url header and payload all we've done and we actually need to change this a little bit so we're going to just use our import here base64 url and the basic function that comes with that library is just a function to convert any sort of object into the base64 url format so these two variables store the correct format for our header and our payload now we have to actually sign and issue the jwt but first let's go ahead and check this we're just going to console log these two values to make sure that we have actually converted these original javascript objects correctly so let's go ahead and clear the terminal give us some space and run this again and you'll see these two values which we can actually check from the commented out code so here's our original jwt that we just took from the website and posted right in there and you'll see that this first value matches the first value of there and then the second one if you wanted to go out there and confirm that it also matches so we've got what we need again the last thing we have to do is actually take some sort of hash of these two pieces of data and then sign that hash and put that in the signature in order to sign this we need to import a few more libraries so at the top i've imported the builtin node.js crypto library and then from the crypto library we can also implement the algorithm that we're using for this jwt so this is going to allow us to sign the jwt using this specific algorithm and then we need the file system from the node.js framework so that we can access the private and public key that we have saved in this current directory now that we have our imports let's come down here get rid of these console logs and we're going to create the signature so the first step is to use this signature function and we want to write some sort of data into it so right here we're just passing in the header and the payload separated by this period and this is going to be the data that is actually hashed using the sha 256 hashing function this is all kind of done within this node crypto library but we're going to hash this data and then we're going to sign the hash so we've loaded the data in here the last thing that we have to do is load our private key which we're going to be signing it with and then use the signature function sign method to actually sign the jwt here is the code to do that copy it in first we need to load our private key that's literally just loading this private key pen file and i actually need to change the name for this to work correctly so private key dot pem and it's important to put this in utf8 encoding and then we are going to convert this is kind of an important part we are going to sign this data which is going to give us a base64 encoded signature so then to actually derive the jwt we're going to have to convert base64 to base64 url we can do that with this imported library right up here so i'll show you the code for that here's the code that we use to do that so we just basically take the signature that we got from the node crypto library and we convert it from base 64 to base64 url so now the signature should be in the same exact format that we were expecting earlier let's go ahead and verify that real quick so signature base64 url we'll print that out really quickly and you're going to see this value right here let's go ahead and just verify it real quick so here again is our jwt we need to come all the way out to the last piece of it and here we go there's the last piece and you can see that the first couple letters are matching up and if you were to go through all of it it's going to match to the character so right there we from scratch created a jwt token using the node.js crypto library now there is an easier way to do this and i will show you that in a few minutes but first we need to verify this jwt that we just issued since we already have a lot of the basics set up we're just going to uncomment some of this code to verify the signature so let me just make a comment for this first part probably should have just named this file jwt because we're doing both the issuance and the verification in the same file so here is the issuance part right here and then end of issuance and then here is the verification and we will go ahead and implement this now so when we verify at jwt we are basically receiving the jwt in the base64 url format in this case we just are going to use this one right here the one that we just created because we know that um it's exactly the same as that example online so to get the jwt parts we're going to uncomment that we will uncomment this part we don't need any of these things right here and i think we're set so now we can actually verify this jwt to do this we'll actually have to just create one more line in the imports and this is going to be the verify function from using the same exact algorithm so we've got the issue or the create jwt function and then the create verify or the verification function as the verifier of this jwt we have received the entire jwt right here we've split it into parts and now we have to actually do something with those parts so the first thing we'll do is we'll take the header and the payload and just like the signer of the or the issuer of the jwt did we're going to take the header and the payload and append them together separated or delimited by the period and since the the node.js crypto library only accepts base64 encoding we need to take the base64 url signature and convert it using the base64 url npm module to base64. so now that we have that we can finally i guess decrypt the signature so we're going to take our public key that corresponds to the issuer issuer's private key and we're going to decrypt the signature so the first thing we need to do is actually get the private or the public key in here so i'm going to just copy this line and use that we'll say public key and we just need public key dot pem so now that we've imported our public key that we're verifying with we are finally ready to verify this jwt so let's copy this in the signature is valid variable is basically going to run the node.js crypto library verify function that we imported right here so verify function dot verify we're going to pass in the public key that we imported from the file system we're going to pass in the jwt signature base64 format and then the most important part this will really trip you up it took me honestly hours to actually get this to work because i had not included the base64 format in the verify function so that's really important and once you've done that we should console.log the signature is valid and i think it returns a boolean whether it's valid or not so let's go ahead and try that really quickly node issue well it's not really issue jwt but bear with me we get first the signature that we were console logging right up here and then the signature is valid variable returns true so we have successfully verified this jwt and essentially we've gone through the whole process so we created the jwt from scratch and then we verified it from scratch now if you wanted you could use all the code that we just used in this example for your web applications to sign and verify jwt tokens but like i said earlier there is an easier way to do this and that easier way is using the json web token npm library and what this library is is basically an abstraction of the node.js crypto library and it gives you a little bit you know more options because in this example we were just using the rsa256 algorithm and we didn't even get into okay what if we use a different jwt algorithm so the json web token library is going to give you a lot of flexibility and it also kind of abstracts away all of the things all of these you know when we have to convert from base64 url to base64 you don't have to worry about doing that in this library so this would be the library that i would recommend using in any sort of web application where you're issuing and verifying jwts and in the next few minutes i will show you exactly how to use it to save us a little bit of time i've just copied in my implementation of the json web token library um if we wanted to accompl accomplish the same exact things that we did with the node crypto library now obviously since this is abstracted a little bit you're not going to get to see the little bits and pieces that are happening and you don't get to truly understand what is happening with the jwt but it does make your life a lot easier when you're actually coding so let me explain to you what's going on here the first thing you'll notice is i imported the json web token library i already installed it with npm install json web token so that is what that import represents we use the file system the node.js file system to grab the public key and the private key that we were using earlier so again this is the public key and private key from that example on jwt.io and then you'll notice this payload object is very similar we've seen it before because it's the exact same payload object but you might notice that you don't see the header and the reason being is that is one of the things that this library abstracts away all we have to do is provide the algorithm and the library creates the header on its own so you'll see in this next line we have a variable called the signed jwt which is a product of the json web token library sign method where all we have to do is pass in the payload object in javascript form so we don't have to do any of that json.stringify stuff and then convert it to base64 url none of that we can just pass in a javascript object then of course we pass in the private key that we want to actually sign it with as we know that's how jwts work and then finally in the options object we just have to give it the algorithm that we want to use and based on this algorithm the json web token library is going to figure out what the header needs to be so it will then combined that header and the payload just as we did with the node crypto library it's going to sign it with i actually think they use the node crypto library underneath the surface so they pretty much do exactly what we did earlier to sign this and then to verify it again just one simple line of code or a couple simple lines of code we just used the json web token verify method we passed it we pass in the signed jwt or this basically it's going to be received in the authorization http header for a web application so we take that jwt pass it into the verify function we use the public key that corresponds to the signer's private key in this case since we're doing the signing or the issuance and the verification it's just these two this key pair and then again we have to pass in the algorithms that it will accept in this case rs256 and then we have a callback function in the callback function if there's an error we know that the verification has gone wrong and either we have the wrong public key to verify this jwt with or the jwt was tampered with and we don't want to use it so let's go ahead and just verify that this works really quick so you can see it in action i will console.log the signed jwt value so let's just do that first really quickly and you'll see this value right here which if you were to match with the value online it's going to be the same exact thing so um you can do that on your own time but just trust me that is the same exact jwt and then here we can go into the callback function and let's say console dot log air and we should expect that we don't see any error whatsoever because we verified this successfully so we get null as the air as expected and then we can also console.log the payload which is the second argument that it returns and you should get the same payload that we had defined right up here except this was when we issued it and then this is when we signed it so you can see how this might work in an actual application you might have a post route that is going to verify credentials and then it will sign and return a jwt in the response and then you might have another couple routes that are like authenticated routes and you might have some sort of middleware like passport.js that is going to underneath the hood use this jwt.verify method and use the public key to verify the jwts that are being passed through the authorization headers couple hours later and we're finally ready for our second form of user authentication which is the passport jwt strategy i think this next section is going to be really rewarding for you because we're about to take all of those prerequisite lessons that we went through whether that be the express middleware overview or you know the basics of cryptography we're going to combine those together and put it into our user authentication strategy this one's going to be fun so let's jump in the first part of this series we went through the passport local strategy and in doing so we talked a lot about the inner workings of the passport framework and in this second part since it's a little bit more advanced i'm going to be skipping over those details so if you find yourself lost for example in the process of generating and validating a username and password in a database or maybe the verify callback for the passport middleware i would suggest going back to the first part of this series and specifically just watching the configuration video for the passport local strategy now before we start to code i want to go through the options that we have here when implementing a jwt authentication strategy so we're working with the passport jwt middleware strategy but we don't necessarily need to and this is going to be the most confusing part for someone looking for a solution on the internet because there are all sorts of ways that you can actually implement a jwt strategy in your application and because of that you'll have people who understand json web tokens pretty well and they'll have their own custom strategy working but they won't explain kind of how they got to that strategy and it leaves you the reader of the tutorial just thinking to yourself well what's the actual correct way to do this and in this video i've stuck with the passport jwt middleware not because it's a hundred percent necessary but because i think it's kind of grounded and it gives us a framework to start with and then we can kind of customize on the fringes as we see fit if we were trying to be very complex about this and probably the reason you would do this if is if you were maybe trying to write your own authentication framework or you're building your own authentication server or something that you have to do that's extremely custom the most complex thing that you could do is you'd use the node.js crypto library and then pair that with your own express middleware that work together to authenticate your users now i have no interest in doing this because there's a lot of code that you'd have to write to do that but given the fact that we actually went through the process of issuing and verifying jwts with the node.js crypto library you already have a pretty good head start if you did choose to use this now the somewhat complex method for authenticating users via jwt would be to use something like the json web token npm library which is going to give you a little bit more abstraction you have a lot less things to think about when you're actually issuing and verifying the jwts but you're still left with writing your own custom middleware for your express application so that leads us to the least complex method which is what we are going to do and that is to use the json web token npm library so it's going to be really simple to issue and verify the jwts and then we'll use the already built framework passport.js and then plug in the passport jwt strategy into that framework so we have our middleware written for us but you don't need this like i said there's a lot of different ways that you can do jwt authentication the reason we're going to go with the passport jwt strategy is because it kind of just takes takes care of some of the tedious things like say air handling or extracting the token from the authorization http header like all of those things you have to write your own code for which is also going to be airprone and you've got to test it so we would prefer to kind of offload that to a framework that's already been tested and used by a lot of different use cases so that's kind of why we're starting with the passport jwt strategy but wanted to lay that out for you the last thing that i want to go through before we get into this is the basic conceptual flow of how jwt authentication is going to work now this slide right here assumes that you understand the issuance and verification process of a jwt which again was in that prerequisite video in this playlist but anyways what happens is a user is going to log into web app so we'll assume that they're already registered um they're already stored in the database our application is going to go through the basic password verification process i talked about that in the session based authentication or the passport local video but basically all we're doing is we're taking the the username that the user is going to log in with we look up that user in the database and then in the database we have a salt and a hash stored for that user then we're going to use some of the um node.js crypto library methods to actually take the plain text password that the user just passed to us and compare it against the salt in the hash that were stored for that user record in the database if the user has validated correctly based on our logic then we are going to use we'll say the json web token npm library to issue them a new jwt token now this jwt token has information about that user as well as a signature from the server itself so one of those pieces of information is probably going to be the database id of the user so then the user client which is usually a browser is going to store that jwt so back up just a second the server issues the jwt and sends it in the response body of the http request then the user client receives that http request and stores the jwt that it received there in local storage or maybe even a cookie it doesn't exactly matter where you store it it just has to be persistent storage in the browser then on every single http request that requires some sort of authentication so maybe you're trying to access a protected api the user is going to or the user client is going to attach that jwt in most commonly but not always the authorization http header the important thing is that you put that jwt in the correct header that the server is expecting and the authorization header is just the most common that you'll probably see then the server looks for that jwt in the authorization header because you've coded it to do so and it's going to use the json web token library to verify the signature of the jwt if the signature is verified we know two things we know that the jwt has not been tampered with none of the data in it has been tampered with we know that it also came from the person that we expected it to come from so if the signature is valid the server then will decode the jwt which is in base64 url encoding so all we're doing is just taking that from base64 url to json format then we will read the um the payload which is going to have information about the user so we're going to probably go for the payload.subfield that's the most common place to find this information and it's where we're going to implement it in this video and we're going to grab from that field is going to be the database id for the user so then the server is going to take that id look up the user in the database and then now it has the full user object it can do whatever it wants with that user object in our case it's going to attach it to the um express request object and then we can use it within our routes and then finally once all that has happened the user is going to have access to the resource that they requested and our flow is complete that's the process if you ever find yourself confused as to what we're doing with the code later in this video in the next couple videos i suggest that you kind of keep this you know pause the video on this slide take a screenshot of it maybe even print it out so that you know exactly the the pseudo code steps that we are going through okay so the next thing that we'll do is come back to our code and what i have open is a github repository that you can download yourself and how i've structured it is we have two branches on this repository let me see if i have it open in the browser we can just visit it there there we go so here's the repository that we that we have i just finished it up a few minutes ago but basically we have two branches to work with so the first branch that we have is going to be master and this is what you're going to have is the default when you clone this and it's going to give you a basic starter skeleton for implementing the jwt authentication strategy as i talked about in other videos my goal here is not to teach you how to write an angular app it's not to teach you how to write an express app and it's not to teach you how to use a database with express the goal here is to solely focus on the authentication piece so what i've done in this template is i've done all the implementation for all of those pieces that i don't want to cover and i've left blank the specific pieces that relate to the authentication alright so when you when you clone this and you come back to whatever code editor that you're using you'll go ahead and npm install in the base of the folder and then you also over here i'm in the angular folder so right here you'll go in the angular folder and also type npm install once you've done that then you'll go to the dot env file and you're going to enter these three variables now you don't necessarily have to do this but i guess if you're using this as like kind of a starter you'll eventually need to implement a production database string but this is going to be entirely sufficient right here and then you're also going to have to come over to this script right here generate key pair and we talked about this in the prerequisite video on public key cryptography and this is the exact file that i used in that video and all it's going to do is create an rsa public in private key pair and then it's going to save it to the current directory now our passport jwt strategy is going to use this public key pair public private key pair to issue and verify the jwts so you're going to need to generate this the one thing that i'll note about running this file if you run into an error um trying to run this then it's probably because your node.js version is not great enough i think there is some method here um i don't know which one exactly it might have been the generate key pair sync from the crypto library but it was only implemented in i think it was version um maybe 10 or something you can go ahead and find that we're in the master branch right here but in the final branch you'll see exactly how to start the app and it's it gives you the required node.js version i think it's like 10. let's go let's just verify this right now um so let's go skip over to the final branch which has the final implementation of everything and it's going to tell you that you need version 10 point x or greater to do this script right here all right so make sure that you have that set up and then you're going to just say node generate key pair and press enter and what this will do i might as well just do this right now so let's delete what i've got right here already and then say node generate key pair and you'll see in the left side here it's going to pop up in a second you should see the public and private key pair that i just created um let's refresh it there we go so we have the private key and the public key and you should be good there and then the last thing that you need to know about the setup i think hold on one second that was actually it so that's all you need to do to set up uh you also need to sorry you also need to run the mongodb database in the background um so go ahead and do that before you run the app and then when we actually run this app we're going to um it's not going to work here because i haven't implemented everything but we're going to run node app.js in the root and then ng serve in the angular application and then we're just going to visit the angular application to run the app but that angular implementation is the last video in the series if you're not interested in that then that's totally fine it's totally optional but it's just a common thing to see jwt authentication in a single page application they're pretty compatible so that's why i decided to include that last video that last optional video okay so you should be set up completely with the repository you've cloned it you've done your setup steps now let's take a very quick look at the code i'm going to perf purposely try to fly through this and i'll assume that you're going to go through on your own and get yourself familiar with what is here already but i definitely want to go through a few things here so we'll start with the express app because that is kind of the required piece let's open up app.js and you'll see that we already have kind of our skeleton app set up so of course we have express we're going to import the cores module and the reason being is because in the optional final video where we go through how to implement this with angular we're going to need to make http request from localhost 4200 to localhost 3000 so from the angular app to the express app so you're going to need this course piece in here um path just going to give us access to the um the path that we want to save things in the file system node.js and then we're requiring in passport um the dot m configuration i talked about this in a previous video but basically gives us access to um the environment variables stored in the dot env file and we access those with process dot env dot variable name so that's how you will do that set up our basic express app we're going to import the configuration for the database which is right here um just scroll through here it's basically saying if we're in production environment connect to the production string if not connect to the development string which is just running on localhost and once it's connected we should just get a little message that says it's connected pretty simple there all right so then we require in our database models which is one model and it is the user so let's open up that real quick same exact user schema that we used in the first part of this with the passport local strategy and we're just having a username and then the hash and salt will represent the password in the database then we will require in the passport configuration which is where we're going to configure the passport jwt strategy now it's a little bit weird syntax but basically in the passport configuration we are exporting a function that takes the passport object so we're importing the passport library in app.js and then we're going to pass this variable right here into the configuration function which will then receive access to that and then in the body of the function it will actually do the configuration on that object so that's kind of how that's working we'll come back to that quite a bit so don't worry about it then we will initialize passport this is required for any passport strategy you always have to initialize it so that it runs every time that you make a route request these are pretty simple just body parser middleware except now express has their own implementation so we don't have to do the body parser middleware that you're used to seeing probably so something like app.use bodyparser.json we don't have to do that because express has their own implementation now here's the cores we talked about this line right here is going to allow you to kind of combine the angular and express apps since the angular thing is optional i'm not going to go through it too much but it's going to basically if we come over to angular and type ng build it's going to build all of the assets all the static assets for that application into this public folder and then express is going to use that public folder as the um static directory so in other words express is going to use the angular build as the front end for the application all right so that's what that's doing we're requiring requiring in our routes which should just be um okay so here's a basic route configuration if you wanted to extend it easily you could just add more route files and then add you know another line here that would say something like users will say i don't know something like courses maybe you're building some sort of course module and then you would have something similar to users right here where we have all of the user routes so that's kind of how you would extend that and then in the user routes we just have a protected route which is going to allow us to test whether we did the jwt authentication correctly then we have our standard login and register post routes which is going to allow us to issue the jwt and kind of validate the jwt and finally we have app.listen which will listen on localhost 3000. so that is the basic express app that we're working with and again i would hope that you would go through this and get yourself a little bit more familiar but if you built a lot of express apps in the past this probably looks like a pretty familiar structure now in the angular app i will go ahead and save that we're not going to go through what's happening in the angular app until you actually get to the video on angular so it kind of if you're not wanting to watch that we're not going to go through it and waste your time with that i think i've gone through everything that we need to to get started with the passport jwt user authentication strategy and like the passport local strategy that we did earlier in this series it's going to follow a pretty similar structure so just like we did in the passport local or pretty much any passport strategy we're going to need something called a verify callback so in other words when we're in our routes so say we're in our login route and we pass in a passport.authena method what that method is going to do is call the verify callback that we have defined in the passport configuration so if we open up config js it's going to be defined right here so whatever we define within these brackets is what is going to be called when we use the passport.authenticate method as with any new package let's go ahead and look at some of the documentation so the documentation for passport jwt i have it pulled up right here you could also go to strategies on the home page and click passport jwt to find it so the documentation like most strategies is not necessarily uniform all these strategies are coded by different developers so it's all based on how that developer is going to put it in there so you can see here it's a little bit jumbled up but it gives us most of what we need to know the first thing that i'll draw your attention to is going to be right here and you'll see that just like the passport local strategy the passport middleware as like a framework is going to expect the same three responses so if our callback returns some sort of error whether it be a database error or an express application error we pass in the done callback with the air parameter as the first parameter and then false for the user object then if we successfully authenticate the user we say that there's no error and here's the user object which will eventually be attached to the express request object and then finally if there is no error within our application but there's also an invalid user then we're going to say there's no error but there's also no user so these three responses to this verify callback is how passport knows what to do all right so now we got that covered let's look at some of the options that we're going to be dealing with when we're using the passport jwt strategy so as we know we're going to call passport.use and then we're going to pass in a new some sort of strategy in this case it's the jwt strategy and then that strategy is usually going to take options first and then the verify callback so those options here are going to be defined up here at the top and i will note that most of these options are related to the json web token npm library so if we open that up here's the json web token library this is actually what the passport jwt strategy is using to verify our jwt so all of the options that you see here so there's some examples here's the jwt dot verify method this is exactly what the passport jwt middleware is using and all this strategy is doing is passing in the token that it receives it's going to pass in the secret or public key so there's multiple ways that you can verify we're going to be using the public key since we're using asymmetric cryptography and then we have the options object which is literally going to be just passed straight through to this method from the passport middleware so you see down here we have all the options that we can put in here algorithms complete issuer ignore expiration all of these you'll also see well not all of them but you'll see most of them listed here in the strategy documentation now the way that we actually include these options is a little bit tricky and i actually could not based on this documentation figure out how to get all of these option passed to the verify callback so what i've done is just put together every single option that you could possibly ever need and i've put it in a single options object and then we'll kind of reduce to the only the stuff that we need going back to our code let me just paste in this like allencompassing options object and i might as i might even leave this in the final implementation just comment it out but here is the full options object if you were to pass in this obviously you need to replace some of these things with valid values but if you were to pass this in it would be readable by the passport jwt middleware so you'll see at the bottom we have the json web token options and this is where it gets a little confusing because here are some of those json web token options that we saw in that library's documentation but there are also options from json web token that are that are passed up here and if you were to pass these down in the json web token options the passport jwt middleware as it's implemented would not actually read them correctly so it's really important that you put the options i have listed here exactly how you see them if you see them in the json web token options they need to stay there so that is the entire allencompassing option object but we don't actually need that i'll go ahead and put this in the final branch of this repository but i'm going to delete it out for right now and we're only going to work on what we need the very first thing we'll do as with any module is import it so we need the passport jwt strategy and we're going to extract the strategy off that so that's going to be a class and then this extract jwt class which is basically a little subclass that is going to give you options as to how you extract the jwt from the http header if you look at the documentation online you'll see that this is detailed at the bottom so in the section extracting the jwt from the request this just has to do with that process where the server needs to know how and where that jwt is stored in the request usually it's going to be in the authorization http header but it isn't always there so this gives you some options as to where you can find this so we're going to just be using from authheader as bearer token this is probably one of the more common ways to do it but you could also pass it into like a post request body field you could put it in a url query param and if you were to do that you would use these different methods from this class you could also write your own extractor function so i know i mentioned earlier that you could put the jwt in a cookie and this right here just gives kind of that example this is how we would grab it from a cookie and so you can kind of have some freedom to implement whatever you would like so our options object is going to be pretty simple just going to replace this right here and this is what we're working with so this is the options object that we're going to need to implement the jwt strategy first is what we just talked about the extract jwt class comes with different methods for finding that jwt and parsing it so we're going to use the from auth header as bearer token so in other words it's going to expect that we have our jwt sitting like this so here's our authorization header and then we're going to say bearer and then a single space and then here is where our token is going to sit so it expects this exact syntax and if you were to maybe take the space out or just delete the bearer portion completely it's not going to be able to read it correctly you'll see how that works a little bit later the next thing is the secret or key property and you can either pass in a symmetric or key which would just be a secret that you stored in an environment variable but for us since we're using the rs256 algorithm to issue and verify jwts we're going to pass in our public key that we generated with that script right here and we're reading that from the file system it says path to key id rsa pub and the reason that we're passing in the public rather than the private is because what we're configuring right here is the verify piece of the jwt so if you remember we have the issuance and then the verification with a digital signature we sign the issuance with the private key and then we verify the identify or we verify the identity with the public key so that's why we're passing in the public key because passport is the verification step of this process then finally we're just passing in the algorithms that it will accept and we should be done with it so that's our options object obviously we didn't include half of the options that were available to us but i just wanted you to know that those were available in case you were doing something a little bit different than me like i did with the passport local strategy i'm going to kind of deconstruct this configuration so that you're not just looking at a big blob of you know callback functions and options and all that stuff so we're going to keep it as modular as possible here the first thing that we do we have our options object already configured but we need to use the well jwt strategy right here so we're going to say const strategy equals new jwt strategy all right so that is going to take two arguments one being the options object that we defined right here and two being a callback function which is going to it's already telling us what it expects so it's going to take a payload and a done callback all right so that is the basic implementation right here and then we're going to actually configure it by saying passport.use strategy so again this passport object is being provided from app.js then we're taking that object we're saying use so similar to a middleware and then we're passing in the strategy which has the options configuration in the callback function or the verify callback that we are about to implement within the callback as i mentioned with the passport local strategy the great thing about passport and also the confusing part is you don't have a specific way that you're required to verify in authentication and in our case we can use whatever database we want we can use whatever you know code logic we want to do now since we're using mongodb we'll just use the find one method on the user model so we've imported this from our database configuration so we'll just say user dot find one and then we're going to pass in the id and where are we going to get this id from well if you remember from previously in this i think is in the first video we talked about how the jwt payload so the second part of a jwt is going to have a subfield well in our case it has a subfield and in many cases it has a subfield that will include some information or unique identifier about the user in our case when we implement the register and login functions or the routes we're going to issue a jwt and we're going to place the mongodb database id in the subfield so here's our payload this is in javascript object form so we can literally just say payload dot sub and that's going to pass in the id that we need to look up our user in the database we will then use promise syntax to grab the user and then we will catch any errors that happen and if you remember we need to pass in the error to the done callback if we um and no user if there's an error within this operation so the last thing we need to do is something in this area where we have access to the user that we just looked up now if you were watching the passport local strategy you'll probably remember that in this area we were doing all sorts of stuff we were verifying um you know using a crypto function we were verifying the username and password well in this jwt strategy it is much much simpler we are just we've already validated this jwt so this strategy has already gone through the process of using the json web token library to verify the jwt that it's received so at this point when we're sitting right here we already know that our jwt is valid so all we have to do is check if we found a user in the database and if we did we need to return it to passport so that it can attach that to the request object so we'll just say if there's a user we will return done and there's no error but there is a user otherwise we're going to return done and we're going to say no air and no user excuse me this is not null this is going to expect false so passport expects to see either a user object or false so that is the implementation that we need to do for this verify callback it seems like nothing really is happening but behind the scenes the passport jwt strategy is taking these options it's grabbing that jwt from the authorization header it's validating that jwt with the json web token library then once it's validated it it passes the payload object right here then we grab the id of the user from the payload sub object look it up in the database return it to passport and then passport attaches it to the request.user object within the express framework so that is all that we needed to do to implement passport jwt now i would try this out in the browser and you know see if it's working so far but the problem is we haven't issued any jwts so we could go generate a jwt or grab an example from online and see if it would work with this but it never will because we have generated exactly zero jwts using the private key that we generated in this repository so in other words when passport jwt strategy tries to verify the jw jwt we've included in the authorization header it's going to reject absolutely everything because there is no jwt in existence right now that corresponds to this private key so when we verify it with the public key it's just going to reject it so what we need to do is write some logic in our login route so that every time a user logs in we're going to issue them a new jwt that is signed with the private key that we are using from this server then the passport jwt middleware will use the public key that resides on this server and will successfully verify these new newly issued jwts so to do this we need to come to the routes so we're in the routes users.js file and the first thing that we'll need to do is the register function so if a user is going to come to our application they obviously need to first register and basically what's going to happen in both of these routes is we're going to issue a jwt regardless so the way that this flow is going to work is if a user comes to our application and has never been there before and registers they're just going to provide their username and password then we're going to store that new user in the database and issue them a new jwt and then we're just going to consider them logged in for as long as that jwt is valid and then the login is also going to issue a new jwt but it's just going to look up the existing user in the database and validate the user the username and password that that user put in there when they registered if you watch the passport local strategy videos you're going to be very familiar with what i'm about to paste in so what we're doing here in the register function is we are taking the plain text password that the user has provided us with and we're creating a salt in a hash based on that plain text password we're just using some crypto utils so if we go in lib you'll notice that these these two functions valid password and gen password are going to be the same exact um generation and validation functions that we used with the passport local strategy and so you might ask yourself for a second well wait a second isn't this jwt isn't this a jwt strategy like why are we working with like username and passwords and all that kind of stuff well you have to remember that the jwt is simply a result of a successful user authentication with a username and password so whether you're using the passport local or passport jwt authentication you're always going to need to know how to store a password in the database and then verify it out of the database i'm not going to go through that if you wanted to really understand how this works i do have a slide on that let me just pull it up really quickly so here is the basic password validation process since i talked about it in the passport local strategy a lot just go watch that video if this doesn't make sense otherwise just read through this really quickly all right so that's basically what's happening with the password generation and verification and in the register function we're doing part one of that so we're going to create the salt in the hash and store those in the user record in the database then we'll save the user in the database and just return a success message as well as the user object now i also mentioned that we're going to be issuing a jwt here which we will do in one second but i want to first look at the function that is creating that jwt so we go to the bottom of the utils and you see that we have exported this issue jwt function which is defined here and since the passport jwt middleware is using the json web token npm library we might as well use the same library to issue the jwt so what we're doing is we're taking in the user object that we have in the database we're going to take the id of that user in the database and we are going to assign it to a variable here we are going to say that we want this jwt to expire in one day usually you'd probably do this like two weeks or something but we're just going to do one day for now and then the payload of this jwt is going to be defined as the sub property we'll have the id as we talked about when we were configuring the passport object and then the issued at will just be whatever time stamp is right now then we will sign the token and we're going to do that using the dot sign method of json web token library we're going to sign it with the private key we imported this up here at the top so here's the private key that we imported and that private key corresponds to the public key that we're going to verify later with then we're going to pass in the expires in value and algorithm that we plan to eventually verify it with and that we will sign it with so once we've signed the token we will return a token which has the bearer string at the beginning and then the sign token and then the expires in property so we have this function that's going to issue a new jwt signing it with the private key living on the server and then we're going to come back to our users routes and then in the success message we're going to attach a token and then a expires in property and to do this we just need to um well actually we're going to want to do this down here because when we initially create the user we don't have the id that was stored in the database yet so we need to come down here in the callback to get that id so we'll say the id is equal to user dot id and then we're going to issue this jwt so i think i've already included the utils library so we've got the utils library up here so we're going to say the jwt is equal to utils dot issue jwt then we're going to pass in the user and actually i don't know why i did this right here the function itself is going to grab that id off of the user object so all we have to do is pass in the user and then if you remember it returns us an object with a token and expires property so we're just going to grab the jwt dot token and jwt dot expires and there we go we have a successful response and once we have saved this user in the database after registering the front end client will get this message right here so let's do that really quickly let's run this make sure that we don't have any errors going on looks like the database connected okay and i'm going to open up postman which is just an http um request application it's got a lot of other stuff i should probably be giving it more credit than that but let's go to register i've already got the post request set up and in the body we're just going to require um i think it was just a username and password so we'll say the username will be zach we'll say zack jwt just that we can distinguish from the passport local strategy i was doing in a previous video then the password will be just one two three my default debugging password here so i think that's all that we need for this request let me just check that really quick okay so this is all we need we should be able to run this and hopefully it works um let's see what we got for the response looks like we had some issues so let's go back and see what's going on um hmm oh of course we have the wrong route that we're using i just said register it's actually going to be i think users slash register or even maybe even api slash users we'll find that out real quick come back to the code let's look at our index.js okay so we're going to okay so it's the slash users route is what we're going to need so come back to postman get rid of this api we didn't include that now we should be able to send it and we get a successful response so here's our response success is true here's the user that we stored in the database and we'll verify that in a second and then here is the token and the expires in that we issued using the utils library that we wrote all right so this is what the frontend is going to receive as a response and then they're going to take this token and store it somewhere in local storage so that it can attach it to every single request in the future implementing the login post route is a little bit more complicated but i'll post in the implementation or paste in not post i'm looking at all these post requests and what we're doing it's it's pretty simple but there's a lot of code here so we'll start at the top the first thing that we're doing is we're going to take the username that we received from the login form whatever the user typed in and we're going to look in our database for that username if we then will assume that we find the user and we populate it in this user property we'll say first if there's no user so if this user in the database doesn't exist maybe this person is trying to log in and they haven't even registered we'll just return a 401 code with a message that says could not find the user pretty simple there this next line if you watch the passport local strategy you'll understand this exactly but if you didn't what this is doing is using that valid password function so up here the validate password function and it's basically going to check okay is the username um that you just gave me and the password you just gave me are they valid so it's going to take that plain text password that the user just typed into the login form and validate it with the node.js crypto library and that function that we already defined so this is going to either be true or false based on whether the user logged in successfully and mind you this is different from the jwt remember we have not issued the jwt yet we'll just assume that they're logged out so if this is valid we know okay this is a valid user we need to give them a jwt that they can attach to all of their future requests so that they don't they don't have to log in every single time so here's our issued jwt it's exactly how we issued it down here and then we will attach that with the same exact response body that we did earlier we also probably should just put in the user property here like we did in the register route and then finally if the user did not log in successfully they gave us the wrong password or the wrong username whatever then we will return this response where it says you entered the wrong password and it's just going to be a 401 response because that is like the unauthorized http code all right and then we're going to catch any errors just put it through standard express middleware and catch it in our air handler i don't even think we have one implemented for this but that's kind of what that's going to do all right so we've got both of our routes implemented and let's come back to postman just make sure that this is going to work alright so we'll go to login and let's just copy the body that we put for the register because it should be the same so here's the user that i already have registered in our database um here's the correct password for that user let's make sure that we have the right path here and click send and we get a success is true and we get the same exact response here is our jwt that we will store in the browser at some point all right so we are done with the bulk of our work here the last thing that we need to do is just test to see if our passport jwt middleware is working correctly so far we haven't even tested the passport jwt middleware we've just be been doing the basic username and password register and login and issuing the jwt all right so coming back to vs code the way that we're going to test this is in this first route which is the protected route and we are going to pass in the passport middleware right here so we'll say passport.authenticate and then we're going to say that we want the jwt strategy and we're going to pass in an object that says session false and the reason that we do that if you're familiar with the passport local strategy that we did in previous videos we were using the passport session middleware to actually interact with the express session middleware but we're not using this here because we're using jwts so we say that that's false all right so what this is going to do is execute that verify callback so this function right here and if we successfully validate the jwt that has attached the request it should let us into this route so we should be able to print something let's see if we can get in here all right so we'll just say res.status200.json.com will stay consistent here is true message is going to be you are authorized we are now ready to test this out so let's go to pat to postman and we'll come over to the protected route again we need to put in that path and here's where the magic comes in but also kind of gets really confusing we have to attach the jwt that this user owns to the authorization header now in postman you have the option to put it here in the authorization tab you could just do bearer token and you put the token here but we're not going to do that we're just going to stick with basic http headers to keep things simple so we're going to use the authorization header and then the value that we will pass in is that token that we received over when we registered or logged in so we just logged in so we're going to take this entire token including the bearer portion and we're going to copy that into the value right here so this value because it's in the authorization header and because it says bearer with the space and then the token which is exactly what the passport jwt middleware is expecting that middleware is going to take this value it's going to run it through the verification function using the json web token library and hopefully authenticate us correctly so we're just doing the get request let's send it and it says success true you are authorized so in this case we just copied in the bearer token here the jwt in postman but obviously if you're implant implementing an application you're going to do this on your front end client so for example angular and you're going to want a way to you you'll probably store it in local storage after you've been issued this and then you will write some sort of logic to attach it to every request but that's not the purpose of this video this video is just to show you how to configure the passport jwt strategy so if you wanted to watch that that'll be probably the one of the next videos or something like that but the last thing i wanted to do in this video is just kind of a quick recap to show you exactly how you're going to be using this alright so every time every route that you want to protect using jwt authentication you're going to use this syntax right here if you wanted to simplify it even further you could probably write write yourself a middleware that just calls this method and then you only have to pass in like a couple letters but if you wanted to you can pass in this exact syntax every single time now this is very different from the passport local strategy because if you remember when we did that if you watched that video we only called the passport.authenticate method one time and we called it in the login post route and then after that what we were doing to check whether this user was authenticated was saying if request.session.passport.user exist or i think we had a shorthand method if request dot is authenticated that's how we were validating whether a user was logged in but since jwts are by default stateless we're not using sessions we have to call this every single time so that the passport middleware can you know grab the jwt that's included in the request and verify it so it's pretty simple actually this all you're going to be using attach it to every request that you want to authenticate and you could even come over to your passport verification and have some sort of different logics you could say in this part of the body you could say if user.admin if you wanted to validate like an admin property or something you can get pretty creative with it but that is the basics of using the passport jwt strategy i just want to take a few moments to say congratulations if you've made it to this point the remainder of the video is completely optional for you you can fully say that you understand the basics of user authentication in node.js express and passport.js if this video has connected the dots for you in one way or another i'd really appreciate if you went and checked out my channel um much smaller channel than the one that i'm on right here but i make a lot of web dev related videos and post on a weekly basis at least at this point so go check it out subscribe like a video that would be extremely helpful to me and i'd really appreciate it alright the last part of this video as i said is completely optional and we're going to be covering two things number one we're going to be covering how do we actually take passport js out of the equation with the jwt strategy believe it or not the passport jwt strategy is just using the json web token library under the hood and we can do the same thing well passport js has a lot of strategies that really alleviate a lot of the work that you would have to do and i'd highly recommend using them the jwt strategy is a little bit unique in the fact that i don't think that the passport jwt strategy adds a whole lot of incremental value to you now that is of course if you understand what you're doing and since we just talked for many many hours to learn how all of this works and we actually do know what we're doing we can implement our own jwt strategy pretty easily and then in the final part of this video we're going to walk through the basic implementation of a jwt strategy with angular on the front end now of course this will not apply to all people not everyone is an angular developer or has an interest in that but i did want to tack it on to the end in case you are working within the angular framework and are confused how do you take all these concepts and translate it to you know the front end and use local storage to keep your users logged in and communicate with the backend that we just wrote all right let's go ahead and first jump into how do we write our own custom jwt authentication strategy so what you see on the screen here is our application it looks a little bit different got a slightly different environment as i'm recording this video which is kind of recorded a separate time as an addition to this course so everything is the same though don't worry about that let's go ahead and open up postman just so that i can prove that out to you so if we go to the register route we'll put in another test user and we'll send that request and it's not going to work because we're not actually running the server at the moment so let's go ahead and run the server try that again and we should get a successful creation of the user now let's copy these same credentials oops we'll copy the same credentials into the login right here click send and we should get a bearer token let's copy that bearer token go to our protected route and drop that into the authorization header value click send and it says you are successfully successfully authenticated to the route so as you can see it's the same exact thing nothing has changed but what i want to do now is close out of here and i want to create a new branch so we're going to create a new branch called custom jwt and what we're going to do on this branch is we're going to completely rip out the passport js implementation and add in our custom jwt implementation you might think that sounds really difficult but it's actually not and although there is a really good use case for passport passport as a middleware and framework such as the local strategy and a lot of the delegated authentication such as you know the social logins truthfully the passport jwt strategy does not really do a whole lot of heavy lifting for us quite honestly i prefer to do my own custom implementation when working with jwt so the most obvious place to start is going to be in the passport.js file where our implementation sits let's take a look at what we might have to change so the first thing that i see in the options is that we have this method called extract jwt from auth header as bearer token so we need to be able to take the off authorization http header and grab the correct token and parse it in our code as i mentioned earlier passport js is doing that for us so we don't have to do it on our own but as we're ripping passport out right here we're gonna have to write a custom function to do this furthermore in the main implementation this is just a middleware so we're just going to replace that with our own custom middleware function that's all it really is is just a function and we're basically going to verify the jwt that is passed through the request and then you know either authorize or deny access to that given route and then that's going to play out once we go to the routes over here where you see in the protected route we're using this passport.authenticate method we're just going to replace that with our custom middleware function that we're about to create so just to start us off let's go ahead and and start removing some things so let's comment out the passport declaration up here and let's also remove the authenticate method right here and see how that changes everything for us so we should still be able to start the application and then go over to postman go to the protected route and we can uncheck this authorization and click send and it says you are successfully authenticated now that's obviously not true because what we did was just remove the middleware that's authenticating us so we need to replace this with some other middleware and we're just going to throw this in the utils file because we've already got this being imported so let's open up utils and you can see we have a lot of our helper methods in here and what we can do is actually create our authentication middleware as well so let's go ahead and create a new function and we'll say this function will be called off middleware something like that and what we need to pass in as with any middleware is going to be the request object the response object and next and then of course we're going to create that as a function so we'll drop it down here by default let's go ahead and just send a 401 unauthorized error so the 401 http status code is for unauthorized and if we were to um let's save this go back to our users right here and add back in the passport authenticate method and then uncomment or yeah uncomment the passport import this is going to put us back to where we were and if we go to this protected route and we've got the authorization removed and click send we should get this unauthorized response and if we click through this let's see we can look at the headers and it says the status is 401 unauthorized and then it explains that error similar to 403 forbidden but specifically used for when authentication is possible but has failed or not yet been provided so that's a good just overview of the 401 error and we can also see that we're doing this in the res dot status right here uh in the login route so we're already a little bit familiar with this but by default we're going to make this off middleware just send that 401 and maybe we can even stay consistent with our login so instead of just sending it we'll say res.status and then give it a payload or a response body so we'll say res.status is 401 the success is false and the message is going to say you are not authorized to visit this route from this point let's go ahead and copy one of these down and replace our export so that we have the off middleware export so that's going to export it from this file and now we can actually use it over in users.js so we've got this import already so let's let's comment out passport again just that we're not we're not importing that anymore and we can we can go ahead and delete that because we're not going to toggle that back on yet or anymore so we'll go to utils.off middleware and that's really all you have to pass in you don't have to pass in any you know parameters or arguments or anything so let's go back to postman and try out our protected route so let's click send and see what the response is we get a success false you're not authorized to visit this route and the reason we're getting that is because when we run this route instead of getting what's in the body of the route we're passing through this off middleware that we just created and it's by default giving us an unauthorized status but that of course is not what we are wanting to do here we're wanting to get the jwt that was passed into the request and then pull out the token from that and validate that token using the json web token library because after all that's all that passport jwt is doing in the end what i have pulled up here is actually the passport jwt strategy implementation and you'll see that on the verify jwt this is all that's happening you're just using the json web token library to verify the token itself so that's not going to be all that difficult for us to do and then furthermore we have the extract jwt which is going to be if we come back here go to passport and see this method right here so the from off header as bearer token so if we were to go to that same repository we can go to the um off header or no the yeah the offheader.js which is going to have a parse offheader method which is going to basically call the extract jwt and then this has a bunch of different ways that we can do this depending on what our header looks like but in our case it's from auth header as bearer token as we saw right here and what that's doing is calling another method which has some utility functions so on and so forth so that's not all that difficult to implement either let's go ahead and see what that request header looks like so if we were to drop into the off middleware in console.log the request and then i believe we can just say the request.header if i'm remembering this correctly and then we came over to postman and we went to the headers turned back the authorization header and click send and then we'll see something printed here so maybe i did not uh print this correctly so i'm printing a function not the actual header so i think i have to say request.headers maybe instead so let's go back send this request again and now we're getting something a little bit better so we're seeing our header printed out now let's go back to postman and instead of this authorization header let's go ahead and copy the token itself and turn this one off and then go to authorization and click bearer auth so if we copy in this token and click send we should still get the same header so we we're always going to get this authorization property and that's kind of what it means when we're looking at the passport implementation and it says that we need to extract jwt from the auth header as bearer token that is us telling the passport library hey we expect this certain format so parse it accordingly so that's basically what we're saying is we always expect this exact format to be passed in and in our utility method we're going to have to take that into account so the next question is how do we actually parse through this token well we can actually split the token because as you see in the format down here there is no spaces other than between the bearer and the token itself so if we have a valid bearer token we can just split it with a javascript method so let's go ahead and make a variable called token parts and then what we're going to do is we're going to say request.headers.split and we're going to split it by a single space now if we console.log the token parts instead of just the entire header you're going to see something that we can work with a little bit easier so let's go ahead and remove this we'll go back to no off because i think it's a little bit more straightforward when we're just passing in the authorization header and let's go ahead and click send and it looks like we got some issues here it says request.headers.split is not a function and that is of course because i'm not thinking at all trying to talk and teach and code all at the same time it's a little bit difficult sometimes i don't want to split the headers i want to split the headers.authorization property let's try that that might work a little bit better and this time we should get an array so our array has the bearer and the token keywords and then from here we basically need to check to make sure that this is the correct format because what if what if we get something that's incorrectly formatted passed as an authorization key that would obviously be invalid so what we're going to do here is we're going to say if the token parts 0 is equal to the word bearer which is what we would expect and the token parts number one so the first index which would be the actual token if that matches a certain regular expression then it's going to be valid in that regular expression as we learned with the jwt portion of this course is always going to be a series of characters with a period and then another series of characters with another period somewhere here if i can track it down and find it so right here is the second period and then some more characters to follow so the way that we can validate that is with a regular expression that basically just looks like characters period characters period more characters if it doesn't follow that format then it's invalid we don't want to let the user into the route so we can actually use the string matching function and we can pass in a regular expression that i've already written so this course is not about regular expressions so you're just going to have to take my word on this this right here is going to basically say look at the string that we've got down here and ask you know whether it fits that format of characters dot characters dot characters and if it is then it's not going to equal a value of null so if it does match then it's going to give you a results array if it does not match it will return null so if we check and make sure that that does not return null then we know that we have a valid jwt format so we're basically saying if we make it into the body of this if statement then our token is valid we are now ready to actually write the verification portion of this with the json web token library now we've only imported our private key up here but we also need to import the public key in order to validate this so remember we sign it with the private key and we verify it with the public key so that's the order we're going in so let's go ahead and copy this down and we're going to grab instead of the private key we're going to grab the public key and then we're going to change the variable name copy this down change private key to public key and update the variable here let's make sure that we're getting that correctly first so if we get here and we have a valid token which we should we should be able to console.log the public key constant variable so we restarted let's try to visit the protected route and you can see that we're getting that public key printed out just fine so that's working now we just have to implement the json web token verify method that it comes prebuilt with so if you were to go to the json web token documentation on npm and search for the jwt dot verify method you can see that it takes in a token which is going to be the jwt a secret or public key so that will be our public key and then of course we have some options and a optional callback function you can read through this but i'm going to go back and just implement it and show you exactly how to use it so we've got the imported json web token library and all we need to do is come down in here and say let's say verification variable equals json web token dot verify now it's going to ask us for a token which we're going to give it the token parts at index 1 which is the actual token we're then going to pass in the public key and then in the options it asks us whether we want to supply an algorithm so if i were to go back to this documentation we have an options and algorithms which is a list of strings with the names of the allowed algorithms for example hs256 blah blah blah so all we have to do is pass in the algorithms and then in the array we need to pass in rs 256 and you might ask how did i decide on that algorithm well if you remember from the passport.js file where we were given the options to the passport middleware we were basically saying i want to extract it as a bearer token which we did here in these lines right here then what we said is i want it to be using the public key so we passed in the actual public key just as we did right here and then finally we said that we wanted the rs256 algorithm which is basically the public private key pair or asymmetric cryptography so that's what we're doing here in the algorithms section so we're basically giving it the same options we're just doing it more directly so let's go ahead and console.log the verification and see what we're getting so let's go back to our postman if i can get there and click send so we sent the request we'll come back here and we're getting this value right here which is going to basically be an invalid value if it was not successful or will get this object if it was successful so let's go ahead and manually put in the wrong key to see what happens if it's not so we'll just remove this first e at the beginning of the bearer token and click send and now we're going to go back to our library here and it's going to say json web token air invalid token as you can see here this has thrown us an air and we don't want that in our application we want to handle all of our errors and if we were to go back to our documentation here for this method it's going to give us an asynchronous way to do it and a synchronous way to do it let me just get rid of this search so we don't see that and for the synchronous method it says if a callback is not supplied function acts synchronously returns the payload decoded if the signature is valid and optional expiration audience or issue issuer are valid if not it will throw the air so that's basically telling us that we need to handle an error if we're doing it synchronously which is how i want to do it here just to stay simple so we can use the builtin try catch block so we'll say try catch and then pass in the air and if we go ahead and run this method right here if i can copy it correctly if we run that right there it should pass and if it if it does not pass it will throw an error and at that point we can console.log the error just to see what we're dealing with so let's go ahead and see if we can verify it so basically if we don't make it to the error state then we know it was successful so we've reconnected let's send the request with an invalid request and you'll see that we have printed out the air now so it looks like it through the air but we're actually just printing it and handling it gracefully so based on this all we need to do now we've just kind of tested everything out let's get rid of this console log statement let's also not print a variable that we don't have anymore that's a problem and then we'll come down into the catch block and if we have an error that's where we're going to put this status of 401 so as of right now if it was successful it's not going to do anything it's not going to return anything if it's unsuccessful we're going to get this message right here so if we go back to postman we should expect to get the you are not authorized to visit this route message which is what just happened so that's working great and now what we need to do let's go ahead and assign this to a verification variable once again and now what we're going to do is pass the next callback in here so we'll just say next and that's going to pass us through to the next route at this point what we could do is we've got this verification stored and let's go ahead and console.log it one more time just to see what we're dealing with and at this point i need to add back in that uh e character that i just manually removed from this token so now it should be valid and when we send the request we're not going to get any response yet because we haven't done anything here but in the terminal if we scroll to the bottom we should get this little block of code which is some useful expiration date of the jwt token which we can then use on the front end to you know set expires headers or expires in local storage and stuff so it would be helpful to pass this along so all i'm going to do is say on the request object i'm going to going to assign the jwt equal to the verification and then i'm going to say next to pass it to the next middleware in the chain so at this point we're passing it to the next middleware in the chain and now we have this jwt property so we're going to drop into this route and now we should be able to console.log the request.jwt and if we console.log that successfully then we know that it was a successful verification and we should see the same object being printed despite the fact that we're not printing it in our middleware anymore let's go back to postman click send and it says you're successfully authenticated which is good good news and you'll also see this jwt that we had attached to the request object so believe it or not we are done ripping out passport.js and implementing our own strategy so if we were to come to the passport.js file and just click delete on this whole thing we should still be able to run our app so let's start it it's going to crash because we're currently importing that into app.js so if you remember we're configuring passport right here and do we do anything else yeah we're importing passport up at the top just want to make sure we're not using it anywhere else let's save that and see what else looks like i missed one so on line 22 here's the initialization call we'll delete that out click save and it looks like we're compiling correctly now we've deleted passport entirely i don't think that we have any other references to passport let's go ahead and check so that's just in the package json and then the readme so we're looking good we have no more references to the passport library in our code and now we should be able to go through the entire flow that we went through previously with our custom strategy so let's go ahead and try it we'll start with the register route we'll put in a new user click send we've created the new user we will update our login route to log in our new user we'll click send there we've just been issued a new bearer token and then we'll come to the protected route copy in the bearer token and click send and it says you're successfully authenticated if we you know delete some stuff here and pass in an invalid bearer token and click send it's sending the request and not returning anything for some reason and i've actually got an error in my code that i forgot to account for because it's not returning a request so the reason that's happening is because remember we're verifying whether this is a valid token in the first place and only if it's a valid token are we trying the verification so we need to provide an else statement to catch any time where the the actual syntax of the bearer token is wrong and we'll return the same unauthorized status if that's the case so now if we come back and click send we should get an unauthorized response so i'm glad i caught that but basically that's just a demonstration of how we implement our own custom jwt strategy and it's what i use in a lot of my apps for when i'm just getting started and you know providing a basic authentication strategy once again you can check out the github repository associated with this course and go to the custom jwt branch to see the code that i just worked on and last but not least let's go through how do we implement this jwt strategy on the front end and sync it up with all the code that we've written on the back end in express today we're going to be talking about how do we take the passport jwt strategy that we implemented in our express application and kind of port that into a frontend that will handle the jwt and attach it to each of our http requests so we're going to do this with angular and the reason being is because i for one know angular better than most of the frontend frameworks and number two it is very compatible with jwts now if you were to um let's say make an express app and you used ejs as a templating language and that's how you built your front end now in that case sure you could you know somehow implement a jwt front end but it's going to be a little bit more difficult because the pages that we would be loading on the front end are going to be coming straight from the server well as in an angular application it's an spa or single page application which means everything happens in the browser so that includes the um the jwt stuff and so it's just very compatible for what we're doing here like i said in previous videos the goal of this one is not to teach you how to write an angular app so i'm assuming that you already know kind of the basics of angular we're not going to do anything too crazy but i'm not going to be walking you through the structure of how angular works and all that good stuff the goal here is to show you exactly how we take our express server that is issuing us jwts and translate that into the front end so to do that i want to first walk you through what i've already provided you with in the previous video i introduced the github repository it'll also be in the description here and when you download the repository on the master branch you're going to have a blank template we implemented the first part of that template in the express application in the last video and then the second part of the template is what we're going to be doing in this video and that is sitting in the angular directory and if we open up the main part of this application you'll see several folders already built for you and they're all connected up so this app kind of runs already even though we haven't implemented the actual methods so i'll walk you through it real quick let's start an app.module let's see what we've got here so i've already set up the routes for us so if we visit login register and protected it's going to load the login register and protected components so that's already set up for us in angular kind of gets that out of the way we are declaring those components here let's see here's the router module and this is important we have to implement the use hash option because we have our api from the express application and then we have the routes from the angular application and we don't want those to conflict now down here i kind of debated whether i was going to put this in here but this is the setup for our http interceptors and that is something that we're going to actually implement but i've left the the structure of it intact and it's already included in the main module so you don't have to worry about doing that but this right here is a very special syntax you're probably not used to seeing it if you don't work in angular a lot so that's the app module which is the base of the application app component just has three links so that you can load each of the routes and then i actually put the routes below so we're pretty much staying on one page the whole time and just toggling between the routes by clicking these buttons up here i can go ahead and run this just so we can see what that looks like i don't think we should get any errors so it loaded successfully let's visit in the browser and you can see that our application is very far from beautiful the goal here is not to style it up or anything we just want the functionality so as i said if you click each of these routes they're going to display below so right now we're at the home route so nothing is being displayed but if we click login you'll see a little ugly login form if we click register you'll get the register form and then the protected route is just going to give us a message and in this case we don't get a message because we're not authenticated so that's kind of the the entirety of this application obviously it's not something that you would show to any user but it does give you the setup and the the logic behind how you would start an application okay so let's come back to the code walk through a couple more things that we've got set up and i'll kind of show you what we're going to be doing in this video so the first thing we've got is the off service this is a service that we're going to be spending a good amount of time in as you can see we've got five different methods that we need to implement in order to kind of manage that jwt that was issued from the express server next up we have an auth interceptor which we have to implement the intercept method for this what this is going to do basically is take each http request and it's going to attach the jwt to it so this is kind of the magic behind the scenes then of course we have each of our components so the login protected and registered components let's see what i have implemented here we we basically just have the form functionality implemented so we don't have to walk through that logic so you see here we have a register form then when we submit the register form it's going to call this method which sits right here and in this on register submit we're just going to take the username and password we're going to make a post request to our express application which is on localhost 3000 and then we're going to get a response and if it's successful then we're going to navigate back to the login so don't worry too much about what's going on here this is basically just making the request to get the jwt from the express server and then same with the login you're going to see something very similar you have a form here you have a method on submit and that method is going to make a post request to the login route of the express application so go ahead i know i didn't cover absolutely everything so go ahead on your own time and just pause the video and take a look through this angular app just get familiar enough with it and then we will get into actually implementing the jwt um strategy here i think the first thing that we should do is implement this service called off service now this is going to manage how we store and retrieve the jwt token or jwt that we have been issued from the express server before we do that though let's go and quickly review what we're getting from the express server so if you remember from the last video when we register a new user let me go ahead and register a new user real quick we send that oh and it's not going to work because the express app is not running yet so we need to first run the express app okay express app is running we can go back and actually let's how do we cancel this request um cancel all right so let's send it one more time this time we should get success true and here is our jwt so this is how we're getting information from the express server and then if i wanted to log in with that same exact user i could do that with the login route and it's going to give me the same exact data so this is the data that the angular application expects and once we get that data we're going to basically take this token and put it into local storage so that is what this auth service is doing it's basically saying okay once we get the response we want to set local storage then the logout method will basically delete stuff from local storage so on and so forth to help us out and kind of keep things straight um in our heads i'm going to copy in this response that we get from um the express application when we register or log in a user so i'm going to put this here and just comment it out so that we have a representation of what we are expecting to receive and this when we implement this first method here the response object should be this right here so the first thing that we need to do in the set local storage this is going to be when we receive our jwt and we need to put it in local storage so the first thing that we need to do is actually figure out when this jwt expires so in the response body up here we're going to get a value of one day to make things a little bit easier and not have to deal with javascript dates and stuff we're going to use a library called moment.js which is here's the documentation for that and it's pretty simple to be honest moment is the main function gives you the current moment and then you can do whatever you want with it you can format it here's like the live on the right side here is like the live updates to these pieces of code you can also do things like add certain amount of days so this is what we're going to be doing we're just going to be doing moment.add and then pass in that 1d which represents one day so come back to the angular application we're going to just store let's say expires equals moment dot add and then we're going to say the response object dot expires in alright so we've got the response object right here and then the expires in property so basically this right here equals 1d and if we add that to the current moment that's going to give us the time that this jwt expires after we've figured out when this jwt expires we need to set two things into local storage to do that we can just say local storage dot set item and this set item method is going to take two values so first is the name of or first is the key and second is the value so we'll say token is the key and then the value of that if we look up in the object that we should be getting here it's going to be dot token so we will say response object dot token and if you remember that token is has the bearer included so just keep that in mind as we go forward local storage dot set item and expires so that's going to be our second one and that is going to be the response object as well but we actually have to do a few things to this or excuse me this is not on the response object it is what we just set right here so we need to pass in expires and then we need to do a few things to it so first we need to get the value of this so this is just a javascript method that's going to take the primitive value of a string object and then we will say json.stringify and pass in that value so nothing too special going on here it's literally just to get us in the correct format and that's pretty much it for the set local storage method so we'll receive this object when we log in or register and then angular is going to take that object pass it into set local storage we'll see where this is actually used a little bit later but it's going to take that response object and set these two items in local storage now to log out we're just going to remove those two items so we can say localstorage.remove item and we just pass in the name of the item that we want to remove so once we remove these items from local storage when angular checks to see whether they exist it won't find them and it will make the user log in again so that's kind of what is going on here the next thing that we're going to do is this get expiration method and that is because this method is going to be required to see if a user is logged in now if we issue a jwt to a user then that means from um that the express application has already done all of the crypto cryptographic logic to decide whether the user is actually valid so if the angular application receives this response then we know that they are pretty much logged in so all we have to do is check whether the jwt is expired and if it is expired we need to delete it from local storage otherwise we can consider this user to be logged in so to grab that expires from the local storage we're just going to paste in a few lines here so first we're going to get the item it's not expires at it should be expires as we set it up here and then we're going to figure out um the so json parse is going to take the json our object and make it a javascript object this last return value is just going to calculate using the moment library it's going to just calculate the point in time which this jwt actually expires and then we'll come up in the is logged in route or not route but function and we're going to take this value the expiration value and see if the current time is before or after it to do that we just say return moment dot is before this is just a method that we have available to us and then we're going to pass in this dot get expiration which will return us the moment that this jwt expires and if it returns true then that means that the jwt is still valid and we should still be logged in then the last method here is just going to return the opposite of this dot is logged in pretty simple now that we've implemented this off service let's go ahead and see it in action before we do that i want to remind you what is happening when we register a user using the register component when the user presses submit on the register form this post request is going to be sent out to our express application which is running over here which will return that big object that we were talking about and looked at and then once we receive that response object we're going to pass it into the set local storage method which will set our token and expires properties in local storage let's test this out go to google chrome right now if i refresh the page you'll see that in the application we don't have anything in local storage for this application now let's go to the register route and let's put in something like jwt test and then a password of one two three and when we click register we should be redirected to the login route and you'll see that these two the token and the expires has been set to the local storage we also will console log the user object that we got back from the express server just to see that it was successful at this point we actually don't even need to log in necessarily because we've got these things set in the local storage but why don't we just go and do it jwt test one two three and then we're going to be redirected to the protected route but it says you are not authorized to visit this route no data is displayed and the reason being is because we have not yet implemented our interceptor which is going to take the jwt that is sitting right here in local storage and append it to every http request that we make in our express applica or our angular application in other words we need to find a way to when we click visit protected route while there is a token that is valid in local storage to get it to actually work looking at the protected component you can see that what this is doing when we click visit that route so ng on init so when this component is loaded the first thing that it will do is make a get request to this link right here which on our express application as you saw in the last video is only going to allow users to receive the correct data if they are authenticated with a jwt that the express server deems as valid right here is the protected route and if we are not authenticating correctly if our if we don't have a jwt attached to this get request or the jwt is invalid we should receive a 401 unauthorized error if we are valid then we should receive this message right here so here's the message you are authorized okay so let's close this out go back to the protected component and you'll see that if we get a response we're going to print the message attached that response so we should see what we were just looking at in the express application if it was successful but if we have an error which is going to be a status of 401 or unauthorized the message is going to be you are not authorized to visit this route and we saw that earlier in the browser so let's go solve the last piece of the puzzle open up the auth interceptor which right now is empty i'm going to paste in the implementation here and then we're going to walk through it so let me indent this correctly okay so again this is not an angular tutorial you're going to have to read up on interceptors which you can find on their documentation it gives you a lot of examples but basically what this is doing is kind of intercepting every http request that angular is sending out and it's going to attach or it's going to run the intercept method so what we're doing here is first we're grabbing this should not be id token should be just token we're grabbing the token from local storage and then if there is an id token so if we get a token from local storage then so far we're good what we're going to do is clone the request so we're taking the current request that is going through the chain of interceptors it's kind of like middleware and express almost and we're going to take that and clone it but this time we're going to set the authorization header equal to the id token so that should set authorate authorization header equal to bearer and then a space and then the jwt then we say return next dot handle and pass in that cloned object so that should basically right here that should successfully attach the jwt if we don't find a token which is very possible if the user is not logged in then we just return next.handle the request and there's going to be no authorization header whatsoever we now have an auth interceptor which should attach this jwt token to our request now if we go to the browser to our application technically if we visit this protected route right now it should say that we are authorized because you remember we already logged in and you'll see that we have the token and the expires already in the browser so as long as we attach this to our next request it should authenticate us so let's try that if you remember from the last request there was no author authorization header but now if we visit the protected route it says you are authorized and if we go to the network tab this is a little bit tricky you're probably tempted to click on localhost but we need to click on protected and you'll see that down in the request headers there is this authorization header which has the jwt that we had stored in local storage so that is the basic flow and you can use this concept to basically manage your users within an angular application and obviously there could be users with different types of permissions and that would require you to come back to your interceptor and write in some custom logic to say okay hey based on what role this user has are we going to attach you know the jwt or not and also you might be you might have routes on the express application that may or may not require authentication but hopefully this implementation so the combination of this auth interceptor and the off service hopefully those two things along with the previous video where we talked about how do we actually issue that jwt have brought your understanding of user authentication um you know to a conclusion and hopefully this all makes sense this is just one way that we can implement user authentication in our front end or angular app you're going to see a lot of different implementations across a lot of different coding languages the most important thing is to understand how everything works how does the jwt work and how are we supposed to kind of pass it from the front end to the back end once you understand that it should be a breeze to implement your own authentication strategy you never thought that we'd make it to this point but we're here we're at the end of this super long user authentication crash course and i want to say a big thank you if you watched all the way through that's really an accomplishment to get through you know however many hours this took us to understand all these concepts and if you are one of those crazy people that went from the very beginning of this uh course all the way to the end here and didn't skip anything i'd love to hear from you i'm on twitter at zg underscore dev and i'd really love to hear from you so reach out tell me what you thought about this course or just say hi once again i'd really appreciate if you checked out my much smaller youtube channel and just gave it a look and until next time i will see you later
