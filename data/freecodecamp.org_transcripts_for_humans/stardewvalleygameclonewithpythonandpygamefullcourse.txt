With timestamps:

00:00 - what better way to improve your python
00:02 - and pygame skills than by building a
00:04 - clone of stardew valley christian from
00:07 - clear code makes amazing python game
00:10 - tutorials and in this course he will
00:12 - teach you how to build a clone of this
00:13 - popular game
00:20 - [Music]
00:32 - in this tutorial we will create a stadio
00:34 - valley style game in python and this is
00:37 - going to have a ton of stuff like
00:39 - farming and foraging we can cut down
00:41 - trees and trade items there's also a day
00:43 - and night cycle and different kinds of
00:45 - weather
00:46 - the entire game was also made entirely
00:48 - so you can expand it yourself
00:51 - speaking of i am using the free version
00:53 - of the sproutland asset pack by cup
00:55 - noodle
00:56 - which is amazing there's also a paid
00:59 - version with more stuff if you want to
01:00 - expand the game yourself although for
01:02 - this video you don't need to spend any
01:04 - money
01:05 - before i start i do want to emphasize
01:07 - that this is not a beginner's tutorial
01:10 - to be able to follow you will need to
01:12 - have a good understanding of pygame if
01:15 - you want an introduction or reminder i
01:17 - would recommend my introduction to
01:19 - pygame and my video on using delta time
01:22 - if you have those two you should have a
01:24 - really solid foundation during the video
01:27 - i will also mention a couple of videos
01:28 - that explain some more advanced topics
01:30 - in detail those can be helpful but you
01:33 - are not going to need them to follow
01:34 - along
01:35 - alternatively i also have a paid course
01:37 - where you learn all of my game by making
01:39 - 4 pretty cool games check this one out
01:42 - if you are interested and sorry about
01:44 - the requirements but if i did this
01:46 - tutorial from scratch it would easily be
01:48 - 20 hours long
01:50 - finally the entire project is inside of
01:52 - one folder and i will be working in the
01:55 - code subfolder
01:56 - i will explain while coding when and how
01:58 - to access elements in here i also saved
02:01 - the progress for every chapter and you
02:03 - can find that on github
02:05 - and with all of that i hope you enjoy
02:08 - alrighty so let's get started and i
02:11 - already have a couple of lines of code
02:13 - ready just to get started let's have a
02:15 - look at those here i have my code and i
02:18 - have main.pi and i have settings.pi both
02:22 - already have quite a bit and i am
02:25 - working in main.pi for now
02:27 - if i execute the code with all of this
02:29 - i can see a black window that doesn't do
02:32 - anything right now but we do have a
02:33 - start
02:35 - and all of the stuff in settings we are
02:37 - going to use later but well for now
02:40 - don't worry about it besides these two
02:42 - lines here
02:44 - those determine the width and the height
02:45 - of our window
02:47 - now if you have a very small or very
02:49 - large monitor
02:51 - you could change these numbers to
02:52 - something else whatever is appropriate
02:54 - for you the rest of the game is going to
02:56 - scale with that
02:58 - at least within reason don't make it 5x5
03:00 - pixels that would be a weird game
03:03 - and i guess really quick let's go over
03:05 - what we have
03:07 - all the way at the top we are importing
03:09 - pie game and cis and settings
03:11 - pie games should be obvious but since we
03:13 - need all the way down here to close the
03:16 - game properly other than that we are not
03:18 - using it
03:19 - after the imports we are creating a
03:21 - class called game inside of that we have
03:24 - an init and a run method
03:27 - most of the game is going to run inside
03:29 - of the run method in here we have the
03:31 - game loop and this one is checking right
03:34 - now if we are closing the game here and
03:36 - then we are getting delta time and we
03:38 - are updating the game
03:40 - besides that in the init method we are
03:43 - creating a display surface we are
03:45 - creating a clock and we are also
03:47 - initiating pygame so all things
03:49 - considered a very simple class
03:52 - and finally all the way at the end we
03:55 - are checking if we are in the main file
03:57 - then we are creating an object from the
03:59 - class and then we are calling the run
04:01 - method
04:02 - and this run method contains the loop
04:04 - that contains our game
04:06 - so with that we have the main setup
04:08 - although there's one more change that i
04:10 - would like to make and that is if i run
04:13 - the game again
04:14 - in the top left we have a window title
04:17 - and right now it says pygame window
04:19 - which doesn't feel good so i want to
04:22 - change that one and this could be a
04:25 - really good exercise for you what i want
04:27 - you guys to do is to change the title of
04:29 - the window and if you want to code along
04:32 - pause the video now and try to figure
04:33 - this one out yourself
04:38 - after we are creating the display
04:39 - surface we have to call pygame dot
04:42 - display dot set underscore caption
04:46 - and in there we can type in the name
04:49 - in my case i want to name the game
04:51 - sprout land
04:53 - after the asset pack
04:55 - although you could name it whatever you
04:56 - want and if you run out of this now you
04:59 - can see in the top left we have
05:00 - sproutland this feels much better
05:03 - although granted a very small change
05:06 - but all right with that we have our
05:09 - setup now if none of the things i've
05:11 - just talked about make any sense check
05:14 - out my introduction to pygame this one
05:16 - is going to explain all of this in much
05:17 - more detail and if you are lost already
05:20 - the rest of the tutorial is just going
05:22 - to get harder so definitely get ready
05:25 - for it
05:26 - now there is one more thing that we do
05:29 - have to start thinking about because
05:31 - later on the game is going to become
05:33 - quite complex and i want to keep the
05:36 - basic main.pie as clean as possible it
05:39 - shouldn't really do too much
05:41 - as a consequence inside of this while
05:43 - loop i want to run another object and
05:46 - this object actually contains the level
05:48 - let me actually implement it and then
05:50 - you see in a second what i mean
05:52 - basically what i want to do is i want to
05:54 - create a new file and this one i want to
05:56 - save as level dot
05:59 - pi
06:00 - for this level i want to import pi game
06:04 - and from
06:05 - settings import everything
06:09 - and this level is going to be a class so
06:12 - class
06:13 - level
06:14 - and this class level is going to have
06:16 - one method that i'm going to call run
06:18 - this one itself and delta time because
06:21 - we need delta time available inside of
06:23 - our game to make everything frame rate
06:25 - independent
06:27 - and inside of this i want to for now
06:30 - just print run game
06:32 - and this is all we need
06:34 - in main.pi
06:36 - i want to from level import level
06:41 - and inside of the init method of the
06:43 - class i want to create an attribute
06:46 - level that is going to be the level
06:50 - and now inside of my run method of the
06:53 - game
06:55 - before i update the display i want
06:58 - self.level.run
07:01 - that way we are always calling this run
07:04 - method here
07:05 - although don't forget this one needs
07:07 - delta time the one we have gotten here
07:11 - if you don't know what delta time is
07:14 - it's a bit more technical but i've made
07:17 - a whole video on it so check this one
07:18 - out you basically are going to need it
07:20 - to follow along for this video so well
07:23 - it is getting quite complex
07:25 - unfortunately there's no way around it
07:29 - if i run all of this now
07:31 - we can see run game in the bottom left
07:34 - so we are continuously updating
07:36 - this method here and this means we can
07:38 - run the entire game inside of it
07:42 - which is helping considerably to keep
07:44 - the entire game clean and organized and
07:47 - for a project of this size this is
07:49 - really important
07:52 - now before i'm finishing this section
07:53 - there are a couple more things that i do
07:55 - want to do first of all when we are
07:58 - creating this class i want to run a
08:00 - dunder init method
08:03 - and in here first of all i want to
08:05 - create another attribute for the display
08:09 - surface
08:10 - in this one i'm getting with
08:12 - pygame.display.get
08:14 - underscore surface
08:17 - this display surface is the same as this
08:20 - self.screen here
08:22 - and this allows the level to draw
08:26 - straight on the main display that we are
08:27 - going to display to the player which
08:30 - makes organizing the entire thing much
08:32 - easier
08:33 - and let me add comments here to make all
08:35 - of this a bit easier to follow let's
08:38 - call it
08:39 - get the display
08:41 - surface
08:43 - now besides that we need sprite
08:47 - groups
08:50 - and for now i just want to create one
08:52 - attribute that i call all sprites
08:56 - and this is going to be
08:57 - pygame.sprite.group
09:00 - groups are a key feature of pygame and
09:03 - they help us to draw and update any kind
09:06 - of sprite in the game and sprites is
09:09 - what you use to basically do anything in
09:11 - pygame so our player is going to be a
09:13 - sprite any kind of tree or plant is
09:16 - going to be a sprite and none of this
09:18 - works without a group
09:20 - in my case what i want to do inside of
09:23 - run i first of all want self.display
09:26 - surface dot fill
09:28 - with a black color so we don't
09:30 - accidentally see the previous frame
09:32 - after that i want self dot all sprites
09:36 - dot raw
09:38 - and in here we need the surface we want
09:40 - to draw on and in my case i want to draw
09:42 - on the display surface
09:44 - meaning this is what we have to pass in
09:46 - here
09:48 - i can just copy it and paste it in here
09:51 - and besides that i also want self dot or
09:54 - sprites dot update
09:56 - now this method we are not going to use
09:59 - for now but later on this is what
10:01 - updates all of the sprites inside of it
10:04 - like the player for example
10:07 - but now back in main.pie i can run all
10:10 - of this and we cannot see any change
10:13 - and that is because we haven't really
10:14 - made any changes to the logic of the
10:16 - game although if you want to see
10:18 - something
10:19 - you could change this black to something
10:20 - like red
10:22 - and now we have a red background
10:24 - although i want to keep this black
10:26 - and there we go
10:28 - so with that we have a basic setup so
10:31 - let's get started with the player
10:34 - now the player is going to become quite
10:36 - complex so i'm going to do all of this
10:38 - over multiple steps
10:40 - but we do have to get started somewhere
10:42 - so let's create a really basic player
10:45 - here we are back in the code and for the
10:47 - player i want to have a separate python
10:49 - file
10:50 - meaning i'm going to create a new one
10:52 - and save it as player.pie
10:56 - just as before we have to import
10:59 - game and also from settings import
11:04 - everything
11:05 - once we have that i want to create a
11:08 - class
11:08 - layer
11:09 - and this one needs to inherit from
11:13 - dot pygame.sprite.spry because it is
11:15 - going to be a sprite
11:16 - in here we need a dunder init method and
11:19 - this one eventually is going to have a
11:21 - lot of parameters although for now all i
11:24 - want is self
11:26 - then i want a position and then i want
11:28 - the group the sprite is supposed to be
11:30 - part of
11:31 - and the first thing we have to do inside
11:33 - of the indent method is called super and
11:36 - dunder init
11:38 - and in here we have to pass in the group
11:41 - that way as soon as we are creating an
11:43 - instance of this class the object is
11:45 - going to be inside of this group which
11:47 - is super handy
11:49 - besides that we will need self dot image
11:54 - this is what the sprite is going to look
11:56 - like and this needs to be some kind of
11:58 - surface
11:59 - now later on we're going to import a lot
12:02 - of surfaces but for now we don't really
12:06 - have that available as a consequence i'm
12:09 - going to create a plane surface
12:12 - and this i get with pygame dot surface
12:15 - this one is going to need a width and a
12:17 - height
12:17 - and the numbers here don't matter since
12:19 - we are going to change them anyway but
12:21 - let me go with 64 by 32
12:24 - now this image right now is going to be
12:26 - completely black and since we are
12:29 - putting this on another black surface as
12:31 - we can see in the level we are not going
12:33 - to see anything
12:35 - you change that i want to fill the image
12:38 - with a color let's go with green
12:41 - finally we are going to need a self dot
12:45 - rectangle and this one would take care
12:47 - of the position
12:49 - this rectangle we create with
12:51 - self.image.get
12:53 - underscore rect and in here as the
12:55 - argument we have to pass in where we
12:58 - want to place it and i want to place the
13:00 - center of this rectangle wherever the
13:03 - position is
13:04 - and this position we are getting from
13:07 - the parameters
13:09 - with that we have a very simple player
13:14 - spread class
13:15 - now we just have to use it and this is
13:17 - going to happen inside of level
13:20 - in here i want from player import player
13:25 - to keep everything organized inside of
13:27 - the level i want to create a setup
13:30 - method this one itself as always and in
13:33 - here we are going to create an attribute
13:36 - called self dot player and this is going
13:39 - to be an instance of the class player
13:43 - the player we have created here
13:45 - and this player is going to need two
13:47 - arguments the position and the group
13:50 - so let me copy both of them
13:52 - and paste them in here
13:54 - for now the position is going to be
13:56 - completely random but we are going to
13:58 - need a tuple with an x and a y position
14:02 - in my case let's go with 640 and 360 the
14:08 - middle of the screen
14:10 - besides that we need a group and the
14:12 - group here is self dot or sprites a
14:16 - group we have created earlier on and now
14:18 - we're just passing it in here
14:21 - we are nearly done the last thing that
14:23 - we have to do is to actually call the
14:25 - setup method and this happens inside of
14:27 - the init method so in here self.setup
14:32 - and now we should be able to see
14:34 - something so back in main.pi i am going
14:37 - to run my code and we can see we have a
14:41 - green thing
14:42 - although i realized i confused the width
14:45 - and the height
14:46 - so back in my player this should be 32
14:50 - for the width and 64 for the height
14:54 - that is looking much better
14:58 - so now we can see something but we
14:59 - cannot interact with anything
15:01 - which means inside of the player
15:04 - i want to get
15:05 - some kind of input
15:08 - and don't forget self that one is really
15:11 - important
15:12 - now to get all of the available keys
15:14 - that are being pressed we need pygame
15:17 - dot key dot
15:19 - get underscore
15:21 - rest
15:22 - this one is returning a list with all of
15:24 - the keys that are potentially being
15:26 - pressed and this i want to save in a
15:28 - variable let me call it keys
15:32 - and this list i can access with for
15:34 - example via keys and then square
15:37 - brackets
15:38 - and now
15:40 - pi game has a couple of predefined names
15:42 - for example for the up arrow we need k
15:45 - up
15:47 - and if that is the case for now let me
15:50 - just print
15:51 - up
15:53 - all that is left to do now is to figure
15:55 - out when to call this input method here
15:58 - and for that
15:59 - we will need an update method then
16:03 - itself and delta time
16:06 - how this is going to work is
16:09 - inside of level we have our all spreads
16:12 - group and this all spreads group has a
16:14 - draw and an update method the update
16:17 - method is the really important part
16:19 - right now
16:20 - because this one calls the update method
16:23 - on all of the children
16:25 - meaning effectively what is going to
16:27 - happen is that this update method here
16:30 - calls this update method
16:33 - as a consequence
16:34 - for the level or the group more
16:36 - specifically we have to pass in
16:39 - delta time as well the delta time we get
16:42 - from the parameters here and this delta
16:44 - time we get all the way at the beginning
16:47 - inside of main
16:49 - in just a bit this is actually going to
16:50 - become useful
16:53 - but now inside of the player
16:55 - all we have to do is call self dot input
17:00 - and this should be working so now if i
17:02 - go back to my main.pi run all of this
17:05 - and now if i press up in the bottom left
17:08 - you can see up
17:10 - which means i get some input
17:13 - all we have to do now is to cover the
17:15 - other directions and then we should be
17:17 - good to go
17:18 - and the usual system works like this
17:21 - if we're not pressing up
17:23 - then i want to check if keys and pygame
17:27 - dot k underscore down so we are pressing
17:31 - the down button and if that is the case
17:34 - i want to print down for now
17:37 - and with that we have up and down
17:39 - besides that let me copy
17:41 - all of this
17:43 - i also want to check for right
17:47 - and i want to check for left
17:51 - and then obviously the text has to be
17:53 - right
17:54 - and it should be left
17:57 - and with that if i run main.pi
18:00 - we get left right up and down all of the
18:03 - four directions
18:04 - what we now have to figure out is how to
18:06 - translate all of this into actual
18:08 - movement
18:10 - and for that we need a few more
18:13 - attributes let me put it all the way in
18:15 - the net method with a comment let's call
18:18 - it movement attributes
18:20 - and the ones before let's call them
18:23 - general setup
18:25 - for the movement i want to have first of
18:28 - all self.direction
18:31 - and this is going to be a vector so
18:32 - pygame.math.vector2
18:36 - and this vector is going to have an x
18:37 - and a y part
18:39 - depending in which way the player should
18:41 - move so for example if x is 1 then the
18:44 - player should move to the right
18:46 - and by default this vector 2 is supposed
18:49 - to be empty so it should have 0 and 0.
18:52 - and this is the default value so i can
18:54 - just leave it like this
18:57 - and all that we are going to do inside
19:00 - of here is change this direction so
19:03 - basically inside of keys for up i want
19:06 - to set self.direction
19:09 - dot y
19:11 - two
19:12 - minus one
19:14 - this i can now copy
19:15 - and do it four down this one is just
19:18 - going to be one
19:20 - for right
19:21 - we are targeting x
19:23 - and this one is going to be positive one
19:25 - and left is going to be
19:29 - x being negative one
19:32 - and with that we have the four different
19:34 - directions
19:35 - although now we do have a problem and
19:38 - let me isolate the vertical directions
19:41 - just to illustrate what the problem here
19:43 - is right now
19:44 - later on
19:45 - we are moving the player in whatever
19:47 - this direction is pointing at so for
19:50 - example if y is negative 1 we want to
19:53 - move up
19:56 - and this is what we are getting in here
19:58 - the problem is
20:00 - in this setup right now once we press up
20:03 - once
20:04 - direction.y is always going to be
20:06 - negative one even if we release the
20:09 - button and this is obviously not great
20:11 - because once you move up once the player
20:14 - never stops moving up which well we have
20:16 - to change
20:18 - this fortunately though is very easy to
20:20 - change because all we have to do is add
20:22 - another else statement
20:24 - and let me copy the direction here
20:26 - because now the direction should be zero
20:30 - which means now if we're pressing up the
20:32 - direction of y is negative one
20:34 - if we are pressing down direction is
20:37 - positive one and if we are pressing
20:39 - neither then direction.y is zero so
20:41 - we're not moving in the vertical axis at
20:43 - all
20:44 - and that is all we need here so i can
20:47 - remove the white space and for the
20:49 - horizontal axis i have to do the same
20:51 - thing so in here self.direction.x
20:55 - is going to be zero
20:58 - and with that we have our basic
21:00 - direction what i can do now at the end
21:03 - of all of this i can print
21:05 - self.direction
21:07 - and now in main.pi if i run all of this
21:10 - and i can have the different directions
21:12 - inside of my vector this is working
21:13 - really well
21:16 - there are two more attributes that we
21:18 - need to make all of this work the first
21:20 - one i always call self.pos and this is
21:24 - also going to be a vector
21:26 - so let me copy this one here and now we
21:28 - have another vector
21:31 - now if you are familiar with pygame you
21:34 - probably always store the position
21:36 - inside of the rectangle however the
21:39 - problem with this approach is that a
21:41 - rectangle always stores the position as
21:43 - an integer
21:45 - but if we want to use delta time so this
21:48 - one here to move everything in a frame
21:50 - rate independent way we are very often
21:52 - getting floating point values which
21:55 - wouldn't work here at all as a
21:57 - consequence i am going to store the
21:58 - position
22:00 - inside of a vector and this is going to
22:02 - be what self.pos is for
22:05 - and this is also what we are going to
22:07 - move and then at the end we are going to
22:10 - update the rectangle depending on where
22:12 - the position is
22:14 - all of that is going to make much more
22:16 - sense later on but for now for the
22:18 - starting position of self.pause i want
22:20 - self.rect.center
22:24 - finally i want
22:25 - self.speed and this is just going to be
22:28 - how fast the player is
22:30 - i put this at 200 but just choose
22:32 - whatever you think looks good
22:35 - and with that i can get rid of this
22:38 - print statement here and add another
22:41 - function or one method and this one is
22:44 - going to be move and here we need self
22:46 - and delta time
22:48 - and essentially what i want to do in
22:50 - here i want to move myself.pause and how
22:54 - i want to move it is by getting myself
22:56 - dot direction
22:58 - multiplied by self dot speed
23:01 - multiplied by delta time
23:05 - and after i have done that i want to set
23:07 - self.direct.center
23:10 - to self.poss
23:12 - and now
23:13 - after the input if i call self.move
23:17 - with deltatime
23:19 - we should be having a moving player so
23:21 - let's try and run main.pi
23:23 - and i can move around this is working
23:26 - really well
23:30 - and this is also frame rate independent
23:33 - and this is why this entire system is
23:35 - really important by using delta time
23:38 - again check out my video on it if you
23:39 - want more detail
23:41 - it does get a bit more technical but if
23:44 - you didn't do this
23:45 - and change the frame rate for example in
23:48 - this self.tick you could set the frame
23:51 - rate for example with 60 or you could
23:53 - set a thousand or you could set 10.
23:57 - with this setup the frame rate doesn't
23:59 - matter but if you didn't do it then the
24:00 - movement would be faster or slower
24:02 - depending on how the frame rate is which
24:04 - would be a massive problem
24:07 - all right in this case
24:09 - we have our basic movement
24:13 - now there's one more important thing
24:15 - that we have to do and that is inside of
24:18 - this move method if i run the code again
24:22 - if i move left and right or up and down
24:25 - i have one speed however if i move in
24:28 - the diagonal direction like this the
24:30 - player moves noticeably faster and that
24:33 - is a problem you can see it pretty well
24:35 - here
24:37 - now why is that happening and let me
24:39 - draw on the screen to explain
24:41 - if the player is only moving in one
24:43 - direction let's say the player is moving
24:45 - to the right like this
24:47 - at a speed of 1. that's not the actual
24:50 - speed but 1 is a very simple number to
24:52 - use
24:54 - and if we only move up we are also going
24:56 - to have a speed of 1. this is what we're
24:59 - getting from direction
25:00 - the problem now is if we're combining
25:03 - these two numbers we are getting a
25:05 - different kind of length
25:07 - so let me rearrange the drawing a tiny
25:09 - bit and let's say i want to move by one
25:11 - unit to the right and by one unit up
25:15 - then the actual distance i am going to
25:17 - move is going to look like this
25:20 - and the distance of this
25:23 - length here is what we are getting from
25:25 - pythagoras theorem
25:27 - it is 1 square plus 1 square and then we
25:31 - are taking the square root of all of
25:33 - this
25:33 - the result in this case would be
25:35 - something like 1.4
25:39 - and this result means that if we move
25:41 - diagonally the player would move about
25:42 - 40 faster than if we just move left or
25:45 - right or up or down
25:47 - which obviously is going to be a problem
25:49 - so we have to adjust for that
25:51 - and the way you adjust for that is
25:54 - called
25:55 - normalizing a
25:57 - vector
25:59 - and normalizing a vector basically just
26:01 - means that well we're making sure the
26:04 - direction of the vector is always one
26:07 - and this is an inbuilt function into
26:09 - pygame so you don't have to think about
26:11 - it too much all we have to do is get
26:13 - self.direction
26:16 - and we have to assign it to
26:17 - self.direction.normalize
26:21 - don't forget to call it
26:23 - and we are nearly done
26:25 - the last problem we have is that we can
26:27 - only normalize a vector if the vector
26:30 - has a length and this should make sense
26:32 - i guess to illustrate what this one is
26:34 - doing is let's say we have a vector of 1
26:38 - and 1.
26:40 - what normalize would now do is convert
26:42 - these two numbers so that the vector
26:44 - overall has a length of 1
26:47 - which in this case would get us the
26:49 - numbers something like 0.7 and 0.7
26:55 - i can actually demonstrate this a bit
26:57 - better so let me print a vector after we
27:00 - are normalizing it so now i want to
27:02 - print self.direction
27:06 - and run all of this again
27:08 - and we are already getting an error that
27:11 - we cannot normalize a vector with the
27:12 - length of zero and this should make
27:15 - sense
27:16 - for normalized to work pygame needs to
27:18 - know in what direction the vector is
27:20 - pointing but if the vector is 0 and 0 it
27:23 - doesn't point in any direction so
27:25 - normalize wouldn't work
27:28 - but this we can fix quite easily all we
27:30 - have to do is check if the vector has
27:33 - any kind of length and this we get with
27:35 - self dot direction dot
27:38 - magnitude
27:39 - don't forget to call it and if this is
27:41 - greater than zero only then do we want
27:44 - to do all of this
27:46 - and now let's try it again if i move
27:48 - left and right we have a direction of
27:50 - one if i move up and down it is one as
27:53 - well but now if i move diagonally it's
27:55 - 0.7 or negative 0.7 and this is
27:58 - important to keep the speed constant
28:02 - and all right i hope that makes sense
28:05 - there is just one more thing that i want
28:07 - to do before we finish off this part and
28:09 - that is later on
28:12 - i have to work with these two lines more
28:14 - to implement the collision mechanics and
28:17 - for that i have to separate
28:20 - these two lines into the horizontal
28:23 - movement
28:24 - and into the
28:26 - vertical movement
28:29 - so first of all i don't want to update
28:32 - the entire position vector i only want
28:34 - to update for the horizontal part the x
28:37 - dimension
28:38 - so for example instead of updating
28:41 - position by itself i only want to update
28:44 - x
28:45 - and as a consequence we have to update
28:47 - the other vector as well and update the
28:49 - rectangle 2 and this could be a really
28:52 - good exercise for you to finish off this
28:54 - section so if you want to code along
28:56 - pause the video now and try to update
28:58 - the vector and the rectangle
29:01 - and see how far you get
29:07 - for position.x we don't want to get the
29:10 - entire direction vector instead i only
29:13 - want to get x of the direction
29:15 - self.speed and delta time can remain the
29:18 - same
29:18 - then for the rectangle i don't want to
29:20 - set the center i want to set the center
29:23 - x
29:24 - and then this should be self.pos.x
29:27 - and with that we have the horizontal
29:29 - movement now i have to copy all of this
29:32 - give me some white space and paste it in
29:34 - here
29:35 - and now i basically have to switch
29:37 - all of these x's to a y
29:42 - and there we go the result in terms of
29:45 - if i run main.pi again we are not going
29:47 - to see a difference
29:49 - but later on for the collision
29:51 - we do want to have control over the
29:53 - horizontal and the vertical movement
29:55 - individually
29:57 - but this i will talk about in much more
29:59 - detail later on for now we have a pretty
30:02 - solid setup
30:03 - in this section we're going to import
30:06 - the player graphics and there's quite a
30:09 - lot of stuff that we have to import
30:11 - let me actually
30:13 - open the folder here we go and inside of
30:17 - graphics we have the character and then
30:19 - here we have all of the different
30:22 - animations for example down is the down
30:24 - movement and here we have the player
30:26 - walking down
30:28 - and well we have to import all of these
30:32 - different animations
30:36 - now you could do all of this by hand and
30:38 - it would be possible but not really
30:41 - practical because there are way too many
30:43 - animations
30:44 - fortunately you don't have to you can do
30:46 - all of this with python to automate the
30:48 - entire process so let's have a look at
30:50 - all of this
30:52 - here we are back in the code and i want
30:55 - to work inside of the player and let me
30:57 - minimize all of the methods so things
31:00 - are a bit easier to read
31:02 - for the import i want to add another
31:05 - method let's call it import
31:07 - assets
31:09 - this one itself and nothing else and
31:12 - inside of here
31:14 - i basically want to create a dictionary
31:18 - called self dot animations and this
31:21 - dictionary
31:22 - is going to have a ton of key value
31:24 - pairs for example one key would be up
31:28 - and this would be up walking
31:30 - and then the value associated with this
31:33 - key would be a list with a bunch of
31:35 - surfaces that correspond to the up
31:37 - movement
31:39 - now for that
31:41 - i have this is something you do have to
31:44 - copy from the notes this is looking like
31:46 - this here are all of the different
31:48 - states the player could be having
31:51 - we have up down left and right these are
31:54 - the movement ones then we have all of
31:56 - those with idle
31:57 - then with the whole the x and the water
32:01 - these are all of the animations
32:04 - and these also correspond if i open the
32:06 - folder again
32:07 - here we have all of the different states
32:10 - and therefore the name corresponds with
32:12 - the key of this dictionary so we have
32:14 - down here and we have down here this is
32:17 - really important
32:19 - because what this allows us to do
32:23 - is i can do for animation in self dot
32:28 - animations dot
32:30 - ease
32:31 - don't forget to call it
32:35 - and in here first of all i'm going to
32:37 - need a full
32:38 - path
32:39 - and the full path is basically i have to
32:42 - go up one folder then i have to go to
32:44 - graphics and then i have to go to
32:47 - character
32:48 - and don't forget another forward slash
32:50 - and then i have to add the animation
32:54 - because the animation name is also the
32:55 - folder name
32:57 - let me demonstrate what this means
33:00 - here is the file setup again and right
33:03 - now we are working inside of the player
33:06 - and from there we have to go up one
33:08 - folder to the project then we go to
33:10 - graphics then we go to character and now
33:13 - we have to select all of these different
33:14 - folders
33:17 - which is what we're doing with this line
33:19 - here along with the for loop
33:21 - and now essentially all i want to do is
33:24 - get
33:24 - myself.animations dictionary
33:27 - target
33:28 - one
33:30 - of the key value pairs
33:32 - and then i have to actually import all
33:34 - of the surfaces now this i'm going to do
33:36 - in a separate folder that i called
33:38 - import folder
33:40 - and this one is going to need the full
33:42 - path so it knows what to import
33:45 - and this import folder i generally put
33:47 - in a separate file because it's quite a
33:50 - handy one to reuse so let me create a
33:53 - new file that i want to save as support
33:56 - dot pi
33:58 - and in here we need a function called
34:00 - import
34:01 - folder
34:03 - and this one needs a path as a parameter
34:05 - but nothing else
34:08 - and this is what the player so inside of
34:10 - the player
34:11 - i want from
34:13 - support import
34:15 - everything
34:16 - so now we have to create this file here
34:19 - and let me add a bit of white space
34:22 - and now we can work on it first of all i
34:25 - want to create what i always call a
34:27 - surface list and this by default is
34:30 - going to be empty
34:31 - and in here we're going to store all of
34:33 - the surfaces and this is also what we
34:36 - are going to return at the end of this
34:38 - function
34:39 - so now we just have to figure out how to
34:43 - actually access the folder and for that
34:46 - we need a specific module
34:49 - is we have to import but it comes with
34:50 - python we need from os import walk
34:55 - and walk allows you to walk through
34:57 - different folders
34:58 - let me actually demonstrate what it does
35:00 - so for let's call it folder in
35:05 - walk and then we have to pass in the
35:08 - path
35:09 - and that is the path we are getting from
35:11 - the parameters and we're just passing it
35:13 - through
35:14 - and i guess in here let me just print
35:16 - what we get the folder
35:18 - and now since we're calling this inside
35:20 - of the player
35:21 - we just need to make sure inside of the
35:23 - init method
35:24 - all the way at the beginning this is
35:26 - really important
35:28 - i want to self dot import assets
35:33 - and this has to be all the way at the
35:34 - top of the indent method because later
35:37 - on
35:37 - when we create the image we need this
35:40 - self animations dictionary
35:43 - but now if i run out of this
35:46 - we are getting a ton of different things
35:48 - at the bottom
35:49 - and this is
35:51 - what work does
35:53 - it basically returns a list
35:55 - with all of the contents of the folder
35:58 - for example the first folder here is the
36:00 - up folder this one doesn't have any
36:02 - subfolders and inside of this folder we
36:05 - have a couple of files they are always
36:08 - called 0 1 2 and 3.
36:11 - they all have the same name but they are
36:12 - different files
36:15 - and this is what we want to use to
36:17 - import things now keep in mind a really
36:21 - important thing here is that all of
36:22 - these are just names we're not actually
36:25 - importing anything for pygame we are
36:27 - just going through a folder and looking
36:29 - at all of the file names but this is
36:31 - something we can definitely work with
36:33 - now first of all since this walk is
36:36 - returning a couple of things that we
36:37 - don't need
36:39 - we can unpack this quite a bit
36:42 - so the first one we get is the folder
36:45 - name
36:47 - the second thing we get is the
36:49 - always a list of subfolders and the
36:51 - final thing we get is the actual content
36:54 - let's call it image files
36:57 - now folder name and subfolder i just do
36:59 - not care about so i'm going to replace
37:02 - the folder name and the subfolder to
37:05 - underscores
37:06 - that way i indicate that i don't care
37:08 - about them
37:09 - so now let me print the image files and
37:13 - let's run main.pi again
37:15 - and now all i get is a list with names
37:18 - of images and this is what i really care
37:21 - about
37:22 - once i have that i need another for loop
37:25 - because remember image files is another
37:28 - list so i need four let's call it image
37:32 - in img files
37:34 - and now let's keep on printing things if
37:37 - i now print the image and run this again
37:40 - i am always getting the name of the
37:42 - image for each file now this right now
37:45 - is a bit confusing because the name of
37:47 - each individual image is fairly
37:49 - repetitive but these are all different
37:51 - files in different folders
37:54 - so all we have to do now is to convert
37:56 - all of this into a full path
37:59 - so
37:59 - now i have to do three things to finish
38:02 - off this function first of all i need a
38:05 - full path
38:07 - and this full path is going to be the
38:08 - path we already have that's a path to
38:11 - the folder and then we have to attach
38:13 - the name of the image itself
38:16 - after we have that i can create an image
38:19 - surface so this is the inbuilt pie game
38:22 - surface that we actually want to create
38:25 - and once we have that surface i want to
38:27 - get my surface list and append
38:30 - wow that is misspelled
38:32 - i want to append the
38:35 - image
38:36 - surface
38:37 - meaning we have to get the full path and
38:39 - the image surface
38:41 - and this i think could be a really good
38:42 - exercise for you
38:44 - try to combine the path to the folder
38:46 - and the image to get the full path and
38:49 - then for the image surface you have to
38:50 - import pygame and then use the full path
38:53 - to import one specific surface so pause
38:57 - the video now and try to figure this one
38:58 - out yourself
39:02 - ready for default path
39:05 - i want to get the path itself and this
39:07 - is getting me my folder and to that i
39:10 - want to add the image remember the image
39:13 - is just the name of the file not the
39:14 - actual image
39:16 - now this would almost work let me
39:19 - actually comment out these other two
39:21 - lines and let me print
39:23 - the full path you might already guess
39:26 - what the problem with this here is if i
39:29 - run this
39:30 - we have the name of the folder let me do
39:32 - this all the way at the top so up here
39:35 - for example is the name of the folder
39:37 - and then 0.png is the name of the file
39:41 - this is a really good start but we do
39:44 - need a slash to separate the two
39:48 - meaning in here
39:49 - besides the image
39:51 - we have to add
39:54 - e
39:54 - slash
39:57 - and now if i run this again
40:00 - we have the whole path towards this one
40:02 - specific image
40:05 - so i can remove the print statement and
40:07 - now i can actually use this full path to
40:11 - import an image as a surface now for
40:13 - that to work obviously i need pi game
40:18 - and what i want to do in here is
40:19 - pygame.image.load
40:22 - and now i need the full path
40:24 - although important here you also have to
40:27 - add convert alpha
40:29 - that way we are converting this image to
40:32 - something that's easier to work with in
40:33 - pi game as a consequence our code is
40:35 - going to run much faster now i can
40:38 - uncomment the append line and we should
40:41 - be good to go
40:43 - back in my player
40:45 - after i've run this for loop i want to
40:49 - print self dot animations
40:52 - and let's see what we get
40:55 - that is looking pretty good we are
40:57 - getting a dictionary
41:00 - with a key and a ton of surfaces as the
41:04 - values now we don't know what each
41:07 - individual surface looks like but i'm
41:09 - pretty confident that this is going to
41:11 - work
41:12 - all we have to do now if i minimize this
41:15 - method here
41:16 - is when we are creating the image i have
41:19 - to pick one of these surfaces now for
41:22 - that we need a few more attributes to
41:24 - make all of this work efficiently
41:27 - and the way i approach this is i add two
41:30 - more attributes the first is self.status
41:33 - and this could for example be up or it
41:36 - could be down or it could be something
41:38 - like down x if you want the downwards x
41:41 - animation
41:42 - but for now let's keep to down actually
41:44 - down idle is a good one i suppose
41:47 - besides that we need what i call the
41:50 - frame
41:51 - index
41:52 - and this by default is going to be 0.
41:55 - now the frame index is going to make
41:57 - much more sense once we are doing the
41:59 - animations in the next bit
42:01 - for now don't worry too much about it
42:04 - how we are going to use all of this is
42:06 - instead of creating a plain surface
42:09 - i want to get myself dot animations this
42:13 - is a dictionary with key value pairs
42:15 - where each key is going to be accessed
42:17 - via the status
42:19 - meaning
42:19 - inside of this i want to access the key
42:21 - value pairs with self dot status
42:25 - and this list i am accessing with self
42:28 - dot frame index
42:32 - and now i can get rid of the image fill
42:36 - and we should be seeing the player let's
42:38 - try
42:39 - and there we go we have
42:41 - one frame of the player
42:43 - now since we don't have animations yet
42:45 - this doesn't look too impressive but
42:48 - well what you can do now for example
42:51 - this could be down
42:52 - x
42:54 - and let's try this one there we have the
42:56 - first frame of the x animation
42:58 - this could also be
43:00 - let's say
43:01 - left
43:03 - water
43:04 - and
43:06 - then we get this kind of animation here
43:07 - or well it's not an animation it's just
43:09 - a surface but we do have a very good
43:11 - start
43:13 - in this section we're going to animate
43:15 - the player
43:17 - now for that we are going to need quite
43:19 - a bit of logic
43:21 - so let's go through it one by one
43:23 - here we are back in the code and i want
43:26 - to keep on working in the player now for
43:29 - the animations to work there are two
43:31 - things we need first of all
43:34 - inside of
43:37 - the self.animations dictionary we have
43:39 - to go through the list of surfaces
43:42 - because they are the animation
43:44 - and this is actually a fairly simple
43:46 - method this we can start with in just a
43:48 - second
43:49 - the much more complicated bit is
43:52 - getting the self.status so we have to
43:55 - know if the player is moving or idling
43:57 - or using the x or the water or the hoe
44:00 - and this is going to determine what
44:02 - animations we need getting the status is
44:04 - quite a bit more complicated but let's
44:07 - start with the actual animation that one
44:09 - is actually quite simple
44:11 - i first of all have to create another
44:14 - method let's call it animate this one
44:16 - itself and it also needs delta time
44:20 - and basically what i want to do in here
44:23 - i want to get myself dot frame index
44:26 - and increase it in my case i want before
44:29 - multiplied by delta time
44:32 - and then after that i'm going to get
44:34 - myself dot image
44:36 - so what the sprite actually looks like
44:38 - and i set this to self dot animations
44:42 - i get myself dot status
44:45 - and then i get myself dot frame index
44:50 - the way you have to think about it let
44:51 - me open the folder again and let's say
44:54 - for down inside of down we have four
44:57 - different images zero one two and three
45:01 - and we are using self.frame index to go
45:04 - through them so we have first zero then
45:06 - one then two and then three
45:10 - and all i am really doing is i am
45:12 - increasing self.frame index to pick up
45:15 - all of these numbers that's literally
45:17 - all that's happening here
45:19 - however there are two major problems
45:21 - here
45:22 - number one
45:24 - is that we can only ever take the index
45:26 - with an integer
45:28 - but this operation here is going to
45:30 - return a floating point number as a
45:33 - consequence this self.frame index has to
45:36 - be converted to an integer which is very
45:39 - easily done
45:40 - besides that the other problem is
45:43 - that each animation has a finite amount
45:46 - of frames for example down has four
45:48 - frames inside
45:50 - however this line here is going to be
45:53 - very quickly on a higher number than
45:55 - four
45:56 - so we have to make sure that we are
45:58 - always looping through this and this we
46:01 - are doing in an if statement if self dot
46:05 - frame index
46:06 - is greater or equal
46:08 - than the length of self dot
46:13 - animations and in here once again i need
46:16 - self dot status
46:18 - if that is the case i want to set self
46:21 - dot frame index back to zero
46:25 - so what this one does if i open the
46:27 - folder again
46:29 - and let me try to get everything on the
46:32 - screen
46:36 - something like this looks good
46:40 - we are basically starting with
46:42 - self.frame index being zero which is
46:45 - getting us this first image here
46:49 - after that we are increasing the frame
46:50 - index by a certain number
46:53 - and then down here we're getting the
46:56 - integer of that number so at some point
46:59 - this is going to be one this is going to
47:01 - be two and this is going to be three
47:05 - after that we're going to end up with a
47:08 - number larger than 3. so we are going to
47:10 - be somewhere down here
47:13 - which would be causing an error and for
47:15 - that we have this line here
47:18 - this one is making sure that this
47:21 - doesn't happen and instead we're moving
47:23 - back to zero
47:25 - and with that we have proper animations
47:28 - all that's left to do now is to actually
47:30 - call it so inside of update all the way
47:33 - at the end i want self dot animate
47:37 - don't forget to pass in delta time in
47:39 - here
47:40 - and now if i run this
47:45 - now the watering animation isn't great
47:47 - but the animation for down
47:50 - does look much better so
47:53 - there we go this is down movement if i
47:56 - just move down this is already looking
47:57 - pretty good
47:59 - and what i actually want to start with
48:02 - is down idle
48:04 - if i run this now there we go we have
48:06 - the player idling and looking straight
48:09 - at us this is looking really good
48:11 - so
48:12 - this was the easy bit now we have
48:15 - animations
48:16 - the one thing we now have to figure out
48:18 - is
48:19 - how to set this self.status to capture
48:22 - all of the different animation states
48:25 - and there are quite a few different
48:27 - states we have to account for
48:29 - all of these
48:31 - the really easy ones we can get in input
48:35 - because in here if we are for example
48:37 - pressing up we know that the player is
48:39 - moving up which means in this we can set
48:42 - self dot status
48:45 - to something like up
48:47 - then i can copy this and change this to
48:49 - down copy it again
48:51 - and change it to right and copy it one
48:54 - more time
48:56 - and change it to
48:58 - left
48:59 - and with that we already have the
49:01 - walking directions so now if i start all
49:03 - of this
49:04 - i can move left right up and down and we
49:08 - already have some very basic animations
49:11 - that look pretty good
49:15 - really good start
49:17 - besides that let me minimize input
49:20 - i want to check if the player is idling
49:23 - so if we go for example from moving up
49:26 - and we stop moving
49:27 - then i want to switch to up idle
49:30 - which in practice means i have to add
49:33 - underscore idle to the status of the
49:36 - player
49:38 - and to do all of that i want to create
49:40 - another method
49:42 - let's put it below input
49:45 - in here i want to get
49:47 - stat test
49:49 - needs self and nothing else
49:51 - and in here
49:53 - i want to check
49:55 - if the player is not moving
49:59 - then i want to add underscore idle to
50:02 - the
50:03 - status
50:05 - and again if you want to code along this
50:07 - could be a really good exercise for you
50:10 - so try to figure this one out yourself
50:12 - and see how far you get
50:14 - if you want a tip this should be doable
50:16 - in two lines of code
50:21 - first of all we have to figure out if
50:23 - the player is moving or not and this we
50:26 - have actually already done this happened
50:29 - inside of move
50:30 - because we know if
50:32 - self.direction.magnitude
50:34 - so the length of the direction vector if
50:36 - that is zero we are not moving so i can
50:39 - just copy it
50:40 - minimize the move method
50:42 - and now
50:45 - if the magnitude is equal to zero
50:49 - then i know the player is not going to
50:50 - move
50:52 - which is covering the first bit let me
50:55 - put it at the top here
50:57 - besides that i have to add underscore
51:00 - idle to the status
51:02 - which
51:03 - in a very simplified way would just be
51:06 - self.status plus equal underscore idle
51:10 - and don't forget this is supposed to be
51:12 - a string
51:14 - all we are really doing for the status
51:15 - here is we are manipulating different
51:18 - strings to represent the status of the
51:20 - player
51:21 - that's literally all it is
51:24 - now this is a good start but it would
51:28 - cause a problem really really quick
51:31 - let me actually demonstrate so after i'm
51:33 - getting the input and before i am moving
51:35 - or animating i want to get
51:37 - self.get status
51:40 - and now if i run main.pi
51:44 - we're getting an error that we have a
51:46 - key down idle and idle
51:49 - and basically what happened here is that
51:52 - if the player is not moving python keeps
51:54 - on adding underscore idle towards the
51:56 - status
51:57 - we're not stopping at one we're adding
51:59 - more and more and that way we're getting
52:02 - an error so we have to make sure that we
52:04 - only ever have a single underscore idle
52:06 - in the status
52:08 - which we can get very easily all we need
52:10 - is self dot status
52:13 - dot split
52:16 - and i want to split wherever we have an
52:19 - underscore and then pick the index 0.
52:23 - this one here is going to return a list
52:26 - and the first item of this list is
52:28 - always going to be the status so this
52:30 - would be up down left right and so on
52:34 - and only to that i want to add the
52:36 - underscore idle that way we will only
52:38 - ever have a single idle inside of any
52:41 - kind of status
52:42 - and this i want to assign i don't want
52:44 - to add it to the status
52:47 - and now
52:48 - the player is idling and if i move
52:50 - downwards we are walking this also works
52:53 - with up it works with left
52:55 - it works with right and this is looking
52:58 - really good
52:59 - so now we have some basic animations
53:02 - that are definitely improving already
53:06 - so let me get rid of the comments here
53:10 - and
53:11 - we have the first bit covered
53:15 - the other bit we need is the tool use
53:19 - i guess let me add general comments here
53:21 - to make this a bit easier to follow
53:24 - let's call this the movement
53:26 - actually the idle is better
53:30 - now for the tool used the code is
53:33 - getting quite a bit more complex because
53:36 - besides get status we also have to add
53:39 - the input and we have to be able to
53:41 - select different kinds of tools
53:43 - so
53:44 - let's do all of this in a separate
53:46 - section
53:47 - so let's work on the tools for this to
53:49 - work we need a few parts that
53:51 - interconnect quite a bit
53:53 - so
53:54 - well let's jump right in and let's have
53:56 - a look at all of this
53:58 - once again here i have main.pi and i
54:01 - want to keep on working inside of player
54:04 - and specifically i want to work inside
54:06 - of the init method and in here i want to
54:09 - add another section let me call this one
54:12 - tools
54:13 - and for now i want to add one more
54:15 - attribute that i call selected
54:19 - pool
54:21 - and this could for example be an x
54:23 - it could be a hoe or it could be water
54:26 - short for watering can
54:27 - i guess for now let's stick with the x
54:29 - that one is really easy to see
54:32 - and for now we don't have any way in the
54:35 - game to change the tool that's going to
54:37 - be in the next section because i do want
54:39 - to keep things a bit more organized
54:42 - but well now that we have the selected
54:44 - tool i want to go to my input and in
54:47 - here
54:48 - besides the directions let me actually
54:51 - add a comment directions
54:55 - i want to add another section and let me
54:58 - call this one tool use
55:01 - and in here first of all i want to check
55:03 - if we are pressing a certain key which i
55:05 - get with if keys and then pygame dot
55:10 - in my case for the tool i have k space
55:14 - now basically what i want to do in here
55:18 - is if this condition is true
55:20 - i want to run
55:22 - a timer for the
55:25 - tool use
55:27 - so for example if the player is pressing
55:29 - space then we should have half a second
55:31 - of tool use being activated in some sort
55:34 - of timer
55:36 - and if the timer is active inside of get
55:38 - status we are always adding underscore x
55:41 - to the status
55:43 - now for that we need a timer and this is
55:47 - not inbuilt into pygame so we have to
55:49 - make it ourself
55:51 - and this i'm doing in a separate file
55:53 - and this one i want to save as timer dot
55:56 - pi
55:57 - and here as always we have to import pi
56:00 - game
56:01 - after we have that i want to create a
56:03 - class timer
56:05 - and this one needs it under init method
56:09 - in here we need self
56:10 - we need a duration
56:13 - and then we need a function that by
56:15 - default is going to be none
56:17 - the duration should make sense this one
56:19 - is really simple it's just how long the
56:21 - timer is going to be the function is
56:24 - going to be if we want to execute some
56:26 - code once the timer has run out
56:29 - something we are going to see in just a
56:31 - second but for now don't worry too much
56:33 - about it
56:34 - inside of this i want to create some
56:36 - attributes so duration is going to be
56:40 - duration
56:41 - and self dot funk is going to be funk so
56:45 - we're just capturing the parameters
56:47 - besides that i want to have two more i
56:50 - want to have self dot start underscore
56:53 - time this one is zero
56:56 - and then i want to have self dot active
56:59 - and this by default is going to be false
57:02 - and for this timer we have a couple of
57:06 - methods
57:06 - we have activate
57:09 - we have
57:12 - deactivate
57:13 - and we have up
57:16 - date
57:17 - and all three will need self but no
57:20 - other parameter besides that
57:23 - and let me go through how the timer is
57:25 - going to work we always start at some
57:27 - kind of start time 0 by default and this
57:30 - is what we are getting here
57:33 - after we have declared that we will
57:35 - continuously check the time which means
57:38 - we are checking the time here here here
57:40 - here here here and so on continuously
57:44 - throughout
57:46 - and besides that we also have a duration
57:49 - and the duration could for example be
57:51 - let me put it here at 300 milliseconds
57:56 - and now all we are really going to do is
57:58 - we are continuously checking if these
58:01 - red dots
58:02 - are before or after the 300
58:06 - meaning once that is the case we want to
58:08 - run some code so let's implement that
58:11 - first of all for activate this one is
58:14 - very simple all i want to do in here is
58:16 - if the timer is active i want to set
58:18 - active to
58:20 - true and besides that i also want to set
58:24 - self.starttime
58:26 - to
58:28 - pygame.time.get underscore ticks
58:32 - this is really important because this
58:35 - starting time here doesn't necessarily
58:37 - have to be zero
58:39 - we could very well start a timer at some
58:41 - point in our game
58:43 - so this zero might be something like
58:45 - 1240
58:48 - which means we started a timer about one
58:50 - second into the game we're doing all of
58:52 - this in milliseconds
58:54 - and if the timer has a duration of 300
58:57 - then this number here would be 1540.
59:02 - so these numbers are all relative it's
59:04 - really important for all of this to work
59:06 - now besides that if i want to deactivate
59:09 - the timer i want to set self.active to
59:13 - false
59:14 - and just to be sure self.starttime
59:17 - is going to be 0.
59:19 - finally inside of update the actual
59:22 - timer happens
59:24 - and this is some horrible spelling there
59:26 - we go first of all inside of update i
59:28 - want to have my current time
59:31 - and this i get with pygame.time.get
59:34 - underscore ticks
59:36 - the same line we have used up here the
59:38 - difference now is that this update
59:40 - method will be called continuously which
59:43 - means that this program.time.get
59:46 - will always get our current time
59:49 - and basically what i want to check is if
59:52 - my current time
59:53 - minus my self dot start time is greater
59:58 - or equal
59:59 - than self dot do
60:02 - ration
60:03 - for example if my current time is
60:05 - something like 1500 my start time is
60:08 - something like 1000
60:10 - and my duration is something like 300
60:16 - then the result here would be 500 is
60:18 - greater or equal than 300 which would be
60:20 - true so our timer should have run out
60:24 - now if that is the case first of all i
60:28 - want to self dot deactivate the timer i
60:31 - want to run all of this here
60:34 - besides that in case we have defined a
60:37 - function we want to run if the timer has
60:39 - run out
60:41 - i want to check if self.func so if a
60:44 - function exists and if that is the case
60:47 - i want to call self.bank
60:50 - and with that we have a timer class that
60:53 - we can use inside of the player now for
60:56 - that first of all we have to import it
61:00 - which we do with from timer import timer
61:06 - and with that covered i want to add
61:08 - another section let me put it before the
61:11 - tools and this i'm going to call timers
61:14 - in here i want to create a dictionary
61:16 - that i call timers
61:19 - in here we have a couple of key value
61:21 - pairs the key is just the name of the
61:24 - timer let's call this one tool use
61:27 - and now i can create a timer and let's
61:30 - say for the tool use i want to have a
61:32 - duration of 350 milliseconds
61:35 - and once this has run out i want to call
61:38 - a function that i called self.use
61:42 - underscore tool
61:44 - really important here you do not want to
61:47 - call this function you just want to pass
61:48 - it into this class
61:51 - and this one doesn't exist right now so
61:53 - we do have to create it let me put it
61:55 - actually right at the top here so things
61:57 - are easier to see
61:59 - so
62:00 - use
62:01 - tool
62:03 - and this one needs self and nothing else
62:06 - now this use tool for now is not going
62:08 - to do anything all i want to do is print
62:11 - let's say self dot selected tool
62:14 - later on this one is going to do quite a
62:16 - bit more but for now i just want to
62:18 - minimize it more importantly for now
62:21 - inside of the input
62:24 - i want to get myself dot timers
62:29 - and in here
62:31 - the tool use timer the one we created
62:35 - just a second ago
62:37 - and this timer i want to activate
62:40 - and now this we can use inside of get
62:43 - status
62:45 - and really all i want to do is if
62:47 - self.timers
62:50 - and tool
62:51 - use
62:52 - if this one is active
62:55 - then for now let me print
62:58 - tool is
63:00 - being used
63:03 - and let's try if this one is working
63:07 - so now if i press space
63:09 - we get tool is being used so something
63:12 - is happening but this is looking weird
63:15 - and it never stops
63:17 - so we do have to make some adjustments
63:19 - here
63:20 - now first of all the one thing i do want
63:22 - to change is the player should not be
63:24 - able to move once we are using a tool
63:27 - which means once
63:29 - this timer is active the player
63:31 - shouldn't be allowed to do anything else
63:34 - and for that i want to indent all of
63:37 - this one level
63:40 - and i want to have an if statement if
63:42 - not self dot timers and tool
63:47 - use
63:48 - if this one is active
63:52 - so only if we are not using a tool the
63:54 - player is allowed to move around
63:57 - and to use a tool
63:59 - we couldn't use a tool if the player is
64:01 - already using a tool
64:03 - that should make sense
64:05 - now besides that i also want to set
64:08 - self.direction
64:10 - to an empty vector so
64:11 - pygame.math.vector2
64:14 - the reason is think of if the player is
64:18 - moving to the right and then starts
64:21 - using a tool here
64:23 - if we didn't add this line here the
64:26 - player would just keep on moving to the
64:28 - right while using the tool which would
64:30 - be very strange
64:32 - and we wouldn't be able to stop it
64:33 - because remember the player is not
64:35 - allowed any kind of input while we are
64:38 - using a tool so we have to stop the
64:40 - player otherwise we would get some weird
64:42 - results
64:44 - but once we have that
64:46 - inside of get status
64:49 - all i really want to do is update my
64:52 - self.status
64:54 - so that i have a string that could for
64:57 - example be
64:58 - right
64:59 - and x
65:01 - so x is going to be
65:03 - what we are getting from our selected
65:06 - tool
65:07 - could also be whole or could be water
65:09 - but for now i want to keep it with x
65:11 - meaning this is going to work kind of
65:14 - like this line here except now we're
65:16 - adding a different word
65:18 - after the underscore
65:20 - which means this could be a really good
65:22 - exercise for you
65:24 - copy this line here and adapt it so you
65:27 - are incorporating the selected tool let
65:30 - me minimize the input so we can see it a
65:33 - bit better
65:34 - if the timer is active
65:36 - you are supposed to have the status so
65:38 - up left down or right plus an underscore
65:41 - plus the x
65:46 - all right all you have to do is first of
65:48 - all copy this line here or this part of
65:52 - the line so we just have up left down or
65:55 - right by itself
65:56 - and to that i want to add
65:59 - an
66:00 - underscore
66:01 - and then i want to add self dot selected
66:05 - tool
66:06 - and with that we should be good to go
66:10 - let's try this one now
66:11 - and now if i press space
66:14 - we have something
66:16 - so we do have an animation the problem
66:18 - is the animation never stops
66:21 - which i guess is a start but we do have
66:24 - to work on it the main reason why this
66:26 - happens is because we don't actually
66:28 - update these timers what i forgot to do
66:31 - is to call this update method
66:33 - continuously
66:35 - and to do that let's put all of this in
66:37 - a separate method although it's going to
66:39 - be a very short one
66:41 - let's call it update
66:43 - timers this one itself and nothing else
66:46 - as always and then here all i want to do
66:49 - is for timer in self.timers.values
66:55 - because remember
66:56 - we have self.timers as an attribute this
66:59 - one is a dictionary and then the key is
67:01 - the name and the value is the actual
67:05 - timer and this is what we are getting
67:06 - here
67:08 - and all i want to do is call
67:09 - timer.update
67:12 - and now inside of the update method of
67:15 - the player i want self dot update timers
67:19 - and now let's try this again
67:23 - so now
67:25 - we have a animation that is very
67:28 - inconsistent though
67:30 - and the reason why that is happening
67:34 - is
67:37 - let me go back to input
67:41 - here
67:42 - we have to add one more line
67:45 - and that line is going to be self dot
67:47 - frame index is going to be 0.
67:50 - the reason we need that is let's say we
67:53 - have our frame index this could be 0 1 2
67:56 - or 3.
67:57 - and essentially what we are doing is we
67:59 - always go from one to the other to the
68:02 - other and then we are going back to the
68:05 - start
68:06 - when we are pressing space so this line
68:09 - here we want to play a new animation
68:13 - the problem is frame index doesn't know
68:16 - that so when we start this animation we
68:19 - might already be on frame index being
68:21 - two and as a consequence we are playing
68:24 - not the first frame but we are playing
68:26 - one frame that is already maybe at the
68:28 - end of the animation which would be
68:30 - looking very strange
68:32 - and if we add frame index being 0 this
68:35 - is being fixed we always start the
68:37 - animation from the start so now let's
68:39 - try this again
68:41 - and there we go
68:42 - we have
68:44 - a proper x animation this one looking
68:47 - quite nice
68:49 - what you could also do
68:50 - is replace this x with a hole
68:55 - and now we have the hole
68:58 - and you could also change it with water
69:02 - and if i do that we have the watering
69:04 - can
69:05 - so with that we have our different tools
69:08 - although we are not able to change
69:10 - between different tools and we also
69:12 - can't see which tool is currently being
69:14 - selected
69:16 - i guess let's work on that in the next
69:17 - major part
69:19 - in this part we are going to work on
69:22 - switching between the different tools
69:24 - and since we already have timers there
69:27 - isn't actually that much to do
69:30 - so let's jump right in and let's have a
69:31 - look at all of this back in the code i
69:34 - want to keep on working inside of
69:36 - player.pi
69:39 - and now first of all i want to check if
69:42 - the player is pressing a button to
69:43 - change the tool this happens inside of
69:46 - input in here
69:49 - i want to add another section let's call
69:51 - it change
69:52 - tool
69:54 - and for this one i want to check my keys
69:56 - again and then here pygame dot k
69:59 - underscore q
70:01 - so we are pressing the q button on the
70:03 - keyboard i couldn't really think of a
70:05 - better one if you can't find a better
70:07 - key just go with that
70:09 - if that is the case i want to do
70:11 - something
70:12 - now what that something is going to be
70:15 - is going to be determined inside of the
70:17 - init method so right now the selected
70:20 - tool is always going to be one specific
70:23 - string but i want to make this a bit
70:25 - more flexible
70:27 - and what i want is first of all i want
70:29 - to have an attribute that is called
70:31 - tools and in here we have the whole
70:35 - we have the axe
70:37 - and we have water
70:40 - and besides that i want to have a seat
70:43 - index
70:44 - and this by default is going to be zero
70:48 - and then when we select a tool
70:50 - i am not going to get a string instead i
70:53 - want to have self.tools
70:56 - and then self dot
70:58 - this shouldn't be seed this should be
71:00 - tool index sorry about that
71:03 - so i want self.tool
71:05 - index
71:06 - and right now since our tool index is
71:09 - zero we are picking the first element
71:12 - from this list
71:13 - and what i basically want to do
71:17 - inside of this if statement here
71:21 - is i want to self dot tool index
71:25 - plus equal one
71:27 - and after we have that i want to update
71:30 - myself dot
71:31 - selected tool
71:33 - and this is just going to be self dot
71:36 - tools and then self dot tool index
71:41 - now this is fine in theory but in
71:43 - practice this is going to break let's
71:45 - actually try
71:46 - so may not pi i want to run it and now
71:48 - if i press q
71:50 - we are getting list index is out of
71:53 - range
71:55 - the reason is
71:57 - to us pressing q once might just be
72:00 - pressing q once
72:01 - to pygame it looks like we are pressing
72:03 - q for a certain amount of time and it
72:06 - keeps on adding this one to the tool
72:09 - index continuously
72:11 - i can actually visualize this that is
72:13 - much better than explaining it so
72:16 - if i print the tool index and run this
72:19 - again and if i now press q
72:22 - we are getting
72:24 - one two and three
72:27 - and then we are running out of numbers
72:29 - and i should get rid of the print
72:31 - statement let me look for it really
72:33 - quick
72:34 - let me comment out this print statement
72:36 - here and let me just add a pass in here
72:39 - that way it's a bit easier to see what's
72:41 - going on if i now press q
72:44 - we're getting one two and three and then
72:47 - we're getting an error because we are
72:49 - trying to use these numbers for indexing
72:51 - and this list doesn't have that many
72:53 - indexes
72:56 - as a consequence we are getting an error
72:59 - and the problem is that pygame tries to
73:01 - add more and more numbers
73:03 - the way around that is we need a timer
73:06 - that after every time we are pressing
73:09 - the button we want to wait a couple of
73:11 - milliseconds
73:12 - now fortunately we already have a very
73:15 - good system to work with timers so i
73:18 - want to create another timer and this
73:20 - one i call tool
73:22 - switch
73:24 - and this one is going to be another
73:26 - timer
73:27 - and this one has a duration of 200
73:29 - milliseconds
73:31 - there's no second argument because we
73:33 - don't really want to call a function
73:35 - after this one is over we just care if
73:37 - this timer is active or not
73:40 - once we have that
73:42 - and
73:43 - not self thought timers and in here i
73:47 - want tool
73:48 - switch
73:50 - dot active
73:52 - the player should only be able to change
73:53 - the tool if we are pressing q and if the
73:57 - tool switch timer is not active inside
74:00 - of the if statement the first thing that
74:02 - we are going to do is self dot timers
74:05 - and tool
74:07 - switch and this timer i want to activate
74:11 - that way we are only ever adding a
74:13 - single number to this tool index and
74:16 - we're not doing it continuously
74:19 - so now let's try this again if i press q
74:22 - we get 1 we get 2 now we get 3 and we're
74:25 - getting an error
74:26 - this error we're getting
74:28 - because even though now i am only adding
74:31 - a single number we can still add as many
74:33 - numbers as we want
74:35 - but what i want to do instead
74:38 - is that if we are exceeding
74:41 - the length of this list
74:43 - i want to set the tool index back to
74:45 - zero
74:48 - so if tool
74:50 - index
74:52 - is greater than length of
74:55 - tools
74:56 - then i want to set the tool index to
75:00 - zero
75:01 - and this could be a really good exercise
75:03 - for you so if you want to code along
75:05 - pause the video now and try to figure
75:06 - this one out yourself this should be
75:08 - doable on a single line of code although
75:11 - two would also be doable
75:16 - alrighty basically all i want to do is i
75:19 - want to set myself dot tool index
75:22 - and now i want to get
75:25 - self.tool index by itself
75:28 - but
75:29 - this only if a certain condition is true
75:31 - and that condition is self dot tool
75:35 - index
75:37 - is smaller than the length of self
75:40 - dot
75:42 - tools
75:44 - and if that is not the case
75:46 - so else i want to set tool index to zero
75:50 - and now let's try this again
75:52 - now i can press q we get 1 2 0 1 2 and
75:56 - so on
75:58 - and i can never go beyond the length of
76:00 - self.tools
76:03 - and now
76:05 - we already have all of the tools
76:08 - because remember we are updating our
76:12 - selected tool and this is what we're
76:14 - using inside of the status so we don't
76:16 - have to make any more changes this is
76:18 - all we need so with that we are able to
76:22 - change our tool
76:24 - it wasn't actually so bad or at least i
76:26 - hope this wasn't too difficult
76:29 - now while we are here we can go in two
76:32 - different directions now
76:34 - we can either work on the overlay or we
76:36 - can work on the seeds
76:38 - now i think it's best to start with the
76:40 - seeds because the seeds work basically
76:42 - in the same way as the tools do
76:45 - and once we have that we can create the
76:47 - entire overlay in one go so let's do the
76:50 - seats right now
76:52 - and this is going to be
76:54 - started inside of the dunder emit method
76:58 - right below tools and here i want to
77:01 - have my seeds
77:03 - and for the seeds i want to have
77:05 - self-doubt seeds and in here
77:08 - we only have two we have corn and we
77:11 - have tomato
77:14 - then we have
77:15 - self.seed index and this by default is
77:18 - going to be zero and then we have self
77:20 - dot
77:21 - selected underscore seed
77:24 - and this is going to be self dot seed
77:28 - index we are basically doing the same
77:31 - thing we have done for the tools except
77:33 - now we are storing all of this in
77:34 - different attributes
77:38 - which means now the tool use and the
77:40 - change tool are going to be very similar
77:43 - as well
77:45 - we have a seat use
77:48 - and we have a change seat part
77:53 - and those are going to be very similar
77:55 - compared those two as a consequence this
77:57 - could also be a really good challenge so
78:00 - try to copy
78:01 - those two
78:03 - to update the seed
78:06 - if you want to start if the player is
78:09 - pressing ctrl or left control then i
78:11 - want to use a seat and if the player is
78:14 - pressing e then i want to change the
78:16 - seat
78:18 - so pause the video now and see if you
78:20 - can figure this one out
78:22 - and remember here you are going to need
78:24 - some more timers
78:29 - all right let's try it together now
78:31 - first of all i need two more timers
78:34 - because i have a tool use i have a tool
78:36 - switch besides that let me actually
78:39 - duplicate both of those
78:43 - i want to have a seat use and a seat
78:46 - switch
78:48 - and for the seat use i want to have a
78:50 - method called use
78:52 - seat
78:54 - and you could change numbers here i
78:57 - really don't care about it
78:59 - now first of all
79:01 - i have to create another method just
79:04 - like use tool i need use underscore seed
79:08 - needs self and nothing else and for now
79:10 - let me add pass in here
79:14 - then i can minimize the function
79:16 - and now
79:17 - we can work on duplicating these two
79:20 - lines
79:21 - and we are very much duplicating them so
79:24 - let me copy and paste things
79:26 - first of all if keys and now we are
79:28 - checking
79:29 - k
79:30 - underscore
79:32 - and the name for the left control button
79:34 - is l c t r l
79:37 - short for left control
79:41 - if that is the case
79:44 - i want to activate my seed use timer
79:48 - and the other two lines i want to keep
79:50 - as they are
79:52 - after that i want to copy the if
79:54 - statement for change tool
79:57 - and this one is going to be k
79:59 - e
80:00 - and not
80:01 - timer's seat switch
80:04 - if that is the case i want to activate
80:06 - my seat switch timer
80:08 - and now the index here
80:11 - is going to be
80:14 - for the seat
80:16 - so i'm basically replacing tool with
80:18 - seed and that is all we are going to
80:21 - need in here
80:23 - now unfortunately there's no animation
80:25 - for the seed
80:27 - so instead what i want to do is i just
80:30 - want to print
80:32 - let's say for left control
80:35 - use seed
80:38 - and then for change seed i want to print
80:40 - self dot selected seed so we can tell
80:44 - what's going on and now let's try
80:48 - and we're getting an error that i made a
80:51 - typo somewhere
80:54 - so inside of the indent method
80:59 - this method here should be used not used
81:02 - seed so now let's try this again
81:04 - and there we go if i press left ctrl we
81:07 - get use seed
81:08 - and if i press e we get
81:11 - either corn or tomato
81:13 - so this is working really well
81:18 - and with all of that we have a ton of
81:21 - different inputs for the player without
81:24 - too much work actually
81:26 - so let me remove the print statements
81:28 - and now i can minimize the input this
81:31 - one is getting quite chunky
81:34 - okay i'm quite happy with this section
81:36 - so in the next section we are going to
81:38 - work on the overlay so we can tell
81:40 - what's going on
81:41 - in this section we're going to create
81:43 - the overlay which honestly isn't all
81:46 - that difficult all we essentially are
81:49 - going to do is put some images on top of
81:52 - the entire game
81:54 - and then those images are going to
81:56 - change depending on what the player has
81:57 - selected both for the tool and for the
81:59 - seats so let's jump right in once more i
82:02 - have main.pi open and i want to create a
82:06 - new python file that i'm going to save
82:08 - as overlay dot pi
82:12 - in here i want to import pi game and
82:15 - also i need from settings import
82:18 - everything
82:19 - and now i want to create a class called
82:22 - overlay
82:24 - there is no need for inheritance and i
82:27 - do need a dunder init method
82:31 - we need self as always and now we also
82:33 - need the player because the overlay
82:36 - needs to know what the player currently
82:37 - has selected
82:39 - inside of that i want to have a general
82:42 - setup in here we need two things first
82:45 - of all i need self dot display
82:49 - surface
82:50 - that is the same thing we have done
82:52 - inside of the level this way we can draw
82:54 - straight on the display surface and we
82:57 - can keep all of this inside of the
82:59 - overlay class
83:00 - all we need here is pygame dot display
83:03 - dot get underscore surface
83:07 - besides that i want to start a player in
83:09 - an attribute so self
83:11 - dot player is going to be player
83:15 - besides that i need to do some imports
83:20 - because in here i need self.tools and
83:23 - self dot seeds
83:26 - and those are not the same seeds and
83:28 - tools that the player has instead let me
83:30 - rename it actually these are all
83:32 - surfaces more specifically they are
83:35 - dictionaries with key value pairs
83:39 - for example one key for the tools could
83:41 - be x
83:42 - and then the value would be a surface of
83:44 - an x
83:46 - now for that we have to import a couple
83:49 - of images
83:50 - let me show you what we are going to
83:52 - import actually
83:54 - here is the project folder i want to
83:56 - look at graphics and inside there we
83:59 - have overlay inside of that we have x
84:02 - corn ho tomato and water and this is
84:05 - what we want to import
84:09 - now here you could import everything
84:12 - manually but once again that's not
84:14 - really a pleasant way to work in well
84:16 - any programming language so i'm going to
84:19 - use dictionary comprehension
84:21 - how that is going to work for the tool
84:23 - surfaces i want to have a tool
84:26 - and this is going to be the key and then
84:28 - i want to have a surface as the value
84:31 - and this i want to do for tool in
84:35 - layer dot tools
84:37 - which means inside of player
84:40 - i want to look at all of these tools and
84:44 - from this data i want to create a key
84:46 - value pair
84:48 - and the tool can actually remain the
84:50 - same so if we leave it like this the
84:52 - tool or the key would be hoe x or water
84:56 - which is totally fine the one thing we
84:58 - have to change is the surface
85:01 - what i want to do in here is
85:03 - pygame.image.load
85:06 - and inside of that we need an f string
85:10 - now to keep things a bit shorter i want
85:13 - to store the path separately so let me
85:15 - call it path actually let's call it
85:17 - overlay path that makes a bit more sense
85:20 - and all this is is a string we go up one
85:24 - folder we go to graphics
85:27 - and then we go to overlay and don't
85:29 - forget the final forward slash
85:32 - and this i want to use inside of this f
85:34 - string so overlay path
85:38 - after that
85:39 - i want to look at the tool
85:42 - so the tool could either be x whole
85:44 - water or could be one of the seeds
85:46 - and this is also how each of the files
85:49 - here are named so this is very handy
85:52 - finally one important thing don't forget
85:54 - we are looking at png files also really
85:57 - important you want to convert
86:00 - alpha all of this
86:02 - which makes all of this fairly long but
86:05 - very easy to work with
86:07 - and once i have that
86:09 - i can copy the entire thing
86:11 - and paste it in here and all i really
86:13 - have to do is to replace tool
86:17 - with seed make sure you call this
86:19 - player.seats
86:21 - and then this tool should also be seed
86:25 - but other than that we should be good to
86:28 - go
86:29 - let me actually print
86:31 - tool
86:32 - surface and
86:35 - seeds surface just to make sure that
86:38 - this is working oh actually we have to
86:40 - create the object from the class first
86:42 - of all
86:43 - and this happens inside of level
86:45 - so in level i want from
86:48 - overlay import overlay
86:52 - and now when we are creating everything
86:55 - i want to create self dot overlay
86:59 - and this is going to be
87:01 - the overlay class and in here don't
87:04 - forget we have to pass in self dot
87:07 - player
87:08 - now for that to work you have to create
87:11 - this overlay after the setup method
87:13 - because inside of setup we are creating
87:15 - the player
87:17 - and now once we have that let's run
87:19 - main.pi
87:20 - and we are getting an error the name
87:22 - tool surface is not defined let's have a
87:24 - look
87:27 - ah i forgot
87:29 - self here
87:31 - now let's try this again and there we go
87:34 - we're getting
87:35 - dictionaries with key value pairs that
87:38 - all look pretty good well i'm very happy
87:40 - with this
87:41 - so now we have access
87:44 - to the player and we have all of the
87:46 - surfaces that we do need all i have to
87:49 - do now is to create another method and
87:51 - let's call this one display
87:54 - in here we need self and nothing else
87:57 - and now i want to show the tools and i
88:01 - want to show the seats
88:03 - and for this one first of all i need the
88:06 - tool surface because right now we have a
88:09 - dictionary with key value pairs but what
88:12 - we want is one specific surface
88:16 - we have to select one surface from this
88:18 - dictionary
88:20 - and this we get with self dot tools
88:23 - surfaces
88:25 - and what i want to select from here is
88:27 - self dot
88:28 - player dot
88:30 - selected
88:32 - tool
88:33 - remember here the selected tool could
88:35 - either be x it could be whole or could
88:37 - be water
88:38 - and this is also what we're using as a
88:41 - key inside of tool surface
88:43 - and let's actually try so i want to
88:45 - display this tool
88:48 - and this i get with
88:49 - self.displaysurface.lit
88:52 - and here
88:53 - i need a surface which is my tool
88:56 - surface and for now i'm going to place
88:58 - this at position 0 and 0.
89:02 - with that covered
89:04 - i have to make sure i actually call the
89:06 - display method of overlay and this
89:09 - happens after we are drawing all of the
89:12 - sprites
89:14 - you could just run this line all the way
89:15 - at the end of the run method so in here
89:18 - self.overlay.display
89:22 - and now let's try
89:24 - and now in the top left i can see my
89:26 - selected tool and if i change
89:28 - my selected tool this graphic updates as
89:31 - well
89:32 - so this is very nice
89:34 - the problem is it shouldn't be in the
89:35 - top left
89:37 - and for that we have to update these
89:39 - numbers here
89:40 - or to have a bit more control i want to
89:43 - create a tool rectangle
89:46 - and this one we get with tool surface
89:49 - dot get underscore rect and in here
89:53 - since i want the tool to be in the
89:55 - bottom left i want to place the mid
89:58 - bottom
89:59 - and the position here i am storing in my
90:02 - settings because in there i have overlay
90:05 - positions
90:06 - that way it's a bit easier to adjust all
90:08 - of the settings later on there are a lot
90:11 - more similar dictionaries in here as
90:13 - well
90:14 - so these are the numbers i do want to
90:16 - use
90:17 - which is quite simple all i have to do
90:20 - is i have to get my overlay
90:23 - positions
90:24 - let me just double check if i spell this
90:26 - correctly actually let me copy all of
90:28 - this
90:29 - and paste it in here that looks pretty
90:31 - good
90:32 - and in here i want to get my tool
90:36 - and now when i am
90:38 - using the blit method i want to use my
90:41 - tool rectangle for the positioning
90:44 - and now let's run this again and this is
90:46 - looking really good
90:48 - and with that all we have to do now is
90:51 - to copy all of this for the seeds and i
90:54 - think this could be a really good
90:55 - exercise for you
90:57 - basically what you want to do is copy
90:59 - all of this except now it should be for
91:01 - the seeds so pause the video now and if
91:03 - you want to follow along try this one
91:05 - yourself
91:09 - just as before
91:10 - i want to create a seed surface
91:13 - and this i get with self dot seed
91:16 - surfaces and in here self dot player dot
91:21 - selected underscore siege
91:24 - after i have that for the positioning i
91:26 - want to get a seed underscore rectangle
91:30 - and this i get with my seed
91:32 - surface this should not have an s
91:36 - and get underscore rect
91:38 - once again i want to place the mid
91:41 - bottom
91:42 - and the position here i can copy it from
91:45 - the tools
91:47 - i want to get my overlay positions and
91:49 - get the key seat
91:52 - that is going to be this one here
91:54 - finally all i have to do is self dot
91:56 - display surface dot
91:58 - lit
91:59 - and i want to have my seed surface
92:03 - and then my seed rectangle
92:06 - and with that
92:08 - let's run main.pi and we are getting an
92:11 - error that i forgot
92:14 - the square brackets here
92:17 - now let's try this again and there we go
92:19 - now on the bottom left we have the seats
92:21 - and the tools and we can switch between
92:23 - them this is working really well
92:26 - and is surprisingly satisfying
92:29 - all right cool with that we have the
92:31 - overlay that was all that was needed
92:35 - now that we have the player we can start
92:37 - working on the camera and the floor
92:40 - those two kind of have to come together
92:42 - because without the floor we wouldn't
92:44 - see what the camera is doing and without
92:46 - the camera we wouldn't be able to see
92:48 - what the floor is looking like in total
92:51 - and i know i am repeating myself a lot
92:53 - but for the camera there is a whole set
92:56 - of logic i will go over the basics but i
92:59 - have made a whole video on cameras in
93:01 - detail in pygame so check this one out
93:04 - if you want to go into much more detail
93:06 - once again here i have the code and
93:09 - before i do anything else i want to
93:11 - close a couple of files we don't need
93:13 - overlay anymore and we don't need the
93:16 - timer.pi anymore those two are basically
93:18 - finished and well we don't have to worry
93:20 - about them and i do want to keep things
93:22 - a bit more organized
93:24 - besides that the level should be right
93:26 - next to main.pi
93:29 - because those two files are the most
93:30 - important ones
93:32 - and inside level.pi i want to create the
93:35 - camera this is going to be a separate
93:37 - class
93:38 - and let me call it camera
93:41 - group
93:42 - and this one has to inherit from
93:44 - pygame.sprite.group
93:47 - basically what this one is going to do
93:49 - or how this one is going to work
93:51 - instead of putting all of the sprites
93:53 - into a normal pie game group we're going
93:56 - to create a special kind of group and
93:58 - via this group we're going to get the
94:00 - camera
94:01 - for that to work though first of all we
94:04 - have to initiate the
94:06 - group by itself and this one itself and
94:09 - nothing else and in here we need the
94:11 - super
94:12 - dunder init method
94:14 - so that the group works by itself
94:17 - now once we have that i can replace the
94:20 - group we created like an hour ago
94:23 - with the camera group and so far
94:27 - since we have basically created another
94:29 - group there shouldn't be any difference
94:31 - meaning if i run main.pi
94:33 - nothing has changed
94:35 - which is a good start at the very least
94:38 - we didn't break anything
94:40 - but now that we have more control over
94:42 - what the group is doing we can customize
94:44 - this thing quite a bit
94:46 - and one thing you could be doing for
94:48 - example is get
94:50 - self.display surface in here as well
94:53 - with pygame.display.get
94:56 - underscore surface
94:59 - that way this camera group can draw on
95:01 - the display surface straight away
95:03 - which you could use
95:05 - by creating a customize draw method and
95:09 - this one itself and nothing else at
95:11 - least for now
95:13 - now the way a normal group draws is
95:16 - bright so this line here
95:19 - essentially all that it does is it runs
95:21 - a for loop with four sprite in self dot
95:25 - sprites
95:27 - don't forget to call it for some reason
95:28 - this is a method
95:30 - and now in here we are calling
95:34 - the display surface with blit
95:37 - and then we are passing in sprite dot
95:39 - image and sprite dot rect
95:42 - this is basically all that is happening
95:44 - inside of a normal group for the draw
95:46 - method
95:48 - which is also the reason why every
95:49 - sprite always needs an image and a
95:51 - rectangle if you didn't have those you
95:54 - wouldn't be able to draw the sprite so
95:56 - they are mandatory
95:58 - so now that we have a customized draw i
96:00 - can comment out this draw here and
96:03 - instead i want to run
96:05 - self dot all sprites dot customize draw
96:10 - and let's call it actually let me call
96:12 - it custom draw that makes a bit more
96:15 - sense
96:16 - custom draw that is better
96:18 - and now if i run this
96:21 - everything still works just as before
96:23 - there's no difference
96:26 - although now we don't have to pass in
96:28 - the display surface anymore in here
96:30 - which already is a minor improvement
96:32 - although not that much of a difference
96:36 - with that we have a start for the camera
96:38 - logic although we don't have a camera
96:40 - yet but well this method is going to
96:43 - become quite a bit more extensive
96:45 - although right now we have a problem
96:48 - because any kind of camera i would
96:50 - create would be impossible to see
96:52 - because the background is pure black so
96:55 - even if we move left or right you
96:57 - wouldn't be able to see it because it's
96:59 - well all black
97:01 - as a consequence we first of all need
97:03 - some kind of floor so we can see what's
97:06 - going on
97:07 - and for that we have to import the floor
97:09 - now the floor is very simple it is one
97:12 - big image
97:13 - if i open the project folder inside of
97:16 - graphics there we have world and inside
97:19 - of there we have the ground and i guess
97:21 - let me open this one all this is is one
97:24 - big image
97:25 - and you can see here
97:28 - we have for example the trader and we
97:30 - have a whole bunch of objects all the
97:32 - way over here
97:34 - and
97:35 - the rest of the map so all of this stuff
97:38 - here is really empty
97:40 - all of this is going to work in detail i
97:42 - will explain in the next few sections
97:44 - for now just don't worry about them but
97:48 - don't worry i didn't make a mistake all
97:50 - of this is intentional
97:53 - so let me move this away and this image
97:56 - we want to import
97:58 - although for it to work we first of all
98:01 - need another class to actually use it
98:04 - inside of pygame
98:05 - and for that i want to create a new
98:07 - python file that i want to save
98:10 - as
98:11 - let's call it sprites.pi
98:14 - because in here we are going to have
98:15 - more than one
98:18 - and i want to import pygame and from
98:21 - settings import everything
98:24 - and for now we just want to create a
98:27 - very generic class so let me call it
98:29 - generic and this one is going to be
98:31 - sprite so pygame.sprite.sprite
98:35 - in here as always we need the dunder
98:37 - init method this one itself and besides
98:40 - that we need a couple of arguments we
98:43 - first of all need to position
98:45 - after that we need the surface we want
98:48 - to import or we want to use
98:50 - then we want the groups so
98:52 - this is kind of similar to the player
98:55 - where we have a position and a group so
98:58 - where the sprite should start and what
99:00 - group it should be part of however for
99:03 - the generic sprite it needs a surface
99:05 - because we might add different kinds of
99:08 - images in here
99:10 - now first of all on here as always you
99:12 - need the dander indeed method with the
99:14 - groups inside that is missing something
99:18 - that's looking better
99:19 - and now we need self.image and we need
99:22 - self.rect
99:24 - the image is just going to be the
99:26 - surface
99:27 - which means we're taking the surface
99:29 - from the arguments and passing it in
99:31 - here that's all that's going to happen
99:34 - and for the rectangle we get self.image
99:37 - dot get underscore rect and now we're
99:40 - placing the top left wherever the
99:42 - position is
99:44 - the position we are again getting from
99:46 - the arguments and passing it in here
99:48 - now we just have to figure out how to
99:50 - use it and this i am going to do inside
99:53 - of a level
99:54 - which means first of all i need from
99:57 - sprites import generic
100:01 - and now inside of setup
100:04 - i have to import it by using this
100:06 - generic class
100:08 - i want to create an instance of the
100:10 - generic class and now i need the
100:13 - different arguments for the various
100:15 - parameters let me copy them and paste
100:17 - them in here
100:18 - and let me use named arguments so this
100:21 - is a bit easier to see
100:24 - the position is super easy it's just
100:26 - going to be 0 and 0.
100:28 - or the this is terrible formatting
100:31 - [Music]
100:33 - let me clean this up a tiny bit
100:36 - for the surface all we have to do is to
100:38 - import pygame dot image and load
100:42 - and now we need the file path which is
100:45 - one folder up then we go into graphics
100:48 - then we go into world and then we get
100:52 - ground dot png
100:54 - as always don't forget to call convert
100:58 - alpha on all of this
101:00 - finally we need the groups and this one
101:02 - is easy just like for the player we need
101:05 - self dot all sprites
101:08 - this one should be working already so
101:10 - let me try and there we go now we can
101:12 - see the background and
101:14 - now we need the camera to see the rest
101:16 - of the level so right now we can only
101:18 - ever see the top left of the map which
101:21 - wouldn't be helpful but this is already
101:23 - looking much better
101:26 - however before we can do that there's
101:29 - one major problem right now the floor
101:32 - is only behind the player because we are
101:35 - creating it before we are creating the
101:37 - player which means if i created the
101:40 - player
101:41 - before this generic class and run this
101:43 - again
101:45 - we wouldn't be able to see the player
101:46 - because the player is behind the ground
101:49 - which is not well good at all
101:52 - and this leads us to one of the 3d
101:56 - effects we need for the game if you look
101:59 - at settings
102:01 - we have what is called layers all of
102:03 - this
102:05 - and this i want to use to draw the
102:08 - different elements of the map most of
102:10 - the game is going to happen inside of
102:12 - main
102:12 - in here for example we have the player
102:14 - all of the plants and the trees and
102:16 - stuff like that
102:18 - and the ground should be all the way
102:20 - here
102:22 - what we are essentially going to do
102:24 - inside of
102:26 - this custom draw method we are going to
102:28 - cycle through
102:29 - this list
102:31 - and then draw things one by one meaning
102:33 - the water will be drawn first then the
102:35 - ground then the soil then the soil water
102:37 - and so on and the rain drops all the way
102:39 - at the end
102:40 - that way we get a three-dimensional
102:42 - effect where different things are on top
102:44 - of other things there's actually going
102:46 - to be a second three-dimensional effect
102:48 - but that's going to come later i don't
102:50 - want to overwhelm you guys
102:51 - now for all of this to work we first of
102:54 - all have to assign each sprite
102:57 - one of these layers
102:59 - which means right now the sprites
103:01 - need one layer and the player is going
103:03 - to need a layer
103:05 - and let me get started for the player
103:07 - right below the rectangle i want to
103:10 - assign what i called z
103:14 - and z is just going to be layers so the
103:17 - dictionary from settings
103:19 - and the player should be on main
103:22 - so i can just copy it and paste it in
103:24 - here and now the player has a z position
103:28 - this means that inside of the game every
103:30 - single sprite has an x position
103:34 - we have a
103:36 - y position and besides that we are going
103:39 - to have a
103:41 - z position
103:43 - x and y are always going to come from
103:46 - the rectangle here and z is going to be
103:50 - a separate variable but both of those
103:52 - work very closely together
103:54 - now besides that for the sprites we also
103:57 - have to determine what the z position is
104:00 - going to be and this might potentially
104:03 - change
104:04 - as a consequence i want to have z as a
104:06 - parameter although here i do want to
104:09 - have a default parameter
104:11 - where if we don't get an argument z
104:13 - should be on the main layer
104:16 - and don't forget to turn the parameter
104:18 - into an attribute so self.z is going to
104:21 - be z
104:23 - now that being said
104:25 - for the ground so the ground we are
104:27 - creating here
104:28 - the floor is not supposed to be on the
104:31 - main layer instead
104:33 - it is supposed to be so z
104:37 - is supposed to be in layers
104:40 - and
104:41 - this key here is called ground
104:45 - let me copy it and paste it in here
104:48 - now we have a z position
104:51 - we just have to figure out how to
104:53 - actually use it
104:54 - this is going to happen in here
104:57 - and this i believe could be a really
105:00 - good challenge for you
105:02 - so try to use this dictionary here and
105:06 - draw elements by the order inside of
105:09 - this layer's dictionary meaning the
105:11 - higher the number is the later it should
105:13 - be drawn
105:14 - if you want a quick tip this should be a
105:17 - for loop but pause the video now and try
105:19 - to figure this one out let's see if we
105:21 - can do it
105:25 - the way this is going to work first of
105:27 - all we have to cycle through the layers
105:29 - dictionary let's call it for layer in
105:34 - layers dot values
105:36 - we don't actually care about the keys
105:39 - they just don't matter
105:41 - and all of the drawing is going to
105:43 - happen inside of this for loop
105:46 - and all i really want to do is i only
105:49 - want to draw a sprite so after going
105:51 - through all of the sprites i want to
105:53 - check if sprite dot z
105:56 - is actually the same as the layer the
105:59 - layer being one of the values of the
106:01 - layer's dictionary
106:02 - and only if that is the case
106:05 - i want to draw this layer
106:08 - and that should be it let's try
106:11 - and now i can see my player again
106:14 - even though the player is being created
106:18 - before we are creating the floor
106:21 - which means this logic here is working
106:24 - just fine cool so with that we actually
106:26 - already have some sort of camera but not
106:29 - a real camera yet
106:31 - let's actually work on it properly now
106:33 - so for the camera and
106:35 - once again check out my dedicated video
106:37 - on camera logic this one is really
106:39 - important to understand
106:41 - but first of all what we need here is we
106:44 - have to create some kind of offset and
106:46 - this is going to be a vector so
106:47 - pygame.math.vector2
106:52 - and how this is going to work think of
106:56 - this one here is the player and
106:59 - everything else so all of this stuff
107:01 - here
107:03 - is going to be the rest of the map and
107:05 - how the camera is going to work is if
107:07 - the player is moving to the right we are
107:10 - going to shift the entire map to the
107:13 - left now when i say shifty and time up
107:15 - to the left i don't mean to actually
107:18 - move it instead we are going to draw it
107:20 - in a different position the actual
107:22 - position doesn't change
107:25 - which means in practice when we are
107:27 - doing display surface dot blit
107:30 - spreader image is going to stay exactly
107:32 - the same
107:33 - which means in practice when we are
107:35 - calling thisdisplaysurface.blit
107:38 - this one doesn't change the position it
107:40 - just draws a sprite in a certain
107:42 - position wherever this rectangle is
107:44 - going to be but this rectangle you can
107:47 - move around perfectly
107:48 - fine and the way i want it to work is by
107:52 - making it relative to the player
107:54 - and for that first of all when i do
107:56 - custom draw i want to look at the player
107:59 - because this is what the camera should
108:01 - be following
108:02 - and now i want to have my offset
108:06 - dot x and i also want to do this for y
108:10 - and the logic here let me do it for x
108:12 - and y together because it's going to be
108:14 - fairly similar
108:16 - i want to look at my player.rect.center
108:20 - and for x is going to be x and for y
108:22 - it's going to be center y
108:24 - so right now i am getting the position
108:26 - of the player
108:28 - and from that i want to subtract this
108:31 - green
108:33 - and then for x this is going to be the
108:36 - width
108:37 - and for y this is going to be the height
108:39 - divided by 2 for both
108:43 - what that basically means is
108:45 - the offset is going to be by how much we
108:48 - are going to shift every single sprite
108:50 - relative to the player and we have to
108:53 - figure out by how much we want to move
108:55 - them
108:56 - and this logic here ensures that the
108:59 - player is always in the center of the
109:01 - camera
109:02 - if this one here is the player
109:05 - we always want to have an offset that
109:07 - points at the top left of the window
109:10 - which means we want to go half the
109:12 - screen width to the left and half the
109:14 - screen width up and then we're ending up
109:17 - on the point up here this is what we
109:20 - have to use to draw everything now for
109:24 - that first of all i want to create an
109:26 - offset rectangle
109:28 - and this we get with sprite dot image
109:32 - dot get underscore rect
109:34 - and this we get with sprite dot rect dot
109:38 - copy
109:39 - and this offset rectangle i actually
109:41 - want to offset so i want to get the
109:43 - offset rectangle again and now i want to
109:45 - move the center by minus equal the
109:49 - offset
109:50 - and this offside rectangle is what i'm
109:53 - going to use to draw the image and now
109:56 - there's one more thing we need and that
109:58 - is what i'm calling custom draw
110:01 - i have to insert the player
110:04 - fortunately we do have the player inside
110:06 - of self.player so let me pass it in here
110:10 - and now let's run all of this
110:12 - and now if i move around we have a
110:15 - camera
110:16 - and this is feeling pretty good we are
110:20 - definitely making progress
110:22 - although a lot of stuff is missing right
110:24 - now and this tends to look a bit weird
110:26 - but well we're getting there
110:32 - and i am fully aware that i didn't
110:35 - really go into detail for this entire
110:37 - logic so i hope you could kind of follow
110:39 - along
110:40 - but if you check out my videos on
110:42 - cameras this is explaining all of this
110:44 - in so much more detail so check this one
110:46 - out if you are interested
110:48 - the logic here unfortunately gets quite
110:51 - complex and i don't want this video to
110:53 - be 20 hours long
110:56 - but alright let me remove some white
110:59 - space and then we are basically done for
111:02 - this part
111:04 - in this part we are going to import all
111:06 - of the other elements and we are going
111:08 - to fake 3d a tiny bit more and i guess
111:12 - let's go for this one by one and let's
111:14 - start by importing all of the elements
111:17 - we have already done this to an extent
111:19 - but well now we have to do more of that
111:22 - now there is a tiny bit of theory that i
111:24 - do have to cover and that is that the
111:27 - entire game was designed entirely which
111:30 - is a free program that you can use to
111:32 - design levels it's really powerful
111:35 - and i am using another module called
111:37 - pytmx to import all of this data
111:40 - now let me go through what all of this
111:42 - means by looking at tiled here we go
111:45 - this is all of tiled so in here
111:48 - i could for example move things around
111:51 - and
111:52 - design the level to look slightly
111:54 - different
111:56 - and doing all of this took quite some
111:59 - time there's a ton of things in here so
112:02 - if you look on the top left there are a
112:04 - ton of layers that you could be working
112:05 - with
112:06 - and well all of this is very complex
112:10 - and once again i have made a complete
112:12 - video on all of this so if you want to
112:15 - have a ton of detail check that one out
112:18 - i just don't have the time for this
112:20 - video to go over titled separately all i
112:22 - am going to do is import all of this
112:24 - data into pygame
112:26 - so let's do all of that
112:29 - once more here i have my python setup
112:32 - and i want to continue working inside of
112:34 - level and let me minimize all of the
112:37 - methods so this is a bit easier to see
112:39 - and i can minimize the camera group
112:41 - now first of all i have to import pi tmx
112:46 - this happens with from pi tmx
112:50 - dot util underscore pygame
112:54 - i have to import load underscore pi game
112:58 - and really important here pitmx you have
113:01 - to install separately it does not come
113:03 - with python
113:05 - so either in the powershell or on the
113:06 - terminal type pip install pi tmx or pip3
113:09 - install pi tmx depending on mac or
113:12 - windows
113:14 - now this i want to use inside of the
113:16 - setup method and in here let me add a
113:19 - bit of white space
113:20 - first of all we have to load a file
113:23 - if i open the project inside of data we
113:27 - have map.tmx
113:30 - this is what i want to import all of the
113:32 - data is in here
113:34 - and this i am loading with load pi game
113:38 - and in here i need the path to this file
113:41 - i have to go one folder up then i have
113:43 - to go to data and in there we have map
113:46 - dot tmx
113:49 - and now we have to import a ton of
113:53 - different things so let's start by
113:56 - building the house i think this is quite
113:58 - good to illustrate how this is going to
113:59 - work
114:00 - now the house if i go back to tiled the
114:03 - house
114:04 - consists of a couple of different layers
114:06 - let me go through them one by one so if
114:08 - i hide all of them and zoom in let me
114:11 - hide all of this as well
114:13 - we have a house floor
114:15 - then we have house walls then we have
114:17 - the furniture at the bottom and then we
114:19 - have the furniture at the top and all of
114:21 - these layers we have to import
114:23 - separately
114:24 - and really important all of these have
114:27 - to be on a different layer inside of
114:29 - pygame
114:30 - which means back in pygame or the house
114:32 - we have a couple of different
114:34 - layers most importantly house bottom is
114:37 - going to be for the bottom and the rest
114:39 - of the house is going to be in main and
114:41 - this is really important
114:44 - so let's go through it one by one
114:46 - first of all to access the data i need
114:49 - to store all of this inside of a
114:51 - variable let me call it tmx underscore
114:53 - data and now i can use it
114:57 - and this has a ton of methods that we
114:59 - could be accessing the one i want to use
115:02 - now is called tmx data dot get
115:05 - underscore layer underscore
115:08 - by underscore name
115:10 - and now we need a name of a layer
115:14 - the one we could be using in here for
115:15 - example is house furniture bottom
115:18 - and this if i look at tiled
115:20 - is this name here house furniture bottom
115:25 - and what i want to do is to add tiles
115:27 - after this that way i am getting all of
115:30 - the tiles inside of this layer and i can
115:33 - use them inside of a for loop
115:35 - and
115:36 - what i'm getting here let me add the for
115:38 - loop first
115:41 - so this for loop is going to return a
115:42 - list that i can unpack right away and
115:44 - the list consists of x y
115:47 - and a surface
115:50 - really quick back in tiled
115:52 - when i'm only looking at the house
115:54 - furniture bottom and let me hide
115:57 - everything else
116:01 - and this is in house decoration there we
116:04 - go
116:06 - in this we have a couple of different
116:07 - tiles and each tiles is one of these
116:10 - well little cells inside of a grid i
116:14 - just want to import
116:15 - this carpet thingy and this other carpet
116:18 - thingy here this is all i really want
116:20 - and each of those is going to have an x
116:22 - position a y position and then what you
116:24 - see is the surface this is what we are
116:27 - importing which means i already have a
116:30 - class to capture all of this data that
116:32 - is my generic class
116:34 - and in here i need a position i need a
116:37 - surface and i need my groups oh and also
116:43 - i need the z position first of all for
116:45 - the position you might be tempted to
116:47 - just add x and y in here but that
116:51 - wouldn't be a good idea because this x
116:53 - and y position is not a pixel position
116:56 - instead if i return to tiled
116:58 - and zoom out a bit
117:01 - there you go
117:03 - the position we are looking at is the x
117:06 - and y position on this grid so for
117:08 - example all the way in the top left this
117:10 - cell here has the grid position zero and
117:13 - zero
117:15 - and the one to the right of it so this
117:17 - one here is going to have one and zero
117:20 - but all of these tiles have a size of 64
117:24 - by 64. so the actual starting position
117:26 - of this cell here
117:28 - is not going to be 1 and 0 it is going
117:31 - to be
117:32 - 64 and 0. we are essentially multiplying
117:36 - the position by 64 or rather the size of
117:40 - the tile
117:41 - and this position we have available in
117:43 - pie game as well it is inside of
117:46 - settings all the way at the top we have
117:48 - the tile size
117:49 - all i have to do is to multiply x and y
117:52 - by the tile size
117:54 - now the surface we already have it is
117:57 - just a surface we are importing up here
118:02 - then we need the groups and this one is
118:04 - also fairly easy because all we need in
118:06 - here is self dot or sprites
118:09 - and for z i want to have my layers
118:13 - and the house furniture bottom
118:16 - should be
118:17 - inside of the layer house bottom this
118:20 - one here
118:22 - let me copy it and paste it in here
118:24 - and this should be
118:26 - all we need
118:28 - there we go
118:29 - this should already be working now let's
118:32 - try
118:34 - and i do have to walk down a tiny bit
118:36 - because the house is somewhere down here
118:40 - there we go there we have a carpet and
118:42 - it is below the player because of the
118:43 - layers
118:46 - that is a really good start
118:48 - now there's a bit more stuff that i want
118:50 - to put on this layer and as a
118:53 - consequence
118:54 - i'm going to wrap this for loop inside
118:57 - of another for loop
118:59 - and what i want to do is four layer in
119:03 - the list
119:04 - in here i have
119:05 - house floor
119:07 - and then i have the house furniture
119:10 - bottom
119:11 - and now
119:12 - for x and y and surface
119:15 - is going to be
119:16 - for the layer
119:20 - this way i am using the same for loop
119:22 - for the house floor layer and for the
119:24 - house furniture bottom layer
119:26 - now if i try this
119:28 - we are getting an error because i forgot
119:31 - the colon so now let's try this
119:34 - and if i now walk down i should be
119:37 - seeing the house floor and the carpet
119:39 - this is looking pretty good
119:41 - although in here the one limitation is
119:44 - that this house floor has to come before
119:46 - the house furniture bottom this house
119:49 - furniture bottom is only drawn on top of
119:51 - the house floor because it's being
119:53 - created afterwards
119:55 - if we reverse the order here
119:57 - let me add it like this
119:59 - then you would not be able to see the
120:00 - house furniture bottom
120:02 - let me try it now
120:05 - and
120:07 - you can see you well cannot see the
120:09 - carpet
120:10 - but we only have two elements here so
120:13 - this isn't really that much of an issue
120:15 - this works just fine as it is
120:17 - with that
120:19 - we have
120:21 - two layers out of quite a few
120:24 - now this entire thing i now want to copy
120:28 - because there are two more layers that
120:29 - work in kind of the same way
120:32 - we have the house walls
120:35 - and we have the house furniture
120:38 - top those are going to work in basically
120:42 - the same way for this line and this line
120:44 - the one difference is that those two
120:47 - should be on the main layer
120:49 - and now let me try
120:51 - if i now walk to the house
120:54 - always takes a second
120:56 - yeah you can see the entire house
120:58 - right now
120:59 - it is always below the player but this
121:02 - we are going to change very soon
121:05 - but well we have a house admittedly this
121:09 - setup here could be a bit more elegant
121:11 - but i don't want to add too many for
121:13 - loops but you could totally do it if you
121:15 - want to
121:17 - there's quite a bit of repetition in
121:18 - these lines here
121:20 - alright there is one more thing that we
121:22 - do need and that is the fence
121:26 - let me illustrate this entitled
121:28 - he is entitled and right now everything
121:30 - is hidden so let me
121:33 - make most of the stuff visible so we can
121:35 - see what's going on
121:37 - the fence i'm talking about is this
121:39 - fence here this is what i want to import
121:42 - now
121:44 - and this is going to work very similar
121:46 - compared to the house
121:48 - which means this could be a really good
121:50 - exercise for you i want you guys to
121:52 - cycle through the layer is called fence
121:56 - cycle through this layer and import
121:59 - the surface with the x and the y
122:01 - position using the generic class and
122:04 - this should be inside of its own for
122:05 - loop
122:06 - so possibly now and try to figure this
122:08 - one out
122:12 - we need for x
122:14 - y and the surface in tmm
122:18 - x underscore data
122:20 - dot get layer by name and the layer we
122:23 - want to look at is called fence and here
122:26 - don't forget we need tiles
122:29 - once we have that we need the generic
122:31 - class
122:33 - and in here we need a position we need a
122:35 - surface we need a group
122:38 - and we need a layer
122:40 - or rather a z position
122:43 - the position is super easy this is the
122:45 - one we have already done multiple times
122:47 - let me just copy it from the house so
122:50 - position this one and surface we also
122:53 - already have
122:55 - now for the groups for now we only have
122:58 - a single spread group so self.all
123:00 - sprites is going to remain the same
123:03 - finally for z i do want the fence to be
123:06 - on the main layer and since that is the
123:09 - default parameter i can just leave it as
123:11 - it is as a matter of fact or this line
123:14 - here i could actually remove layers dot
123:17 - main because this is what we get anyway
123:20 - let's do it like this and now let's try
123:24 - and there we can see the fence this is
123:26 - looking very nice
123:32 - righty there are
123:34 - three more things that we do have to
123:36 - import we have the water
123:38 - we have the trees and we have some wild
123:41 - flowers
123:43 - and all three of those are going to be
123:45 - their own class because they are all
123:47 - slightly different so let's create some
123:51 - more classes
123:53 - this is all going to happen inside of
123:55 - sprite
123:57 - first of all i want to create a class
123:59 - called water and this is also going to
124:01 - be a sprite but the sprite we are
124:04 - getting from generic which means water
124:07 - is going to inherit from generic and
124:10 - since generic is a sprite water is also
124:12 - going to be a sprite
124:13 - and in here as always we need it under
124:16 - init method
124:18 - and this one needs self it needs a
124:21 - position
124:22 - it needs frames not a surface we need
124:25 - groups and we need z
124:28 - the major thing about the water is that
124:30 - the water is going to be animated
124:33 - and this means we kind of need the same
124:36 - setup for the animation that we have
124:38 - seen for the player it's inside of
124:40 - animate
124:41 - basically this kind of setup here
124:44 - so we need a couple of frames like we've
124:47 - seen in here and then we need an entire
124:49 - method to loop over all of these frames
124:53 - and the frames are going to be stored
124:55 - inside of the method frames
124:58 - let me add a comment here and let's call
125:01 - this animation setup in here we first of
125:04 - all need an attribute with frames and
125:06 - this is just going to be frames what we
125:08 - are getting from the parameters
125:10 - then we need self dot frame underscore
125:13 - index this is zero by default
125:16 - and once we have that
125:18 - we can start with the sprite
125:20 - setup and in here all we need is this
125:23 - super
125:24 - dunder init method
125:27 - and for this one we need the init method
125:30 - of the generic class all of these
125:32 - parameters here
125:34 - position is what we are getting from the
125:37 - position from the water and let me use
125:39 - named arguments here that is a bit
125:41 - easier to follow i think
125:43 - for the surface i want to get myself dot
125:46 - frames and then here self dot frame
125:50 - underscore index
125:53 - and this should probably be on multiple
125:55 - lines otherwise it's kind of hard to
125:58 - read
125:59 - for the groups all i want is the groups
126:01 - i am getting
126:02 - from the parameters of the water class
126:05 - and finally for z
126:07 - all we need here is inside of settings
126:10 - we have water
126:12 - this is what i want to pass inside of
126:15 - the z argument here
126:17 - and this doesn't animate yet but we do
126:20 - need a few more things so back a level
126:23 - let's start creating this thing
126:25 - and first of all as always i need this
126:28 - kind of line here so let me just copy it
126:32 - the name of the layer we need here is
126:34 - called water
126:35 - and what i want to do is to create a
126:38 - water tile although right now we don't
126:40 - have water available inside of level
126:44 - meaning besides generic i want to import
126:46 - water
126:47 - for this one we need all of these
126:51 - parameters
126:53 - position is going to remain basically
126:56 - the same i can just copy things and
126:58 - paste them in here
126:59 - the other easy one is the groups because
127:01 - once again we only have a single group
127:03 - so far so this is always going to be all
127:06 - sprites
127:08 - the problem we have is we need the water
127:11 - frames
127:12 - which if you open the project folder
127:15 - again are inside of graphics and in
127:18 - there we have water and we have four
127:20 - different frames and these we want to
127:22 - animate
127:23 - but for that we have to import all of
127:25 - them
127:26 - fortunately we already have a function
127:29 - that imports an entire folder and
127:31 - converts it into surfaces the same thing
127:34 - we have used for the player so we can
127:36 - reuse all of this
127:39 - for that to work though we first have to
127:41 - make it available inside of level.pi
127:44 - which means from support i want to
127:47 - import everything
127:49 - and now i can use import folder
127:52 - and for the water i want to have some
127:54 - water frames
127:56 - and this is going to be input folder
127:59 - and the file path we need here
128:02 - is one fold up then we have graphics and
128:05 - then we have water
128:07 - and these water frames we want to use in
128:09 - here
128:10 - and now let's see if this is going to
128:13 - work already
128:14 - so if i move over this side there is
128:18 - going to be some water this is looking
128:20 - really good
128:21 - and if i move further down we should be
128:23 - able to see some more water
128:26 - there we go so now we have water except
128:29 - it's all static so now we have to
128:31 - animate it
128:32 - that is going to happen inside of
128:34 - sprites and in here
128:37 - i want to create an animate function or
128:40 - well method in itself and delta time
128:45 - i think we could do another really good
128:47 - exercise so like for the player
128:50 - we have to create an animate function so
128:53 - try to create this one for the water
128:55 - basically what you have to do is copy
128:57 - the thing you have seen for the player
128:58 - and then make sure you're actually
129:00 - calling it
129:01 - so try this one yourself and see if you
129:03 - can figure it out
129:07 - i think a really good way here is to
129:09 - look at both of the files next to each
129:11 - other it's a bit hard to see but i hope
129:14 - you get the idea we are basically going
129:15 - to copy all of this so first of all we
129:19 - need self dot frame index
129:22 - and we want to increase this by a
129:24 - certain number for the water i went with
129:27 - 5 and multiply this by delta time but
129:30 - this 5 here is entirely subjective play
129:32 - around with this
129:34 - after that
129:35 - i want to check if myself dot frame
129:38 - index is greater or equal than the
129:41 - length of self dot
129:44 - frames if that is the case i want to set
129:48 - self dot frame index to zero
129:52 - finally i want to update self dot image
129:56 - and this is going to be
129:58 - self dot frames and in here don't forget
130:02 - we need an integer of self dot frame
130:06 - index
130:07 - and that is all we need all we have to
130:10 - do now is to figure out when to call
130:12 - this animate method and this we are
130:14 - doing inside of the update method
130:16 - in here we need self and delta time
130:19 - and all i really have to do in here is
130:21 - call self dot animate and pass in delta
130:24 - time
130:25 - technically you could just add all of
130:27 - these lines here and paste them inside
130:29 - of the update method
130:31 - it would work perfectly fine but i think
130:33 - this is a bit more organized it well
130:35 - it's entirely up to you
130:37 - but now we should be having animated
130:39 - water let's try and let's walk to the
130:42 - water
130:44 - and there we go we have animated water
130:47 - this is looking quite nice
130:52 - so i can minimize the water and now we
130:55 - can work on the next kind of sprite
130:58 - i guess a really easy one would be the
131:00 - class wild
131:02 - laurer
131:04 - and this one like the water has to
131:06 - inherit from generic
131:08 - and in here we need a dunder init method
131:11 - and this one needs self it needs a
131:13 - position it needs a surface and we need
131:16 - the groups
131:18 - and after that we need a super and a
131:21 - dunder init method and once again
131:25 - we need
131:26 - these three parameters
131:29 - we don't need z because all of the
131:31 - wildflowers are supposed to be on the
131:33 - main layer
131:34 - and the wildflowers for now are going to
131:37 - stay just like that we're not going to
131:39 - make any more changes although later on
131:42 - they are going to change a tiny bit
131:44 - which is why we need a separate class
131:47 - but now that we have them inside of
131:49 - level.pi i want to import the wild
131:53 - flower
131:54 - and this one
131:55 - if i copy these two lines here
132:00 - i want to look at the layer called
132:02 - decoration
132:05 - let's have a look at tiled how this
132:06 - looks
132:07 - the layer i am looking at is this one
132:10 - here decoration
132:11 - and in there if i hide and unhide it
132:15 - it's all of these small elements inside
132:17 - of the foresty area
132:19 - and these i want to import
132:21 - now there if you look at the layers in
132:23 - the top right
132:25 - these are slightly different compared to
132:26 - the tile layers we have already seen
132:29 - basically these are objects and this we
132:31 - can move around easily
132:32 - whereas these with the square icon are
132:36 - all tiles
132:38 - but again check out my original video it
132:40 - explains all of this in much more detail
132:42 - the difference honestly isn't that bad
132:45 - i shouldn't have actually copied this
132:47 - line instead what i should have been
132:49 - doing is for obj in tmx data dot get
132:54 - layer by name
132:56 - and the layer we are looking at is
132:57 - called decoration this one doesn't
132:59 - change
133:00 - and now in here we are getting an obj
133:04 - and this obj has an x it has a y and it
133:08 - has an image and this one is the surface
133:11 - so this is what we are going to use
133:13 - and now i want to create a wild flower
133:18 - and in here let me copy the parameters
133:21 - we need we need a position we need a
133:24 - surface and we need the groups
133:26 - for the position we need obj.x and obj.y
133:31 - and those are actual pixel positions so
133:34 - we don't have to multiply them with
133:35 - anything
133:37 - for the surface we need obj dot image
133:41 - and for the groups once again we need
133:43 - self dot
133:44 - all sprites
133:46 - let's run this again and now we can see
133:49 - a whole lot more stuff on the map
133:52 - this is already starting to look much
133:54 - better
133:56 - finally we are going to need some trees
134:00 - so i'm going to create a class called
134:02 - tree
134:03 - this one is also going to inherit from
134:05 - generic
134:07 - and in here we need a dunder init method
134:10 - with self we need a position we need a
134:13 - surface we need the groups
134:15 - and besides that i also want to have a
134:17 - name of the tree
134:19 - why that name is going to matter let me
134:22 - visualize all of this entirely
134:25 - inside of tiled here you can see all of
134:28 - the trees and they all have a name the
134:30 - name you can see here so a tree could be
134:32 - called small or large
134:35 - and this is what i want to use for the
134:38 - name that way i can tell if a tree is
134:40 - going to be small or large that's
134:42 - basically all it is
134:44 - although later on this is also going to
134:45 - determine where the apples are going to
134:47 - be on the tree
134:49 - for example for a larger tree we would
134:52 - have this entire surface to place apples
134:54 - or a small tree we would only have this
134:56 - surface here
134:58 - and inside of here i want to have a
135:00 - super dunder init method
135:04 - and this one is going to need a position
135:06 - a surface and the groups
135:09 - all of these we are getting from the
135:11 - parameters so we can just leave it as it
135:13 - is
135:14 - although later on the trees are going to
135:16 - become quite substantially more
135:18 - extensive
135:19 - but for now all we have to do is
135:23 - or obj in tmx data.get layer by name
135:29 - and the layer i am looking for is called
135:31 - trees
135:34 - and in here i want to create a tree
135:36 - although first of all i do have to
135:38 - import it with three
135:41 - and the arguments we need let me copy
135:44 - the parameters
135:46 - the position we can just copy from the
135:49 - wildflowers this one here
135:51 - so position is covered
135:54 - the surface is going to be obj.image
135:57 - for the groups once again
135:59 - we have self dot all sprites
136:02 - and for the name this one we get with
136:04 - obj.name
136:06 - [Music]
136:07 - and now if we run this
136:11 - here you can see a huge amount of trees
136:14 - and this is looking really nice
136:17 - so the entire thing is definitely coming
136:18 - together
136:20 - so there's only one more thing that i do
136:22 - want to cover although for that we need
136:24 - a tiny bit of theory let's talk about it
136:27 - i want the various elements to overlap
136:30 - at the very least the elements inside of
136:32 - the main layer so for example if the
136:35 - player is behind in the y-axis it should
136:38 - be drawn below the other elements for
136:41 - example if we have the player here and
136:43 - the player is behind a sunflower the
136:45 - player should be behind the sunflower or
136:48 - rather below the sunflower
136:51 - and if the player is in front and the y
136:54 - axis the player should be drawn in front
136:56 - of the other elements so if the player
136:58 - is in front of it it should be drawn on
137:00 - top of the sunflower and this effect is
137:03 - really nice in the game it makes it look
137:05 - much better
137:06 - it's also very easy to implement so
137:08 - let's jump right in back in the code i
137:10 - want to minimize the setup method
137:13 - and i want to work inside of the camera
137:16 - group
137:17 - i have to work inside of all of this and
137:20 - this line here in particular is really
137:22 - important because right now we are just
137:25 - drawing or well cycling through all of
137:28 - the sprites and this
137:30 - i want to sort
137:33 - and the way i want to sort it let's say
137:35 - we have two elements like this
137:38 - i want to sort them by the white
137:40 - position which means
137:42 - the further down the center of a sprite
137:45 - is the later it should be drawn in this
137:48 - case this right here should be drawn
137:50 - first and this sprite should be drawn
137:52 - after that that way this sprite here is
137:54 - always on top of this other sprite
137:57 - and since this is going to happen on
137:59 - every single frame of the game this can
138:01 - also change to get all of this
138:04 - we need a key for this sorted function
138:08 - this always has to be a lambda function
138:10 - and into this lambda function i want to
138:12 - pass in this sprite
138:14 - what i want to look at from the sprite
138:16 - is
138:17 - sprite.rect.center y
138:20 - that is literally all i needed so now if
138:23 - i run out of this again
138:25 - you can already see it with the fence
138:26 - but it's kind of weird but the
138:28 - sunflowers make it look much nicer
138:30 - so now
138:33 - the player
138:34 - can walk through all of this and it's
138:37 - looking significantly better
138:39 - so this is really really nice
138:43 - and that way the game feels much more
138:45 - three-dimensional
138:46 - it also works with the house let me walk
138:48 - there
138:49 - so for example here
138:52 - we can walk through all of this
138:55 - and well this is very very nice
138:59 - cool this was a very large section but
139:02 - we basically imported the entire game so
139:05 - massive progress
139:07 - with the level and the player in place
139:09 - we can work on the collisions and let me
139:12 - cover a tiny bit of theory how the
139:14 - collisions are going to work first
139:15 - because that can be kind of confusing
139:18 - let's say we have an object here
139:22 - and we have the player moving in some
139:24 - kind of direction and we want to check
139:26 - if the player is colliding with this
139:28 - obstacle
139:30 - what we are going to do for that is
139:32 - we are first going to check if the
139:34 - player is overlapping with the obstacle
139:36 - for example the player could be here and
139:38 - we have an overlap detecting this is
139:41 - really easy the difficult bit is to
139:43 - figure out where the collision came from
139:46 - in this case it might look like the
139:48 - collision came from this side but it
139:50 - might have happened that the player was
139:51 - moving really fast in this direction for
139:53 - example or the player could have come
139:55 - down this side here
139:57 - as a consequence we're going to add a
139:59 - bit more code to figure out where the
140:01 - player came from
140:02 - in this case since the only object that
140:04 - can move is the player we can check the
140:07 - player direction so for example if the
140:09 - player was moving in let's say
140:12 - this direction here we know the
140:13 - collision must have happened on this
140:15 - side because the player was moving in
140:17 - this direction
140:19 - and once we have that bit of information
140:21 - let me clean this up a tiny bit
140:23 - if we know that the player moved in this
140:25 - direction and our collision happened
140:27 - here
140:28 - then we want to move the player
140:30 - back to
140:32 - something like this
140:34 - and then we have the entire collision
140:37 - logic
140:39 - it honestly isn't that bad but you do
140:41 - need some theory here and one more time
140:44 - i made a whole separate video on it so
140:45 - check this one out if you are interested
140:48 - but other than that let's implement all
140:50 - of this alrighty here i'm back in the
140:52 - code and i want to do a couple of things
140:54 - first before we start with the collision
140:57 - logic the most important part is that
140:59 - all of the sprites let me minimize them
141:04 - there we go all of the sprites and the
141:06 - player are going to need a hitbox or
141:09 - some kind of collision rectangle
141:11 - we could be using the rectangle itself
141:14 - but that would not be a good idea
141:17 - for two reasons actually first of all
141:19 - for the player the rectangle is going to
141:22 - be really large
141:24 - if i open the project folder inside of
141:26 - graphics and let's look at the character
141:29 - for something like left x
141:32 - in here if i open this okay it's going
141:34 - to be very hard to see but if i zoom in
141:37 - you can kind of see by the shade this
141:39 - entire surface here has a size of this
141:43 - this is the entire image and the
141:45 - rectangle we are creating from this has
141:48 - the same dimensions and this is much
141:50 - larger than the actual image the reason
141:52 - why it is so large is because we have to
141:54 - capture the entire image and the bunny
141:57 - has to be in the middle
141:59 - if that wasn't the case the character
142:01 - would move around if the size changed so
142:03 - all of these surfaces have the same size
142:05 - and that is really important
142:08 - because of that we couldn't use the
142:09 - rectangle but what we can do
142:13 - is create self dot hitbox
142:16 - and this hitbox is what we actually use
142:18 - for the collisions
142:20 - and for this one all i want to do is
142:22 - self door direct dot copy so we are
142:25 - copying the rectangle and this i want to
142:28 - inflate
142:29 - all that inflate is doing is it takes a
142:31 - rectangle and it changes the dimension
142:34 - while keeping it centered around the
142:36 - well center
142:38 - as an argument here we need a tuple with
142:41 - a width and a height by how much we want
142:43 - to shrink or increase it in my case i
142:45 - want to shrink it by 126 pixels on the
142:48 - horizontal axis and negative 70 pixels
142:51 - on the vertical axis
142:53 - next up this hitbox has to be moved
142:56 - along with the rectangle
142:58 - and this is going to happen inside of
143:01 - the move method
143:03 - so in here what i usually do is
143:06 - after i've moved the position i am
143:09 - moving the hitbox so self.hit
143:12 - that is terrible spelling self dot
143:14 - hitbox
143:15 - dot center x
143:19 - is going to be self.pos.x
143:24 - and then self.rect.centerx
143:27 - is going to be self.hitbox.centerx
143:32 - although in here i actually realized i
143:35 - forgot one important thing and that is
143:38 - that this self deposited x needs to be
143:41 - rounded
143:42 - if we didn't include that pygame would
143:44 - truncate these values which means a 1.9
143:48 - for example would be truncated to one
143:52 - whereas the proper value would be a two
143:55 - and this is what we get by rounding
143:57 - which is why we need the rounding here
143:59 - if you don't do that you are going to
144:01 - get occasionally wrong behavior
144:04 - or well incorrect behavior
144:06 - but all right now that we have that i
144:08 - have to do the same thing for the
144:09 - vertical movement so self.hitbox.center
144:13 - y
144:14 - is going to be rounded self dot pos dot
144:17 - y
144:19 - and now self.record center y is going to
144:21 - be
144:23 - self.hitbox.center y
144:25 - with that we have a hitbox for the
144:27 - player and now all of the sprites are
144:29 - going to need a hitbox as well
144:31 - let's start with generic and in here i
144:35 - just want to create a hitbox with
144:37 - self.rect.copy
144:41 - and this i want to inflate and the
144:44 - number here i want to be a bit more
144:46 - flexible so for the wife i went with
144:48 - negative self.rect.with
144:52 - and multiply this by 0.2
144:56 - then i'm going to copy all of this
144:58 - and then for the height
145:01 - this is going to be self.rect.height
145:03 - multiplied by negative 0.75
145:08 - the numbers here you definitely just
145:10 - want to play around with it is fairly
145:14 - subjective it really depends how you
145:16 - want this to look
145:17 - mostly for the width you want to have a
145:19 - fairly small number because you don't
145:21 - want to shrink it too much on the
145:22 - horizontal axis
145:24 - for the vertical axis you do actually
145:26 - want quite a large number and this again
145:28 - is because of the overlap let me show
145:31 - the slide again actually
145:33 - the overlap for all of this works really
145:35 - well because when we created this there
145:37 - was no collision but once we have
145:40 - collision we really have to be aware
145:42 - that this
145:44 - rectangle here shouldn't be too tall
145:47 - because if the sunflower would have a
145:49 - collision rectangle that covers the
145:51 - entire height
145:52 - the main character would never be able
145:54 - to go behind it we would always get
145:56 - stuck on top as a consequence you do
145:58 - want quite a high negative number for
146:00 - the vertical axes
146:03 - all right with that let me minimize the
146:04 - generic class so we have a lot of space
146:07 - water doesn't need any hitbox because it
146:09 - cannot be collided with and next up we
146:12 - need the wildflower
146:13 - and this is now the reason why this is a
146:16 - separate class because in here i want to
146:18 - have a hitbox and this is going to be
146:21 - self dot rect
146:23 - dot let me copy it and then i want to
146:26 - inflate the entire thing
146:28 - and i want to inflate this by static
146:30 - numbers for the horizontal axis which is
146:32 - negative 20 and for the height i want to
146:35 - go with negative self.rect.height
146:39 - and this i want to multiply with
146:43 - 0.9 finally we have the tree
146:47 - although in here we don't actually have
146:49 - to make too many changes because the
146:50 - tree can take the hitbox from the
146:53 - generic class so this hitbox is still
146:55 - going to apply
146:57 - inheritance here makes our life a lot
146:59 - easier
147:00 - that covers a lot of the setup there's
147:02 - one more thing that we need back in
147:04 - level inside of the init method i need
147:08 - another group
147:09 - the group i want to create is called
147:11 - self dot collision
147:14 - sprites and this is going to be a plain
147:16 - pie game.sprite.group
147:19 - the only reason i'm going to create this
147:21 - group is because i have to keep track of
147:24 - what sprites can be collided with so any
147:26 - sprite the player can collide with is
147:28 - going to be inside of this group and
147:30 - inside of this group that way i can
147:32 - identify them easily which makes my life
147:34 - a lot easier
147:36 - and now when we are creating all of the
147:40 - collidable sprites
147:42 - that is going to be for example
147:45 - defense we can collide with so in here
147:49 - self. all sprites
147:51 - i want to put in a list and besides that
147:53 - self.collision sprites
147:56 - the same is also going to apply
147:58 - to the trees and to the decoration
148:02 - so let me target both
148:05 - and all sprites should be in a list
148:07 - along with
148:08 - self.collision sprites
148:11 - you might be wondering if house walls
148:13 - and house furniture top also need
148:15 - collision sprites
148:16 - the answer is not really but i'm going
148:19 - to cover that in just a bit
148:22 - but that's going to come in just a bit
148:26 - the one thing we need now is that the
148:28 - player needs to know where all of the
148:30 - collision sprites are because we are
148:32 - going to run the collision method inside
148:34 - of the player
148:35 - which means i want to pass
148:38 - self.collisions sprites into the player
148:42 - i do want to mention here for the player
148:44 - the player sprite is inside of all
148:46 - sprites and then besides that the player
148:49 - is going to have a separate parameter
148:51 - for the collision sprites but the player
148:53 - sprite itself is not inside of the
148:56 - collision sprite we just have a
148:58 - reference to it whereas the decorations
149:01 - are both in all sprites and in the
149:04 - collision sprites this is a
149:06 - fundamentally different concept here so
149:08 - i hope you get the difference but now to
149:10 - make all of this work inside of player
149:12 - the player is going to need one more
149:13 - parameter and let's call this the
149:15 - collision
149:17 - sprites
149:19 - and this we have to capture let me put
149:22 - it below the movement attributes in here
149:25 - we have collision and i want to get
149:27 - myself dot collision sprites
149:31 - as an attribute
149:33 - and i guess to keep things organized i
149:35 - could put the hitbox in here as well it
149:37 - does seem to make sense
149:39 - and now i can minimize the indent method
149:41 - and now
149:43 - inside of the move method
149:44 - we can work with the collisions or more
149:46 - specifically i want to create a separate
149:49 - method that i'm going to call
149:52 - collide
149:54 - actually i guess collision makes a bit
149:56 - more sense
149:57 - it doesn't really matter and in here i
149:59 - need self and i need the direction
150:03 - first of all in here
150:04 - i want to look at every single sprite
150:06 - inside of the collision sprites so for
150:09 - sprite in self dot collision sprites dot
150:13 - sprites
150:14 - in here i want to check has attribute
150:18 - if this sprite i am looking at has an
150:21 - attribute called hitbox
150:24 - they should all do but this is a good
150:26 - way to make sure and that we just skip
150:28 - any kind of collision if that isn't the
150:30 - case it well makes our life a bit easier
150:33 - now once i have that i want to check if
150:35 - there's any kind of overlap and this i
150:37 - get with sprite dot hitbox dot polite
150:42 - rect and now i want to check with self
150:44 - dot hitbox
150:46 - if that is the case we know there is
150:49 - going to be some kind of overlap the
150:51 - problem is we don't know where the
150:53 - overlap came from this is why i talked
150:54 - just a second ago so here we have an
150:57 - obstacle and the player might be
151:00 - somewhere here
151:01 - we know the overlap is here the problem
151:04 - is we don't know where the player came
151:07 - from the player could have come from
151:08 - here the player could have come from
151:10 - here the player could have even come
151:11 - from here and moved really fast meaning
151:14 - we have to figure out where this came
151:16 - from
151:17 - and the best way to think about this is
151:20 - first of all you want to separate the
151:22 - dimensions so we first have
151:25 - let me call it we first have horizontal
151:27 - and after we have done that we are doing
151:30 - vertical
151:31 - this is also the reason why down here we
151:34 - split the movement into horizontal and
151:36 - vertical movement
151:38 - in here
151:39 - the logic gets much easier we still have
151:41 - an obstacle
151:42 - and now the player overlaps again
151:44 - something like this but now we only have
151:47 - to check if the collision happened on
151:50 - the left or on the right
151:53 - now it's still perfectly possible that
151:56 - the player came this way here and moved
151:58 - really fast
152:00 - so i want to check the direction of the
152:02 - player meaning if the player was moving
152:04 - to the right
152:06 - i know that the collision must have
152:08 - happened on the left because if the
152:09 - player is moving to the right any kind
152:11 - of collision has to happen on the left
152:13 - of the obstacle meaning this side here
152:17 - and this is what we have to implement
152:19 - now
152:20 - first of all i want to check the
152:22 - direction and if this is horizontal
152:27 - then i want to check the player
152:28 - direction so if self.direction.x
152:33 - is greater than zero if that is the case
152:36 - we are moving right or the player is
152:39 - moving right
152:40 - as a consequence if there is a collision
152:43 - then i want to set self.hitbox.write
152:47 - is going to be
152:50 - sprite.hitbox.left and besides that if
152:55 - self.direction.x is smaller than zero
152:57 - this means we are moving left
153:01 - then self.hitbox.left
153:04 - is going to be sprite
153:06 - dot hitbox dot right
153:09 - there are two more things we need in
153:11 - here and that is we have to update
153:13 - self.rect.centerx
153:16 - so the rectangle the player actually
153:18 - sees because right now we are just
153:20 - updating the hitbox we're not updating
153:22 - the rectangle itself so
153:25 - where the player appears on the screen
153:28 - and this should be
153:29 - whereself.hitbox.centeraxis
153:32 - finally for the movement we have to
153:34 - update self.post.x
153:36 - and this i also want to set
153:37 - wereself.hitbox.centerxis
153:41 - and this is the entire logic for the
153:44 - horizontal collisions
153:47 - all i have to do now is after we have
153:48 - done all of the movement for the
153:51 - horizontal movement then i want to call
153:53 - self dot
153:55 - collision
153:58 - like this
153:58 - and pass in horizontal in here and now
154:02 - this should be working let's try
154:04 - if i now
154:06 - okay this is getting a bit weird because
154:08 - we spawned on something but if i just
154:10 - move left and right
154:12 - we definitely have some collisions now
154:14 - if i move up and down this doesn't work
154:16 - at all but just by itself this is
154:18 - looking pretty good
154:22 - which means all we have to do now
154:25 - is to also check
154:27 - if direction
154:30 - is equal to
154:32 - vertical
154:34 - let me add a bit of white space here
154:36 - and this is going to be your exercise
154:39 - basically what i want you guys to do is
154:40 - to copy the logic here and apply it on
154:43 - the vertical axis
154:45 - so pause the video now and see if we can
154:47 - figure this one out
154:51 - first of all i want to check if
154:53 - self.direction.y
154:56 - is greater than zero if that is the case
154:59 - i know i am moving down
155:02 - which means i want to set
155:03 - self.hitbox.bottom
155:06 - to sprite.hitbox.top
155:10 - i guess let me draw what this means
155:13 - this line here means we are checking if
155:16 - the player is moving down so the player
155:19 - like this is moving down
155:22 - and now we also know that there has been
155:24 - some kind of collision
155:26 - the collision object now is pink i hope
155:28 - it still makes sense
155:30 - and now we have to resolve this
155:31 - collision
155:33 - this is happening inside of this line
155:35 - here
155:36 - we are putting the bottom of the player
155:38 - this line here at the top of the
155:41 - obstacle
155:43 - which means we are moving the player up
155:45 - by this amount and that way it appears
155:48 - that the player is on top of the
155:49 - obstacle
155:51 - and it appears like that because it
155:53 - literally is so next up we need
155:55 - self.direction.y
155:58 - is smaller than zero and if that is the
156:00 - case we are moving up
156:04 - and this means
156:07 - top self.hitbox.top going to be sprite
156:08 - dot hitbox dot autumn
156:11 - besides that we also have to update
156:15 - self.rect.center y and this is going to
156:18 - be self.hitbox.center
156:21 - y
156:23 - and finally besides that
156:25 - self.post.y is also going to be
156:27 - self.hitbox.center y
156:29 - and with that we have the entire
156:32 - collision logic
156:33 - so let's try
156:35 - and we do have a bit of a problem
156:37 - because we always spawn outside of this
156:39 - fence
156:40 - which causes a few problems
156:42 - so let me move around here
156:45 - and now if i just move around the forest
156:48 - here there's lots of things i can
156:49 - collide with
156:54 - and
156:55 - we do have some problems so
156:58 - something is not right and i think i
156:59 - know what it is
157:01 - because back in the player
157:03 - i am not calling the collision after the
157:05 - vertical movement
157:07 - meaning let me copy the collision here
157:10 - and this should be vertical
157:12 - now let's try this again
157:14 - so now we have the same problem we are
157:16 - spawning right on top of a fence which
157:18 - causes weird behavior but other than
157:19 - that
157:21 - now we have proper collisions
157:24 - let's see if this is working this is
157:26 - looking pretty good
157:29 - and if i walk through here i can walk
157:31 - behind the bushes but i cannot walk
157:33 - through all of the trees
157:36 - and
157:37 - this is looking pretty good
157:43 - so i am quite happy with this
157:48 - nice this is working very well
157:51 - there are two problems we have right now
157:54 - number one is the starting position of
157:56 - the player meaning inside of setup the
158:00 - player is just being spawned in a random
158:02 - position which isn't ideal
158:05 - and besides that
158:06 - we need some kind of mechanism to
158:09 - prevent the player from moving outside
158:11 - of the map so like this
158:13 - and let's go through them one by one
158:16 - the starting position of the player is
158:17 - the easier thing and for that we need
158:20 - tiled once more if i open this one
158:23 - there is an entire layer called player
158:26 - and inside of that we have a couple of
158:30 - objects and one is called start this is
158:33 - a simple node
158:34 - and this one we can use to set positions
158:37 - and this is where i want to spawn the
158:38 - player which means back in my code i
158:42 - let me add another comment here
158:45 - player is probably the best name for
158:47 - this spelling it correctly would also
158:49 - help
158:50 - what i want to do in here is for obj in
158:54 - tmx data dot get layer by name and this
158:58 - layer is literally called player
159:01 - and what i want to check is if obj.name
159:04 - is equal to
159:06 - start
159:07 - if that is the case i want to create the
159:11 - player
159:12 - and the starting position of the player
159:14 - is going to be obj
159:16 - dot x and dot y
159:20 - if i run this again we are starting
159:22 - right in the middle of the map so this
159:24 - is much better
159:28 - now we have to figure out the other
159:30 - kinds of collision so let me run the
159:32 - game again i can for example just walk
159:34 - through the house which feels a bit
159:36 - strange
159:39 - for that if i open tiled again
159:41 - there is an entire layer called
159:43 - collision if i make this one visible you
159:45 - can kind of tell what's going on
159:47 - i basically drew
159:49 - a couple of tiles all across the level
159:53 - and this is limiting the player
159:55 - this is what i want to import and then
159:57 - use it for collisions this i am doing
159:59 - inside of level and let me do it
160:02 - i guess right before the player makes
160:04 - sense
160:05 - and here i want to have some collision
160:08 - tiles and that is some terrible spelling
160:11 - collision tiles
160:13 - since we are now working with a tile
160:15 - layer again i want for x
160:18 - y and surface
160:21 - in
160:22 - emx data dot get layer by name
160:26 - this layer is called collision don't
160:28 - forget we also need tiles
160:31 - in here i want to create a generic tile
160:34 - and this one is going to need a position
160:36 - a surface and a group
160:39 - what you have to consider here is that
160:42 - for the group i want to only place it in
160:45 - self dot collision sprites
160:48 - this is the one sprite that is not going
160:50 - to be in all sprites
160:52 - as a consequence it is not going to be
160:55 - drawn or updated but it is going to
160:57 - exist and since this one isn't going to
160:59 - move we don't really have to update it
161:02 - that way even though we have a sprite
161:05 - with a surface it is not going to be
161:07 - visible
161:08 - but besides that everything else remains
161:10 - basically the same so i have x and y
161:13 - and both of these need
161:17 - to be multiplied with the tile size
161:21 - for the surface
161:23 - all i really want to do is create a pie
161:25 - game dot surface
161:27 - and this one should be
161:29 - tile size and tile size
161:32 - that way we are creating a empty surface
161:35 - or well a black surface with the
161:37 - dimensions of 64 by 64 which is all we
161:41 - need for this sprite
161:43 - and with that we should be having
161:45 - collisions so let me run main.pie again
161:48 - i am not able to walk through the house
161:50 - anymore
161:51 - on top of that if i try to walk on the
161:53 - water
161:54 - i can also not do that anymore and if i
161:57 - walk further to the right
161:59 - this one also doesn't work
162:01 - so
162:02 - this is much better
162:04 - i guess i can demonstrate what would
162:07 - happen if we added these generic sprites
162:10 - to all sprites as well so if i add
162:12 - this to self
162:14 - dot all sprites
162:18 - it would look something like this so
162:20 - these are the sprites we are actually
162:21 - colliding with
162:23 - and well it doesn't feel great but you
162:26 - can tell what's going on so this is the
162:29 - entire
162:30 - religion map of the level
162:33 - but i do not want to show them so let me
162:36 - undo all of this
162:38 - there we go
162:39 - and now we have all of the collisions
162:41 - that we need
162:44 - in this part i want to work on the trees
162:47 - so that we can hit the trees and the
162:50 - trees all have apples there are quite a
162:52 - few different things we need so let's
162:54 - jump right in
162:55 - here we are back in the code and i want
162:58 - to work on my trees
163:00 - let's get started by giving the trees
163:02 - some
163:03 - apples
163:06 - for that first of all we need an apple
163:10 - surface this we get with
163:11 - pygame.image.load
163:14 - and the file path here let me just copy
163:16 - it to save me a bit of writing this file
163:19 - path here
163:20 - inside of the project folder we are
163:22 - looking at
163:23 - graphics and in there we have root and
163:27 - in there we have if i make it a bit
163:29 - larger we have the apple this is what
163:31 - we're importing is simple image
163:33 - after that we need a list of possible
163:36 - positions for the apple and this we have
163:39 - in the settings
163:40 - let me minimize all of this so it's
163:43 - easier to read
163:45 - we have one dictionary
163:47 - with small and large and the values here
163:50 - are lists with positions
163:52 - and these names here refer to small or
163:54 - large trees and these are positions on
163:57 - the tree where we could have an apple
163:59 - this i want to create as an attribute so
164:02 - self dot let's call it apple pos
164:06 - is going to be apple underscore pos
164:08 - that's the dictionary
164:10 - from the settings file
164:13 - and from this
164:15 - i
164:16 - want to pick the list that is
164:18 - appropriate and this i'm getting by
164:19 - using the name remember here the name of
164:21 - the trees is either small or large and
164:23 - this is why this works
164:25 - finally each of the trees is going to
164:28 - have its own sprite group which i'm
164:30 - going to call apple
164:32 - sprites
164:33 - this is just going to be
164:34 - pygame.sprite.group
164:37 - now once we have that i actually have to
164:40 - use that to create some apples this i
164:42 - want to do in a separate method that i'm
164:45 - going to call create fruit we need self
164:48 - and nothing else and in here
164:52 - basically what i want to do is
164:54 - for position in
164:56 - self.apple
164:58 - position
164:59 - i want to have some random number
165:01 - generator to tell if we want to create
165:03 - an apple in a position or not now for
165:06 - that i am going to need randint so from
165:09 - random import rand
165:13 - and now all i really want to do is rant
165:16 - in
165:17 - generating a number between 0 and 10
165:20 - and if that number is smaller than 2 i
165:22 - want to create an apple
165:24 - and the apple here is just going to be a
165:27 - generic object this one is going to need
165:29 - a position a surface and a group
165:33 - all the stuff we're getting from the
165:34 - generic class up here let me go through
165:37 - them one by one because we do have to be
165:38 - a bit careful here although the surface
165:40 - is very easy all we need is self dot
165:43 - apple's surface actually this should
165:45 - just be uphill
165:46 - surface because it's singular
165:49 - for the position you might be very
165:50 - tempted to just go with position by
165:52 - itself here because if you look at
165:54 - settings we have a list and this looks
165:58 - like a position
165:59 - and it kind of is but it's a bit
166:01 - misleading
166:03 - the way you have to think about it
166:05 - if this one here is the entire map of
166:08 - the game
166:09 - and we have a tree somewhere
166:12 - here
166:13 - the position
166:15 - that is inside of the list refers to the
166:18 - position on the tree
166:20 - and the number is the distance from the
166:22 - top left of the tree not the top left of
166:26 - the entire game
166:27 - meaning every time we are creating an
166:29 - apple we have to add the top left of the
166:32 - game and then we have to add the offset
166:35 - of the apple
166:36 - and let's do this separately for the
166:38 - variables we have x and y
166:41 - and this i think could actually be a
166:43 - really good exercise for you
166:45 - try to get the actual position of the
166:48 - apple you want to get the position of
166:50 - the apple the position we already have
166:52 - and then add it to the top left of the
166:55 - tree and see how far you get
167:00 - all right let's do it for the x and i
167:02 - want to get position 0. that is always
167:05 - the x this is let me bring the drawing
167:08 - back up and let me clean it up a tiny
167:10 - bit
167:11 - this position 0 is basically telling me
167:14 - how far from the left of the tree i want
167:16 - to go to this i have to add self
167:18 - self.rect.left
167:21 - and this self.director left is the left
167:24 - side of the tree
167:26 - meaning this
167:27 - side here is this side or in other words
167:31 - it is this distance here
167:33 - combined we are getting this entire
167:36 - arrow here and this is where we want to
167:37 - place the actual apple
167:40 - at least on the horizontal axis
167:42 - for the y this is going to look very
167:43 - similar we want pause one and then
167:45 - self.direct dot top
167:49 - and this is the actual x and y position
167:51 - we want this is what i want to pass in
167:54 - here for x and y
167:56 - finally for the group
167:58 - i want to have two groups in here the
168:01 - first one is easy i want to have self
168:03 - dot apple sprites
168:06 - besides that i also want to put all of
168:09 - these apples into all sprites because
168:11 - that's the only way to display them to
168:13 - the player the problem is we don't
168:15 - really have those available anywhere
168:18 - inside of this entire python file we
168:21 - only really have them inside of the
168:22 - level so this all sprites
168:26 - now the work around here is
168:28 - every single sprite has the attributes
168:31 - of what sprites it is part of and this
168:33 - we can access with self.groups
168:35 - and these are all of the groups that
168:37 - tree sprite is in
168:39 - this i do have to call and this is going
168:42 - to return a list and from this list i
168:44 - want to pick the first element
168:47 - and this first element if i look at my
168:50 - level where i am creating the trees
168:54 - this one here
168:55 - the first element is going to be all
168:57 - sprites the second element is going to
168:59 - be collision sprites
169:01 - this is what i'm getting with this line
169:04 - here
169:05 - so that way i am placing each apple into
169:07 - apple sprites that's the sprite group of
169:10 - the tree and then into all sprites that
169:12 - way they are going to be visible
169:14 - there's one more thing that we need and
169:16 - let me put all of this over multiple
169:18 - lines with named arguments
169:20 - otherwise this is going to be very hard
169:23 - to read
169:24 - this one is groups and finally the one
169:28 - thing i forgot is we need a z position
169:31 - fortunately this one is very easy we
169:33 - need layers
169:35 - and inside of settings inside of layers
169:39 - we have
169:40 - a fruit layer this is where the apples
169:42 - should be on
169:44 - every time we are creating the tree i
169:47 - want to call self dot create fruit
169:50 - and this should be working let's try if
169:53 - i now run main.pi and look at a tree
169:56 - we can see
169:58 - quite a lot of apples this is looking
170:00 - very nice
170:04 - i am very happy with this we are
170:06 - definitely making progress
170:09 - next up i want to have the logic that we
170:12 - can hit the player and let me minimize
170:14 - create fruit we don't need it anymore
170:17 - so let me call this the tree
170:19 - attributes
170:22 - in here first of all each tree is going
170:24 - to have an amount of health which i'm
170:26 - always going to set to 5 but choose
170:29 - whatever you want in here besides that i
170:31 - also want self dot alive and by default
170:34 - this is going to be true if this one is
170:36 - false the tree for example wouldn't
170:39 - create fruits but this is going to come
170:41 - later
170:42 - besides that i also want to have what i
170:44 - called self.stump underscore surface and
170:48 - this is what the tree is going to look
170:50 - like if the tree was destroyed so once a
170:53 - life is false we want to display a sum
170:55 - surface instead of the tree
170:58 - and this we have to import with pygame
170:59 - dot image dot load
171:02 - and in here i want to create an f string
171:05 - because we have to decide between two
171:07 - different files so there's one stump for
171:09 - the small tree and one for the large
171:11 - tree
171:12 - for both we have to go up one folder
171:14 - then to graphics and there's a folder
171:16 - called stumps and here i want to work
171:19 - with variables
171:21 - and this should be
171:22 - small
171:24 - if name
171:26 - is equal to small
171:28 - and if that is not the case
171:31 - it should be large
171:33 - and don't forget this should be png
171:36 - this is getting really large and i made
171:38 - a typo so let's put this on a separate
171:41 - line
171:42 - let's call this the stump
171:44 - path
171:46 - so i want to get this out of here
171:49 - and paste it in there
171:51 - and place this stump path in here and
171:54 - now don't forget we also have to convert
171:57 - alpha this one there's one more thing
171:59 - that we do need and that is a timer so i
172:02 - want to have self dot involve underscore
172:05 - timer
172:06 - is going to be a timer that lasts for
172:09 - about 200 milliseconds why we need this
172:11 - timer i'm going to visualize in just a
172:13 - second for now just follow along
172:16 - but this is basically all we need for
172:17 - the three attributes
172:19 - now that we have that i want to create
172:21 - another method
172:23 - and this i'm going to call damage
172:26 - here we need self and nothing else
172:29 - this method is well damaging the tree so
172:31 - i want self dot health
172:34 - minus equal one
172:36 - and this is going to be damaging
172:40 - the
172:41 - three
172:42 - besides that every time we're hitting
172:44 - the tree with an x i also want to
172:48 - remove an
172:49 - apple but i only want to do that if
172:51 - there is an apple meaning first of all i
172:54 - want to check the length of self dot
172:57 - apple sprites dot sprites
173:00 - if this list here is 0 there is no point
173:03 - in removing an apple
173:04 - so i only want to do this if this list
173:06 - is greater than 0.
173:08 - if that is the case i want to pick a
173:11 - random apple and store it in a variable
173:14 - and to pick a random apple i need the
173:16 - choice function and this one i also get
173:19 - from random so besides randint i want to
173:21 - import
173:22 - choice and in here i want choice and i
173:26 - want self.apple
173:28 - sprites
173:30 - dot sprites
173:32 - and this random apple i want to destroy
173:35 - with the kill method
173:37 - so now we just have to figure out how to
173:40 - call this damage method
173:42 - and this is going to happen inside of
173:46 - the player
173:47 - although for that to work we need a few
173:49 - more things so let me minimize
173:51 - everything inside of the player first of
173:53 - all the player needs to know where all
173:56 - of the trees are
173:57 - and for that to work back in my level
174:00 - let me minimize all of these methods as
174:02 - well
174:02 - i want to create another group and this
174:05 - i called self dot tree
174:09 - sprites again this is just going to be
174:11 - pygame.sprite.group
174:14 - all of the trees that i am going to
174:16 - create which happens down here each tree
174:20 - is supposed to be in all sprites
174:21 - collision sprites and also in
174:25 - self.3 sprites
174:27 - really important here
174:29 - make sure that self.all sprites is the
174:32 - first sprite inside of the list
174:35 - if that is not the case then
174:37 - [Music]
174:38 - inside of createfruit this line here
174:41 - would not work anymore so be careful
174:43 - here
174:45 - but now that we have that i can minimize
174:47 - the setup actually i can't because i
174:50 - have to pass
174:51 - into my player
174:54 - this one here
174:56 - let me put all of this over multiple
174:57 - lines because this is also getting
174:59 - really hard to read
175:01 - we have a position
175:03 - we have a group i think it was a
175:06 - singular group right yeah just group
175:09 - besides that we have collision
175:13 - sprites
175:14 - and finally i want to add one more
175:17 - parameter and this is called trees
175:20 - and this is going to be self.3
175:23 - sprites
175:24 - and now inside of the player in the init
175:27 - method
175:28 - i want to create three
175:31 - sprites
175:32 - next up i have to convert all of this
175:35 - into an attribute let me put it all the
175:36 - way at the bottom here and let me create
175:39 - another section that i call interaction
175:42 - there are going to be quite a few things
175:43 - we need to interact with but in here i
175:46 - want to have myself dot
175:48 - three sprites and this is going to be
175:51 - the tree sprites parameter
175:53 - now we have to figure out how to
175:55 - actually target this thing and this is
175:57 - going to happen inside of use tool
176:01 - remember this we created
176:03 - ages ago about 2 hours by now but this
176:06 - method is being called every time we are
176:08 - using a tool and in here i want to check
176:12 - what tool we are currently using so if
176:14 - self dot
176:16 - selected tool
176:18 - is equal to
176:20 - let's start with a ho
176:22 - if that is the case i want to pass for
176:24 - now
176:26 - besides that i can duplicate this line
176:29 - i want to check if the selected tool is
176:32 - an x
176:34 - and this is what we want to work on in
176:35 - this part but for now let me add a path
176:37 - in here and finally
176:39 - i also want to check
176:42 - if
176:43 - our selected tool is water
176:46 - although in here for now also going to
176:48 - be a pass
176:49 - if we are using the x i want to check
176:52 - for
176:53 - 3 in self dot 3 sprites dot
176:57 - sprites
176:59 - don't forget to call it
177:01 - and now i want to check if we are
177:03 - actually hitting the tree which means if
177:06 - 3 and now i have to figure out
177:10 - if we are actually hitting the tree
177:12 - the problem is i don't really have any
177:15 - way to know which point i'm actually
177:17 - targeting
177:18 - meaning let me comment out all of this
177:21 - for now and let me run the code
177:23 - and i'm getting an error
177:25 - because i didn't import the timer
177:28 - so
177:29 - from timer import timer
177:32 - now let's try this again we are getting
177:34 - another error that the player
177:38 - this is probably happening in level
177:41 - this should be tree
177:43 - underscore sprites
177:46 - now it's working
177:47 - right now i can use the different tools
177:50 - and this is working perfectly fine for
177:52 - all of them
177:53 - the issue is right now we have no idea
177:56 - which point we are targeting
177:58 - for example if i'm using the x
178:01 - i want to know that i am basically
178:02 - targeting this point here
178:06 - let me use the x again this looks about
178:08 - right
178:10 - and this point i have to get in my code
178:14 - so back in my player let me minimize the
178:17 - init method and in here
178:20 - i want to create another method that i'm
178:23 - going to call get underscore target
178:25 - underscore position and all i really
178:28 - want to do in here is i want to create
178:30 - another attribute that i'm going to call
178:32 - self.target
178:34 - position
178:35 - this is going to be the same for all of
178:36 - the tools which makes it quite easy to
178:38 - work with and the basic logic here is
178:42 - if this is our player
178:45 - and this is the center of the player for
178:47 - each of the tools for example if the
178:49 - player is looking to the left
178:52 - then i want the tool to be somewhere
178:55 - here
178:56 - a certain distance to the left of the
178:58 - player and a bit further down
179:01 - the reason why i have to move it down is
179:03 - because most of the tools
179:05 - like the x for example they go in this
179:08 - direction here
179:09 - basically what i want to do i want to
179:12 - get self.rect.center
179:14 - and then i'm going to need some kind of
179:16 - offset
179:18 - and this offset
179:20 - i am getting from my settings because in
179:22 - here we have player tool offsets and
179:25 - these are a bunch of offsets that we can
179:27 - work with
179:28 - meaning this is what i want to copy
179:32 - paste it inside of the player and now we
179:36 - have a dictionary that we want to take
179:38 - some information from
179:40 - notice here
179:41 - the keys are called left right up and
179:44 - down which is the same as the status of
179:46 - the player
179:48 - which is very handy because now we can
179:50 - get self.status dot split
179:54 - and as always we want to split it
179:55 - wherever there's an underscore and then
179:57 - pick the index 0 of that list
180:01 - and this is basically all we need for
180:04 - this one method i guess importantly do
180:07 - not forget to call it
180:09 - right after the timers so self dot get
180:12 - target position
180:15 - now the problem is that this target
180:17 - position is going to be really hard to
180:19 - see
180:20 - at least for now for testing purposes we
180:22 - do need some way to visualize it and i
180:24 - just realized this should be status not
180:27 - stats
180:29 - and since this isn't something the
180:30 - player is supposed to see
180:32 - we can just do this really quick so for
180:35 - testing purposes back in level dot pi
180:37 - all the way at the end of custom draw i
180:40 - added a tiny bit more code that looks
180:42 - like this
180:44 - if you go for this basically what we are
180:45 - doing is we are drawing a rectangle
180:48 - another rectangle and a
180:50 - circle the result is going to look like
180:54 - this
180:55 - this is telling us the red line
180:59 - is the rectangle of the player the green
181:03 - line is the collision rectangle and the
181:05 - blue dot this one here
181:08 - is the target position
181:10 - so if i use a tool
181:13 - you can kind of see where it's going and
181:15 - this also works with the x and with the
181:17 - watering can
181:20 - and well this way you can play around
181:22 - with this quite a bit more
181:25 - although for the actual game you don't
181:26 - need it so
181:28 - most of the time
181:29 - you're just going to comment it out or
181:30 - remove it entirely
181:32 - but i guess let me keep it for now
181:34 - because now we know that the target
181:36 - position so the blue dot
181:38 - looks pretty good
181:42 - now with that we can uncomment this part
181:45 - here
181:46 - and now for the tree i want to look at
181:50 - the rectangle of the tree and i want to
181:52 - check if this tree is colliding with a
181:55 - point
181:57 - the point that i want to check is self
181:59 - dot target position
182:01 - if that is the case
182:02 - i want to
182:04 - get the tree and then run the damage
182:06 - method
182:08 - which is this damage method here let's
182:11 - try if this is working
182:13 - so back in the game
182:18 - we are already getting a problem because
182:21 - even if i don't use the axe the apples
182:24 - all disappear
182:25 - which i guess kind of looks cool but not
182:28 - ideal
182:29 - also this one should be commented
182:32 - one of the main reasons why that
182:33 - happened is if i open the timer again
182:38 - in here this line is causing the problem
182:41 - because there is a chance that our
182:44 - current time minus the start time is
182:46 - bigger than the duration so this could
182:48 - run forever
182:49 - and as a consequence we might trigger
182:52 - this function by accident
182:54 - and a really easy way to fix that is to
182:56 - add another end statement here that we
182:58 - want to check self dot start time
183:01 - is different from zero
183:04 - and now let's run may not pi again
183:07 - and
183:08 - now
183:09 - if i am colliding with a tree nothing
183:11 - happens
183:12 - and if i use the x
183:14 - also nothing happens
183:17 - let's try different tools okay nothing
183:19 - happens in general
183:21 - and the reason why that is happening
183:23 - inside of timer
183:25 - every time we are deactivating the timer
183:28 - we're setting the start time to zero
183:30 - meaning this is not going to run
183:32 - the activate has to be after this if
183:34 - statement
183:35 - and now
183:37 - inside of the player
183:39 - let me just
183:40 - print
183:42 - tool
183:43 - use
183:44 - just to try if this is working so now if
183:46 - i use the x i can see tool use in the
183:49 - bottom left
183:50 - and i guess now we can try to hit a tree
183:53 - there we go the apple disappeared
183:56 - and this is working quite well
184:04 - and let me close the timer again now we
184:07 - are done with it
184:09 - back in the sprites
184:11 - i want to have
184:13 - another method that checks if the tree
184:17 - is still alive so check def
184:21 - and basically all i want to do is if
184:23 - self.health is smaller or equal than
184:26 - zero
184:27 - then the tree is going to die let me
184:29 - just print that
184:32 - we just have to figure out when to call
184:34 - check def in my case i went with an
184:37 - update method that needs self and delta
184:39 - time like any update method and then
184:41 - here i'm going to call self dot check
184:44 - def
184:45 - actually to be a bit better here
184:47 - we only want to check def if self dot
184:50 - alive is true
184:52 - and now
184:53 - let me run main.pi again
184:58 - if i hit a tree with my x we get tool
185:01 - use tool use and now we get that
185:05 - this is looking really good
185:07 - which means what we can do in here now
185:10 - is i can set self dot alive u
185:13 - volts
185:14 - although there are a few more things
185:16 - that i do want to change first of all
185:18 - self.image so what the sprite actually
185:21 - looks like should be
185:23 - self.stump surface
185:26 - and since we are updating the image we
185:28 - also have to update
185:30 - self.rect this i get with
185:33 - self.image.getunderscorerect
185:36 - and i want to place the mid
185:39 - bottom should be
185:41 - wherever the previous self.rect.mid
185:46 - bottom was
185:47 - what that means is if this one here is
185:50 - the original tree and we want to create
185:53 - a tree stump that is a bit smaller
185:56 - we now have to figure out in this line
185:59 - where we want to place this rectangle
186:01 - finally we also have to update the
186:03 - hitbox
186:05 - and this we get with self.direct dot
186:08 - inflate actually i think good practice
186:10 - here is to copy the entire thing
186:14 - and now
186:16 - in here we are going to need a width and
186:19 - a height or an x and a y basically the
186:22 - same thing for the three stems i always
186:24 - went with negative 10 and negative
186:26 - self.direct
186:29 - and multiply this by 0.6
186:33 - let's try
186:35 - so if i now go to a tree
186:39 - hit the tree a few times there we go we
186:42 - have a tree stump i can do this with the
186:44 - other tree as well
186:47 - and we get a different kind of tree
186:48 - stump
186:49 - and this section is getting quite long
186:51 - so let's finish it now but in the next
186:53 - section we are going to finish up the
186:55 - trees
186:56 - we are nearly done with the trees there
186:59 - is only one more major thing that i
187:00 - would like to add and that is some
187:02 - particle effects so that when an apple
187:05 - disappears or when a tree disappears i
187:07 - want to show some white object that
187:09 - flashes on the screen you'll see in a
187:11 - second what i mean but it looks quite
187:13 - nice once more here we have main.pi and
187:16 - i want to work inside of the sprites
187:19 - inside of the tree in here
187:22 - whenever one of the apples disappears
187:25 - that happens here i want to basically
187:29 - create a white apple on top of the
187:31 - disappearing apple
187:32 - that way we're indicating which apple
187:34 - disappears
187:36 - also whenever the tree dies
187:39 - which happens inside of this method here
187:41 - i want to do the same thing for the tree
187:43 - so for a couple of milliseconds we have
187:45 - a white tree and then we can see the
187:47 - tree stump
187:49 - both of these are being created with
187:52 - another class let me create it right
187:54 - here and i'm going to call this one
187:56 - class partic kill
187:59 - this particle is also going to be a
188:01 - generic sprite so it inherits like all
188:04 - of the other sprites from the generic
188:05 - class
188:06 - in here
188:08 - as always we are going to need the
188:10 - dunder init method
188:12 - we need self
188:14 - we need a position we need a surface we
188:17 - need groups and we need a z layer
188:21 - for the parent class to work we need the
188:24 - super and dunder init method
188:27 - this one for generic
188:29 - add position groups and the z layer
188:33 - meaning i can copy them in here
188:36 - and
188:37 - most of them we don't really have to
188:39 - worry about too much
188:41 - as a matter of fact if you look at this
188:43 - closely
188:44 - those parameters and those arguments are
188:46 - basically identical the only thing i
188:49 - really want to change is i do not want
188:51 - to have the default argument now the way
188:53 - this particle is going to work is it is
188:56 - going to be a sprite but this sprite is
188:58 - going to self-destroy really quickly it
189:01 - basically has an internal timer let's
189:03 - create this one actually right now
189:05 - we can use the update method here and
189:07 - this one needs self and
189:09 - delta time
189:10 - just so that we capture delta time
189:12 - in here
189:13 - i am let me save it as the current time
189:17 - the current time i'm getting with
189:19 - pygame.time.get
189:21 - underscore ticks
189:23 - once i have that all i really want to do
189:25 - is if my current time
189:27 - minus
189:28 - some kind of start time we'll create
189:31 - that one in just a second
189:33 - is greater than a certain kind of
189:36 - duration
189:37 - if that is the case i want to destroy
189:40 - this sprite that way we are only showing
189:43 - this sprite for let's say half a second
189:45 - and then it disappears
189:47 - besides that this particle is always
189:50 - going to have the same surface as for
189:52 - example the tree except it is going to
189:54 - color the entire thing white
189:56 - and that way we have some kind of
189:58 - particle effect it's a fairly minimal
190:00 - one but it does the job for this game
190:03 - we need to do two more things we need to
190:05 - get a duration and this one i should
190:09 - have put in the init parameters so in
190:11 - here duration and i do want to have a
190:13 - default value let's say 200
190:17 - now that we have all of that i want to
190:19 - create self.starttime
190:21 - and this one is pygame.time.get
190:25 - underscore ticks
190:27 - i suppose i should mention the
190:29 - difference between this start time here
190:31 - and this current time
190:33 - is that the start time here
190:36 - is only being taken once
190:39 - it's basically one point in time
190:42 - whereas the current time is being
190:44 - continuously updated meaning from this
190:47 - point here we are checking another
190:48 - current time another current time
190:50 - another current time and so on and at
190:53 - some point
190:54 - we are hitting the duration meaning that
190:57 - this distance here is greater than the
190:59 - duration and then we are destroying the
191:01 - sprite
191:02 - besides that i have to store my duration
191:05 - as an attribute and this i just get from
191:08 - my duration
191:10 - and this is the basic setup besides that
191:14 - we need to create the white
191:17 - surface
191:19 - in this we are doing via a mask for that
191:22 - i want to create a mask surface
191:25 - this i'm getting from pygame dot mask
191:28 - dot from underscore surface
191:31 - this one needs one surface and the
191:33 - surface we have is self dot image
191:36 - now once we have that
191:38 - i want to create a new surface
191:42 - and this new surface we get with the
191:43 - mass surface and then to underscore
191:47 - surface
191:48 - this new surface now is going to be a
191:50 - black and white silhouette of the
191:52 - original self.image
191:55 - any pixel that had any kind of color
191:56 - value is going to be white and any kind
191:59 - of transparent value will be black i can
192:01 - visualize this in just a second actually
192:03 - but what we need to do now is to get rid
192:05 - of all of the black color values which
192:08 - we do with new surface and we have to
192:10 - set a color key
192:13 - the color we want to get rid of
192:14 - is going to be black so a tuple with 0 0
192:17 - and 0.
192:18 - and this new surface i want to set as
192:21 - the image of this sprite
192:23 - there we go and this should be all we
192:26 - need for the entire class
192:28 - all we have to figure out now is when to
192:30 - create it and this happens for example
192:32 - inside of the tree
192:34 - for example
192:37 - when we are destroying an apple i want
192:39 - to play this particle effect
192:41 - let's do it right below the random apple
192:44 - i want to create a particle for this
192:47 - particle i want to have
192:50 - not these parameters i want to have
192:52 - these parameters
192:55 - i suppose for simplicity we could get
192:58 - rid of the duration here because we're
193:00 - not going to need it for now
193:02 - and well now we have to figure out a
193:04 - position a surface groups and a z and i
193:07 - think this could be a really good
193:08 - exercise try to pass in all of these
193:11 - arguments and see if you can create this
193:13 - particle effect it should already be
193:16 - working once you have created it
193:21 - let's put them all on separate lines so
193:24 - i can work with named arguments and that
193:26 - should make all of this much easier to
193:27 - read
193:29 - first of all we need a position we
193:31 - already have the random apple we want to
193:33 - destroy i want to get this random apple
193:36 - i want to get the rectangle of this
193:38 - random apple and then i want to get the
193:40 - top left
193:42 - because this particle should be in the
193:44 - same position as this apple
193:47 - along the same lines it should also have
193:49 - the same surface so random apple dot
193:53 - image
193:54 - for the groups we need to do basically
193:56 - the same thing we have done for the
193:58 - apples
193:59 - which means i want to have myself dot
194:02 - groups don't forget to call it and now i
194:04 - want to have the element with the index
194:07 - 0.
194:08 - now looking at all of this since we are
194:10 - doing this quite often it might be a
194:12 - good idea
194:13 - to put a reference to the self.all
194:16 - sprites inside of the tree
194:19 - but you can do this in your own time it
194:21 - isn't going to make much of a difference
194:24 - finally for the set parameter
194:26 - i also realized it doesn't really have a
194:29 - separate layer but you don't really need
194:31 - one you can put it inside of the fruit
194:34 - but also be inside of raindrops it
194:36 - honestly doesn't matter at this point
194:37 - let's go with fruit i guess it fits in
194:39 - there quite well
194:41 - we need layers and in there i want to
194:44 - have the fruit
194:46 - and with that we should be having a
194:48 - particle effect let's try if i run out
194:51 - of this it still runs that's generally a
194:53 - good sign
194:54 - and let's use this tree here and there
194:57 - we go we have a very basic particle
195:00 - effect
195:01 - it is indeed very subtle but it
195:03 - certainly does work
195:06 - let me minimize the damage method and
195:09 - now we want to do the same thing for the
195:11 - tree once the tree is being destroyed
195:14 - which we can also do quite easily once
195:16 - again i want to create a particle
195:19 - and now
195:20 - once again let me get all of the
195:23 - parameters we need
195:25 - and i guess for this one we can also
195:26 - change the duration
195:28 - so in here i want to have all of these
195:31 - arguments the position is going to be
195:34 - self.rect.top
195:36 - left
195:37 - the surface is going to be self.image
195:40 - spelled correctly would be good as well
195:43 - then for the groups once more
195:45 - self.groups
195:47 - with the index 0
195:50 - and for that i want to have
195:52 - layers
195:54 - and i guess we can put this on the fruit
195:57 - layer as well
195:59 - since this is a slightly larger object
196:01 - let's go for a duration of 500
196:04 - and this should be all we need let's try
196:06 - this one now
196:07 - and this one is only going to play once
196:10 - the tree is dead so we have to hit a
196:12 - tree a couple of times
196:16 - we go i guess the effect is a tiny bit
196:18 - long
196:20 - uh let's go with 300.
196:22 - let's try this one
196:25 - although at this point this is quite
196:27 - subjective so you can just go with
196:28 - whatever you think looks best
196:32 - and yeah i think this is okay
196:35 - and with that we have some basic
196:37 - particle effects and these we can also
196:39 - reuse later on for the plans which is
196:41 - very nice
196:43 - which means we have covered another
196:45 - major section
196:47 - to finish off the tree we have to create
196:49 - a player inventory so the player gets an
196:51 - apple or some wood whenever we hit a
196:54 - tree
196:55 - which means we have to connect the
196:56 - player and the tree with each other
196:58 - which is a fairly straightforward thing
197:00 - to do so let's jump right in once more
197:03 - we are in the code and first of all we
197:05 - have to look at the player specifically
197:08 - inside of the init method let me put it
197:11 - above the interactions and right below
197:14 - the tools and the seats this one i want
197:16 - to call inventory
197:18 - because if you want to add something to
197:20 - the player the player needs to have some
197:22 - kind of system to store data
197:25 - and for now the player is only going to
197:27 - have a single dictionary and this i call
197:29 - item inventory although later on there's
197:32 - going to be a bit more
197:34 - and in here we're going to have a couple
197:36 - of different key value pairs let me copy
197:38 - them in actually so you don't have to
197:39 - watch me right
197:41 - we have
197:42 - these four
197:43 - wood and apple is what the player gets
197:45 - from the trees and corn and tomato is
197:47 - what we're getting from the soil
197:50 - by default all of them are going to be
197:52 - zero and let me line them up a bit nicer
197:56 - so
197:57 - this is looking better
198:00 - and these numbers we want to increase
198:02 - whenever the player for example gets a
198:04 - piece of wood or an apple
198:06 - which means we have to connect the
198:08 - player
198:09 - all of this here
198:11 - with the tree
198:13 - and since they are in different files we
198:16 - have to work via the level to make all
198:18 - of this work
198:20 - and let me minimize
198:22 - everything
198:24 - so we're not getting lost
198:25 - right now the level only has three
198:27 - methods even though it is quite a chunky
198:29 - class already but i want to add another
198:32 - method in here
198:34 - and this one i'm going to call player
198:36 - underscore add
198:39 - besides self we are going to need an
198:41 - item so the item we want to add to the
198:43 - player
198:44 - what is going to happen in here is i am
198:47 - targeting the player i want to get the
198:50 - item inventory of the player the one we
198:53 - just created
198:54 - from the dictionary i want to get the
198:56 - item
198:58 - this would be
198:59 - one of
199:00 - these key value pairs
199:03 - and this i want to increase by one
199:06 - i suppose you could make this a bit more
199:08 - flexible by adding another parameter
199:10 - that would be the amount for example but
199:12 - in my case i would always stick with one
199:15 - because i do want to keep things simple
199:17 - and this tutorial is already getting
199:19 - quite long
199:20 - this method i have to pass into the
199:22 - trees
199:24 - which means inside of setup
199:26 - when i am creating the trees this
199:29 - happens here
199:30 - and once again
199:32 - let's do this over multiple lines with
199:34 - named arguments
199:36 - so we're not getting completely lost
199:41 - we have the groups and finally this one
199:43 - was called the name
199:47 - the one additional argument we want to
199:48 - add is let's call it player add
199:52 - and this is going to be self dot player
199:54 - add
199:55 - make sure here not to call it because we
199:58 - only want to call it from inside of the
200:00 - tree object
200:02 - which means inside of the tree we're
200:05 - going to need another parameter
200:08 - layer add and this one we also have to
200:11 - store somewhere in the attributes let's
200:14 - do it here and self dot player add is
200:17 - going to be player add
200:20 - now that we have that
200:22 - when we are damaging the tree
200:25 - this stuff here i want to
200:28 - run self dot player add and give the
200:31 - player an apple
200:34 - which should be all we need i guess
200:37 - inside of the level in the run method
200:41 - all the way at the bottom let me print
200:45 - self.player.item inventory so we can
200:48 - tell what's going on
200:49 - if i run this now
200:50 - you can see in the bottom left the
200:52 - inventory of the player
200:54 - and if i now hit a tree we have one
200:56 - apple
200:57 - this i can do multiple times we have two
200:59 - apples three apples that is looking
201:02 - really good
201:04 - so that is basically all we need for the
201:06 - apples
201:07 - the one last thing for the tree we have
201:09 - to do is whenever the tree dies we have
201:11 - to give the player some wood and this
201:14 - could be a fairly easy exercise for you
201:16 - so try to figure this one out yourself
201:21 - i hope that this one is fairly easy at
201:23 - this point all you need is self dot
201:25 - player add and then here you have to add
201:28 - some wood
201:29 - let's run all of this again
201:32 - and for this one i have to hit a tree
201:35 - multiple times
201:38 - there we go now we have one wood this is
201:40 - working very well
201:42 - with that i can get rid of this print
201:45 - statement here and minimize the run
201:47 - method
201:48 - in fact i can minimize all of these
201:50 - methods so things are easier to see
201:54 - and with that we are basically done with
201:56 - the basic tree although the next section
201:59 - is we have to make sure that the trees
202:01 - get new apples once we are sleeping
202:04 - which means we have to work on the logic
202:06 - to start a new day
202:08 - but that is going to be the next section
202:11 - so let's start to work on restarting the
202:13 - day for now all this means is all of the
202:16 - trees are getting some new fruits but
202:19 - later on there's going to be quite a bit
202:20 - more besides that we also have to work
202:23 - on some transitions but let's do all of
202:25 - this straight in code it isn't so hard
202:28 - it's more an organizational thing but
202:30 - let's have a look at all of this
202:32 - alright once again we are inside
202:34 - main.pie and let's start by talking
202:37 - about what we need
202:38 - basically i want to start a new day when
202:41 - i stand here or when the player stands
202:43 - here and presses enter so right next to
202:45 - the bat
202:46 - which means we have to check an input
202:48 - and we need to check if the player is on
202:50 - top of this carpet or at least inside of
202:52 - this area
202:54 - for this i already have some basic setup
202:56 - inside of tiled let's have a look at
202:58 - that
202:59 - here we have tiled if i zoom in
203:02 - there is one object
203:05 - that is called bed that is right next to
203:07 - the pad this is an empty area that i
203:10 - want to import and if the player is
203:12 - inside of this area and presses enter
203:15 - then i want to start a new day
203:18 - once again if you want more detail
203:19 - entitled check out the dedicated video
203:22 - now this i want to import but for the
203:26 - import i need another dedicated sprite
203:30 - that sprite
203:31 - let me put it right here i have called
203:34 - interaction
203:36 - once more this inherits from the generic
203:39 - sprite
203:40 - although other than that it is going to
203:42 - be fairly simple we have an init method
203:44 - as always
203:46 - and in here we have self we have a
203:48 - position we have a size we have the
203:51 - groups and finally we have a name
203:56 - we do not need a surface in here
203:58 - for the simple reason that this kind of
204:00 - sprite is never visible anyway
204:03 - speaking of we can just create the
204:05 - surface in here and the surface we are
204:07 - creating with pygame dot surface
204:10 - and we are passing the size in here
204:12 - that is the size we're getting from the
204:14 - parameters
204:15 - other than that i have to call
204:17 - the parent init method with superdunder
204:20 - init and pass the surface the position
204:24 - and the groups in here
204:26 - there's that position really doesn't
204:28 - matter because again this is not going
204:30 - to be visible so we can just leave it as
204:32 - it is
204:33 - finally we have to get self.name and
204:36 - store it as an attribute the name if i
204:39 - open tiled again
204:41 - is what you can see on the left side
204:44 - here we have a name
204:46 - besides the bat by the way this is what
204:48 - you are going to see in quite a bit
204:52 - we have the trader meaning if the player
204:55 - stands inside of this area and presses
204:56 - enter we want to open some kind of menu
204:58 - for trading but well that is something
205:02 - for later but now i just want to work
205:04 - with the bad
205:06 - but other than that we have finished the
205:08 - entire interaction class
205:10 - it wasn't actually so bad
205:13 - now we have to import it this happens
205:15 - inside of level inside of setup
205:18 - in here this is getting quite extensive
205:22 - the layer we want to work in is the
205:24 - player layer
205:26 - let me add a bit of white space here
205:28 - because this is the same layer where we
205:30 - have the player
205:31 - except now
205:33 - i want to check if
205:35 - obj.name
205:36 - is equal to
205:39 - that
205:40 - if that is the case i want to create the
205:43 - inter
205:45 - action
205:46 - sprite for that to work i need to import
205:49 - it meaning all the way at the top after
205:51 - tree i want to have the interaction
205:53 - sprite
205:56 - now back in here
205:58 - let me copy all of the parameters we
206:01 - need we need those four
206:03 - and all of those should be fairly
206:05 - straightforward for the position
206:07 - we need
206:08 - the same thing we have seen for the
206:10 - player so obj.x and obj.y
206:13 - i can just copy paste them and for the
206:16 - size we're doing something fairly
206:17 - similar except for x and y we need with
206:21 - and we need height
206:23 - for the group i actually want to create
206:26 - a whole new group
206:27 - let me do it all the way inside of the
206:30 - init method this one i've called
206:32 - self.interaction
206:36 - sprites
206:39 - but this is once again just another
206:41 - pygame.sprite.group
206:49 - self dot interaction sprites we don't
206:52 - need self that all sprites here because
206:54 - again this kind of sprite is not going
206:56 - to be visible
206:57 - finally we need the name of this kind of
207:01 - sprite
207:02 - you could write just bad in here this
207:04 - would be perfectly fine
207:06 - alternatively you could also use
207:08 - obj.name
207:10 - you would be getting the same result
207:12 - and with that we have an area
207:16 - next up the player needs to know about
207:18 - this area because right now these
207:20 - interaction sprites only exist inside of
207:23 - the level and the player has no idea
207:25 - about them
207:27 - as a consequence for the player which is
207:30 - right on top
207:31 - i want to add let me call it interaction
207:35 - and this is going to be self.interaction
207:38 - sprites that way the player has an
207:40 - attribute to know where these
207:42 - interaction sprites are
207:45 - so with that inside of the player we are
207:47 - going to need one more parameter
207:50 - interaction
207:52 - this i want to store below my three
207:55 - sprites
207:56 - and let's call it interaction is going
207:59 - to be interaction
208:01 - with that the player knows where these
208:04 - kind of sprites are
208:06 - all we have to do now is check if the
208:08 - player is inside of this area and
208:10 - presses the enter button
208:12 - which we are doing
208:13 - if i minimize all of the methods this is
208:16 - going to happen inside of input
208:19 - all the way at the bottom of this method
208:24 - i need another if statement if keys are
208:28 - pygame dot a underscore return
208:33 - this is telling me if the player has
208:34 - pressed the enter button or not after i
208:37 - know that i want to know if the player
208:39 - collided with the bad sprite for example
208:42 - and this i want to store in collided
208:44 - interaction
208:46 - sprite
208:48 - this we are getting with
208:49 - pygame.sprite.sprite
208:52 - or lite
208:53 - and in here we need three arguments we
208:55 - need a sprite we need a group and we
208:57 - need what is called do
209:00 - kill
209:01 - the sprite in this example is just going
209:03 - to be self
209:05 - and we want to check the sprite so the
209:07 - player sprite against all of the
209:09 - interaction sprites which we get with
209:11 - self.interaction
209:14 - do kill
209:15 - is supposed to be false and basically
209:17 - what it means is if the player
209:21 - which is self in this example if this
209:24 - one collides with the sprite inside of
209:27 - this group do we want to destroy this
209:30 - sprite which in this case we don't want
209:33 - to do
209:34 - which is why this one is going to be
209:35 - false
209:37 - and now that we have that i want to
209:39 - check if collided interaction sprite
209:42 - exists in the first place
209:44 - or rather if it is truthy because that
209:46 - is only the case if it has a sprite
209:48 - inside
209:50 - if that is the case i want to check my
209:52 - collided sprite
209:54 - the first item inside that can only have
209:56 - a b1 and of that i want to check the
209:58 - name
209:59 - that is the name we have created here if
210:02 - this name is trader
210:07 - for now i want to pass but later on we
210:09 - are doing something else in here
210:10 - obviously
210:12 - if that is not the case which means we
210:14 - have the bad
210:15 - then
210:16 - i want to do something else
210:19 - one thing i do want to do in here is add
210:22 - self dot status is going to be left idle
210:28 - the main reason for that is
210:31 - if
210:34 - this is the player and we have the bad
210:37 - here
210:37 - if the player presses enter i want the
210:39 - player to point towards the bat
210:42 - it would be kind of weird if the player
210:44 - looked to the right then we press enter
210:45 - and then we start a new day it's kind of
210:48 - feeling bad
210:50 - let's try this one actually it should be
210:52 - working
210:54 - and we're getting an error that element
210:56 - property with does not exist do you mean
210:58 - with
210:59 - this happened inside of the level and
211:02 - here we need with
211:04 - now let's try this again this is looking
211:06 - better and now if i
211:09 - look to the right and press enter the
211:11 - player is looking to the left so this is
211:13 - working very good
211:16 - with that we can tell if the player is
211:18 - next to the bat and pressing enter so
211:21 - with that we can actually start working
211:23 - on the day transition
211:26 - for that we have two elements we need to
211:29 - cover first of all we have to basically
211:31 - restart the level in our case this just
211:34 - means all of the trees are going to get
211:36 - some new apples if they are still alive
211:39 - besides that we also have to play some
211:41 - kind of transition that indicates we
211:43 - have a new day
211:45 - let's start by resetting the entire
211:47 - level
211:48 - which is going to happen inside of level
211:51 - and i really want to hide the setup
211:53 - method this one is really large
211:56 - and all of the reset logic should be in
211:59 - a dedicated method called reset
212:02 - this one doesn't need any parameters
212:04 - and in here we basically want to reset
212:07 - everything
212:08 - which for now is just going to be the
212:10 - trees
212:12 - or rather the apples
212:14 - on the
212:15 - grease
212:17 - the way i approach this i first of all
212:19 - have to get every individual tree which
212:21 - i get with four tree in
212:24 - self.3 sprites dot sprites
212:29 - in here we actually have not too much
212:32 - work to do because if you look at
212:35 - the tree
212:36 - we have a dedicated function if i
212:39 - minimize everything
212:41 - we have a function called create fruit
212:43 - and this one creates all of the fruits
212:45 - that we need meaning all we really have
212:47 - to do is call tree dot create
212:50 - root
212:52 - although now we do have a problem
212:54 - because we are not destroying the
212:55 - existing apples
212:57 - that however is quite easily done all we
212:59 - have to do is for apple in
213:02 - three dot apple
213:06 - underscore sprites
213:09 - dot
213:10 - rights don't forget to call it and i
213:12 - want to destroy with the kill method all
213:15 - of the apples
213:17 - with that we're getting rid of all of
213:18 - the apples and we are creating new
213:20 - apples which is basically a reset
213:24 - what we now have to figure out is when
213:26 - to call this method
213:28 - because remember we are updating the
213:31 - level inside of the player not inside of
213:34 - the level class itself
213:36 - which means i have to connect the reset
213:39 - to the player although there's going to
213:41 - be another problem
213:42 - because besides the player this reset
213:45 - also needs to be connected to a
213:46 - transition effect
213:48 - how that is going to work is
213:51 - basically
213:52 - the entire screen is going to go dark
213:55 - then we are resetting the level and then
213:57 - we are making the screen go back to
213:59 - normal
214:01 - inside of this transition reset is going
214:04 - to be played here
214:05 - which means we need a system where the
214:08 - player the level and the transition all
214:10 - work together
214:12 - and
214:13 - this well let's go for it step by step
214:16 - first of all inside of the player for
214:18 - the ending method i want to have one
214:20 - more attribute this i called self dot
214:24 - sleep
214:25 - by default this one is going to be false
214:28 - if the player now presses enter and goes
214:31 - to bad all the way down here i want to
214:33 - set self dot sleep who
214:36 - rue
214:38 - that way we know if the player is
214:40 - sleeping or not and this we can use to
214:42 - start a transition
214:45 - that is going to happen inside of the
214:46 - level inside of run
214:50 - all the way at the end
214:52 - i want to check if player
214:54 - this should be self dot player dot sleep
214:59 - then i want to do something like self
215:01 - dot transition this one doesn't exist
215:03 - yet dot
215:05 - lay
215:06 - and this one is going to need delta time
215:09 - now this transition is going to be a
215:11 - separate class and this class is going
215:13 - to call the reset method once we are in
215:16 - a certain point of the transition
215:18 - animation
215:19 - which basically means
215:20 - inside of the init
215:22 - method i want to create
215:27 - self.transition this is going to be a
215:29 - transition class we will create in just
215:32 - a second
215:33 - and this one is going to get self.reset
215:36 - and it's going to get self.player
215:40 - with that we can actually create this
215:43 - new class
215:44 - let me save it as
215:46 - transition.pi
215:49 - once again we have to import pygame for
215:52 - the obvious reasons and we need from
215:54 - settings import everything
215:57 - the class we want to create is called
216:00 - transition
216:01 - no need for inheritance but i do need a
216:04 - dander init method because this one
216:06 - needs self reset and the player
216:11 - inside of this we first of all need to
216:13 - get the display
216:16 - surface
216:16 - because we want to be able to draw on
216:19 - the level itself
216:20 - this one we get with pygame.display.get
216:23 - underscore surface
216:26 - besides that we have to capture the
216:28 - reset
216:29 - method inside of an attribute
216:33 - and we have to do the same thing for the
216:36 - layer
216:38 - let me call this part here
216:42 - setup
216:44 - and besides that we are going to need an
216:47 - over
216:48 - lay
216:49 - image
216:51 - for the overlay image we are basically
216:54 - going to create a black image and then
216:56 - we are going to change the transparency
216:58 - or rather the blending mode but in this
217:00 - case this is going to be the same i'm
217:02 - going to explain this as we implement it
217:04 - but first of all i need self
217:08 - dot image
217:10 - and this is going to be pygame dot
217:12 - surface
217:13 - and the dimensions
217:14 - here we are getting from the settings
217:17 - because i want to have the screen width
217:19 - and the screen height
217:21 - let me copy this screen width
217:23 - paste it in here
217:25 - and the second one should be screen
217:27 - height
217:28 - this right now is giving us a surface
217:31 - the size of the entire window that is
217:33 - entirely black
217:35 - besides that i also want to have self
217:38 - dot color this one is 255
217:41 - by default and then self dot speed
217:44 - this one is going to be negative two
217:48 - how these two attributes are going to
217:50 - work i think the best way to explain
217:52 - this is let's use them right away
217:54 - so i want to have some kind of play
217:57 - method that needs self
217:59 - and in here i want to
218:02 - self dot color
218:05 - plus equal self dot speed
218:09 - and that information i can use to fill
218:11 - my image so self.image.fill
218:15 - and in here i need an rgb tuple we need
218:18 - red we need green and we need blue
218:22 - in this case since we only care between
218:24 - a black and a white color they can all
218:27 - be the same
218:29 - color
218:31 - this image i now want to blit on top of
218:34 - the entire game which means
218:36 - self.displaysurface.lit
218:39 - i need self.image
218:41 - the top left should be a position zero
218:43 - and zero
218:45 - and for now let's just leave it like
218:48 - this
218:51 - and play it because you're probably
218:53 - confused at this point
218:54 - things are going to make a lot of sense
218:56 - in just a second or at least i hope they
218:58 - will
218:59 - first of all for all of this to work we
219:01 - have to import from transition import
219:05 - transition
219:07 - that means this one here is going to
219:09 - work
219:10 - and now inside of the run method
219:15 - layer.sleep is also going to work
219:18 - although here that's a time we don't
219:20 - actually need
219:22 - now with that let's try main.pi and
219:26 - let's press enter next to the bat
219:29 - and we're getting some very strange
219:31 - effect and we're getting an error
219:32 - message
219:34 - let's try it again really quick
219:38 - if i run this first of all we get white
219:40 - and then we go darker and darker and
219:43 - that is exactly what i wanted
219:45 - the entire logic is going to happen
219:47 - inside of play
219:49 - in here
219:51 - self.color on the first frame is 255
219:54 - which with the fill method here
219:57 - means we are turning the entire image
220:00 - white all of these self.colors are 255
220:04 - and those are the values for pure white
220:08 - and if you put this on top of the
220:11 - display surface we are getting a white
220:13 - image
220:15 - however now we are updating in this line
220:19 - the color
220:21 - which means on every single frame the
220:23 - color is going to be a tiny bit darker
220:26 - because of that we started with a white
220:28 - image and it became darker and darker
220:31 - and at some point this self.color got
220:34 - negative and this is where we got the
220:36 - error
220:37 - and this doesn't seem very much right
220:40 - now but we can make this look much
220:42 - better by adding another argument inside
220:46 - of the blit method
220:48 - the argument we need here is called a
220:50 - special underscore flags
220:53 - what we can do with this is set the
220:54 - blending mode
220:56 - the one we want is pygame dot blend
220:59 - underscore rgba underscore mult
221:04 - and now if i run this
221:06 - and try the same thing again
221:10 - now we have a much nicer transition
221:13 - this blending mode works it basically
221:15 - gets rid of all of the white values so
221:18 - the brighter a value is the less visible
221:20 - it is going to be and the pure white
221:22 - value is going to be completely
221:24 - invisible
221:25 - that way at the beginning we are not
221:27 - seeing any of this image but the darker
221:30 - it gets the more we see of it and at
221:32 - some point it turns the entire screen
221:35 - pure black although right after that the
221:37 - entire thing crashes
221:39 - that we do have to work on
221:42 - fortunately it's not that difficult all
221:44 - we have to do is if self dot color is
221:48 - smaller or equal than zero and if that
221:51 - is the case i want to set self dot speed
221:56 - and multiply it with negative one
221:59 - besides that if self.color
222:02 - is greater than 255
222:05 - because now after these two lines
222:08 - we are increasing the color continuously
222:12 - and at some point it's going to be
222:14 - greater than 255
222:15 - which is also going to be a problem
222:18 - we do need to limit that one as well
222:21 - if that is the case at least for now i
222:23 - want to set self dot
222:25 - color to 255
222:28 - and with that we should be having a
222:30 - transition
222:31 - let me play main.pi and let's see how
222:34 - this is going to look
222:37 - we are still getting an error let's have
222:39 - a look
222:40 - i guess the main reason here is that
222:43 - once we get below zero
222:45 - we are only changing the speed we're not
222:47 - changing this number
222:49 - and as a consequence for this one frame
222:52 - things are falling apart but that we can
222:54 - fix quite easily all we have to do is
222:55 - set self.color to zero
223:00 - with that it should be working
223:03 - if i now walk next to the bed
223:06 - and this is working really well
223:12 - we are very nearly done
223:16 - there are three more things that we have
223:18 - to do let me write them all the way at
223:20 - the top number one we have to call the
223:23 - reset method
223:25 - number two we have to wake up the
223:27 - layer
223:28 - and number three
223:31 - we have to set the speed
223:33 - to
223:34 - negative 2
223:36 - at the end of the
223:38 - transition
223:41 - i am pretty sure you can already tell
223:42 - where this is going this is going to be
223:44 - your exercise
223:46 - work through these three parts and try
223:48 - to implement them yourself and see how
223:50 - far you get
223:54 - the reset method i want to call
223:57 - when we are reaching this point here all
224:00 - i have to do is call self.reset
224:04 - because reset we have stored here and
224:06 - this is the one we created in level.pi
224:08 - and this is all we needed
224:11 - let's try this one actually i created it
224:14 - but never tested it
224:15 - meaning now let's have a look at some
224:17 - trees
224:19 - you can see we have
224:21 - two apples on most of those trees
224:25 - and now if i go to bed
224:31 - and look at the trees again
224:33 - they are looking different which means
224:36 - the reset method has worked
224:38 - next up we have to wake up the player
224:41 - that should happen once the entire
224:43 - transition is over all the way at the
224:45 - bottom self.player.sleep
224:49 - should be false
224:52 - on top of that while the player is
224:54 - sleeping i don't want the player to be
224:56 - able to move that would be kind of weird
224:58 - this happens inside of the player
225:00 - and all the way at the top here
225:03 - i only want to allow any kind of input
225:06 - if we are not using a tool and
225:09 - if we are not self dot
225:12 - sleep
225:14 - this one we can also test quite easily
225:17 - now if i press enter i would try to move
225:19 - to the left
225:21 - and i tried and now i can move again
225:23 - after a couple of milliseconds meaning
225:25 - this one is working as well
225:28 - finally we have to set the speed to
225:31 - negative 2 at the end of the transition
225:33 - this is also going to happen at the
225:35 - bottom
225:36 - all we have to do here is set
225:39 - speed to negative two with that we are
225:43 - done
225:45 - this is the entire transition
225:48 - i guess we should probably try this a
225:49 - couple of times
225:51 - but this is working once if i try again
225:54 - now
225:55 - and this is working again and it keeps
225:57 - on working just fine
225:58 - with that we have a daytime transition
226:02 - and this one is going to update all of
226:04 - the trees as well
226:06 - later on once we have plans we are also
226:08 - going to make updates to those
226:10 - and that i guess we can actually start
226:12 - working on next
226:15 - with the trees finished we can start
226:17 - working on the soil and there is going
226:20 - to be a ton of logic in here
226:22 - basically what we have to do is we need
226:24 - one class that covers all of the soil
226:27 - and this glass has to be connected to
226:28 - all of the watering and all of the
226:30 - plants
226:31 - which is going to be a very chunky
226:34 - python file
226:35 - just to warn you probably for the next
226:37 - hour maybe two we are going to work just
226:40 - on the soil you have been warned but for
226:44 - now just to get started let's create the
226:47 - very basic logic for the soil so if the
226:50 - player uses the hole we want to create
226:52 - one soil tile
226:55 - once again i am inside my project and i
226:58 - want to create a new file that i'm going
227:00 - to call soil dot pi
227:03 - in here i have to import by game
227:07 - and i need from settings import
227:10 - everything
227:11 - with that covered i want to create a new
227:14 - class called soil
227:16 - layer
227:17 - no need for inheritance but in here i
227:19 - want to have a init or done the init
227:22 - method with self and for now all
227:26 - sprites
227:28 - because in here each of the soil patches
227:32 - is going to be a dedicated sprite and to
227:34 - make them visible we have to attach them
227:36 - to all sprites
227:38 - as a consequence we do need them
227:39 - available inside of the class
227:42 - inside of this class i want to add
227:45 - one section let's call it
227:48 - sprite
227:49 - groups
227:51 - and in here i want to have self dot all
227:53 - sprites
227:55 - as my all sprites
227:57 - besides that since i do want to have
228:00 - easy access to all of my soil patches i
228:02 - want to create another attribute that i
228:04 - call self.soil
228:06 - sprites and this is just going to be
228:09 - another pygame dot sprite
228:11 - dot group
228:13 - after that
228:14 - we are going to need
228:16 - graphics
228:17 - and for now this is going to be
228:20 - very simple we have a single self.soil
228:24 - underscore surface
228:26 - and this is something we are going to
228:27 - import
228:29 - here we have the project i want to go to
228:31 - graphics and there we have the soil
228:36 - and in there we have a bunch of
228:39 - different things for now all i want to
228:41 - import is the file called o
228:43 - what all of the other files do you will
228:46 - see in the next major part for now just
228:48 - don't worry about them it's honestly
228:50 - better for you meaning all i want to do
228:52 - is pygame dot image dot load the path we
228:56 - need here is one folder up then graphics
229:00 - then we need soil
229:03 - and in the app we have o dot png with
229:06 - that we do have a setup but now we do
229:10 - have a couple of problems first of all
229:12 - not every single tile in our map should
229:15 - be farmable
229:16 - let me demonstrate this entitled
229:18 - actually
229:19 - here's the entire level
229:21 - and i think it should be quite obvious
229:23 - that not every single tile here should
229:25 - be farmable in fact
229:28 - i only want this area here
229:31 - to be farmable
229:34 - this is also going to exclude the house
229:36 - and the path
229:38 - none of these should be farmable
229:40 - only the stuff that is inside of this
229:42 - area i hope you can see what i'm talking
229:45 - about
229:47 - for that there is a whole other layer
229:49 - called farmable if i make this one
229:51 - visible you can kind of see what i am
229:53 - talking about only the pure green tiles
229:56 - here should be farmable meaning this is
229:59 - what we have to import and then only if
230:02 - the player hits one of these areas
230:05 - only there we are going to create a soil
230:07 - tile
230:08 - however now we do have another problem
230:12 - and that is that we have to manage quite
230:14 - a bit of data and this i want to address
230:17 - early because is becoming really
230:19 - important
230:20 - basically later on for every single one
230:23 - of the tiles we have to check a couple
230:24 - of different things let me add a couple
230:27 - of comments here in terms of what we
230:29 - need so requirements
230:32 - for each of the tiles
230:34 - we need to know
230:36 - if the area is far mobile that's the
230:40 - thing you have just seen
230:42 - besides that later on for the plants we
230:45 - also need to know if the soil has been
230:48 - watered
230:50 - and we have to know if this soil has a
230:53 - plant already for example if we want to
230:56 - plant a new plant we cannot plant that
230:58 - new plant if the soil patch has a plant
231:01 - already i hope that sentence makes sense
231:04 - meaning we need to have quite a robust
231:06 - way to manage all of this data as a
231:09 - consequence i'm going to store all of
231:11 - this information in one grid
231:14 - that for now is only going to store if
231:17 - we have a farmable area or not
231:20 - but let's do all of this in a separate
231:21 - method that i called create soil
231:24 - underscore grid
231:26 - in here we don't need any parameters
231:30 - and in here i want to create one list
231:33 - that contains other lists and one list
231:36 - for each tile of the game
231:38 - let's do this in tiled actually
231:41 - so when you look at these specific tiles
231:43 - here each of these cells is one tiled
231:47 - and in the grid i am going to create
231:49 - every single tile is going to be one
231:51 - list and this list is going to contain a
231:53 - couple of different pieces of
231:55 - information the one we are going to care
231:57 - about now is if it is farmable or not
232:01 - which i'm going to do by just adding a
232:03 - capital f inside of the list if it is
232:05 - farmable and well there's not going to
232:08 - be an f if it's not farmable that way we
232:10 - can always tell which one we have
232:13 - although to create this we first of all
232:15 - have to know how tall the map is
232:18 - for that i have to import the background
232:21 - image or the floor this one i get with
232:23 - pygame.image.low
232:26 - the file path here is one folder up then
232:29 - we have graphics then we have the world
232:32 - and then we have ground dot png
232:35 - this one we don't have to convert
232:37 - because we're not going to show it to
232:38 - the player instead what i want to do i
232:42 - just want to know how many tiles we
232:43 - actually have in the entire thing
232:46 - i want to know how many horizontal and
232:48 - how many vertical tiles we actually have
232:51 - this information i get by simply taking
232:53 - the whole width and dividing it by the
232:55 - tile size
232:57 - for example for the horizontal tiles
233:01 - i want to get my ground and then get
233:03 - underscore with
233:05 - and floor divided by the tile underscore
233:09 - size
233:11 - this i also need for the vertical tiles
233:14 - and this i can all do on one line so v
233:16 - tiles in here
233:18 - and this one i get with ground dot get
233:21 - underscore height
233:24 - although this one also has to be floor
233:26 - divided by tile underscore size
233:29 - i guess while we're here let me actually
233:31 - print the h tiles and the
233:34 - v tiles
233:36 - also i do want to call this method here
233:39 - in the indented method so self.create
233:41 - soil grid
233:43 - although first of all i do want to
233:46 - create this soil file inside of my level
233:50 - that way i can show you what the
233:52 - progress is while we are making it that
233:54 - should make all of this easier to follow
233:58 - all i really want here is from soil
234:00 - import soil
234:02 - layer
234:04 - this soil layer should become an
234:07 - attribute let's call it soil underscore
234:09 - layer
234:10 - and here soil layer
234:13 - really important we have to pass in one
234:15 - argument and that is going to be all
234:17 - sprites
234:19 - which we get up here
234:21 - and now if i run all of this
234:24 - we can see we have 50 horizontal tiles
234:27 - and 40 vertical tiles
234:29 - which if i look at tiled and look at map
234:33 - and mid properties
234:34 - we have in the top left
234:37 - the width and the height and this is 50
234:40 - and 40. so this one is working just fine
234:43 - this i can now use to create a list of
234:46 - lists with every single tile being one
234:49 - individual list this is going to happen
234:51 - inside of soil.pi
234:54 - and what i want to create is self.grid
234:59 - this one we are going to do with list
235:02 - comprehension and let me add a bit of
235:04 - white space in here because this one
235:06 - gets slightly more complicated
235:10 - first of all i want to go through every
235:12 - single one of my columns and i want to
235:14 - create an empty list for my column in
235:18 - range
235:19 - h
235:20 - tiles
235:22 - although this is only a single one so
235:25 - i'm going to put this in another list
235:28 - comprehension
235:29 - which is going to be for
235:31 - row in range v
235:34 - tiles
235:36 - now i can get rid of the white space
235:40 - and let me just print what we actually
235:43 - get so self.grid
235:46 - run all of this
235:47 - and we are getting
235:50 - a very long list of lists
235:53 - the entire thing is one long list
235:56 - inside of this list we have one list for
236:00 - each row inside of the game
236:02 - and then inside of this row
236:05 - we have one more list for each
236:07 - individual cell
236:09 - now that we have that we have to
236:11 - actually check inside of tiled
236:14 - let me open it again we have to know
236:16 - which of these tiles are farmable and
236:19 - for that we need pi tmx again meaning i
236:22 - want from pi tmx dot util underscore
236:27 - pi game import load underscore pi game
236:32 - once i have that
236:34 - i want to use load pi game and load my
236:37 - tmx data file
236:39 - that i get by going
236:41 - up one folder there we have data in
236:44 - there we have map.tmx
236:47 - since we are only going to use this once
236:50 - i can use a method straight away and
236:52 - that is get layer
236:54 - by
236:55 - name
236:57 - the layer we need is called farmer bill
237:02 - and on this one we want to get the tiles
237:05 - because this one allows us to use all of
237:07 - this inside of a for loop
237:09 - meaning in here this is the one we have
237:11 - already seen we have for x
237:13 - y
237:14 - and a surface in load pi game
237:18 - although for this one we don't really
237:19 - care about the surface meaning i'm going
237:21 - to use an underscore to just ignore it
237:24 - or to indicate that i don't care about
237:26 - it
237:27 - what i now have to do is to figure out
237:30 - which of these grid cells corresponds to
237:32 - the x and y values and then add a
237:35 - capital f for each of those
237:37 - which is honestly very simple all i need
237:40 - is self.grid
237:42 - and first of all i need the row which is
237:44 - the y position this is going to give me
237:46 - another list and on this list i want to
237:49 - get the x position which is the column
237:53 - and now i'm getting a list and i want to
237:55 - append a capital f to that
237:59 - that is basically it if i now print self
238:02 - dot grid
238:05 - and run all of this
238:07 - we are getting an even stranger list
238:11 - what we're seeing in here is every
238:13 - single cell where we have a capital f
238:15 - this cell can be farmed
238:17 - what you should be seeing here actually
238:19 - is the first couple of lists should be
238:21 - entirely empty because on the top of the
238:23 - map there's nothing farmable
238:26 - and we only get a bit further down
238:28 - an actual f tile
238:32 - i suppose we can make this a bit easier
238:35 - to read by
238:36 - going for row in self dot grid
238:41 - and then print the row
238:45 - if i now run all of this
238:48 - this is well still very difficult to
238:51 - read but you can see it a tiny bit
238:53 - better this one here is the first row
238:55 - there's nothing and this continues for a
238:57 - couple more rows quite a few actually
239:00 - and at some point for this row here we
239:02 - have a couple of empty cells and then we
239:04 - start having four cells that are
239:07 - actually being farmable
239:08 - if i look at this inside of tiled
239:11 - you can see
239:12 - on the first row we have a lot of
239:14 - nothing and then we have four cells that
239:17 - are going to be farmable
239:19 - which is a pretty good sign that this is
239:21 - going to work
239:23 - i guess for one double check on the next
239:25 - row we have a couple more cells that are
239:27 - farmable and then we have a gap and a
239:30 - few more cells
239:32 - let's check this one out
239:34 - on the next row we have a gap then we
239:37 - have six thumb cells then we have
239:40 - another gap and then a few more farmable
239:42 - tiles so this is looking pretty good
239:46 - with that we have a grid
239:49 - that can store at least one bit of
239:51 - information
239:53 - it is going to get a bit more
239:54 - complicated later on actually
239:57 - what we now have to figure out is how
239:59 - the player can hit all of those with the
240:02 - whole
240:03 - for that i want to create another method
240:06 - and this i called create hit
240:08 - rects
240:09 - no need for any kind of parameters here
240:12 - and what we are going to do is for every
240:14 - single tile we are going to create a
240:16 - rectangle that the player can hit
240:19 - this i'm going to store in self.hit rex
240:22 - which is just going to be a list
240:25 - and now i have to cycle through
240:27 - myself.gridlist
240:29 - and convert all of the cells into actual
240:32 - positions and for that i am going to
240:36 - need the enumerate method
240:38 - let's go through it slowly
240:40 - i first of all want to get for row in
240:44 - self.grid
240:46 - and inside of that i want for
240:49 - cell in
240:51 - row
240:52 - let me give a bit of white space here to
240:54 - explain what is going to happen
240:57 - we essentially have a list
241:00 - that is going to contain let me draw it
241:02 - really quick so we have a couple of
241:04 - lists and inside of each list we have a
241:07 - few more lists
241:09 - the first for loop this one here goes
241:13 - through all of the lists and then the
241:16 - inner for loop this one here goes
241:18 - through these lists here which is
241:20 - basically horizontal axis
241:22 - the problem we have right now is we need
241:24 - to know on what list we are on for
241:27 - example we have to know that this one is
241:29 - list 0 this one is list 1 this one is
241:31 - list two and so on
241:34 - and for that we need enumerate
241:37 - i want to put both of these inside of an
241:40 - enumerate function
241:42 - that way
241:43 - we are first getting the index we are on
241:45 - and then the actual information
241:48 - let's call this one the index row
241:52 - and the second one i called the index
241:55 - column
241:56 - inside of this we can actually check
241:58 - every individual cell and i want to
242:00 - check if f
242:02 - is inside of this cell
242:05 - if that is the case
242:08 - i want to create an x position
242:10 - i want to create a y position and then i
242:14 - want to create a rectangle
242:17 - and this rectangle i want to append to
242:19 - myself dot hitrex dot append dot rect
242:23 - and now for the position and the
242:25 - rectangle i think this could be a really
242:27 - good exercise i hope you're not entirely
242:29 - lost at this point
242:31 - but try to figure out we are now
242:33 - creating a couple of rectangles and for
242:35 - each rectangle we have to convert the
242:38 - position in the grid to an actual xy
242:41 - position inside of our game
242:44 - so try if you can figure this one out
242:47 - we know where each cell is inside of the
242:50 - grid we also know what the tile size is
242:52 - if you want a hint but pause the video
242:55 - now and try to figure this one out
242:56 - yourself
243:01 - this is actually fairly simple all we
243:02 - need for the x position is the index
243:05 - column multiplying it by the tile size
243:10 - for y this is going to be the index row
243:14 - also multiplied by the tile size
243:17 - finally then for the rectangle we have
243:19 - pi game dot rekt
243:21 - and in here we need x we need y
243:24 - and then we need the tile size and the
243:26 - tile size
243:29 - meaning for this rectangle x and y is
243:31 - the top left and the tile size is always
243:33 - going to be 64 by 64. and that way
243:37 - we have a rectangle created for every
243:40 - single cell that has an f
243:44 - do not forget to call this one now self
243:47 - dot create hit rex
243:52 - and now we actually have something the
243:54 - player can hit
243:56 - although i guess for this one we have to
243:59 - create another method let's call this
244:01 - one get hit
244:03 - in here we need self and i want to have
244:06 - a point and this is the point the player
244:08 - can hit
244:10 - in here i want to check for rect in self
244:13 - dot hit underscore rects
244:17 - and i want to check for each rectangle
244:19 - if the rectangle was being hit by the
244:22 - point we have specified in the parameter
244:24 - which we get with
244:26 - rect.collide point
244:29 - and the point we are getting from the
244:30 - parameter
244:31 - if that is the case i have to convert
244:34 - this rectangle position back into my
244:37 - grid and that way i can identify if i
244:40 - have a list with an f or not
244:44 - and well for that i have to do basically
244:46 - the opposite i have done here
244:49 - i need an x
244:51 - and i need a y position
244:53 - and for the x i want to get my wrecked
244:56 - dot x
244:57 - and floor divided by the tile size
245:01 - this i also want to do for y except now
245:03 - it's rect.y
245:05 - floor divided by the tile size
245:10 - the way you want to think about it let's
245:12 - say we have one tile here and another
245:15 - tile here
245:17 - the first tile starts at position zero
245:20 - and zero the second one at position 64
245:24 - and zero these points here
245:29 - if we now for example for x have
245:32 - something like
245:34 - 91
245:36 - if i floor divide 91 by 64 we are going
245:40 - to get one
245:42 - which is going to be
245:44 - this
245:45 - tile here
245:46 - that way i have converted a pixel
245:48 - position this one here into an actual
245:51 - tile position that we can use to get
245:53 - information from this self.grid
245:56 - and with that i can check if the string
245:59 - f is in self.grid
246:03 - and once again we have the entire list
246:06 - of lists we first want to get y for the
246:08 - rows and then we want to get x for the
246:11 - columns
246:12 - and now if that is the case i want to
246:16 - print
246:17 - let's call it farmer bill
246:19 - what we now have to check is how to call
246:22 - this self.gethit
246:24 - my solution to that is i'm going to pass
246:27 - a reference to the entire soil layer
246:29 - into the player
246:30 - which happens inside of the level
246:33 - inside of the setup method
246:36 - when i create the player the player is
246:39 - going to have one more parameter that i
246:42 - called soil layer this is going to be
246:44 - self dot soil
246:47 - layer
246:48 - that way inside of the player
246:50 - i can create another attribute
246:54 - soil
246:55 - layer
246:56 - don't forget to turn this parameter into
246:59 - an actual attribute self dot soil layer
247:02 - is soil
247:04 - layer
247:05 - and now when we are using the tool
247:08 - i
247:09 - can get rid of the print statement and
247:12 - when we're using the whole i want to get
247:15 - self.soil layer
247:17 - and that way i can target or use this
247:21 - method here
247:22 - which means inside of player i want dot
247:26 - get
247:27 - it
247:28 - and the position is the same target
247:31 - position we have used for the x
247:34 - target position in here and now this
247:36 - should be working let's try
247:39 - although we're getting an error the
247:41 - level object has no attribute soil layer
247:43 - let's have a look
247:45 - inside of level we need a soil layer and
247:48 - i think i just called it soil
247:51 - ah no the problem is i am creating soil
247:53 - layer after the setup method
247:56 - that is a very easy thing to fix all i
247:58 - need is the soil layer before the setup
248:00 - method
248:01 - now if i run this there we go and i can
248:04 - use the whole and we get farmable if i
248:07 - use this here but if i go further to the
248:09 - right and use it here we are not getting
248:12 - anything
248:13 - and let me make this a bit smaller there
248:15 - we go
248:16 - with that we know where we are hitting
248:20 - something
248:21 - or more importantly if that is farmable
248:24 - or not
248:25 - if that is the case
248:27 - i want to get myself dot grid
248:31 - with the y and the x
248:34 - and append
248:37 - a capital x
248:39 - this is telling me that on this tile we
248:42 - have a soil patch
248:44 - once i have that i want to run another
248:47 - method that i call create soil
248:50 - tiles
248:52 - this one for now is going to seem quite
248:54 - weird but it is going to make much more
248:56 - sense in the next video
248:58 - but for now
249:00 - all that this create soil tiles is going
249:04 - to do
249:05 - we need self in here as always
249:08 - i want to get rid first of all of all of
249:11 - the existing soil tiles which i get with
249:14 - self.soil
249:15 - sprites dot empty
249:18 - after that i want to look through the
249:22 - entire grid and wherever there is an x i
249:25 - want to create a soil tile
249:27 - which means once again i can basically
249:30 - copy
249:32 - all of this here
249:34 - paste it in there
249:37 - and in here what i want to check is if
249:39 - capital x is in the cell
249:43 - and if that is the case
249:45 - i want to create a soil tile
249:49 - this one doesn't exist right now let me
249:51 - minimize a couple of methods so we have
249:53 - a bit more space
249:55 - we don't need any of this
249:57 - although at the top i want to create
249:59 - another class that i call soil tile
250:03 - this one is a sprite so we need
250:04 - pygame.sprite.sprite
250:08 - after that we have to create a dunder
250:10 - init method this one itself a position a
250:14 - surface and the groups it's supposed to
250:16 - be part of
250:17 - then we have to call this super dunder
250:20 - init method
250:22 - and pass the groups in here
250:25 - after that we need self.image this is
250:28 - just the surface we're getting from the
250:29 - parameters and we need self.rect this
250:32 - one we are getting with self.image.get
250:35 - underscore rect
250:37 - and the top left
250:40 - should be the position
250:42 - the position and the surface here are
250:44 - really important
250:46 - finally this one is going to need a
250:48 - self.set position this one fortunately
250:51 - is very easy because if you look at the
250:54 - settings
250:55 - we have a dedicated layer for the soil
250:58 - this i want to copy and paste it in here
251:02 - and now we have a basic soil tile all we
251:05 - have to do now is to pass in all of the
251:08 - information into the class to create it
251:12 - for the position this is something we
251:14 - have already seen inside of create hit
251:18 - rectangles we basically want to do this
251:20 - one here again
251:21 - i guess i can just put it straight in
251:24 - here
251:26 - and with that we have the position the
251:28 - surface we also have that is inside of
251:31 - the dunder init this soil surface here
251:34 - this is what we want to paste in there
251:37 - finally for the groups i want to have
251:40 - self dot all sprites because they are
251:43 - supposed to be visible
251:44 - and then self
251:47 - but i called this one the soil sprites
251:51 - soil sprites
251:54 - and since this is getting quite long let
251:56 - me put it over multiple lines we have
251:58 - the position
252:01 - we have the surface
252:03 - and we have the groups that is much
252:07 - easier to read
252:08 - and with that we should have a basic
252:11 - start let's try all of this if i now hit
252:15 - the floor we have a soil tile
252:19 - this is working really well
252:22 - and if i hit
252:24 - some other field
252:26 - we are not getting anything
252:29 - with that we have the start of this soil
252:32 - tile and we also have a really efficient
252:34 - system to organize our data which is
252:38 - really important
252:39 - although this is getting a very long
252:41 - section so let's finish it for now let's
252:44 - keep on working on the soil patch
252:45 - graphics the one really important thing
252:48 - i want to cover in this section let me
252:50 - demonstrate it
252:52 - when we place one patch it looks like
252:54 - this when we place another one right
252:56 - next to it it looks like this
252:59 - which is okay for a basic game but
253:01 - ideally it should be looking something
253:04 - like this
253:06 - that is what we are going to create in
253:08 - this section
253:09 - we are going to create our own auto
253:10 - titling system that creates nice looking
253:13 - soil patches
253:15 - this is also the reason if i jump into
253:17 - my code
253:18 - inside of soil layer
253:20 - we have this weird setup here that every
253:24 - time the player is hitting the soil we
253:27 - are getting rid of all of the soil
253:29 - sprites and then drawing them from
253:31 - scratch
253:32 - what this allows us to do is to draw all
253:34 - of the soil patches together
253:36 - and that way we can control different
253:38 - graphics depending on the position of
253:40 - each soil patch or rather if one patch
253:43 - is next to another patch then they
253:46 - should get a specific kind of graphic
253:48 - that is what all of this here is for
253:51 - although for all of this to work we are
253:54 - going to need a whole lot more graphics
253:56 - this is going to happen all the way at
253:58 - the top
253:59 - right now we only have a single soil
254:02 - surface
254:03 - instead what we need if i open the
254:06 - folder again inside of graphics inside
254:09 - of soil
254:10 - we have to import all of these different
254:12 - elements this is what i've shown earlier
254:14 - and now
254:15 - basically what all of them do
254:18 - i guess i can't really make them larger
254:20 - but if you look at them individually
254:23 - for example here we have the left tile
254:26 - this is going to be placed if there is
254:29 - one tile to the right of this tile
254:32 - we also have a tile called lr short for
254:35 - left and right this one we want to place
254:38 - if there's a tile to the right and
254:40 - another tile to the left
254:43 - there's also a file called x all the way
254:45 - at the bottom and this one is supposed
254:47 - to be placed if we have tiles all around
254:50 - it
254:53 - so i hope the logic here makes sense
254:55 - basically each of these tiles is going
254:57 - to be placed relative to where the other
254:59 - tiles are
255:00 - but for that we have to input all of
255:02 - them
255:04 - now this i want to save in self.soil
255:08 - underscore surfaces
255:11 - and in here you might be tempted to use
255:14 - the support file this one here and use
255:16 - import folder that however would not
255:20 - work because we need to know which file
255:22 - we are working with in all of the
255:25 - examples so far we didn't really care
255:27 - about what specific image we had we just
255:29 - used all of them but for this one we
255:32 - need to know which tile we are working
255:34 - with
255:35 - as a consequence
255:36 - i want to create another function in
255:38 - here i want to create import folder
255:43 - dictionary
255:45 - we again need a path
255:48 - although now we want to create a surface
255:51 - dictionary
255:52 - what i want to have in here is obviously
255:55 - a key value pair with the value being a
255:59 - surface one of the surfaces we are going
256:01 - to import however the key should be
256:04 - something like right it should be left
256:06 - it could also be something like x or lr
256:11 - and this is what we are getting from the
256:13 - folder so i want the key to be the name
256:16 - of each of these files and the file
256:18 - itself the value
256:20 - and that is what we have to create in
256:22 - here
256:23 - and this i believe could be a really
256:25 - interesting exercise look at this logic
256:28 - here and adapt it so that we are
256:31 - creating a dictionary with key value
256:33 - pairs and at the end of it return the
256:35 - entire thing
256:37 - pause the video now and try to figure
256:39 - this one out
256:43 - a lot of the stuff i can just copy the
256:46 - first three lines are going to remain
256:48 - identical
256:50 - because in here we are just accessing
256:52 - every individual file path that we are
256:54 - going to need so no change so far
256:58 - as a matter of fact the surface is also
257:00 - going to remain the same so a lot of the
257:02 - stuff remains identical
257:04 - the one difference now is when we are
257:06 - getting the surface dictionary i don't
257:10 - just want to append something instead i
257:12 - have to get a specific key or rather i
257:15 - have to create a specific key
257:18 - this i want to be the file name which i
257:21 - get with image and the image right now
257:24 - would be something like l dot png
257:27 - the png i do want to get rid of
257:30 - that i'm getting with split
257:32 - i want to split it wherever we have a
257:34 - dot
257:35 - and then i want to get the index 0 of
257:38 - this list
257:40 - this is always going to give me the name
257:41 - of the file without the file ending
257:44 - this is going to be my key and the value
257:46 - is going to be the image surface
257:50 - and that is all we needed all we have to
257:53 - do now is to return this surface
257:56 - dictionary and we are good to go
258:00 - now back to soil.pi and in here i have
258:03 - to import from so port
258:07 - import let's say everything
258:09 - and now i want import folder underscore
258:13 - dictionary
258:14 - and the file path i need is this one
258:18 - here
258:19 - i guess just to try if this is working
258:22 - let me print
258:24 - self.soil
258:26 - surfaces
258:27 - and run the entire thing
258:31 - the game doesn't crash that is generally
258:33 - a good sign and now we are getting what
258:36 - i wanted
258:37 - we have a key with for example b this
258:40 - stands for bottom
258:42 - and we have a surface associated with it
258:45 - in this we have multiple times these are
258:48 - all of the files that we wanted
258:50 - with that i can close the support file
258:53 - because we are not going to need it
258:54 - anymore
258:57 - i can also get rid of the print
258:59 - statement here this one isn't needed
259:01 - either
259:03 - and with that we are coming to the
259:06 - really fun part basically what we now
259:09 - have to do is to create the entire auto
259:11 - tiling option so let me go through step
259:13 - by step first of all i want to add let
259:17 - me call it tile options
259:19 - in here i'm going to determine what is
259:21 - to the left to the right to the top and
259:23 - to the bottom of the current cell
259:26 - which means we are going to cycle in
259:29 - here through every single cell in our
259:31 - grid one cell could look like this
259:34 - i have to know
259:36 - what is on the right on the left on top
259:39 - and on the bottom
259:41 - this is going to determine what graphic
259:43 - we are getting in here
259:45 - so first of all i want to have easy
259:47 - access to all of these options
259:49 - which i'm going to store in a variable
259:51 - we have top we have right we have left
259:54 - and we have bottom
259:56 - i want to check if we have a capital x
259:59 - in for example for the top self.grid
260:04 - and then usually we went with y and x
260:08 - although those we don't have available
260:10 - right now but we do have the index row
260:12 - and the index column those we can use
260:16 - index column is basically x this one we
260:18 - can use like this
260:20 - and y is going to be the index row
260:23 - this we can use here
260:25 - although for the index row since we do
260:27 - want to have the cell on top of our
260:29 - current cell
260:30 - this needs to be negative one
260:33 - and i guess while we are here we can
260:35 - also do the bottom because this one is
260:37 - very similar
260:39 - we can basically copy the entire line
260:41 - and instead of a negative one we have a
260:44 - positive one
260:46 - for right and left we are also checking
260:49 - for a capital x except now we are
260:52 - checking in
260:53 - the row
260:55 - and we're checking
260:57 - index
260:58 - column
261:00 - -1
261:01 - this is working because we have the row
261:03 - quite easily accessible and this we can
261:06 - use this i want to copy one more time oh
261:10 - and i just realized right should be plus
261:12 - one and left should be minus one
261:15 - and with that we know for each of the
261:17 - tiles what the neighbors are doing now
261:20 - this system is still fairly simple
261:23 - because if i open the graphic again
261:26 - for most of the tiles we are only
261:27 - checking the four directions but there
261:30 - are four more we have the top right the
261:33 - bottom right the bottom left and the top
261:36 - left i am not going to check any of
261:38 - those because that would become
261:40 - incredibly complex and i don't really
261:42 - need it
261:43 - but if you want to have a proper auto
261:45 - titing system you would have to do it
261:47 - which would lead to a ton of if
261:50 - statements
261:51 - but let's go through it one by one now
261:53 - first of all i need to get some kind of
261:56 - tile type
261:58 - and this by default is going to be an o
262:02 - if i open this thing here again o is the
262:06 - default one the one we have already seen
262:08 - and this is a nice default one if
262:10 - everything else fails having this one
262:12 - probably isn't going to be too bad
262:15 - and now this we can use inside of soil
262:19 - tile because in here we have a surface
262:22 - this i want to replace with soil
262:23 - surfaces
262:24 - which is a dictionary and this
262:27 - dictionary i can access with my tile
262:30 - type and let's try this one right now if
262:34 - i run main.pi
262:35 - and use the whole everything works just
262:38 - as before that is a good sign
262:41 - and what i can do now i could for
262:43 - example change this to an lr
262:47 - run main.pi again
262:49 - and now we are getting a different kind
262:51 - of tile
262:53 - all we have to figure out now is to make
262:55 - all of this a lot more flexible
262:58 - which is going to involve a huge amount
263:01 - of if statements
263:03 - let's start with the really easy one all
263:06 - sides this one should illustrate the
263:08 - logic here quite well
263:10 - basically what i want to check is
263:12 - all of these are either true or false
263:16 - and i want to check if all of them are
263:18 - true
263:19 - this could for example be if l and b
263:23 - and
263:24 - r and l
263:26 - if that is the case
263:28 - i want to have the tile type
263:31 - to be
263:33 - an
263:33 - x
263:35 - this should be an equal sign and now
263:38 - let's try this one
263:42 - so here we have the center tile and i
263:44 - want to create tiles to the left and to
263:46 - the right and now to the bottom and
263:48 - there we go the thing updated
263:52 - this was the easiest kind of side
263:55 - although this we can clean up a tiny bit
263:58 - this we're doing with the all function
264:01 - and the all function checks if all
264:03 - values inside of an iterable like a list
264:06 - are true meaning in here we can pass t r
264:09 - b and left
264:11 - and we should be having the same result
264:15 - also let me put all of this on the same
264:17 - line
264:18 - because we are going to have a lot of
264:20 - lines
264:22 - let's try this one again
264:28 - it should still have the same result
264:32 - and it does this is looking really good
264:36 - that is covering all of the sides so
264:39 - next up we can start working on the
264:43 - horizontal tiles only
264:47 - this means i want to check if i have a
264:50 - tile and if there is a tile to the left
264:53 - or to the right or to
264:57 - both sides
264:59 - meaning we are going to have three
265:01 - different if statements here
265:03 - the first one we want to check if l is
265:06 - true so there's a tile left and not any
265:11 - inside of top right and bottom
265:16 - any kind of works like all except now we
265:18 - want to check if any of those is true
265:21 - for all to work all of them have to be
265:23 - true for any to trigger
265:26 - only a single one in there has to be
265:28 - true
265:30 - and let me illustrate the logic here
265:32 - let's say we have a tile like this
265:35 - and we only want to check if there is a
265:38 - tile on the left of it this is what we
265:40 - are doing in here
265:42 - if this is true we would ideally want
265:44 - some kind of graphic that would look
265:46 - something like this
265:50 - this would be working by itself but we
265:52 - also have to check that there are no
265:55 - tiles on top to the right or at the
265:57 - bottom of this tile which is what we are
266:00 - doing here if that was the case we would
266:03 - be needing some kind of other condition
266:06 - which we are going to do in a bit but i
266:09 - do not want to confuse the different if
266:10 - statements here
266:12 - each of those should be unique
266:15 - if that is the case though i want to
266:17 - have my tile type and now the tile
266:20 - should be right
266:22 - which means if a tile only has a tile to
266:25 - the left and nothing else we want tile
266:28 - type to be right
266:30 - let's try this one
266:32 - i have a tile here
266:34 - and if i had another one this one is
266:36 - going to be to the right
266:37 - i can continue doing this
266:40 - and now you can kind of see the one to
266:42 - the right works really well but the one
266:44 - in the middle gets a bit confused
266:47 - but that is something we can work on
266:51 - although first of all i can cover the
266:53 - right side which is kind of simple all i
266:55 - need is if r is true
266:58 - and now
266:59 - this should be t
267:01 - l and b
267:03 - we are basically doing the inverse of
267:05 - this one here and this one should be l
267:09 - then i can copy this one more time
267:11 - and now i want to check if we have a
267:13 - tile to the left and to the right
267:15 - which means i want to check if r is true
267:18 - and if l is true
267:21 - and if we don't have
267:23 - top and bottom
267:25 - if that is the case
267:27 - the tile type i want is left and right
267:32 - with that i should be having the
267:34 - horizontal logic
267:36 - if i run this now
267:38 - i can create some tiles here and this is
267:41 - looking very good
267:42 - although if i go down we are getting
267:45 - some weird results
267:47 - but that
267:48 - we can start working on in the next part
267:51 - which is going to be vertical only
267:55 - in here i want to check if we have a
267:57 - tile on top and not any tiles inside of
268:01 - the list right left and bottom
268:04 - if that is the case the tile type i want
268:08 - should be
268:09 - autumn
268:10 - i can copy this one more time because
268:12 - now we can check if we have a tile at
268:14 - the bottom and i also want to check if
268:17 - we have no tiles to the right to the
268:18 - left and to the top
268:21 - if that is the case i want to have a
268:23 - tile with the type t
268:25 - finally one more time now i want to
268:27 - check if we have a tile on the bottom
268:30 - and on the top
268:32 - and
268:33 - not
268:34 - do the right to the left and that is it
268:37 - if that is the case
268:39 - the tiles i have are t and b
268:42 - with that we have the vertical tile
268:44 - types let's try this one so now if i
268:48 - only go down
268:51 - this is also looking really good
268:53 - and i can still use
268:56 - the horizontal ones as well
268:58 - although now if i connect them we are
269:00 - again getting weird results
269:03 - which means we need some more if
269:06 - statements
269:07 - let's go with the corners for this one
269:11 - if this is the tile i for example have
269:14 - to check if there is a tile to the left
269:17 - and the tile to the bottom
269:19 - if that is the case this should be a
269:21 - corner like that
269:23 - which if you could follow along so far
269:25 - should be fairly doable
269:27 - it's going to look kind of similar
269:29 - compared to these lines at the end here
269:31 - let me copy it actually
269:33 - for this one i want to check if we have
269:35 - a tile to the left and a tile to the
269:37 - bottom
269:38 - and i do not want to have a tile on the
269:41 - top and the tile on the right
269:43 - and if all of that is the case i want to
269:46 - have a top right tile
269:48 - this logic is going to continue like
269:49 - that so let me just copy from my notes
269:53 - it's going to look like this
269:54 - these are all of the different kind of
269:57 - corners we could possibly have if i try
270:00 - this one now i can go down
270:03 - and now if i go to the right we have a
270:06 - corner
270:08 - the thing we are still missing though
270:09 - are t shapes because if i do this things
270:12 - are falling apart once again
270:16 - which is going to be another section and
270:19 - this is going to be t shapes
270:22 - in here for example i want to check if
270:24 - we have a tile and there is another tile
270:28 - on the top on the bottom and to the
270:30 - right
270:32 - if that is the case i want to have this
270:33 - kind of t shape
270:35 - which means in here i want to have if
270:37 - all
270:38 - and the tiles i want to look at are
270:41 - let's start with top bottom and right
270:45 - also i have to check and not
270:48 - left
270:49 - if that is the case i want to have a
270:51 - tile type of
270:54 - ebr let's try this one
270:59 - now i have my tile and i have a tile to
271:01 - the top
271:02 - to the right
271:04 - i'm at the bottom and to the right and
271:06 - there we go we have a t piece and now if
271:08 - we add one more direction we have an x
271:10 - piece so this is working just fine
271:13 - this i now have to copy a couple of
271:15 - times because we have to cover the other
271:17 - sides as well
271:18 - next up would be top bottom and left and
271:22 - not right if we have that we have a
271:25 - title called tbl
271:28 - copy it one more time
271:30 - now we have
271:32 - left
271:33 - right and top
271:35 - and not
271:37 - bottom
271:39 - if that is the case the tile i want to
271:40 - use is called
271:42 - lrb
271:44 - finally the last one
271:46 - i want to check if we have left right
271:49 - and bottom and not the top
271:52 - and if that is the case i want to have
271:54 - lrt
271:56 - and with that we should have a proper
271:59 - auto titling system so let's try the
272:01 - entire thing now
272:02 - i can just go around create more tiles
272:06 - this is looking pretty good
272:09 - and yeah i'm quite happy with this
272:11 - although you can probably see there are
272:14 - some minor thingies
272:16 - these
272:17 - little bits here
272:19 - they exist because the auto titling
272:21 - system here is not perfect for example
272:26 - this tile here
272:28 - is technically a corner tile where we
272:30 - have a tile to the bottom and to the
272:32 - right
272:33 - and corner tiles always have this kind
272:35 - of bit here at the end
272:37 - this we could get rid of by adding a bit
272:39 - more logic for this tile to also check
272:42 - if there's something for the bottom
272:44 - right
272:45 - although in my case i think this looks
272:46 - fine and if we added more logic here
272:49 - this would become even more complex
272:52 - and i think this is already quite a lot
272:55 - of if statements so i'm going to leave
272:57 - it as it is
272:59 - and now i can minimize all of this and
273:02 - we have definitely made a ton of
273:04 - progress
273:06 - for this part we are going to work on
273:08 - the watering logic
273:10 - which with the current system in place
273:13 - isn't all that difficult to do
273:15 - let's jump right in and let's do it step
273:17 - by step
273:18 - once more we have the entire project and
273:21 - i want to start inside of the player let
273:24 - me minimize everything
273:27 - and we already have the use tool method
273:29 - here
273:30 - inside of there we have selected tool
273:33 - being water
273:34 - if that one is being triggered i want to
273:37 - once again get myself the soil layer
273:40 - remember here the player has access to
273:42 - the entire soil layer this we have also
273:45 - used for the whole however now i want to
273:47 - use a method called water which doesn't
273:49 - exist right now but will in just a
273:52 - second and here once again we need our
273:54 - target position
273:56 - and with that we can return to the soil
273:59 - file and all we have to do now is to
274:02 - create another method let's do it
274:05 - below get hit i call this one water in
274:08 - here we need self and the target
274:11 - position
274:12 - what i want to check in here is if this
274:14 - target position hits any of the soil
274:16 - sprites any of those here
274:19 - oh also i forgot the soil surface we can
274:22 - get rid of because we don't need it
274:24 - anymore for the water i want to check
274:27 - for soil
274:29 - sprite
274:30 - in self.soil
274:33 - sprites and there's already typo in
274:36 - there
274:37 - dot sprites
274:39 - i want to check if soil sprite
274:43 - dot wrecked dot
274:45 - light point
274:46 - and in here i can add my target position
274:49 - and let's try this one first if that is
274:52 - the case i want to print
274:55 - soil tile watered
274:58 - and the rest should already work let's
275:01 - try i want to create a water tile change
275:04 - to the watering can and now use it and
275:07 - we get soil tile
275:09 - watered
275:10 - which means
275:12 - this here is already working
275:14 - this means i have to do two things
275:17 - number one i want to add an entry to
275:20 - this soil red
275:23 - which means i want to add a capital w to
275:26 - the cell
275:28 - besides that number two i want to create
275:31 - a water sprite this is going to indicate
275:34 - that there is water on this tile
275:37 - let's start with number one in here we
275:40 - have the same problem again we have a
275:42 - position for this soil sprite but we
275:45 - need a cell position
275:47 - which means we have to do some
275:49 - conversion
275:50 - we need an x position and a y position
275:53 - and what we need in here is the soil
275:56 - sprite
275:57 - dot rect.x floor divided by the tile
276:02 - size
276:03 - this i want to do again for y let me
276:06 - copy the entire thing except now this
276:09 - should be rec dot y
276:11 - that way i can use these positions to
276:13 - access the grid
276:15 - which i get with self.grid
276:18 - and now i want to have my y
276:20 - then i want to have my x
276:22 - and then i get a list and to this list i
276:25 - want to append a capital
276:28 - w
276:30 - that way we know which tiles have been
276:32 - watered and which ones haven't
276:35 - besides that number two i want to create
276:38 - a water tile to visually indicate that
276:41 - we have indeed watered this soil tile
276:43 - this water tile i want to create
276:46 - inside of this python file which is
276:49 - class water tile once again this is
276:52 - going to be a sprite so
276:54 - pygame.sprite.sprite
276:57 - we also need a dunder init method for
277:00 - the obvious reasons this one needs a
277:02 - position a surface and the groups
277:06 - and we also need a super dunder init
277:09 - method
277:10 - this one gets the groups as well
277:14 - although this class is going to be
277:16 - fairly simple all we're going to do in
277:17 - here is self.image is what we're getting
277:20 - from the surface
277:22 - self.rect
277:23 - is going to be
277:24 - self.image.getunderscorerect
277:28 - with the top left being the position
277:31 - like this
277:32 - and finally we are going to need self
277:35 - dot z
277:37 - this self.set we are getting from layers
277:40 - and inside of settings
277:44 - we have a soil water layer this i want
277:46 - to copy and paste in here
277:49 - i guess if you're being specific here
277:51 - this water tile and the generic tile are
277:55 - basically identical but i do want to
277:57 - keep things as separated as i can here
277:59 - but you could be a bit more aggressive
278:01 - with inheritance here it's entirely up
278:03 - to you
278:04 - and with that we have the water tile i
278:08 - just have to call it now and for this
278:10 - one we need a position we need a surface
278:13 - and we need the groups
278:15 - and that is going to be your exercise
278:17 - there are a couple of steps to it number
278:20 - one
278:21 - copy the position from
278:24 - the soil sprite meaning this water tile
278:28 - should be in the same position as this
278:30 - soil spray here which should be very
278:32 - easy to get
278:34 - number two for the surface
278:37 - i want you guys to import the folder
278:41 - with the path let me copy it really
278:44 - quick the path is going to be this one
278:46 - from this folder
278:49 - randomly select one surface
278:53 - finally
278:54 - i want you guys to create one more group
278:59 - let's call it water sprites
279:03 - and the water tile should be in all
279:05 - sprites and inside of water sprites so
279:08 - pause the video now and try to work
279:10 - through all four of those tasks and see
279:12 - how far you get
279:16 - i guess to make it easy to read let's
279:17 - store it in a separate variable but all
279:20 - we really want in here is the soil
279:22 - spread itself then dot rect which stores
279:25 - the position and then top left
279:28 - that is basically it
279:31 - for number two we have to import another
279:33 - folder and this should happen inside of
279:36 - the init method
279:38 - let's do it right below graphics it does
279:40 - seem to make sense here i call this one
279:42 - water underscore serves
279:45 - and in here we only want to import a
279:47 - folder which means import folder
279:50 - the file path being
279:52 - this one here
279:54 - in case you are interested if i open the
279:56 - graphics part we have soil water and in
280:00 - there we have three different water
280:03 - kind of tiles
280:05 - from those we want to select one
280:07 - randomly
280:09 - again let's do that in a separate
280:11 - variable let's call it surface
280:14 - and in here i want to use the choice
280:16 - function which we don't have yet but we
280:19 - can get it with from random import
280:22 - choice
280:24 - and i want to get a random self dot
280:27 - water surface
280:29 - and this is going to be part number two
280:32 - and three actually
280:35 - finally we need one more group this i am
280:38 - going to do up here
280:39 - and i want to create self dot water
280:42 - underscore sprites i think i called it
280:45 - yes
280:47 - this is going to be just another group
280:49 - so let me copy it and there we go
280:52 - now when we are assigning the groups
280:54 - i want to have self dot all sprites and
280:57 - self.water
280:59 - sprites
281:01 - and that is all we needed with that i
281:04 - suppose i can get rid of all of the
281:06 - comments because they are getting a bit
281:08 - annoying
281:09 - there we go this feels much better
281:13 - and now
281:15 - if i run main.pi again
281:17 - i can still use the hole and if i now
281:19 - use the water we have a water tile
281:22 - and i can do a couple more tiles and use
281:25 - the watering can again
281:27 - there we go this is working really well
281:31 - the last thing we need is that once i
281:34 - restart the game i want to destroy all
281:36 - of the water tiles and also get rid of
281:39 - the w for every single tile
281:42 - that is going to be a separate method
281:45 - let's call it remove water
281:49 - no need for any arguments in here and
281:51 - there are two things that we have to do
281:53 - number one is we have to destroy
281:57 - all water
281:59 - sprites and the second one is clean up
282:03 - the grid
282:05 - the first one is really simple all we
282:07 - need is for sprite in self.water
282:11 - sprites
282:13 - dot sprites
282:15 - and i want to just destroy all of the
282:18 - sprites
282:20 - that is going to be the first part
282:23 - the second part is going to be
282:26 - for row in self dot grid
282:30 - and then for cell in row what i want to
282:34 - check in here is if there is a capital w
282:38 - inside of this cell
282:40 - if that is the case i want cell dot
282:43 - remove
282:45 - and the capital w
282:47 - all i have to figure out now is when to
282:50 - call this method this is going to happen
282:52 - inside of level.pi
282:55 - in here once again let me minimize
282:57 - everything and i want to work inside of
283:00 - the reset method
283:02 - there is going to be another section
283:04 - let's call it soil
283:07 - and all i have to do is self dot soil
283:09 - layer and remove underscore water
283:13 - if i run main.pi again
283:15 - i can create a couple of soil patches
283:20 - water them and now if i restart the day
283:24 - this is still working fine and there we
283:26 - go this is looking really good
283:30 - so with that we have the watering logic
283:33 - we are not quite done yet with the
283:35 - watering logic because we need the rain
283:38 - this is going to consist of two
283:40 - different parts
283:41 - number one we need the actual rain
283:43 - animation so that the player can tell if
283:45 - it's raining or not
283:47 - besides that if it is raining i want to
283:49 - automatically water all of the soil
283:51 - sprites
283:53 - so that is what we're going to work on
283:55 - let's jump right in
283:57 - back in the code i want to create a new
283:59 - file that i want to save as sky dot
284:02 - python
284:03 - in here i want to import pi game and i
284:07 - also want from settings import
284:10 - everything
284:11 - and i want to create a class called rain
284:15 - there is no need for inheritance but i
284:18 - do want a dunder init method
284:21 - although in here all we want is all
284:24 - sprites
284:25 - once again so that we can draw in here
284:28 - without having to leave the class itself
284:31 - this we have to save inside of an
284:33 - attribute so self.all sprites is going
284:36 - to be all sprites
284:39 - once we have that i want to have a few
284:42 - more graphic files we need self dot rain
284:46 - underscore drops and i want self dot
284:50 - rain underscore floor
284:54 - both are going to use the import folder
284:58 - function except with a different path
285:02 - as a consequence i have to import
285:06 - from support import let's say import
285:10 - folder for this one
285:13 - just to have a look at them inside of
285:15 - the project i have graphics and in there
285:18 - i have rain in here we have drops and
285:21 - floor
285:22 - drops are very simple raindrops
285:24 - basically just straight lines
285:27 - for the floor
285:28 - we have a whole animation or it's not
285:31 - really an animation we can just play
285:32 - them separately but this is what we are
285:34 - going to import
285:36 - let me just copy the file path it is
285:38 - going to be this one
285:40 - and it is going to be this one
285:44 - there's one more thing that we do need
285:46 - and that is we need to know the size of
285:49 - the entire map basically what is going
285:51 - to happen
285:53 - if this here is the entire map
285:56 - i want to randomly create
285:59 - little rain animations all throughout it
286:05 - and for that to work i need to know how
286:07 - wide the entire map is and how tall the
286:10 - entire map is
286:12 - that is information i can get from the
286:15 - ground image which we have to load with
286:17 - pygame.image.load
286:20 - and for this one
286:22 - let me copy the file path as well it is
286:24 - this one and this is literally just the
286:26 - ground nothing else all i want to know
286:29 - is get size
286:31 - and this i want to store in self
286:34 - dot
286:35 - let's do it via two variables we have
286:37 - floor w
286:39 - and self dot floor
286:42 - h
286:44 - once we have that we are going to need
286:46 - two separate methods one for create the
286:50 - floor
286:51 - and besides that
286:53 - we
286:54 - need
286:55 - create
286:56 - drops
286:58 - and after that i want to have an update
287:00 - method that is creating both of those so
287:04 - self.create floor and
287:07 - self.create drops in here now we have to
287:11 - figure out what to do in my case all i'm
287:14 - really going to do is create a drop
287:17 - class which doesn't exist yet so we have
287:20 - to create it
287:22 - and this i want to create inside of this
287:24 - file as well plus drop
287:28 - now this is going to be
287:29 - applygame.sprite.sprite
287:32 - although i do want this to inherit from
287:35 - generic to save me a bit of writing as a
287:38 - consequence i need from
287:40 - sprites
287:41 - import generic
287:44 - i am getting much worse at spelling
287:47 - essentially what i want to do is to
287:48 - import this generic class here
287:52 - we are using this all throughout and you
287:54 - could even put the drop in here it would
287:56 - be perfectly fine but i think in here it
287:59 - does make a bit more sense
288:00 - all i want is to create another indent
288:03 - method in here we need self we need a
288:05 - surface we need a position
288:07 - we need to know if this one is moving or
288:09 - not
288:10 - then we need the groups and then we need
288:12 - a z position
288:14 - and how the drop is going to work it is
288:17 - going to be kind of similar compared to
288:20 - if i minimize all of this
288:23 - it is going to be kind of comparable to
288:25 - the particle
288:26 - we're going to create the object for a
288:28 - short period of time and then destroy it
288:31 - which means we are going to have a timer
288:33 - for each object and then destroy it
288:34 - after a couple of milliseconds
288:37 - now for that i want to have a random
288:39 - live
288:41 - time
288:42 - which i'm getting with randint which we
288:45 - don't have in here yet meaning from
288:48 - random import rand int
288:51 - the duration here i want to go with 400
288:55 - to 500.
288:57 - besides that for the timer i want to
289:00 - have self.start time and this we get
289:03 - with
289:04 - pygame.time.get underscore ticks also
289:08 - let me comment here that this should be
289:12 - the general setup
289:14 - because in here i guess this should be
289:17 - at the top i also want to have a super
289:19 - dunder init method the arguments we need
289:23 - for this one are the same that we have
289:24 - for generic
289:26 - we need these four
289:28 - all four of them are going to come from
289:31 - the attributes that we are passing in
289:34 - when we are creating the drop so there
289:36 - isn't anything we have to do right now
289:38 - although what we do have to do is to
289:40 - work on the moving part
289:43 - basically how that is going to work if
289:45 - we have a raindrop so the things that
289:47 - are going down those are supposed to be
289:50 - moving
289:50 - whereas the raindrops on the bottom so
289:53 - the round things those are going to be
289:56 - staying in place
289:57 - which means i want to have another
289:59 - attribute that i called moving
290:01 - and this is going to capture the moving
290:03 - parameter
290:04 - if self.moving is true
290:08 - then we need a position and this is
290:11 - going to be pygame.math.vector2
290:15 - and
290:16 - self.direct.top left
290:18 - besides that we also need a direction
290:22 - and the direction here is going to be
290:23 - pygame.math.vector2
290:27 - and for the value here i went with
290:29 - negative 2 and 4. those directions mean
290:33 - we are going 2 units in the negative
290:36 - direction and we're going 4 units down
290:39 - as a consequence our actual movement is
290:41 - something like this
290:43 - finally we need self self.speed
290:47 - which is going to be a random value as
290:49 - well between 200 and 250.
290:53 - now these three attributes is the same
290:55 - thing you have seen a couple of hours
290:57 - earlier inside of the player
291:00 - so if i show the init method somewhere
291:03 - here we have direction position and
291:05 - speed
291:06 - these are the attributes you basically
291:08 - always need to move anything inside of
291:10 - pygame
291:11 - finally i want to have an update method
291:15 - in here don't forget we do need delta
291:17 - time
291:19 - and i want to check if self.moving
291:22 - if that is the case self.pos should be
291:25 - plus equal
291:26 - self.direction
291:28 - multiplied by self.speed
291:31 - multiplied by deltatime
291:34 - and once we have that
291:36 - self.rect.top left
291:39 - should be
291:40 - rounded self.post.x
291:44 - and
291:45 - rounded self.y
291:48 - we are basically assigning the top left
291:50 - of the rectangle to position.x and we're
291:54 - using round to avoid the truncating that
291:56 - pygin does by default
291:59 - this is going to be the movement and
292:02 - besides that we are going to need a
292:06 - timer
292:07 - that i want to destroy this timer if it
292:10 - has lived longer than the lifetime
292:13 - and this is going to be your exercise
292:15 - create the timer that you are destroying
292:17 - this sprite after the lifetime has run
292:19 - out pause the video now and try to
292:21 - figure this one out
292:25 - all we need here is pygame.time.get
292:29 - underscore ticks
292:31 - this is getting our current time
292:33 - from that i want to subtract
292:35 - self.starttime
292:38 - if that difference is greater or equal
292:40 - than self dot lifetime
292:43 - we know the lifetime has been exceeded
292:46 - as a consequence we want to kill this
292:48 - sprite
292:50 - and that is all we need for the drop
292:53 - now we just have to create it inside of
292:56 - here and inside of here
293:00 - so
293:01 - let me copy all of the parameters we
293:03 - need
293:04 - and paste them in here
293:06 - and in here or create floor the surface
293:10 - is going to be self dot
293:13 - rain
293:13 - drops and from this we want to randomly
293:16 - select one of them for that we need
293:18 - choice which we don't have yet but we
293:21 - can import it very easily
293:24 - for the position i need to have an x and
293:26 - a y position for x this should be a
293:29 - number between 0
293:31 - and the width of the map
293:35 - that is what we created up here
293:38 - which means
293:39 - i need
293:40 - rand int
293:42 - that goes from 0 all the way to
293:44 - self.floor
293:46 - width
293:48 - and this i also want to do for the y
293:50 - position
293:51 - and this should go from zero to the
293:53 - floor height
293:54 - next up we have moving for the floor
293:57 - tiles this is going to be false
293:59 - then we have the groups and the groups
294:02 - are going to be quite simple because in
294:05 - here all we have is self dot
294:07 - all sprites
294:09 - finally we need the set position and for
294:12 - this one if you look at settings
294:15 - we have rain floor
294:18 - this i want to copy
294:20 - and paste it inside of layers and there
294:23 - we go
294:24 - this is all we need for the floor and
294:27 - now i can basically copy all of this and
294:30 - do the same thing for the raindrops
294:32 - it's going to be fairly similar
294:34 - for the surface we want to have rain
294:38 - this should actually be raindrops and
294:39 - here this should be rain floor sorry
294:42 - about that
294:43 - the position can remain the same
294:46 - moving should be true
294:48 - ropes can remain the same although for
294:50 - the set position
294:52 - we have raindrops that's the layer all
294:54 - the way on top
294:56 - this i want to paste in here
295:00 - and there we go this is covering the
295:02 - entire rain class
295:04 - so let me minimize the raindrop
295:07 - and basically everything in here as well
295:10 - all we have to figure out now is when to
295:13 - call this rain method here
295:16 - and that is going to happen inside of
295:18 - the level
295:19 - first of all i want from sky
295:22 - import rain
295:25 - this i have to turn into an actual
295:28 - object
295:30 - let me add another comment here actually
295:32 - to organize this a bit better let's call
295:34 - it the sky because there's going to be a
295:36 - bit more
295:38 - in here we have self.rain and this is
295:41 - going to be the rain which needs self
295:44 - dot all sprites
295:46 - besides that i want to have another
295:49 - attribute here that i called
295:50 - self.raining
295:53 - and this by default let's say for now it
295:56 - is going to be true so it's easier to
295:58 - test but later on this is going to be
296:00 - random
296:01 - and now
296:03 - inside of the run method
296:05 - before we are doing the overlay let me
296:08 - add a few comments here actually
296:10 - transition
296:12 - overlay
296:14 - i want to have my rain
296:16 - all i have to do for that is check if
296:19 - self.raining is true
296:21 - and if that is the case i want to have
296:23 - self.rain.update
296:26 - that way we are calling this update
296:29 - method here which is going to generate
296:31 - raindrops and those drops we are going
296:34 - to see hopefully in the game
296:37 - so let's try
296:39 - and there we go we have the rain
296:43 - and honestly this is actually a fairly
296:46 - simple effect
296:47 - all we are doing is we are creating
296:49 - random sprites that are either moving
296:51 - for the rain or that are staying static
296:53 - on the bottom
296:55 - and well this is the entire rain graphic
296:58 - if we go over this it really isn't that
297:00 - complicated or at least i hope it isn't
297:03 - with that i can close the sky.pi file
297:06 - although we are going to see it later
297:08 - but for now we don't need it
297:10 - what we need now which is much more
297:12 - important
297:13 - we have to update all of the soil tiles
297:16 - if it is raining
297:18 - and for that inside of soil.pie let me
297:21 - minimize everything once again because
297:24 - this is getting quite extensive
297:26 - i want to create another method that i
297:29 - want to call right below water water
297:32 - underscore all
297:34 - no need for any arguments in here
297:36 - and once again i want to go through all
297:40 - of my grid cells
297:42 - for that let me copy the nested for loop
297:45 - again one more time
297:47 - and paste it in here
297:49 - i want to check if there's a capital x
297:52 - in the cell and
297:55 - w
297:56 - is not in the cell
297:59 - already
298:00 - which basically means we're going
298:02 - through all of the cells and we are
298:05 - checking if there's an x meaning there's
298:07 - a soil tile but this soil tile hasn't
298:10 - been watered yet
298:12 - but we do want to make sure that does
298:14 - get watered which means first of all i
298:17 - want to append
298:18 - a w to the cell
298:21 - and after that i want to create all of
298:23 - the water tiles again
298:26 - and in here let me copy it from the
298:29 - water
298:30 - we basically want to copy this entire
298:33 - thing
298:34 - although we do have to make some changes
298:36 - because for this one we have a position
298:39 - inside of a cell and this we have to
298:41 - convert to an actual pixel position the
298:44 - main thing you have to understand about
298:45 - the soil layer is we are working with
298:47 - two different systems
298:49 - one is we have all of the positions
298:51 - inside of the grid and that is basically
298:54 - a table besides that we have all of the
298:56 - pixel positions in the actual game
298:59 - switching between them is really simple
299:02 - in this case we need an x and a y
299:04 - position and those we get
299:07 - for x it's going to be the index column
299:11 - multiplied by the tile size
299:14 - and for y it's going to be the index row
299:17 - multiplied by the tile size
299:20 - this x and y we now want to paste into
299:23 - the position for x and y
299:25 - and we are good to go
299:27 - the surface is going to be the same
299:29 - surface we had up here i just want to
299:31 - pick a random water tile i can just
299:33 - paste it straight in here
299:35 - and the groups can remain identical
299:37 - those work just fine
299:39 - with that we have a function that can
299:41 - water all of our soil tiles
299:44 - we now have to figure out when to call
299:46 - it
299:47 - and this has to happen in two separate
299:50 - places
299:51 - number one is when we get hit or rather
299:54 - when the soil gets hit
299:56 - we are attaching an x inside of the cell
299:59 - here
300:01 - if that is the case i want to pass in if
300:04 - self.raining
300:06 - which is not something we have yet but
300:08 - we are going to in just a second
300:11 - if that is the case i want to call
300:12 - self.water
300:14 - all
300:15 - the problem we have right now is that
300:17 - the soil layer doesn't know if it is
300:19 - raining or not this we only know inside
300:22 - of the level
300:24 - although that is a problem that is very
300:26 - easily fixed all we have to do inside of
300:28 - the init method after we have set the
300:30 - rain i want to get myself dot soil layer
300:35 - and set raining
300:37 - ooh self dot raining
300:41 - also when we are resetting the day i
300:44 - have to do the same thing
300:45 - which means in here in a bit i want to
300:47 - randomize the rain every time we are
300:50 - resetting the day
300:51 - once we have updated that i want to get
300:53 - myself dot soil layer again and set
300:57 - raining back to self dot
301:00 - raining and now we always know if it is
301:04 - raining inside of this class here
301:08 - which means if i run main.pi and i use
301:11 - the whole we automatically get water
301:13 - sprites this is looking really good
301:17 - and if i switch off the rain
301:21 - all the way at the top
301:23 - here
301:24 - so raining should be false
301:26 - let's try this now we don't have rain
301:29 - and we don't have water at least not by
301:30 - default
301:33 - so all right with that we have some
301:36 - basic rain logic
301:37 - although what i also want
301:40 - when we are resetting the day
301:42 - and it is raining i want to
301:45 - automatically water all of the existing
301:47 - soil tiles because right now in the
301:49 - logic here we are only watering new
301:52 - tiles we don't water existing tiles
301:55 - which means when i'm resetting the day
301:57 - i want
301:59 - if
302:00 - self.raining is true
302:02 - then
302:03 - self dot soil layer dot water underscore
302:07 - all
302:08 - let's try this one
302:10 - oh and i do have to switch on the rain
302:13 - and to test this one let's randomize the
302:16 - rain
302:17 - meaning when i'm creating the rain
302:19 - i want to have a random chance to create
302:22 - a rain which i'm getting with rent int
302:24 - which i don't think i have available yet
302:27 - i do not
302:29 - i need from random import rand int
302:34 - and in here i'm just creating a number
302:36 - between 0 and 10
302:39 - and if this number is let's say
302:41 - greater than 7 this is going to be true
302:44 - although for now for testing purposes
302:47 - i'm going to set this number to a free
302:49 - which means we're going to have a ton of
302:52 - rain
302:54 - this i also want to do down here
302:56 - actually i can copy the entire line
302:59 - like
303:01 - so
303:02 - and now for every day we have a pretty
303:05 - high chance to generate rain
303:07 - if i run this
303:09 - it's raining right now but we can still
303:11 - get started and let's go to bed
303:16 - and let's hope there we go now there's
303:18 - no rain so there's no water on them and
303:21 - i guess let me water one of them just
303:23 - for testing purposes
303:25 - if i now go to sleep again
303:26 - [Music]
303:27 - it's not raining
303:29 - now it's raining again
303:31 - and all of the soil tiles have been
303:33 - watered so this is working really well
303:37 - very nice
303:39 - and with that we have the basic watering
303:44 - logic so another major step forward next
303:47 - up we can start working on the plans
303:50 - let's get started with the plans since
303:52 - we already have a ton of logic in the
303:55 - soil this shouldn't be so bad actually
303:58 - but once again let's go for this step by
304:00 - step
304:01 - the very first thing we need is inside
304:04 - of the player we need to know if the
304:06 - player is planting some seeds
304:09 - for that we already have a method that
304:12 - is called use seed right now there's
304:15 - nothing in there but
304:17 - that is going to change
304:19 - i want to get this soil layer once again
304:22 - and now call a method that i called
304:25 - plant seed for this one we need two
304:28 - arguments the first one is going to be
304:30 - self dot the target position the second
304:33 - one is self dot selected not tool but
304:37 - seat
304:38 - and i hope this makes sense we have to
304:40 - know what target we are hitting and we
304:42 - want to know what kind of seat we are
304:44 - using this is all we need inside of the
304:46 - player and now in the soil
304:49 - in the soil layer
304:51 - i want to minimize all of the methods
304:55 - and
304:56 - let me put it
304:58 - let me put it all the way below the
305:00 - water in here
305:02 - i want to have planned underscore seat
305:07 - we need self we need a
305:09 - target position
305:11 - and we need a
305:13 - and once again we have to check if we
305:16 - actually hit a soil sprite which we get
305:18 - before
305:19 - soil sprite
305:22 - in
305:22 - self.soil sprites dot sprites
305:26 - i want to check if
305:28 - soilsprite.rect.collide.point
305:32 - and the point i want to check is the
305:34 - target position
305:36 - if that is the case once again i have a
305:39 - pixel position and this i want to
305:41 - convert to a position inside of the grid
305:45 - which means i need my soil sprite or
305:49 - direct.x
305:51 - and floor divided by the tile size
305:54 - i can duplicate this line and change the
305:57 - x to a y and that way i'm getting my y
305:59 - position inside of the grid
306:02 - if that is the case i want to get myself
306:04 - dot grid with my y and x
306:09 - this is going to give me the cell and i
306:11 - want to append a capital p
306:14 - short for a plant
306:16 - that way we know we have a plant inside
306:18 - of this cell
306:19 - now this should only be possible once
306:22 - which means i can already
306:24 - check if a capital p
306:26 - is
306:27 - not
306:29 - in
306:30 - self dot grid
306:32 - with
306:33 - y
306:34 - and x
306:36 - and only if that is the case i want to
306:38 - create a plant now that we have that i
306:41 - want to create a plant object
306:44 - this i am creating also inside of this
306:47 - python file with class
306:49 - land
306:50 - and this one is also going to be
306:52 - pygame.sprite.sprite
306:55 - i want to have a dunder init method with
306:58 - self we need a plant
307:01 - pipe so do we want corn or tomato
307:04 - then we want groups next up i need the
307:06 - soil for the positioning and let's say
307:08 - that's it for now
307:10 - as always i need the dander init method
307:13 - with the
307:15 - roots
307:16 - i have to convert the plant type
307:20 - parameter into an attribute so
307:21 - self.plant type is plant type
307:24 - and then i have a couple of frames
307:27 - depending on what kind of plant we have
307:30 - meaning here's the project i have
307:32 - graphics inside of there we have fruit
307:36 - and there's corn and tomato not the best
307:39 - naming but it really doesn't matter
307:41 - inside of corn we have these different
307:43 - files and inside of tomato we have those
307:47 - this is what we are going to import
307:49 - this we get with import folder and the
307:52 - file path here is let me just copy it
307:54 - right away
307:56 - we have to go into graphics and fruit
307:59 - and in there we have two subfolders and
308:01 - those subfolders i want to get with an f
308:05 - string
308:07 - because what we can use in here is the
308:08 - planned type
308:10 - besides that we need self dot h
308:14 - by default this is going to be zero
308:17 - after that we also need self.max h so
308:21 - that we know when the plant is reaching
308:23 - the full h
308:24 - this we can get with self.
308:27 - frames and get the length of it and
308:29 - subtract 1 from that
308:32 - finally i want to have
308:34 - self.grow underscore speed
308:37 - which is telling me how fast this kind
308:39 - of plant is growing and for that inside
308:42 - of settings i have a dictionary this is
308:46 - what i want to use
308:47 - meaning i can use grow speed in here
308:52 - and then get the plant type
308:55 - i guess i should really comment all of
308:57 - this a bit better to make it a bit
308:59 - easier to understand
309:00 - let's call this section here the plant
309:03 - growing
309:05 - and this stuff at the top is going to be
309:08 - the setup
309:10 - also there's one thing i forgot we have
309:12 - to turn
309:13 - the soil into an attribute so self.soil
309:16 - is going to be soil once we have all of
309:19 - that we can work on the sprite set up
309:24 - first of all here we need self.image
309:27 - this is very easy because we have a
309:29 - bunch of frames i want to use self.h for
309:32 - the indexing
309:34 - besides that i have to create self.rect
309:38 - this i'm getting with
309:39 - self.image.getunderscorerect
309:43 - i want to place the mid
309:45 - bottom
309:47 - and the position i'm getting from
309:48 - soil.rect.mit
309:53 - although here we have a problem
309:55 - this is going to be the size of a soil
309:58 - tile but each plant is going to be about
310:02 - this tall and since we're placing the
310:04 - bottom of the plant at the bottom
310:07 - of this soil tile we're going to be
310:09 - somewhere here
310:11 - and i want there to be some kind of
310:13 - offset
310:15 - this i created separately and i called
310:18 - it self dot y underscore offset
310:22 - this is going to be negative 16 if the
310:25 - plant
310:26 - type
310:28 - is equal to corn and if that is not the
310:31 - case it's supposed to be negative 8. the
310:34 - reason here is that the various plans
310:36 - are very different in size we do have to
310:38 - account for that
310:40 - and to use that i have to turn it into a
310:43 - vector which means pygame.math.vector2
310:47 - this needs to be capitalized
310:50 - for x it's supposed to be zero and for y
310:53 - it is going to be self dot y offset
310:57 - we are nearly done the last thing we
310:59 - need is self dot z
311:02 - in here we need layers as always and for
311:05 - the plants we actually have two
311:06 - different layers
311:09 - the one we are going to start with is
311:11 - the
311:12 - round plant
311:14 - this i want to paste in here and this
311:16 - means if you look at the settings the
311:18 - plans are always going to be below the
311:20 - player
311:21 - by default i want the plans to be
311:24 - non-collidable so the player can just
311:26 - walk on top of them but once they have
311:28 - grown i want them to be on the main
311:30 - layer and the player should be able to
311:32 - collide with them but that's going to
311:34 - come in a bit i guess for now we have
311:36 - added a ton of stuff so let's actually
311:39 - create one of the plans and see how far
311:43 - we get
311:44 - so when i create a plant i need a plant
311:46 - type the groups and the soil
311:48 - this one should be fairly simple because
311:51 - the plant type is going to be the same
311:53 - as the seed
311:54 - the soil is also going to be very simple
311:57 - because all we need in here is the soil
311:59 - sprite
312:00 - for the groups i do want to have one
312:03 - group specifically for the plants
312:07 - this is going to happen in the init
312:09 - method of the soil layer in here i want
312:11 - to have self.plan
312:14 - underscore sprites
312:16 - once again this is just going to be
312:17 - pygame.sprite.group
312:20 - and now for the groups
312:22 - each plant should be
312:25 - inside of self dot all sprites
312:29 - it should be inside self dot blend
312:33 - not types but sprites
312:35 - and let me fix this typo here
312:38 - and let's actually try this
312:40 - so in the game i can use a hole and now
312:43 - if i press left ctrl
312:45 - we get some seeds that we can walk over
312:48 - and this i can do multiple times
312:51 - also with e i can change the seed and
312:53 - now we get a tomato this is working
312:56 - surprisingly well
312:58 - cool so i'm very happy with that what we
313:01 - now have to figure out is how to make
313:02 - the plants grow
313:06 - inside of the
313:09 - we need an update or some kind of an
313:11 - update method
313:14 - this one i called grow
313:17 - there is no need for an argument in here
313:20 - and now we have a problem because the
313:22 - plant needs to know if the soil it is in
313:25 - was watered but this information we
313:27 - don't have available right now what i
313:29 - want to happen is that each plant can
313:32 - access the soil layer and check out
313:35 - self.grid
313:37 - know if the tile it is in was watered or
313:39 - not
313:40 - and for that i am going to create
313:43 - another method
313:46 - that is going to be fairly simple though
313:48 - i called this one
313:50 - check
313:52 - watered
313:54 - in here we need some kind of position
313:58 - this position will be entered by the
314:00 - plant itself
314:02 - i want to get the actual cell and right
314:04 - now once again we have a pixel position
314:08 - this we have to convert into an actual
314:10 - grid position so we can access the grid
314:13 - the same thing we have done here
314:14 - actually
314:15 - let me copy the entire thing actually
314:20 - and fix the indentation
314:24 - there we go
314:26 - to get the cell all i want is self.grid
314:29 - and y and then x
314:32 - once i have that i can check is watered
314:36 - and is watered we are getting with
314:38 - capital w
314:40 - in cell
314:42 - meaning this could ever be true or false
314:45 - and that is the information i want to
314:48 - return so return is watered
314:51 - now this method i am going to pass into
314:54 - a plant whenever we create it
314:56 - which happens down here
314:58 - each plant is going to have access to
315:00 - self.js
315:02 - watered
315:04 - for this we have to create another
315:06 - attribute after soil
315:08 - i want to have check watered
315:13 - this we have to turn into an attribute
315:15 - so
315:16 - self.jackwatered is check watered
315:20 - and now we can create this grow method
315:24 - all i have to do is check if self dot
315:29 - check watered
315:31 - with self dot wrecked dot center
315:34 - remember here check water it needs a
315:36 - position and i'm just going to go with
315:38 - the center remember here check water did
315:41 - need a position
315:44 - if that is the case
315:46 - i want to add self dot
315:48 - h plus equal self.grow
315:52 - speed
315:53 - and after i have that i can run
315:56 - self.image is going to be self.frames
316:00 - and i can use self.h again although now
316:03 - we do have to be careful because this
316:06 - age
316:06 - could be a floating point value which we
316:09 - couldn't use for indexing but if we turn
316:12 - it into an integer this is going to work
316:14 - again and after that i can turn this
316:16 - into a rectangle
316:18 - which i am getting with self.image
316:22 - actually let me copy
316:24 - this one here
316:26 - because it isn't going to change besides
316:28 - that now the main reason why i am
316:31 - updating the rectangle is because the
316:33 - image is going to change and we might
316:35 - have different dimensions
316:37 - which means we have to get a new
316:39 - rectangle
316:40 - but other than that this is the basics
316:43 - of the grow method
316:45 - what we now have to figure out is when
316:47 - to call it
316:48 - for that inside of the soil layer i
316:51 - created another method update
316:55 - plans
316:57 - all i need in here is for planned in
316:59 - self.plannedsprites.sprites
317:03 - i want plant.grow
317:06 - and this method i now want to call
317:08 - inside of the level
317:11 - when we are resetting the day so in here
317:15 - let's do it all the way at the top
317:17 - we have the plans
317:20 - self. soil layer dot
317:24 - update underscore plants
317:28 - and that should basically be it i guess
317:32 - the one thing you want to be careful
317:33 - about here is that this should be called
317:36 - before all of this
317:38 - because for example if we called it
317:39 - after is raining with this method here
317:42 - we might water all of them and then
317:44 - update all of the plants which would be
317:45 - a tiny bit weird
317:47 - let's try
317:49 - so i want to grow some corn
317:53 - make sure i am watering it and now let's
317:56 - update the entire day
317:59 - and we are getting an error that name
318:01 - soil sprite is not defined
318:05 - this probably happened inside of here
318:09 - ah right
318:10 - jack watered has the problem right now
318:12 - that this should be
318:15 - position
318:16 - zero and
318:19 - position
318:21 - one
318:22 - because what we actually pass in here
318:25 - inside of the plant is self.record
318:28 - center which is giving us a tuple with
318:30 - an x and a y position
318:32 - now let's try this again next attempt
318:35 - i want to plan some coin again
318:37 - and start a new day
318:40 - and we are getting another error
318:47 - this one happens down here inside of
318:49 - plant.grow so let's have a look at this
318:52 - one
318:53 - and the problem is happening somewhere
318:55 - in here
318:57 - the problem is we don't have the soil as
318:59 - an attribute this we can fix with self
319:02 - dot soil
319:04 - ready next attempt
319:06 - let's try it again
319:09 - let's see if i made another mistake
319:12 - now it's working and there we go this
319:14 - definitely grew
319:16 - let me water it by hand
319:21 - and start another day and there we go
319:24 - this keeps on growing
319:26 - and now if i start another day it should
319:29 - be fully grown there we go now if i
319:31 - start another day this is going to crash
319:34 - because we are running out of frames but
319:36 - this was expected
319:38 - other than that this is working just
319:40 - fine we do have a very good start now we
319:44 - just have to make some more updates to
319:46 - the plant and then we are nearly done
319:48 - with the plants and with most of the
319:50 - game actually
319:51 - first of all once the plant is reaching
319:54 - the max age i want the plan to stop
319:57 - growing which happens inside of grow all
320:00 - i want to do in here is if self.h
320:04 - is greater or equal than self dot
320:08 - max h and if that is the case self.h is
320:13 - going to be self.max
320:15 - h
320:16 - although if that is the case i want to
320:19 - indicate that the plant is ready for
320:21 - harvesting
320:23 - which i am doing via another attribute
320:27 - that i called harvester bill
320:30 - and harvestable is going to be true once
320:33 - this condition here is true so we can
320:35 - set this to true
320:38 - with that the game is not going to crash
320:41 - anymore although what i also want to do
320:43 - is if the plan starts to grow it should
320:45 - be on the main layer and the player
320:47 - should be able to collide with it
320:50 - this could be a good exercise
320:53 - if the plant
320:55 - h is greater
320:58 - than zero so if we have one and above
321:01 - then the plant should be on the main
321:02 - layer
321:04 - and pause the video now and see if we
321:05 - can figure this one out
321:10 - for this one we need an if statement and
321:13 - i want to check if self.h is greater
321:16 - than zero
321:17 - if that is the case i want to update
321:20 - self dot z
321:21 - which now should be inside of
321:25 - layers
321:26 - and the main layer
321:29 - although there is one thing you really
321:31 - want to be careful about because self.h
321:34 - could be a floating point value and we
321:37 - only want to do this line here
321:40 - if the plant is greater than one
321:43 - which we can get quite easily
321:46 - with integer if you didn't do this
321:49 - self.h might be something like
321:52 - 0.7 which would be greater than 0 but
321:55 - the plant itself would still be a tiny
321:57 - seed
321:58 - which the player should walk on top
322:01 - so integer ensures
322:03 - that we have a certain kind of plan size
322:07 - if i run the game now let's hope it
322:09 - doesn't crash
322:10 - i can
322:12 - land something
322:14 - and if i now update the entire thing it
322:17 - doesn't crash and now we should be
322:20 - behind and in front of all of this stuff
322:23 - so this is working just fine
322:27 - what we now have to figure out is the
322:29 - collision mechanic
322:30 - and for that if i look at the player
322:33 - again at collision
322:36 - in here the plans don't have collisions
322:39 - yet because they don't have a hitbox
322:41 - which we are checking here
322:44 - but that we can fix quite easily
322:46 - once a plant has a certain age it should
322:50 - have self.hit
322:52 - box
322:54 - and this is just going to be
322:55 - self.direct.com
322:58 - p
322:59 - and this i want to inflate
323:02 - and now i need an x and a y dimension
323:05 - again
323:06 - for x is going to be negative 26
323:09 - and for y it is going to be self
323:10 - self.rect.height
323:14 - multiplied by 0.4 and this should be
323:19 - negative that is all we needed if i now
323:22 - run main.pi
323:24 - and let's create a tomato for now
323:26 - if i plant this one although i think
323:28 - this takes two days to grow but that's a
323:30 - good way to double check
323:32 - so now i can still walk over the tomato
323:34 - plant
323:35 - but if i sleep again
323:39 - now we have a grown plant and there is
323:43 - no collision yet
323:45 - and i also know why
323:47 - the reason is
323:48 - the plants are not inside of the
323:51 - collision sprites method
323:55 - so when i am creating a plant
323:58 - it needs to be inside of self.collision
324:03 - sprites
324:06 - the problem is
324:07 - the soil layer doesn't have that one
324:10 - although that we can change
324:12 - i want another attribute with the
324:14 - collision sprites
324:16 - and let me put this right below all
324:18 - sprites
324:19 - self.collision sprites is going to be
324:22 - collision
324:23 - sprites
324:25 - now inside of level when i create the
324:29 - soil layer which happens here
324:32 - i also want to pass in
324:34 - self.collision sprites
324:36 - now let's try this again
324:39 - i want to plan some corn because that
324:41 - one is faster and now if i restart the
324:44 - day
324:46 - we have something and now we have
324:49 - collisions
324:52 - this is looking really good
324:58 - cool so with that we have the basics of
325:02 - the plant
325:04 - although we cannot harvest them but that
325:07 - is going to be the next section
325:11 - with the plants being done the last
325:13 - thing we have to do is the harvesting
325:15 - part or at least the last thing we have
325:16 - to do for the plans there is going to be
325:18 - quite a bit more
325:20 - let's jump right in and once again let's
325:23 - go through it step by step
325:25 - back in the code what i basically now
325:28 - have to figure out is
325:30 - if a plant is harvestable so this line
325:34 - here is true
325:35 - and i have a collision with the player
325:38 - so this player here
325:40 - then i want to destroy the plant and
325:42 - update the player inventory
325:45 - all of this is going to happen inside of
325:47 - level.pi
325:49 - i want to create let's call it planned
325:53 - collisions
325:56 - or collision
325:58 - there's no need for any parameters in
326:00 - here first of all i want to check if
326:03 - there are any plans in the first place
326:05 - which i get with self dot soil layer dot
326:09 - plant
326:10 - underscore sprites
326:13 - if there are no plans this is not going
326:15 - to trigger
326:16 - and then there's no point doing any of
326:18 - all of this
326:19 - if there are no plans this would not
326:21 - trigger in here i want to check for
326:24 - plant in
326:26 - self.soil layer dot plant sprites dot
326:30 - sprites
326:31 - that way i can access every individual
326:33 - plant and what i want to check is if
326:36 - plant dot harvest bill
326:40 - and
326:41 - the plant.rect.colliderect
326:46 - with self.player.hitbox
326:50 - we are checking if the plan can be
326:52 - harvested and if the plant is colliding
326:55 - with the player
326:56 - if that is the case i want to destroy
327:00 - this plant
327:01 - make sure to call this plant collision
327:04 - right after update which happens here
327:08 - i want to run self.planned
327:10 - collision
327:13 - and now let's try all of this
327:16 - we're getting an error
327:18 - that
327:19 - inside of level
327:22 - this should be planned sprites
327:24 - so should this one here
327:27 - now let's try this again
327:29 - there we go i can plant some corn and
327:33 - water this
327:34 - and now i have to do a
327:37 - bit of
327:39 - restarting the day
327:42 - but the game is definitely coming
327:44 - together
327:45 - now it's raining so i can go straight
327:47 - back to sleep
327:49 - and now if i collide with this it
327:52 - disappears cool this is a very good
327:55 - start
327:57 - although we do have to a few more things
327:59 - in here
328:00 - first of all i want to run self dot
328:04 - player underscore add
328:08 - and in here i want to get the planned
328:12 - and then dot planned underscore type
328:16 - that way we are updating the player
328:18 - inventory so there's an actual reason to
328:20 - harvest something
328:22 - and this we should probably test so once
328:25 - again all the way at the end of the run
328:27 - method i want to print self dot player
328:32 - dot item inventory
328:35 - if i run this now
328:37 - we get the entire inventory and i want
328:40 - to plant some corn
328:43 - now i have to restart it's still raining
328:46 - it's also raining and we need one more
328:48 - day
328:51 - and now if i collide with this we get
328:54 - corn one this is working very well
328:58 - so let me delete this print statement
329:01 - here again and now we can keep on
329:03 - working in here
329:05 - i also want to create a particle when
329:07 - the plant disappears which we don't have
329:10 - available yet
329:13 - we do not
329:14 - but i can import it quite easily
329:17 - i want a particle which we're getting
329:20 - from the sprites this one here
329:26 - and now i need all of the arguments to
329:29 - create it
329:30 - so let me copy
329:32 - these ones here
329:34 - paste them in here
329:35 - and now we have to figure out all of
329:37 - them again
329:38 - for the position i want to have
329:41 - land.rect.top
329:43 - left
329:44 - for the surface i want to have planned
329:46 - dot image and for the groups this should
329:49 - be self dot all sprites
329:52 - for the z layer i want to have the
329:55 - layers
329:56 - and in here this should be main
329:59 - this should be all we need once again
330:01 - let's try this
330:06 - and i do hope it starts to rain this is
330:10 - looking good
330:11 - raining again one more time
330:14 - and now we should have a particle effect
330:16 - and there we go this is looking good
330:18 - the last thing we need is whenever we
330:21 - destroy the plant we still have inside
330:24 - of the grid
330:27 - let me minimize the plans
330:29 - the last thing we need inside of this
330:32 - soil grid
330:33 - we have to remove the capital p that way
330:36 - we can create another plant
330:38 - for this one i need
330:40 - self.sawyer layer once again
330:43 - and now we need the grid
330:46 - the problem is right now we only have an
330:49 - x in the y position and for the grid we
330:52 - need rows and columns
330:54 - which means we need a row and we need a
330:58 - volume
331:00 - and once we have that i want to remove
331:02 - any kind of capital p
331:05 - and this column is going to be your
331:07 - exercise
331:09 - see if you can figure this one out
331:14 - for the row we are going to need the y
331:16 - position of the plant which we get with
331:20 - plant.rect.com
331:22 - y
331:23 - and this i want to flow divide by the
331:26 - tile size
331:28 - for
331:29 - the column this is going to work in the
331:31 - same way except now we need center x
331:34 - and with that we should be good to go
331:38 - so now if i run main.pi again
331:41 - now if i plant some corn
331:44 - and restart the day
331:47 - it's raining again we do have to wait
331:49 - until the thing grows completely
331:53 - now it should be working and
331:55 - now we are getting an error because i
331:57 - made a typo
332:00 - this should be tile size
332:03 - okay once again
332:06 - let's try this again
332:09 - and
332:10 - testing a game can be very annoying it's
332:13 - not raining but i guess all of this is
332:15 - good way to test all of this
332:19 - let's try it one more time now it is
332:21 - raining it keeps on growing and
332:24 - now it is completely grown
332:26 - if i touch it it disappears and now i
332:28 - should be able to create a new plant so
332:31 - let me plant a tomato
332:33 - and there we go we have a tomato
332:36 - i guess
332:37 - if i restart the date just to be sure
332:40 - all of this is working
332:42 - one more time
332:43 - and it is growing cool so this is
332:46 - working as well
332:48 - with that we have the harvesting logic
332:51 - this honestly wasn't so bad
332:54 - or at least i hope it wasn't
332:56 - there isn't actually that much more to
332:58 - do but there's one thing i did forget to
333:01 - do and that is the night transition or
333:04 - the daytime transition let's do this one
333:07 - next
333:08 - for the day transition we kind of have
333:11 - to do the same thing we have done for
333:12 - the transition between different days we
333:15 - are basically creating an image on top
333:18 - of the entire game and then we use
333:20 - blending modes to merge the two
333:22 - i probably should have done this a
333:24 - couple of hours ago when we worked on
333:26 - the transition but well here we are
333:29 - back in the code i want to do all of
333:31 - this inside of my sky because it kind of
333:34 - fits in there
333:36 - let me reopen it we need the sky in here
333:39 - besides the drop and the rain all the
333:42 - way at the top i want to have let's call
333:44 - it sky
333:47 - we need a dunder init method in here
333:50 - with self and now first of all we need
333:53 - the display surface
333:55 - which as always we get with
333:57 - pygame.display.get
333:59 - underscore surface
334:02 - besides that we are going to need an
334:04 - image that covers the entire window
334:06 - which i called self.full
334:09 - surface just surf is fine
334:12 - and this we get with pygame dot surface
334:16 - and in here
334:18 - i can once again from my settings get
334:20 - the screen width and the screen height
334:22 - let me copy in the screen width and this
334:25 - green height
334:26 - and now we have a full surface
334:29 - once i have that i want to let me call
334:32 - it display
334:33 - in here we need self and we also need
334:36 - delta time and essentially all i want to
334:40 - do here is self dot display surface dot
334:43 - blit
334:44 - i want to have myself dot full surface
334:47 - at the position 0 and 0 that will be
334:49 - covering the entire window and finally
334:53 - we need a special
334:55 - blacks which in this case is going to be
334:57 - pygame dot blend underscore rgba
335:01 - underscore mult
335:03 - right now this is going to be entirely
335:06 - black so there isn't too much point but
335:09 - let's use it right away also i want to
335:11 - close the soil at least for now to keep
335:13 - things a bit more organized
335:15 - i can also close the sprites because i
335:18 - don't think we need it at all anymore
335:20 - inside of the level
335:22 - i want besides rain also import sky
335:26 - and the sky has to be an attribute
335:29 - let's put it right here self.sky is
335:32 - going to be sky once we have that inside
335:36 - of the run method
335:37 - after the rain
335:39 - i want to have the day
335:42 - time
335:43 - like that
335:44 - and this we get with self.sky
335:47 - dot display
335:49 - in here we do need to at a time although
335:51 - not right now but we do need it to call
335:54 - the method
335:55 - if i run this now
335:57 - everything is going to be black
335:59 - the reason is we are putting a black
336:01 - surface on top of the entire window
336:04 - which well isn't particularly helpful
336:08 - although what i want to do now is self
336:10 - dot start
336:12 - color
336:13 - and this start color is going to be a
336:15 - list with the values 255 255 and 255
336:21 - before i am displaying this surface i
336:24 - want to fill it with that color so
336:27 - self.color serve.fill with
336:30 - self.startcolor
336:32 - once we have that we shouldn't be seeing
336:35 - anything we can see the game itself this
336:37 - is looking as always
336:40 - but now what we can do with this setup i
336:42 - could for example change this to a0 and
336:46 - if i now run this again
336:48 - we get a bunch of weird colors
336:51 - and this way we can control how the game
336:54 - is going to look like
336:56 - in my case i want to transition from a
336:58 - pure white color
337:01 - to myself dot and color
337:04 - which is going to be the tuple 38 101
337:09 - and 189
337:11 - just to illustrate what this one is
337:12 - going to look like
337:14 - let me run it in the game it's going to
337:16 - look like this
337:18 - this is very much night time
337:22 - all we have to figure out now is how to
337:24 - transition from this value to this value
337:26 - here how this is going to look like is
337:28 - i'm going to look at every individual
337:30 - value and subtract it by a certain
337:32 - amount let's say negative 2.
337:35 - and this i'm going to do until we're
337:37 - reaching
337:38 - this particular point
337:40 - this point here so you can see it
337:43 - this is also going to happen for the
337:44 - second one this is going to go until
337:47 - this point here and for this one as well
337:49 - up to this point here
337:52 - this i am getting with for value in self
337:56 - dot and color
337:59 - although in here i do need the enumerate
338:02 - method because i need to know what index
338:05 - i am on so i have my index and i have
338:07 - the value
338:08 - i want to check if self dot start not
338:12 - time but
338:13 - color
338:15 - is greater than the value and if that is
338:18 - the case self dot start color
338:21 - with the index
338:23 - should be minus equal 2 multiplied by
338:26 - delta time
338:28 - also when i am filling all of this this
338:30 - should be the start color
338:33 - we are looking at every single color
338:34 - inside of n color against this we are
338:37 - checking on this line here
338:41 - if the corresponding value inside of
338:43 - start color let's say the first one 255
338:46 - is greater than the end color 38 in this
338:49 - case and if that is the case we want to
338:52 - reduce the start color value by a
338:54 - certain amount
338:56 - and this we want to do until we reach
338:58 - the end point and with that we should be
339:00 - having a transition let's try now
339:02 - and we are getting an error
339:05 - this one here should be start color and
339:08 - index
339:10 - and now all i have to do is wait
339:16 - i guess while i'm doing that i can run
339:18 - around a bit to check out the entire
339:20 - level i've been very focused on specific
339:22 - tasks but well the entire game is coming
339:25 - together pretty nice
339:28 - also here you can see the trader and now
339:30 - since we have a collision block here we
339:32 - cannot move over him anymore
339:35 - we're going to work on the trader in
339:36 - just a second
339:41 - and everything else is working really
339:44 - well
339:47 - okay probably i'm just going to speed up
339:49 - this entire game because i am running
339:52 - out of things to talk about so let's
339:54 - speed it up a bit
339:57 - alright i think at this point you can
339:59 - definitely tell things are getting
340:01 - darker
340:05 - this is definitely working
340:07 - all we have to figure out now
340:09 - is once we have
340:11 - all of this color here we have to set it
340:14 - back to the starting position so 255 255
340:18 - and 255
340:19 - whenever we are
340:22 - resetting
340:23 - the entire day
340:25 - this is also going to be fairly simple
340:28 - all we have to do let me add another
340:30 - comment here sky i want to get self.sky
340:34 - dot start color
340:36 - is going to be 255 255 and 255.
340:42 - that
340:43 - if i now wait a tiny bit let me speed
340:46 - all of this up
340:52 - all right now we can definitely tell
340:54 - things are getting darker so let me
340:56 - restart the day
340:59 - and there we go this is much brighter
341:02 - with that we have the daytime cycle
341:06 - really wasn't that bad
341:08 - and this is literally all we need for
341:10 - the sky meaning i can minimize it and
341:13 - close the entire python file
341:15 - and we are almost done
341:18 - the last major bit of the game is going
341:20 - to be the merchant so let's work on that
341:23 - one there are quite a few different
341:25 - elements we have to cover here
341:27 - back in the code first of all the player
341:30 - is going to need let me minimize
341:32 - everything
341:33 - the player is going to need a full
341:35 - inventory we already have a couple of
341:38 - things in here we have this kind of
341:40 - inventory
341:41 - but we are going to need a tiny bit more
341:44 - we also need
341:46 - self.seed underscore inventory and this
341:50 - one is going to have two key value pairs
341:53 - we have
341:54 - corn
341:55 - and by default let's say we have five
341:59 - and besides that we have tomato five in
342:02 - here would also work well
342:04 - finally besides that we are going to
342:07 - need self dot money
342:09 - and for starting value here let's go
342:11 - with 200 it's entirely arbitrary
342:15 - this is going to be the inventory for
342:16 - the player and this is also what we're
342:18 - going to access when we are doing the
342:20 - merchant
342:21 - although before we are coming to that
342:23 - there's one more thing that i want to do
342:25 - and that is that the player shouldn't be
342:27 - able to use a seat once we are running
342:29 - out of seat
342:31 - for example the player can only use corn
342:33 - if this number here is at least one
342:37 - let me minimize the init method and all
342:40 - of this happens inside of use seed
342:43 - all i want to do in here is if self dot
342:47 - seed inventory
342:49 - and then i want to pick myself dot
342:52 - selected seed
342:55 - and only if this is greater than zero
342:58 - then i want to plant a seed
343:01 - besides that inside of here as well i
343:03 - want to get myself dot seed inventory
343:07 - get the selected self dot selected seed
343:10 - again
343:11 - and subtract it by one
343:13 - with that we can start working on the
343:15 - merchant itself
343:17 - let me explain how it's going to work
343:19 - here we are back in tiled and the trader
343:22 - is all the way in the top left
343:24 - what you can see around the trader is
343:27 - inside of player we have a trader area
343:31 - this is going to work kind of like the
343:33 - bad if the player is inside of this area
343:36 - presses enter
343:37 - then we are going to start the merchant
343:39 - menu
343:40 - back in the code when we are creating
343:43 - the level more specifically when we are
343:45 - running the setup method
343:47 - in here a bit further down
343:49 - we are checking for the start position
343:51 - of the player
343:52 - if there is a bad and besides that i
343:55 - want to check
343:56 - if object
343:59 - is equal to
344:01 - trader
344:03 - if that is the case i want to create
344:05 - another interaction object meaning i can
344:07 - duplicate this line here and paste it in
344:10 - here
344:11 - with that we are actually done all of
344:13 - these arguments here can stay identical
344:16 - since we're getting information from
344:17 - tiled all of this is going to be done
344:19 - automatically the only major change here
344:22 - is going to obj name because this one
344:24 - now is going to be trader instead of bad
344:27 - but with that we have the interaction
344:30 - object
344:31 - we have to do a tiny bit more inside of
344:33 - the player
344:34 - inside of the input method all the way
344:37 - at the bottom
344:40 - we have created this line a couple of
344:42 - hours ago and that is if the player is
344:45 - inside of the interaction area and we
344:47 - have trader then we want to do a certain
344:50 - thing
344:51 - basically what i want to do is to run a
344:53 - method called self dot toggle underscore
344:57 - shop
344:58 - this one doesn't exist right now but
345:01 - basically what i want to do is inside of
345:03 - the level
345:04 - i want to create another method let me
345:07 - minimize everything in here so it's a
345:09 - bit easier to see
345:11 - inside of the level class
345:13 - i want to let me do it below player ad
345:17 - this one i want to call toggle
345:20 - underscore shop in here we need self and
345:23 - nothing else and this is a fairly simple
345:26 - method
345:27 - all i really want to do in here is self
345:30 - dot shop
345:32 - active
345:33 - is going to be not self self.shop
345:37 - active
345:38 - meaning whenever we are running this
345:40 - method we are switching shopactive
345:43 - either on or off
345:45 - this attribute doesn't exist right now
345:47 - so we do have to create it this happens
345:50 - inside of the init method in here let's
345:53 - put it under another section
345:56 - shop
345:57 - and by default this one needs to be
345:59 - false
346:01 - if this one is true though we are going
346:03 - to show the shop menu
346:05 - but that is going to come later first of
346:07 - all
346:08 - we have to pass this method here into
346:10 - the player which happens inside of setup
346:14 - and in here we have the player and the
346:18 - player is going to get another parameter
346:21 - toggle shop
346:23 - which is going to be self dot toggle
346:26 - shop
346:27 - for that to work inside of the player
346:30 - all the way at the top
346:31 - let me minimize the input method and
346:34 - inside of the indent method we need
346:37 - toggle
346:38 - shop
346:40 - and for this one
346:42 - inside of interaction
346:45 - i want to create another attribute self
346:47 - dot
346:48 - or girl shop is going to be toggle shop
346:52 - and with that we should be having a
346:55 - pretty good start
346:57 - i suppose we can test this inside of
347:02 - the run method
347:04 - all the way to bottom
347:05 - i want to print
347:08 - self dot
347:09 - shop
347:10 - active
347:12 - and this we should be able to influence
347:14 - with the player
347:16 - so let's run the game
347:18 - and we are getting thoughts right now
347:20 - that is a very good sign
347:22 - and if i walk to the merchant
347:25 - and if i press enter right next to him
347:28 - we're getting true if i press it again
347:30 - we're getting false
347:32 - so this is a very good sign
347:34 - and with that we can start working on
347:37 - the actual merchant for that i want to
347:39 - create a new file
347:41 - and save it as menu dot
347:44 - pi
347:46 - in here as always we are going to need
347:48 - import pygame and we also need from
347:52 - settings import everything
347:55 - after that i want to create a new class
347:57 - that i call menu
348:00 - in here we need a dunder init method
348:04 - this one itself
348:06 - it needs the player and it also needs
348:09 - toggle
348:10 - menu
348:11 - so we can switch off the menu from
348:14 - inside of the menu
348:15 - inside of this i want to have a general
348:19 - setup
348:20 - for this i want to turn the player into
348:23 - an attribute so self.player is player
348:27 - the same i want to do for the toggle
348:29 - menu so self.toggle menu is going to be
348:32 - toggle menu
348:34 - and besides that i am going to need two
348:36 - more things first of all i need the
348:39 - display
348:40 - surface
348:41 - this as always i'm getting with pygame
348:44 - dot display dot get underscore
348:48 - surface
348:50 - and besides that i need self dot font
348:53 - the font we get with pygame dot bond dot
348:57 - font be careful here about the
348:59 - capitalization the first font is
349:01 - lowercase the second font is uppercase
349:04 - this we want to call and in here we need
349:07 - a font style and we need a size
349:11 - the size is easy because we just want an
349:13 - integer in my case 30.
349:15 - for the font
349:16 - we need an actual file
349:19 - in my case
349:20 - here's the project folder and we have
349:23 - font and in there we have a file called
349:25 - lychee soda this is what i want to
349:27 - import
349:28 - the file path for that is going to be a
349:31 - string
349:32 - and i want to go one folder up
349:34 - to font
349:35 - and then to lichi
349:38 - so
349:39 - da dot ttf
349:41 - and with that i have a font
349:44 - with all of that covered basically what
349:46 - i want to do i want to create an update
349:49 - method that one itself and nothing else
349:53 - and this is actually going to show the
349:55 - menu although we do have to do quite a
349:58 - bit of work to get this one done
350:00 - for now just to see if this is working i
350:03 - want to show some blank surface
350:06 - which means i want self.display
350:10 - surface dot blit
350:12 - in here i want to create a surface from
350:14 - scratch and this one is going to have a
350:17 - dimension of let's say
350:20 - one thousand and one thousand
350:23 - the position here is going to be zero
350:25 - and zero
350:26 - the way we are going to call it inside
350:29 - of level.pi
350:31 - i want to get rid of print shop active
350:34 - and instead first of all at the top i
350:37 - want from menu
350:39 - import menu
350:42 - inside of the init method
350:44 - i want to create an object from the
350:46 - class so self.menu
350:49 - is going to be
350:51 - menu
350:52 - the two arguments we need here from menu
350:55 - we need player and toggle menu
350:58 - layer is really easy because we have
351:00 - self dot player
351:02 - toggle menu is also very easy because in
351:05 - here we have self dot this one is called
351:08 - toggle shop though but same thing i can
351:10 - just paste it in here and we are good to
351:13 - go
351:15 - inside of the run method i have to do
351:18 - some reorganizing
351:20 - the first two lines can stay identical
351:23 - and let me add a few more comments here
351:24 - to make all of this a bit clearer
351:27 - the first two lines are let's call it
351:30 - drawing logic
351:32 - after that we have the updates
351:36 - in here i want to check if
351:39 - shop
351:39 - active
351:41 - if that is the case i want self dodge
351:44 - menu dot update i think i called it
351:47 - yeah update i want to call this method
351:50 - here
351:51 - and only if that is not the case so else
351:54 - i want to do
351:56 - these two lines here
351:58 - if the menu is active the player cannot
352:00 - move anyway so there's no point updating
352:03 - all of the sprites or any of the planned
352:05 - collisions it's simply not necessary as
352:08 - a matter of fact i want to stop the
352:10 - entire game while the menu is open this
352:13 - is going to include the rain as well
352:16 - which means it's only supposed to rain
352:18 - if raining is true and not self dot shop
352:22 - active
352:24 - only then do i want to update the rain
352:27 - the overlay however can stay here
352:31 - let's put all of this under the weather
352:33 - section actually
352:36 - and let me remove these comments i think
352:39 - this makes the most sense
352:42 - with that we have the entire run logic
352:46 - let's try it
352:47 - so in
352:49 - it still works and now i want to run to
352:52 - the shop
352:57 - and in here i want to press enter
352:59 - and the game is crashing
353:01 - because inside of menu this one should
353:04 - be pi game dot surface
353:07 - and while i'm here i also realized this
353:10 - should be
353:11 - inside of another tuple
353:13 - now let's try this again
353:24 - and next to the merchant i press enter
353:26 - and now we have a big black rectangle
353:30 - and the rest of the game also doesn't
353:31 - update which is a very good sign
353:34 - which means this one is working we just
353:37 - have to add more logic to it the most
353:39 - important one for now is that we need an
353:42 - input method so that we can switch off
353:45 - the menu as well
353:47 - this is actually going to be your
353:49 - exercise
353:51 - i want you guys to get the input
353:55 - and then
353:56 - if the player presses
354:01 - escape
354:02 - close the
354:04 - menu
354:05 - pause the video now and try to figure
354:07 - this one out it should be fairly doable
354:13 - first of all we have to get all of the
354:15 - keys this we get with pygame dot key dot
354:19 - get underscore pressed
354:22 - once we have that i want to check if
354:25 - keys and pygame dot a underscore escape
354:30 - if that is the case i want to run self
354:33 - dot toggle menu don't forget we also
354:36 - have to call self dot input
354:39 - but other than that this should be it
354:42 - back at main.pie let's run this again
354:47 - and right next to the merchant i press
354:49 - enter and now if i press escape
354:52 - the game continues and this i can do
354:54 - multiple times this is working really
354:56 - well
354:57 - so with that we can toggle the menu
355:00 - with that we can actually start creating
355:03 - the proper one
355:05 - and for that i first of all want to have
355:07 - a couple of options the most important
355:09 - one for now is self dot width
355:12 - and this one i set to 400
355:15 - this is going to be the entire window
355:18 - and inside of it roughly here
355:21 - i want to have the menu
355:23 - inside of the menu we're going to have
355:25 - individual entries like
355:28 - so
355:29 - what with is determining right now is
355:31 - the width of this entire menu
355:35 - besides that i also want self dot space
355:39 - that is the space between the elements
355:41 - this i set to 10 and then self dot
355:44 - padding
355:45 - and this i set to 8. once we have that
355:48 - information
355:49 - i want to create the actual menu entries
355:53 - and for that first of all we are going
355:55 - to need all of the i call this one the
355:59 - options
356:00 - what this is going to be inside of the
356:02 - player
356:03 - in the init method we have the inventory
356:07 - this is going to be what i want for the
356:10 - options for the menu
356:12 - and i am going to combine all of those
356:14 - into one list
356:15 - self dot player dot item underscore
356:19 - inventory and i only really care about
356:21 - the keys here
356:23 - don't forget to call this and this i
356:25 - want to turn into a list
356:28 - this list i want to combine with the
356:31 - seeds
356:32 - let me copy it and to combine it to
356:34 - lists i need plus and copy this list
356:38 - and i want to have the seed inventory
356:43 - this one here
356:45 - to make sure this one is working let me
356:47 - print what we get self dot options
356:52 - and now if i run this
356:54 - and close the game
356:57 - here you can see we have all of the
356:59 - different options
357:01 - apple corn and tomato are the inventory
357:04 - of the player so the items corn and
357:06 - tomato are the seeds
357:08 - although now we do have a problem let me
357:10 - run it again actually
357:12 - inside of this list i need to know which
357:15 - of these items can be sold and which
357:17 - ones can be bought
357:19 - the items should be only sellable so
357:23 - these four items i want to be able to
357:25 - sell and these two items here i can only
357:27 - buy as a consequence i need to figure
357:30 - out where i'm drawing this line here
357:33 - where we end the selling menu and start
357:35 - the buying menu for that i created
357:38 - another attribute that i called cell
357:42 - border
357:43 - this is basically self dot player dot
357:46 - item inventory i am getting the length
357:51 - of it and from this i'm subtracting
357:54 - negative one
357:55 - later on i'm going to cycle through this
357:57 - list and for every item i am going to
358:00 - check the index and check if it is
358:02 - smaller or greater than this border
358:04 - if it is smaller we are selling if it is
358:07 - greater we are buying
358:08 - and with that i can create is self.setup
358:12 - method
358:14 - let's do it right below
358:16 - this one doesn't need any arguments
358:19 - the most important thing i have to do in
358:21 - here is to create the text surfaces
358:26 - all of those are going to be stored in
358:28 - the list and the list i called text
358:31 - surfaces
358:32 - for now it's just going to be an empty
358:35 - list
358:36 - all of these items are going to be
358:37 - created with four item in self dot
358:41 - options
358:43 - that is the list we have created up here
358:45 - all i have to do is to create a text
358:48 - surface and this i am getting with
358:50 - self.font.render
358:54 - in here we need a string
358:57 - we need anti-alias and we need a color
359:01 - the color is the easiest bit i just want
359:03 - to have black in here
359:05 - anti-alias should be false and the
359:08 - string should just be the item
359:11 - once i have that text surface i want to
359:13 - get myself dot text surfaces and append
359:17 - the individual text surface
359:20 - i also just realized this one should be
359:22 - set up not input
359:25 - now with that we have a list of surfaces
359:30 - this we can now use inside of the update
359:32 - method in here i can get rid of this big
359:35 - black rectangle and instead i want to do
359:39 - for text
359:41 - surfaces in self.text
359:44 - serves
359:46 - although remember what i explained
359:48 - earlier
359:49 - for this logic here to work to separate
359:51 - between the by and the cell menu i need
359:54 - to know the index of every item inside
359:56 - of this for loop
359:58 - as a consequence i am going to use the
360:01 - enumerate method
360:02 - here and let's call this one text index
360:07 - i suppose for now all we have to do is
360:10 - self dot display surface dot blit
360:13 - we have a text surface
360:16 - and for the position
360:19 - let's say we can go with a hundred for x
360:23 - and for y i want to have the text
360:25 - index
360:27 - multiplied by 50.
360:29 - let's try all of this now
360:32 - and once again i have to walk to the
360:35 - trader
360:41 - here we are at the trader if i run this
360:43 - we can see the different entries so this
360:45 - is looking really good we can also end
360:47 - the menu and this is working very well
360:51 - very good we are making progress
360:55 - although now we do have a problem right
360:58 - now the height is basically random so we
361:02 - have to figure this out more
361:03 - deliberately
361:04 - this is also going to happen inside of
361:07 - the setup method
361:08 - besides the text surfaces i want to have
361:12 - self.total
361:14 - height
361:15 - by default this is going to be zero
361:19 - inside of the for loop i want to get
361:21 - this total height
361:23 - and plus equal
361:25 - self dodge text
361:28 - surface
361:30 - and then get underscore height
361:33 - although don't forget i also want to add
361:36 - plus
361:37 - self dot
361:39 - heading
361:40 - multiplied by two and this i want to put
361:44 - in brackets that looks a bit cleaner
361:46 - each of those text entries let's say we
361:50 - have three for now
361:52 - inside of those the text is only one
361:55 - part in the middle
361:57 - and there should be some space or some
361:59 - padding between the top and the bottom
362:01 - of the text this is what we're getting
362:03 - with self.padding the entire height
362:06 - though is what we're getting from
362:08 - self.total height this is what we're
362:10 - going to use in just a second to center
362:12 - the entire menu
362:14 - although there's one more thing that we
362:16 - do need
362:17 - because if i open the drawing again
362:21 - between each of the entries so this
362:24 - space here
362:25 - there should be some more space that is
362:27 - the space we have set up earlier in here
362:31 - to get that number
362:33 - let's do it here i want to get self dot
362:36 - total height
362:38 - and i want to add a number number i want
362:41 - to get the
362:43 - text surfaces and i want to know how
362:45 - many items i have so i want to have the
362:47 - length
362:49 - right now that number would be free
362:50 - because we have one two and three
362:53 - elements
362:54 - from that i want to subtract one for the
362:56 - simple reason that we only have one
362:58 - space for any two elements
363:01 - as a consequence if we have three
363:04 - elements in total we want to have two
363:06 - spaces between them all of this i want
363:09 - to put inside of another bracket and
363:11 - this i want to multiply with self dot
363:14 - space
363:17 - and now i have the total height
363:21 - this i can use to calculate self dot
363:24 - let's call it menu top
363:26 - this is going to be the top part of the
363:28 - menu
363:30 - for this number i need in my settings
363:32 - the screen height
363:35 - and this i want to divide by two
363:38 - from this number i want to get myself
363:41 - dot total height
363:43 - and divide this by two as well
363:45 - this here is going to be the entire
363:47 - screen and screen height divided by 2
363:50 - would be roughly this point here
363:53 - from that i want to subtract self.total
363:55 - height divided by 2.
363:58 - that would be
363:59 - roughly let's say here with this being
364:02 - the first half and the other half would
364:05 - be below so one half here that way the
364:08 - menu is always going to be in the middle
364:11 - there's one more attribute i want and
364:13 - this i called self dot main
364:17 - rect
364:18 - this is going to be the bounding box for
364:20 - the entire menu and this is going to be
364:22 - a rectangle so pygame.rect
364:25 - in here we need the left the top the
364:27 - width and the height
364:29 - figuring those numbers out could
364:31 - actually be a really good exercise so
364:34 - try to figure them out yourself and see
364:36 - how far you get
364:40 - there are three numbers in here that
364:41 - should be fairly simple the top is what
364:44 - we have just done it's just self.menu
364:47 - top
364:48 - so i can place this one in here
364:50 - the width is also very easy that is the
364:52 - number we have created up here
364:55 - which means i want to have self dot
364:57 - width
364:59 - height is also easy this is just going
365:01 - to be self dot total height
365:04 - the only minor complication is the left
365:06 - side
365:07 - to get this one we kind of need the same
365:10 - logic we have used here i first of all
365:13 - want to get my screen
365:15 - width
365:16 - and this i want to divide by two
365:19 - from that i want to subtract self dot
365:22 - width and subtract this by two as well
365:25 - with that we should be having a
365:27 - rectangle that is in the center of the
365:29 - window and also is as tall as all of the
365:32 - text elements
365:34 - i guess let me minimize the setup method
365:37 - and try this one
365:39 - i guess for now we can comment out this
365:41 - for loop here and instead
365:44 - i want to pygame.draw.rect
365:48 - i want to draw on self.display
365:51 - underscore surface
365:53 - the color let's go with red
365:56 - and the rectangle is going to be self
365:58 - dot main rectangle
366:00 - and just for testing purposes it's going
366:02 - to be kind of annoying to always walk
366:05 - towards the merchant
366:07 - so inside of the player
366:09 - let me go to the input method
366:15 - and then here if the player is pressing
366:17 - enter i want to toggle the shop already
366:21 - like this
366:22 - now if i run the game
366:24 - i am getting an error
366:27 - this happens inside of menu inside of
366:30 - setup
366:31 - and this self.text surface shouldn't be
366:34 - yourself it's just a text surface so
366:36 - we're getting this one here
366:39 - now let's try this again we're not
366:40 - crashing and now if i press enter
366:43 - we're getting a menu in the middle of
366:44 - the window i can also press escape and
366:47 - the game continues as always
366:49 - so this is working quite well
366:51 - i suppose next up we can start working
366:54 - on another important ui element and that
366:58 - is display underscore money
367:01 - there's no need for any arguments in
367:03 - here and all we are going to do in here
367:06 - is first of all we need a money surface
367:10 - or rather
367:12 - since we have local variables this can
367:14 - be a text surface
367:16 - all i want in here is self.font.render
367:20 - in here again we need a string we need
367:22 - anti-alias and we need a color the color
367:25 - once again is going to be black and
367:28 - anti-alias is going to be false
367:31 - it is false here because i have pixel
367:33 - fonts which don't look good when you
367:35 - enter and use them
367:36 - finally for the string what i want to
367:39 - access is inside of the player in the
367:42 - init method
367:44 - i want to access
367:46 - this money attribute here this i get
367:49 - with self dot player dot
367:52 - money
367:53 - although this i want to put inside of an
367:56 - f string
367:58 - like this because that way i can add a
368:01 - dollar sign before
368:03 - once i have that i can create a text
368:06 - rectangle
368:08 - this is just going to be the text
368:09 - surface dot get underscore rect
368:13 - and in here i want to place the mid
368:15 - bottom
368:16 - for the position here i want to have
368:19 - this green
368:21 - width divided by two so we are right in
368:24 - the middle and then i want to have this
368:26 - green height and subtract 20 from here
368:30 - that way we are slightly off centered
368:32 - from the bottom of the window
368:34 - once we have those two bits i can get
368:36 - myself dot display surface and split the
368:40 - text
368:41 - surface and the text
368:44 - rectangle
368:46 - and now all i have to do is to run self
368:50 - dot display money and this should be
368:53 - working
368:54 - so inside of main or pi i press enter
368:56 - and we can see the money in the bottom
368:58 - center of the window
369:00 - this is working very well
369:02 - although there's one more element i want
369:04 - to add
369:06 - and that is a background
369:08 - for this text this i get with pygame dot
369:12 - draw.rect
369:14 - and in here i want to draw on
369:16 - self.display surface
369:18 - the color for this one should be white
369:21 - the rectangle i want to use in here is
369:24 - the text rectangle although i do want to
369:26 - inflate this one by a tiny bit
369:29 - let's say 10 and 10 pixels
369:33 - if i run this now
369:35 - this is already looking much better
369:37 - although i do want to have some rounded
369:38 - borders
369:40 - this i can also get very easily
369:42 - i need to add two more arguments
369:46 - the first one is the border width which
369:48 - in my case is going to be zero and then
369:50 - we have to border radius
369:52 - which in my case is going to be 6 and
369:55 - this 6 here determines the border radius
369:57 - or how much rounding we get
369:59 - if i run this now
370:01 - we have some rounded borders which makes
370:04 - the entire thing look much nicer
370:06 - i guess you can play around with
370:07 - different numbers here let's try four
370:11 - yeah i guess this one looks a bit better
370:13 - but again this is pretty subjective so
370:16 - choose whatever you think is best
370:18 - with that we have finished the money
370:20 - this is all we need in this one
370:23 - i guess next up we can work on all of
370:26 - the actual entries and we already have
370:29 - some good starting points here we have
370:32 - access to all of the text surfaces and
370:35 - we know their index
370:37 - this i can use inside of another method
370:40 - let me call it show
370:42 - entry
370:43 - in here we do need a couple of arguments
370:46 - i want to have a text surface so the
370:49 - text i want to show that i want to have
370:51 - the amount
370:53 - like so
370:54 - then i need the actual position and this
370:56 - is going to be top
370:58 - with all of that i can start working on
371:01 - this and first of all in here i need a
371:05 - background
371:07 - after that we are going to create the
371:09 - text and later on we are also going to
371:12 - show an amount
371:15 - but let's get started with the
371:16 - background
371:18 - in here i want to create a bg rectangle
371:22 - this is just going to be a pie game rect
371:25 - and once again we need a left a top a
371:27 - width and a height
371:29 - left we can get fairly easily because we
371:31 - have self dot main rectangle dot left
371:36 - since this main rectangle is in the
371:38 - center of the window this makes it very
371:40 - easy for us to get positions
371:42 - top is going to be what we're getting
371:45 - from the parameters this top here the
371:48 - width is going to be self dot with the
371:50 - one we have created all the way up here
371:53 - and finally the height
371:55 - is going to be text surface dot get
371:58 - underscore height don't forget to call
372:00 - it
372:01 - and to this i want to add
372:04 - self.heading
372:05 - multiplied by two
372:07 - once i have that all i want to do is
372:09 - pygame.draw.org
372:12 - and in here self.display surface
372:16 - the color should be white
372:18 - i want to draw the background rectangle
372:21 - and i want to go with 0 and 4 for the
372:24 - border radius
372:26 - with that we already have a pretty good
372:28 - start all we have to do now is inside of
372:32 - this for loop we have to figure out how
372:34 - to actually call this show entry let me
372:37 - add a bit of white space and first of
372:40 - all in here we need to get the top
372:42 - and the top is going to be self dot
372:45 - main rectangle dot top
372:48 - plus the
372:49 - text
372:51 - index
372:52 - and this i want to multiply with a
372:54 - couple of things most importantly the
372:57 - text surface
372:58 - and i want to get the height of that
373:01 - although to that i have to add
373:04 - self dot
373:05 - heading
373:06 - multiplied by 2 and i have to add self
373:09 - dot
373:10 - space
373:11 - think of this one here is the main
373:15 - rectangle this one here
373:17 - and by default we are getting the top
373:20 - this line here
373:22 - and for every item we want to get the
373:24 - distance downwards
373:26 - that we get by multiplying the text
373:28 - index by the height of the text the
373:31 - padding and the space
373:34 - for example if the text index is zero
373:37 - all of this is going to be zero so the
373:39 - first item is going to be all the way at
373:41 - the top here
373:42 - for item number one
373:44 - we would be somewhere
373:46 - here
373:47 - let's say this one could be 100 because
373:50 - the text height
373:51 - would be something like 70.
373:54 - the padding
373:56 - could be
373:57 - 2 times 10 and let's say for the space
374:00 - we also have 10
374:03 - and all of this we want to multiply by
374:06 - one as a consequence the result here is
374:08 - going to be 100 and this 100 is going to
374:11 - be the top of this text entry
374:14 - and this is what we can use in self dot
374:17 - show entry let me copy all of the
374:20 - parameters here
374:21 - so top is what we have just calculated
374:24 - text surface is also what we are getting
374:26 - from here
374:27 - for the amount for now let's just say 0
374:30 - we're going to work on this in just a
374:32 - second
374:33 - but for now if i run main.pi again and
374:36 - press enter now we can see all of the
374:39 - background fields and those are
374:41 - perfectly centered which is looking very
374:43 - nice
374:44 - definitely progress
374:46 - although let me get rid of
374:49 - this line here so we're not drawing the
374:51 - text anymore and also
374:53 - this drawing here so we don't have the
374:56 - red background
374:58 - now if i run this again this is looking
375:01 - much cleaner cool so with that we can
375:04 - start working on the text
375:07 - for this one i want to create a text
375:10 - rectangle
375:11 - once again this is going to be pygame
375:13 - dot rect and again we need a left at top
375:17 - a width and a height
375:19 - for this one i want to get the text
375:22 - surface and get underscore rect
375:25 - in here once again i want to place the
375:28 - mid left
375:29 - i need an x and a y position
375:32 - or rather i need a left and a top
375:35 - position to be a bit more specific
375:37 - for the left side i want to have
375:40 - self.mainrect dot left and now i want to
375:44 - have an offset let's say 20.
375:47 - for the top i want to have the bg
375:50 - rectangle
375:51 - and in here i want to have the center y
375:54 - position
375:55 - once i have that i can run
375:57 - self.displaysurface.blit
376:00 - and pass in the text surface and the
376:03 - text
376:04 - rectangle
376:05 - let's try this one now
376:08 - and there we go this is looking really
376:10 - good
376:11 - finally we need the amount
376:15 - for this one first of all i want to
376:17 - create an amount surface
376:20 - this once again i get with self.font.rna
376:25 - in here we need some text we need
376:28 - anti-alias and once again the color
376:31 - the color
376:32 - is always going to be black and the
376:34 - alias is always going to be false and
376:36 - the text itself is going to be the
376:39 - amount
376:40 - although
376:41 - here this we have to convert to a string
376:44 - because by default amount is a number
376:47 - and pygame doesn't like that it always
376:49 - wants a string for the render method
376:52 - now that we have that we can create an
376:54 - amount rectangle
376:56 - this we get with amount surface dot get
377:00 - underscore rec
377:01 - and for this one i want to place the mid
377:04 - right
377:05 - again we need a left and a top and for
377:08 - the left side what i want in here if
377:11 - this is one text box
377:15 - or rather one of the bg rectangle
377:19 - inside of there we have the text
377:21 - rectangle and the text is somewhere here
377:23 - ish
377:24 - with a offset from the left
377:27 - for the amount surface i want the exact
377:29 - opposite i want to come from the right
377:31 - side and have something like this which
377:34 - means for the left side here we want to
377:37 - have the right side
377:39 - of the main rectangle and then go to the
377:42 - left a bit
377:43 - which means i want to have self dot main
377:46 - rect
377:47 - dot right
377:49 - and subtract let's start with 20 pixels
377:52 - although for the top all i want is the
377:55 - bg rectangle and then center y again
377:58 - and let me clean this up a tiny bit
378:01 - there we go all we have to do now is get
378:03 - self dot display surface dot blit and
378:07 - pass in the amount surface and the
378:09 - amount rectangle
378:12 - if i run this now
378:15 - this is looking pretty good
378:18 - although we do have to figure out the
378:20 - actual numbers for the amount
378:22 - that however isn't that difficult or at
378:25 - the very least it's certainly possible
378:27 - first of all inside of the for loop i
378:30 - want to get let's call it an amount list
378:34 - and this amount list is going to be very
378:36 - similar compared to this options here as
378:38 - a consequence i can just copy it
378:41 - and paste it in here except now we don't
378:44 - look at the keys instead we are looking
378:46 - at the values
378:48 - this way if i open the player we are
378:51 - getting
378:52 - all of these values here inside of one
378:55 - list
378:56 - and this list has the same order
378:59 - as this list here
379:02 - as a consequence
379:04 - we can get the amount
379:06 - simply by looking at the amount list and
379:09 - using the text index
379:12 - and that is what i want to pass in here
379:17 - if i now run this again press enter we
379:19 - are getting lots of zeros but then we
379:21 - are getting five and five those are the
379:24 - two seats and with that we have the
379:29 - basics of the menu
379:31 - although we cannot select anything and
379:33 - let's do this right now i guess we can
379:35 - keep the entire merchant in one big
379:38 - section
379:39 - for the selection we need a few more
379:41 - things most importantly let me add this
379:44 - section here and let's call it
379:48 - movement
379:50 - the one thing we need in here is self
379:52 - dot index
379:54 - by default zero here is totally fine
379:57 - and how i'm going to use this when i'm
380:00 - creating show entry let me minimize
380:02 - everything else
380:04 - there's going to be one more parameter
380:06 - and that is going to be selected
380:09 - and if selected is true so if selected
380:15 - then i want to for now just draw a
380:18 - border around this particular box which
380:21 - i'm getting with self.display surface
380:24 - for the drawing the color here should be
380:27 - black
380:28 - and i want to get the background
380:30 - rectangle
380:31 - although now i want to have a border
380:34 - width of four and 4 for the border
380:37 - radius if you specify a border width the
380:40 - content or the filling disappears for
380:43 - this rectangle
380:44 - but let me show what actually happens if
380:47 - i press enter now
380:49 - we are getting an error because i forget
380:51 - to add the argument in here i want to
380:54 - have either true or
380:56 - false
380:57 - and what i am checking is if self.index
381:01 - is equal to the text index
381:05 - now if i run this and press enter
381:07 - now by default the first item is going
381:10 - to be selected however if i go to my
381:12 - menu and set this index to let's say a 3
381:17 - and run this again
381:19 - now
381:21 - we have tomatoes selected
381:24 - and all i really have to do inside of
381:26 - the menu is to change this index to
381:29 - select a different item and this i'm
381:31 - doing inside of input
381:34 - all i want to do in here is if keys and
381:38 - pie game dot k underscore up if that is
381:42 - the case
381:43 - i want to set self dot index minus equal
381:47 - one
381:48 - then i can copy all of this
381:51 - and change the up to down
381:54 - and this one should be a plus one
381:57 - now i can set index back to zero and now
382:00 - let's try this actually if i press enter
382:03 - now and press down
382:05 - something weird is happening the thing
382:07 - disappears oh well it kind of works but
382:11 - it moves way too fast
382:13 - and this is a problem we have
382:14 - encountered earlier
382:16 - basically inside of the init method
382:19 - pygame for this one for example checks
382:21 - if the down key is being pressed but
382:23 - pygame checks this about 100 times per
382:26 - second as a consequence if we are
382:29 - pressing it down pygame registers this
382:31 - line let's say 20 times
382:34 - even though for us it seems like we are
382:36 - only pressing the key once
382:39 - and as a consequence we need a timer
382:43 - this one we already have i want from
382:46 - timer import timer
382:49 - and the timer i want to create in here
382:51 - so self.timer
382:53 - is going to be
382:54 - timer for this one we only need a
382:58 - duration and for the duration for this
383:00 - one i went with 200 milliseconds
383:03 - now inside of the input method when i'm
383:06 - pressing either up or down
383:09 - i want to activate this timer so
383:11 - self.timer.activate
383:14 - but all of this should only be possible
383:17 - if the timer is not active
383:19 - meaning if not self.timer.active
383:24 - finally there's one more thing that we
383:26 - need and that is we have to update the
383:28 - timer which i'm doing all the way to the
383:30 - top of the input method
383:31 - self.timer.update
383:35 - i hope you remember the time i actually
383:36 - recreated this one a couple of hours ago
383:39 - let me open it actually so inside of the
383:41 - timer this one here
383:43 - we have all of this
383:45 - and this is what i'm using inside of the
383:46 - menu right now
383:48 - but with that this should already be
383:51 - working if i run this now i can open the
383:53 - menu and i can move up and down this is
383:55 - working really well the problem right
383:57 - now is if i move too far up the thing
383:59 - disappears and also if i move too far
384:01 - down it disappears
384:05 - this we want to control for
384:07 - meaning i want to
384:10 - clamp the
384:12 - values
384:14 - all this really means in practice is i
384:16 - want to have myself.index and if this
384:18 - one is below zero
384:20 - i want to set self dot index
384:23 - to length of self dot options
384:28 - minus one
384:30 - this means if we are going below zero we
384:32 - we're going to the end of the list
384:35 - this is also going to work the other way
384:36 - around that if self.index
384:39 - is greater than
384:41 - the length of the list minus one then i
384:44 - want to set self.index to zero
384:49 - and now let's run this again
384:51 - and if i move down this still works if i
384:53 - move up we are getting to the bottom of
384:55 - the list and if i move downwards we are
384:57 - going back to the top
384:59 - so this is working perfectly fine
385:03 - okay next up
385:05 - when we are showing the entry
385:08 - let me minimize everything once more
385:12 - the next thing i want to do is that let
385:15 - me run the game again
385:17 - and we have what apple corn automator
385:20 - selected i want to have a cell text
385:24 - roughly here
385:26 - for all of these and if we have corn or
385:29 - tomato selected there should be a by
385:32 - text here
385:33 - and this is what i'm going to create now
385:37 - first of all for that inside of the
385:40 - setup we have to import or well create
385:43 - two more things
385:44 - those two things are going to be the by
385:46 - or cell text surface
385:50 - in here i want to have self dot by text
385:54 - and i want to have self dot cell text
385:58 - both of those are going to be
386:00 - pygame.font.render
386:03 - and again we need three arguments the
386:05 - first one is the text let's leave this
386:07 - one empty for now after that we want
386:09 - folds for the anti-alias and for the
386:11 - color we want black
386:14 - for the byte text this should just be by
386:17 - and for the cell text it should be cell
386:21 - with that we have two surfaces
386:24 - we just have to figure out when to
386:27 - actually show them
386:29 - that is going to happen inside of show
386:31 - entry
386:32 - specifically i only want to show this
386:35 - when the specific entry is selected
386:38 - how this is going to work i am first
386:40 - going to check if self dot index
386:44 - is greater than self.cell
386:47 - border this is the border we created in
386:50 - the init method
386:52 - right here this one is checking the
386:55 - length of the inventory so if we are
386:59 - inside of the length of this border we
387:01 - want to sell if we are beyond it we want
387:03 - to buy
387:04 - let me add comments here this one is
387:06 - going to be buy and if this one is not
387:08 - true so else then we want to sell
387:12 - actually i think this one is a bit
387:14 - confusing let me do this the other way
387:16 - around so if we are below this we want
387:19 - to sell and if we are beyond it we want
387:22 - to buy
387:24 - and all we have to do now is self dot
387:26 - display surface dot blit and in the cell
387:30 - one i want to display self dot
387:34 - i called this one
387:36 - cell
387:38 - text
387:39 - for the position let's say for now we
387:41 - are going to go with zero and zero
387:44 - and for the buy text this is going to be
387:46 - by text
387:48 - and let's try this one although it's
387:50 - going to look a bit funny
387:52 - and we have an issue inside of the setup
387:55 - method this shouldn't be pi game it
387:58 - should be self.font.render
388:01 - if i now run this again this is working
388:03 - and now in the top left you can see sell
388:05 - sell sell and now we have buy
388:08 - buy buy
388:10 - although for the tomato something did go
388:12 - wrong so we have to make some minor
388:14 - adjustments here but other than that
388:16 - this is working pretty good i guess the
388:18 - problem here is inside of entry this
388:21 - should be smaller or equal
388:24 - if i now run this again we get sell sell
388:27 - sell and buy and buy there we go this is
388:29 - working just fine
388:33 - although the position of the buy and
388:35 - sell text we do have to work on although
388:38 - the position is looking a bit weird
388:40 - let's work on that one and for this i
388:43 - want to create another rectangle let's
388:45 - call it the position rectangle
388:48 - in here i want to have self dot for cell
388:52 - i want to have the cell
388:54 - text and get underscore rect
388:57 - for this one i have to place the mid
388:59 - left and once again i need the left and
389:02 - i need a top the top is the really easy
389:04 - part because i get my background
389:06 - rectangle dot center y
389:09 - for the left i want to have my self dot
389:12 - main rectangle dot left
389:15 - and to this one i want to add 150 pixels
389:19 - i can place the position rectangle in
389:22 - here and this should be working let's
389:25 - try
389:27 - and we are getting an error that this
389:29 - should be
389:30 - yet wrecked with lowercase letters
389:35 - and now we get cell
389:37 - in the perfect positions although buy is
389:40 - still looking a bit weird
389:42 - but that we can work on
389:45 - all i have to do is duplicate this one
389:46 - here paste it in there and now we want
389:49 - to get the bi-text
389:53 - surface
389:55 - but the rest is going to remain the same
389:58 - meaning if i run this now
390:00 - we get sell cell and bye bye because i
390:03 - didn't paste
390:05 - the position rectangle in here for the
390:07 - position
390:08 - now this should be working
390:10 - sell sell and buy and buy this is
390:12 - working perfectly fine
390:16 - cool i am really happy with this
390:21 - so let me minimize show entry and the
390:24 - setup all we have to do now inside of
390:27 - input is to actually make the menu do
390:30 - something
390:32 - for that inside of this if statement
390:34 - here i want to add another if statement
390:37 - and now i want to check if keys and
390:40 - pygame dot k underscore space
390:44 - if that is the case first of all i want
390:46 - to activate the timer so
390:47 - self.timer.activate
390:51 - after that i want to get the item
390:55 - so i want to create another variable
390:57 - called current item
390:59 - and for this one i want to have myself
391:02 - dot options
391:04 - and use self dot index
391:07 - i suppose let me print what we actually
391:09 - get with current item
391:11 - and if i run main.pi
391:13 - if i now press space we get wood apple
391:16 - corn tomato corn and tomato this is
391:20 - working just fine
391:21 - now i have to figure out do i want to
391:23 - sell or do i want to buy
391:27 - that is information we can access quite
391:29 - easily
391:30 - because i once again want to check if
391:33 - self.index is smaller or equal than
391:37 - self dot sell order
391:40 - if that is the case i do want to sell if
391:43 - it is not the case so else i want to buy
391:46 - if i am selling it should be
391:49 - self.player.item.inventory
391:53 - and i want to check the current item
391:56 - if that is greater than 0
391:58 - i want to do something so this should
392:00 - all be an if statement
392:03 - let me copy the entire line here because
392:05 - what i want to do if this is the case
392:08 - this should be reduced by 1.
392:10 - and on top of that i want to get myself
392:13 - dot
392:14 - layer
392:16 - dot money
392:18 - and i want to increase that amount by a
392:21 - certain number this number i'm getting
392:24 - from settings and here i can minimize a
392:26 - ton of different things
392:30 - in here we have sale price and purchase
392:32 - prices
392:33 - for now i only care about the sale price
392:36 - this i want to access and i want to use
392:39 - the current item as the index
392:41 - this should be all we need for now for
392:44 - the else i want to add a pass and just
392:47 - to test this inside of the player let's
392:49 - give the player a couple of items
392:53 - like this
392:54 - and now if i run this again i press
392:56 - enter i have lots of different items i
392:59 - could be selling and if i press space
393:02 - the amount gets reduced and our money
393:04 - increases
393:06 - and let me try to sell all of my wood
393:09 - if i now get to zero i cannot sell
393:11 - anymore
393:13 - but i can still sell other things so
393:14 - this is working perfectly fine
393:17 - so with that all we have to do is to
393:20 - check the buy part and we are basically
393:23 - done
393:24 - in here first of all i need to get the
393:26 - seed price
393:28 - this i'm getting again from settings and
393:30 - there we have purchase prices
393:32 - this i want to get and in here i want to
393:34 - get my current item as the index
393:37 - now i want to check if the player has
393:39 - enough money for it which means if
393:41 - self.player.money
393:43 - is greater or equal than the seed
393:47 - rise
393:48 - then i want to get self.player.seed
393:52 - underscore inventory
393:55 - and i want to get the current item again
393:58 - i want to plus equal one
394:00 - and then self.player.money
394:05 - is going to be minus equal the purchase
394:08 - price of the current item
394:10 - there we go and this should be it let's
394:13 - try
394:15 - so i can still sell things but now if i
394:18 - try to buy things
394:19 - my money goes down and
394:22 - let me hold space pressed and at some
394:25 - point we should be reaching zero
394:29 - there we go now we are zero and i cannot
394:32 - buy any more seats
394:35 - i can still sell things though and now
394:37 - that i have money again i can buy some
394:38 - tomato seeds
394:40 - until i am running out of money and
394:44 - there we go this is working fine
394:49 - so with that we have created the entire
394:52 - menu
394:53 - and that finishes basically the main
394:55 - part of the game all we have to do now
394:57 - is to add some sounds and then we are
394:59 - done for the final bit we have to add
395:01 - the sound let's jump right in this
395:03 - really shouldn't take too long here we
395:05 - are back in the code and what i want to
395:07 - work with let me open the folder
395:10 - here's the entire project and i want to
395:13 - look at audio in here we have a couple
395:16 - of different files that i want to use
395:18 - the main problem is we have to figure
395:20 - out when and where to use them
395:23 - but that really shouldn't be too
395:25 - difficult
395:27 - let's start with the axe for this one i
395:29 - want to look at my sprites so let's open
395:31 - this one again
395:35 - in the sprites i want to minimize
395:37 - everything because i only want to focus
395:39 - on the tree
395:41 - basically inside of the tree whenever we
395:43 - damage a tree i want to play the x sound
395:47 - let me add another comment here
395:49 - play
395:50 - sound
395:51 - basically all i want to do is self dot x
395:54 - sound dot play and that is basically it
395:58 - for that i have to import it
396:00 - this happens in the init method
396:04 - let's call this one sounds
396:06 - all i need in here is self dot x sound
396:10 - and this is what i get from pygame dot
396:14 - mixer dot sound
396:17 - spelled like that
396:19 - the file path we need here is one fold
396:21 - up then audio and in there we have a
396:23 - file called x dot
396:26 - mp3 and with that we should be ready
396:32 - if i now run main.pi and walk towards a
396:35 - tree and hit that one with an x
396:41 - that is sounding pretty good
396:44 - so next up we need to sound effect if
396:47 - the player gets a thing
396:50 - this is going to happen inside of level
396:52 - because in here i have the player add
396:55 - method i basically want to play
396:58 - something like self.success.lay
397:03 - this success we have to import and this
397:05 - happens let's do it all the way at the
397:08 - bottom
397:09 - music this i call self.success
397:14 - and this once again we get with
397:15 - pygame.mixer.sound
397:18 - the file once again is one folder up
397:21 - audio
397:22 - and the file is called success.wav
397:27 - although for this one by default i think
397:28 - it's a bit loud as a consequence
397:32 - self.success dot set underscore volume
397:36 - and in here 0.3 i think sounded good
397:41 - and now anytime the player gets any kind
397:43 - of item we are playing that sound
397:47 - so let's run minded pi
397:49 - and let's say i want to get an apple
397:54 - that sounds not too bad
397:56 - and if a tree disappears
397:59 - this also plays cool so this is working
398:02 - it's also going to play when we are
398:04 - picking up a plant but that takes a
398:06 - while to test so i think we're good for
398:08 - the next tool i want to work on the hoe
398:11 - and for that i want to reopen my soil
398:14 - layer
398:15 - or soil.pie
398:17 - and i want to minimize everything in the
398:19 - soil layer
398:21 - i want to add sounds
398:24 - and in here i want to create self.hoe
398:28 - sound
398:29 - and this one i get with
398:31 - pygame.mixer.sound
398:33 - the file path here is one folder up
398:35 - audio
398:37 - and in there i have whole dot wav
398:41 - this i want to make a little bit less
398:43 - loud though so
398:45 - i want to set the volume to 0.4
398:50 - and this now if i minimize all of the
398:52 - methods i want to play
398:54 - whenever the soil gets hit so in here
398:57 - let's do it all the way to the top
399:00 - self.hold
399:04 - and with that we should be having
399:05 - another sound
399:07 - so if i now use this one
399:10 - possibly a bit loud
399:13 - i want to change the set volume to 0.1
399:17 - and now let's try this
399:20 - definitely an improvement
399:23 - it's going to get better once we have
399:24 - background music but i'm kind of happy
399:26 - with this
399:27 - next up i want to work on the watering
399:29 - sound this one is going to happen inside
399:31 - of the player in here all the way at the
399:34 - bottom
399:35 - here
399:36 - i want to add
399:37 - his sound section and this i called
399:40 - self.water ring
399:43 - this once again we get
399:44 - pygame.mixer.sound
399:47 - the file path here is one fold up audio
399:50 - and the file name is called water.
399:54 - this one is an mp3
399:58 - and whenever we are using a tool and the
400:01 - selected tool is water
400:03 - i want to play self dot water ring
400:08 - although for this one i also want to
400:09 - change the
400:10 - volume so self.watering.set
400:13 - underscore volume
400:15 - is going to be 0.2
400:18 - if i now run main.pi again select the
400:20 - watering can
400:23 - that's working just fine cool
400:26 - there's one more that i forgot and that
400:28 - is inside of soil besides the whole we
400:31 - also have self dot plant
400:34 - and this one let's call it plant sound
400:36 - actually plant sound
400:38 - once again pygame dot mixer dot sound
400:41 - and in here one folder up audio
400:45 - and this one is called
400:48 - planned and the file ending is
400:50 - a dot wav
400:53 - let me just duplicate it self dot plan
400:56 - sound dot set underscore volume
400:59 - let's go of 0.2
401:00 - [Music]
401:02 - this one i want to play whenever we are
401:05 - planting a seed in here so all the way
401:08 - at the top i want self dot plant sound
401:12 - dot play
401:14 - that way this one will only be played if
401:16 - we are actually hitting the soil if i
401:19 - run this
401:20 - i first have to create a soil patch and
401:22 - now if i plant some seed
401:26 - not the greatest sound effect but it
401:28 - certainly works
401:30 - and all right with that we have all of
401:31 - the minor sound effects the one last
401:34 - thing we have to do is to play the
401:35 - background music and this could be a
401:37 - really good exercise for you figure out
401:40 - where you could play the background
401:41 - music and import it and play it
401:46 - all of this is going to happen inside of
401:48 - level i guess theoretically you could
401:50 - also play it in main.pi but level.pi is
401:53 - a bit more flexible
401:54 - in here i want to import music so
401:57 - self.music
401:59 - and this we get with pygame.mixer.sound
402:03 - the file name here is called well we
402:06 - have to go to audio first and i want to
402:08 - import music
402:10 - which in this case is an mp3 file
402:14 - what we also have to do to play it is
402:15 - self dodge music dot play and in here
402:19 - loops needs to be -1 so that we play
402:22 - this continuously
402:24 - now for the background music i have been
402:25 - a bit lazy because you probably want to
402:27 - change the volume depending on the day
402:29 - time or play different kinds of music
402:31 - depending on what kind of weather you
402:32 - have but well i just have one kind of
402:35 - background music
402:36 - but this video is getting long enough
402:38 - you can work on this yourself but now if
402:40 - i run this
402:53 - now before i finish the entire thing
402:55 - there are some very minor things i do
402:57 - want to change
402:59 - first of all inside of the player
403:01 - if i minimize everything again so we can
403:04 - see what's going on inside of the input
403:07 - in here i have to clean up this
403:09 - self.toggle shop that's the one i forgot
403:11 - earlier
403:13 - here we go and now this one is done so
403:16 - let me close the entire player
403:18 - besides that in the level
403:21 - i want to set the rain to something
403:23 - greater than seven
403:25 - because the rain really shouldn't happen
403:27 - that often this i also have to update
403:30 - let me minimize all of the methods once
403:33 - more
403:34 - in the
403:35 - reset method this one should be like
403:38 - this
403:39 - finally inside of the sprites in here
403:42 - once again i want to minimize everything
403:44 - and in the tree i created an involved
403:47 - timer and this one simply isn't
403:49 - necessary i just mixed up my notes
403:52 - but now we are done with the entire
403:56 - thing this was literally all we needed
403:58 - and let's make sure this is all still
403:59 - running
404:10 - [Music]
404:16 - all right this is looking really good so
404:19 - well done if you have gotten this part
404:21 - this was a really long tutorial so i
404:24 - hope you enjoyed it and i'll see you
404:25 - around

Cleaned transcript:

what better way to improve your python and pygame skills than by building a clone of stardew valley christian from clear code makes amazing python game tutorials and in this course he will teach you how to build a clone of this popular game in this tutorial we will create a stadio valley style game in python and this is going to have a ton of stuff like farming and foraging we can cut down trees and trade items there's also a day and night cycle and different kinds of weather the entire game was also made entirely so you can expand it yourself speaking of i am using the free version of the sproutland asset pack by cup noodle which is amazing there's also a paid version with more stuff if you want to expand the game yourself although for this video you don't need to spend any money before i start i do want to emphasize that this is not a beginner's tutorial to be able to follow you will need to have a good understanding of pygame if you want an introduction or reminder i would recommend my introduction to pygame and my video on using delta time if you have those two you should have a really solid foundation during the video i will also mention a couple of videos that explain some more advanced topics in detail those can be helpful but you are not going to need them to follow along alternatively i also have a paid course where you learn all of my game by making 4 pretty cool games check this one out if you are interested and sorry about the requirements but if i did this tutorial from scratch it would easily be 20 hours long finally the entire project is inside of one folder and i will be working in the code subfolder i will explain while coding when and how to access elements in here i also saved the progress for every chapter and you can find that on github and with all of that i hope you enjoy alrighty so let's get started and i already have a couple of lines of code ready just to get started let's have a look at those here i have my code and i have main.pi and i have settings.pi both already have quite a bit and i am working in main.pi for now if i execute the code with all of this i can see a black window that doesn't do anything right now but we do have a start and all of the stuff in settings we are going to use later but well for now don't worry about it besides these two lines here those determine the width and the height of our window now if you have a very small or very large monitor you could change these numbers to something else whatever is appropriate for you the rest of the game is going to scale with that at least within reason don't make it 5x5 pixels that would be a weird game and i guess really quick let's go over what we have all the way at the top we are importing pie game and cis and settings pie games should be obvious but since we need all the way down here to close the game properly other than that we are not using it after the imports we are creating a class called game inside of that we have an init and a run method most of the game is going to run inside of the run method in here we have the game loop and this one is checking right now if we are closing the game here and then we are getting delta time and we are updating the game besides that in the init method we are creating a display surface we are creating a clock and we are also initiating pygame so all things considered a very simple class and finally all the way at the end we are checking if we are in the main file then we are creating an object from the class and then we are calling the run method and this run method contains the loop that contains our game so with that we have the main setup although there's one more change that i would like to make and that is if i run the game again in the top left we have a window title and right now it says pygame window which doesn't feel good so i want to change that one and this could be a really good exercise for you what i want you guys to do is to change the title of the window and if you want to code along pause the video now and try to figure this one out yourself after we are creating the display surface we have to call pygame dot display dot set underscore caption and in there we can type in the name in my case i want to name the game sprout land after the asset pack although you could name it whatever you want and if you run out of this now you can see in the top left we have sproutland this feels much better although granted a very small change but all right with that we have our setup now if none of the things i've just talked about make any sense check out my introduction to pygame this one is going to explain all of this in much more detail and if you are lost already the rest of the tutorial is just going to get harder so definitely get ready for it now there is one more thing that we do have to start thinking about because later on the game is going to become quite complex and i want to keep the basic main.pie as clean as possible it shouldn't really do too much as a consequence inside of this while loop i want to run another object and this object actually contains the level let me actually implement it and then you see in a second what i mean basically what i want to do is i want to create a new file and this one i want to save as level dot pi for this level i want to import pi game and from settings import everything and this level is going to be a class so class level and this class level is going to have one method that i'm going to call run this one itself and delta time because we need delta time available inside of our game to make everything frame rate independent and inside of this i want to for now just print run game and this is all we need in main.pi i want to from level import level and inside of the init method of the class i want to create an attribute level that is going to be the level and now inside of my run method of the game before i update the display i want self.level.run that way we are always calling this run method here although don't forget this one needs delta time the one we have gotten here if you don't know what delta time is it's a bit more technical but i've made a whole video on it so check this one out you basically are going to need it to follow along for this video so well it is getting quite complex unfortunately there's no way around it if i run all of this now we can see run game in the bottom left so we are continuously updating this method here and this means we can run the entire game inside of it which is helping considerably to keep the entire game clean and organized and for a project of this size this is really important now before i'm finishing this section there are a couple more things that i do want to do first of all when we are creating this class i want to run a dunder init method and in here first of all i want to create another attribute for the display surface in this one i'm getting with pygame.display.get underscore surface this display surface is the same as this self.screen here and this allows the level to draw straight on the main display that we are going to display to the player which makes organizing the entire thing much easier and let me add comments here to make all of this a bit easier to follow let's call it get the display surface now besides that we need sprite groups and for now i just want to create one attribute that i call all sprites and this is going to be pygame.sprite.group groups are a key feature of pygame and they help us to draw and update any kind of sprite in the game and sprites is what you use to basically do anything in pygame so our player is going to be a sprite any kind of tree or plant is going to be a sprite and none of this works without a group in my case what i want to do inside of run i first of all want self.display surface dot fill with a black color so we don't accidentally see the previous frame after that i want self dot all sprites dot raw and in here we need the surface we want to draw on and in my case i want to draw on the display surface meaning this is what we have to pass in here i can just copy it and paste it in here and besides that i also want self dot or sprites dot update now this method we are not going to use for now but later on this is what updates all of the sprites inside of it like the player for example but now back in main.pie i can run all of this and we cannot see any change and that is because we haven't really made any changes to the logic of the game although if you want to see something you could change this black to something like red and now we have a red background although i want to keep this black and there we go so with that we have a basic setup so let's get started with the player now the player is going to become quite complex so i'm going to do all of this over multiple steps but we do have to get started somewhere so let's create a really basic player here we are back in the code and for the player i want to have a separate python file meaning i'm going to create a new one and save it as player.pie just as before we have to import game and also from settings import everything once we have that i want to create a class layer and this one needs to inherit from dot pygame.sprite.spry because it is going to be a sprite in here we need a dunder init method and this one eventually is going to have a lot of parameters although for now all i want is self then i want a position and then i want the group the sprite is supposed to be part of and the first thing we have to do inside of the indent method is called super and dunder init and in here we have to pass in the group that way as soon as we are creating an instance of this class the object is going to be inside of this group which is super handy besides that we will need self dot image this is what the sprite is going to look like and this needs to be some kind of surface now later on we're going to import a lot of surfaces but for now we don't really have that available as a consequence i'm going to create a plane surface and this i get with pygame dot surface this one is going to need a width and a height and the numbers here don't matter since we are going to change them anyway but let me go with 64 by 32 now this image right now is going to be completely black and since we are putting this on another black surface as we can see in the level we are not going to see anything you change that i want to fill the image with a color let's go with green finally we are going to need a self dot rectangle and this one would take care of the position this rectangle we create with self.image.get underscore rect and in here as the argument we have to pass in where we want to place it and i want to place the center of this rectangle wherever the position is and this position we are getting from the parameters with that we have a very simple player spread class now we just have to use it and this is going to happen inside of level in here i want from player import player to keep everything organized inside of the level i want to create a setup method this one itself as always and in here we are going to create an attribute called self dot player and this is going to be an instance of the class player the player we have created here and this player is going to need two arguments the position and the group so let me copy both of them and paste them in here for now the position is going to be completely random but we are going to need a tuple with an x and a y position in my case let's go with 640 and 360 the middle of the screen besides that we need a group and the group here is self dot or sprites a group we have created earlier on and now we're just passing it in here we are nearly done the last thing that we have to do is to actually call the setup method and this happens inside of the init method so in here self.setup and now we should be able to see something so back in main.pi i am going to run my code and we can see we have a green thing although i realized i confused the width and the height so back in my player this should be 32 for the width and 64 for the height that is looking much better so now we can see something but we cannot interact with anything which means inside of the player i want to get some kind of input and don't forget self that one is really important now to get all of the available keys that are being pressed we need pygame dot key dot get underscore rest this one is returning a list with all of the keys that are potentially being pressed and this i want to save in a variable let me call it keys and this list i can access with for example via keys and then square brackets and now pi game has a couple of predefined names for example for the up arrow we need k up and if that is the case for now let me just print up all that is left to do now is to figure out when to call this input method here and for that we will need an update method then itself and delta time how this is going to work is inside of level we have our all spreads group and this all spreads group has a draw and an update method the update method is the really important part right now because this one calls the update method on all of the children meaning effectively what is going to happen is that this update method here calls this update method as a consequence for the level or the group more specifically we have to pass in delta time as well the delta time we get from the parameters here and this delta time we get all the way at the beginning inside of main in just a bit this is actually going to become useful but now inside of the player all we have to do is call self dot input and this should be working so now if i go back to my main.pi run all of this and now if i press up in the bottom left you can see up which means i get some input all we have to do now is to cover the other directions and then we should be good to go and the usual system works like this if we're not pressing up then i want to check if keys and pygame dot k underscore down so we are pressing the down button and if that is the case i want to print down for now and with that we have up and down besides that let me copy all of this i also want to check for right and i want to check for left and then obviously the text has to be right and it should be left and with that if i run main.pi we get left right up and down all of the four directions what we now have to figure out is how to translate all of this into actual movement and for that we need a few more attributes let me put it all the way in the net method with a comment let's call it movement attributes and the ones before let's call them general setup for the movement i want to have first of all self.direction and this is going to be a vector so pygame.math.vector2 and this vector is going to have an x and a y part depending in which way the player should move so for example if x is 1 then the player should move to the right and by default this vector 2 is supposed to be empty so it should have 0 and 0. and this is the default value so i can just leave it like this and all that we are going to do inside of here is change this direction so basically inside of keys for up i want to set self.direction dot y two minus one this i can now copy and do it four down this one is just going to be one for right we are targeting x and this one is going to be positive one and left is going to be x being negative one and with that we have the four different directions although now we do have a problem and let me isolate the vertical directions just to illustrate what the problem here is right now later on we are moving the player in whatever this direction is pointing at so for example if y is negative 1 we want to move up and this is what we are getting in here the problem is in this setup right now once we press up once direction.y is always going to be negative one even if we release the button and this is obviously not great because once you move up once the player never stops moving up which well we have to change this fortunately though is very easy to change because all we have to do is add another else statement and let me copy the direction here because now the direction should be zero which means now if we're pressing up the direction of y is negative one if we are pressing down direction is positive one and if we are pressing neither then direction.y is zero so we're not moving in the vertical axis at all and that is all we need here so i can remove the white space and for the horizontal axis i have to do the same thing so in here self.direction.x is going to be zero and with that we have our basic direction what i can do now at the end of all of this i can print self.direction and now in main.pi if i run all of this and i can have the different directions inside of my vector this is working really well there are two more attributes that we need to make all of this work the first one i always call self.pos and this is also going to be a vector so let me copy this one here and now we have another vector now if you are familiar with pygame you probably always store the position inside of the rectangle however the problem with this approach is that a rectangle always stores the position as an integer but if we want to use delta time so this one here to move everything in a frame rate independent way we are very often getting floating point values which wouldn't work here at all as a consequence i am going to store the position inside of a vector and this is going to be what self.pos is for and this is also what we are going to move and then at the end we are going to update the rectangle depending on where the position is all of that is going to make much more sense later on but for now for the starting position of self.pause i want self.rect.center finally i want self.speed and this is just going to be how fast the player is i put this at 200 but just choose whatever you think looks good and with that i can get rid of this print statement here and add another function or one method and this one is going to be move and here we need self and delta time and essentially what i want to do in here i want to move myself.pause and how i want to move it is by getting myself dot direction multiplied by self dot speed multiplied by delta time and after i have done that i want to set self.direct.center to self.poss and now after the input if i call self.move with deltatime we should be having a moving player so let's try and run main.pi and i can move around this is working really well and this is also frame rate independent and this is why this entire system is really important by using delta time again check out my video on it if you want more detail it does get a bit more technical but if you didn't do this and change the frame rate for example in this self.tick you could set the frame rate for example with 60 or you could set a thousand or you could set 10. with this setup the frame rate doesn't matter but if you didn't do it then the movement would be faster or slower depending on how the frame rate is which would be a massive problem all right in this case we have our basic movement now there's one more important thing that we have to do and that is inside of this move method if i run the code again if i move left and right or up and down i have one speed however if i move in the diagonal direction like this the player moves noticeably faster and that is a problem you can see it pretty well here now why is that happening and let me draw on the screen to explain if the player is only moving in one direction let's say the player is moving to the right like this at a speed of 1. that's not the actual speed but 1 is a very simple number to use and if we only move up we are also going to have a speed of 1. this is what we're getting from direction the problem now is if we're combining these two numbers we are getting a different kind of length so let me rearrange the drawing a tiny bit and let's say i want to move by one unit to the right and by one unit up then the actual distance i am going to move is going to look like this and the distance of this length here is what we are getting from pythagoras theorem it is 1 square plus 1 square and then we are taking the square root of all of this the result in this case would be something like 1.4 and this result means that if we move diagonally the player would move about 40 faster than if we just move left or right or up or down which obviously is going to be a problem so we have to adjust for that and the way you adjust for that is called normalizing a vector and normalizing a vector basically just means that well we're making sure the direction of the vector is always one and this is an inbuilt function into pygame so you don't have to think about it too much all we have to do is get self.direction and we have to assign it to self.direction.normalize don't forget to call it and we are nearly done the last problem we have is that we can only normalize a vector if the vector has a length and this should make sense i guess to illustrate what this one is doing is let's say we have a vector of 1 and 1. what normalize would now do is convert these two numbers so that the vector overall has a length of 1 which in this case would get us the numbers something like 0.7 and 0.7 i can actually demonstrate this a bit better so let me print a vector after we are normalizing it so now i want to print self.direction and run all of this again and we are already getting an error that we cannot normalize a vector with the length of zero and this should make sense for normalized to work pygame needs to know in what direction the vector is pointing but if the vector is 0 and 0 it doesn't point in any direction so normalize wouldn't work but this we can fix quite easily all we have to do is check if the vector has any kind of length and this we get with self dot direction dot magnitude don't forget to call it and if this is greater than zero only then do we want to do all of this and now let's try it again if i move left and right we have a direction of one if i move up and down it is one as well but now if i move diagonally it's 0.7 or negative 0.7 and this is important to keep the speed constant and all right i hope that makes sense there is just one more thing that i want to do before we finish off this part and that is later on i have to work with these two lines more to implement the collision mechanics and for that i have to separate these two lines into the horizontal movement and into the vertical movement so first of all i don't want to update the entire position vector i only want to update for the horizontal part the x dimension so for example instead of updating position by itself i only want to update x and as a consequence we have to update the other vector as well and update the rectangle 2 and this could be a really good exercise for you to finish off this section so if you want to code along pause the video now and try to update the vector and the rectangle and see how far you get for position.x we don't want to get the entire direction vector instead i only want to get x of the direction self.speed and delta time can remain the same then for the rectangle i don't want to set the center i want to set the center x and then this should be self.pos.x and with that we have the horizontal movement now i have to copy all of this give me some white space and paste it in here and now i basically have to switch all of these x's to a y and there we go the result in terms of if i run main.pi again we are not going to see a difference but later on for the collision we do want to have control over the horizontal and the vertical movement individually but this i will talk about in much more detail later on for now we have a pretty solid setup in this section we're going to import the player graphics and there's quite a lot of stuff that we have to import let me actually open the folder here we go and inside of graphics we have the character and then here we have all of the different animations for example down is the down movement and here we have the player walking down and well we have to import all of these different animations now you could do all of this by hand and it would be possible but not really practical because there are way too many animations fortunately you don't have to you can do all of this with python to automate the entire process so let's have a look at all of this here we are back in the code and i want to work inside of the player and let me minimize all of the methods so things are a bit easier to read for the import i want to add another method let's call it import assets this one itself and nothing else and inside of here i basically want to create a dictionary called self dot animations and this dictionary is going to have a ton of key value pairs for example one key would be up and this would be up walking and then the value associated with this key would be a list with a bunch of surfaces that correspond to the up movement now for that i have this is something you do have to copy from the notes this is looking like this here are all of the different states the player could be having we have up down left and right these are the movement ones then we have all of those with idle then with the whole the x and the water these are all of the animations and these also correspond if i open the folder again here we have all of the different states and therefore the name corresponds with the key of this dictionary so we have down here and we have down here this is really important because what this allows us to do is i can do for animation in self dot animations dot ease don't forget to call it and in here first of all i'm going to need a full path and the full path is basically i have to go up one folder then i have to go to graphics and then i have to go to character and don't forget another forward slash and then i have to add the animation because the animation name is also the folder name let me demonstrate what this means here is the file setup again and right now we are working inside of the player and from there we have to go up one folder to the project then we go to graphics then we go to character and now we have to select all of these different folders which is what we're doing with this line here along with the for loop and now essentially all i want to do is get myself.animations dictionary target one of the key value pairs and then i have to actually import all of the surfaces now this i'm going to do in a separate folder that i called import folder and this one is going to need the full path so it knows what to import and this import folder i generally put in a separate file because it's quite a handy one to reuse so let me create a new file that i want to save as support dot pi and in here we need a function called import folder and this one needs a path as a parameter but nothing else and this is what the player so inside of the player i want from support import everything so now we have to create this file here and let me add a bit of white space and now we can work on it first of all i want to create what i always call a surface list and this by default is going to be empty and in here we're going to store all of the surfaces and this is also what we are going to return at the end of this function so now we just have to figure out how to actually access the folder and for that we need a specific module is we have to import but it comes with python we need from os import walk and walk allows you to walk through different folders let me actually demonstrate what it does so for let's call it folder in walk and then we have to pass in the path and that is the path we are getting from the parameters and we're just passing it through and i guess in here let me just print what we get the folder and now since we're calling this inside of the player we just need to make sure inside of the init method all the way at the beginning this is really important i want to self dot import assets and this has to be all the way at the top of the indent method because later on when we create the image we need this self animations dictionary but now if i run out of this we are getting a ton of different things at the bottom and this is what work does it basically returns a list with all of the contents of the folder for example the first folder here is the up folder this one doesn't have any subfolders and inside of this folder we have a couple of files they are always called 0 1 2 and 3. they all have the same name but they are different files and this is what we want to use to import things now keep in mind a really important thing here is that all of these are just names we're not actually importing anything for pygame we are just going through a folder and looking at all of the file names but this is something we can definitely work with now first of all since this walk is returning a couple of things that we don't need we can unpack this quite a bit so the first one we get is the folder name the second thing we get is the always a list of subfolders and the final thing we get is the actual content let's call it image files now folder name and subfolder i just do not care about so i'm going to replace the folder name and the subfolder to underscores that way i indicate that i don't care about them so now let me print the image files and let's run main.pi again and now all i get is a list with names of images and this is what i really care about once i have that i need another for loop because remember image files is another list so i need four let's call it image in img files and now let's keep on printing things if i now print the image and run this again i am always getting the name of the image for each file now this right now is a bit confusing because the name of each individual image is fairly repetitive but these are all different files in different folders so all we have to do now is to convert all of this into a full path so now i have to do three things to finish off this function first of all i need a full path and this full path is going to be the path we already have that's a path to the folder and then we have to attach the name of the image itself after we have that i can create an image surface so this is the inbuilt pie game surface that we actually want to create and once we have that surface i want to get my surface list and append wow that is misspelled i want to append the image surface meaning we have to get the full path and the image surface and this i think could be a really good exercise for you try to combine the path to the folder and the image to get the full path and then for the image surface you have to import pygame and then use the full path to import one specific surface so pause the video now and try to figure this one out yourself ready for default path i want to get the path itself and this is getting me my folder and to that i want to add the image remember the image is just the name of the file not the actual image now this would almost work let me actually comment out these other two lines and let me print the full path you might already guess what the problem with this here is if i run this we have the name of the folder let me do this all the way at the top so up here for example is the name of the folder and then 0.png is the name of the file this is a really good start but we do need a slash to separate the two meaning in here besides the image we have to add e slash and now if i run this again we have the whole path towards this one specific image so i can remove the print statement and now i can actually use this full path to import an image as a surface now for that to work obviously i need pi game and what i want to do in here is pygame.image.load and now i need the full path although important here you also have to add convert alpha that way we are converting this image to something that's easier to work with in pi game as a consequence our code is going to run much faster now i can uncomment the append line and we should be good to go back in my player after i've run this for loop i want to print self dot animations and let's see what we get that is looking pretty good we are getting a dictionary with a key and a ton of surfaces as the values now we don't know what each individual surface looks like but i'm pretty confident that this is going to work all we have to do now if i minimize this method here is when we are creating the image i have to pick one of these surfaces now for that we need a few more attributes to make all of this work efficiently and the way i approach this is i add two more attributes the first is self.status and this could for example be up or it could be down or it could be something like down x if you want the downwards x animation but for now let's keep to down actually down idle is a good one i suppose besides that we need what i call the frame index and this by default is going to be 0. now the frame index is going to make much more sense once we are doing the animations in the next bit for now don't worry too much about it how we are going to use all of this is instead of creating a plain surface i want to get myself dot animations this is a dictionary with key value pairs where each key is going to be accessed via the status meaning inside of this i want to access the key value pairs with self dot status and this list i am accessing with self dot frame index and now i can get rid of the image fill and we should be seeing the player let's try and there we go we have one frame of the player now since we don't have animations yet this doesn't look too impressive but well what you can do now for example this could be down x and let's try this one there we have the first frame of the x animation this could also be let's say left water and then we get this kind of animation here or well it's not an animation it's just a surface but we do have a very good start in this section we're going to animate the player now for that we are going to need quite a bit of logic so let's go through it one by one here we are back in the code and i want to keep on working in the player now for the animations to work there are two things we need first of all inside of the self.animations dictionary we have to go through the list of surfaces because they are the animation and this is actually a fairly simple method this we can start with in just a second the much more complicated bit is getting the self.status so we have to know if the player is moving or idling or using the x or the water or the hoe and this is going to determine what animations we need getting the status is quite a bit more complicated but let's start with the actual animation that one is actually quite simple i first of all have to create another method let's call it animate this one itself and it also needs delta time and basically what i want to do in here i want to get myself dot frame index and increase it in my case i want before multiplied by delta time and then after that i'm going to get myself dot image so what the sprite actually looks like and i set this to self dot animations i get myself dot status and then i get myself dot frame index the way you have to think about it let me open the folder again and let's say for down inside of down we have four different images zero one two and three and we are using self.frame index to go through them so we have first zero then one then two and then three and all i am really doing is i am increasing self.frame index to pick up all of these numbers that's literally all that's happening here however there are two major problems here number one is that we can only ever take the index with an integer but this operation here is going to return a floating point number as a consequence this self.frame index has to be converted to an integer which is very easily done besides that the other problem is that each animation has a finite amount of frames for example down has four frames inside however this line here is going to be very quickly on a higher number than four so we have to make sure that we are always looping through this and this we are doing in an if statement if self dot frame index is greater or equal than the length of self dot animations and in here once again i need self dot status if that is the case i want to set self dot frame index back to zero so what this one does if i open the folder again and let me try to get everything on the screen something like this looks good we are basically starting with self.frame index being zero which is getting us this first image here after that we are increasing the frame index by a certain number and then down here we're getting the integer of that number so at some point this is going to be one this is going to be two and this is going to be three after that we're going to end up with a number larger than 3. so we are going to be somewhere down here which would be causing an error and for that we have this line here this one is making sure that this doesn't happen and instead we're moving back to zero and with that we have proper animations all that's left to do now is to actually call it so inside of update all the way at the end i want self dot animate don't forget to pass in delta time in here and now if i run this now the watering animation isn't great but the animation for down does look much better so there we go this is down movement if i just move down this is already looking pretty good and what i actually want to start with is down idle if i run this now there we go we have the player idling and looking straight at us this is looking really good so this was the easy bit now we have animations the one thing we now have to figure out is how to set this self.status to capture all of the different animation states and there are quite a few different states we have to account for all of these the really easy ones we can get in input because in here if we are for example pressing up we know that the player is moving up which means in this we can set self dot status to something like up then i can copy this and change this to down copy it again and change it to right and copy it one more time and change it to left and with that we already have the walking directions so now if i start all of this i can move left right up and down and we already have some very basic animations that look pretty good really good start besides that let me minimize input i want to check if the player is idling so if we go for example from moving up and we stop moving then i want to switch to up idle which in practice means i have to add underscore idle to the status of the player and to do all of that i want to create another method let's put it below input in here i want to get stat test needs self and nothing else and in here i want to check if the player is not moving then i want to add underscore idle to the status and again if you want to code along this could be a really good exercise for you so try to figure this one out yourself and see how far you get if you want a tip this should be doable in two lines of code first of all we have to figure out if the player is moving or not and this we have actually already done this happened inside of move because we know if self.direction.magnitude so the length of the direction vector if that is zero we are not moving so i can just copy it minimize the move method and now if the magnitude is equal to zero then i know the player is not going to move which is covering the first bit let me put it at the top here besides that i have to add underscore idle to the status which in a very simplified way would just be self.status plus equal underscore idle and don't forget this is supposed to be a string all we are really doing for the status here is we are manipulating different strings to represent the status of the player that's literally all it is now this is a good start but it would cause a problem really really quick let me actually demonstrate so after i'm getting the input and before i am moving or animating i want to get self.get status and now if i run main.pi we're getting an error that we have a key down idle and idle and basically what happened here is that if the player is not moving python keeps on adding underscore idle towards the status we're not stopping at one we're adding more and more and that way we're getting an error so we have to make sure that we only ever have a single underscore idle in the status which we can get very easily all we need is self dot status dot split and i want to split wherever we have an underscore and then pick the index 0. this one here is going to return a list and the first item of this list is always going to be the status so this would be up down left right and so on and only to that i want to add the underscore idle that way we will only ever have a single idle inside of any kind of status and this i want to assign i don't want to add it to the status and now the player is idling and if i move downwards we are walking this also works with up it works with left it works with right and this is looking really good so now we have some basic animations that are definitely improving already so let me get rid of the comments here and we have the first bit covered the other bit we need is the tool use i guess let me add general comments here to make this a bit easier to follow let's call this the movement actually the idle is better now for the tool used the code is getting quite a bit more complex because besides get status we also have to add the input and we have to be able to select different kinds of tools so let's do all of this in a separate section so let's work on the tools for this to work we need a few parts that interconnect quite a bit so well let's jump right in and let's have a look at all of this once again here i have main.pi and i want to keep on working inside of player and specifically i want to work inside of the init method and in here i want to add another section let me call this one tools and for now i want to add one more attribute that i call selected pool and this could for example be an x it could be a hoe or it could be water short for watering can i guess for now let's stick with the x that one is really easy to see and for now we don't have any way in the game to change the tool that's going to be in the next section because i do want to keep things a bit more organized but well now that we have the selected tool i want to go to my input and in here besides the directions let me actually add a comment directions i want to add another section and let me call this one tool use and in here first of all i want to check if we are pressing a certain key which i get with if keys and then pygame dot in my case for the tool i have k space now basically what i want to do in here is if this condition is true i want to run a timer for the tool use so for example if the player is pressing space then we should have half a second of tool use being activated in some sort of timer and if the timer is active inside of get status we are always adding underscore x to the status now for that we need a timer and this is not inbuilt into pygame so we have to make it ourself and this i'm doing in a separate file and this one i want to save as timer dot pi and here as always we have to import pi game after we have that i want to create a class timer and this one needs it under init method in here we need self we need a duration and then we need a function that by default is going to be none the duration should make sense this one is really simple it's just how long the timer is going to be the function is going to be if we want to execute some code once the timer has run out something we are going to see in just a second but for now don't worry too much about it inside of this i want to create some attributes so duration is going to be duration and self dot funk is going to be funk so we're just capturing the parameters besides that i want to have two more i want to have self dot start underscore time this one is zero and then i want to have self dot active and this by default is going to be false and for this timer we have a couple of methods we have activate we have deactivate and we have up date and all three will need self but no other parameter besides that and let me go through how the timer is going to work we always start at some kind of start time 0 by default and this is what we are getting here after we have declared that we will continuously check the time which means we are checking the time here here here here here here and so on continuously throughout and besides that we also have a duration and the duration could for example be let me put it here at 300 milliseconds and now all we are really going to do is we are continuously checking if these red dots are before or after the 300 meaning once that is the case we want to run some code so let's implement that first of all for activate this one is very simple all i want to do in here is if the timer is active i want to set active to true and besides that i also want to set self.starttime to pygame.time.get underscore ticks this is really important because this starting time here doesn't necessarily have to be zero we could very well start a timer at some point in our game so this zero might be something like 1240 which means we started a timer about one second into the game we're doing all of this in milliseconds and if the timer has a duration of 300 then this number here would be 1540. so these numbers are all relative it's really important for all of this to work now besides that if i want to deactivate the timer i want to set self.active to false and just to be sure self.starttime is going to be 0. finally inside of update the actual timer happens and this is some horrible spelling there we go first of all inside of update i want to have my current time and this i get with pygame.time.get underscore ticks the same line we have used up here the difference now is that this update method will be called continuously which means that this program.time.get will always get our current time and basically what i want to check is if my current time minus my self dot start time is greater or equal than self dot do ration for example if my current time is something like 1500 my start time is something like 1000 and my duration is something like 300 then the result here would be 500 is greater or equal than 300 which would be true so our timer should have run out now if that is the case first of all i want to self dot deactivate the timer i want to run all of this here besides that in case we have defined a function we want to run if the timer has run out i want to check if self.func so if a function exists and if that is the case i want to call self.bank and with that we have a timer class that we can use inside of the player now for that first of all we have to import it which we do with from timer import timer and with that covered i want to add another section let me put it before the tools and this i'm going to call timers in here i want to create a dictionary that i call timers in here we have a couple of key value pairs the key is just the name of the timer let's call this one tool use and now i can create a timer and let's say for the tool use i want to have a duration of 350 milliseconds and once this has run out i want to call a function that i called self.use underscore tool really important here you do not want to call this function you just want to pass it into this class and this one doesn't exist right now so we do have to create it let me put it actually right at the top here so things are easier to see so use tool and this one needs self and nothing else now this use tool for now is not going to do anything all i want to do is print let's say self dot selected tool later on this one is going to do quite a bit more but for now i just want to minimize it more importantly for now inside of the input i want to get myself dot timers and in here the tool use timer the one we created just a second ago and this timer i want to activate and now this we can use inside of get status and really all i want to do is if self.timers and tool use if this one is active then for now let me print tool is being used and let's try if this one is working so now if i press space we get tool is being used so something is happening but this is looking weird and it never stops so we do have to make some adjustments here now first of all the one thing i do want to change is the player should not be able to move once we are using a tool which means once this timer is active the player shouldn't be allowed to do anything else and for that i want to indent all of this one level and i want to have an if statement if not self dot timers and tool use if this one is active so only if we are not using a tool the player is allowed to move around and to use a tool we couldn't use a tool if the player is already using a tool that should make sense now besides that i also want to set self.direction to an empty vector so pygame.math.vector2 the reason is think of if the player is moving to the right and then starts using a tool here if we didn't add this line here the player would just keep on moving to the right while using the tool which would be very strange and we wouldn't be able to stop it because remember the player is not allowed any kind of input while we are using a tool so we have to stop the player otherwise we would get some weird results but once we have that inside of get status all i really want to do is update my self.status so that i have a string that could for example be right and x so x is going to be what we are getting from our selected tool could also be whole or could be water but for now i want to keep it with x meaning this is going to work kind of like this line here except now we're adding a different word after the underscore which means this could be a really good exercise for you copy this line here and adapt it so you are incorporating the selected tool let me minimize the input so we can see it a bit better if the timer is active you are supposed to have the status so up left down or right plus an underscore plus the x all right all you have to do is first of all copy this line here or this part of the line so we just have up left down or right by itself and to that i want to add an underscore and then i want to add self dot selected tool and with that we should be good to go let's try this one now and now if i press space we have something so we do have an animation the problem is the animation never stops which i guess is a start but we do have to work on it the main reason why this happens is because we don't actually update these timers what i forgot to do is to call this update method continuously and to do that let's put all of this in a separate method although it's going to be a very short one let's call it update timers this one itself and nothing else as always and then here all i want to do is for timer in self.timers.values because remember we have self.timers as an attribute this one is a dictionary and then the key is the name and the value is the actual timer and this is what we are getting here and all i want to do is call timer.update and now inside of the update method of the player i want self dot update timers and now let's try this again so now we have a animation that is very inconsistent though and the reason why that is happening is let me go back to input here we have to add one more line and that line is going to be self dot frame index is going to be 0. the reason we need that is let's say we have our frame index this could be 0 1 2 or 3. and essentially what we are doing is we always go from one to the other to the other and then we are going back to the start when we are pressing space so this line here we want to play a new animation the problem is frame index doesn't know that so when we start this animation we might already be on frame index being two and as a consequence we are playing not the first frame but we are playing one frame that is already maybe at the end of the animation which would be looking very strange and if we add frame index being 0 this is being fixed we always start the animation from the start so now let's try this again and there we go we have a proper x animation this one looking quite nice what you could also do is replace this x with a hole and now we have the hole and you could also change it with water and if i do that we have the watering can so with that we have our different tools although we are not able to change between different tools and we also can't see which tool is currently being selected i guess let's work on that in the next major part in this part we are going to work on switching between the different tools and since we already have timers there isn't actually that much to do so let's jump right in and let's have a look at all of this back in the code i want to keep on working inside of player.pi and now first of all i want to check if the player is pressing a button to change the tool this happens inside of input in here i want to add another section let's call it change tool and for this one i want to check my keys again and then here pygame dot k underscore q so we are pressing the q button on the keyboard i couldn't really think of a better one if you can't find a better key just go with that if that is the case i want to do something now what that something is going to be is going to be determined inside of the init method so right now the selected tool is always going to be one specific string but i want to make this a bit more flexible and what i want is first of all i want to have an attribute that is called tools and in here we have the whole we have the axe and we have water and besides that i want to have a seat index and this by default is going to be zero and then when we select a tool i am not going to get a string instead i want to have self.tools and then self dot this shouldn't be seed this should be tool index sorry about that so i want self.tool index and right now since our tool index is zero we are picking the first element from this list and what i basically want to do inside of this if statement here is i want to self dot tool index plus equal one and after we have that i want to update myself dot selected tool and this is just going to be self dot tools and then self dot tool index now this is fine in theory but in practice this is going to break let's actually try so may not pi i want to run it and now if i press q we are getting list index is out of range the reason is to us pressing q once might just be pressing q once to pygame it looks like we are pressing q for a certain amount of time and it keeps on adding this one to the tool index continuously i can actually visualize this that is much better than explaining it so if i print the tool index and run this again and if i now press q we are getting one two and three and then we are running out of numbers and i should get rid of the print statement let me look for it really quick let me comment out this print statement here and let me just add a pass in here that way it's a bit easier to see what's going on if i now press q we're getting one two and three and then we're getting an error because we are trying to use these numbers for indexing and this list doesn't have that many indexes as a consequence we are getting an error and the problem is that pygame tries to add more and more numbers the way around that is we need a timer that after every time we are pressing the button we want to wait a couple of milliseconds now fortunately we already have a very good system to work with timers so i want to create another timer and this one i call tool switch and this one is going to be another timer and this one has a duration of 200 milliseconds there's no second argument because we don't really want to call a function after this one is over we just care if this timer is active or not once we have that and not self thought timers and in here i want tool switch dot active the player should only be able to change the tool if we are pressing q and if the tool switch timer is not active inside of the if statement the first thing that we are going to do is self dot timers and tool switch and this timer i want to activate that way we are only ever adding a single number to this tool index and we're not doing it continuously so now let's try this again if i press q we get 1 we get 2 now we get 3 and we're getting an error this error we're getting because even though now i am only adding a single number we can still add as many numbers as we want but what i want to do instead is that if we are exceeding the length of this list i want to set the tool index back to zero so if tool index is greater than length of tools then i want to set the tool index to zero and this could be a really good exercise for you so if you want to code along pause the video now and try to figure this one out yourself this should be doable on a single line of code although two would also be doable alrighty basically all i want to do is i want to set myself dot tool index and now i want to get self.tool index by itself but this only if a certain condition is true and that condition is self dot tool index is smaller than the length of self dot tools and if that is not the case so else i want to set tool index to zero and now let's try this again now i can press q we get 1 2 0 1 2 and so on and i can never go beyond the length of self.tools and now we already have all of the tools because remember we are updating our selected tool and this is what we're using inside of the status so we don't have to make any more changes this is all we need so with that we are able to change our tool it wasn't actually so bad or at least i hope this wasn't too difficult now while we are here we can go in two different directions now we can either work on the overlay or we can work on the seeds now i think it's best to start with the seeds because the seeds work basically in the same way as the tools do and once we have that we can create the entire overlay in one go so let's do the seats right now and this is going to be started inside of the dunder emit method right below tools and here i want to have my seeds and for the seeds i want to have selfdoubt seeds and in here we only have two we have corn and we have tomato then we have self.seed index and this by default is going to be zero and then we have self dot selected underscore seed and this is going to be self dot seed index we are basically doing the same thing we have done for the tools except now we are storing all of this in different attributes which means now the tool use and the change tool are going to be very similar as well we have a seat use and we have a change seat part and those are going to be very similar compared those two as a consequence this could also be a really good challenge so try to copy those two to update the seed if you want to start if the player is pressing ctrl or left control then i want to use a seat and if the player is pressing e then i want to change the seat so pause the video now and see if you can figure this one out and remember here you are going to need some more timers all right let's try it together now first of all i need two more timers because i have a tool use i have a tool switch besides that let me actually duplicate both of those i want to have a seat use and a seat switch and for the seat use i want to have a method called use seat and you could change numbers here i really don't care about it now first of all i have to create another method just like use tool i need use underscore seed needs self and nothing else and for now let me add pass in here then i can minimize the function and now we can work on duplicating these two lines and we are very much duplicating them so let me copy and paste things first of all if keys and now we are checking k underscore and the name for the left control button is l c t r l short for left control if that is the case i want to activate my seed use timer and the other two lines i want to keep as they are after that i want to copy the if statement for change tool and this one is going to be k e and not timer's seat switch if that is the case i want to activate my seat switch timer and now the index here is going to be for the seat so i'm basically replacing tool with seed and that is all we are going to need in here now unfortunately there's no animation for the seed so instead what i want to do is i just want to print let's say for left control use seed and then for change seed i want to print self dot selected seed so we can tell what's going on and now let's try and we're getting an error that i made a typo somewhere so inside of the indent method this method here should be used not used seed so now let's try this again and there we go if i press left ctrl we get use seed and if i press e we get either corn or tomato so this is working really well and with all of that we have a ton of different inputs for the player without too much work actually so let me remove the print statements and now i can minimize the input this one is getting quite chunky okay i'm quite happy with this section so in the next section we are going to work on the overlay so we can tell what's going on in this section we're going to create the overlay which honestly isn't all that difficult all we essentially are going to do is put some images on top of the entire game and then those images are going to change depending on what the player has selected both for the tool and for the seats so let's jump right in once more i have main.pi open and i want to create a new python file that i'm going to save as overlay dot pi in here i want to import pi game and also i need from settings import everything and now i want to create a class called overlay there is no need for inheritance and i do need a dunder init method we need self as always and now we also need the player because the overlay needs to know what the player currently has selected inside of that i want to have a general setup in here we need two things first of all i need self dot display surface that is the same thing we have done inside of the level this way we can draw straight on the display surface and we can keep all of this inside of the overlay class all we need here is pygame dot display dot get underscore surface besides that i want to start a player in an attribute so self dot player is going to be player besides that i need to do some imports because in here i need self.tools and self dot seeds and those are not the same seeds and tools that the player has instead let me rename it actually these are all surfaces more specifically they are dictionaries with key value pairs for example one key for the tools could be x and then the value would be a surface of an x now for that we have to import a couple of images let me show you what we are going to import actually here is the project folder i want to look at graphics and inside there we have overlay inside of that we have x corn ho tomato and water and this is what we want to import now here you could import everything manually but once again that's not really a pleasant way to work in well any programming language so i'm going to use dictionary comprehension how that is going to work for the tool surfaces i want to have a tool and this is going to be the key and then i want to have a surface as the value and this i want to do for tool in layer dot tools which means inside of player i want to look at all of these tools and from this data i want to create a key value pair and the tool can actually remain the same so if we leave it like this the tool or the key would be hoe x or water which is totally fine the one thing we have to change is the surface what i want to do in here is pygame.image.load and inside of that we need an f string now to keep things a bit shorter i want to store the path separately so let me call it path actually let's call it overlay path that makes a bit more sense and all this is is a string we go up one folder we go to graphics and then we go to overlay and don't forget the final forward slash and this i want to use inside of this f string so overlay path after that i want to look at the tool so the tool could either be x whole water or could be one of the seeds and this is also how each of the files here are named so this is very handy finally one important thing don't forget we are looking at png files also really important you want to convert alpha all of this which makes all of this fairly long but very easy to work with and once i have that i can copy the entire thing and paste it in here and all i really have to do is to replace tool with seed make sure you call this player.seats and then this tool should also be seed but other than that we should be good to go let me actually print tool surface and seeds surface just to make sure that this is working oh actually we have to create the object from the class first of all and this happens inside of level so in level i want from overlay import overlay and now when we are creating everything i want to create self dot overlay and this is going to be the overlay class and in here don't forget we have to pass in self dot player now for that to work you have to create this overlay after the setup method because inside of setup we are creating the player and now once we have that let's run main.pi and we are getting an error the name tool surface is not defined let's have a look ah i forgot self here now let's try this again and there we go we're getting dictionaries with key value pairs that all look pretty good well i'm very happy with this so now we have access to the player and we have all of the surfaces that we do need all i have to do now is to create another method and let's call this one display in here we need self and nothing else and now i want to show the tools and i want to show the seats and for this one first of all i need the tool surface because right now we have a dictionary with key value pairs but what we want is one specific surface we have to select one surface from this dictionary and this we get with self dot tools surfaces and what i want to select from here is self dot player dot selected tool remember here the selected tool could either be x it could be whole or could be water and this is also what we're using as a key inside of tool surface and let's actually try so i want to display this tool and this i get with self.displaysurface.lit and here i need a surface which is my tool surface and for now i'm going to place this at position 0 and 0. with that covered i have to make sure i actually call the display method of overlay and this happens after we are drawing all of the sprites you could just run this line all the way at the end of the run method so in here self.overlay.display and now let's try and now in the top left i can see my selected tool and if i change my selected tool this graphic updates as well so this is very nice the problem is it shouldn't be in the top left and for that we have to update these numbers here or to have a bit more control i want to create a tool rectangle and this one we get with tool surface dot get underscore rect and in here since i want the tool to be in the bottom left i want to place the mid bottom and the position here i am storing in my settings because in there i have overlay positions that way it's a bit easier to adjust all of the settings later on there are a lot more similar dictionaries in here as well so these are the numbers i do want to use which is quite simple all i have to do is i have to get my overlay positions let me just double check if i spell this correctly actually let me copy all of this and paste it in here that looks pretty good and in here i want to get my tool and now when i am using the blit method i want to use my tool rectangle for the positioning and now let's run this again and this is looking really good and with that all we have to do now is to copy all of this for the seeds and i think this could be a really good exercise for you basically what you want to do is copy all of this except now it should be for the seeds so pause the video now and if you want to follow along try this one yourself just as before i want to create a seed surface and this i get with self dot seed surfaces and in here self dot player dot selected underscore siege after i have that for the positioning i want to get a seed underscore rectangle and this i get with my seed surface this should not have an s and get underscore rect once again i want to place the mid bottom and the position here i can copy it from the tools i want to get my overlay positions and get the key seat that is going to be this one here finally all i have to do is self dot display surface dot lit and i want to have my seed surface and then my seed rectangle and with that let's run main.pi and we are getting an error that i forgot the square brackets here now let's try this again and there we go now on the bottom left we have the seats and the tools and we can switch between them this is working really well and is surprisingly satisfying all right cool with that we have the overlay that was all that was needed now that we have the player we can start working on the camera and the floor those two kind of have to come together because without the floor we wouldn't see what the camera is doing and without the camera we wouldn't be able to see what the floor is looking like in total and i know i am repeating myself a lot but for the camera there is a whole set of logic i will go over the basics but i have made a whole video on cameras in detail in pygame so check this one out if you want to go into much more detail once again here i have the code and before i do anything else i want to close a couple of files we don't need overlay anymore and we don't need the timer.pi anymore those two are basically finished and well we don't have to worry about them and i do want to keep things a bit more organized besides that the level should be right next to main.pi because those two files are the most important ones and inside level.pi i want to create the camera this is going to be a separate class and let me call it camera group and this one has to inherit from pygame.sprite.group basically what this one is going to do or how this one is going to work instead of putting all of the sprites into a normal pie game group we're going to create a special kind of group and via this group we're going to get the camera for that to work though first of all we have to initiate the group by itself and this one itself and nothing else and in here we need the super dunder init method so that the group works by itself now once we have that i can replace the group we created like an hour ago with the camera group and so far since we have basically created another group there shouldn't be any difference meaning if i run main.pi nothing has changed which is a good start at the very least we didn't break anything but now that we have more control over what the group is doing we can customize this thing quite a bit and one thing you could be doing for example is get self.display surface in here as well with pygame.display.get underscore surface that way this camera group can draw on the display surface straight away which you could use by creating a customize draw method and this one itself and nothing else at least for now now the way a normal group draws is bright so this line here essentially all that it does is it runs a for loop with four sprite in self dot sprites don't forget to call it for some reason this is a method and now in here we are calling the display surface with blit and then we are passing in sprite dot image and sprite dot rect this is basically all that is happening inside of a normal group for the draw method which is also the reason why every sprite always needs an image and a rectangle if you didn't have those you wouldn't be able to draw the sprite so they are mandatory so now that we have a customized draw i can comment out this draw here and instead i want to run self dot all sprites dot customize draw and let's call it actually let me call it custom draw that makes a bit more sense custom draw that is better and now if i run this everything still works just as before there's no difference although now we don't have to pass in the display surface anymore in here which already is a minor improvement although not that much of a difference with that we have a start for the camera logic although we don't have a camera yet but well this method is going to become quite a bit more extensive although right now we have a problem because any kind of camera i would create would be impossible to see because the background is pure black so even if we move left or right you wouldn't be able to see it because it's well all black as a consequence we first of all need some kind of floor so we can see what's going on and for that we have to import the floor now the floor is very simple it is one big image if i open the project folder inside of graphics there we have world and inside of there we have the ground and i guess let me open this one all this is is one big image and you can see here we have for example the trader and we have a whole bunch of objects all the way over here and the rest of the map so all of this stuff here is really empty all of this is going to work in detail i will explain in the next few sections for now just don't worry about them but don't worry i didn't make a mistake all of this is intentional so let me move this away and this image we want to import although for it to work we first of all need another class to actually use it inside of pygame and for that i want to create a new python file that i want to save as let's call it sprites.pi because in here we are going to have more than one and i want to import pygame and from settings import everything and for now we just want to create a very generic class so let me call it generic and this one is going to be sprite so pygame.sprite.sprite in here as always we need the dunder init method this one itself and besides that we need a couple of arguments we first of all need to position after that we need the surface we want to import or we want to use then we want the groups so this is kind of similar to the player where we have a position and a group so where the sprite should start and what group it should be part of however for the generic sprite it needs a surface because we might add different kinds of images in here now first of all on here as always you need the dander indeed method with the groups inside that is missing something that's looking better and now we need self.image and we need self.rect the image is just going to be the surface which means we're taking the surface from the arguments and passing it in here that's all that's going to happen and for the rectangle we get self.image dot get underscore rect and now we're placing the top left wherever the position is the position we are again getting from the arguments and passing it in here now we just have to figure out how to use it and this i am going to do inside of a level which means first of all i need from sprites import generic and now inside of setup i have to import it by using this generic class i want to create an instance of the generic class and now i need the different arguments for the various parameters let me copy them and paste them in here and let me use named arguments so this is a bit easier to see the position is super easy it's just going to be 0 and 0. or the this is terrible formatting let me clean this up a tiny bit for the surface all we have to do is to import pygame dot image and load and now we need the file path which is one folder up then we go into graphics then we go into world and then we get ground dot png as always don't forget to call convert alpha on all of this finally we need the groups and this one is easy just like for the player we need self dot all sprites this one should be working already so let me try and there we go now we can see the background and now we need the camera to see the rest of the level so right now we can only ever see the top left of the map which wouldn't be helpful but this is already looking much better however before we can do that there's one major problem right now the floor is only behind the player because we are creating it before we are creating the player which means if i created the player before this generic class and run this again we wouldn't be able to see the player because the player is behind the ground which is not well good at all and this leads us to one of the 3d effects we need for the game if you look at settings we have what is called layers all of this and this i want to use to draw the different elements of the map most of the game is going to happen inside of main in here for example we have the player all of the plants and the trees and stuff like that and the ground should be all the way here what we are essentially going to do inside of this custom draw method we are going to cycle through this list and then draw things one by one meaning the water will be drawn first then the ground then the soil then the soil water and so on and the rain drops all the way at the end that way we get a threedimensional effect where different things are on top of other things there's actually going to be a second threedimensional effect but that's going to come later i don't want to overwhelm you guys now for all of this to work we first of all have to assign each sprite one of these layers which means right now the sprites need one layer and the player is going to need a layer and let me get started for the player right below the rectangle i want to assign what i called z and z is just going to be layers so the dictionary from settings and the player should be on main so i can just copy it and paste it in here and now the player has a z position this means that inside of the game every single sprite has an x position we have a y position and besides that we are going to have a z position x and y are always going to come from the rectangle here and z is going to be a separate variable but both of those work very closely together now besides that for the sprites we also have to determine what the z position is going to be and this might potentially change as a consequence i want to have z as a parameter although here i do want to have a default parameter where if we don't get an argument z should be on the main layer and don't forget to turn the parameter into an attribute so self.z is going to be z now that being said for the ground so the ground we are creating here the floor is not supposed to be on the main layer instead it is supposed to be so z is supposed to be in layers and this key here is called ground let me copy it and paste it in here now we have a z position we just have to figure out how to actually use it this is going to happen in here and this i believe could be a really good challenge for you so try to use this dictionary here and draw elements by the order inside of this layer's dictionary meaning the higher the number is the later it should be drawn if you want a quick tip this should be a for loop but pause the video now and try to figure this one out let's see if we can do it the way this is going to work first of all we have to cycle through the layers dictionary let's call it for layer in layers dot values we don't actually care about the keys they just don't matter and all of the drawing is going to happen inside of this for loop and all i really want to do is i only want to draw a sprite so after going through all of the sprites i want to check if sprite dot z is actually the same as the layer the layer being one of the values of the layer's dictionary and only if that is the case i want to draw this layer and that should be it let's try and now i can see my player again even though the player is being created before we are creating the floor which means this logic here is working just fine cool so with that we actually already have some sort of camera but not a real camera yet let's actually work on it properly now so for the camera and once again check out my dedicated video on camera logic this one is really important to understand but first of all what we need here is we have to create some kind of offset and this is going to be a vector so pygame.math.vector2 and how this is going to work think of this one here is the player and everything else so all of this stuff here is going to be the rest of the map and how the camera is going to work is if the player is moving to the right we are going to shift the entire map to the left now when i say shifty and time up to the left i don't mean to actually move it instead we are going to draw it in a different position the actual position doesn't change which means in practice when we are doing display surface dot blit spreader image is going to stay exactly the same which means in practice when we are calling thisdisplaysurface.blit this one doesn't change the position it just draws a sprite in a certain position wherever this rectangle is going to be but this rectangle you can move around perfectly fine and the way i want it to work is by making it relative to the player and for that first of all when i do custom draw i want to look at the player because this is what the camera should be following and now i want to have my offset dot x and i also want to do this for y and the logic here let me do it for x and y together because it's going to be fairly similar i want to look at my player.rect.center and for x is going to be x and for y it's going to be center y so right now i am getting the position of the player and from that i want to subtract this green and then for x this is going to be the width and for y this is going to be the height divided by 2 for both what that basically means is the offset is going to be by how much we are going to shift every single sprite relative to the player and we have to figure out by how much we want to move them and this logic here ensures that the player is always in the center of the camera if this one here is the player we always want to have an offset that points at the top left of the window which means we want to go half the screen width to the left and half the screen width up and then we're ending up on the point up here this is what we have to use to draw everything now for that first of all i want to create an offset rectangle and this we get with sprite dot image dot get underscore rect and this we get with sprite dot rect dot copy and this offset rectangle i actually want to offset so i want to get the offset rectangle again and now i want to move the center by minus equal the offset and this offside rectangle is what i'm going to use to draw the image and now there's one more thing we need and that is what i'm calling custom draw i have to insert the player fortunately we do have the player inside of self.player so let me pass it in here and now let's run all of this and now if i move around we have a camera and this is feeling pretty good we are definitely making progress although a lot of stuff is missing right now and this tends to look a bit weird but well we're getting there and i am fully aware that i didn't really go into detail for this entire logic so i hope you could kind of follow along but if you check out my videos on cameras this is explaining all of this in so much more detail so check this one out if you are interested the logic here unfortunately gets quite complex and i don't want this video to be 20 hours long but alright let me remove some white space and then we are basically done for this part in this part we are going to import all of the other elements and we are going to fake 3d a tiny bit more and i guess let's go for this one by one and let's start by importing all of the elements we have already done this to an extent but well now we have to do more of that now there is a tiny bit of theory that i do have to cover and that is that the entire game was designed entirely which is a free program that you can use to design levels it's really powerful and i am using another module called pytmx to import all of this data now let me go through what all of this means by looking at tiled here we go this is all of tiled so in here i could for example move things around and design the level to look slightly different and doing all of this took quite some time there's a ton of things in here so if you look on the top left there are a ton of layers that you could be working with and well all of this is very complex and once again i have made a complete video on all of this so if you want to have a ton of detail check that one out i just don't have the time for this video to go over titled separately all i am going to do is import all of this data into pygame so let's do all of that once more here i have my python setup and i want to continue working inside of level and let me minimize all of the methods so this is a bit easier to see and i can minimize the camera group now first of all i have to import pi tmx this happens with from pi tmx dot util underscore pygame i have to import load underscore pi game and really important here pitmx you have to install separately it does not come with python so either in the powershell or on the terminal type pip install pi tmx or pip3 install pi tmx depending on mac or windows now this i want to use inside of the setup method and in here let me add a bit of white space first of all we have to load a file if i open the project inside of data we have map.tmx this is what i want to import all of the data is in here and this i am loading with load pi game and in here i need the path to this file i have to go one folder up then i have to go to data and in there we have map dot tmx and now we have to import a ton of different things so let's start by building the house i think this is quite good to illustrate how this is going to work now the house if i go back to tiled the house consists of a couple of different layers let me go through them one by one so if i hide all of them and zoom in let me hide all of this as well we have a house floor then we have house walls then we have the furniture at the bottom and then we have the furniture at the top and all of these layers we have to import separately and really important all of these have to be on a different layer inside of pygame which means back in pygame or the house we have a couple of different layers most importantly house bottom is going to be for the bottom and the rest of the house is going to be in main and this is really important so let's go through it one by one first of all to access the data i need to store all of this inside of a variable let me call it tmx underscore data and now i can use it and this has a ton of methods that we could be accessing the one i want to use now is called tmx data dot get underscore layer underscore by underscore name and now we need a name of a layer the one we could be using in here for example is house furniture bottom and this if i look at tiled is this name here house furniture bottom and what i want to do is to add tiles after this that way i am getting all of the tiles inside of this layer and i can use them inside of a for loop and what i'm getting here let me add the for loop first so this for loop is going to return a list that i can unpack right away and the list consists of x y and a surface really quick back in tiled when i'm only looking at the house furniture bottom and let me hide everything else and this is in house decoration there we go in this we have a couple of different tiles and each tiles is one of these well little cells inside of a grid i just want to import this carpet thingy and this other carpet thingy here this is all i really want and each of those is going to have an x position a y position and then what you see is the surface this is what we are importing which means i already have a class to capture all of this data that is my generic class and in here i need a position i need a surface and i need my groups oh and also i need the z position first of all for the position you might be tempted to just add x and y in here but that wouldn't be a good idea because this x and y position is not a pixel position instead if i return to tiled and zoom out a bit there you go the position we are looking at is the x and y position on this grid so for example all the way in the top left this cell here has the grid position zero and zero and the one to the right of it so this one here is going to have one and zero but all of these tiles have a size of 64 by 64. so the actual starting position of this cell here is not going to be 1 and 0 it is going to be 64 and 0. we are essentially multiplying the position by 64 or rather the size of the tile and this position we have available in pie game as well it is inside of settings all the way at the top we have the tile size all i have to do is to multiply x and y by the tile size now the surface we already have it is just a surface we are importing up here then we need the groups and this one is also fairly easy because all we need in here is self dot or sprites and for z i want to have my layers and the house furniture bottom should be inside of the layer house bottom this one here let me copy it and paste it in here and this should be all we need there we go this should already be working now let's try and i do have to walk down a tiny bit because the house is somewhere down here there we go there we have a carpet and it is below the player because of the layers that is a really good start now there's a bit more stuff that i want to put on this layer and as a consequence i'm going to wrap this for loop inside of another for loop and what i want to do is four layer in the list in here i have house floor and then i have the house furniture bottom and now for x and y and surface is going to be for the layer this way i am using the same for loop for the house floor layer and for the house furniture bottom layer now if i try this we are getting an error because i forgot the colon so now let's try this and if i now walk down i should be seeing the house floor and the carpet this is looking pretty good although in here the one limitation is that this house floor has to come before the house furniture bottom this house furniture bottom is only drawn on top of the house floor because it's being created afterwards if we reverse the order here let me add it like this then you would not be able to see the house furniture bottom let me try it now and you can see you well cannot see the carpet but we only have two elements here so this isn't really that much of an issue this works just fine as it is with that we have two layers out of quite a few now this entire thing i now want to copy because there are two more layers that work in kind of the same way we have the house walls and we have the house furniture top those are going to work in basically the same way for this line and this line the one difference is that those two should be on the main layer and now let me try if i now walk to the house always takes a second yeah you can see the entire house right now it is always below the player but this we are going to change very soon but well we have a house admittedly this setup here could be a bit more elegant but i don't want to add too many for loops but you could totally do it if you want to there's quite a bit of repetition in these lines here alright there is one more thing that we do need and that is the fence let me illustrate this entitled he is entitled and right now everything is hidden so let me make most of the stuff visible so we can see what's going on the fence i'm talking about is this fence here this is what i want to import now and this is going to work very similar compared to the house which means this could be a really good exercise for you i want you guys to cycle through the layer is called fence cycle through this layer and import the surface with the x and the y position using the generic class and this should be inside of its own for loop so possibly now and try to figure this one out we need for x y and the surface in tmm x underscore data dot get layer by name and the layer we want to look at is called fence and here don't forget we need tiles once we have that we need the generic class and in here we need a position we need a surface we need a group and we need a layer or rather a z position the position is super easy this is the one we have already done multiple times let me just copy it from the house so position this one and surface we also already have now for the groups for now we only have a single spread group so self.all sprites is going to remain the same finally for z i do want the fence to be on the main layer and since that is the default parameter i can just leave it as it is as a matter of fact or this line here i could actually remove layers dot main because this is what we get anyway let's do it like this and now let's try and there we can see the fence this is looking very nice righty there are three more things that we do have to import we have the water we have the trees and we have some wild flowers and all three of those are going to be their own class because they are all slightly different so let's create some more classes this is all going to happen inside of sprite first of all i want to create a class called water and this is also going to be a sprite but the sprite we are getting from generic which means water is going to inherit from generic and since generic is a sprite water is also going to be a sprite and in here as always we need it under init method and this one needs self it needs a position it needs frames not a surface we need groups and we need z the major thing about the water is that the water is going to be animated and this means we kind of need the same setup for the animation that we have seen for the player it's inside of animate basically this kind of setup here so we need a couple of frames like we've seen in here and then we need an entire method to loop over all of these frames and the frames are going to be stored inside of the method frames let me add a comment here and let's call this animation setup in here we first of all need an attribute with frames and this is just going to be frames what we are getting from the parameters then we need self dot frame underscore index this is zero by default and once we have that we can start with the sprite setup and in here all we need is this super dunder init method and for this one we need the init method of the generic class all of these parameters here position is what we are getting from the position from the water and let me use named arguments here that is a bit easier to follow i think for the surface i want to get myself dot frames and then here self dot frame underscore index and this should probably be on multiple lines otherwise it's kind of hard to read for the groups all i want is the groups i am getting from the parameters of the water class and finally for z all we need here is inside of settings we have water this is what i want to pass inside of the z argument here and this doesn't animate yet but we do need a few more things so back a level let's start creating this thing and first of all as always i need this kind of line here so let me just copy it the name of the layer we need here is called water and what i want to do is to create a water tile although right now we don't have water available inside of level meaning besides generic i want to import water for this one we need all of these parameters position is going to remain basically the same i can just copy things and paste them in here the other easy one is the groups because once again we only have a single group so far so this is always going to be all sprites the problem we have is we need the water frames which if you open the project folder again are inside of graphics and in there we have water and we have four different frames and these we want to animate but for that we have to import all of them fortunately we already have a function that imports an entire folder and converts it into surfaces the same thing we have used for the player so we can reuse all of this for that to work though we first have to make it available inside of level.pi which means from support i want to import everything and now i can use import folder and for the water i want to have some water frames and this is going to be input folder and the file path we need here is one fold up then we have graphics and then we have water and these water frames we want to use in here and now let's see if this is going to work already so if i move over this side there is going to be some water this is looking really good and if i move further down we should be able to see some more water there we go so now we have water except it's all static so now we have to animate it that is going to happen inside of sprites and in here i want to create an animate function or well method in itself and delta time i think we could do another really good exercise so like for the player we have to create an animate function so try to create this one for the water basically what you have to do is copy the thing you have seen for the player and then make sure you're actually calling it so try this one yourself and see if you can figure it out i think a really good way here is to look at both of the files next to each other it's a bit hard to see but i hope you get the idea we are basically going to copy all of this so first of all we need self dot frame index and we want to increase this by a certain number for the water i went with 5 and multiply this by delta time but this 5 here is entirely subjective play around with this after that i want to check if myself dot frame index is greater or equal than the length of self dot frames if that is the case i want to set self dot frame index to zero finally i want to update self dot image and this is going to be self dot frames and in here don't forget we need an integer of self dot frame index and that is all we need all we have to do now is to figure out when to call this animate method and this we are doing inside of the update method in here we need self and delta time and all i really have to do in here is call self dot animate and pass in delta time technically you could just add all of these lines here and paste them inside of the update method it would work perfectly fine but i think this is a bit more organized it well it's entirely up to you but now we should be having animated water let's try and let's walk to the water and there we go we have animated water this is looking quite nice so i can minimize the water and now we can work on the next kind of sprite i guess a really easy one would be the class wild laurer and this one like the water has to inherit from generic and in here we need a dunder init method and this one needs self it needs a position it needs a surface and we need the groups and after that we need a super and a dunder init method and once again we need these three parameters we don't need z because all of the wildflowers are supposed to be on the main layer and the wildflowers for now are going to stay just like that we're not going to make any more changes although later on they are going to change a tiny bit which is why we need a separate class but now that we have them inside of level.pi i want to import the wild flower and this one if i copy these two lines here i want to look at the layer called decoration let's have a look at tiled how this looks the layer i am looking at is this one here decoration and in there if i hide and unhide it it's all of these small elements inside of the foresty area and these i want to import now there if you look at the layers in the top right these are slightly different compared to the tile layers we have already seen basically these are objects and this we can move around easily whereas these with the square icon are all tiles but again check out my original video it explains all of this in much more detail the difference honestly isn't that bad i shouldn't have actually copied this line instead what i should have been doing is for obj in tmx data dot get layer by name and the layer we are looking at is called decoration this one doesn't change and now in here we are getting an obj and this obj has an x it has a y and it has an image and this one is the surface so this is what we are going to use and now i want to create a wild flower and in here let me copy the parameters we need we need a position we need a surface and we need the groups for the position we need obj.x and obj.y and those are actual pixel positions so we don't have to multiply them with anything for the surface we need obj dot image and for the groups once again we need self dot all sprites let's run this again and now we can see a whole lot more stuff on the map this is already starting to look much better finally we are going to need some trees so i'm going to create a class called tree this one is also going to inherit from generic and in here we need a dunder init method with self we need a position we need a surface we need the groups and besides that i also want to have a name of the tree why that name is going to matter let me visualize all of this entirely inside of tiled here you can see all of the trees and they all have a name the name you can see here so a tree could be called small or large and this is what i want to use for the name that way i can tell if a tree is going to be small or large that's basically all it is although later on this is also going to determine where the apples are going to be on the tree for example for a larger tree we would have this entire surface to place apples or a small tree we would only have this surface here and inside of here i want to have a super dunder init method and this one is going to need a position a surface and the groups all of these we are getting from the parameters so we can just leave it as it is although later on the trees are going to become quite substantially more extensive but for now all we have to do is or obj in tmx data.get layer by name and the layer i am looking for is called trees and in here i want to create a tree although first of all i do have to import it with three and the arguments we need let me copy the parameters the position we can just copy from the wildflowers this one here so position is covered the surface is going to be obj.image for the groups once again we have self dot all sprites and for the name this one we get with obj.name and now if we run this here you can see a huge amount of trees and this is looking really nice so the entire thing is definitely coming together so there's only one more thing that i do want to cover although for that we need a tiny bit of theory let's talk about it i want the various elements to overlap at the very least the elements inside of the main layer so for example if the player is behind in the yaxis it should be drawn below the other elements for example if we have the player here and the player is behind a sunflower the player should be behind the sunflower or rather below the sunflower and if the player is in front and the y axis the player should be drawn in front of the other elements so if the player is in front of it it should be drawn on top of the sunflower and this effect is really nice in the game it makes it look much better it's also very easy to implement so let's jump right in back in the code i want to minimize the setup method and i want to work inside of the camera group i have to work inside of all of this and this line here in particular is really important because right now we are just drawing or well cycling through all of the sprites and this i want to sort and the way i want to sort it let's say we have two elements like this i want to sort them by the white position which means the further down the center of a sprite is the later it should be drawn in this case this right here should be drawn first and this sprite should be drawn after that that way this sprite here is always on top of this other sprite and since this is going to happen on every single frame of the game this can also change to get all of this we need a key for this sorted function this always has to be a lambda function and into this lambda function i want to pass in this sprite what i want to look at from the sprite is sprite.rect.center y that is literally all i needed so now if i run out of this again you can already see it with the fence but it's kind of weird but the sunflowers make it look much nicer so now the player can walk through all of this and it's looking significantly better so this is really really nice and that way the game feels much more threedimensional it also works with the house let me walk there so for example here we can walk through all of this and well this is very very nice cool this was a very large section but we basically imported the entire game so massive progress with the level and the player in place we can work on the collisions and let me cover a tiny bit of theory how the collisions are going to work first because that can be kind of confusing let's say we have an object here and we have the player moving in some kind of direction and we want to check if the player is colliding with this obstacle what we are going to do for that is we are first going to check if the player is overlapping with the obstacle for example the player could be here and we have an overlap detecting this is really easy the difficult bit is to figure out where the collision came from in this case it might look like the collision came from this side but it might have happened that the player was moving really fast in this direction for example or the player could have come down this side here as a consequence we're going to add a bit more code to figure out where the player came from in this case since the only object that can move is the player we can check the player direction so for example if the player was moving in let's say this direction here we know the collision must have happened on this side because the player was moving in this direction and once we have that bit of information let me clean this up a tiny bit if we know that the player moved in this direction and our collision happened here then we want to move the player back to something like this and then we have the entire collision logic it honestly isn't that bad but you do need some theory here and one more time i made a whole separate video on it so check this one out if you are interested but other than that let's implement all of this alrighty here i'm back in the code and i want to do a couple of things first before we start with the collision logic the most important part is that all of the sprites let me minimize them there we go all of the sprites and the player are going to need a hitbox or some kind of collision rectangle we could be using the rectangle itself but that would not be a good idea for two reasons actually first of all for the player the rectangle is going to be really large if i open the project folder inside of graphics and let's look at the character for something like left x in here if i open this okay it's going to be very hard to see but if i zoom in you can kind of see by the shade this entire surface here has a size of this this is the entire image and the rectangle we are creating from this has the same dimensions and this is much larger than the actual image the reason why it is so large is because we have to capture the entire image and the bunny has to be in the middle if that wasn't the case the character would move around if the size changed so all of these surfaces have the same size and that is really important because of that we couldn't use the rectangle but what we can do is create self dot hitbox and this hitbox is what we actually use for the collisions and for this one all i want to do is self door direct dot copy so we are copying the rectangle and this i want to inflate all that inflate is doing is it takes a rectangle and it changes the dimension while keeping it centered around the well center as an argument here we need a tuple with a width and a height by how much we want to shrink or increase it in my case i want to shrink it by 126 pixels on the horizontal axis and negative 70 pixels on the vertical axis next up this hitbox has to be moved along with the rectangle and this is going to happen inside of the move method so in here what i usually do is after i've moved the position i am moving the hitbox so self.hit that is terrible spelling self dot hitbox dot center x is going to be self.pos.x and then self.rect.centerx is going to be self.hitbox.centerx although in here i actually realized i forgot one important thing and that is that this self deposited x needs to be rounded if we didn't include that pygame would truncate these values which means a 1.9 for example would be truncated to one whereas the proper value would be a two and this is what we get by rounding which is why we need the rounding here if you don't do that you are going to get occasionally wrong behavior or well incorrect behavior but all right now that we have that i have to do the same thing for the vertical movement so self.hitbox.center y is going to be rounded self dot pos dot y and now self.record center y is going to be self.hitbox.center y with that we have a hitbox for the player and now all of the sprites are going to need a hitbox as well let's start with generic and in here i just want to create a hitbox with self.rect.copy and this i want to inflate and the number here i want to be a bit more flexible so for the wife i went with negative self.rect.with and multiply this by 0.2 then i'm going to copy all of this and then for the height this is going to be self.rect.height multiplied by negative 0.75 the numbers here you definitely just want to play around with it is fairly subjective it really depends how you want this to look mostly for the width you want to have a fairly small number because you don't want to shrink it too much on the horizontal axis for the vertical axis you do actually want quite a large number and this again is because of the overlap let me show the slide again actually the overlap for all of this works really well because when we created this there was no collision but once we have collision we really have to be aware that this rectangle here shouldn't be too tall because if the sunflower would have a collision rectangle that covers the entire height the main character would never be able to go behind it we would always get stuck on top as a consequence you do want quite a high negative number for the vertical axes all right with that let me minimize the generic class so we have a lot of space water doesn't need any hitbox because it cannot be collided with and next up we need the wildflower and this is now the reason why this is a separate class because in here i want to have a hitbox and this is going to be self dot rect dot let me copy it and then i want to inflate the entire thing and i want to inflate this by static numbers for the horizontal axis which is negative 20 and for the height i want to go with negative self.rect.height and this i want to multiply with 0.9 finally we have the tree although in here we don't actually have to make too many changes because the tree can take the hitbox from the generic class so this hitbox is still going to apply inheritance here makes our life a lot easier that covers a lot of the setup there's one more thing that we need back in level inside of the init method i need another group the group i want to create is called self dot collision sprites and this is going to be a plain pie game.sprite.group the only reason i'm going to create this group is because i have to keep track of what sprites can be collided with so any sprite the player can collide with is going to be inside of this group and inside of this group that way i can identify them easily which makes my life a lot easier and now when we are creating all of the collidable sprites that is going to be for example defense we can collide with so in here self. all sprites i want to put in a list and besides that self.collision sprites the same is also going to apply to the trees and to the decoration so let me target both and all sprites should be in a list along with self.collision sprites you might be wondering if house walls and house furniture top also need collision sprites the answer is not really but i'm going to cover that in just a bit but that's going to come in just a bit the one thing we need now is that the player needs to know where all of the collision sprites are because we are going to run the collision method inside of the player which means i want to pass self.collisions sprites into the player i do want to mention here for the player the player sprite is inside of all sprites and then besides that the player is going to have a separate parameter for the collision sprites but the player sprite itself is not inside of the collision sprite we just have a reference to it whereas the decorations are both in all sprites and in the collision sprites this is a fundamentally different concept here so i hope you get the difference but now to make all of this work inside of player the player is going to need one more parameter and let's call this the collision sprites and this we have to capture let me put it below the movement attributes in here we have collision and i want to get myself dot collision sprites as an attribute and i guess to keep things organized i could put the hitbox in here as well it does seem to make sense and now i can minimize the indent method and now inside of the move method we can work with the collisions or more specifically i want to create a separate method that i'm going to call collide actually i guess collision makes a bit more sense it doesn't really matter and in here i need self and i need the direction first of all in here i want to look at every single sprite inside of the collision sprites so for sprite in self dot collision sprites dot sprites in here i want to check has attribute if this sprite i am looking at has an attribute called hitbox they should all do but this is a good way to make sure and that we just skip any kind of collision if that isn't the case it well makes our life a bit easier now once i have that i want to check if there's any kind of overlap and this i get with sprite dot hitbox dot polite rect and now i want to check with self dot hitbox if that is the case we know there is going to be some kind of overlap the problem is we don't know where the overlap came from this is why i talked just a second ago so here we have an obstacle and the player might be somewhere here we know the overlap is here the problem is we don't know where the player came from the player could have come from here the player could have come from here the player could have even come from here and moved really fast meaning we have to figure out where this came from and the best way to think about this is first of all you want to separate the dimensions so we first have let me call it we first have horizontal and after we have done that we are doing vertical this is also the reason why down here we split the movement into horizontal and vertical movement in here the logic gets much easier we still have an obstacle and now the player overlaps again something like this but now we only have to check if the collision happened on the left or on the right now it's still perfectly possible that the player came this way here and moved really fast so i want to check the direction of the player meaning if the player was moving to the right i know that the collision must have happened on the left because if the player is moving to the right any kind of collision has to happen on the left of the obstacle meaning this side here and this is what we have to implement now first of all i want to check the direction and if this is horizontal then i want to check the player direction so if self.direction.x is greater than zero if that is the case we are moving right or the player is moving right as a consequence if there is a collision then i want to set self.hitbox.write is going to be sprite.hitbox.left and besides that if self.direction.x is smaller than zero this means we are moving left then self.hitbox.left is going to be sprite dot hitbox dot right there are two more things we need in here and that is we have to update self.rect.centerx so the rectangle the player actually sees because right now we are just updating the hitbox we're not updating the rectangle itself so where the player appears on the screen and this should be whereself.hitbox.centeraxis finally for the movement we have to update self.post.x and this i also want to set wereself.hitbox.centerxis and this is the entire logic for the horizontal collisions all i have to do now is after we have done all of the movement for the horizontal movement then i want to call self dot collision like this and pass in horizontal in here and now this should be working let's try if i now okay this is getting a bit weird because we spawned on something but if i just move left and right we definitely have some collisions now if i move up and down this doesn't work at all but just by itself this is looking pretty good which means all we have to do now is to also check if direction is equal to vertical let me add a bit of white space here and this is going to be your exercise basically what i want you guys to do is to copy the logic here and apply it on the vertical axis so pause the video now and see if we can figure this one out first of all i want to check if self.direction.y is greater than zero if that is the case i know i am moving down which means i want to set self.hitbox.bottom to sprite.hitbox.top i guess let me draw what this means this line here means we are checking if the player is moving down so the player like this is moving down and now we also know that there has been some kind of collision the collision object now is pink i hope it still makes sense and now we have to resolve this collision this is happening inside of this line here we are putting the bottom of the player this line here at the top of the obstacle which means we are moving the player up by this amount and that way it appears that the player is on top of the obstacle and it appears like that because it literally is so next up we need self.direction.y is smaller than zero and if that is the case we are moving up and this means top self.hitbox.top going to be sprite dot hitbox dot autumn besides that we also have to update self.rect.center y and this is going to be self.hitbox.center y and finally besides that self.post.y is also going to be self.hitbox.center y and with that we have the entire collision logic so let's try and we do have a bit of a problem because we always spawn outside of this fence which causes a few problems so let me move around here and now if i just move around the forest here there's lots of things i can collide with and we do have some problems so something is not right and i think i know what it is because back in the player i am not calling the collision after the vertical movement meaning let me copy the collision here and this should be vertical now let's try this again so now we have the same problem we are spawning right on top of a fence which causes weird behavior but other than that now we have proper collisions let's see if this is working this is looking pretty good and if i walk through here i can walk behind the bushes but i cannot walk through all of the trees and this is looking pretty good so i am quite happy with this nice this is working very well there are two problems we have right now number one is the starting position of the player meaning inside of setup the player is just being spawned in a random position which isn't ideal and besides that we need some kind of mechanism to prevent the player from moving outside of the map so like this and let's go through them one by one the starting position of the player is the easier thing and for that we need tiled once more if i open this one there is an entire layer called player and inside of that we have a couple of objects and one is called start this is a simple node and this one we can use to set positions and this is where i want to spawn the player which means back in my code i let me add another comment here player is probably the best name for this spelling it correctly would also help what i want to do in here is for obj in tmx data dot get layer by name and this layer is literally called player and what i want to check is if obj.name is equal to start if that is the case i want to create the player and the starting position of the player is going to be obj dot x and dot y if i run this again we are starting right in the middle of the map so this is much better now we have to figure out the other kinds of collision so let me run the game again i can for example just walk through the house which feels a bit strange for that if i open tiled again there is an entire layer called collision if i make this one visible you can kind of tell what's going on i basically drew a couple of tiles all across the level and this is limiting the player this is what i want to import and then use it for collisions this i am doing inside of level and let me do it i guess right before the player makes sense and here i want to have some collision tiles and that is some terrible spelling collision tiles since we are now working with a tile layer again i want for x y and surface in emx data dot get layer by name this layer is called collision don't forget we also need tiles in here i want to create a generic tile and this one is going to need a position a surface and a group what you have to consider here is that for the group i want to only place it in self dot collision sprites this is the one sprite that is not going to be in all sprites as a consequence it is not going to be drawn or updated but it is going to exist and since this one isn't going to move we don't really have to update it that way even though we have a sprite with a surface it is not going to be visible but besides that everything else remains basically the same so i have x and y and both of these need to be multiplied with the tile size for the surface all i really want to do is create a pie game dot surface and this one should be tile size and tile size that way we are creating a empty surface or well a black surface with the dimensions of 64 by 64 which is all we need for this sprite and with that we should be having collisions so let me run main.pie again i am not able to walk through the house anymore on top of that if i try to walk on the water i can also not do that anymore and if i walk further to the right this one also doesn't work so this is much better i guess i can demonstrate what would happen if we added these generic sprites to all sprites as well so if i add this to self dot all sprites it would look something like this so these are the sprites we are actually colliding with and well it doesn't feel great but you can tell what's going on so this is the entire religion map of the level but i do not want to show them so let me undo all of this there we go and now we have all of the collisions that we need in this part i want to work on the trees so that we can hit the trees and the trees all have apples there are quite a few different things we need so let's jump right in here we are back in the code and i want to work on my trees let's get started by giving the trees some apples for that first of all we need an apple surface this we get with pygame.image.load and the file path here let me just copy it to save me a bit of writing this file path here inside of the project folder we are looking at graphics and in there we have root and in there we have if i make it a bit larger we have the apple this is what we're importing is simple image after that we need a list of possible positions for the apple and this we have in the settings let me minimize all of this so it's easier to read we have one dictionary with small and large and the values here are lists with positions and these names here refer to small or large trees and these are positions on the tree where we could have an apple this i want to create as an attribute so self dot let's call it apple pos is going to be apple underscore pos that's the dictionary from the settings file and from this i want to pick the list that is appropriate and this i'm getting by using the name remember here the name of the trees is either small or large and this is why this works finally each of the trees is going to have its own sprite group which i'm going to call apple sprites this is just going to be pygame.sprite.group now once we have that i actually have to use that to create some apples this i want to do in a separate method that i'm going to call create fruit we need self and nothing else and in here basically what i want to do is for position in self.apple position i want to have some random number generator to tell if we want to create an apple in a position or not now for that i am going to need randint so from random import rand and now all i really want to do is rant in generating a number between 0 and 10 and if that number is smaller than 2 i want to create an apple and the apple here is just going to be a generic object this one is going to need a position a surface and a group all the stuff we're getting from the generic class up here let me go through them one by one because we do have to be a bit careful here although the surface is very easy all we need is self dot apple's surface actually this should just be uphill surface because it's singular for the position you might be very tempted to just go with position by itself here because if you look at settings we have a list and this looks like a position and it kind of is but it's a bit misleading the way you have to think about it if this one here is the entire map of the game and we have a tree somewhere here the position that is inside of the list refers to the position on the tree and the number is the distance from the top left of the tree not the top left of the entire game meaning every time we are creating an apple we have to add the top left of the game and then we have to add the offset of the apple and let's do this separately for the variables we have x and y and this i think could actually be a really good exercise for you try to get the actual position of the apple you want to get the position of the apple the position we already have and then add it to the top left of the tree and see how far you get all right let's do it for the x and i want to get position 0. that is always the x this is let me bring the drawing back up and let me clean it up a tiny bit this position 0 is basically telling me how far from the left of the tree i want to go to this i have to add self self.rect.left and this self.director left is the left side of the tree meaning this side here is this side or in other words it is this distance here combined we are getting this entire arrow here and this is where we want to place the actual apple at least on the horizontal axis for the y this is going to look very similar we want pause one and then self.direct dot top and this is the actual x and y position we want this is what i want to pass in here for x and y finally for the group i want to have two groups in here the first one is easy i want to have self dot apple sprites besides that i also want to put all of these apples into all sprites because that's the only way to display them to the player the problem is we don't really have those available anywhere inside of this entire python file we only really have them inside of the level so this all sprites now the work around here is every single sprite has the attributes of what sprites it is part of and this we can access with self.groups and these are all of the groups that tree sprite is in this i do have to call and this is going to return a list and from this list i want to pick the first element and this first element if i look at my level where i am creating the trees this one here the first element is going to be all sprites the second element is going to be collision sprites this is what i'm getting with this line here so that way i am placing each apple into apple sprites that's the sprite group of the tree and then into all sprites that way they are going to be visible there's one more thing that we need and let me put all of this over multiple lines with named arguments otherwise this is going to be very hard to read this one is groups and finally the one thing i forgot is we need a z position fortunately this one is very easy we need layers and inside of settings inside of layers we have a fruit layer this is where the apples should be on every time we are creating the tree i want to call self dot create fruit and this should be working let's try if i now run main.pi and look at a tree we can see quite a lot of apples this is looking very nice i am very happy with this we are definitely making progress next up i want to have the logic that we can hit the player and let me minimize create fruit we don't need it anymore so let me call this the tree attributes in here first of all each tree is going to have an amount of health which i'm always going to set to 5 but choose whatever you want in here besides that i also want self dot alive and by default this is going to be true if this one is false the tree for example wouldn't create fruits but this is going to come later besides that i also want to have what i called self.stump underscore surface and this is what the tree is going to look like if the tree was destroyed so once a life is false we want to display a sum surface instead of the tree and this we have to import with pygame dot image dot load and in here i want to create an f string because we have to decide between two different files so there's one stump for the small tree and one for the large tree for both we have to go up one folder then to graphics and there's a folder called stumps and here i want to work with variables and this should be small if name is equal to small and if that is not the case it should be large and don't forget this should be png this is getting really large and i made a typo so let's put this on a separate line let's call this the stump path so i want to get this out of here and paste it in there and place this stump path in here and now don't forget we also have to convert alpha this one there's one more thing that we do need and that is a timer so i want to have self dot involve underscore timer is going to be a timer that lasts for about 200 milliseconds why we need this timer i'm going to visualize in just a second for now just follow along but this is basically all we need for the three attributes now that we have that i want to create another method and this i'm going to call damage here we need self and nothing else this method is well damaging the tree so i want self dot health minus equal one and this is going to be damaging the three besides that every time we're hitting the tree with an x i also want to remove an apple but i only want to do that if there is an apple meaning first of all i want to check the length of self dot apple sprites dot sprites if this list here is 0 there is no point in removing an apple so i only want to do this if this list is greater than 0. if that is the case i want to pick a random apple and store it in a variable and to pick a random apple i need the choice function and this one i also get from random so besides randint i want to import choice and in here i want choice and i want self.apple sprites dot sprites and this random apple i want to destroy with the kill method so now we just have to figure out how to call this damage method and this is going to happen inside of the player although for that to work we need a few more things so let me minimize everything inside of the player first of all the player needs to know where all of the trees are and for that to work back in my level let me minimize all of these methods as well i want to create another group and this i called self dot tree sprites again this is just going to be pygame.sprite.group all of the trees that i am going to create which happens down here each tree is supposed to be in all sprites collision sprites and also in self.3 sprites really important here make sure that self.all sprites is the first sprite inside of the list if that is not the case then inside of createfruit this line here would not work anymore so be careful here but now that we have that i can minimize the setup actually i can't because i have to pass into my player this one here let me put all of this over multiple lines because this is also getting really hard to read we have a position we have a group i think it was a singular group right yeah just group besides that we have collision sprites and finally i want to add one more parameter and this is called trees and this is going to be self.3 sprites and now inside of the player in the init method i want to create three sprites next up i have to convert all of this into an attribute let me put it all the way at the bottom here and let me create another section that i call interaction there are going to be quite a few things we need to interact with but in here i want to have myself dot three sprites and this is going to be the tree sprites parameter now we have to figure out how to actually target this thing and this is going to happen inside of use tool remember this we created ages ago about 2 hours by now but this method is being called every time we are using a tool and in here i want to check what tool we are currently using so if self dot selected tool is equal to let's start with a ho if that is the case i want to pass for now besides that i can duplicate this line i want to check if the selected tool is an x and this is what we want to work on in this part but for now let me add a path in here and finally i also want to check if our selected tool is water although in here for now also going to be a pass if we are using the x i want to check for 3 in self dot 3 sprites dot sprites don't forget to call it and now i want to check if we are actually hitting the tree which means if 3 and now i have to figure out if we are actually hitting the tree the problem is i don't really have any way to know which point i'm actually targeting meaning let me comment out all of this for now and let me run the code and i'm getting an error because i didn't import the timer so from timer import timer now let's try this again we are getting another error that the player this is probably happening in level this should be tree underscore sprites now it's working right now i can use the different tools and this is working perfectly fine for all of them the issue is right now we have no idea which point we are targeting for example if i'm using the x i want to know that i am basically targeting this point here let me use the x again this looks about right and this point i have to get in my code so back in my player let me minimize the init method and in here i want to create another method that i'm going to call get underscore target underscore position and all i really want to do in here is i want to create another attribute that i'm going to call self.target position this is going to be the same for all of the tools which makes it quite easy to work with and the basic logic here is if this is our player and this is the center of the player for each of the tools for example if the player is looking to the left then i want the tool to be somewhere here a certain distance to the left of the player and a bit further down the reason why i have to move it down is because most of the tools like the x for example they go in this direction here basically what i want to do i want to get self.rect.center and then i'm going to need some kind of offset and this offset i am getting from my settings because in here we have player tool offsets and these are a bunch of offsets that we can work with meaning this is what i want to copy paste it inside of the player and now we have a dictionary that we want to take some information from notice here the keys are called left right up and down which is the same as the status of the player which is very handy because now we can get self.status dot split and as always we want to split it wherever there's an underscore and then pick the index 0 of that list and this is basically all we need for this one method i guess importantly do not forget to call it right after the timers so self dot get target position now the problem is that this target position is going to be really hard to see at least for now for testing purposes we do need some way to visualize it and i just realized this should be status not stats and since this isn't something the player is supposed to see we can just do this really quick so for testing purposes back in level dot pi all the way at the end of custom draw i added a tiny bit more code that looks like this if you go for this basically what we are doing is we are drawing a rectangle another rectangle and a circle the result is going to look like this this is telling us the red line is the rectangle of the player the green line is the collision rectangle and the blue dot this one here is the target position so if i use a tool you can kind of see where it's going and this also works with the x and with the watering can and well this way you can play around with this quite a bit more although for the actual game you don't need it so most of the time you're just going to comment it out or remove it entirely but i guess let me keep it for now because now we know that the target position so the blue dot looks pretty good now with that we can uncomment this part here and now for the tree i want to look at the rectangle of the tree and i want to check if this tree is colliding with a point the point that i want to check is self dot target position if that is the case i want to get the tree and then run the damage method which is this damage method here let's try if this is working so back in the game we are already getting a problem because even if i don't use the axe the apples all disappear which i guess kind of looks cool but not ideal also this one should be commented one of the main reasons why that happened is if i open the timer again in here this line is causing the problem because there is a chance that our current time minus the start time is bigger than the duration so this could run forever and as a consequence we might trigger this function by accident and a really easy way to fix that is to add another end statement here that we want to check self dot start time is different from zero and now let's run may not pi again and now if i am colliding with a tree nothing happens and if i use the x also nothing happens let's try different tools okay nothing happens in general and the reason why that is happening inside of timer every time we are deactivating the timer we're setting the start time to zero meaning this is not going to run the activate has to be after this if statement and now inside of the player let me just print tool use just to try if this is working so now if i use the x i can see tool use in the bottom left and i guess now we can try to hit a tree there we go the apple disappeared and this is working quite well and let me close the timer again now we are done with it back in the sprites i want to have another method that checks if the tree is still alive so check def and basically all i want to do is if self.health is smaller or equal than zero then the tree is going to die let me just print that we just have to figure out when to call check def in my case i went with an update method that needs self and delta time like any update method and then here i'm going to call self dot check def actually to be a bit better here we only want to check def if self dot alive is true and now let me run main.pi again if i hit a tree with my x we get tool use tool use and now we get that this is looking really good which means what we can do in here now is i can set self dot alive u volts although there are a few more things that i do want to change first of all self.image so what the sprite actually looks like should be self.stump surface and since we are updating the image we also have to update self.rect this i get with self.image.getunderscorerect and i want to place the mid bottom should be wherever the previous self.rect.mid bottom was what that means is if this one here is the original tree and we want to create a tree stump that is a bit smaller we now have to figure out in this line where we want to place this rectangle finally we also have to update the hitbox and this we get with self.direct dot inflate actually i think good practice here is to copy the entire thing and now in here we are going to need a width and a height or an x and a y basically the same thing for the three stems i always went with negative 10 and negative self.direct and multiply this by 0.6 let's try so if i now go to a tree hit the tree a few times there we go we have a tree stump i can do this with the other tree as well and we get a different kind of tree stump and this section is getting quite long so let's finish it now but in the next section we are going to finish up the trees we are nearly done with the trees there is only one more major thing that i would like to add and that is some particle effects so that when an apple disappears or when a tree disappears i want to show some white object that flashes on the screen you'll see in a second what i mean but it looks quite nice once more here we have main.pi and i want to work inside of the sprites inside of the tree in here whenever one of the apples disappears that happens here i want to basically create a white apple on top of the disappearing apple that way we're indicating which apple disappears also whenever the tree dies which happens inside of this method here i want to do the same thing for the tree so for a couple of milliseconds we have a white tree and then we can see the tree stump both of these are being created with another class let me create it right here and i'm going to call this one class partic kill this particle is also going to be a generic sprite so it inherits like all of the other sprites from the generic class in here as always we are going to need the dunder init method we need self we need a position we need a surface we need groups and we need a z layer for the parent class to work we need the super and dunder init method this one for generic add position groups and the z layer meaning i can copy them in here and most of them we don't really have to worry about too much as a matter of fact if you look at this closely those parameters and those arguments are basically identical the only thing i really want to change is i do not want to have the default argument now the way this particle is going to work is it is going to be a sprite but this sprite is going to selfdestroy really quickly it basically has an internal timer let's create this one actually right now we can use the update method here and this one needs self and delta time just so that we capture delta time in here i am let me save it as the current time the current time i'm getting with pygame.time.get underscore ticks once i have that all i really want to do is if my current time minus some kind of start time we'll create that one in just a second is greater than a certain kind of duration if that is the case i want to destroy this sprite that way we are only showing this sprite for let's say half a second and then it disappears besides that this particle is always going to have the same surface as for example the tree except it is going to color the entire thing white and that way we have some kind of particle effect it's a fairly minimal one but it does the job for this game we need to do two more things we need to get a duration and this one i should have put in the init parameters so in here duration and i do want to have a default value let's say 200 now that we have all of that i want to create self.starttime and this one is pygame.time.get underscore ticks i suppose i should mention the difference between this start time here and this current time is that the start time here is only being taken once it's basically one point in time whereas the current time is being continuously updated meaning from this point here we are checking another current time another current time another current time and so on and at some point we are hitting the duration meaning that this distance here is greater than the duration and then we are destroying the sprite besides that i have to store my duration as an attribute and this i just get from my duration and this is the basic setup besides that we need to create the white surface in this we are doing via a mask for that i want to create a mask surface this i'm getting from pygame dot mask dot from underscore surface this one needs one surface and the surface we have is self dot image now once we have that i want to create a new surface and this new surface we get with the mass surface and then to underscore surface this new surface now is going to be a black and white silhouette of the original self.image any pixel that had any kind of color value is going to be white and any kind of transparent value will be black i can visualize this in just a second actually but what we need to do now is to get rid of all of the black color values which we do with new surface and we have to set a color key the color we want to get rid of is going to be black so a tuple with 0 0 and 0. and this new surface i want to set as the image of this sprite there we go and this should be all we need for the entire class all we have to figure out now is when to create it and this happens for example inside of the tree for example when we are destroying an apple i want to play this particle effect let's do it right below the random apple i want to create a particle for this particle i want to have not these parameters i want to have these parameters i suppose for simplicity we could get rid of the duration here because we're not going to need it for now and well now we have to figure out a position a surface groups and a z and i think this could be a really good exercise try to pass in all of these arguments and see if you can create this particle effect it should already be working once you have created it let's put them all on separate lines so i can work with named arguments and that should make all of this much easier to read first of all we need a position we already have the random apple we want to destroy i want to get this random apple i want to get the rectangle of this random apple and then i want to get the top left because this particle should be in the same position as this apple along the same lines it should also have the same surface so random apple dot image for the groups we need to do basically the same thing we have done for the apples which means i want to have myself dot groups don't forget to call it and now i want to have the element with the index 0. now looking at all of this since we are doing this quite often it might be a good idea to put a reference to the self.all sprites inside of the tree but you can do this in your own time it isn't going to make much of a difference finally for the set parameter i also realized it doesn't really have a separate layer but you don't really need one you can put it inside of the fruit but also be inside of raindrops it honestly doesn't matter at this point let's go with fruit i guess it fits in there quite well we need layers and in there i want to have the fruit and with that we should be having a particle effect let's try if i run out of this it still runs that's generally a good sign and let's use this tree here and there we go we have a very basic particle effect it is indeed very subtle but it certainly does work let me minimize the damage method and now we want to do the same thing for the tree once the tree is being destroyed which we can also do quite easily once again i want to create a particle and now once again let me get all of the parameters we need and i guess for this one we can also change the duration so in here i want to have all of these arguments the position is going to be self.rect.top left the surface is going to be self.image spelled correctly would be good as well then for the groups once more self.groups with the index 0 and for that i want to have layers and i guess we can put this on the fruit layer as well since this is a slightly larger object let's go for a duration of 500 and this should be all we need let's try this one now and this one is only going to play once the tree is dead so we have to hit a tree a couple of times we go i guess the effect is a tiny bit long uh let's go with 300. let's try this one although at this point this is quite subjective so you can just go with whatever you think looks best and yeah i think this is okay and with that we have some basic particle effects and these we can also reuse later on for the plans which is very nice which means we have covered another major section to finish off the tree we have to create a player inventory so the player gets an apple or some wood whenever we hit a tree which means we have to connect the player and the tree with each other which is a fairly straightforward thing to do so let's jump right in once more we are in the code and first of all we have to look at the player specifically inside of the init method let me put it above the interactions and right below the tools and the seats this one i want to call inventory because if you want to add something to the player the player needs to have some kind of system to store data and for now the player is only going to have a single dictionary and this i call item inventory although later on there's going to be a bit more and in here we're going to have a couple of different key value pairs let me copy them in actually so you don't have to watch me right we have these four wood and apple is what the player gets from the trees and corn and tomato is what we're getting from the soil by default all of them are going to be zero and let me line them up a bit nicer so this is looking better and these numbers we want to increase whenever the player for example gets a piece of wood or an apple which means we have to connect the player all of this here with the tree and since they are in different files we have to work via the level to make all of this work and let me minimize everything so we're not getting lost right now the level only has three methods even though it is quite a chunky class already but i want to add another method in here and this one i'm going to call player underscore add besides self we are going to need an item so the item we want to add to the player what is going to happen in here is i am targeting the player i want to get the item inventory of the player the one we just created from the dictionary i want to get the item this would be one of these key value pairs and this i want to increase by one i suppose you could make this a bit more flexible by adding another parameter that would be the amount for example but in my case i would always stick with one because i do want to keep things simple and this tutorial is already getting quite long this method i have to pass into the trees which means inside of setup when i am creating the trees this happens here and once again let's do this over multiple lines with named arguments so we're not getting completely lost we have the groups and finally this one was called the name the one additional argument we want to add is let's call it player add and this is going to be self dot player add make sure here not to call it because we only want to call it from inside of the tree object which means inside of the tree we're going to need another parameter layer add and this one we also have to store somewhere in the attributes let's do it here and self dot player add is going to be player add now that we have that when we are damaging the tree this stuff here i want to run self dot player add and give the player an apple which should be all we need i guess inside of the level in the run method all the way at the bottom let me print self.player.item inventory so we can tell what's going on if i run this now you can see in the bottom left the inventory of the player and if i now hit a tree we have one apple this i can do multiple times we have two apples three apples that is looking really good so that is basically all we need for the apples the one last thing for the tree we have to do is whenever the tree dies we have to give the player some wood and this could be a fairly easy exercise for you so try to figure this one out yourself i hope that this one is fairly easy at this point all you need is self dot player add and then here you have to add some wood let's run all of this again and for this one i have to hit a tree multiple times there we go now we have one wood this is working very well with that i can get rid of this print statement here and minimize the run method in fact i can minimize all of these methods so things are easier to see and with that we are basically done with the basic tree although the next section is we have to make sure that the trees get new apples once we are sleeping which means we have to work on the logic to start a new day but that is going to be the next section so let's start to work on restarting the day for now all this means is all of the trees are getting some new fruits but later on there's going to be quite a bit more besides that we also have to work on some transitions but let's do all of this straight in code it isn't so hard it's more an organizational thing but let's have a look at all of this alright once again we are inside main.pie and let's start by talking about what we need basically i want to start a new day when i stand here or when the player stands here and presses enter so right next to the bat which means we have to check an input and we need to check if the player is on top of this carpet or at least inside of this area for this i already have some basic setup inside of tiled let's have a look at that here we have tiled if i zoom in there is one object that is called bed that is right next to the pad this is an empty area that i want to import and if the player is inside of this area and presses enter then i want to start a new day once again if you want more detail entitled check out the dedicated video now this i want to import but for the import i need another dedicated sprite that sprite let me put it right here i have called interaction once more this inherits from the generic sprite although other than that it is going to be fairly simple we have an init method as always and in here we have self we have a position we have a size we have the groups and finally we have a name we do not need a surface in here for the simple reason that this kind of sprite is never visible anyway speaking of we can just create the surface in here and the surface we are creating with pygame dot surface and we are passing the size in here that is the size we're getting from the parameters other than that i have to call the parent init method with superdunder init and pass the surface the position and the groups in here there's that position really doesn't matter because again this is not going to be visible so we can just leave it as it is finally we have to get self.name and store it as an attribute the name if i open tiled again is what you can see on the left side here we have a name besides the bat by the way this is what you are going to see in quite a bit we have the trader meaning if the player stands inside of this area and presses enter we want to open some kind of menu for trading but well that is something for later but now i just want to work with the bad but other than that we have finished the entire interaction class it wasn't actually so bad now we have to import it this happens inside of level inside of setup in here this is getting quite extensive the layer we want to work in is the player layer let me add a bit of white space here because this is the same layer where we have the player except now i want to check if obj.name is equal to that if that is the case i want to create the inter action sprite for that to work i need to import it meaning all the way at the top after tree i want to have the interaction sprite now back in here let me copy all of the parameters we need we need those four and all of those should be fairly straightforward for the position we need the same thing we have seen for the player so obj.x and obj.y i can just copy paste them and for the size we're doing something fairly similar except for x and y we need with and we need height for the group i actually want to create a whole new group let me do it all the way inside of the init method this one i've called self.interaction sprites but this is once again just another pygame.sprite.group self dot interaction sprites we don't need self that all sprites here because again this kind of sprite is not going to be visible finally we need the name of this kind of sprite you could write just bad in here this would be perfectly fine alternatively you could also use obj.name you would be getting the same result and with that we have an area next up the player needs to know about this area because right now these interaction sprites only exist inside of the level and the player has no idea about them as a consequence for the player which is right on top i want to add let me call it interaction and this is going to be self.interaction sprites that way the player has an attribute to know where these interaction sprites are so with that inside of the player we are going to need one more parameter interaction this i want to store below my three sprites and let's call it interaction is going to be interaction with that the player knows where these kind of sprites are all we have to do now is check if the player is inside of this area and presses the enter button which we are doing if i minimize all of the methods this is going to happen inside of input all the way at the bottom of this method i need another if statement if keys are pygame dot a underscore return this is telling me if the player has pressed the enter button or not after i know that i want to know if the player collided with the bad sprite for example and this i want to store in collided interaction sprite this we are getting with pygame.sprite.sprite or lite and in here we need three arguments we need a sprite we need a group and we need what is called do kill the sprite in this example is just going to be self and we want to check the sprite so the player sprite against all of the interaction sprites which we get with self.interaction do kill is supposed to be false and basically what it means is if the player which is self in this example if this one collides with the sprite inside of this group do we want to destroy this sprite which in this case we don't want to do which is why this one is going to be false and now that we have that i want to check if collided interaction sprite exists in the first place or rather if it is truthy because that is only the case if it has a sprite inside if that is the case i want to check my collided sprite the first item inside that can only have a b1 and of that i want to check the name that is the name we have created here if this name is trader for now i want to pass but later on we are doing something else in here obviously if that is not the case which means we have the bad then i want to do something else one thing i do want to do in here is add self dot status is going to be left idle the main reason for that is if this is the player and we have the bad here if the player presses enter i want the player to point towards the bat it would be kind of weird if the player looked to the right then we press enter and then we start a new day it's kind of feeling bad let's try this one actually it should be working and we're getting an error that element property with does not exist do you mean with this happened inside of the level and here we need with now let's try this again this is looking better and now if i look to the right and press enter the player is looking to the left so this is working very good with that we can tell if the player is next to the bat and pressing enter so with that we can actually start working on the day transition for that we have two elements we need to cover first of all we have to basically restart the level in our case this just means all of the trees are going to get some new apples if they are still alive besides that we also have to play some kind of transition that indicates we have a new day let's start by resetting the entire level which is going to happen inside of level and i really want to hide the setup method this one is really large and all of the reset logic should be in a dedicated method called reset this one doesn't need any parameters and in here we basically want to reset everything which for now is just going to be the trees or rather the apples on the grease the way i approach this i first of all have to get every individual tree which i get with four tree in self.3 sprites dot sprites in here we actually have not too much work to do because if you look at the tree we have a dedicated function if i minimize everything we have a function called create fruit and this one creates all of the fruits that we need meaning all we really have to do is call tree dot create root although now we do have a problem because we are not destroying the existing apples that however is quite easily done all we have to do is for apple in three dot apple underscore sprites dot rights don't forget to call it and i want to destroy with the kill method all of the apples with that we're getting rid of all of the apples and we are creating new apples which is basically a reset what we now have to figure out is when to call this method because remember we are updating the level inside of the player not inside of the level class itself which means i have to connect the reset to the player although there's going to be another problem because besides the player this reset also needs to be connected to a transition effect how that is going to work is basically the entire screen is going to go dark then we are resetting the level and then we are making the screen go back to normal inside of this transition reset is going to be played here which means we need a system where the player the level and the transition all work together and this well let's go for it step by step first of all inside of the player for the ending method i want to have one more attribute this i called self dot sleep by default this one is going to be false if the player now presses enter and goes to bad all the way down here i want to set self dot sleep who rue that way we know if the player is sleeping or not and this we can use to start a transition that is going to happen inside of the level inside of run all the way at the end i want to check if player this should be self dot player dot sleep then i want to do something like self dot transition this one doesn't exist yet dot lay and this one is going to need delta time now this transition is going to be a separate class and this class is going to call the reset method once we are in a certain point of the transition animation which basically means inside of the init method i want to create self.transition this is going to be a transition class we will create in just a second and this one is going to get self.reset and it's going to get self.player with that we can actually create this new class let me save it as transition.pi once again we have to import pygame for the obvious reasons and we need from settings import everything the class we want to create is called transition no need for inheritance but i do need a dander init method because this one needs self reset and the player inside of this we first of all need to get the display surface because we want to be able to draw on the level itself this one we get with pygame.display.get underscore surface besides that we have to capture the reset method inside of an attribute and we have to do the same thing for the layer let me call this part here setup and besides that we are going to need an over lay image for the overlay image we are basically going to create a black image and then we are going to change the transparency or rather the blending mode but in this case this is going to be the same i'm going to explain this as we implement it but first of all i need self dot image and this is going to be pygame dot surface and the dimensions here we are getting from the settings because i want to have the screen width and the screen height let me copy this screen width paste it in here and the second one should be screen height this right now is giving us a surface the size of the entire window that is entirely black besides that i also want to have self dot color this one is 255 by default and then self dot speed this one is going to be negative two how these two attributes are going to work i think the best way to explain this is let's use them right away so i want to have some kind of play method that needs self and in here i want to self dot color plus equal self dot speed and that information i can use to fill my image so self.image.fill and in here i need an rgb tuple we need red we need green and we need blue in this case since we only care between a black and a white color they can all be the same color this image i now want to blit on top of the entire game which means self.displaysurface.lit i need self.image the top left should be a position zero and zero and for now let's just leave it like this and play it because you're probably confused at this point things are going to make a lot of sense in just a second or at least i hope they will first of all for all of this to work we have to import from transition import transition that means this one here is going to work and now inside of the run method layer.sleep is also going to work although here that's a time we don't actually need now with that let's try main.pi and let's press enter next to the bat and we're getting some very strange effect and we're getting an error message let's try it again really quick if i run this first of all we get white and then we go darker and darker and that is exactly what i wanted the entire logic is going to happen inside of play in here self.color on the first frame is 255 which with the fill method here means we are turning the entire image white all of these self.colors are 255 and those are the values for pure white and if you put this on top of the display surface we are getting a white image however now we are updating in this line the color which means on every single frame the color is going to be a tiny bit darker because of that we started with a white image and it became darker and darker and at some point this self.color got negative and this is where we got the error and this doesn't seem very much right now but we can make this look much better by adding another argument inside of the blit method the argument we need here is called a special underscore flags what we can do with this is set the blending mode the one we want is pygame dot blend underscore rgba underscore mult and now if i run this and try the same thing again now we have a much nicer transition this blending mode works it basically gets rid of all of the white values so the brighter a value is the less visible it is going to be and the pure white value is going to be completely invisible that way at the beginning we are not seeing any of this image but the darker it gets the more we see of it and at some point it turns the entire screen pure black although right after that the entire thing crashes that we do have to work on fortunately it's not that difficult all we have to do is if self dot color is smaller or equal than zero and if that is the case i want to set self dot speed and multiply it with negative one besides that if self.color is greater than 255 because now after these two lines we are increasing the color continuously and at some point it's going to be greater than 255 which is also going to be a problem we do need to limit that one as well if that is the case at least for now i want to set self dot color to 255 and with that we should be having a transition let me play main.pi and let's see how this is going to look we are still getting an error let's have a look i guess the main reason here is that once we get below zero we are only changing the speed we're not changing this number and as a consequence for this one frame things are falling apart but that we can fix quite easily all we have to do is set self.color to zero with that it should be working if i now walk next to the bed and this is working really well we are very nearly done there are three more things that we have to do let me write them all the way at the top number one we have to call the reset method number two we have to wake up the layer and number three we have to set the speed to negative 2 at the end of the transition i am pretty sure you can already tell where this is going this is going to be your exercise work through these three parts and try to implement them yourself and see how far you get the reset method i want to call when we are reaching this point here all i have to do is call self.reset because reset we have stored here and this is the one we created in level.pi and this is all we needed let's try this one actually i created it but never tested it meaning now let's have a look at some trees you can see we have two apples on most of those trees and now if i go to bed and look at the trees again they are looking different which means the reset method has worked next up we have to wake up the player that should happen once the entire transition is over all the way at the bottom self.player.sleep should be false on top of that while the player is sleeping i don't want the player to be able to move that would be kind of weird this happens inside of the player and all the way at the top here i only want to allow any kind of input if we are not using a tool and if we are not self dot sleep this one we can also test quite easily now if i press enter i would try to move to the left and i tried and now i can move again after a couple of milliseconds meaning this one is working as well finally we have to set the speed to negative 2 at the end of the transition this is also going to happen at the bottom all we have to do here is set speed to negative two with that we are done this is the entire transition i guess we should probably try this a couple of times but this is working once if i try again now and this is working again and it keeps on working just fine with that we have a daytime transition and this one is going to update all of the trees as well later on once we have plans we are also going to make updates to those and that i guess we can actually start working on next with the trees finished we can start working on the soil and there is going to be a ton of logic in here basically what we have to do is we need one class that covers all of the soil and this glass has to be connected to all of the watering and all of the plants which is going to be a very chunky python file just to warn you probably for the next hour maybe two we are going to work just on the soil you have been warned but for now just to get started let's create the very basic logic for the soil so if the player uses the hole we want to create one soil tile once again i am inside my project and i want to create a new file that i'm going to call soil dot pi in here i have to import by game and i need from settings import everything with that covered i want to create a new class called soil layer no need for inheritance but in here i want to have a init or done the init method with self and for now all sprites because in here each of the soil patches is going to be a dedicated sprite and to make them visible we have to attach them to all sprites as a consequence we do need them available inside of the class inside of this class i want to add one section let's call it sprite groups and in here i want to have self dot all sprites as my all sprites besides that since i do want to have easy access to all of my soil patches i want to create another attribute that i call self.soil sprites and this is just going to be another pygame dot sprite dot group after that we are going to need graphics and for now this is going to be very simple we have a single self.soil underscore surface and this is something we are going to import here we have the project i want to go to graphics and there we have the soil and in there we have a bunch of different things for now all i want to import is the file called o what all of the other files do you will see in the next major part for now just don't worry about them it's honestly better for you meaning all i want to do is pygame dot image dot load the path we need here is one folder up then graphics then we need soil and in the app we have o dot png with that we do have a setup but now we do have a couple of problems first of all not every single tile in our map should be farmable let me demonstrate this entitled actually here's the entire level and i think it should be quite obvious that not every single tile here should be farmable in fact i only want this area here to be farmable this is also going to exclude the house and the path none of these should be farmable only the stuff that is inside of this area i hope you can see what i'm talking about for that there is a whole other layer called farmable if i make this one visible you can kind of see what i am talking about only the pure green tiles here should be farmable meaning this is what we have to import and then only if the player hits one of these areas only there we are going to create a soil tile however now we do have another problem and that is that we have to manage quite a bit of data and this i want to address early because is becoming really important basically later on for every single one of the tiles we have to check a couple of different things let me add a couple of comments here in terms of what we need so requirements for each of the tiles we need to know if the area is far mobile that's the thing you have just seen besides that later on for the plants we also need to know if the soil has been watered and we have to know if this soil has a plant already for example if we want to plant a new plant we cannot plant that new plant if the soil patch has a plant already i hope that sentence makes sense meaning we need to have quite a robust way to manage all of this data as a consequence i'm going to store all of this information in one grid that for now is only going to store if we have a farmable area or not but let's do all of this in a separate method that i called create soil underscore grid in here we don't need any parameters and in here i want to create one list that contains other lists and one list for each tile of the game let's do this in tiled actually so when you look at these specific tiles here each of these cells is one tiled and in the grid i am going to create every single tile is going to be one list and this list is going to contain a couple of different pieces of information the one we are going to care about now is if it is farmable or not which i'm going to do by just adding a capital f inside of the list if it is farmable and well there's not going to be an f if it's not farmable that way we can always tell which one we have although to create this we first of all have to know how tall the map is for that i have to import the background image or the floor this one i get with pygame.image.low the file path here is one folder up then we have graphics then we have the world and then we have ground dot png this one we don't have to convert because we're not going to show it to the player instead what i want to do i just want to know how many tiles we actually have in the entire thing i want to know how many horizontal and how many vertical tiles we actually have this information i get by simply taking the whole width and dividing it by the tile size for example for the horizontal tiles i want to get my ground and then get underscore with and floor divided by the tile underscore size this i also need for the vertical tiles and this i can all do on one line so v tiles in here and this one i get with ground dot get underscore height although this one also has to be floor divided by tile underscore size i guess while we're here let me actually print the h tiles and the v tiles also i do want to call this method here in the indented method so self.create soil grid although first of all i do want to create this soil file inside of my level that way i can show you what the progress is while we are making it that should make all of this easier to follow all i really want here is from soil import soil layer this soil layer should become an attribute let's call it soil underscore layer and here soil layer really important we have to pass in one argument and that is going to be all sprites which we get up here and now if i run all of this we can see we have 50 horizontal tiles and 40 vertical tiles which if i look at tiled and look at map and mid properties we have in the top left the width and the height and this is 50 and 40. so this one is working just fine this i can now use to create a list of lists with every single tile being one individual list this is going to happen inside of soil.pi and what i want to create is self.grid this one we are going to do with list comprehension and let me add a bit of white space in here because this one gets slightly more complicated first of all i want to go through every single one of my columns and i want to create an empty list for my column in range h tiles although this is only a single one so i'm going to put this in another list comprehension which is going to be for row in range v tiles now i can get rid of the white space and let me just print what we actually get so self.grid run all of this and we are getting a very long list of lists the entire thing is one long list inside of this list we have one list for each row inside of the game and then inside of this row we have one more list for each individual cell now that we have that we have to actually check inside of tiled let me open it again we have to know which of these tiles are farmable and for that we need pi tmx again meaning i want from pi tmx dot util underscore pi game import load underscore pi game once i have that i want to use load pi game and load my tmx data file that i get by going up one folder there we have data in there we have map.tmx since we are only going to use this once i can use a method straight away and that is get layer by name the layer we need is called farmer bill and on this one we want to get the tiles because this one allows us to use all of this inside of a for loop meaning in here this is the one we have already seen we have for x y and a surface in load pi game although for this one we don't really care about the surface meaning i'm going to use an underscore to just ignore it or to indicate that i don't care about it what i now have to do is to figure out which of these grid cells corresponds to the x and y values and then add a capital f for each of those which is honestly very simple all i need is self.grid and first of all i need the row which is the y position this is going to give me another list and on this list i want to get the x position which is the column and now i'm getting a list and i want to append a capital f to that that is basically it if i now print self dot grid and run all of this we are getting an even stranger list what we're seeing in here is every single cell where we have a capital f this cell can be farmed what you should be seeing here actually is the first couple of lists should be entirely empty because on the top of the map there's nothing farmable and we only get a bit further down an actual f tile i suppose we can make this a bit easier to read by going for row in self dot grid and then print the row if i now run all of this this is well still very difficult to read but you can see it a tiny bit better this one here is the first row there's nothing and this continues for a couple more rows quite a few actually and at some point for this row here we have a couple of empty cells and then we start having four cells that are actually being farmable if i look at this inside of tiled you can see on the first row we have a lot of nothing and then we have four cells that are going to be farmable which is a pretty good sign that this is going to work i guess for one double check on the next row we have a couple more cells that are farmable and then we have a gap and a few more cells let's check this one out on the next row we have a gap then we have six thumb cells then we have another gap and then a few more farmable tiles so this is looking pretty good with that we have a grid that can store at least one bit of information it is going to get a bit more complicated later on actually what we now have to figure out is how the player can hit all of those with the whole for that i want to create another method and this i called create hit rects no need for any kind of parameters here and what we are going to do is for every single tile we are going to create a rectangle that the player can hit this i'm going to store in self.hit rex which is just going to be a list and now i have to cycle through myself.gridlist and convert all of the cells into actual positions and for that i am going to need the enumerate method let's go through it slowly i first of all want to get for row in self.grid and inside of that i want for cell in row let me give a bit of white space here to explain what is going to happen we essentially have a list that is going to contain let me draw it really quick so we have a couple of lists and inside of each list we have a few more lists the first for loop this one here goes through all of the lists and then the inner for loop this one here goes through these lists here which is basically horizontal axis the problem we have right now is we need to know on what list we are on for example we have to know that this one is list 0 this one is list 1 this one is list two and so on and for that we need enumerate i want to put both of these inside of an enumerate function that way we are first getting the index we are on and then the actual information let's call this one the index row and the second one i called the index column inside of this we can actually check every individual cell and i want to check if f is inside of this cell if that is the case i want to create an x position i want to create a y position and then i want to create a rectangle and this rectangle i want to append to myself dot hitrex dot append dot rect and now for the position and the rectangle i think this could be a really good exercise i hope you're not entirely lost at this point but try to figure out we are now creating a couple of rectangles and for each rectangle we have to convert the position in the grid to an actual xy position inside of our game so try if you can figure this one out we know where each cell is inside of the grid we also know what the tile size is if you want a hint but pause the video now and try to figure this one out yourself this is actually fairly simple all we need for the x position is the index column multiplying it by the tile size for y this is going to be the index row also multiplied by the tile size finally then for the rectangle we have pi game dot rekt and in here we need x we need y and then we need the tile size and the tile size meaning for this rectangle x and y is the top left and the tile size is always going to be 64 by 64. and that way we have a rectangle created for every single cell that has an f do not forget to call this one now self dot create hit rex and now we actually have something the player can hit although i guess for this one we have to create another method let's call this one get hit in here we need self and i want to have a point and this is the point the player can hit in here i want to check for rect in self dot hit underscore rects and i want to check for each rectangle if the rectangle was being hit by the point we have specified in the parameter which we get with rect.collide point and the point we are getting from the parameter if that is the case i have to convert this rectangle position back into my grid and that way i can identify if i have a list with an f or not and well for that i have to do basically the opposite i have done here i need an x and i need a y position and for the x i want to get my wrecked dot x and floor divided by the tile size this i also want to do for y except now it's rect.y floor divided by the tile size the way you want to think about it let's say we have one tile here and another tile here the first tile starts at position zero and zero the second one at position 64 and zero these points here if we now for example for x have something like 91 if i floor divide 91 by 64 we are going to get one which is going to be this tile here that way i have converted a pixel position this one here into an actual tile position that we can use to get information from this self.grid and with that i can check if the string f is in self.grid and once again we have the entire list of lists we first want to get y for the rows and then we want to get x for the columns and now if that is the case i want to print let's call it farmer bill what we now have to check is how to call this self.gethit my solution to that is i'm going to pass a reference to the entire soil layer into the player which happens inside of the level inside of the setup method when i create the player the player is going to have one more parameter that i called soil layer this is going to be self dot soil layer that way inside of the player i can create another attribute soil layer don't forget to turn this parameter into an actual attribute self dot soil layer is soil layer and now when we are using the tool i can get rid of the print statement and when we're using the whole i want to get self.soil layer and that way i can target or use this method here which means inside of player i want dot get it and the position is the same target position we have used for the x target position in here and now this should be working let's try although we're getting an error the level object has no attribute soil layer let's have a look inside of level we need a soil layer and i think i just called it soil ah no the problem is i am creating soil layer after the setup method that is a very easy thing to fix all i need is the soil layer before the setup method now if i run this there we go and i can use the whole and we get farmable if i use this here but if i go further to the right and use it here we are not getting anything and let me make this a bit smaller there we go with that we know where we are hitting something or more importantly if that is farmable or not if that is the case i want to get myself dot grid with the y and the x and append a capital x this is telling me that on this tile we have a soil patch once i have that i want to run another method that i call create soil tiles this one for now is going to seem quite weird but it is going to make much more sense in the next video but for now all that this create soil tiles is going to do we need self in here as always i want to get rid first of all of all of the existing soil tiles which i get with self.soil sprites dot empty after that i want to look through the entire grid and wherever there is an x i want to create a soil tile which means once again i can basically copy all of this here paste it in there and in here what i want to check is if capital x is in the cell and if that is the case i want to create a soil tile this one doesn't exist right now let me minimize a couple of methods so we have a bit more space we don't need any of this although at the top i want to create another class that i call soil tile this one is a sprite so we need pygame.sprite.sprite after that we have to create a dunder init method this one itself a position a surface and the groups it's supposed to be part of then we have to call this super dunder init method and pass the groups in here after that we need self.image this is just the surface we're getting from the parameters and we need self.rect this one we are getting with self.image.get underscore rect and the top left should be the position the position and the surface here are really important finally this one is going to need a self.set position this one fortunately is very easy because if you look at the settings we have a dedicated layer for the soil this i want to copy and paste it in here and now we have a basic soil tile all we have to do now is to pass in all of the information into the class to create it for the position this is something we have already seen inside of create hit rectangles we basically want to do this one here again i guess i can just put it straight in here and with that we have the position the surface we also have that is inside of the dunder init this soil surface here this is what we want to paste in there finally for the groups i want to have self dot all sprites because they are supposed to be visible and then self but i called this one the soil sprites soil sprites and since this is getting quite long let me put it over multiple lines we have the position we have the surface and we have the groups that is much easier to read and with that we should have a basic start let's try all of this if i now hit the floor we have a soil tile this is working really well and if i hit some other field we are not getting anything with that we have the start of this soil tile and we also have a really efficient system to organize our data which is really important although this is getting a very long section so let's finish it for now let's keep on working on the soil patch graphics the one really important thing i want to cover in this section let me demonstrate it when we place one patch it looks like this when we place another one right next to it it looks like this which is okay for a basic game but ideally it should be looking something like this that is what we are going to create in this section we are going to create our own auto titling system that creates nice looking soil patches this is also the reason if i jump into my code inside of soil layer we have this weird setup here that every time the player is hitting the soil we are getting rid of all of the soil sprites and then drawing them from scratch what this allows us to do is to draw all of the soil patches together and that way we can control different graphics depending on the position of each soil patch or rather if one patch is next to another patch then they should get a specific kind of graphic that is what all of this here is for although for all of this to work we are going to need a whole lot more graphics this is going to happen all the way at the top right now we only have a single soil surface instead what we need if i open the folder again inside of graphics inside of soil we have to import all of these different elements this is what i've shown earlier and now basically what all of them do i guess i can't really make them larger but if you look at them individually for example here we have the left tile this is going to be placed if there is one tile to the right of this tile we also have a tile called lr short for left and right this one we want to place if there's a tile to the right and another tile to the left there's also a file called x all the way at the bottom and this one is supposed to be placed if we have tiles all around it so i hope the logic here makes sense basically each of these tiles is going to be placed relative to where the other tiles are but for that we have to input all of them now this i want to save in self.soil underscore surfaces and in here you might be tempted to use the support file this one here and use import folder that however would not work because we need to know which file we are working with in all of the examples so far we didn't really care about what specific image we had we just used all of them but for this one we need to know which tile we are working with as a consequence i want to create another function in here i want to create import folder dictionary we again need a path although now we want to create a surface dictionary what i want to have in here is obviously a key value pair with the value being a surface one of the surfaces we are going to import however the key should be something like right it should be left it could also be something like x or lr and this is what we are getting from the folder so i want the key to be the name of each of these files and the file itself the value and that is what we have to create in here and this i believe could be a really interesting exercise look at this logic here and adapt it so that we are creating a dictionary with key value pairs and at the end of it return the entire thing pause the video now and try to figure this one out a lot of the stuff i can just copy the first three lines are going to remain identical because in here we are just accessing every individual file path that we are going to need so no change so far as a matter of fact the surface is also going to remain the same so a lot of the stuff remains identical the one difference now is when we are getting the surface dictionary i don't just want to append something instead i have to get a specific key or rather i have to create a specific key this i want to be the file name which i get with image and the image right now would be something like l dot png the png i do want to get rid of that i'm getting with split i want to split it wherever we have a dot and then i want to get the index 0 of this list this is always going to give me the name of the file without the file ending this is going to be my key and the value is going to be the image surface and that is all we needed all we have to do now is to return this surface dictionary and we are good to go now back to soil.pi and in here i have to import from so port import let's say everything and now i want import folder underscore dictionary and the file path i need is this one here i guess just to try if this is working let me print self.soil surfaces and run the entire thing the game doesn't crash that is generally a good sign and now we are getting what i wanted we have a key with for example b this stands for bottom and we have a surface associated with it in this we have multiple times these are all of the files that we wanted with that i can close the support file because we are not going to need it anymore i can also get rid of the print statement here this one isn't needed either and with that we are coming to the really fun part basically what we now have to do is to create the entire auto tiling option so let me go through step by step first of all i want to add let me call it tile options in here i'm going to determine what is to the left to the right to the top and to the bottom of the current cell which means we are going to cycle in here through every single cell in our grid one cell could look like this i have to know what is on the right on the left on top and on the bottom this is going to determine what graphic we are getting in here so first of all i want to have easy access to all of these options which i'm going to store in a variable we have top we have right we have left and we have bottom i want to check if we have a capital x in for example for the top self.grid and then usually we went with y and x although those we don't have available right now but we do have the index row and the index column those we can use index column is basically x this one we can use like this and y is going to be the index row this we can use here although for the index row since we do want to have the cell on top of our current cell this needs to be negative one and i guess while we are here we can also do the bottom because this one is very similar we can basically copy the entire line and instead of a negative one we have a positive one for right and left we are also checking for a capital x except now we are checking in the row and we're checking index column 1 this is working because we have the row quite easily accessible and this we can use this i want to copy one more time oh and i just realized right should be plus one and left should be minus one and with that we know for each of the tiles what the neighbors are doing now this system is still fairly simple because if i open the graphic again for most of the tiles we are only checking the four directions but there are four more we have the top right the bottom right the bottom left and the top left i am not going to check any of those because that would become incredibly complex and i don't really need it but if you want to have a proper auto titing system you would have to do it which would lead to a ton of if statements but let's go through it one by one now first of all i need to get some kind of tile type and this by default is going to be an o if i open this thing here again o is the default one the one we have already seen and this is a nice default one if everything else fails having this one probably isn't going to be too bad and now this we can use inside of soil tile because in here we have a surface this i want to replace with soil surfaces which is a dictionary and this dictionary i can access with my tile type and let's try this one right now if i run main.pi and use the whole everything works just as before that is a good sign and what i can do now i could for example change this to an lr run main.pi again and now we are getting a different kind of tile all we have to figure out now is to make all of this a lot more flexible which is going to involve a huge amount of if statements let's start with the really easy one all sides this one should illustrate the logic here quite well basically what i want to check is all of these are either true or false and i want to check if all of them are true this could for example be if l and b and r and l if that is the case i want to have the tile type to be an x this should be an equal sign and now let's try this one so here we have the center tile and i want to create tiles to the left and to the right and now to the bottom and there we go the thing updated this was the easiest kind of side although this we can clean up a tiny bit this we're doing with the all function and the all function checks if all values inside of an iterable like a list are true meaning in here we can pass t r b and left and we should be having the same result also let me put all of this on the same line because we are going to have a lot of lines let's try this one again it should still have the same result and it does this is looking really good that is covering all of the sides so next up we can start working on the horizontal tiles only this means i want to check if i have a tile and if there is a tile to the left or to the right or to both sides meaning we are going to have three different if statements here the first one we want to check if l is true so there's a tile left and not any inside of top right and bottom any kind of works like all except now we want to check if any of those is true for all to work all of them have to be true for any to trigger only a single one in there has to be true and let me illustrate the logic here let's say we have a tile like this and we only want to check if there is a tile on the left of it this is what we are doing in here if this is true we would ideally want some kind of graphic that would look something like this this would be working by itself but we also have to check that there are no tiles on top to the right or at the bottom of this tile which is what we are doing here if that was the case we would be needing some kind of other condition which we are going to do in a bit but i do not want to confuse the different if statements here each of those should be unique if that is the case though i want to have my tile type and now the tile should be right which means if a tile only has a tile to the left and nothing else we want tile type to be right let's try this one i have a tile here and if i had another one this one is going to be to the right i can continue doing this and now you can kind of see the one to the right works really well but the one in the middle gets a bit confused but that is something we can work on although first of all i can cover the right side which is kind of simple all i need is if r is true and now this should be t l and b we are basically doing the inverse of this one here and this one should be l then i can copy this one more time and now i want to check if we have a tile to the left and to the right which means i want to check if r is true and if l is true and if we don't have top and bottom if that is the case the tile type i want is left and right with that i should be having the horizontal logic if i run this now i can create some tiles here and this is looking very good although if i go down we are getting some weird results but that we can start working on in the next part which is going to be vertical only in here i want to check if we have a tile on top and not any tiles inside of the list right left and bottom if that is the case the tile type i want should be autumn i can copy this one more time because now we can check if we have a tile at the bottom and i also want to check if we have no tiles to the right to the left and to the top if that is the case i want to have a tile with the type t finally one more time now i want to check if we have a tile on the bottom and on the top and not do the right to the left and that is it if that is the case the tiles i have are t and b with that we have the vertical tile types let's try this one so now if i only go down this is also looking really good and i can still use the horizontal ones as well although now if i connect them we are again getting weird results which means we need some more if statements let's go with the corners for this one if this is the tile i for example have to check if there is a tile to the left and the tile to the bottom if that is the case this should be a corner like that which if you could follow along so far should be fairly doable it's going to look kind of similar compared to these lines at the end here let me copy it actually for this one i want to check if we have a tile to the left and a tile to the bottom and i do not want to have a tile on the top and the tile on the right and if all of that is the case i want to have a top right tile this logic is going to continue like that so let me just copy from my notes it's going to look like this these are all of the different kind of corners we could possibly have if i try this one now i can go down and now if i go to the right we have a corner the thing we are still missing though are t shapes because if i do this things are falling apart once again which is going to be another section and this is going to be t shapes in here for example i want to check if we have a tile and there is another tile on the top on the bottom and to the right if that is the case i want to have this kind of t shape which means in here i want to have if all and the tiles i want to look at are let's start with top bottom and right also i have to check and not left if that is the case i want to have a tile type of ebr let's try this one now i have my tile and i have a tile to the top to the right i'm at the bottom and to the right and there we go we have a t piece and now if we add one more direction we have an x piece so this is working just fine this i now have to copy a couple of times because we have to cover the other sides as well next up would be top bottom and left and not right if we have that we have a title called tbl copy it one more time now we have left right and top and not bottom if that is the case the tile i want to use is called lrb finally the last one i want to check if we have left right and bottom and not the top and if that is the case i want to have lrt and with that we should have a proper auto titling system so let's try the entire thing now i can just go around create more tiles this is looking pretty good and yeah i'm quite happy with this although you can probably see there are some minor thingies these little bits here they exist because the auto titling system here is not perfect for example this tile here is technically a corner tile where we have a tile to the bottom and to the right and corner tiles always have this kind of bit here at the end this we could get rid of by adding a bit more logic for this tile to also check if there's something for the bottom right although in my case i think this looks fine and if we added more logic here this would become even more complex and i think this is already quite a lot of if statements so i'm going to leave it as it is and now i can minimize all of this and we have definitely made a ton of progress for this part we are going to work on the watering logic which with the current system in place isn't all that difficult to do let's jump right in and let's do it step by step once more we have the entire project and i want to start inside of the player let me minimize everything and we already have the use tool method here inside of there we have selected tool being water if that one is being triggered i want to once again get myself the soil layer remember here the player has access to the entire soil layer this we have also used for the whole however now i want to use a method called water which doesn't exist right now but will in just a second and here once again we need our target position and with that we can return to the soil file and all we have to do now is to create another method let's do it below get hit i call this one water in here we need self and the target position what i want to check in here is if this target position hits any of the soil sprites any of those here oh also i forgot the soil surface we can get rid of because we don't need it anymore for the water i want to check for soil sprite in self.soil sprites and there's already typo in there dot sprites i want to check if soil sprite dot wrecked dot light point and in here i can add my target position and let's try this one first if that is the case i want to print soil tile watered and the rest should already work let's try i want to create a water tile change to the watering can and now use it and we get soil tile watered which means this here is already working this means i have to do two things number one i want to add an entry to this soil red which means i want to add a capital w to the cell besides that number two i want to create a water sprite this is going to indicate that there is water on this tile let's start with number one in here we have the same problem again we have a position for this soil sprite but we need a cell position which means we have to do some conversion we need an x position and a y position and what we need in here is the soil sprite dot rect.x floor divided by the tile size this i want to do again for y let me copy the entire thing except now this should be rec dot y that way i can use these positions to access the grid which i get with self.grid and now i want to have my y then i want to have my x and then i get a list and to this list i want to append a capital w that way we know which tiles have been watered and which ones haven't besides that number two i want to create a water tile to visually indicate that we have indeed watered this soil tile this water tile i want to create inside of this python file which is class water tile once again this is going to be a sprite so pygame.sprite.sprite we also need a dunder init method for the obvious reasons this one needs a position a surface and the groups and we also need a super dunder init method this one gets the groups as well although this class is going to be fairly simple all we're going to do in here is self.image is what we're getting from the surface self.rect is going to be self.image.getunderscorerect with the top left being the position like this and finally we are going to need self dot z this self.set we are getting from layers and inside of settings we have a soil water layer this i want to copy and paste in here i guess if you're being specific here this water tile and the generic tile are basically identical but i do want to keep things as separated as i can here but you could be a bit more aggressive with inheritance here it's entirely up to you and with that we have the water tile i just have to call it now and for this one we need a position we need a surface and we need the groups and that is going to be your exercise there are a couple of steps to it number one copy the position from the soil sprite meaning this water tile should be in the same position as this soil spray here which should be very easy to get number two for the surface i want you guys to import the folder with the path let me copy it really quick the path is going to be this one from this folder randomly select one surface finally i want you guys to create one more group let's call it water sprites and the water tile should be in all sprites and inside of water sprites so pause the video now and try to work through all four of those tasks and see how far you get i guess to make it easy to read let's store it in a separate variable but all we really want in here is the soil spread itself then dot rect which stores the position and then top left that is basically it for number two we have to import another folder and this should happen inside of the init method let's do it right below graphics it does seem to make sense here i call this one water underscore serves and in here we only want to import a folder which means import folder the file path being this one here in case you are interested if i open the graphics part we have soil water and in there we have three different water kind of tiles from those we want to select one randomly again let's do that in a separate variable let's call it surface and in here i want to use the choice function which we don't have yet but we can get it with from random import choice and i want to get a random self dot water surface and this is going to be part number two and three actually finally we need one more group this i am going to do up here and i want to create self dot water underscore sprites i think i called it yes this is going to be just another group so let me copy it and there we go now when we are assigning the groups i want to have self dot all sprites and self.water sprites and that is all we needed with that i suppose i can get rid of all of the comments because they are getting a bit annoying there we go this feels much better and now if i run main.pi again i can still use the hole and if i now use the water we have a water tile and i can do a couple more tiles and use the watering can again there we go this is working really well the last thing we need is that once i restart the game i want to destroy all of the water tiles and also get rid of the w for every single tile that is going to be a separate method let's call it remove water no need for any arguments in here and there are two things that we have to do number one is we have to destroy all water sprites and the second one is clean up the grid the first one is really simple all we need is for sprite in self.water sprites dot sprites and i want to just destroy all of the sprites that is going to be the first part the second part is going to be for row in self dot grid and then for cell in row what i want to check in here is if there is a capital w inside of this cell if that is the case i want cell dot remove and the capital w all i have to figure out now is when to call this method this is going to happen inside of level.pi in here once again let me minimize everything and i want to work inside of the reset method there is going to be another section let's call it soil and all i have to do is self dot soil layer and remove underscore water if i run main.pi again i can create a couple of soil patches water them and now if i restart the day this is still working fine and there we go this is looking really good so with that we have the watering logic we are not quite done yet with the watering logic because we need the rain this is going to consist of two different parts number one we need the actual rain animation so that the player can tell if it's raining or not besides that if it is raining i want to automatically water all of the soil sprites so that is what we're going to work on let's jump right in back in the code i want to create a new file that i want to save as sky dot python in here i want to import pi game and i also want from settings import everything and i want to create a class called rain there is no need for inheritance but i do want a dunder init method although in here all we want is all sprites once again so that we can draw in here without having to leave the class itself this we have to save inside of an attribute so self.all sprites is going to be all sprites once we have that i want to have a few more graphic files we need self dot rain underscore drops and i want self dot rain underscore floor both are going to use the import folder function except with a different path as a consequence i have to import from support import let's say import folder for this one just to have a look at them inside of the project i have graphics and in there i have rain in here we have drops and floor drops are very simple raindrops basically just straight lines for the floor we have a whole animation or it's not really an animation we can just play them separately but this is what we are going to import let me just copy the file path it is going to be this one and it is going to be this one there's one more thing that we do need and that is we need to know the size of the entire map basically what is going to happen if this here is the entire map i want to randomly create little rain animations all throughout it and for that to work i need to know how wide the entire map is and how tall the entire map is that is information i can get from the ground image which we have to load with pygame.image.load and for this one let me copy the file path as well it is this one and this is literally just the ground nothing else all i want to know is get size and this i want to store in self dot let's do it via two variables we have floor w and self dot floor h once we have that we are going to need two separate methods one for create the floor and besides that we need create drops and after that i want to have an update method that is creating both of those so self.create floor and self.create drops in here now we have to figure out what to do in my case all i'm really going to do is create a drop class which doesn't exist yet so we have to create it and this i want to create inside of this file as well plus drop now this is going to be applygame.sprite.sprite although i do want this to inherit from generic to save me a bit of writing as a consequence i need from sprites import generic i am getting much worse at spelling essentially what i want to do is to import this generic class here we are using this all throughout and you could even put the drop in here it would be perfectly fine but i think in here it does make a bit more sense all i want is to create another indent method in here we need self we need a surface we need a position we need to know if this one is moving or not then we need the groups and then we need a z position and how the drop is going to work it is going to be kind of similar compared to if i minimize all of this it is going to be kind of comparable to the particle we're going to create the object for a short period of time and then destroy it which means we are going to have a timer for each object and then destroy it after a couple of milliseconds now for that i want to have a random live time which i'm getting with randint which we don't have in here yet meaning from random import rand int the duration here i want to go with 400 to 500. besides that for the timer i want to have self.start time and this we get with pygame.time.get underscore ticks also let me comment here that this should be the general setup because in here i guess this should be at the top i also want to have a super dunder init method the arguments we need for this one are the same that we have for generic we need these four all four of them are going to come from the attributes that we are passing in when we are creating the drop so there isn't anything we have to do right now although what we do have to do is to work on the moving part basically how that is going to work if we have a raindrop so the things that are going down those are supposed to be moving whereas the raindrops on the bottom so the round things those are going to be staying in place which means i want to have another attribute that i called moving and this is going to capture the moving parameter if self.moving is true then we need a position and this is going to be pygame.math.vector2 and self.direct.top left besides that we also need a direction and the direction here is going to be pygame.math.vector2 and for the value here i went with negative 2 and 4. those directions mean we are going 2 units in the negative direction and we're going 4 units down as a consequence our actual movement is something like this finally we need self self.speed which is going to be a random value as well between 200 and 250. now these three attributes is the same thing you have seen a couple of hours earlier inside of the player so if i show the init method somewhere here we have direction position and speed these are the attributes you basically always need to move anything inside of pygame finally i want to have an update method in here don't forget we do need delta time and i want to check if self.moving if that is the case self.pos should be plus equal self.direction multiplied by self.speed multiplied by deltatime and once we have that self.rect.top left should be rounded self.post.x and rounded self.y we are basically assigning the top left of the rectangle to position.x and we're using round to avoid the truncating that pygin does by default this is going to be the movement and besides that we are going to need a timer that i want to destroy this timer if it has lived longer than the lifetime and this is going to be your exercise create the timer that you are destroying this sprite after the lifetime has run out pause the video now and try to figure this one out all we need here is pygame.time.get underscore ticks this is getting our current time from that i want to subtract self.starttime if that difference is greater or equal than self dot lifetime we know the lifetime has been exceeded as a consequence we want to kill this sprite and that is all we need for the drop now we just have to create it inside of here and inside of here so let me copy all of the parameters we need and paste them in here and in here or create floor the surface is going to be self dot rain drops and from this we want to randomly select one of them for that we need choice which we don't have yet but we can import it very easily for the position i need to have an x and a y position for x this should be a number between 0 and the width of the map that is what we created up here which means i need rand int that goes from 0 all the way to self.floor width and this i also want to do for the y position and this should go from zero to the floor height next up we have moving for the floor tiles this is going to be false then we have the groups and the groups are going to be quite simple because in here all we have is self dot all sprites finally we need the set position and for this one if you look at settings we have rain floor this i want to copy and paste it inside of layers and there we go this is all we need for the floor and now i can basically copy all of this and do the same thing for the raindrops it's going to be fairly similar for the surface we want to have rain this should actually be raindrops and here this should be rain floor sorry about that the position can remain the same moving should be true ropes can remain the same although for the set position we have raindrops that's the layer all the way on top this i want to paste in here and there we go this is covering the entire rain class so let me minimize the raindrop and basically everything in here as well all we have to figure out now is when to call this rain method here and that is going to happen inside of the level first of all i want from sky import rain this i have to turn into an actual object let me add another comment here actually to organize this a bit better let's call it the sky because there's going to be a bit more in here we have self.rain and this is going to be the rain which needs self dot all sprites besides that i want to have another attribute here that i called self.raining and this by default let's say for now it is going to be true so it's easier to test but later on this is going to be random and now inside of the run method before we are doing the overlay let me add a few comments here actually transition overlay i want to have my rain all i have to do for that is check if self.raining is true and if that is the case i want to have self.rain.update that way we are calling this update method here which is going to generate raindrops and those drops we are going to see hopefully in the game so let's try and there we go we have the rain and honestly this is actually a fairly simple effect all we are doing is we are creating random sprites that are either moving for the rain or that are staying static on the bottom and well this is the entire rain graphic if we go over this it really isn't that complicated or at least i hope it isn't with that i can close the sky.pi file although we are going to see it later but for now we don't need it what we need now which is much more important we have to update all of the soil tiles if it is raining and for that inside of soil.pie let me minimize everything once again because this is getting quite extensive i want to create another method that i want to call right below water water underscore all no need for any arguments in here and once again i want to go through all of my grid cells for that let me copy the nested for loop again one more time and paste it in here i want to check if there's a capital x in the cell and w is not in the cell already which basically means we're going through all of the cells and we are checking if there's an x meaning there's a soil tile but this soil tile hasn't been watered yet but we do want to make sure that does get watered which means first of all i want to append a w to the cell and after that i want to create all of the water tiles again and in here let me copy it from the water we basically want to copy this entire thing although we do have to make some changes because for this one we have a position inside of a cell and this we have to convert to an actual pixel position the main thing you have to understand about the soil layer is we are working with two different systems one is we have all of the positions inside of the grid and that is basically a table besides that we have all of the pixel positions in the actual game switching between them is really simple in this case we need an x and a y position and those we get for x it's going to be the index column multiplied by the tile size and for y it's going to be the index row multiplied by the tile size this x and y we now want to paste into the position for x and y and we are good to go the surface is going to be the same surface we had up here i just want to pick a random water tile i can just paste it straight in here and the groups can remain identical those work just fine with that we have a function that can water all of our soil tiles we now have to figure out when to call it and this has to happen in two separate places number one is when we get hit or rather when the soil gets hit we are attaching an x inside of the cell here if that is the case i want to pass in if self.raining which is not something we have yet but we are going to in just a second if that is the case i want to call self.water all the problem we have right now is that the soil layer doesn't know if it is raining or not this we only know inside of the level although that is a problem that is very easily fixed all we have to do inside of the init method after we have set the rain i want to get myself dot soil layer and set raining ooh self dot raining also when we are resetting the day i have to do the same thing which means in here in a bit i want to randomize the rain every time we are resetting the day once we have updated that i want to get myself dot soil layer again and set raining back to self dot raining and now we always know if it is raining inside of this class here which means if i run main.pi and i use the whole we automatically get water sprites this is looking really good and if i switch off the rain all the way at the top here so raining should be false let's try this now we don't have rain and we don't have water at least not by default so all right with that we have some basic rain logic although what i also want when we are resetting the day and it is raining i want to automatically water all of the existing soil tiles because right now in the logic here we are only watering new tiles we don't water existing tiles which means when i'm resetting the day i want if self.raining is true then self dot soil layer dot water underscore all let's try this one oh and i do have to switch on the rain and to test this one let's randomize the rain meaning when i'm creating the rain i want to have a random chance to create a rain which i'm getting with rent int which i don't think i have available yet i do not i need from random import rand int and in here i'm just creating a number between 0 and 10 and if this number is let's say greater than 7 this is going to be true although for now for testing purposes i'm going to set this number to a free which means we're going to have a ton of rain this i also want to do down here actually i can copy the entire line like so and now for every day we have a pretty high chance to generate rain if i run this it's raining right now but we can still get started and let's go to bed and let's hope there we go now there's no rain so there's no water on them and i guess let me water one of them just for testing purposes if i now go to sleep again it's not raining now it's raining again and all of the soil tiles have been watered so this is working really well very nice and with that we have the basic watering logic so another major step forward next up we can start working on the plans let's get started with the plans since we already have a ton of logic in the soil this shouldn't be so bad actually but once again let's go for this step by step the very first thing we need is inside of the player we need to know if the player is planting some seeds for that we already have a method that is called use seed right now there's nothing in there but that is going to change i want to get this soil layer once again and now call a method that i called plant seed for this one we need two arguments the first one is going to be self dot the target position the second one is self dot selected not tool but seat and i hope this makes sense we have to know what target we are hitting and we want to know what kind of seat we are using this is all we need inside of the player and now in the soil in the soil layer i want to minimize all of the methods and let me put it let me put it all the way below the water in here i want to have planned underscore seat we need self we need a target position and we need a and once again we have to check if we actually hit a soil sprite which we get before soil sprite in self.soil sprites dot sprites i want to check if soilsprite.rect.collide.point and the point i want to check is the target position if that is the case once again i have a pixel position and this i want to convert to a position inside of the grid which means i need my soil sprite or direct.x and floor divided by the tile size i can duplicate this line and change the x to a y and that way i'm getting my y position inside of the grid if that is the case i want to get myself dot grid with my y and x this is going to give me the cell and i want to append a capital p short for a plant that way we know we have a plant inside of this cell now this should only be possible once which means i can already check if a capital p is not in self dot grid with y and x and only if that is the case i want to create a plant now that we have that i want to create a plant object this i am creating also inside of this python file with class land and this one is also going to be pygame.sprite.sprite i want to have a dunder init method with self we need a plant pipe so do we want corn or tomato then we want groups next up i need the soil for the positioning and let's say that's it for now as always i need the dander init method with the roots i have to convert the plant type parameter into an attribute so self.plant type is plant type and then i have a couple of frames depending on what kind of plant we have meaning here's the project i have graphics inside of there we have fruit and there's corn and tomato not the best naming but it really doesn't matter inside of corn we have these different files and inside of tomato we have those this is what we are going to import this we get with import folder and the file path here is let me just copy it right away we have to go into graphics and fruit and in there we have two subfolders and those subfolders i want to get with an f string because what we can use in here is the planned type besides that we need self dot h by default this is going to be zero after that we also need self.max h so that we know when the plant is reaching the full h this we can get with self. frames and get the length of it and subtract 1 from that finally i want to have self.grow underscore speed which is telling me how fast this kind of plant is growing and for that inside of settings i have a dictionary this is what i want to use meaning i can use grow speed in here and then get the plant type i guess i should really comment all of this a bit better to make it a bit easier to understand let's call this section here the plant growing and this stuff at the top is going to be the setup also there's one thing i forgot we have to turn the soil into an attribute so self.soil is going to be soil once we have all of that we can work on the sprite set up first of all here we need self.image this is very easy because we have a bunch of frames i want to use self.h for the indexing besides that i have to create self.rect this i'm getting with self.image.getunderscorerect i want to place the mid bottom and the position i'm getting from soil.rect.mit although here we have a problem this is going to be the size of a soil tile but each plant is going to be about this tall and since we're placing the bottom of the plant at the bottom of this soil tile we're going to be somewhere here and i want there to be some kind of offset this i created separately and i called it self dot y underscore offset this is going to be negative 16 if the plant type is equal to corn and if that is not the case it's supposed to be negative 8. the reason here is that the various plans are very different in size we do have to account for that and to use that i have to turn it into a vector which means pygame.math.vector2 this needs to be capitalized for x it's supposed to be zero and for y it is going to be self dot y offset we are nearly done the last thing we need is self dot z in here we need layers as always and for the plants we actually have two different layers the one we are going to start with is the round plant this i want to paste in here and this means if you look at the settings the plans are always going to be below the player by default i want the plans to be noncollidable so the player can just walk on top of them but once they have grown i want them to be on the main layer and the player should be able to collide with them but that's going to come in a bit i guess for now we have added a ton of stuff so let's actually create one of the plans and see how far we get so when i create a plant i need a plant type the groups and the soil this one should be fairly simple because the plant type is going to be the same as the seed the soil is also going to be very simple because all we need in here is the soil sprite for the groups i do want to have one group specifically for the plants this is going to happen in the init method of the soil layer in here i want to have self.plan underscore sprites once again this is just going to be pygame.sprite.group and now for the groups each plant should be inside of self dot all sprites it should be inside self dot blend not types but sprites and let me fix this typo here and let's actually try this so in the game i can use a hole and now if i press left ctrl we get some seeds that we can walk over and this i can do multiple times also with e i can change the seed and now we get a tomato this is working surprisingly well cool so i'm very happy with that what we now have to figure out is how to make the plants grow inside of the we need an update or some kind of an update method this one i called grow there is no need for an argument in here and now we have a problem because the plant needs to know if the soil it is in was watered but this information we don't have available right now what i want to happen is that each plant can access the soil layer and check out self.grid know if the tile it is in was watered or not and for that i am going to create another method that is going to be fairly simple though i called this one check watered in here we need some kind of position this position will be entered by the plant itself i want to get the actual cell and right now once again we have a pixel position this we have to convert into an actual grid position so we can access the grid the same thing we have done here actually let me copy the entire thing actually and fix the indentation there we go to get the cell all i want is self.grid and y and then x once i have that i can check is watered and is watered we are getting with capital w in cell meaning this could ever be true or false and that is the information i want to return so return is watered now this method i am going to pass into a plant whenever we create it which happens down here each plant is going to have access to self.js watered for this we have to create another attribute after soil i want to have check watered this we have to turn into an attribute so self.jackwatered is check watered and now we can create this grow method all i have to do is check if self dot check watered with self dot wrecked dot center remember here check water it needs a position and i'm just going to go with the center remember here check water did need a position if that is the case i want to add self dot h plus equal self.grow speed and after i have that i can run self.image is going to be self.frames and i can use self.h again although now we do have to be careful because this age could be a floating point value which we couldn't use for indexing but if we turn it into an integer this is going to work again and after that i can turn this into a rectangle which i am getting with self.image actually let me copy this one here because it isn't going to change besides that now the main reason why i am updating the rectangle is because the image is going to change and we might have different dimensions which means we have to get a new rectangle but other than that this is the basics of the grow method what we now have to figure out is when to call it for that inside of the soil layer i created another method update plans all i need in here is for planned in self.plannedsprites.sprites i want plant.grow and this method i now want to call inside of the level when we are resetting the day so in here let's do it all the way at the top we have the plans self. soil layer dot update underscore plants and that should basically be it i guess the one thing you want to be careful about here is that this should be called before all of this because for example if we called it after is raining with this method here we might water all of them and then update all of the plants which would be a tiny bit weird let's try so i want to grow some corn make sure i am watering it and now let's update the entire day and we are getting an error that name soil sprite is not defined this probably happened inside of here ah right jack watered has the problem right now that this should be position zero and position one because what we actually pass in here inside of the plant is self.record center which is giving us a tuple with an x and a y position now let's try this again next attempt i want to plan some coin again and start a new day and we are getting another error this one happens down here inside of plant.grow so let's have a look at this one and the problem is happening somewhere in here the problem is we don't have the soil as an attribute this we can fix with self dot soil ready next attempt let's try it again let's see if i made another mistake now it's working and there we go this definitely grew let me water it by hand and start another day and there we go this keeps on growing and now if i start another day it should be fully grown there we go now if i start another day this is going to crash because we are running out of frames but this was expected other than that this is working just fine we do have a very good start now we just have to make some more updates to the plant and then we are nearly done with the plants and with most of the game actually first of all once the plant is reaching the max age i want the plan to stop growing which happens inside of grow all i want to do in here is if self.h is greater or equal than self dot max h and if that is the case self.h is going to be self.max h although if that is the case i want to indicate that the plant is ready for harvesting which i am doing via another attribute that i called harvester bill and harvestable is going to be true once this condition here is true so we can set this to true with that the game is not going to crash anymore although what i also want to do is if the plan starts to grow it should be on the main layer and the player should be able to collide with it this could be a good exercise if the plant h is greater than zero so if we have one and above then the plant should be on the main layer and pause the video now and see if we can figure this one out for this one we need an if statement and i want to check if self.h is greater than zero if that is the case i want to update self dot z which now should be inside of layers and the main layer although there is one thing you really want to be careful about because self.h could be a floating point value and we only want to do this line here if the plant is greater than one which we can get quite easily with integer if you didn't do this self.h might be something like 0.7 which would be greater than 0 but the plant itself would still be a tiny seed which the player should walk on top so integer ensures that we have a certain kind of plan size if i run the game now let's hope it doesn't crash i can land something and if i now update the entire thing it doesn't crash and now we should be behind and in front of all of this stuff so this is working just fine what we now have to figure out is the collision mechanic and for that if i look at the player again at collision in here the plans don't have collisions yet because they don't have a hitbox which we are checking here but that we can fix quite easily once a plant has a certain age it should have self.hit box and this is just going to be self.direct.com p and this i want to inflate and now i need an x and a y dimension again for x is going to be negative 26 and for y it is going to be self self.rect.height multiplied by 0.4 and this should be negative that is all we needed if i now run main.pi and let's create a tomato for now if i plant this one although i think this takes two days to grow but that's a good way to double check so now i can still walk over the tomato plant but if i sleep again now we have a grown plant and there is no collision yet and i also know why the reason is the plants are not inside of the collision sprites method so when i am creating a plant it needs to be inside of self.collision sprites the problem is the soil layer doesn't have that one although that we can change i want another attribute with the collision sprites and let me put this right below all sprites self.collision sprites is going to be collision sprites now inside of level when i create the soil layer which happens here i also want to pass in self.collision sprites now let's try this again i want to plan some corn because that one is faster and now if i restart the day we have something and now we have collisions this is looking really good cool so with that we have the basics of the plant although we cannot harvest them but that is going to be the next section with the plants being done the last thing we have to do is the harvesting part or at least the last thing we have to do for the plans there is going to be quite a bit more let's jump right in and once again let's go through it step by step back in the code what i basically now have to figure out is if a plant is harvestable so this line here is true and i have a collision with the player so this player here then i want to destroy the plant and update the player inventory all of this is going to happen inside of level.pi i want to create let's call it planned collisions or collision there's no need for any parameters in here first of all i want to check if there are any plans in the first place which i get with self dot soil layer dot plant underscore sprites if there are no plans this is not going to trigger and then there's no point doing any of all of this if there are no plans this would not trigger in here i want to check for plant in self.soil layer dot plant sprites dot sprites that way i can access every individual plant and what i want to check is if plant dot harvest bill and the plant.rect.colliderect with self.player.hitbox we are checking if the plan can be harvested and if the plant is colliding with the player if that is the case i want to destroy this plant make sure to call this plant collision right after update which happens here i want to run self.planned collision and now let's try all of this we're getting an error that inside of level this should be planned sprites so should this one here now let's try this again there we go i can plant some corn and water this and now i have to do a bit of restarting the day but the game is definitely coming together now it's raining so i can go straight back to sleep and now if i collide with this it disappears cool this is a very good start although we do have to a few more things in here first of all i want to run self dot player underscore add and in here i want to get the planned and then dot planned underscore type that way we are updating the player inventory so there's an actual reason to harvest something and this we should probably test so once again all the way at the end of the run method i want to print self dot player dot item inventory if i run this now we get the entire inventory and i want to plant some corn now i have to restart it's still raining it's also raining and we need one more day and now if i collide with this we get corn one this is working very well so let me delete this print statement here again and now we can keep on working in here i also want to create a particle when the plant disappears which we don't have available yet we do not but i can import it quite easily i want a particle which we're getting from the sprites this one here and now i need all of the arguments to create it so let me copy these ones here paste them in here and now we have to figure out all of them again for the position i want to have land.rect.top left for the surface i want to have planned dot image and for the groups this should be self dot all sprites for the z layer i want to have the layers and in here this should be main this should be all we need once again let's try this and i do hope it starts to rain this is looking good raining again one more time and now we should have a particle effect and there we go this is looking good the last thing we need is whenever we destroy the plant we still have inside of the grid let me minimize the plans the last thing we need inside of this soil grid we have to remove the capital p that way we can create another plant for this one i need self.sawyer layer once again and now we need the grid the problem is right now we only have an x in the y position and for the grid we need rows and columns which means we need a row and we need a volume and once we have that i want to remove any kind of capital p and this column is going to be your exercise see if you can figure this one out for the row we are going to need the y position of the plant which we get with plant.rect.com y and this i want to flow divide by the tile size for the column this is going to work in the same way except now we need center x and with that we should be good to go so now if i run main.pi again now if i plant some corn and restart the day it's raining again we do have to wait until the thing grows completely now it should be working and now we are getting an error because i made a typo this should be tile size okay once again let's try this again and testing a game can be very annoying it's not raining but i guess all of this is good way to test all of this let's try it one more time now it is raining it keeps on growing and now it is completely grown if i touch it it disappears and now i should be able to create a new plant so let me plant a tomato and there we go we have a tomato i guess if i restart the date just to be sure all of this is working one more time and it is growing cool so this is working as well with that we have the harvesting logic this honestly wasn't so bad or at least i hope it wasn't there isn't actually that much more to do but there's one thing i did forget to do and that is the night transition or the daytime transition let's do this one next for the day transition we kind of have to do the same thing we have done for the transition between different days we are basically creating an image on top of the entire game and then we use blending modes to merge the two i probably should have done this a couple of hours ago when we worked on the transition but well here we are back in the code i want to do all of this inside of my sky because it kind of fits in there let me reopen it we need the sky in here besides the drop and the rain all the way at the top i want to have let's call it sky we need a dunder init method in here with self and now first of all we need the display surface which as always we get with pygame.display.get underscore surface besides that we are going to need an image that covers the entire window which i called self.full surface just surf is fine and this we get with pygame dot surface and in here i can once again from my settings get the screen width and the screen height let me copy in the screen width and this green height and now we have a full surface once i have that i want to let me call it display in here we need self and we also need delta time and essentially all i want to do here is self dot display surface dot blit i want to have myself dot full surface at the position 0 and 0 that will be covering the entire window and finally we need a special blacks which in this case is going to be pygame dot blend underscore rgba underscore mult right now this is going to be entirely black so there isn't too much point but let's use it right away also i want to close the soil at least for now to keep things a bit more organized i can also close the sprites because i don't think we need it at all anymore inside of the level i want besides rain also import sky and the sky has to be an attribute let's put it right here self.sky is going to be sky once we have that inside of the run method after the rain i want to have the day time like that and this we get with self.sky dot display in here we do need to at a time although not right now but we do need it to call the method if i run this now everything is going to be black the reason is we are putting a black surface on top of the entire window which well isn't particularly helpful although what i want to do now is self dot start color and this start color is going to be a list with the values 255 255 and 255 before i am displaying this surface i want to fill it with that color so self.color serve.fill with self.startcolor once we have that we shouldn't be seeing anything we can see the game itself this is looking as always but now what we can do with this setup i could for example change this to a0 and if i now run this again we get a bunch of weird colors and this way we can control how the game is going to look like in my case i want to transition from a pure white color to myself dot and color which is going to be the tuple 38 101 and 189 just to illustrate what this one is going to look like let me run it in the game it's going to look like this this is very much night time all we have to figure out now is how to transition from this value to this value here how this is going to look like is i'm going to look at every individual value and subtract it by a certain amount let's say negative 2. and this i'm going to do until we're reaching this particular point this point here so you can see it this is also going to happen for the second one this is going to go until this point here and for this one as well up to this point here this i am getting with for value in self dot and color although in here i do need the enumerate method because i need to know what index i am on so i have my index and i have the value i want to check if self dot start not time but color is greater than the value and if that is the case self dot start color with the index should be minus equal 2 multiplied by delta time also when i am filling all of this this should be the start color we are looking at every single color inside of n color against this we are checking on this line here if the corresponding value inside of start color let's say the first one 255 is greater than the end color 38 in this case and if that is the case we want to reduce the start color value by a certain amount and this we want to do until we reach the end point and with that we should be having a transition let's try now and we are getting an error this one here should be start color and index and now all i have to do is wait i guess while i'm doing that i can run around a bit to check out the entire level i've been very focused on specific tasks but well the entire game is coming together pretty nice also here you can see the trader and now since we have a collision block here we cannot move over him anymore we're going to work on the trader in just a second and everything else is working really well okay probably i'm just going to speed up this entire game because i am running out of things to talk about so let's speed it up a bit alright i think at this point you can definitely tell things are getting darker this is definitely working all we have to figure out now is once we have all of this color here we have to set it back to the starting position so 255 255 and 255 whenever we are resetting the entire day this is also going to be fairly simple all we have to do let me add another comment here sky i want to get self.sky dot start color is going to be 255 255 and 255. that if i now wait a tiny bit let me speed all of this up all right now we can definitely tell things are getting darker so let me restart the day and there we go this is much brighter with that we have the daytime cycle really wasn't that bad and this is literally all we need for the sky meaning i can minimize it and close the entire python file and we are almost done the last major bit of the game is going to be the merchant so let's work on that one there are quite a few different elements we have to cover here back in the code first of all the player is going to need let me minimize everything the player is going to need a full inventory we already have a couple of things in here we have this kind of inventory but we are going to need a tiny bit more we also need self.seed underscore inventory and this one is going to have two key value pairs we have corn and by default let's say we have five and besides that we have tomato five in here would also work well finally besides that we are going to need self dot money and for starting value here let's go with 200 it's entirely arbitrary this is going to be the inventory for the player and this is also what we're going to access when we are doing the merchant although before we are coming to that there's one more thing that i want to do and that is that the player shouldn't be able to use a seat once we are running out of seat for example the player can only use corn if this number here is at least one let me minimize the init method and all of this happens inside of use seed all i want to do in here is if self dot seed inventory and then i want to pick myself dot selected seed and only if this is greater than zero then i want to plant a seed besides that inside of here as well i want to get myself dot seed inventory get the selected self dot selected seed again and subtract it by one with that we can start working on the merchant itself let me explain how it's going to work here we are back in tiled and the trader is all the way in the top left what you can see around the trader is inside of player we have a trader area this is going to work kind of like the bad if the player is inside of this area presses enter then we are going to start the merchant menu back in the code when we are creating the level more specifically when we are running the setup method in here a bit further down we are checking for the start position of the player if there is a bad and besides that i want to check if object is equal to trader if that is the case i want to create another interaction object meaning i can duplicate this line here and paste it in here with that we are actually done all of these arguments here can stay identical since we're getting information from tiled all of this is going to be done automatically the only major change here is going to obj name because this one now is going to be trader instead of bad but with that we have the interaction object we have to do a tiny bit more inside of the player inside of the input method all the way at the bottom we have created this line a couple of hours ago and that is if the player is inside of the interaction area and we have trader then we want to do a certain thing basically what i want to do is to run a method called self dot toggle underscore shop this one doesn't exist right now but basically what i want to do is inside of the level i want to create another method let me minimize everything in here so it's a bit easier to see inside of the level class i want to let me do it below player ad this one i want to call toggle underscore shop in here we need self and nothing else and this is a fairly simple method all i really want to do in here is self dot shop active is going to be not self self.shop active meaning whenever we are running this method we are switching shopactive either on or off this attribute doesn't exist right now so we do have to create it this happens inside of the init method in here let's put it under another section shop and by default this one needs to be false if this one is true though we are going to show the shop menu but that is going to come later first of all we have to pass this method here into the player which happens inside of setup and in here we have the player and the player is going to get another parameter toggle shop which is going to be self dot toggle shop for that to work inside of the player all the way at the top let me minimize the input method and inside of the indent method we need toggle shop and for this one inside of interaction i want to create another attribute self dot or girl shop is going to be toggle shop and with that we should be having a pretty good start i suppose we can test this inside of the run method all the way to bottom i want to print self dot shop active and this we should be able to influence with the player so let's run the game and we are getting thoughts right now that is a very good sign and if i walk to the merchant and if i press enter right next to him we're getting true if i press it again we're getting false so this is a very good sign and with that we can start working on the actual merchant for that i want to create a new file and save it as menu dot pi in here as always we are going to need import pygame and we also need from settings import everything after that i want to create a new class that i call menu in here we need a dunder init method this one itself it needs the player and it also needs toggle menu so we can switch off the menu from inside of the menu inside of this i want to have a general setup for this i want to turn the player into an attribute so self.player is player the same i want to do for the toggle menu so self.toggle menu is going to be toggle menu and besides that i am going to need two more things first of all i need the display surface this as always i'm getting with pygame dot display dot get underscore surface and besides that i need self dot font the font we get with pygame dot bond dot font be careful here about the capitalization the first font is lowercase the second font is uppercase this we want to call and in here we need a font style and we need a size the size is easy because we just want an integer in my case 30. for the font we need an actual file in my case here's the project folder and we have font and in there we have a file called lychee soda this is what i want to import the file path for that is going to be a string and i want to go one folder up to font and then to lichi so da dot ttf and with that i have a font with all of that covered basically what i want to do i want to create an update method that one itself and nothing else and this is actually going to show the menu although we do have to do quite a bit of work to get this one done for now just to see if this is working i want to show some blank surface which means i want self.display surface dot blit in here i want to create a surface from scratch and this one is going to have a dimension of let's say one thousand and one thousand the position here is going to be zero and zero the way we are going to call it inside of level.pi i want to get rid of print shop active and instead first of all at the top i want from menu import menu inside of the init method i want to create an object from the class so self.menu is going to be menu the two arguments we need here from menu we need player and toggle menu layer is really easy because we have self dot player toggle menu is also very easy because in here we have self dot this one is called toggle shop though but same thing i can just paste it in here and we are good to go inside of the run method i have to do some reorganizing the first two lines can stay identical and let me add a few more comments here to make all of this a bit clearer the first two lines are let's call it drawing logic after that we have the updates in here i want to check if shop active if that is the case i want self dodge menu dot update i think i called it yeah update i want to call this method here and only if that is not the case so else i want to do these two lines here if the menu is active the player cannot move anyway so there's no point updating all of the sprites or any of the planned collisions it's simply not necessary as a matter of fact i want to stop the entire game while the menu is open this is going to include the rain as well which means it's only supposed to rain if raining is true and not self dot shop active only then do i want to update the rain the overlay however can stay here let's put all of this under the weather section actually and let me remove these comments i think this makes the most sense with that we have the entire run logic let's try it so in it still works and now i want to run to the shop and in here i want to press enter and the game is crashing because inside of menu this one should be pi game dot surface and while i'm here i also realized this should be inside of another tuple now let's try this again and next to the merchant i press enter and now we have a big black rectangle and the rest of the game also doesn't update which is a very good sign which means this one is working we just have to add more logic to it the most important one for now is that we need an input method so that we can switch off the menu as well this is actually going to be your exercise i want you guys to get the input and then if the player presses escape close the menu pause the video now and try to figure this one out it should be fairly doable first of all we have to get all of the keys this we get with pygame dot key dot get underscore pressed once we have that i want to check if keys and pygame dot a underscore escape if that is the case i want to run self dot toggle menu don't forget we also have to call self dot input but other than that this should be it back at main.pie let's run this again and right next to the merchant i press enter and now if i press escape the game continues and this i can do multiple times this is working really well so with that we can toggle the menu with that we can actually start creating the proper one and for that i first of all want to have a couple of options the most important one for now is self dot width and this one i set to 400 this is going to be the entire window and inside of it roughly here i want to have the menu inside of the menu we're going to have individual entries like so what with is determining right now is the width of this entire menu besides that i also want self dot space that is the space between the elements this i set to 10 and then self dot padding and this i set to 8. once we have that information i want to create the actual menu entries and for that first of all we are going to need all of the i call this one the options what this is going to be inside of the player in the init method we have the inventory this is going to be what i want for the options for the menu and i am going to combine all of those into one list self dot player dot item underscore inventory and i only really care about the keys here don't forget to call this and this i want to turn into a list this list i want to combine with the seeds let me copy it and to combine it to lists i need plus and copy this list and i want to have the seed inventory this one here to make sure this one is working let me print what we get self dot options and now if i run this and close the game here you can see we have all of the different options apple corn and tomato are the inventory of the player so the items corn and tomato are the seeds although now we do have a problem let me run it again actually inside of this list i need to know which of these items can be sold and which ones can be bought the items should be only sellable so these four items i want to be able to sell and these two items here i can only buy as a consequence i need to figure out where i'm drawing this line here where we end the selling menu and start the buying menu for that i created another attribute that i called cell border this is basically self dot player dot item inventory i am getting the length of it and from this i'm subtracting negative one later on i'm going to cycle through this list and for every item i am going to check the index and check if it is smaller or greater than this border if it is smaller we are selling if it is greater we are buying and with that i can create is self.setup method let's do it right below this one doesn't need any arguments the most important thing i have to do in here is to create the text surfaces all of those are going to be stored in the list and the list i called text surfaces for now it's just going to be an empty list all of these items are going to be created with four item in self dot options that is the list we have created up here all i have to do is to create a text surface and this i am getting with self.font.render in here we need a string we need antialias and we need a color the color is the easiest bit i just want to have black in here antialias should be false and the string should just be the item once i have that text surface i want to get myself dot text surfaces and append the individual text surface i also just realized this one should be set up not input now with that we have a list of surfaces this we can now use inside of the update method in here i can get rid of this big black rectangle and instead i want to do for text surfaces in self.text serves although remember what i explained earlier for this logic here to work to separate between the by and the cell menu i need to know the index of every item inside of this for loop as a consequence i am going to use the enumerate method here and let's call this one text index i suppose for now all we have to do is self dot display surface dot blit we have a text surface and for the position let's say we can go with a hundred for x and for y i want to have the text index multiplied by 50. let's try all of this now and once again i have to walk to the trader here we are at the trader if i run this we can see the different entries so this is looking really good we can also end the menu and this is working very well very good we are making progress although now we do have a problem right now the height is basically random so we have to figure this out more deliberately this is also going to happen inside of the setup method besides the text surfaces i want to have self.total height by default this is going to be zero inside of the for loop i want to get this total height and plus equal self dodge text surface and then get underscore height although don't forget i also want to add plus self dot heading multiplied by two and this i want to put in brackets that looks a bit cleaner each of those text entries let's say we have three for now inside of those the text is only one part in the middle and there should be some space or some padding between the top and the bottom of the text this is what we're getting with self.padding the entire height though is what we're getting from self.total height this is what we're going to use in just a second to center the entire menu although there's one more thing that we do need because if i open the drawing again between each of the entries so this space here there should be some more space that is the space we have set up earlier in here to get that number let's do it here i want to get self dot total height and i want to add a number number i want to get the text surfaces and i want to know how many items i have so i want to have the length right now that number would be free because we have one two and three elements from that i want to subtract one for the simple reason that we only have one space for any two elements as a consequence if we have three elements in total we want to have two spaces between them all of this i want to put inside of another bracket and this i want to multiply with self dot space and now i have the total height this i can use to calculate self dot let's call it menu top this is going to be the top part of the menu for this number i need in my settings the screen height and this i want to divide by two from this number i want to get myself dot total height and divide this by two as well this here is going to be the entire screen and screen height divided by 2 would be roughly this point here from that i want to subtract self.total height divided by 2. that would be roughly let's say here with this being the first half and the other half would be below so one half here that way the menu is always going to be in the middle there's one more attribute i want and this i called self dot main rect this is going to be the bounding box for the entire menu and this is going to be a rectangle so pygame.rect in here we need the left the top the width and the height figuring those numbers out could actually be a really good exercise so try to figure them out yourself and see how far you get there are three numbers in here that should be fairly simple the top is what we have just done it's just self.menu top so i can place this one in here the width is also very easy that is the number we have created up here which means i want to have self dot width height is also easy this is just going to be self dot total height the only minor complication is the left side to get this one we kind of need the same logic we have used here i first of all want to get my screen width and this i want to divide by two from that i want to subtract self dot width and subtract this by two as well with that we should be having a rectangle that is in the center of the window and also is as tall as all of the text elements i guess let me minimize the setup method and try this one i guess for now we can comment out this for loop here and instead i want to pygame.draw.rect i want to draw on self.display underscore surface the color let's go with red and the rectangle is going to be self dot main rectangle and just for testing purposes it's going to be kind of annoying to always walk towards the merchant so inside of the player let me go to the input method and then here if the player is pressing enter i want to toggle the shop already like this now if i run the game i am getting an error this happens inside of menu inside of setup and this self.text surface shouldn't be yourself it's just a text surface so we're getting this one here now let's try this again we're not crashing and now if i press enter we're getting a menu in the middle of the window i can also press escape and the game continues as always so this is working quite well i suppose next up we can start working on another important ui element and that is display underscore money there's no need for any arguments in here and all we are going to do in here is first of all we need a money surface or rather since we have local variables this can be a text surface all i want in here is self.font.render in here again we need a string we need antialias and we need a color the color once again is going to be black and antialias is going to be false it is false here because i have pixel fonts which don't look good when you enter and use them finally for the string what i want to access is inside of the player in the init method i want to access this money attribute here this i get with self dot player dot money although this i want to put inside of an f string like this because that way i can add a dollar sign before once i have that i can create a text rectangle this is just going to be the text surface dot get underscore rect and in here i want to place the mid bottom for the position here i want to have this green width divided by two so we are right in the middle and then i want to have this green height and subtract 20 from here that way we are slightly off centered from the bottom of the window once we have those two bits i can get myself dot display surface and split the text surface and the text rectangle and now all i have to do is to run self dot display money and this should be working so inside of main or pi i press enter and we can see the money in the bottom center of the window this is working very well although there's one more element i want to add and that is a background for this text this i get with pygame dot draw.rect and in here i want to draw on self.display surface the color for this one should be white the rectangle i want to use in here is the text rectangle although i do want to inflate this one by a tiny bit let's say 10 and 10 pixels if i run this now this is already looking much better although i do want to have some rounded borders this i can also get very easily i need to add two more arguments the first one is the border width which in my case is going to be zero and then we have to border radius which in my case is going to be 6 and this 6 here determines the border radius or how much rounding we get if i run this now we have some rounded borders which makes the entire thing look much nicer i guess you can play around with different numbers here let's try four yeah i guess this one looks a bit better but again this is pretty subjective so choose whatever you think is best with that we have finished the money this is all we need in this one i guess next up we can work on all of the actual entries and we already have some good starting points here we have access to all of the text surfaces and we know their index this i can use inside of another method let me call it show entry in here we do need a couple of arguments i want to have a text surface so the text i want to show that i want to have the amount like so then i need the actual position and this is going to be top with all of that i can start working on this and first of all in here i need a background after that we are going to create the text and later on we are also going to show an amount but let's get started with the background in here i want to create a bg rectangle this is just going to be a pie game rect and once again we need a left a top a width and a height left we can get fairly easily because we have self dot main rectangle dot left since this main rectangle is in the center of the window this makes it very easy for us to get positions top is going to be what we're getting from the parameters this top here the width is going to be self dot with the one we have created all the way up here and finally the height is going to be text surface dot get underscore height don't forget to call it and to this i want to add self.heading multiplied by two once i have that all i want to do is pygame.draw.org and in here self.display surface the color should be white i want to draw the background rectangle and i want to go with 0 and 4 for the border radius with that we already have a pretty good start all we have to do now is inside of this for loop we have to figure out how to actually call this show entry let me add a bit of white space and first of all in here we need to get the top and the top is going to be self dot main rectangle dot top plus the text index and this i want to multiply with a couple of things most importantly the text surface and i want to get the height of that although to that i have to add self dot heading multiplied by 2 and i have to add self dot space think of this one here is the main rectangle this one here and by default we are getting the top this line here and for every item we want to get the distance downwards that we get by multiplying the text index by the height of the text the padding and the space for example if the text index is zero all of this is going to be zero so the first item is going to be all the way at the top here for item number one we would be somewhere here let's say this one could be 100 because the text height would be something like 70. the padding could be 2 times 10 and let's say for the space we also have 10 and all of this we want to multiply by one as a consequence the result here is going to be 100 and this 100 is going to be the top of this text entry and this is what we can use in self dot show entry let me copy all of the parameters here so top is what we have just calculated text surface is also what we are getting from here for the amount for now let's just say 0 we're going to work on this in just a second but for now if i run main.pi again and press enter now we can see all of the background fields and those are perfectly centered which is looking very nice definitely progress although let me get rid of this line here so we're not drawing the text anymore and also this drawing here so we don't have the red background now if i run this again this is looking much cleaner cool so with that we can start working on the text for this one i want to create a text rectangle once again this is going to be pygame dot rect and again we need a left at top a width and a height for this one i want to get the text surface and get underscore rect in here once again i want to place the mid left i need an x and a y position or rather i need a left and a top position to be a bit more specific for the left side i want to have self.mainrect dot left and now i want to have an offset let's say 20. for the top i want to have the bg rectangle and in here i want to have the center y position once i have that i can run self.displaysurface.blit and pass in the text surface and the text rectangle let's try this one now and there we go this is looking really good finally we need the amount for this one first of all i want to create an amount surface this once again i get with self.font.rna in here we need some text we need antialias and once again the color the color is always going to be black and the alias is always going to be false and the text itself is going to be the amount although here this we have to convert to a string because by default amount is a number and pygame doesn't like that it always wants a string for the render method now that we have that we can create an amount rectangle this we get with amount surface dot get underscore rec and for this one i want to place the mid right again we need a left and a top and for the left side what i want in here if this is one text box or rather one of the bg rectangle inside of there we have the text rectangle and the text is somewhere here ish with a offset from the left for the amount surface i want the exact opposite i want to come from the right side and have something like this which means for the left side here we want to have the right side of the main rectangle and then go to the left a bit which means i want to have self dot main rect dot right and subtract let's start with 20 pixels although for the top all i want is the bg rectangle and then center y again and let me clean this up a tiny bit there we go all we have to do now is get self dot display surface dot blit and pass in the amount surface and the amount rectangle if i run this now this is looking pretty good although we do have to figure out the actual numbers for the amount that however isn't that difficult or at the very least it's certainly possible first of all inside of the for loop i want to get let's call it an amount list and this amount list is going to be very similar compared to this options here as a consequence i can just copy it and paste it in here except now we don't look at the keys instead we are looking at the values this way if i open the player we are getting all of these values here inside of one list and this list has the same order as this list here as a consequence we can get the amount simply by looking at the amount list and using the text index and that is what i want to pass in here if i now run this again press enter we are getting lots of zeros but then we are getting five and five those are the two seats and with that we have the basics of the menu although we cannot select anything and let's do this right now i guess we can keep the entire merchant in one big section for the selection we need a few more things most importantly let me add this section here and let's call it movement the one thing we need in here is self dot index by default zero here is totally fine and how i'm going to use this when i'm creating show entry let me minimize everything else there's going to be one more parameter and that is going to be selected and if selected is true so if selected then i want to for now just draw a border around this particular box which i'm getting with self.display surface for the drawing the color here should be black and i want to get the background rectangle although now i want to have a border width of four and 4 for the border radius if you specify a border width the content or the filling disappears for this rectangle but let me show what actually happens if i press enter now we are getting an error because i forget to add the argument in here i want to have either true or false and what i am checking is if self.index is equal to the text index now if i run this and press enter now by default the first item is going to be selected however if i go to my menu and set this index to let's say a 3 and run this again now we have tomatoes selected and all i really have to do inside of the menu is to change this index to select a different item and this i'm doing inside of input all i want to do in here is if keys and pie game dot k underscore up if that is the case i want to set self dot index minus equal one then i can copy all of this and change the up to down and this one should be a plus one now i can set index back to zero and now let's try this actually if i press enter now and press down something weird is happening the thing disappears oh well it kind of works but it moves way too fast and this is a problem we have encountered earlier basically inside of the init method pygame for this one for example checks if the down key is being pressed but pygame checks this about 100 times per second as a consequence if we are pressing it down pygame registers this line let's say 20 times even though for us it seems like we are only pressing the key once and as a consequence we need a timer this one we already have i want from timer import timer and the timer i want to create in here so self.timer is going to be timer for this one we only need a duration and for the duration for this one i went with 200 milliseconds now inside of the input method when i'm pressing either up or down i want to activate this timer so self.timer.activate but all of this should only be possible if the timer is not active meaning if not self.timer.active finally there's one more thing that we need and that is we have to update the timer which i'm doing all the way to the top of the input method self.timer.update i hope you remember the time i actually recreated this one a couple of hours ago let me open it actually so inside of the timer this one here we have all of this and this is what i'm using inside of the menu right now but with that this should already be working if i run this now i can open the menu and i can move up and down this is working really well the problem right now is if i move too far up the thing disappears and also if i move too far down it disappears this we want to control for meaning i want to clamp the values all this really means in practice is i want to have myself.index and if this one is below zero i want to set self dot index to length of self dot options minus one this means if we are going below zero we we're going to the end of the list this is also going to work the other way around that if self.index is greater than the length of the list minus one then i want to set self.index to zero and now let's run this again and if i move down this still works if i move up we are getting to the bottom of the list and if i move downwards we are going back to the top so this is working perfectly fine okay next up when we are showing the entry let me minimize everything once more the next thing i want to do is that let me run the game again and we have what apple corn automator selected i want to have a cell text roughly here for all of these and if we have corn or tomato selected there should be a by text here and this is what i'm going to create now first of all for that inside of the setup we have to import or well create two more things those two things are going to be the by or cell text surface in here i want to have self dot by text and i want to have self dot cell text both of those are going to be pygame.font.render and again we need three arguments the first one is the text let's leave this one empty for now after that we want folds for the antialias and for the color we want black for the byte text this should just be by and for the cell text it should be cell with that we have two surfaces we just have to figure out when to actually show them that is going to happen inside of show entry specifically i only want to show this when the specific entry is selected how this is going to work i am first going to check if self dot index is greater than self.cell border this is the border we created in the init method right here this one is checking the length of the inventory so if we are inside of the length of this border we want to sell if we are beyond it we want to buy let me add comments here this one is going to be buy and if this one is not true so else then we want to sell actually i think this one is a bit confusing let me do this the other way around so if we are below this we want to sell and if we are beyond it we want to buy and all we have to do now is self dot display surface dot blit and in the cell one i want to display self dot i called this one cell text for the position let's say for now we are going to go with zero and zero and for the buy text this is going to be by text and let's try this one although it's going to look a bit funny and we have an issue inside of the setup method this shouldn't be pi game it should be self.font.render if i now run this again this is working and now in the top left you can see sell sell sell and now we have buy buy buy although for the tomato something did go wrong so we have to make some minor adjustments here but other than that this is working pretty good i guess the problem here is inside of entry this should be smaller or equal if i now run this again we get sell sell sell and buy and buy there we go this is working just fine although the position of the buy and sell text we do have to work on although the position is looking a bit weird let's work on that one and for this i want to create another rectangle let's call it the position rectangle in here i want to have self dot for cell i want to have the cell text and get underscore rect for this one i have to place the mid left and once again i need the left and i need a top the top is the really easy part because i get my background rectangle dot center y for the left i want to have my self dot main rectangle dot left and to this one i want to add 150 pixels i can place the position rectangle in here and this should be working let's try and we are getting an error that this should be yet wrecked with lowercase letters and now we get cell in the perfect positions although buy is still looking a bit weird but that we can work on all i have to do is duplicate this one here paste it in there and now we want to get the bitext surface but the rest is going to remain the same meaning if i run this now we get sell cell and bye bye because i didn't paste the position rectangle in here for the position now this should be working sell sell and buy and buy this is working perfectly fine cool i am really happy with this so let me minimize show entry and the setup all we have to do now inside of input is to actually make the menu do something for that inside of this if statement here i want to add another if statement and now i want to check if keys and pygame dot k underscore space if that is the case first of all i want to activate the timer so self.timer.activate after that i want to get the item so i want to create another variable called current item and for this one i want to have myself dot options and use self dot index i suppose let me print what we actually get with current item and if i run main.pi if i now press space we get wood apple corn tomato corn and tomato this is working just fine now i have to figure out do i want to sell or do i want to buy that is information we can access quite easily because i once again want to check if self.index is smaller or equal than self dot sell order if that is the case i do want to sell if it is not the case so else i want to buy if i am selling it should be self.player.item.inventory and i want to check the current item if that is greater than 0 i want to do something so this should all be an if statement let me copy the entire line here because what i want to do if this is the case this should be reduced by 1. and on top of that i want to get myself dot layer dot money and i want to increase that amount by a certain number this number i'm getting from settings and here i can minimize a ton of different things in here we have sale price and purchase prices for now i only care about the sale price this i want to access and i want to use the current item as the index this should be all we need for now for the else i want to add a pass and just to test this inside of the player let's give the player a couple of items like this and now if i run this again i press enter i have lots of different items i could be selling and if i press space the amount gets reduced and our money increases and let me try to sell all of my wood if i now get to zero i cannot sell anymore but i can still sell other things so this is working perfectly fine so with that all we have to do is to check the buy part and we are basically done in here first of all i need to get the seed price this i'm getting again from settings and there we have purchase prices this i want to get and in here i want to get my current item as the index now i want to check if the player has enough money for it which means if self.player.money is greater or equal than the seed rise then i want to get self.player.seed underscore inventory and i want to get the current item again i want to plus equal one and then self.player.money is going to be minus equal the purchase price of the current item there we go and this should be it let's try so i can still sell things but now if i try to buy things my money goes down and let me hold space pressed and at some point we should be reaching zero there we go now we are zero and i cannot buy any more seats i can still sell things though and now that i have money again i can buy some tomato seeds until i am running out of money and there we go this is working fine so with that we have created the entire menu and that finishes basically the main part of the game all we have to do now is to add some sounds and then we are done for the final bit we have to add the sound let's jump right in this really shouldn't take too long here we are back in the code and what i want to work with let me open the folder here's the entire project and i want to look at audio in here we have a couple of different files that i want to use the main problem is we have to figure out when and where to use them but that really shouldn't be too difficult let's start with the axe for this one i want to look at my sprites so let's open this one again in the sprites i want to minimize everything because i only want to focus on the tree basically inside of the tree whenever we damage a tree i want to play the x sound let me add another comment here play sound basically all i want to do is self dot x sound dot play and that is basically it for that i have to import it this happens in the init method let's call this one sounds all i need in here is self dot x sound and this is what i get from pygame dot mixer dot sound spelled like that the file path we need here is one fold up then audio and in there we have a file called x dot mp3 and with that we should be ready if i now run main.pi and walk towards a tree and hit that one with an x that is sounding pretty good so next up we need to sound effect if the player gets a thing this is going to happen inside of level because in here i have the player add method i basically want to play something like self.success.lay this success we have to import and this happens let's do it all the way at the bottom music this i call self.success and this once again we get with pygame.mixer.sound the file once again is one folder up audio and the file is called success.wav although for this one by default i think it's a bit loud as a consequence self.success dot set underscore volume and in here 0.3 i think sounded good and now anytime the player gets any kind of item we are playing that sound so let's run minded pi and let's say i want to get an apple that sounds not too bad and if a tree disappears this also plays cool so this is working it's also going to play when we are picking up a plant but that takes a while to test so i think we're good for the next tool i want to work on the hoe and for that i want to reopen my soil layer or soil.pie and i want to minimize everything in the soil layer i want to add sounds and in here i want to create self.hoe sound and this one i get with pygame.mixer.sound the file path here is one folder up audio and in there i have whole dot wav this i want to make a little bit less loud though so i want to set the volume to 0.4 and this now if i minimize all of the methods i want to play whenever the soil gets hit so in here let's do it all the way to the top self.hold and with that we should be having another sound so if i now use this one possibly a bit loud i want to change the set volume to 0.1 and now let's try this definitely an improvement it's going to get better once we have background music but i'm kind of happy with this next up i want to work on the watering sound this one is going to happen inside of the player in here all the way at the bottom here i want to add his sound section and this i called self.water ring this once again we get pygame.mixer.sound the file path here is one fold up audio and the file name is called water. this one is an mp3 and whenever we are using a tool and the selected tool is water i want to play self dot water ring although for this one i also want to change the volume so self.watering.set underscore volume is going to be 0.2 if i now run main.pi again select the watering can that's working just fine cool there's one more that i forgot and that is inside of soil besides the whole we also have self dot plant and this one let's call it plant sound actually plant sound once again pygame dot mixer dot sound and in here one folder up audio and this one is called planned and the file ending is a dot wav let me just duplicate it self dot plan sound dot set underscore volume let's go of 0.2 this one i want to play whenever we are planting a seed in here so all the way at the top i want self dot plant sound dot play that way this one will only be played if we are actually hitting the soil if i run this i first have to create a soil patch and now if i plant some seed not the greatest sound effect but it certainly works and all right with that we have all of the minor sound effects the one last thing we have to do is to play the background music and this could be a really good exercise for you figure out where you could play the background music and import it and play it all of this is going to happen inside of level i guess theoretically you could also play it in main.pi but level.pi is a bit more flexible in here i want to import music so self.music and this we get with pygame.mixer.sound the file name here is called well we have to go to audio first and i want to import music which in this case is an mp3 file what we also have to do to play it is self dodge music dot play and in here loops needs to be 1 so that we play this continuously now for the background music i have been a bit lazy because you probably want to change the volume depending on the day time or play different kinds of music depending on what kind of weather you have but well i just have one kind of background music but this video is getting long enough you can work on this yourself but now if i run this now before i finish the entire thing there are some very minor things i do want to change first of all inside of the player if i minimize everything again so we can see what's going on inside of the input in here i have to clean up this self.toggle shop that's the one i forgot earlier here we go and now this one is done so let me close the entire player besides that in the level i want to set the rain to something greater than seven because the rain really shouldn't happen that often this i also have to update let me minimize all of the methods once more in the reset method this one should be like this finally inside of the sprites in here once again i want to minimize everything and in the tree i created an involved timer and this one simply isn't necessary i just mixed up my notes but now we are done with the entire thing this was literally all we needed and let's make sure this is all still running all right this is looking really good so well done if you have gotten this part this was a really long tutorial so i hope you enjoyed it and i'll see you around
