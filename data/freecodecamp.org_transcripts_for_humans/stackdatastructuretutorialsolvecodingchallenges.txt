With timestamps:

00:00 - Stacks are a common programming data
00:02 - structure and many programming interview
00:04 - questions require knowledge of stacks
00:07 - tanishq has helped thousands of people
00:09 - prepare for coding interviews and now
00:11 - he's going to help you understand the
00:13 - stack data structure by demonstrating
00:15 - how to solve a bunch of common coding
00:17 - interview problems the problems go from
00:19 - easier to harder and Denise will be
00:22 - guiding you the entire time my name is
00:24 - Dani sheltery and I'm very excited to
00:27 - bring you this course on Stacks so let's
00:29 - go ahead and get started
00:31 - hello everyone and welcome let's talk
00:34 - about the implementation of Stack we are
00:37 - going to start off with a couple of
00:38 - examples to understand the reason why
00:40 - Stacks are built in first place then
00:42 - we'll look at the implementation level
00:44 - details of stacks in terms of python and
00:48 - C plus plus
00:49 - all right let's get started
00:51 - now if I ask you the question what do
00:53 - you see on the screen you might reply
00:55 - that there looks to be a couple of books
00:57 - present on a shelf so you can call this
00:59 - a stack of books
01:01 - now what would you do if you had to read
01:03 - the first book the book on the top of
01:05 - the stack
01:06 - well you want to read Harry Potter so
01:08 - you will just pull it out of the stack
01:10 - you'll remove it from the stack you'll
01:12 - read it and then you'll push it back on
01:14 - to the stack once again
01:16 - now this is simple and fine but what if
01:19 - you want to read grocking the coding
01:20 - interview now
01:21 - what do you do
01:23 - of course you can drop pulling it out
01:25 - from the middle but all of these books
01:27 - are dense and heavy and you don't really
01:29 - want to disturb the balance of the
01:30 - elements on the top of the stack so what
01:32 - you can do is you can take out the first
01:34 - book
01:35 - you can take out the second one and then
01:38 - finally read grocking the coding
01:39 - interview you read it and then you can
01:42 - put it back on the stack along with
01:44 - these two books
01:46 - what we have just seen is a very
01:49 - important property of stacks that is
01:52 - called the leaf ordering
01:54 - lifo stands for lost in first out
01:57 - saying that the elements that come into
01:59 - the stack towards the end that is the
02:02 - elements that come in the last or the
02:04 - first ones to get out blast in first out
02:09 - now this is a property that will exploit
02:11 - again and again throughout this entire
02:13 - series it's going to be a central
02:15 - property and it's the heart of the
02:17 - reason why we use a stack in many of
02:19 - these questions
02:21 - now let's go ahead and formalize the
02:23 - operations we can do on the stack
02:24 - because we know that if the leaf
02:26 - ordering is being followed we have to
02:28 - use a stack but how do we exactly we use
02:31 - it
02:32 - well let's look at a couple of
02:33 - operations the first operation we saw
02:35 - was removing items from the top of the
02:37 - stack
02:38 - we call this operation formally the pop
02:40 - operation because we are popping the
02:42 - elements out from the top of the stack
02:45 - right so this is going to be the pop
02:47 - operation
02:48 - the second operation we saw was to add
02:51 - the book back onto the stack in other
02:54 - words we're looking at a push operation
02:56 - pushes the formal term used to define
02:58 - saying that we want to add an element
03:00 - onto the stack in other words we'll push
03:02 - an element on the stack
03:04 - now there's a final operation that we do
03:07 - very commonly and that's the peak
03:09 - operation now the peak operation simply
03:11 - says hey go ahead and take a look at the
03:13 - top of the stack go ahead and take a
03:15 - peek at the top of the stack
03:17 - right so these are three operations that
03:20 - we'll keep in mind all right so now
03:22 - let's go ahead and actually look at how
03:24 - these are implemented in terms of python
03:26 - and C plus plus Java implementations are
03:28 - pretty close to both of them so even if
03:30 - you understand just one implementation
03:32 - way you'll be able to do it in any other
03:34 - language I have ensured and tried my
03:36 - best to make sure all of the codes are
03:39 - language agnostic they can be easily
03:41 - translated from one language to the
03:42 - other without having a lot of issues all
03:45 - right so let's go ahead and actually
03:46 - look at how we are implementing these
03:48 - the first thing is how do we initialize
03:50 - this tag and in Python we're going to
03:52 - use the list implementation of Stack
03:54 - because there is no inbuilt internal
03:56 - class for it we're going to create a
03:58 - list empty list of our own to initialize
04:00 - the stack in C plus plus there is so
04:03 - we're going to use stack
04:05 - and we're going to have a stack of int
04:07 - variables and we'll call it as pretty
04:09 - simple all right how do we push in
04:12 - Python we do stack dot append and so we
04:14 - can do stack dot append an item and this
04:16 - is going to return a non-value that is
04:19 - it does not return anything we just
04:21 - append this element onto the top of the
04:23 - stack
04:24 - in C plus plus we simply do s dot push
04:27 - this is going to return a null
04:29 - all right how do we Peak how do we check
04:31 - what is the element at the top of the
04:33 - stack
04:33 - well in Python the way to do that is to
04:36 - use stack of -1 that is it is going to
04:38 - give you the last element on the top of
04:41 - the stack
04:42 - right so in this case it's the element
04:44 - three how do we do it in C plus plus we
04:47 - simply do s dot top
04:49 - now remember this is a slight
04:51 - terminology difference but nothing much
04:53 - you want to look at the top of the stack
04:55 - you want to peek at the top of the stack
04:57 - this is how you do it all right how
04:59 - about pop
05:00 - in Python you do directly stack dot pop
05:03 - and that is going to return your value
05:05 - three this is a crucial Difference by
05:07 - the way in Python you're going to get a
05:09 - return value of 3 however in C plus plus
05:11 - when you do the pop operation you're not
05:14 - going to get any return value
05:16 - all right this is super important
05:18 - especially when it comes to
05:19 - implementation keep the language
05:21 - specific details in your mind
05:23 - all right the last thing which will also
05:25 - very commonly use is to check whether
05:28 - the stack exists or not in other words
05:31 - is the stack empty or not
05:33 - so in Python we can simply use the stack
05:35 - variable and that internally checks its
05:38 - length so in our case we appended one
05:41 - element we checked the top of the stack
05:43 - and then we popped it out so the stack
05:44 - is currently empty in both the cases
05:47 - now if you just use stack if you say if
05:50 - stack colon blah blah blah that is going
05:53 - to return of value of faults
05:55 - because the stack is empty right in C
05:58 - plus plus we can do s dot empty which is
06:00 - a function that is going to work on the
06:02 - stack variable and it's going to return
06:04 - true saying that you know what the stack
06:06 - is indeed empty
06:07 - so again small implementation level
06:09 - details that you have to keep in mind
06:12 - all right so now that we have a better
06:13 - understanding of how do we Implement
06:15 - Stacks let's go ahead and take a look at
06:17 - a real life test case where Stacks will
06:21 - be very helpful to understand hello
06:23 - everyone and welcome back
06:26 - in the previous video we talked about
06:28 - how to implement Stacks in terms of C
06:30 - plus plus and python in this video we're
06:33 - going to take an example problem
06:35 - simplify path to build up our
06:37 - understanding of stacks further in fact
06:40 - this question is present of both lead
06:42 - code and interview bit and has been
06:44 - asked in companies coding interview
06:45 - rounds many times
06:47 - this in fact forms a basis for very
06:50 - important point that how Stacks are
06:53 - being used in the real world as well
06:55 - all right let's go ahead and get started
06:57 - with the formal problem discussion
06:59 - so we're given a path and this path is a
07:02 - Unix path given to us and the goal of
07:04 - this problem is to return the canonical
07:06 - path now if you're not familiar with how
07:08 - paths are unique Unix based paths work
07:11 - I'm going to link to resources down
07:13 - below so you can check them out first
07:15 - anyways we're given a path and we have
07:17 - to follow four conditions to return a
07:20 - canonical path first we have to start
07:22 - from a single slash the slash represents
07:25 - nothing but the root directory
07:27 - second any two directories are separated
07:30 - by a single slash so we can have
07:32 - directory one slash directory 2 slash
07:35 - blah blah blah
07:37 - condition 3 says that we should not end
07:40 - with a trailing slash in other words the
07:43 - slash at the end of it if there is a
07:45 - slash at the end of it you have to
07:47 - return it
07:48 - all right fourth condition which is the
07:50 - most important one it says that it only
07:52 - contains the directories on the path
07:54 - from the root to the Target that is
07:57 - there is no period or double period
07:59 - directories now period and double period
08:02 - have special meanings period basically
08:04 - says that wherever you are stay that is
08:07 - whatever directory you are on currently
08:09 - just stay over there
08:11 - double period means take a step back
08:14 - right so whatever directory you are on
08:15 - take a step back
08:17 - all right let's try to uh formally build
08:19 - up our intuitions and our logic all
08:22 - right let's take a couple of examples to
08:24 - understand this better first things we
08:26 - have a slash home slash SD input the
08:29 - blue is the input and the green is the
08:30 - output which by the way is a common
08:33 - coloring schema followed throughout the
08:35 - rest of the series so you don't have to
08:36 - worry about anything
08:37 - all right so we have slash home slash
08:40 - and what is the output the output is
08:43 - slash home that's because we have a
08:45 - trailing slash at the end of the input
08:46 - which we remove
08:48 - all right let's go ahead and take
08:49 - another example
08:51 - in this case we have slash dot dot slash
08:54 - what it means is we start from the root
08:56 - directory and we have to take a step
08:58 - back because dot dot really means that
09:00 - you have to take a step back from the
09:02 - current directory
09:03 - and then we have a slash at the end so
09:05 - of course you can remove the slash at
09:07 - the end because it's a trailing slash
09:08 - but now this double dot means that from
09:11 - the root directory we have to take a
09:13 - step back but there is no step Backs
09:16 - from the root directory root directory
09:18 - is where you start
09:19 - so in fact this will simply be reduced
09:21 - to staying on the root directory that is
09:24 - from the root if you want to take a step
09:26 - back you will end up at the same route
09:29 - all right let's take another example and
09:31 - this time we have slash home slash slash
09:33 - 1337 slash dot slash
09:37 - first things first remove the trailing
09:39 - slash now what we notice that between
09:41 - home and 1337 there are actually two
09:44 - slashes
09:45 - what does that mean well in our case the
09:48 - implementation level detail is that if
09:51 - there are multiple consecutive slashes
09:53 - all of them will be useless basically
09:55 - and we only have to consider one slash
09:58 - in other words multiple slashes will get
10:01 - compressed to a single slash so we have
10:03 - slash home slash 1337
10:06 - note that the period at the end now
10:07 - means that we have to stay at the
10:09 - current directory
10:10 - so we were at 1337 and we stayed at 1337
10:15 - let's take a look at one final example
10:17 - which is going to be the most important
10:19 - one and this has sort of all of the
10:21 - conditions mentioned in the question so
10:23 - let's go ahead and formally try to break
10:25 - this down to get the logic
10:27 - first things first we start off with the
10:30 - single slash which is going to be a root
10:32 - directory this is by default present in
10:34 - all the test cases we have to start from
10:37 - the root directory
10:38 - now what's the next step we want to go
10:40 - toward the next value which we see is
10:43 - home
10:44 - now what does home mean
10:46 - who means that we have to go One
10:47 - Directory forward that is from the root
10:50 - you have to go to home
10:52 - all right so pretty simple but now you
10:54 - get a dot dot
10:57 - what does this mean this means that you
10:59 - have to take a step back which means
11:02 - that from the root you first went to
11:03 - home but now you have to take a step
11:05 - back and go back to the root
11:07 - all right pretty simple again uh work
11:10 - next we get a dot dot once again and
11:12 - since we are already at the root taking
11:14 - another dot dot simply means that go
11:16 - straight at the root
11:19 - all right so now we get a slash uh TMP
11:22 - and what does that mean
11:23 - that means that now we have to take a
11:25 - step forward we have gotten the
11:26 - directory and so we'll go to slash TMP
11:30 - and then we have a bunch of slashes
11:32 - together that we have two slashes that
11:34 - just gets compressed to one single slash
11:36 - and then we have a DOT
11:38 - now dot simply means that wherever you
11:40 - are stay so you viewer are the slash
11:43 - temp directory and we'll stay over there
11:46 - and of course the last slash at the end
11:48 - is just a trailing one so we'll remove
11:49 - it
11:51 - in other words the final answer we get
11:52 - is slash TMP as we saw in the first line
11:55 - of this slide
11:57 - so now let's go ahead and formally talk
11:59 - about how did we do this
12:01 - how are we going to implement this going
12:03 - forward and going backward thing
12:06 - if you have guessed it yes you are right
12:08 - we have to use the data structure
12:12 - of course this is a playlist of our Sac
12:14 - we have to use a stack
12:16 - but why do we use it again
12:19 - whenever we have a directory like home
12:22 - or slash TMP we have to take a step
12:24 - forward and whenever we have dot dots we
12:27 - have to take a step backwards and a good
12:30 - way to simulate that is by using a stack
12:33 - all right let me go ahead and show you
12:35 - how this formally works out
12:37 - so the first thing we get is uh home so
12:39 - home means that we have to move forward
12:41 - which means that we will push the value
12:44 - home on to the stack
12:46 - that is we'll append this value to the
12:49 - top of the stack
12:50 - now we get a dot dot next what does that
12:53 - mean that means that we have to go back
12:55 - One Directory in other words we have to
12:58 - pop the element out of the stack
13:01 - right we get a dot dot once again but
13:03 - the stack is already empty what do we do
13:06 - this is a special condition and we have
13:08 - to say that you know what if the stack
13:10 - is empty you can't really pop anything
13:11 - and we don't really have to pop either
13:14 - we were at the root and we'll stay at
13:16 - the root so the stack remains as is
13:19 - then we have TMP so what do we do next
13:23 - this is a directory so we append it we
13:26 - push this value on the top of the stack
13:29 - now we get a DOT what does that mean
13:31 - that means whatever directory you are at
13:34 - stay there in other words the stack
13:36 - remains unchanged
13:39 - so if we have to formalize what can we
13:41 - say
13:42 - let's focus on the core Parts first
13:45 - things first how do we start
13:47 - the way we start is at the root and that
13:49 - is nothing but the cue to initialize the
13:53 - stack
13:53 - right whenever we start we're going to
13:55 - initialize the stack now directory means
13:58 - taking a step forward what does that
14:00 - mean
14:01 - that means that we're going to append an
14:03 - element onto the top of the stack in
14:06 - other words we are going to push this
14:07 - directory in the stack
14:10 - right and what does dot dot mean dot dot
14:13 - now means that we have to pop we have to
14:15 - go One Directory backward
14:17 - so whatever you append it just pop it
14:19 - back again
14:20 - and then finally we have a DOT which
14:23 - means that we really do nothing do no
14:25 - operations
14:27 - and this is really it this is it for the
14:30 - logic of this problem let's go ahead and
14:31 - look at the optimize solution and we're
14:33 - going to code it up from scratch all
14:35 - right let's go ahead and look at how do
14:37 - we implement this question in terms of
14:39 - python code
14:41 - the first thing we'll do is initialize
14:42 - the stack to be an empty stack
14:45 - and then we'll start to iterate over the
14:46 - directories
14:48 - in the paths
14:49 - now obviously the path given to us is
14:52 - going to be a string
14:53 - which is separated by these flashes so
14:56 - each of them directories
14:57 - that is any two directories are
14:59 - separated by a single slash
15:01 - so we have to say go ahead and do path
15:03 - dot split
15:05 - by the Slash
15:07 - that is
15:08 - get me the individual directories and
15:10 - we'll see what to do next
15:12 - so what's the first condition we saw
15:14 - remember from the code remember from the
15:16 - logic the first condition we can say is
15:18 - that you know what if you get a DOT that
15:21 - is if you get the operation where the
15:24 - directory
15:26 - we have to move to is a DOT that means
15:29 - that wait don't really do anything
15:31 - right we don't really do any operation
15:33 - on the stack if we get a single Dot
15:36 - so it was the other case we'll have the
15:38 - directory
15:42 - is what if it's a double lot what do we
15:45 - do
15:46 - if it's a double dot we have to do an
15:48 - operation called pop
15:51 - that is we have to go back one step we
15:53 - have to pop the element from the top of
15:55 - the stack so we'll do stack dot pop
15:58 - but now is a very important Edge case
16:01 - right this is a very important condition
16:04 - I'm going to write see it's not always
16:06 - the case that you can pop this directory
16:08 - from the stack
16:09 - that is for stack dot pop to work you
16:13 - have to ensure that stack is not empty
16:16 - because if the stack is empty and you
16:18 - pop an element out of the stack that is
16:21 - going to give you an error whether it be
16:23 - a python or C plus plus or Java all of
16:25 - these languages are going to give you an
16:27 - error if you pop an element out of the
16:30 - empty stack so first we'll go ahead and
16:32 - check hey you know what if the stack
16:34 - exists only then go ahead and do the
16:37 - stack dot pop operation
16:40 - what do we do else what do we do
16:42 - otherwise
16:43 - well in case this Jack is already empty
16:45 - and we get a double dot what does that
16:48 - mean
16:50 - on an empty stack which means that we
16:52 - are at the root and we get a double dot
16:54 - which means that from the root we have
16:56 - to move a step back
16:57 - which means that we just have to stay at
16:59 - the root so the stack remains as is and
17:02 - this condition in the else condition we
17:04 - don't really have to do anything
17:06 - all right it was the final case what the
17:08 - final case is say that go ahead and
17:12 - append this value to the stack append
17:15 - this directory
17:16 - to the stack all right so this is it
17:20 - right we're going to return what
17:22 - well one of the conditions the first
17:24 - condition and the question says that the
17:25 - path starts with a single slash
17:28 - so we're going to go ahead and start
17:29 - with the single slash
17:31 - and since we have all the directories in
17:33 - the stack let's go ahead and do the join
17:35 - operation so we'll do uh
17:38 - join Dot
17:41 - start
17:42 - so what this is going to do is iterate
17:44 - over all the elements in the stack and
17:46 - join them with a slash in the middle
17:49 - all right so before we go ahead and run
17:51 - this code by the way there's one more
17:53 - condition that is important to know
17:55 - see because directories can have a case
17:58 - where we have say double slashes that is
18:01 - if we have slash home slash Foo slash
18:04 - these double slashes are going to give
18:06 - us an issue
18:07 - because when we split when we split this
18:11 - path by slash it means that there is
18:13 - going to be a case where there is one
18:14 - slash and then there's a empty string
18:17 - and then another slash
18:19 - in other words what I'm saying is we
18:22 - have to add one more condition saying
18:24 - that if the directory
18:26 - is actually empty
18:28 - that is if there were multiple
18:30 - consecutive slashes
18:31 - then we don't have to do anything like
18:33 - that
18:34 - right if we get multiple slashes we just
18:37 - look at it as one slash
18:39 - and we don't really do anything
18:40 - right so
18:42 - this is it for the logic of the code and
18:45 - let's go ahead and test this out on a
18:47 - bunch of input test cases
18:50 - looks to be correct so let's go ahead
18:51 - and submit this
18:54 - and we get it accepted
18:57 - all right so this is it for the solution
18:58 - to the problem simplify path
19:00 - hello everyone and welcome back let's
19:04 - talk about the problem main stack on
19:06 - interview bit
19:07 - all right so the goal of this problem is
19:10 - to design a stack that supports a bunch
19:13 - of operations first Operation Push
19:16 - we have to push an element X onto the
19:18 - stack very simple
19:20 - second operation you have to design an
19:22 - operation that returns as the top of the
19:24 - element that is it is going to see what
19:27 - is the top of the stack and return it
19:31 - third operation we have to design a
19:33 - function that pops the value out of the
19:35 - stack we have to remove the top element
19:37 - and return it right so all of these
19:41 - three operations up till now are
19:42 - something we've already seen that are
19:45 - like very basics of what a stack is
19:48 - but now there is a fourth operation
19:49 - given to us getman
19:52 - this function is going to return a value
19:54 - X which is going to be the minimum value
19:56 - of the entire stack
19:58 - now the only constraint that is given to
20:00 - us is that all of the queries should run
20:03 - in constant time that is we should take
20:05 - order of one time each
20:08 - now how do we start to think about a
20:10 - solution
20:11 - once since the problem is about using a
20:13 - stack let's go ahead and create a stack
20:15 - and we'll start to see what do we do
20:17 - once we get the queries all right so
20:19 - this is the simulation will run let's
20:21 - say we get the um
20:23 - query to push the value 7 onto the stack
20:26 - so now this is how the stack is going to
20:28 - look with the value 7 on top of it
20:31 - if you get push 3 we'll just Add 3 to
20:33 - the top of the stack
20:35 - we hit push nine
20:37 - we add 9 to the top of this track
20:40 - now let's go ahead and say that we get
20:41 - the query getman
20:43 - what do we do at this point of time
20:46 - gateman query says that go ahead and get
20:48 - the minimum element of the entire stack
20:52 - which means that a naive way to proceed
20:54 - about it is to go over all of the
20:56 - elements inside of the stack one by one
20:58 - and find the minimum value
21:01 - in this case we find the 3 is the
21:03 - minimum value so we'll go ahead and
21:04 - return 3.
21:06 - now let's say that we get another
21:07 - operation called pop so we'll go ahead
21:10 - and pop the element out of the top of
21:12 - the stack then let's say we get uh get
21:15 - min again
21:16 - what are we going to do iterate over the
21:19 - entire stack go over all of the elements
21:21 - one by one and return three we realize
21:24 - that three is the minimum value right so
21:27 - let's go ahead and say we get another
21:28 - value another Operation Push one so we
21:31 - will add one to the top of the stack
21:32 - getman says
21:34 - well
21:36 - get me the minimum value of all the
21:38 - elements in the stack which means that
21:40 - the value will be 1.
21:42 - now if you realize what we have been
21:44 - doing up till now is all of the
21:46 - operations like portion the pop even the
21:49 - top are going to take order of one time
21:51 - to run as it does in normal stack
21:53 - however the gate main operation is kind
21:56 - of a pain
21:57 - that is because we have to iterate over
22:00 - the entire stack one by one taking order
22:02 - of end time where n is the number of
22:05 - elements in the stack
22:07 - this means that there has to be a better
22:09 - way to do it we have to figure out a way
22:11 - to answer the getman query in order of
22:14 - one time
22:15 - all right so let's go ahead and talk
22:16 - about the optimization
22:18 - this is one of those questions where if
22:20 - you don't know what to do you really
22:23 - would have no idea on how to proceed
22:25 - and in these kind of questions what we
22:27 - are going to do is we're going to create
22:28 - another stack that's right we're not
22:31 - doing just going to have one stack we
22:33 - are going to have two stacks the first
22:35 - is the blue one which we already saw
22:37 - which will handle the queries like push
22:39 - and the Bob in the top
22:40 - but we will also have a green stack
22:43 - which is going to keep a track of the
22:45 - minimum value we have seen up till now
22:49 - let me go ahead and show you the
22:50 - simulation once again and that will make
22:52 - a lot more sense
22:54 - because it's a beautiful way to approach
22:56 - this problem right so let's go ahead and
22:58 - say we get the query push second we get
23:01 - the request to do push seven so we'll
23:03 - just add 7 on the top of the stack now
23:06 - this is the stack we're going to append
23:08 - it to we're going to add it to the blue
23:09 - stack directly whatever query we get we
23:12 - directly apply it to the bluestack
23:15 - the green stack will simply reflect the
23:17 - changes of the blue one
23:19 - so since we added 7 to the stack the
23:21 - minimum value of the stack is now 7 so
23:24 - we'll add 7 to the stack
23:26 - now let's say we get a push 3 Operation
23:28 - what do we do
23:30 - because this is a blue case we'll simply
23:32 - add 3 to the top of the stack but we'll
23:35 - have the three reflect changes in the
23:37 - green stack as well that is the green
23:40 - stack is now going to store a value that
23:42 - is the minimum of 7 and 3 because we
23:44 - have two elements on the top of the
23:46 - stack right
23:48 - so we're going to have minimum of 3 and
23:50 - 7 and so we'll store three
23:52 - now let's say we go ahead and get the
23:54 - value as uh let's say we get a push nine
23:56 - operation
23:57 - now the top of the blue stack will have
23:59 - nine but the top of the green stack will
24:02 - have the value 3.
24:04 - and that is because 3 is the minimum
24:06 - value of 3 and 9 which is going to be
24:08 - the minimum value of the entire stack
24:12 - all right so now what do we do now we if
24:15 - we get a query get min what do we do
24:19 - simply look at the top of the green
24:21 - stack and return that as the answer we
24:25 - are not going to pop out anything at
24:27 - this point of time right
24:28 - as soon as we get a get main query we
24:31 - are going to Peak at the top of the
24:33 - green stack and return that value
24:36 - now let's say we get a operations which
24:38 - says go ahead and pop the element out of
24:40 - the stack
24:41 - so this is going to pop the element 9
24:43 - and now we have to make the green stack
24:45 - we reflect changes of the blue one since
24:48 - we removed an element we will also have
24:50 - to remove the element from the green
24:52 - stack
24:53 - now what if we get a getman query once
24:55 - again
24:56 - if we get a getman query we'll simply
24:58 - look at the top of the stack
25:00 - and since the value 3 will return 3.
25:03 - right so now let's say we get a push one
25:07 - operation what do we do one gets
25:10 - directly pushed onto the green sorry
25:12 - pushed on to the blue stack and the
25:14 - green stack is now going to reflect the
25:16 - changes green stack is going to have the
25:19 - value the minimum of three and one that
25:22 - is it is going to take the minimum of
25:25 - the previous element on the top of the
25:26 - stack
25:27 - the one which we got currently
25:30 - all right so now if I get uh get men
25:33 - again what do we do
25:35 - look at the top of the stack and return
25:37 - one as the answer
25:39 - all right so this is really it for the
25:41 - logic of the code what we have done is
25:43 - we have figured out a way to implement
25:45 - the solution using two stacks so let's
25:47 - go ahead and initialize
25:49 - sorry
25:52 - and uh let's go ahead and create self
25:54 - dot stack
25:56 - and we'll have self dot Min stack right
25:59 - these are the two stacks that we
26:00 - initialize this is the green one
26:03 - and this is the blue one all right now
26:06 - what do we do when we get a push query
26:08 - the stack the stack that we have the
26:11 - blue one is simply going to reflect the
26:13 - changes directly so we'll say when we
26:15 - get a push operation self dot stack dot
26:18 - append X nothing special
26:20 - but what do we do about the Min stack
26:23 - Min stack is going to reflect the
26:25 - changes so I'm going to say
26:27 - self.minstack dot append
26:29 - well I want to append the minimum value
26:31 - of the current X that is I'm going to
26:34 - take the current value and find the
26:37 - minimum with the Min stack top
26:40 - so we'll go ahead and do the main stack
26:42 - find the Top Value and take their
26:44 - minimum right pretty simple
26:46 - this is exactly what we discussed before
26:48 - but now we have to take care about one
26:51 - thing this is a common thing which we
26:53 - have to take here across all the stack
26:55 - questions see what we have tried to do
26:57 - here is that we have to try to access
26:59 - the minus one element on the Min stack
27:02 - that is I'm going to find the top
27:03 - element of the main stack but this will
27:06 - only work
27:07 - when will it work this will only work if
27:12 - the self dot main stack is not empty
27:15 - but if it's empty what do we do
27:18 - look if it's not empty we'll simply take
27:20 - the Min of X and the top of the stack
27:21 - but if it's an empty stack let's just go
27:24 - ahead and directly append this element
27:26 - to the main stack so we'll do self dot
27:28 - mainstack dot append
27:30 - X
27:31 - all right this makes sense
27:34 - so now what do we do when we get the pop
27:36 - operation
27:37 - remember we have to ensure that all of
27:41 - the changes in the stack
27:43 - are reflected in the green one as well
27:45 - so when we do self.stag.pop
27:48 - we have to do the pop operation for the
27:51 - Min stack as well
27:53 - again one more Edge case one more
27:55 - condition you can only do pop when you
27:58 - can only do pop if the stack is not
28:01 - empty so we'll say if
28:04 - self dot stack exist that is there are
28:07 - elements inside of the stack then you
28:08 - can do pop
28:09 - but if the stack is empty pop will
28:12 - really do nothing so we'll just say it's
28:13 - pass right now what do we do when we get
28:16 - top again uh here we have to return what
28:20 - is value at the top of the stack so
28:22 - we'll do stealth dot stack
28:24 - minus 1.
28:26 - but wait a second it is not guaranteed
28:29 - that the self of TAC of minus 1 is going
28:31 - to exist
28:33 - in other words the stack might be empty
28:35 - so if
28:37 - self dot stack exists well then you can
28:40 - go ahead and do this
28:41 - but what do we do otherwise
28:43 - the stack is empty and we are asked to
28:45 - return the top element of the stack
28:48 - well look at the condition
28:51 - in the question mentions something
28:54 - what should top do on an empty stack
28:57 - return -1 so in this case we are going
29:01 - to return
29:02 - -1 right what do we do when we get get
29:04 - min now
29:06 - remember
29:07 - in the top function we return the top of
29:10 - the stack which is the stop of the blue
29:12 - stack but in the getman function we're
29:15 - going to return the top of the green
29:16 - stack so we'll say if self
29:20 - self.minstax exist well then you can go
29:24 - ahead and return the self dot main stack
29:26 - stop
29:28 - but if it does not
29:30 - go ahead and return
29:31 - -1 you can see that there's a lot of
29:33 - paddles between gateman and the top
29:35 - that's because the only thing that
29:37 - changes is the stack in top we use the
29:40 - blue stack and in the green one green
29:43 - one is used in the getman function
29:45 - all right let's go ahead and test this
29:47 - out quickly
29:48 - looks like this is correct so we'll go
29:50 - ahead and submit this
29:55 - all right we get it accepted and this is
29:58 - it for the solution to the problem men
30:00 - stack on interview bit all right that's
30:03 - it hello everyone and welcome back now
30:06 - this is after our first section on where
30:08 - we discuss the stack related questions
30:10 - where we built up our understanding of
30:13 - stacks the implementation level details
30:15 - along with a couple of example problems
30:17 - to help us understand things better
30:19 - in this section we're going to focus on
30:21 - parentheses related questions which is
30:24 - actually going to be a step up from the
30:25 - previous one and is going to lead us to
30:28 - calculator related questions in the next
30:30 - section
30:31 - now why are we talking about parentheses
30:33 - questions in stack playlist
30:35 - you will get the questions answered very
30:37 - soon what we're going to look at is a
30:39 - bunch of example problems like valid
30:41 - parentheses longest valid parentheses
30:43 - written in braces and many more
30:46 - these are commonly asked in interviews
30:48 - and applying Stacks to these problems
30:51 - becomes a crucial part of understanding
30:53 - Stacks themselves
30:55 - all right now we will go ahead and take
30:58 - a look at an example and we'll try to
30:59 - build up our understanding of
31:01 - parentheses related questions and
31:03 - calculated related questions later on
31:06 - because what we're going to understand
31:07 - is the reason why we use Stacks inside
31:12 - of these parentheses questions in the
31:13 - first place
31:16 - all right so given this expression to
31:17 - you let me ask you the question if I
31:19 - give this to you on a paper and I'll
31:22 - give you a pen to solve this how would
31:24 - you go about solving this kind of
31:25 - expression
31:27 - the first thing you would want to do is
31:28 - look at the innermost brackets that is
31:31 - the innermost brackets contain the value
31:33 - D so let's go ahead and evaluate that
31:36 - first
31:37 - right you want to focus on the innermost
31:39 - first and then slowly zoom out to the
31:41 - outermost now what do we do zoom out to
31:45 - we would zoom out to B minus D in The
31:47 - Next Step and this would then finally
31:49 - lead us to the entire expression
31:52 - what we have done is nothing but parsing
31:55 - now parsing is a fancy word for what it
31:58 - means is
31:59 - we have to figure out the structure of
32:02 - the input that is it parsing means to
32:05 - figure out how the input is laid out
32:08 - now why do we want to understand the
32:10 - structure of the input why is this kind
32:12 - of thinking helpful
32:14 - let's take a look at a simple example
32:15 - we'll take this simple example and in
32:18 - this case we have two opening round
32:20 - brackets and two closing round brackets
32:22 - now if I ask you the question can you
32:24 - tell me
32:25 - what is the corresponding opening
32:28 - bracket to this current closing round
32:30 - bracket that is I've highlighted this
32:33 - closing round bracket for you can you
32:34 - tell me which of these
32:37 - is the corresponding current opening
32:40 - bracket
32:41 - pretty simple to answer because we
32:43 - already know the way we do this is by
32:45 - taking the bracket that is the closest
32:47 - we figured that this opening bracket
32:50 - came in the last and was the first one
32:52 - to get a result
32:55 - wait a second
32:56 - the bracket which came in the last was
32:59 - the first one to get resolved that is
33:02 - we're following something of the sort of
33:04 - a leaf ordering
33:06 - that's right this is the reason why we
33:09 - use Stacks in these parentheses
33:11 - questions
33:12 - because when to use stack is answered
33:15 - whenever we see Lee for ordering right
33:18 - so we have seen that we have to use a
33:21 - stack in parentheses questions and in
33:23 - calculator related questions as well but
33:25 - how exactly do we use it
33:27 - how do we use tax in these kind of
33:29 - questions
33:31 - what we are going to do is we are going
33:33 - to do a left to right parsing as I
33:35 - explained earlier parsing is a fancy
33:37 - word what it simply means is we have to
33:39 - understand the structure of the input we
33:41 - have to break it down step by step and
33:43 - understand okay this is what gets
33:45 - resolved first and this is what get
33:47 - resolves later on now left to right
33:49 - simply means that we're going to iterate
33:51 - from the left to the right
33:53 - okay enough talking let me actually show
33:55 - you with an example so this is the
33:57 - example case we took earlier and we have
33:59 - initialized an empty stack on this
34:02 - all right so what do we do next
34:04 - well here's a rule that you have to keep
34:06 - in mind
34:08 - anything that you get which is a opening
34:10 - bracket a character Like A B C D or an
34:13 - operator like plus minus division
34:15 - multiplication anything of that sort you
34:18 - get you simply append it to the stack
34:20 - that is you push
34:22 - everything except close brackets on the
34:26 - top of the stack
34:27 - here's what I mean say we get this
34:29 - opening round bracket we do nothing but
34:31 - push this on the top of the stack
34:33 - then we get a push it on top of the
34:36 - stack then we get Plus
34:38 - open curly bracket B minus open around
34:40 - bracket d
34:42 - the only time V and B do not append
34:45 - items on a stack is when we get a
34:47 - closing bracket this is important this
34:49 - is very important
34:51 - if we get a opening bracket a character
34:54 - or an operator whatever
34:56 - we directly added to the stack without
34:58 - thinking without having second thoughts
35:00 - but as soon as we get a closing bracket
35:03 - of any kind we have to start thinking
35:06 - all right so I already asked you the
35:08 - question of what this closing bracket
35:09 - actually closes what is the
35:11 - corresponding opening bracket and if you
35:13 - see in the stack we actually have that
35:15 - value with us we have this opening round
35:17 - bracket on the top on this stack here
35:19 - however that is not the top element and
35:22 - it might not always be obvious which of
35:25 - these opening brackets am I closing
35:28 - right because we have a currently we
35:30 - have a closing bracket in our hand and
35:32 - we want to figure out hey what is the
35:34 - area that I close
35:36 - what is the area what is the expression
35:38 - that needs to be resolved first because
35:40 - I'm following the leaf forwarding again
35:42 - so what we do is we'll keep on popping
35:44 - these elements of the top of the stack
35:46 - till we see a corresponding opening
35:49 - round bracket here's what I mean as soon
35:52 - as we get this closing around bracket
35:54 - we'll go ahead and start looking for the
35:55 - opening round bracket so we'll pop out D
35:57 - because D is not opening round bracket
35:59 - and so D sort of in an intermediate
36:01 - state
36:02 - we don't really know if D is part of a
36:04 - valid expression or not so we'll just
36:06 - keep it hold
36:08 - right now what we get
36:11 - on the top of the stack you see that
36:13 - there's a opening round bracket
36:15 - what does that mean currently look at
36:18 - the yellow marker we are at a closing
36:20 - round bracket and on the top of the
36:22 - stack we have found a opening round
36:23 - bracket in other words everything inside
36:27 - of both of these brackets is going to
36:30 - get resolved
36:31 - both of these brackets satisfy each
36:34 - other both of them resolve each other
36:35 - and everything in the middle of them
36:37 - will get satisfied so D is actually part
36:40 - of a valid string now right the brackets
36:43 - are balanced in a way
36:45 - all right so now let's go ahead and look
36:47 - at what happens later on we'll keep on
36:49 - iterating and we get a closing curly
36:51 - bracket now what do we do again this is
36:54 - a closing bracket so we have to be
36:56 - careful
36:57 - what do we do we look at the value on
36:59 - the top of the stack this is clearly not
37:01 - opening curly bracket so we'll go ahead
37:03 - and remove it but we'll keep it on hold
37:05 - minus maybe or may not be a part of a
37:08 - valid string
37:09 - all right so we have B now again B is
37:12 - not an opening curly bracket so we can't
37:14 - care about that
37:16 - so B and minus are both at an
37:18 - intermediate State we can't really see
37:19 - anything about
37:21 - what do we get now
37:24 - we have a opening curly bracket in other
37:27 - words we have found the opening for this
37:31 - closing curly bracket which we are on
37:32 - currently
37:34 - in other words what does that mean
37:36 - that means we have resolved everything
37:38 - in the middle of these two brackets so
37:41 - you can see somehow that kind of
37:42 - structure is being followed again we
37:44 - have sort of parsed the input we're
37:45 - trying to understand how this input is
37:47 - laid out all right so now what do we do
37:51 - next let's go ahead and keep on
37:52 - iterating so we get a start again this
37:54 - is not a closing bracket so we'll just
37:56 - add it directly we get a c not a closing
37:59 - bracket added directly and now we get a
38:01 - closing round bracket what do we do next
38:04 - what do we do think about it
38:07 - we're gonna keep on popping these
38:09 - elements out one by one we're gonna keep
38:11 - on popping them out till we get an
38:15 - opening round bracket and as soon as we
38:18 - get an opening round bracket what do we
38:20 - know
38:21 - we know that everything in the middle of
38:23 - both of these brackets is going to be
38:25 - validated
38:27 - and this is the way we have figured out
38:29 - how to parse the input
38:32 - we knew that we had to use a stack
38:34 - because we could see the leaf ordering
38:35 - being followed in the way brackets were
38:37 - opens and closed
38:39 - and then we figured out how to exactly
38:40 - go about looking at the opening and the
38:42 - closing of brackets by using a left to
38:45 - right parsing
38:46 - now a quick small implementation level
38:48 - detail is how do we implement this
38:51 - in the previous example I showed you we
38:53 - were appending these brackets and the
38:55 - pluses and the minuses directly and you
38:58 - can do that you can directly add the
38:59 - elements or you can also add the indices
39:03 - now uh different questions will require
39:05 - different cases but in general if you
39:07 - want one single template just use
39:09 - indices
39:10 - that's because if you append indices to
39:13 - the stack you will obviously have a
39:15 - mapping to the elements as well but if
39:17 - you only append elements to the stack
39:19 - you might forget which indice which
39:21 - index it came from
39:23 - anyways that's a very small level detail
39:25 - but still important to keep in mind just
39:28 - make sure you are consistent with what
39:29 - you are appending to the style whether
39:31 - it be elements or indices right so what
39:35 - is the conclusion let's summarize this
39:36 - once more we figured out in all the
39:38 - parentheses and the calculated questions
39:41 - we have to use a stack why is that
39:44 - because these brackets were following a
39:46 - leaf ordering last ones to get in were
39:49 - the first ones to get out they were the
39:51 - first ones to get a result
39:53 - and how did we figure out how do we use
39:55 - it we know we have to use a stack and we
39:58 - iterate it from the left to the right
40:00 - and we parsed the input we figured out
40:02 - the input and the structure of the
40:04 - string that is given to us and finally
40:07 - you can either add elements or the
40:09 - indexes to the stack that's upon you and
40:11 - that's a small detail you can take care
40:12 - of later on as well
40:14 - all right so keeping these three rules
40:16 - in mind let's go ahead and work out a
40:18 - couple of problems to fully get
40:20 - comfortable with parentheses related
40:22 - questions hello everyone and welcome
40:25 - back let's talk about the problem valid
40:28 - parentheses on lead code this by the way
40:30 - is a slight bit modification of the
40:33 - problem balanced parentheses on entropy
40:35 - bit if we are able to solve this you you
40:37 - will obviously be able to copy paste the
40:39 - code and get it accepted for balanced
40:41 - parentheses as well anyways this entire
40:44 - solution is based upon the understanding
40:46 - from the previous video where we talked
40:48 - about the introduction to all
40:50 - parentheses based questions we figured
40:52 - out how do we use the leaf ordering how
40:54 - do we go from the left to right and
40:55 - pause the input and the way we exactly
40:58 - Implement Stacks so if you haven't
40:59 - checked that video out I'll highly
41:01 - recommend you do because this solution
41:03 - is based entirely on top of that in fact
41:07 - it's going to be a very easy version of
41:09 - what we have seen before
41:10 - all right let me go ahead and show you
41:12 - and take you step by step throughout
41:14 - this problem
41:15 - given a string s containing only
41:18 - brackets we have opening and closing
41:20 - brackets of the type round curly and
41:23 - square
41:24 - and the goal of this problem is to
41:25 - return true if s is valid and false
41:27 - otherwise
41:29 - so looking at the example cases we have
41:31 - the first one Returns the output issue
41:33 - because the closing and the opening
41:35 - brackets match and mix and match
41:38 - appropriately
41:39 - in the second case however there is a
41:42 - spray opening curly bracket which never
41:44 - gets closed in fact it is trying to
41:47 - close the round bracket which is going
41:50 - to be invalid so we have to return false
41:52 - in this case
41:53 - all right let's go and talk about the
41:55 - intuitions and the observations needed
41:57 - to solve this question a bit more
41:59 - formally
42:00 - we'll take the same test case and we'll
42:02 - try to build our understanding from this
42:04 - now if we focus on the opening round
42:07 - bracket we see that it gets close
42:09 - towards the very end we get a closing
42:12 - round bracket towards the very end so
42:14 - both of them resolve each other out
42:16 - all right what about the opening and the
42:19 - closing curly brackets well both of them
42:21 - again mix and match well and this
42:23 - closing bracket is able to close the
42:25 - appropriate opening bracket that is the
42:28 - closing query bracket wants an opening
42:31 - curly bracket to be present before it
42:33 - and it is so we can see that this is
42:36 - also a valid case
42:38 - what about the square brackets again the
42:41 - opening square brackets gets closed by
42:43 - the appropriate closing bracket
42:45 - so this is also valid which means that
42:47 - everything inside of this test case
42:49 - mixes and match as well the opening
42:52 - brackets are closed by the appropriate
42:54 - closing brackets so we return true in
42:56 - this case
42:57 - right let's take another example and
43:00 - this time we have something more
43:01 - interesting going on because we have the
43:03 - same number of opening and the closing
43:05 - brackets that is for one opening around
43:07 - bracket we have one closing round
43:09 - bracket one opening curly bracket we
43:12 - have one closing curly bracket
43:14 - but the ordering in this case is meshed
43:17 - up
43:18 - that's because if you can notice this
43:21 - closing round bracket is trying to close
43:23 - an opening curly bracket
43:26 - obviously this will never work
43:28 - because this closing curly bracket sorry
43:31 - this closing round bracket wants to
43:34 - close an opening round bracket it cannot
43:37 - close the opening curly bracket so
43:39 - brackets in this case do not match
43:42 - and obviously this is contrasted with
43:43 - the case where we have the same number
43:45 - of opening and the closing ground and
43:47 - curly brackets
43:49 - but one of them is invalid and the other
43:52 - is valid
43:53 - so clearly ordering matters
43:55 - and if you notice
43:57 - the input has to follow this Leaf
44:00 - ordering that we discussed in the
44:01 - previous video as well that is the last
44:04 - bracket to get in should be the first
44:07 - one to get out
44:09 - and that was sort of the intuition
44:11 - behind using a stack and we also
44:13 - discussed how do we go from the left to
44:15 - the right and parse the input
44:17 - let's go ahead and do that in the next
44:18 - step
44:19 - one more thing we also discussed that if
44:23 - the brackets open add them directly if
44:25 - the brackets close check what they are
44:28 - closing
44:29 - that is if you get any kind of opening
44:33 - bracket just add it to the stack without
44:35 - thinking Twice But as soon as you get a
44:38 - closing bracket what do you do as soon
44:41 - as you get a closing bracket you have to
44:43 - check whether it closes the right
44:45 - opening bracket or not
44:47 - all right let's go ahead and go ahead
44:49 - with the simulation the first thing
44:50 - we'll do keep on iterating from the left
44:52 - to the right we get the first element as
44:54 - an opening round bracket opening bracket
44:56 - what do we do add directly no thinking
45:00 - then we may trade forward and we get
45:02 - opening curly bracket again since this
45:04 - is opening we'll just add it directly no
45:07 - thinking twice
45:08 - but now what do we get
45:10 - we get a curly closing bracket now we
45:13 - have to be careful we have to be very
45:15 - careful in what we do
45:17 - because as soon as we get a closing
45:19 - curly bracket what do we expect
45:21 - we expect that it closes an opening
45:25 - curly bracket because no other case will
45:28 - work out this closing curly bracket
45:30 - cannot close an opening round bracket or
45:32 - an opening square bracket it can only
45:34 - close and opening curly bracket so now
45:37 - following that leaf ordering again we
45:39 - look at the top of the stack what is the
45:41 - top of the stack
45:42 - it's a opening curly bracket so that's
45:45 - great but this current closing around
45:48 - sorry this current closing curly bracket
45:51 - we found an appropriate opening curly
45:54 - bracket in other words both of them
45:56 - validate each other and satisfy each
45:58 - other pretty nice right all right let's
46:01 - go ahead and continue iterating and we
46:02 - get an opening round bracket since it's
46:04 - opening we added directly
46:06 - but now what to have what happens next
46:09 - we get a closing square bracket
46:12 - what does that mean well this closing
46:14 - square bracket comes in and requests
46:16 - that hey uh can you get me an opening
46:18 - square bracket because that is who I can
46:20 - satisfy right I can mix and match well
46:22 - with the closing or sorry opening square
46:25 - bracket
46:27 - so we go ahead and look at the top of
46:28 - the stack and we see that it's the
46:30 - opening round bracket instead
46:32 - what does this mean
46:34 - this means that this closing bracket is
46:37 - actually invalid
46:38 - and so this was ill-validate the entire
46:41 - expression as soon as we get one invalid
46:44 - case one parentheses messes up as soon
46:47 - as one guy messes up the entire string
46:49 - gets canceled think about it that way
46:51 - right
46:53 - now just to another example is uh what
46:56 - happens if we had a closing round
46:58 - bracket
47:00 - what would happen in this case
47:02 - in this case what would happen is we
47:04 - would be able to mix and match well with
47:07 - the top of the stack
47:08 - so we can say that you know what this
47:10 - closing round bracket will be able to
47:13 - match with the stack top both of them
47:14 - resolve each other and we can move
47:16 - forward with our lives again this is a
47:19 - closing round bracket we'll check the
47:20 - top of the stack is it an appropriate
47:22 - opening bracket
47:24 - yes it is so let's go ahead and close
47:26 - that and we're done
47:29 - now what do we see happening at the end
47:31 - all of these brackets are validated all
47:34 - of the opening brackets have been closed
47:37 - and this is the reason why stack is
47:39 - empty
47:40 - remember this is another important
47:42 - condition which you might miss
47:44 - the stack should be empty at the end and
47:48 - what it says is really is that all of
47:50 - the brackets that opened which we put
47:51 - into the stack remember all the opening
47:53 - were put into the stack and all the
47:55 - closing were removing them from the side
47:57 - so if at the end the stack is empty that
48:00 - is a good sign because we were able to
48:03 - close all the brackets that ever opened
48:07 - now what's another case that could
48:09 - happen let's say that we have another
48:10 - curly bracket towards the end now this
48:13 - is the entire string what would happen
48:16 - in this case we would add it to the
48:17 - stack but this would never get resolved
48:21 - in other words it will be left alone and
48:24 - it would make the entire expression
48:26 - entire parentheses invalid
48:29 - right so it's very important for us to
48:31 - follow a couple of conditions let's go
48:32 - ahead and formalize the logic and that
48:34 - should make a lot more sense
48:36 - all right let's go ahead and talk about
48:38 - the code for the is valid parentheses
48:40 - question all right so first things first
48:42 - we'll go ahead and create a stack which
48:44 - is going to be an empty list
48:46 - next we want to create a mapping from
48:49 - the uh
48:50 - closing bracket to the opening bracket
48:53 - that is for this closing bracket for a
48:56 - closing curly bracket I expect an
48:58 - opening curly bracket to be present on
49:01 - the top of this track right this is
49:03 - something we've discussed already we
49:05 - have to do the same for opening and
49:07 - closing brackets for all the kind now
49:13 - all right cool so now that we have
49:14 - created the mapping we can finally go
49:16 - ahead and start to iterate from the left
49:18 - to the right so we'll go over all the
49:20 - characters in The String given to us
49:23 - now first things we'll check is that if
49:26 - the character is a opening bracket if
49:28 - it's round
49:30 - square or curly opening bracket then
49:33 - don't think twice
49:35 - just append it to the stack
49:38 - right
49:39 - because as soon as we get a opening
49:41 - bracket we directly add it to the stack
49:42 - without thinking twice this is something
49:44 - we've already established
49:46 - else else what do we do
49:48 - in the else condition things get more
49:50 - interesting because now I have to say
49:53 - you know what to check if the mapping of
49:55 - this character if the mapping of this
49:57 - closing bracket maps to the correct
49:59 - value present on the stack top
50:02 - that is for the closing bracket that I
50:05 - have right now can you check if it maps
50:07 - to the correct value that is the opening
50:09 - bracket of curly type on the top of the
50:12 - stack because if it does then it's good
50:14 - then it's good right
50:16 - and we'll see you know what since both
50:18 - of them match both of them resolve each
50:20 - other so I'm just going to do stack dot
50:22 - pop I'm going to remove this bracket
50:24 - that matched
50:26 - all right what do we do in the ash
50:27 - condition what do we say when there's a
50:30 - mismatch
50:31 - as soon as there's a mismatch I'm going
50:32 - to return false I'm going to be
50:34 - merciless as soon as you guys miss much
50:36 - I'm going to return false right away
50:38 - okay there's one more thing that we need
50:40 - to take care of
50:41 - see I've tried to access the stack of -1
50:44 - here what have we learned up till now
50:46 - you just cannot access this stack of -1
50:49 - just whenever you want you have to
50:51 - ensure if the stack exists
50:53 - and only when the stack exists you can
50:55 - do all of these operations well what do
50:58 - you do otherwise
50:59 - what if the stack does not exist
51:02 - what if the stack does not exist and you
51:04 - have a closing curly bracket or closing
51:06 - bracket of any kind rather
51:09 - in that case that closing bracket is
51:11 - trying to close something that doesn't
51:13 - exist in other words we can just set it
51:16 - on pause right away
51:18 - all right so at this point are we done
51:20 - can we return true
51:23 - not so fast this is where another
51:25 - mistake can occur
51:27 - we have to ensure that the stack is
51:29 - empty we have to ensure that the length
51:31 - of the stack is equal to equal to zero
51:35 - why because we already saw this example
51:38 - over here
51:39 - in this case we reached the end of the
51:41 - iteration and we had one curly bracket
51:43 - remaining in the stack
51:44 - and this curly bracket was never
51:46 - resolved it was never popped out of the
51:48 - stack
51:49 - which means that it Still Remains
51:51 - unresolved to this date
51:53 - in other words this entire expression
51:55 - became invalid just because the stack
51:58 - was not empty
52:00 - in just to reframe what does empty stack
52:03 - mean empty stack really means that
52:05 - although the brackets that were input
52:07 - into the stack all of the opening
52:09 - brackets that were ever inputted into
52:10 - the stack have been closed
52:14 - all right cool so let's go ahead and run
52:15 - this code and this gets accepted so
52:18 - let's go ahead and submit this once and
52:20 - we get it accepted as well
52:22 - all right cool so this is it for the
52:23 - solution to the problem valid
52:25 - parentheses hello everyone and welcome
52:28 - back
52:29 - let's talk about the problem redundant
52:31 - braces on interview bid
52:33 - now just a quick aside if you haven't
52:35 - watched the video introduction to
52:36 - parentheses question I highly recommend
52:39 - you watch it because we are directly
52:40 - going to use rules and logic that we
52:42 - formed in that video
52:44 - inside of this question because we're
52:46 - going to apply things directly without
52:47 - talking about it much that's going to
52:49 - make the solution a lot simpler all
52:51 - right anyways let's talk about the
52:53 - problem statement first given a string a
52:55 - containing operators round braces and
52:58 - letters so we have a bunch of operators
53:00 - like plus minus multiplication divide
53:02 - then we have our round braces so we have
53:05 - the opening and closing round brackets
53:06 - and a bunch of letters
53:09 - the goal of this problem is to return
53:10 - one if a has redundant braces and zero
53:13 - otherwise
53:14 - all right so let's go and take a look at
53:16 - some examples how do they find redundant
53:18 - in the first case we have a redundant
53:20 - brace because we have two sets of round
53:23 - brackets wrapping the a plus b when we
53:26 - only ever need one
53:28 - in the second case we see that there are
53:29 - no redundant brackets because we're
53:31 - going to make use of every single one of
53:32 - them
53:33 - so let's go ahead and take a look at
53:35 - some observations and logic from test
53:37 - cases given and really there is just one
53:39 - single observation that we need to pull
53:41 - out from these
53:42 - what is that let's try to build up to it
53:45 - the first test case we see is a plus b
53:47 - wrapped in these two sets of braces
53:50 - why is there redundancy in this because
53:52 - instead of 2 we can just use one right
53:55 - let's take a look at the last test Keys
53:57 - here we have a simple letter A which is
53:59 - wrapped inside of these parentheses
54:02 - but it looks like we don't really need
54:04 - this the example and the problem sector
54:06 - says that you know what this is a case
54:08 - of redundant braces because you don't
54:09 - really need to wrap a in anything else
54:12 - and in the middle we see that we have a
54:14 - plus a plus b in this case there are no
54:17 - redundant braces we're using every
54:18 - single thing
54:20 - now what do you notice
54:22 - there's actually one thing in common
54:24 - with all of them which makes the
54:26 - solution work and this is the central
54:28 - observation of the entire problem
54:30 - what is the observation
54:32 - the observation is there should be no
54:34 - operators in between these braces so in
54:37 - the first one you see between the first
54:39 - set of braces and the second set of
54:40 - braces there are either no letters and
54:43 - no operators right there are no letters
54:46 - or operators
54:47 - in the second one there are both letters
54:49 - and operators and a third one there is a
54:51 - letter but there is not an operator
54:53 - right so we have to ensure that there
54:56 - are no operators between any two sets of
54:58 - braces because if we can make this
55:00 - condition work then
55:02 - will have a case of redundant braces
55:05 - all right just a quick aside what are
55:07 - some of the rules that we saw earlier
55:09 - rules when do we decide when we have to
55:11 - use a stack
55:12 - we use a stack whenever we see a leaf
55:14 - ordering being followed and that is true
55:16 - for all parentheses questions so in this
55:18 - question we're also going to use a stack
55:20 - however we're going to use it we're
55:23 - going to go from the left to the right
55:24 - and parse the input see what uh
55:27 - structure this input is following
55:30 - and finally how do we implement this in
55:32 - this question the elements are the
55:33 - bigger uh Focus instead of the indices
55:36 - so let's just focus on elements let me
55:38 - actually go ahead and show this to you
55:40 - right as we discussed there should be no
55:42 - operators between any two sets of braces
55:44 - this is something we'll keep in mind as
55:46 - we go through the example
55:49 - all right so let's go ahead and iterate
55:51 - from the left to the right one by one so
55:54 - let's say we have the first element and
55:55 - that's the opening bracket so let's just
55:57 - push it on to the stack again if we get
56:00 - opening bracket if we get a operator or
56:03 - if we get a letter we push that onto the
56:05 - stack
56:06 - the only time we don't push an element
56:08 - onto the stack is when we get a closing
56:10 - bracket because then we need to be more
56:12 - careful again this is something I've
56:14 - already explained in the parentheses
56:16 - questions uh the introduction to
56:18 - parentheses questions video if you
56:20 - haven't checked it out if you haven't
56:21 - understood it well enough go ahead and
56:24 - dive into advanced mode right cool so
56:27 - we'll go ahead and continue iterating we
56:29 - get another opening round bracket so
56:31 - we'll just add it to the stack now we
56:33 - get a
56:34 - then we get plus and then we get B
56:37 - nothing special these are just opening
56:39 - brackets operators or letters we add
56:42 - them directly onto the stack without any
56:45 - question
56:45 - only when we get a closing bracket then
56:48 - we have to be careful all right so now
56:50 - that we have gotten a closing bracket
56:52 - let's try to be more careful with what
56:53 - we do
56:54 - what's the first thing we do well this
56:57 - closing round bracket is looking for an
56:59 - opening round bracket to close make
57:01 - sense
57:02 - so we look at the stack top well that's
57:04 - an element B
57:05 - um B is not really useful for us so
57:07 - let's just go ahead and pop that and
57:09 - we'll keep it as an intermediate state
57:11 - we don't really know if B is useful or
57:13 - not
57:14 - and then we see a plus now what does
57:16 - that mean look at the condition on the
57:18 - top right
57:19 - the question wants that there should be
57:21 - no operators if you want to have a
57:23 - redundant brace
57:24 - that is if you can find an operator in
57:27 - this case we have found an operator that
57:30 - means that the expression that we're
57:31 - going to interrupt in these two opening
57:33 - and the closing round brackets is
57:35 - actually going to be a non-redundant one
57:37 - we need those braces in this case again
57:41 - that is just how the problem is defined
57:43 - so now since we have found an operator
57:44 - let's go ahead and keep that in mind and
57:46 - we'll keep on popping these elements out
57:48 - one by one again so we go we pop out
57:51 - plus
57:51 - and then we also pop out a but now what
57:55 - do we have on the stack top there is a
57:58 - opening round bracket
58:00 - and what do we have currently the
58:01 - pointer is pointing to it's losing round
58:04 - bracket which means that everything
58:05 - inside of this has to be considered
58:07 - together right
58:09 - now since we found an operator What can
58:11 - we say about this current highlighted
58:13 - section
58:15 - we can say that this is actually non
58:17 - redundant case so this is actually a
58:19 - valid case of how braces are being used
58:22 - so let's not touch this we'll just keep
58:24 - on iterating forward
58:25 - so now we get a plus again it is not a
58:28 - closing bracket so we can just add it
58:30 - directly no thinking again opening
58:33 - bracket good to go C good to go
58:36 - ah but now we have a closing bracket so
58:38 - let's try to be more careful this time
58:40 - now what do we do
58:42 - the first thing we do is look at the
58:43 - stack top we have our element C again
58:45 - it's not an opening bracket so let's
58:47 - just pop it out keep it as a
58:49 - intermediate state
58:51 - and now what do we have we have a
58:53 - opening bracket so we have found an
58:55 - opening bracket for this current closing
58:57 - bracket what does that mean
58:59 - that means that the entire highlighted
59:01 - expression is what we have to look at
59:03 - right now
59:04 - but look at this
59:06 - there was no operator that we found in
59:08 - the middle
59:09 - right there was no operator in this
59:11 - highlighted expression
59:13 - which means that there are redundant
59:15 - array cells
59:17 - that's correct so this is what it means
59:20 - we have found a redundant bracket and we
59:23 - can return true that yes indeed there
59:25 - are redundant brackets in this input
59:28 - all right so let's go ahead and take a
59:30 - look at the optimized solution and we'll
59:31 - go ahead and code this up
59:33 - right so this is going to be the code
59:35 - where we start from an empty stack again
59:38 - very simple and then we'll go ahead and
59:40 - iterate over all the characters in the
59:42 - input string right
59:44 - now as I mentioned what is the first
59:45 - condition
59:46 - the first condition is if you get a
59:48 - letter if you get a operator or an
59:50 - opening bracket that is if you get
59:52 - anything other than a closing bracket
59:54 - this is directly appended to the stack
59:56 - no thinking at all
59:58 - all right when it goes to the edge
60:00 - condition we have to be a bit more
60:01 - careful
60:02 - so in this condition what we'll do is
60:04 - we'll keep a track of the count and this
60:06 - count keeps a track of account of the
60:08 - number of operators we have seen because
60:10 - remember that is what is going to tell
60:12 - us whether a bracket or whether an
60:14 - expression inside of the input is
60:16 - redundant or not so we'll start the
60:18 - count from 0 and we'll say you know what
60:20 - since we have found this uh closing
60:23 - ground bracket let's just go ahead and
60:25 - keep on popping these elements out from
60:28 - the top of the stack one by one till we
60:30 - get a
60:31 - opening round bracket right till we get
60:34 - a opening round bracket so we'll go
60:36 - ahead and say now if the Pod is actually
60:39 - an operator
60:41 - that is if it's any of the plus minus
60:44 - star or Division if the character is any
60:47 - of these operators then I want you to do
60:49 - count plus one
60:51 - in other words since we have found a
60:54 - positive number of counts of The
60:56 - Operators whatever the expression is
60:58 - going to be is going to be a valid
61:01 - non-redundant expression
61:03 - and of course at the end of this while
61:05 - loop we are going to do a stack dot pop
61:07 - because we want to pop out this uh
61:10 - opening bracket we don't really have any
61:12 - use for this at all
61:14 - anyways now what do we do
61:16 - once we're done with this entire
61:18 - iteration of this while loop we're gonna
61:20 - check what the condition is
61:23 - we're gonna say if the count is zero
61:25 - that is if the count did not change at
61:27 - all in other words we did not encounter
61:30 - any operators if we did not encounter
61:32 - any operators return one we have found
61:36 - the case of redundancy
61:38 - and if not we'll just keep on going
61:40 - forward going forward again and again
61:41 - and again and if throughout the entire
61:44 - iteration of this entire string you find
61:46 - no such redundancy then you can safely
61:49 - return 0. that is the entire string is
61:52 - non-redundant
61:54 - right so let's go ahead and test this
61:56 - out it looks like it works and we'll go
61:58 - ahead and submit this as well
62:01 - cool so this gets accepted and this is
62:04 - it for the solution to the problem
62:05 - redundant braces hello everyone and
62:09 - welcome back let's talk about the
62:11 - problem minimum removed to make valid
62:13 - parentheses this by the way is a medium
62:15 - level question on lead code and we're
62:17 - going to use this problem to build up
62:19 - our solution for longest valid
62:21 - parentheses as well in fact this
62:24 - solution is going to convert that hard
62:26 - problem into an easy one I'm not even
62:28 - kidding all right let's go ahead and get
62:30 - started with the problem statement
62:32 - so we're given a string that contains
62:34 - opening and the closing round brackets
62:36 - and lowercase English letters
62:38 - the goal of this problem is to remove
62:40 - the minimum number of parentheses to
62:42 - make S valid
62:44 - so in the first case we see that there
62:45 - are two opening brackets and one closing
62:47 - bracket and we see that we have to
62:49 - remove any one of these opening brackets
62:51 - to balance these opening and the closing
62:53 - ones out
62:54 - okay pretty simple and so what I've
62:56 - decided to do is I've decided to remove
62:58 - the first opening bracket and keep the
63:01 - second one you can also do it the other
63:03 - way both of them are perfectly fine
63:05 - in the second case we have the input as
63:08 - 1337 wrapped inside of brackets
63:11 - in this case I have to remove no such
63:13 - parentheses to convert it to a valid
63:16 - string because it's already a valid
63:17 - string all right so let's go ahead and
63:19 - take a look at some observations the
63:21 - logic to build up to the solution
63:23 - now we already talked about this test
63:25 - case where we removed the first bracket
63:28 - but I want you to notice one more thing
63:31 - the question clearly mentioned that we
63:33 - can only remove brackets that is we have
63:35 - to remove the minimum number of brackets
63:37 - to make it a valid shrink in other words
63:39 - we're only going to remove brackets and
63:42 - never the lowercase English letters
63:45 - now this is important because what we
63:47 - can do is simplify our life a bit what
63:49 - we can do is look at these characters
63:50 - instead as indices and we can filter out
63:53 - all of those characters which are
63:56 - lowercase English letters
63:58 - in this way we have simplified the
63:59 - problem quite a lot and now we only have
64:01 - to worry about the brackets opening and
64:03 - closing
64:04 - all right so let's go ahead and talk
64:06 - about uh a couple of rules that we
64:09 - discussed previously first was the thing
64:11 - where uh why do we use a stack and when
64:14 - do we use a stack as soon as we see a
64:16 - leaf quadrant being followed we are
64:17 - going to use a stack and in this
64:19 - question is a parenthesis question so we
64:21 - will use the stack the second thing was
64:23 - how do we use it well we're going to go
64:25 - from the left to the right and parse the
64:27 - input that is for every opening bracket
64:30 - we see we'll go ahead and add it to the
64:32 - stack and for regularly every Closing
64:34 - one we are going to remove an opening
64:36 - from the stack
64:37 - so both of them are going to resolve
64:39 - each other this will make sense in a
64:40 - second don't worry about it and the
64:42 - third one is how do we implement this
64:45 - in this case it is better to use indices
64:48 - instead of elements okay because we did
64:51 - a filtering out operation which means
64:53 - that indices are going to be the way to
64:56 - go
64:57 - all right so let's go ahead and get that
64:59 - input set up and now we have an empty
65:01 - stack with this so what we'll do is
65:04 - we'll go ahead and start to iterate from
65:05 - the left to the right so first we'll go
65:07 - ahead and look at the element 0. all
65:10 - right so element at the index 0 is an
65:12 - opening bracket so we're going to add it
65:14 - directly onto the stack no questions
65:16 - asked
65:17 - then we move on and we iterate further
65:20 - and we find another opening bracket at
65:22 - the index four so we'll again add the
65:24 - index 4 to the stack
65:26 - oh by the way I am adding these indices
65:28 - and you have to focus on getting these
65:30 - indices into the stack the brackets are
65:32 - there just for the sake of demonstration
65:34 - and understanding we're actually going
65:36 - to only have indices in the stack not
65:39 - the brackets
65:40 - anyways then we go ahead and reiterate
65:43 - further and we find that we get a
65:44 - closing round bracket
65:46 - now what does this mean
65:48 - we have found a closing round bracket
65:51 - which means that it is going to satisfy
65:53 - the opening round bracket so this 9 is
65:56 - going to get satisfied with the 4.
65:59 - both of them mix and match together and
66:01 - we'll pop the element 4 out of the stack
66:03 - this is the reason why you see 4 and 9
66:05 - in the answer
66:06 - make sense
66:08 - now we reached the end of the iteration
66:09 - but 0 Still Remains on the top of the
66:11 - stack
66:12 - in other words it never gets satisfied
66:15 - it never finds any closing bracket to
66:18 - resolve it
66:19 - so we'll leave 0 out
66:22 - so the minimum remove to make valid
66:24 - parentheses is going to remove the
66:26 - element 0 from the input
66:29 - okay let's go ahead and take a look at
66:31 - another example and this one will really
66:33 - bring forward the core of the problem
66:37 - so let's go ahead and start iterating
66:38 - from the first element we see 0 which is
66:40 - a closing bracket now this closing
66:43 - bracket is going to close an opening
66:45 - bracket
66:46 - but do we have an opening bracket on top
66:48 - of the stack
66:49 - well no we don't even have any brackets
66:52 - on top of the stack we don't have any
66:54 - brackets at all
66:55 - which means that this closing bracket
66:57 - will never get satisfied it will be
66:59 - alone always and forever so we are going
67:01 - to leave it and we're going to iterate
67:03 - further
67:04 - all right so now we get an opening
67:06 - bracket let's go ahead and add it to the
67:07 - stack pretty simple
67:09 - next iteration we see that we get a 4.
67:12 - now this four did what as soon as this 4
67:16 - got an opening bracket
67:19 - popped it out and satisfied both of them
67:21 - so now both the opening and the closing
67:23 - brackets have satisfied each other which
67:25 - means both of them are essential to be a
67:28 - part of the solution
67:30 - right so let's go ahead and continue
67:31 - iterating now we get 6 and this is an
67:34 - opening bracket so let's just go ahead
67:36 - and add it to the stack
67:38 - then we get a 7 also added to the stack
67:40 - and then we get a 9. what do we do when
67:43 - we get a 9
67:44 - that's right we'll pop out the 7 and now
67:47 - both 7 and 9 will satisfy each other
67:51 - at this point we have 1 4 7 and 9 which
67:55 - are the
67:56 - parentheses which satisfy each other in
67:59 - other words they form an essential part
68:01 - of the answer however 0 and 6 have to be
68:04 - removed right we have to remove a
68:06 - minimum number of brackets and this way
68:08 - we have found two brackets to remove
68:09 - from the answer
68:12 - okay pretty simple uh but what would
68:15 - happen say if I get a 10
68:17 - which is a closing bracket just for uh
68:20 - thought process sake
68:22 - as soon as I get this 10 what would
68:24 - happen this 10 is going to satisfy the
68:27 - element on the top of the stack which is
68:28 - the element six so 10 and 6 are going to
68:32 - satisfy each other and so
68:33 - there is where we end the iteration all
68:37 - right let's go ahead and take a look at
68:38 - the optimize solution and uh okay cool
68:41 - let's go ahead and get started now if
68:43 - you notice what we have done up till now
68:45 - is uh have a differentiation between
68:49 - these blue and the green ones right the
68:52 - blue ones were ones that never got
68:54 - satisfied and the green ones were the
68:55 - ones which got satisfied
68:57 - so the first thing I'm going to do is
68:59 - create an array called is okay which is
69:01 - going to be initialized with 0 for all
69:03 - the values of the string in other words
69:05 - I'm going to say none of the elements in
69:08 - the original shrink ever get satisfied
69:10 - that is my initial assumption and I'm
69:12 - going to build upon that later on now
69:15 - I'll also have an initial stack and
69:17 - we'll go ahead and start iterating over
69:18 - all the elements inside of the string so
69:21 - we'll first get its index another
69:22 - character for every single element of
69:25 - the string
69:26 - now if the characters in opening bracket
69:27 - what do we do
69:29 - if the character is an opening bracket
69:30 - we add it to the stack without asking
69:33 - any questions now what happens when we
69:36 - have a closing bracket
69:37 - when we have a closing bracket we'll
69:39 - first ask the question here does the
69:41 - stack exist is there any opening bracket
69:44 - on the top of the stack because if there
69:47 - is what do we do if there is we will pop
69:50 - that element from the top of the stack
69:52 - and assign its index the value 1. saying
69:56 - that this opening bracket which we just
69:58 - popped out is actually a one it is okay
70:01 - it is a green value as we saw in the
70:03 - case for one and seven both of them were
70:06 - opening brackets and they got Satisfied
70:08 - by four and nine respectively
70:10 - so one and seven both get this one
70:13 - and we also assign is okay if I to one
70:15 - as well saying that because 4 was the
70:18 - one that popped out one from the top of
70:20 - the stack one gets satisfied but also
70:23 - four gets satisfied
70:24 - so we're going to satisfy both of them
70:26 - and what is the else condition what if
70:29 - the stack is non-existent what if we get
70:31 - a closing bracket and then we realize
70:34 - that hey wait a second the stack is
70:36 - empty so we can't really close any
70:39 - opening bracket
70:41 - in other words we'll just have to
70:43 - continue unfortunately skipping over
70:44 - this current I
70:46 - alright so was the final lens condition
70:48 - if you get a opening bracket we append
70:51 - it to the stack if you get a closing one
70:53 - we check the stack for emptiness or not
70:55 - and figure out what to resolve but
70:58 - there's a final condition which says if
71:00 - you have English letters well go ahead
71:03 - and also continue because we don't want
71:05 - to mess with any lowercase English
71:07 - letters what we are only going to
71:09 - message
71:10 - we are only going to mess with the
71:13 - indices of the parentheses
71:16 - all right so at the end of this
71:18 - iteration is okay is the array which
71:20 - contains all the information it is the
71:23 - one which contains the information of
71:24 - which all are blue which already do and
71:27 - which one or green the green represents
71:29 - one and blue represents zero right so
71:32 - let's go ahead and
71:34 - iterate further now the goal of this
71:36 - problem is to return the string
71:39 - we have to return the string by removing
71:41 - the minimum number of parentheses
71:43 - Now using this is okay array we have
71:46 - already found out all the parentheses
71:47 - which are essential and which are
71:49 - non-essential
71:50 - so what we are going to do is we are
71:52 - going to go ahead and build the answer
71:53 - character by character once again
71:55 - remember all of this what this tag did
71:58 - was to store the indices of the elements
72:00 - and this is why the is okay thing worked
72:02 - out now we are going to iterate over the
72:04 - string once again and we are going to
72:06 - ask the question hey is the character a
72:09 - bracket or not because if it is a
72:11 - bracket and only if it is okay
72:15 - only if it has been satisfied then we
72:18 - added to the answer
72:19 - because if it's a bracket and it has not
72:21 - been satisfied we'll have to continue
72:23 - we'll have to pass over this test case
72:26 - now was the else condition over here if
72:28 - the character is a bracket then you will
72:29 - have to check if it's okay or not but if
72:32 - a character is not a bracket that is
72:34 - it's a lowercase English letter then by
72:37 - default you have to add it to the answer
72:40 - all right anyways at the final point of
72:43 - time you go ahead and just return the
72:44 - answer so let's go ahead and run the
72:46 - code for sample test cases
72:48 - and some of this
72:51 - all right cool so this is it for the
72:53 - solution to the problem minimum remove
72:55 - to make valid parentheses hello everyone
72:58 - and welcome back let's talk about the
73:00 - problem longest valid parentheses now if
73:03 - you haven't seen the video on minimum
73:05 - remove to make valid parentheses this
73:08 - question will seem out of the blue
73:09 - however if you have seen that this
73:11 - question is just a breeze question
73:13 - because we're going to use the exact
73:15 - same logic as we saw in the previous one
73:17 - all right let's go ahead and talk about
73:19 - the problem statement of formally and
73:21 - we're given a string of just opening and
73:23 - the closing brackets that is we only
73:25 - have opening and the closing around
73:27 - brackets
73:28 - the goal of this problem is to find the
73:30 - longest substring of valid parentheses
73:33 - in other words let's take an example in
73:35 - the first test case we have the opening
73:37 - and the closing brackets which form a
73:38 - length of two but then we have three
73:40 - opening brackets which never get closed
73:43 - in other words the longest substring of
73:46 - valid parentheses is just 2.
73:49 - now the second test case is one where we
73:51 - have opening and closing bracket and
73:52 - then we have a bunch of opening brackets
73:54 - the bin one opening bracket at the end
73:57 - gets closed now what is the longest
74:00 - substring of valid parentheses we have
74:02 - in this case two sets of the length two
74:05 - substring of valid parentheses since
74:07 - both of them are of land 2 will just
74:09 - return to as the answer
74:11 - now what can we say right away about
74:13 - this kind of question
74:15 - this kind of question is actually
74:17 - twofold we have to find two things first
74:19 - first we have to figure out what all
74:22 - parentheses are valid or not
74:24 - because once we have the valid
74:26 - parentheses in hand once we know which
74:28 - of them are valid which of them are
74:29 - invalid we simply have to find the
74:32 - longest substring of them
74:33 - right so this is going to be uh broken
74:36 - down into two parts and if you realize
74:38 - the answer to the first one is something
74:40 - we've already seen
74:42 - all right since there is not a lot to go
74:43 - on let's go ahead and just build up our
74:45 - logic from the previous question
74:48 - as with the previous one we'll set up an
74:50 - is okay variable that is going to be all
74:52 - zeros of the length n in other words
74:54 - it's going to say that you know what
74:56 - I'll assume none of the brackets opening
74:59 - or closing ever get satisfied all of
75:01 - them are zeros
75:03 - we'll also have an initial
75:04 - initialization of this track and then
75:06 - we'll start to iterate our all the
75:08 - characters in the string
75:09 - as before we'll check if the character
75:12 - is a opening bracket or not because if
75:14 - it is an opening bracket will just
75:16 - directly add it to the stack
75:18 - what if it's a closing bracket though
75:21 - in the else Condition it's a closing
75:22 - bracket we'll have to check if the stack
75:25 - exists or not
75:26 - that is for this current closing bracket
75:29 - because I've gone in dl's case for this
75:31 - closing bracket does the stack exist
75:34 - in other words is there a opening
75:36 - bracket is there any opening bracket
75:38 - that you can find which had been put on
75:40 - the stack
75:41 - now if you can find that is the case
75:43 - well then go ahead and make both of them
75:46 - satisfied that is go ahead and pop the
75:49 - element from the top of the stack which
75:50 - is going to be an opening bracket and
75:52 - set its value to 1 that is that opening
75:55 - bracket has been satisfied by this
75:57 - current closing bracket and obviously
75:59 - that also means this current losing
76:01 - bracket has been satisfied so we'll set
76:03 - is okay file to B1
76:06 - and the off chance that the stack is
76:08 - empty and you get a closing bracket well
76:10 - that's just sad we can't really do
76:11 - anything about that I'm sorry
76:13 - anyways once we're done figuring out
76:15 - which of them which of the brackets
76:17 - opening or closing are valid or not we
76:20 - simply have to figure out the longest
76:22 - substring of these valid cases so what
76:25 - we'll do is we'll set up a count which
76:26 - is going to be a running count of all
76:27 - the values and we have a answer which is
76:31 - going to store the maximum of all of
76:32 - these counts so what we're going to do
76:34 - is we're going to iterate in the range
76:36 - of n that is we'll iterate over every
76:38 - single index and we'll ask the question
76:40 - hey is the bracket I'm looking at is the
76:43 - current bracket okay or not because if
76:46 - it is okay well that's great news
76:47 - whatever the count was increase its
76:50 - value by one why because I found the
76:53 - case of a valid parenthesis
76:56 - right so as soon as I know this current
76:59 - bracket is a part of a valid substring
77:01 - go ahead and add one to the count else
77:04 - else what do we do
77:06 - if at this point of time there is a
77:09 - bracket which is a stray bracket which
77:10 - never gets opened or never gets closed
77:12 - well then we unfortunately have to reset
77:15 - the counter from zero
77:18 - okay so the next step is then going to
77:20 - be simply taking a Max of the answer in
77:22 - the count because answer wants to store
77:24 - the maximum possible value of all the
77:26 - counts ever
77:28 - all right so this is it for the code
77:30 - let's go ahead and run it and we'll go
77:32 - ahead and submit this as well
77:33 - and cool this gets accepted
77:36 - so yeah this is it for the solution to
77:37 - the problem long history valid
77:39 - parentheses
77:40 - hello everyone and welcome back this is
77:44 - the start of a new section on calculator
77:46 - related questions it builds on top of
77:49 - our previous work on parentheses related
77:51 - questions we'll be discussed the exact
77:53 - reasons why we use a stack how we use it
77:56 - especially the left to right parsing
77:58 - method and the implementation level
77:59 - details that we need to take care of
78:02 - now what I'm going to do in this video
78:04 - is establish the we just need two steps
78:06 - that's right just two steps we need to
78:09 - know to solve any calculator related
78:11 - question
78:12 - in fact both of these steps individually
78:14 - are interview problems on their own
78:16 - which means that once we solve both of
78:18 - them both of these questions we'll be
78:21 - able to solve any calculator related
78:23 - question that is like killing three
78:25 - birds with two stones
78:27 - all right so the first step is to parse
78:30 - the input from the infix to the postfix
78:32 - notation and the second one is to
78:34 - evaluate the post fix notation
78:36 - now the first question that you should
78:37 - ask is wait what is the post fix
78:40 - notation
78:41 - so let's go ahead and talk about the
78:43 - introduction to the postfix notation
78:45 - first
78:46 - all right let's go ahead and take a
78:47 - simple example and let's see that we
78:49 - have this kind of string that we need to
78:51 - evaluate
78:52 - now the infix notation is formally
78:54 - defined as such
78:55 - in the infix notation the operator is
78:59 - fixed in between the operands
79:02 - again the operator is the focus over
79:05 - here and the operator is going to be
79:07 - fixed in between in the operands now
79:11 - what is the post fixed notation
79:13 - formally speaking postfix notation is
79:15 - where the operator is present after the
79:17 - operands now that might sound a bit
79:20 - unnatural given that what we have been
79:21 - looking at all throughout our life is
79:23 - the infix notation this is the simple in
79:26 - fixed notation over here and if I ask
79:28 - you the question hey how would you go
79:30 - about evaluating this kind of thing what
79:32 - would you do
79:33 - the first thing we'll look at is
79:35 - brackets so we'll evaluate everything
79:37 - inside of the brackets so 3 times 3
79:39 - becomes 9. and so this is the expression
79:42 - that we have now
79:43 - what do we do next we realize that we
79:46 - have to do a division operation first
79:48 - which means that we'll do 9x7 C style
79:51 - division
79:52 - so 9x7 will get rounded off to 1. and
79:55 - now we have 0 minus 1 plus 1. and since
79:58 - plus and minus are of the same priority
80:00 - we'll simply cancel both of them out and
80:02 - say the final answer is nothing but zero
80:06 - now what have we done over here what we
80:08 - have done is simply apply a rule called
80:10 - bod Mass which stands for bracket order
80:13 - division multiplication addition and
80:16 - subtraction
80:17 - this is a rule that is commonly taught
80:19 - in high school math and is the way we
80:21 - evaluate any sort of input given to us
80:24 - however there is a small catch
80:26 - see if you have brackets inside of
80:28 - brackets those brackets inside of
80:30 - brackets need to be resolved first
80:32 - before you evaluate the brackets
80:35 - and if you have brackets inside of
80:36 - brackets inside of brackets then you
80:38 - resolve then you need to resolve the
80:40 - innermost bracket first then zoom out
80:42 - and then zoom out once again
80:44 - you can see that this sort of nesting is
80:47 - what can give rise to such complicated
80:50 - expressions and while the first one on
80:52 - the top is pretty easy to solve using
80:55 - the same in fixed notation the second
80:57 - one becomes much more harder
81:00 - and so the question arose
81:02 - whether we can write the expression
81:04 - unambiguously and we can solve it
81:06 - efficiently
81:07 - that is without having to worry about
81:09 - this Bond Mass rule is there a way we
81:12 - can write this expression and secondly
81:14 - is there an efficient way to solve that
81:16 - expression once you have written it that
81:18 - way
81:19 - this is the idea behind post fixed
81:22 - notation
81:23 - the both fixed notation simply says that
81:25 - the operator is present after the
81:27 - operands in other words if we take an
81:29 - example like this we have 1 2 plus it is
81:33 - equivalent to saying 1 plus 2.
81:35 - again I know this sounds unnatural but
81:38 - bear with me for a second because
81:39 - something interesting is going to happen
81:41 - let's see if we have 1 2 plus 3 star
81:44 - what will that evaluate to
81:46 - 1 2 plus will become 3 and then we have
81:49 - 3 3 star
81:51 - in other words we'll have 3 times 3.
81:55 - what we have done is one plus two inside
81:57 - of brackets that needs to be resolved
81:59 - first and then we'll do times three
82:02 - do you notice something
82:04 - if we go back the other way around we
82:07 - have figured out a way to write these
82:09 - bracketed Expressions into non-bracketed
82:12 - ones that is one plus two which had to
82:14 - be resolved first which were present
82:16 - inside of the brackets we found a way to
82:18 - write that without using the brackets
82:20 - how nice is that we were able to figure
82:23 - out a way to unambiguously write this
82:26 - expression
82:27 - all right so this is the general idea
82:29 - behind using a post-fixed notation and
82:31 - so we can finally formally talk about
82:33 - these two steps again the first step was
82:35 - to convert and parse the input from the
82:38 - infects to the postfix notation and that
82:40 - is something we're going to look at in
82:41 - the next video and then in the next to
82:43 - next one we'll look at how do you
82:45 - evaluate the postrix notation all right
82:48 - so let's get started hello everyone and
82:50 - welcome back let's talk about how do we
82:53 - convert the infects to the post fix
82:55 - notation
82:56 - as we discussed the infix notation is
82:59 - one in where we put the operator in
83:02 - between the operands that is we fix the
83:05 - operator such as a minus between the
83:07 - operands such as 0 and 1. so we have
83:09 - something like 0 minus 1. in the post
83:12 - fixed notation we have the operator
83:14 - after the operands where we have
83:16 - something like 0 1 minus
83:18 - let's go ahead and take a look at some
83:20 - examples to understand this vector in
83:22 - the case we have 1 plus 2 in the infix
83:24 - notation it gets converted to 1 2 plus
83:27 - if we have say 5 minus 6 it gets
83:30 - converted to 5 6 minus
83:32 - and then if we have something like 1
83:34 - plus 2 times 3 we have 1 2 plus 3 times
83:39 - wait a second uh one two sorry one plus
83:43 - two times three will evaluate to 1 plus
83:46 - 6 which is nothing but 7. but if we
83:49 - actually evaluate this
83:50 - will come out to be wrong
83:52 - that's because 1 2 plus will get
83:56 - evaluated to 3 first
83:58 - and then we'll have to do three times
83:59 - three
84:00 - giving us the answer nine
84:02 - this is in fact wrong we are doing one
84:06 - two plus three times which is wrong
84:09 - so what do we have to do instead
84:11 - we have to switch out the ordering of
84:14 - this Plus
84:15 - because now what we have done is we have
84:17 - done one two three Star Plus basically
84:19 - saying go ahead and multiply 2 and 3
84:21 - first so 2 times 3 becomes 6 and so
84:25 - we'll write 1 6 Plus Now 1 6 Plus is
84:28 - what it's nothing but 1 plus 6 which is
84:30 - seven and so now we have the correct
84:32 - answer
84:33 - but if you notice what happened over
84:35 - here we realized something The Ordering
84:38 - of these plus and the star operators
84:39 - changed
84:41 - right we had one plus two times three
84:45 - and it becomes 1 2 sorry it became one
84:48 - two three Star Plus
84:51 - so the ordering of the plus and the star
84:53 - operators change although the ordering
84:56 - of the operands like one two three did
84:58 - not change
84:59 - there's something interesting which
85:01 - we'll come to very soon again
85:03 - all right so now we want to formally
85:04 - talk about how do we convert the infix
85:07 - notation to the postfix notation right
85:09 - so let's go ahead and try to work out
85:11 - the answer one by one
85:13 - so using the board Master will let me
85:15 - know we can say that you know what let's
85:16 - go ahead and do the division operation
85:18 - first all right so we have to do B by C
85:21 - first and how are we going to write d by
85:23 - C
85:23 - we're going to write it as B C slash all
85:27 - right pretty simple up till now then
85:29 - what do we do next
85:30 - we also realize that there's a b by c
85:32 - times D we have to do times D in The
85:35 - Next Step because that is the second
85:37 - operation we have to follow using the
85:38 - board Mass rule so what will how do we
85:41 - write times d
85:42 - well BC by forms one single operand now
85:45 - and so we have to multiply BC by with d
85:49 - BC by is one operating and D is another
85:52 - and so we can write BC by D star
85:56 - all right how do we handle the plus case
85:59 - and the minus case then well it's going
86:01 - to handle the plus one first so we have
86:02 - a plus this entire expression now can we
86:05 - handle that
86:06 - we can write a in the front and plus the
86:09 - end and then we have minus E towards the
86:12 - end so we can write it as e minus
86:15 - right so we followed the bod Mass
86:17 - property and we have written down the
86:19 - infix to the postfix notation
86:21 - in fact if you break it down we have
86:23 - something of this sort first we looked
86:25 - at BC slash then D star then a plus and
86:28 - then e minus
86:30 - following the board Mass rule exactly
86:33 - in fact what we have done here in other
86:35 - words is that we have somehow implicitly
86:37 - encoded the information of the bond Mass
86:40 - rule into the post fixed notation
86:43 - now to evaluate the post fixed notation
86:44 - we won't need this bodmas rule at all
86:46 - because we have already encoded that
86:49 - information in the structuring of the
86:51 - post fixed notation
86:53 - right let me go ahead and explain that
86:55 - further
86:56 - what we have done is that we looked at
86:58 - the bod muscle and we figured out that
87:00 - we have to First Look at brackets then
87:02 - order then Division and multiplication
87:04 - are the same level then addition and
87:06 - subtraction are the next lower level
87:08 - right so this is something we've
87:10 - implicitly encoded into the answer look
87:13 - at the ordering of The Operators we have
87:15 - slash first then star then plus and then
87:18 - minus
87:19 - I also want you to notice another thing
87:21 - which I brought up earlier as well
87:24 - The Ordering of the operands which are a
87:27 - b c d and e remain the same from the
87:31 - infix to the post fixed notation
87:33 - only and Only The Ordering of The
87:36 - Operators change it went from plus slash
87:39 - star minus that is it went from a
87:41 - completely random ordering to a
87:43 - well-defined ordering where we had
87:45 - division multiplication addition and
87:47 - subtraction
87:49 - so now the question is how do we
87:51 - implement this how do we make this
87:53 - happen using formal logic
87:55 - what we're going to do is we're going to
87:57 - go ahead and use a stack to do this let
87:59 - me actually run a simulation and show
88:01 - you how this works
88:02 - the first thing we'll do is we'll start
88:04 - to iterate from the left to the right
88:06 - and so let's say that we get the first
88:08 - element as a since this is the operand
88:10 - and we don't mess with the order of the
88:13 - operands we are just going to write it
88:14 - as a part of the answer directly no
88:16 - thinking twice you see an operand you
88:18 - write it in the answer that's it as
88:20 - simple as that
88:22 - what's the next step
88:23 - the next step is to iterate further and
88:25 - we see that we get a plus sign
88:27 - since the ordering of these operators do
88:30 - change later on we'll keep them in a
88:32 - stack for now and we'll see what to do
88:33 - later on right so now we add this plus
88:36 - to the stack
88:37 - then we get the element B and what do we
88:39 - do since b as an operand We'll add it
88:42 - and obtain it at the end of the post
88:44 - fixed answer
88:46 - all right cool so now we get a slash
88:49 - now I'm going to ask you a very
88:51 - important question is it okay to put
88:53 - this slash after this Plus
88:56 - or should we instead remove this plus
88:59 - first and add the slash later on
89:02 - what should we do
89:04 - let's think about something that is
89:05 - going to happen
89:07 - if you remember stack follows something
89:09 - called the default ring the last one to
89:11 - come in is the first one to get out
89:14 - and notice how the answer on the top
89:15 - right hand side says
89:17 - the answer on the top right hand says
89:19 - that we have to have division then
89:20 - multiplication then addition and
89:22 - subtraction that is we have to follow
89:25 - this highest to lowest ordering in the
89:27 - post fixed notation that is something
89:29 - that we have to encode it by default
89:32 - now if it means that we have to have the
89:34 - highest operation highest priority
89:36 - operators first and the lowest ones
89:38 - later on using this lifo notation what
89:41 - should be the ordering we follow in the
89:43 - stack
89:44 - again the last ones to get in will be
89:47 - the first ones to get out so if you want
89:49 - the highest ones to come first in the
89:51 - answer we'll have to ensure that the
89:53 - highest ones are the first one to leave
89:56 - out of the stack
89:57 - in other words we have to say that the
90:00 - stack follows the lowest to highest
90:02 - ordering
90:03 - so in fact what we have right now plus
90:05 - followed by a slash is okay
90:08 - because in the edge case because in the
90:10 - edge case that we ever decide to remove
90:12 - both of these elements first will pop
90:14 - out slash and then Plus
90:17 - which now exactly follows the ordering
90:19 - we want
90:20 - right so I think that should make a lot
90:21 - more sense now so let's go ahead and
90:23 - continue iterating we get the element C
90:25 - and since this is an operand We'll add
90:27 - it directly add it to the stack
90:30 - now what do we do when we get a slasher
90:32 - uh sorry when we get a star operation
90:35 - remember the board Mass rule
90:37 - it says the first you resolve brackets
90:39 - then order then Division and
90:40 - multiplication at the same level
90:43 - what does it mean for us to get a
90:45 - division and a multiplication right now
90:48 - this is nothing but going to hint us at
90:51 - the fact that this multiplication
90:53 - operator is actually going to take this
90:55 - division operator and kick it out
90:58 - because both of them are of the same
91:00 - priority and remember what is the
91:02 - ordering of the stack The Ordering of
91:04 - the stack goes from the lowest to the
91:06 - highest
91:07 - all right we can't allow elements of the
91:09 - same priority to stick in together so
91:11 - we'll have to kick out the Slash and
91:14 - only then we can add in the star again
91:17 - if you look at it it is still going to
91:19 - maintain lowest to the highest ordering
91:21 - now right it only happens after we kick
91:24 - out the Slash and if you look on the top
91:27 - side top right hand side we can see that
91:29 - you know what this is indeed the correct
91:30 - way to go so we're thinking about this
91:32 - correctly
91:33 - anyways let's keep on iterating further
91:35 - and see what happens we get a d and
91:37 - since this is a what since this is an
91:39 - operand we'll add it directly to the
91:42 - answer
91:43 - then we get a minus and now what happens
91:46 - the priority of minus is much lower than
91:49 - that of multiplication
91:50 - which means that this minus is going to
91:53 - kick out the multiplication you can
91:55 - think about it this way you can think
91:57 - that an undeserving candidate comes a
91:59 - lower priority element comes and it
92:01 - kicks out all the higher priority or the
92:04 - equal priority elements out of the stack
92:06 - it says that you know what you guys are
92:08 - much higher priority than me minus comes
92:10 - in and says you know what addition and
92:12 - multiplication are both either higher or
92:14 - equal to me so I'll kick you both out
92:16 - let me just go and stay in the stack so
92:19 - we'll go ahead and first kick out the
92:20 - multiplication operator and then we'll
92:22 - again compare it with the addition one
92:23 - so now we'll say okay you know what
92:25 - since plus and minus are both of the
92:27 - same priority let's go ahead and kick
92:29 - out plus as well then we'll add minus
92:31 - into the stack
92:33 - okay so now we can go ahead and continue
92:35 - iterating and we get the value e we'll
92:37 - just add it to the answer and then wait
92:40 - a second we have reached the end of the
92:42 - iteration right
92:44 - after e we have reached the end of the
92:46 - iteration so what do we want to do if we
92:48 - want to empty out the contents of the
92:51 - stack and since there is only one single
92:54 - element let's just go ahead and add this
92:56 - at the end
92:57 - so now you can go ahead and compare both
92:58 - of them and realize that you know what
93:00 - we were actually a right all of this
93:02 - logic worked out for us
93:04 - so now we want to go ahead and formalize
93:07 - the logic and write it in terms of code
93:09 - and we're going to follow the exact same
93:11 - things that I taught you before
93:12 - first things first let's create a post
93:14 - fix array which will return at the end
93:16 - and now we'll also create a stack for
93:18 - The Operators the stack is only ever
93:20 - going to store The Operators
93:23 - and not the operands
93:25 - now we want to start iterating over
93:27 - every single element in the infix and
93:30 - we're going to call this element token
93:32 - because it can either be operator or an
93:34 - operand we don't know yet
93:36 - now we'll ask the question hey if the
93:38 - token is not an operator that is if it's
93:42 - a letter or if it's a number or digit
93:43 - something like that if the token is not
93:46 - in the operators then what do we do
93:49 - hit me is that the token is actually an
93:51 - operand and in that case we realize that
93:54 - we just have to directly append it to
93:56 - the postfix notation we don't ask any
93:58 - more questions and that is it for an
94:01 - operand
94:02 - now what happens if we have an operator
94:04 - though
94:05 - then obviously we want to append this
94:07 - item to the stack
94:08 - we want to push the token onto the stack
94:11 - remember stack follows the lowest to
94:13 - highest ordering which means that we
94:16 - have to write one or two lines of code
94:19 - more
94:20 - and this is very important and this is
94:22 - something we'll come to by the way in
94:23 - the next section as well
94:24 - okay so let me explain what's going on
94:26 - here
94:27 - I'm going to say while the stack exists
94:29 - that is while there are elements in the
94:31 - stack and the priority of the element on
94:33 - the top of the stack is greater than the
94:35 - priority of the current token that is
94:37 - we're looking at something like a minus
94:39 - as the current token and the top of the
94:41 - stack is a star
94:43 - which we had a case like that before if
94:46 - we have a case like that then this
94:47 - current token of lower priority is kick
94:50 - out is going to kick out the element
94:53 - from the top of the stack
94:55 - and it's going to kick that element from
94:56 - the top of the stack we'll do stack.pop
94:58 - and whatever the element was kicked out
95:00 - is going to be appended to the post fix
95:02 - one directly
95:04 - so we are going to say while that is
95:06 - true while the current priority of the
95:08 - token is lesser than equals to the
95:10 - priority of the element on the top of
95:12 - the stack then keep on doing this for
95:14 - prep operation because we are strict we
95:17 - want to have a lowest to highest
95:19 - ordering we can't even allow elements of
95:21 - the same priority to be there because
95:23 - even if the priority same we're still
95:25 - going to make a cake operation we're
95:26 - going to kick that element out from the
95:28 - top of the stack and append it to the
95:30 - post fix notation all right
95:32 - good so this should make sense now
95:34 - because we have to follow the lowest to
95:36 - the highest ordering
95:37 - okay what's the last step then are we
95:39 - done
95:41 - if you remember we had the case where
95:43 - there was one single element minus in
95:45 - the stack remaining at the end so we'll
95:47 - actually have to handle cases like that
95:48 - as well and we have to say you know what
95:50 - while the stack exists while there are a
95:52 - bunch of operators in the stack go ahead
95:54 - and pop that element of the stack and
95:56 - append it to the post six now obviously
95:58 - in this kind of case we will only ever
96:00 - have one single element like that
96:03 - okay anyways uh all of this was to
96:07 - convert this kind of input as we saw on
96:09 - the top from the infix notation to the
96:11 - postfix notation
96:13 - but now I ask you the question is it
96:16 - possible
96:17 - to somehow include in Brackets as well
96:19 - because look at the inputs we have never
96:22 - talked about brackets up till now we've
96:24 - only talked about operands and operators
96:27 - what if there are brackets
96:29 - all right let's go ahead and write some
96:31 - more code and since brackets are of
96:33 - higher priority since you know in bodmas
96:36 - you will be always take care of brackets
96:37 - first let's go ahead and handle the
96:39 - cases of brackets in the first two
96:41 - conditions so the first will first thing
96:43 - we'll see is that if the token is an
96:45 - opening bracket what do we do
96:48 - we will append this token on top of the
96:51 - stack we'll say you know what this is
96:53 - going to start of a new expression that
96:55 - we need to take care of earlier on so
96:57 - let's go ahead and append this token on
96:58 - the top of the stack
97:00 - okay now what
97:01 - well we want to say you know what if the
97:03 - token is a closing bracket then we need
97:05 - to do something more
97:08 - as soon as we get a closing round
97:09 - bracket what do we want to do
97:11 - we want to take care of all the elements
97:13 - present between this opening round
97:16 - bracket and the closing round bracket
97:18 - so what we are going to do is we're
97:20 - going to say you know what while the
97:22 - stack of top while the stack top is not
97:26 - an opening bracket go ahead and kick out
97:28 - all the elements one by one
97:30 - so what we are going to say is
97:31 - everything in between of these two
97:33 - brackets between this opening round
97:35 - bracket and the closing round brackets
97:37 - go ahead and pop those elements from the
97:39 - top of the stack and keep on appending
97:42 - them to the post fix notation
97:44 - one last thing that we have to do what
97:46 - is the one last thing the stack top is
97:48 - currently now having the opening round
97:51 - bracket
97:52 - as the Stacked out why is that because
97:54 - that is when the while loop exists
97:57 - because the stack top is going to have
97:58 - the opening round bracket which means
98:00 - that we have to take care of that once
98:02 - again
98:03 - we have to do a stack.pop operation
98:04 - saying that you know what we don't
98:06 - really care about brackets in the post
98:07 - fix notation
98:08 - because that was the whole point of post
98:10 - fixed notation to get rid of the
98:12 - brackets in the weird board Mass
98:13 - ordering
98:15 - now let me ask you this one question and
98:17 - this is a kind of a special trick case
98:19 - that we need to take care of remember
98:21 - the board Mass rule right and what I
98:24 - promised at the start was that we will
98:26 - be able to somehow implicitly encode the
98:29 - information of the infix notation in the
98:31 - postfix notation right and we were able
98:33 - to do that by handling the cases of
98:35 - brackets separately and division
98:37 - multiplication addition subtraction
98:39 - all right
98:40 - but now if I ask you let's go ahead and
98:42 - also formally Define the priority what
98:44 - is that going to look like
98:46 - because we use this priority over here
98:48 - in the while loop right
98:51 - now how do we Define the priority well
98:53 - the priority will be a little bit
98:55 - different
98:56 - so obviously the order has the highest
98:58 - priority then division multiplication
99:00 - and then addition subtraction but the
99:02 - bracket the opening bracket will have
99:05 - the lowest priority
99:07 - why is that you ask
99:10 - it has a very interesting reason behind
99:12 - it all right let's say that we have a
99:14 - bunch of elements in the stack let's say
99:16 - there's a opening bracket and now let's
99:18 - say that the operator is simply a star
99:21 - so we have an opening bracket and a star
99:23 - after it
99:24 - now let's say that the minus comes right
99:27 - so what is minus going to do minus is a
99:29 - lower priority element so it is going to
99:31 - kick out the star out of the stack
99:33 - but at the same time we want to ensure
99:35 - that this minus does not kick out the
99:39 - opening round bracket
99:41 - because it's not minus his job to handle
99:44 - that it's the job of the closing bracket
99:46 - to handle that in its own while
99:48 - condition
99:49 - so we are going to have opening bracket
99:52 - having the lowest priority so that the
99:55 - minus or any other sign in fact is never
99:58 - able to kick it out of the stack all
100:00 - right so in this video we learned how to
100:02 - convert the infix notation to the
100:04 - postfix notation now I promise you in
100:06 - the next one we're going to look at how
100:07 - do we evaluate the post fix notation and
100:10 - that is going to be a so so much simpler
100:12 - than this code hello everyone and
100:15 - welcome back let's talk about how to
100:17 - evaluate the post fix notation in the
100:20 - previous video we looked at how do we
100:21 - convert the infix notation to the post
100:23 - fixed notation and I promised early on
100:25 - that the post switch notation is going
100:27 - to be a very easily computable way to
100:30 - get the answer for any calculator
100:32 - related question
100:33 - what we're going to do is very simple
100:35 - I'm going to create a stack and now
100:37 - we'll see that we're going to start
100:39 - iterating from the left to the right
100:41 - now for elements like 0 which we'll get
100:44 - as operands we are going to push them
100:46 - onto the stack without asking any
100:48 - questions as soon as we get another
100:50 - operand let's say in the case of one we
100:52 - are also going to the push it to the top
100:55 - of the stack
100:56 - but things get a bit more interesting
100:58 - when we get an operator because now what
101:01 - does this operator mean what is this
101:03 - entire 0 1 minus thing mean
101:05 - this means that we have to do 0 minus 1.
101:08 - in other words we have to pop one out of
101:11 - the stack we have to also pop out Zero
101:13 - from the stack take their negation that
101:16 - is do 0 minus 1 because we have gotten a
101:18 - current value as the negative minus sign
101:20 - so we have to do 0 minus 1 and then put
101:23 - it back into the stack
101:25 - right so what did we do you get an
101:28 - operand you add it to the stack no
101:31 - asking questions Twice But as soon as
101:33 - you get an operator go ahead and remove
101:36 - two values from the top of the stack do
101:39 - the evaluation and then add them back in
101:41 - okay let me continue and show you what
101:44 - this means
101:45 - so we get three this is an operand we'll
101:48 - add it to the stack we get another three
101:50 - operand add to the stack
101:52 - what do we do when we get a star as soon
101:55 - as we get a star we'll pop one value out
101:57 - we'll pop another value out multiply
102:00 - both of them since this is a star
102:01 - operation find the value and push this
102:04 - answer back onto the stack
102:06 - okay again what do we do when we get a 7
102:09 - add this one to the stack now what do we
102:12 - do when we get a slash
102:14 - what will the be the next step
102:17 - since we have a slash we're going to pop
102:18 - out the last two elements seven and nine
102:21 - we're going to take the division nine by
102:24 - seven and this is the C style division
102:25 - so we'll get the answer as one
102:27 - so we'll get the answer as 1 and we'll
102:29 - push this back onto the stack
102:32 - and then finally we have the plus
102:34 - operation where we'll pull out one we're
102:37 - also pop out minus one add them together
102:40 - get the answer 0 and then push it back
102:43 - onto the stack
102:45 - at the end of this iteration one thing
102:47 - is guaranteed there will be only one
102:50 - single element inside of the stack and
102:53 - that will be the answer
102:54 - okay so what are the rules formally
102:57 - speaking we do two things first if you
103:00 - have an operand you add it to the stack
103:02 - else you pop the last two elements
103:05 - evaluate them and then add them add
103:08 - their result onto the stack again all
103:11 - right so let's go ahead and look at the
103:12 - code implementation of the same problem
103:14 - this is the problem evaluate reverse
103:17 - polish notation which is the same as the
103:19 - post fix notation on lead code all right
103:22 - what are we going to do first things
103:24 - first initialize a stack right the stack
103:26 - is going to be an empty list
103:28 - I'm also going to Define these Ops which
103:30 - is basically going to Define for this
103:33 - character for this current operator
103:35 - represented as a string as a character I
103:38 - want to do this operation I'm going to
103:40 - do operator dot add for minus I'm going
103:43 - to do the subtraction for the
103:45 - multiplication I'm going to do 1 and
103:47 - then for the division I am not
103:50 - going to do floor Dem
103:52 - right these are the two options because
103:54 - we have one as true div which is just a
103:56 - slash and the floative which is actually
103:59 - double slash so it might look tempting
104:01 - for you to do double slash in when it
104:03 - comes to python code although in other
104:05 - languages you can just do slash and get
104:07 - away with it in Python do not do double
104:10 - slash because that is floor div that
104:12 - does not work as intended as you want
104:15 - and it's going to give you issues when
104:17 - it comes to negative values uh I won't
104:19 - go into much more detail in that you can
104:21 - go check out some of the links down
104:23 - below anyways what we're going to do
104:25 - next is we're going to iterate over
104:26 - these token given in the input tokens
104:29 - so what was the goal we have to first
104:31 - figure out if it's operand or not
104:34 - now we'll say if the token is not in the
104:36 - operators that is if the token is not of
104:39 - plus minus multiplication or division
104:41 - symbols that means it's a integer value
104:44 - given to us so what we're going to do is
104:46 - we're going to convert that token to an
104:48 - end value and append it to the stack all
104:51 - right
104:52 - cool so now what we're going to do in
104:54 - the else condition the else conditions
104:56 - when we have these kind of operators
104:58 - with us
104:59 - so what we want to do is pop out two
105:01 - elements from the top of the stack do
105:03 - the computation and then append the
105:06 - result back into the stack
105:08 - now just a quick run through of what's
105:09 - Happening note that the ordering of
105:11 - these matters a lot we are first going
105:13 - to pop out N2 and then N1
105:17 - again uh look at all of the simulation
105:19 - actually Vijaya I didn't explain it back
105:22 - them but is something very important
105:24 - look at what we have done
105:27 - right so as soon as we get the plus
105:30 - operation what do we do we first pop out
105:32 - this element from the top of the stack
105:34 - which is going to take the second place
105:36 - and then we're going to pop out this
105:38 - element which is going to take the first
105:40 - place so this one we currently popped
105:42 - out this guy is the N1 and the element
105:45 - on the right hand side is the N2 right
105:48 - this makes more sense for division as
105:50 - well as subtraction because they are not
105:52 - exactly commutative all right anyways
105:54 - first will pop out N2 and then will pop
105:57 - out N1 whatever the result is we are
106:00 - going to get it by using this Ops of
106:03 - token that is whatever this token is say
106:06 - it's a plus sign so we'll go ahead into
106:08 - this dictionary and access this operator
106:10 - dot add function and this is going to
106:12 - take into values again N1 and N2
106:15 - whatever the result is we're going to
106:17 - append it to the stack
106:19 - now one last thing that we realized one
106:21 - last thing that we realized was that the
106:23 - stack is going to have only one single
106:26 - element at the end of this iteration
106:27 - which is going to be the answer so we
106:30 - return it at the end and uh now let's go
106:32 - ahead and test the code out
106:34 - so we'll run the code once okay looks
106:36 - good and we'll go ahead and submit this
106:39 - all right cool so this works out and uh
106:42 - yeah this is sort of a formal
106:43 - implementation of evaluating reverse
106:46 - polish notation by the way if this seems
106:48 - too fancy you can write some manual code
106:50 - here as well you can just say LF token
106:53 - is a plus sign just go ahead and do this
106:56 - this this
106:57 - and result will be nothing but
107:01 - N1 plus into and something like this and
107:03 - so you can do LF for all of these sort
107:06 - of cases right if that seems too fancy
107:09 - you can do it this way as well
107:11 - all right cool so this is it and I'll
107:14 - see you in the next one hello everyone
107:17 - and welcome in this video we're going to
107:19 - implement basic calculator one two and
107:22 - three all using the same exact code
107:24 - believe me I'm going to do a copy paste
107:27 - like nothing you've seen before all
107:29 - right so the first thing we want to do
107:30 - with basic calculator is realize that we
107:33 - have already written most of the code in
107:35 - these two functions post function is
107:37 - going to convert the infix notation to
107:39 - the post fixed notation and the second
107:41 - one is going to evaluate the post fix
107:43 - notation again both of these functions
107:46 - have been covered in separate videos of
107:48 - their own which each of their own
107:49 - intuitions observations and formal code
107:52 - that we wrote down
107:54 - in this question however we have to
107:55 - write one more function which is going
107:57 - to do the parsing or the cleaning up
107:59 - thing so we're going to do and create a
108:02 - read function which is going to take in
108:03 - the string and return us the infix
108:06 - notation all right that is the goal of
108:09 - this problem
108:10 - okay why do we do this by the way
108:13 - look at this the input we are given is a
108:15 - string and so we can have a case like 3
108:18 - plus a bunch of spaces one space times
108:22 - 337
108:24 - okay so nothing too special but you can
108:26 - see that this is a hard string to work
108:29 - with mostly because won't it be so nice
108:32 - if you can actually have a list of
108:34 - tokens that we need to focus on that is
108:36 - if you have something like say uh
108:39 - something that gave us three then
108:41 - something that gave us Plus
108:43 - then punch Then star then 337. won't it
108:48 - be nice if we have a infix notation laid
108:50 - out like this right this will make
108:53 - things a lot simpler because we don't
108:54 - have nasty spaces to deal with and all
108:56 - of the numbers have been dealt with that
108:58 - is 337 actually is considered as 337 and
109:03 - not three three and seven right these
109:06 - are some of the cases that we have to
109:07 - handle and so what we are going to do is
109:10 - convert and read the string into the
109:12 - infix notation so the infix notation is
109:16 - going to be a list which will return at
109:17 - the end
109:18 - how do we go about making this happen
109:21 - well we'll go ahead and write a by Loop
109:23 - so we'll say I equals to 0 and while
109:26 - I is lesser than the length of s go
109:30 - ahead and keep on doing some computation
109:32 - the first thing we'll do is clear out
109:34 - all the spaces so if the SFI the current
109:36 - character I'm looking at if it's a space
109:38 - well just go ahead and ignore this I
109:41 - don't really want to mess with this
109:43 - what do we do
109:45 - well in the case of space we simply
109:47 - ignore but in the case of operators we
109:49 - can't really do that because we have to
109:51 - add these individual operators to the
109:53 - infix notation list
109:55 - so what I'm going to say is if if s of I
109:58 - is present inside of the operators by
110:02 - the way these operators is the variable
110:04 - over here which is simply just the
110:07 - brackets and the multiplication division
110:08 - signs blah blah if the current character
110:11 - I'm looking at is an operator well then
110:14 - go ahead and add this to the infix list
110:17 - so I'll do infix dot append the current
110:19 - s of I I'll also do I plus equals to 1.
110:23 - all right what's the else condition vl's
110:26 - condition is some case where we have a
110:28 - digit like 2 or 234 or 345 things like
110:33 - that so we have to handle cases like
110:35 - these separately right what I'm going to
110:37 - do is I'm going to create a number
110:39 - variable which is going to be an empty
110:41 - string and I'm going to say you know
110:42 - what while
110:44 - the SFI dot digit is digit actually so
110:50 - while the SFI I'm looking at is a digit
110:53 - well then go ahead and append this to
110:55 - the number so I'll do number plus equals
110:57 - to the S of I
110:59 - and once I'm done with this oh by the
111:02 - way I'll also do I plus equals to 1
111:03 - always and once I'm done with this
111:05 - iteration when the saturation stops when
111:08 - I get either a space or an operator I'm
111:10 - going to say you know what go ahead and
111:11 - stop at this point of time and please go
111:14 - ahead and do infix dot document p number
111:18 - one thing that we always check whenever
111:20 - we write these by Loops is whether s of
111:22 - I will actually exist or not there might
111:24 - be a case where this I plus 1 might take
111:27 - it out of the length of the string so
111:28 - we'll also have to say
111:30 - keep it limited to that while I is less
111:32 - than length of s and this happens then
111:35 - do these computations
111:37 - okay so we are almost done but there's
111:39 - one more thing that we have to keep in
111:40 - mind and this is sort of a well kind of
111:43 - a pain implementation that we have to
111:45 - take care of
111:46 - because here's the thing the minus could
111:48 - be used as an unary operation that is in
111:51 - the case of -1 and sort of minus of 2
111:54 - plus 3 all of these cases like all of
111:57 - these cases are valid
111:59 - but in one of the codes we have seen
112:01 - previously we did not handle these unre
112:03 - operations so what is a hacky way around
112:06 - this okay this is going to be a very
112:08 - happy way but what we can do is we can
112:10 - add a 0 in front of it so as soon as we
112:13 - get an honorary minus we're going to do
112:16 - 0 minus that thing so in the case of
112:19 - minus 1 we'll instead write it as 0
112:21 - minus 1 and instead of minus of 2 plus 3
112:23 - we are going to write it as 0 minus 2
112:26 - plus 3. this is going to make the rest
112:28 - of the implementation consistent with
112:30 - the logic
112:31 - so we'll have to say you know what uh
112:33 - before you do this please go ahead and
112:34 - check if the SFI is actually a
112:37 - minus sign or not because if it's a
112:39 - minus sign then we need to do some extra
112:41 - steps before we can jump into solution
112:44 - all right when is a character when is
112:47 - this minus sign and unre operated
112:51 - this is a ninery operator in a bunch of
112:53 - cases we have to say first of all if
112:58 - I equals 2 equals to 0 then go ahead and
113:01 - do infix dot append 0.
113:04 - that is if this minus sign is the first
113:07 - thing you ever get in the entire string
113:09 - if it is the first position in the
113:12 - string then you have to append a 0
113:14 - before you append this current operator
113:17 - all right but this is not the only case
113:20 - all right so we can have another case
113:21 - where we say uh say 5 minus of minus 2.
113:27 - all right so this is a case where the
113:29 - preceding element with the element to
113:31 - the previous of this minus is actually
113:33 - an opening bracket so we'll also have to
113:35 - take care of this condition and say that
113:37 - you know what if the current minus the
113:40 - zerothal element is the zeroth place
113:42 - where an append 0 to the infix before
113:45 - you append the minus or we have to say
113:48 - or
113:49 - if the S of I minus 1 If the previous
113:52 - element If the previous character
113:54 - was an opening bracket
113:57 - then what
113:59 - then you have to take care
114:01 - to also append the zero by the way just
114:04 - to make sure that this I minus 1
114:06 - actually exists we have to write one
114:07 - more condition and say that this I minus
114:10 - 1
114:11 - this I minus 1 should be greater than
114:13 - equals to 0. right so pretty simple
114:17 - and uh yeah I think we're done now let's
114:19 - go ahead and run the code once oh by the
114:21 - way we still have to write all these
114:22 - functions now so the first thing we'll
114:25 - do is go ahead and read
114:27 - the S string given as the input and this
114:29 - will get me the infinix notation
114:31 - for the infix notation I'm going to
114:32 - convert it to the post fix notation so
114:35 - post fix
114:37 - equals to in fixed to postfix
114:42 - of impacts
114:43 - and finally I'm going to return
114:46 - evaluate postwix
114:51 - all right cool let's go ahead and test
114:52 - this out hopefully it works
114:54 - ah God damn it okay it's a typo line 20.
115:00 - is digit
115:02 - okay cool fixed again hoping that we
115:06 - don't have any issues
115:07 - let's just hope that we don't have any
115:10 - more issues it's going to be a pain
115:11 - otherwise all right I'm gonna go ahead
115:13 - and submit this let's hope and great we
115:15 - got it accepted cool so now as I
115:18 - promised before we're going to do a
115:19 - massive copy pasting thing I'm gonna
115:21 - control C go here and uh
115:25 - paste this baby over here let's go run
115:28 - the code once again get it accepted here
115:31 - all right cool looks good and once
115:34 - finally in the basic calculator 3 is
115:36 - going to do the submit directly YOLO all
115:39 - right cool so we get this code accepted
115:41 - in all the three questions just by using
115:43 - these simple Logics what did we do we
115:46 - first read the input string and we sort
115:49 - of cleaned it up and converted the
115:51 - string to a list of tokens then we went
115:54 - ahead and evaluated and converted the
115:56 - infix to the post fix notation and
115:58 - finally we evaluated the postrix
116:00 - notation
116:01 - all right cool uh this is it for this
116:03 - video and this ends the string related
116:06 - section of Stack questions next up we're
116:09 - going to look at monotonic Stacks which
116:10 - is more of a mathematical side of stacks
116:12 - all right

Cleaned transcript:

Stacks are a common programming data structure and many programming interview questions require knowledge of stacks tanishq has helped thousands of people prepare for coding interviews and now he's going to help you understand the stack data structure by demonstrating how to solve a bunch of common coding interview problems the problems go from easier to harder and Denise will be guiding you the entire time my name is Dani sheltery and I'm very excited to bring you this course on Stacks so let's go ahead and get started hello everyone and welcome let's talk about the implementation of Stack we are going to start off with a couple of examples to understand the reason why Stacks are built in first place then we'll look at the implementation level details of stacks in terms of python and C plus plus all right let's get started now if I ask you the question what do you see on the screen you might reply that there looks to be a couple of books present on a shelf so you can call this a stack of books now what would you do if you had to read the first book the book on the top of the stack well you want to read Harry Potter so you will just pull it out of the stack you'll remove it from the stack you'll read it and then you'll push it back on to the stack once again now this is simple and fine but what if you want to read grocking the coding interview now what do you do of course you can drop pulling it out from the middle but all of these books are dense and heavy and you don't really want to disturb the balance of the elements on the top of the stack so what you can do is you can take out the first book you can take out the second one and then finally read grocking the coding interview you read it and then you can put it back on the stack along with these two books what we have just seen is a very important property of stacks that is called the leaf ordering lifo stands for lost in first out saying that the elements that come into the stack towards the end that is the elements that come in the last or the first ones to get out blast in first out now this is a property that will exploit again and again throughout this entire series it's going to be a central property and it's the heart of the reason why we use a stack in many of these questions now let's go ahead and formalize the operations we can do on the stack because we know that if the leaf ordering is being followed we have to use a stack but how do we exactly we use it well let's look at a couple of operations the first operation we saw was removing items from the top of the stack we call this operation formally the pop operation because we are popping the elements out from the top of the stack right so this is going to be the pop operation the second operation we saw was to add the book back onto the stack in other words we're looking at a push operation pushes the formal term used to define saying that we want to add an element onto the stack in other words we'll push an element on the stack now there's a final operation that we do very commonly and that's the peak operation now the peak operation simply says hey go ahead and take a look at the top of the stack go ahead and take a peek at the top of the stack right so these are three operations that we'll keep in mind all right so now let's go ahead and actually look at how these are implemented in terms of python and C plus plus Java implementations are pretty close to both of them so even if you understand just one implementation way you'll be able to do it in any other language I have ensured and tried my best to make sure all of the codes are language agnostic they can be easily translated from one language to the other without having a lot of issues all right so let's go ahead and actually look at how we are implementing these the first thing is how do we initialize this tag and in Python we're going to use the list implementation of Stack because there is no inbuilt internal class for it we're going to create a list empty list of our own to initialize the stack in C plus plus there is so we're going to use stack and we're going to have a stack of int variables and we'll call it as pretty simple all right how do we push in Python we do stack dot append and so we can do stack dot append an item and this is going to return a nonvalue that is it does not return anything we just append this element onto the top of the stack in C plus plus we simply do s dot push this is going to return a null all right how do we Peak how do we check what is the element at the top of the stack well in Python the way to do that is to use stack of 1 that is it is going to give you the last element on the top of the stack right so in this case it's the element three how do we do it in C plus plus we simply do s dot top now remember this is a slight terminology difference but nothing much you want to look at the top of the stack you want to peek at the top of the stack this is how you do it all right how about pop in Python you do directly stack dot pop and that is going to return your value three this is a crucial Difference by the way in Python you're going to get a return value of 3 however in C plus plus when you do the pop operation you're not going to get any return value all right this is super important especially when it comes to implementation keep the language specific details in your mind all right the last thing which will also very commonly use is to check whether the stack exists or not in other words is the stack empty or not so in Python we can simply use the stack variable and that internally checks its length so in our case we appended one element we checked the top of the stack and then we popped it out so the stack is currently empty in both the cases now if you just use stack if you say if stack colon blah blah blah that is going to return of value of faults because the stack is empty right in C plus plus we can do s dot empty which is a function that is going to work on the stack variable and it's going to return true saying that you know what the stack is indeed empty so again small implementation level details that you have to keep in mind all right so now that we have a better understanding of how do we Implement Stacks let's go ahead and take a look at a real life test case where Stacks will be very helpful to understand hello everyone and welcome back in the previous video we talked about how to implement Stacks in terms of C plus plus and python in this video we're going to take an example problem simplify path to build up our understanding of stacks further in fact this question is present of both lead code and interview bit and has been asked in companies coding interview rounds many times this in fact forms a basis for very important point that how Stacks are being used in the real world as well all right let's go ahead and get started with the formal problem discussion so we're given a path and this path is a Unix path given to us and the goal of this problem is to return the canonical path now if you're not familiar with how paths are unique Unix based paths work I'm going to link to resources down below so you can check them out first anyways we're given a path and we have to follow four conditions to return a canonical path first we have to start from a single slash the slash represents nothing but the root directory second any two directories are separated by a single slash so we can have directory one slash directory 2 slash blah blah blah condition 3 says that we should not end with a trailing slash in other words the slash at the end of it if there is a slash at the end of it you have to return it all right fourth condition which is the most important one it says that it only contains the directories on the path from the root to the Target that is there is no period or double period directories now period and double period have special meanings period basically says that wherever you are stay that is whatever directory you are on currently just stay over there double period means take a step back right so whatever directory you are on take a step back all right let's try to uh formally build up our intuitions and our logic all right let's take a couple of examples to understand this better first things we have a slash home slash SD input the blue is the input and the green is the output which by the way is a common coloring schema followed throughout the rest of the series so you don't have to worry about anything all right so we have slash home slash and what is the output the output is slash home that's because we have a trailing slash at the end of the input which we remove all right let's go ahead and take another example in this case we have slash dot dot slash what it means is we start from the root directory and we have to take a step back because dot dot really means that you have to take a step back from the current directory and then we have a slash at the end so of course you can remove the slash at the end because it's a trailing slash but now this double dot means that from the root directory we have to take a step back but there is no step Backs from the root directory root directory is where you start so in fact this will simply be reduced to staying on the root directory that is from the root if you want to take a step back you will end up at the same route all right let's take another example and this time we have slash home slash slash 1337 slash dot slash first things first remove the trailing slash now what we notice that between home and 1337 there are actually two slashes what does that mean well in our case the implementation level detail is that if there are multiple consecutive slashes all of them will be useless basically and we only have to consider one slash in other words multiple slashes will get compressed to a single slash so we have slash home slash 1337 note that the period at the end now means that we have to stay at the current directory so we were at 1337 and we stayed at 1337 let's take a look at one final example which is going to be the most important one and this has sort of all of the conditions mentioned in the question so let's go ahead and formally try to break this down to get the logic first things first we start off with the single slash which is going to be a root directory this is by default present in all the test cases we have to start from the root directory now what's the next step we want to go toward the next value which we see is home now what does home mean who means that we have to go One Directory forward that is from the root you have to go to home all right so pretty simple but now you get a dot dot what does this mean this means that you have to take a step back which means that from the root you first went to home but now you have to take a step back and go back to the root all right pretty simple again uh work next we get a dot dot once again and since we are already at the root taking another dot dot simply means that go straight at the root all right so now we get a slash uh TMP and what does that mean that means that now we have to take a step forward we have gotten the directory and so we'll go to slash TMP and then we have a bunch of slashes together that we have two slashes that just gets compressed to one single slash and then we have a DOT now dot simply means that wherever you are stay so you viewer are the slash temp directory and we'll stay over there and of course the last slash at the end is just a trailing one so we'll remove it in other words the final answer we get is slash TMP as we saw in the first line of this slide so now let's go ahead and formally talk about how did we do this how are we going to implement this going forward and going backward thing if you have guessed it yes you are right we have to use the data structure of course this is a playlist of our Sac we have to use a stack but why do we use it again whenever we have a directory like home or slash TMP we have to take a step forward and whenever we have dot dots we have to take a step backwards and a good way to simulate that is by using a stack all right let me go ahead and show you how this formally works out so the first thing we get is uh home so home means that we have to move forward which means that we will push the value home on to the stack that is we'll append this value to the top of the stack now we get a dot dot next what does that mean that means that we have to go back One Directory in other words we have to pop the element out of the stack right we get a dot dot once again but the stack is already empty what do we do this is a special condition and we have to say that you know what if the stack is empty you can't really pop anything and we don't really have to pop either we were at the root and we'll stay at the root so the stack remains as is then we have TMP so what do we do next this is a directory so we append it we push this value on the top of the stack now we get a DOT what does that mean that means whatever directory you are at stay there in other words the stack remains unchanged so if we have to formalize what can we say let's focus on the core Parts first things first how do we start the way we start is at the root and that is nothing but the cue to initialize the stack right whenever we start we're going to initialize the stack now directory means taking a step forward what does that mean that means that we're going to append an element onto the top of the stack in other words we are going to push this directory in the stack right and what does dot dot mean dot dot now means that we have to pop we have to go One Directory backward so whatever you append it just pop it back again and then finally we have a DOT which means that we really do nothing do no operations and this is really it this is it for the logic of this problem let's go ahead and look at the optimize solution and we're going to code it up from scratch all right let's go ahead and look at how do we implement this question in terms of python code the first thing we'll do is initialize the stack to be an empty stack and then we'll start to iterate over the directories in the paths now obviously the path given to us is going to be a string which is separated by these flashes so each of them directories that is any two directories are separated by a single slash so we have to say go ahead and do path dot split by the Slash that is get me the individual directories and we'll see what to do next so what's the first condition we saw remember from the code remember from the logic the first condition we can say is that you know what if you get a DOT that is if you get the operation where the directory we have to move to is a DOT that means that wait don't really do anything right we don't really do any operation on the stack if we get a single Dot so it was the other case we'll have the directory is what if it's a double lot what do we do if it's a double dot we have to do an operation called pop that is we have to go back one step we have to pop the element from the top of the stack so we'll do stack dot pop but now is a very important Edge case right this is a very important condition I'm going to write see it's not always the case that you can pop this directory from the stack that is for stack dot pop to work you have to ensure that stack is not empty because if the stack is empty and you pop an element out of the stack that is going to give you an error whether it be a python or C plus plus or Java all of these languages are going to give you an error if you pop an element out of the empty stack so first we'll go ahead and check hey you know what if the stack exists only then go ahead and do the stack dot pop operation what do we do else what do we do otherwise well in case this Jack is already empty and we get a double dot what does that mean on an empty stack which means that we are at the root and we get a double dot which means that from the root we have to move a step back which means that we just have to stay at the root so the stack remains as is and this condition in the else condition we don't really have to do anything all right it was the final case what the final case is say that go ahead and append this value to the stack append this directory to the stack all right so this is it right we're going to return what well one of the conditions the first condition and the question says that the path starts with a single slash so we're going to go ahead and start with the single slash and since we have all the directories in the stack let's go ahead and do the join operation so we'll do uh join Dot start so what this is going to do is iterate over all the elements in the stack and join them with a slash in the middle all right so before we go ahead and run this code by the way there's one more condition that is important to know see because directories can have a case where we have say double slashes that is if we have slash home slash Foo slash these double slashes are going to give us an issue because when we split when we split this path by slash it means that there is going to be a case where there is one slash and then there's a empty string and then another slash in other words what I'm saying is we have to add one more condition saying that if the directory is actually empty that is if there were multiple consecutive slashes then we don't have to do anything like that right if we get multiple slashes we just look at it as one slash and we don't really do anything right so this is it for the logic of the code and let's go ahead and test this out on a bunch of input test cases looks to be correct so let's go ahead and submit this and we get it accepted all right so this is it for the solution to the problem simplify path hello everyone and welcome back let's talk about the problem main stack on interview bit all right so the goal of this problem is to design a stack that supports a bunch of operations first Operation Push we have to push an element X onto the stack very simple second operation you have to design an operation that returns as the top of the element that is it is going to see what is the top of the stack and return it third operation we have to design a function that pops the value out of the stack we have to remove the top element and return it right so all of these three operations up till now are something we've already seen that are like very basics of what a stack is but now there is a fourth operation given to us getman this function is going to return a value X which is going to be the minimum value of the entire stack now the only constraint that is given to us is that all of the queries should run in constant time that is we should take order of one time each now how do we start to think about a solution once since the problem is about using a stack let's go ahead and create a stack and we'll start to see what do we do once we get the queries all right so this is the simulation will run let's say we get the um query to push the value 7 onto the stack so now this is how the stack is going to look with the value 7 on top of it if you get push 3 we'll just Add 3 to the top of the stack we hit push nine we add 9 to the top of this track now let's go ahead and say that we get the query getman what do we do at this point of time gateman query says that go ahead and get the minimum element of the entire stack which means that a naive way to proceed about it is to go over all of the elements inside of the stack one by one and find the minimum value in this case we find the 3 is the minimum value so we'll go ahead and return 3. now let's say that we get another operation called pop so we'll go ahead and pop the element out of the top of the stack then let's say we get uh get min again what are we going to do iterate over the entire stack go over all of the elements one by one and return three we realize that three is the minimum value right so let's go ahead and say we get another value another Operation Push one so we will add one to the top of the stack getman says well get me the minimum value of all the elements in the stack which means that the value will be 1. now if you realize what we have been doing up till now is all of the operations like portion the pop even the top are going to take order of one time to run as it does in normal stack however the gate main operation is kind of a pain that is because we have to iterate over the entire stack one by one taking order of end time where n is the number of elements in the stack this means that there has to be a better way to do it we have to figure out a way to answer the getman query in order of one time all right so let's go ahead and talk about the optimization this is one of those questions where if you don't know what to do you really would have no idea on how to proceed and in these kind of questions what we are going to do is we're going to create another stack that's right we're not doing just going to have one stack we are going to have two stacks the first is the blue one which we already saw which will handle the queries like push and the Bob in the top but we will also have a green stack which is going to keep a track of the minimum value we have seen up till now let me go ahead and show you the simulation once again and that will make a lot more sense because it's a beautiful way to approach this problem right so let's go ahead and say we get the query push second we get the request to do push seven so we'll just add 7 on the top of the stack now this is the stack we're going to append it to we're going to add it to the blue stack directly whatever query we get we directly apply it to the bluestack the green stack will simply reflect the changes of the blue one so since we added 7 to the stack the minimum value of the stack is now 7 so we'll add 7 to the stack now let's say we get a push 3 Operation what do we do because this is a blue case we'll simply add 3 to the top of the stack but we'll have the three reflect changes in the green stack as well that is the green stack is now going to store a value that is the minimum of 7 and 3 because we have two elements on the top of the stack right so we're going to have minimum of 3 and 7 and so we'll store three now let's say we go ahead and get the value as uh let's say we get a push nine operation now the top of the blue stack will have nine but the top of the green stack will have the value 3. and that is because 3 is the minimum value of 3 and 9 which is going to be the minimum value of the entire stack all right so now what do we do now we if we get a query get min what do we do simply look at the top of the green stack and return that as the answer we are not going to pop out anything at this point of time right as soon as we get a get main query we are going to Peak at the top of the green stack and return that value now let's say we get a operations which says go ahead and pop the element out of the stack so this is going to pop the element 9 and now we have to make the green stack we reflect changes of the blue one since we removed an element we will also have to remove the element from the green stack now what if we get a getman query once again if we get a getman query we'll simply look at the top of the stack and since the value 3 will return 3. right so now let's say we get a push one operation what do we do one gets directly pushed onto the green sorry pushed on to the blue stack and the green stack is now going to reflect the changes green stack is going to have the value the minimum of three and one that is it is going to take the minimum of the previous element on the top of the stack the one which we got currently all right so now if I get uh get men again what do we do look at the top of the stack and return one as the answer all right so this is really it for the logic of the code what we have done is we have figured out a way to implement the solution using two stacks so let's go ahead and initialize sorry and uh let's go ahead and create self dot stack and we'll have self dot Min stack right these are the two stacks that we initialize this is the green one and this is the blue one all right now what do we do when we get a push query the stack the stack that we have the blue one is simply going to reflect the changes directly so we'll say when we get a push operation self dot stack dot append X nothing special but what do we do about the Min stack Min stack is going to reflect the changes so I'm going to say self.minstack dot append well I want to append the minimum value of the current X that is I'm going to take the current value and find the minimum with the Min stack top so we'll go ahead and do the main stack find the Top Value and take their minimum right pretty simple this is exactly what we discussed before but now we have to take care about one thing this is a common thing which we have to take here across all the stack questions see what we have tried to do here is that we have to try to access the minus one element on the Min stack that is I'm going to find the top element of the main stack but this will only work when will it work this will only work if the self dot main stack is not empty but if it's empty what do we do look if it's not empty we'll simply take the Min of X and the top of the stack but if it's an empty stack let's just go ahead and directly append this element to the main stack so we'll do self dot mainstack dot append X all right this makes sense so now what do we do when we get the pop operation remember we have to ensure that all of the changes in the stack are reflected in the green one as well so when we do self.stag.pop we have to do the pop operation for the Min stack as well again one more Edge case one more condition you can only do pop when you can only do pop if the stack is not empty so we'll say if self dot stack exist that is there are elements inside of the stack then you can do pop but if the stack is empty pop will really do nothing so we'll just say it's pass right now what do we do when we get top again uh here we have to return what is value at the top of the stack so we'll do stealth dot stack minus 1. but wait a second it is not guaranteed that the self of TAC of minus 1 is going to exist in other words the stack might be empty so if self dot stack exists well then you can go ahead and do this but what do we do otherwise the stack is empty and we are asked to return the top element of the stack well look at the condition in the question mentions something what should top do on an empty stack return 1 so in this case we are going to return 1 right what do we do when we get get min now remember in the top function we return the top of the stack which is the stop of the blue stack but in the getman function we're going to return the top of the green stack so we'll say if self self.minstax exist well then you can go ahead and return the self dot main stack stop but if it does not go ahead and return 1 you can see that there's a lot of paddles between gateman and the top that's because the only thing that changes is the stack in top we use the blue stack and in the green one green one is used in the getman function all right let's go ahead and test this out quickly looks like this is correct so we'll go ahead and submit this all right we get it accepted and this is it for the solution to the problem men stack on interview bit all right that's it hello everyone and welcome back now this is after our first section on where we discuss the stack related questions where we built up our understanding of stacks the implementation level details along with a couple of example problems to help us understand things better in this section we're going to focus on parentheses related questions which is actually going to be a step up from the previous one and is going to lead us to calculator related questions in the next section now why are we talking about parentheses questions in stack playlist you will get the questions answered very soon what we're going to look at is a bunch of example problems like valid parentheses longest valid parentheses written in braces and many more these are commonly asked in interviews and applying Stacks to these problems becomes a crucial part of understanding Stacks themselves all right now we will go ahead and take a look at an example and we'll try to build up our understanding of parentheses related questions and calculated related questions later on because what we're going to understand is the reason why we use Stacks inside of these parentheses questions in the first place all right so given this expression to you let me ask you the question if I give this to you on a paper and I'll give you a pen to solve this how would you go about solving this kind of expression the first thing you would want to do is look at the innermost brackets that is the innermost brackets contain the value D so let's go ahead and evaluate that first right you want to focus on the innermost first and then slowly zoom out to the outermost now what do we do zoom out to we would zoom out to B minus D in The Next Step and this would then finally lead us to the entire expression what we have done is nothing but parsing now parsing is a fancy word for what it means is we have to figure out the structure of the input that is it parsing means to figure out how the input is laid out now why do we want to understand the structure of the input why is this kind of thinking helpful let's take a look at a simple example we'll take this simple example and in this case we have two opening round brackets and two closing round brackets now if I ask you the question can you tell me what is the corresponding opening bracket to this current closing round bracket that is I've highlighted this closing round bracket for you can you tell me which of these is the corresponding current opening bracket pretty simple to answer because we already know the way we do this is by taking the bracket that is the closest we figured that this opening bracket came in the last and was the first one to get a result wait a second the bracket which came in the last was the first one to get resolved that is we're following something of the sort of a leaf ordering that's right this is the reason why we use Stacks in these parentheses questions because when to use stack is answered whenever we see Lee for ordering right so we have seen that we have to use a stack in parentheses questions and in calculator related questions as well but how exactly do we use it how do we use tax in these kind of questions what we are going to do is we are going to do a left to right parsing as I explained earlier parsing is a fancy word what it simply means is we have to understand the structure of the input we have to break it down step by step and understand okay this is what gets resolved first and this is what get resolves later on now left to right simply means that we're going to iterate from the left to the right okay enough talking let me actually show you with an example so this is the example case we took earlier and we have initialized an empty stack on this all right so what do we do next well here's a rule that you have to keep in mind anything that you get which is a opening bracket a character Like A B C D or an operator like plus minus division multiplication anything of that sort you get you simply append it to the stack that is you push everything except close brackets on the top of the stack here's what I mean say we get this opening round bracket we do nothing but push this on the top of the stack then we get a push it on top of the stack then we get Plus open curly bracket B minus open around bracket d the only time V and B do not append items on a stack is when we get a closing bracket this is important this is very important if we get a opening bracket a character or an operator whatever we directly added to the stack without thinking without having second thoughts but as soon as we get a closing bracket of any kind we have to start thinking all right so I already asked you the question of what this closing bracket actually closes what is the corresponding opening bracket and if you see in the stack we actually have that value with us we have this opening round bracket on the top on this stack here however that is not the top element and it might not always be obvious which of these opening brackets am I closing right because we have a currently we have a closing bracket in our hand and we want to figure out hey what is the area that I close what is the area what is the expression that needs to be resolved first because I'm following the leaf forwarding again so what we do is we'll keep on popping these elements of the top of the stack till we see a corresponding opening round bracket here's what I mean as soon as we get this closing around bracket we'll go ahead and start looking for the opening round bracket so we'll pop out D because D is not opening round bracket and so D sort of in an intermediate state we don't really know if D is part of a valid expression or not so we'll just keep it hold right now what we get on the top of the stack you see that there's a opening round bracket what does that mean currently look at the yellow marker we are at a closing round bracket and on the top of the stack we have found a opening round bracket in other words everything inside of both of these brackets is going to get resolved both of these brackets satisfy each other both of them resolve each other and everything in the middle of them will get satisfied so D is actually part of a valid string now right the brackets are balanced in a way all right so now let's go ahead and look at what happens later on we'll keep on iterating and we get a closing curly bracket now what do we do again this is a closing bracket so we have to be careful what do we do we look at the value on the top of the stack this is clearly not opening curly bracket so we'll go ahead and remove it but we'll keep it on hold minus maybe or may not be a part of a valid string all right so we have B now again B is not an opening curly bracket so we can't care about that so B and minus are both at an intermediate State we can't really see anything about what do we get now we have a opening curly bracket in other words we have found the opening for this closing curly bracket which we are on currently in other words what does that mean that means we have resolved everything in the middle of these two brackets so you can see somehow that kind of structure is being followed again we have sort of parsed the input we're trying to understand how this input is laid out all right so now what do we do next let's go ahead and keep on iterating so we get a start again this is not a closing bracket so we'll just add it directly we get a c not a closing bracket added directly and now we get a closing round bracket what do we do next what do we do think about it we're gonna keep on popping these elements out one by one we're gonna keep on popping them out till we get an opening round bracket and as soon as we get an opening round bracket what do we know we know that everything in the middle of both of these brackets is going to be validated and this is the way we have figured out how to parse the input we knew that we had to use a stack because we could see the leaf ordering being followed in the way brackets were opens and closed and then we figured out how to exactly go about looking at the opening and the closing of brackets by using a left to right parsing now a quick small implementation level detail is how do we implement this in the previous example I showed you we were appending these brackets and the pluses and the minuses directly and you can do that you can directly add the elements or you can also add the indices now uh different questions will require different cases but in general if you want one single template just use indices that's because if you append indices to the stack you will obviously have a mapping to the elements as well but if you only append elements to the stack you might forget which indice which index it came from anyways that's a very small level detail but still important to keep in mind just make sure you are consistent with what you are appending to the style whether it be elements or indices right so what is the conclusion let's summarize this once more we figured out in all the parentheses and the calculated questions we have to use a stack why is that because these brackets were following a leaf ordering last ones to get in were the first ones to get out they were the first ones to get a result and how did we figure out how do we use it we know we have to use a stack and we iterate it from the left to the right and we parsed the input we figured out the input and the structure of the string that is given to us and finally you can either add elements or the indexes to the stack that's upon you and that's a small detail you can take care of later on as well all right so keeping these three rules in mind let's go ahead and work out a couple of problems to fully get comfortable with parentheses related questions hello everyone and welcome back let's talk about the problem valid parentheses on lead code this by the way is a slight bit modification of the problem balanced parentheses on entropy bit if we are able to solve this you you will obviously be able to copy paste the code and get it accepted for balanced parentheses as well anyways this entire solution is based upon the understanding from the previous video where we talked about the introduction to all parentheses based questions we figured out how do we use the leaf ordering how do we go from the left to right and pause the input and the way we exactly Implement Stacks so if you haven't checked that video out I'll highly recommend you do because this solution is based entirely on top of that in fact it's going to be a very easy version of what we have seen before all right let me go ahead and show you and take you step by step throughout this problem given a string s containing only brackets we have opening and closing brackets of the type round curly and square and the goal of this problem is to return true if s is valid and false otherwise so looking at the example cases we have the first one Returns the output issue because the closing and the opening brackets match and mix and match appropriately in the second case however there is a spray opening curly bracket which never gets closed in fact it is trying to close the round bracket which is going to be invalid so we have to return false in this case all right let's go and talk about the intuitions and the observations needed to solve this question a bit more formally we'll take the same test case and we'll try to build our understanding from this now if we focus on the opening round bracket we see that it gets close towards the very end we get a closing round bracket towards the very end so both of them resolve each other out all right what about the opening and the closing curly brackets well both of them again mix and match well and this closing bracket is able to close the appropriate opening bracket that is the closing query bracket wants an opening curly bracket to be present before it and it is so we can see that this is also a valid case what about the square brackets again the opening square brackets gets closed by the appropriate closing bracket so this is also valid which means that everything inside of this test case mixes and match as well the opening brackets are closed by the appropriate closing brackets so we return true in this case right let's take another example and this time we have something more interesting going on because we have the same number of opening and the closing brackets that is for one opening around bracket we have one closing round bracket one opening curly bracket we have one closing curly bracket but the ordering in this case is meshed up that's because if you can notice this closing round bracket is trying to close an opening curly bracket obviously this will never work because this closing curly bracket sorry this closing round bracket wants to close an opening round bracket it cannot close the opening curly bracket so brackets in this case do not match and obviously this is contrasted with the case where we have the same number of opening and the closing ground and curly brackets but one of them is invalid and the other is valid so clearly ordering matters and if you notice the input has to follow this Leaf ordering that we discussed in the previous video as well that is the last bracket to get in should be the first one to get out and that was sort of the intuition behind using a stack and we also discussed how do we go from the left to the right and parse the input let's go ahead and do that in the next step one more thing we also discussed that if the brackets open add them directly if the brackets close check what they are closing that is if you get any kind of opening bracket just add it to the stack without thinking Twice But as soon as you get a closing bracket what do you do as soon as you get a closing bracket you have to check whether it closes the right opening bracket or not all right let's go ahead and go ahead with the simulation the first thing we'll do keep on iterating from the left to the right we get the first element as an opening round bracket opening bracket what do we do add directly no thinking then we may trade forward and we get opening curly bracket again since this is opening we'll just add it directly no thinking twice but now what do we get we get a curly closing bracket now we have to be careful we have to be very careful in what we do because as soon as we get a closing curly bracket what do we expect we expect that it closes an opening curly bracket because no other case will work out this closing curly bracket cannot close an opening round bracket or an opening square bracket it can only close and opening curly bracket so now following that leaf ordering again we look at the top of the stack what is the top of the stack it's a opening curly bracket so that's great but this current closing around sorry this current closing curly bracket we found an appropriate opening curly bracket in other words both of them validate each other and satisfy each other pretty nice right all right let's go ahead and continue iterating and we get an opening round bracket since it's opening we added directly but now what to have what happens next we get a closing square bracket what does that mean well this closing square bracket comes in and requests that hey uh can you get me an opening square bracket because that is who I can satisfy right I can mix and match well with the closing or sorry opening square bracket so we go ahead and look at the top of the stack and we see that it's the opening round bracket instead what does this mean this means that this closing bracket is actually invalid and so this was illvalidate the entire expression as soon as we get one invalid case one parentheses messes up as soon as one guy messes up the entire string gets canceled think about it that way right now just to another example is uh what happens if we had a closing round bracket what would happen in this case in this case what would happen is we would be able to mix and match well with the top of the stack so we can say that you know what this closing round bracket will be able to match with the stack top both of them resolve each other and we can move forward with our lives again this is a closing round bracket we'll check the top of the stack is it an appropriate opening bracket yes it is so let's go ahead and close that and we're done now what do we see happening at the end all of these brackets are validated all of the opening brackets have been closed and this is the reason why stack is empty remember this is another important condition which you might miss the stack should be empty at the end and what it says is really is that all of the brackets that opened which we put into the stack remember all the opening were put into the stack and all the closing were removing them from the side so if at the end the stack is empty that is a good sign because we were able to close all the brackets that ever opened now what's another case that could happen let's say that we have another curly bracket towards the end now this is the entire string what would happen in this case we would add it to the stack but this would never get resolved in other words it will be left alone and it would make the entire expression entire parentheses invalid right so it's very important for us to follow a couple of conditions let's go ahead and formalize the logic and that should make a lot more sense all right let's go ahead and talk about the code for the is valid parentheses question all right so first things first we'll go ahead and create a stack which is going to be an empty list next we want to create a mapping from the uh closing bracket to the opening bracket that is for this closing bracket for a closing curly bracket I expect an opening curly bracket to be present on the top of this track right this is something we've discussed already we have to do the same for opening and closing brackets for all the kind now all right cool so now that we have created the mapping we can finally go ahead and start to iterate from the left to the right so we'll go over all the characters in The String given to us now first things we'll check is that if the character is a opening bracket if it's round square or curly opening bracket then don't think twice just append it to the stack right because as soon as we get a opening bracket we directly add it to the stack without thinking twice this is something we've already established else else what do we do in the else condition things get more interesting because now I have to say you know what to check if the mapping of this character if the mapping of this closing bracket maps to the correct value present on the stack top that is for the closing bracket that I have right now can you check if it maps to the correct value that is the opening bracket of curly type on the top of the stack because if it does then it's good then it's good right and we'll see you know what since both of them match both of them resolve each other so I'm just going to do stack dot pop I'm going to remove this bracket that matched all right what do we do in the ash condition what do we say when there's a mismatch as soon as there's a mismatch I'm going to return false I'm going to be merciless as soon as you guys miss much I'm going to return false right away okay there's one more thing that we need to take care of see I've tried to access the stack of 1 here what have we learned up till now you just cannot access this stack of 1 just whenever you want you have to ensure if the stack exists and only when the stack exists you can do all of these operations well what do you do otherwise what if the stack does not exist what if the stack does not exist and you have a closing curly bracket or closing bracket of any kind rather in that case that closing bracket is trying to close something that doesn't exist in other words we can just set it on pause right away all right so at this point are we done can we return true not so fast this is where another mistake can occur we have to ensure that the stack is empty we have to ensure that the length of the stack is equal to equal to zero why because we already saw this example over here in this case we reached the end of the iteration and we had one curly bracket remaining in the stack and this curly bracket was never resolved it was never popped out of the stack which means that it Still Remains unresolved to this date in other words this entire expression became invalid just because the stack was not empty in just to reframe what does empty stack mean empty stack really means that although the brackets that were input into the stack all of the opening brackets that were ever inputted into the stack have been closed all right cool so let's go ahead and run this code and this gets accepted so let's go ahead and submit this once and we get it accepted as well all right cool so this is it for the solution to the problem valid parentheses hello everyone and welcome back let's talk about the problem redundant braces on interview bid now just a quick aside if you haven't watched the video introduction to parentheses question I highly recommend you watch it because we are directly going to use rules and logic that we formed in that video inside of this question because we're going to apply things directly without talking about it much that's going to make the solution a lot simpler all right anyways let's talk about the problem statement first given a string a containing operators round braces and letters so we have a bunch of operators like plus minus multiplication divide then we have our round braces so we have the opening and closing round brackets and a bunch of letters the goal of this problem is to return one if a has redundant braces and zero otherwise all right so let's go and take a look at some examples how do they find redundant in the first case we have a redundant brace because we have two sets of round brackets wrapping the a plus b when we only ever need one in the second case we see that there are no redundant brackets because we're going to make use of every single one of them so let's go ahead and take a look at some observations and logic from test cases given and really there is just one single observation that we need to pull out from these what is that let's try to build up to it the first test case we see is a plus b wrapped in these two sets of braces why is there redundancy in this because instead of 2 we can just use one right let's take a look at the last test Keys here we have a simple letter A which is wrapped inside of these parentheses but it looks like we don't really need this the example and the problem sector says that you know what this is a case of redundant braces because you don't really need to wrap a in anything else and in the middle we see that we have a plus a plus b in this case there are no redundant braces we're using every single thing now what do you notice there's actually one thing in common with all of them which makes the solution work and this is the central observation of the entire problem what is the observation the observation is there should be no operators in between these braces so in the first one you see between the first set of braces and the second set of braces there are either no letters and no operators right there are no letters or operators in the second one there are both letters and operators and a third one there is a letter but there is not an operator right so we have to ensure that there are no operators between any two sets of braces because if we can make this condition work then will have a case of redundant braces all right just a quick aside what are some of the rules that we saw earlier rules when do we decide when we have to use a stack we use a stack whenever we see a leaf ordering being followed and that is true for all parentheses questions so in this question we're also going to use a stack however we're going to use it we're going to go from the left to the right and parse the input see what uh structure this input is following and finally how do we implement this in this question the elements are the bigger uh Focus instead of the indices so let's just focus on elements let me actually go ahead and show this to you right as we discussed there should be no operators between any two sets of braces this is something we'll keep in mind as we go through the example all right so let's go ahead and iterate from the left to the right one by one so let's say we have the first element and that's the opening bracket so let's just push it on to the stack again if we get opening bracket if we get a operator or if we get a letter we push that onto the stack the only time we don't push an element onto the stack is when we get a closing bracket because then we need to be more careful again this is something I've already explained in the parentheses questions uh the introduction to parentheses questions video if you haven't checked it out if you haven't understood it well enough go ahead and dive into advanced mode right cool so we'll go ahead and continue iterating we get another opening round bracket so we'll just add it to the stack now we get a then we get plus and then we get B nothing special these are just opening brackets operators or letters we add them directly onto the stack without any question only when we get a closing bracket then we have to be careful all right so now that we have gotten a closing bracket let's try to be more careful with what we do what's the first thing we do well this closing round bracket is looking for an opening round bracket to close make sense so we look at the stack top well that's an element B um B is not really useful for us so let's just go ahead and pop that and we'll keep it as an intermediate state we don't really know if B is useful or not and then we see a plus now what does that mean look at the condition on the top right the question wants that there should be no operators if you want to have a redundant brace that is if you can find an operator in this case we have found an operator that means that the expression that we're going to interrupt in these two opening and the closing round brackets is actually going to be a nonredundant one we need those braces in this case again that is just how the problem is defined so now since we have found an operator let's go ahead and keep that in mind and we'll keep on popping these elements out one by one again so we go we pop out plus and then we also pop out a but now what do we have on the stack top there is a opening round bracket and what do we have currently the pointer is pointing to it's losing round bracket which means that everything inside of this has to be considered together right now since we found an operator What can we say about this current highlighted section we can say that this is actually non redundant case so this is actually a valid case of how braces are being used so let's not touch this we'll just keep on iterating forward so now we get a plus again it is not a closing bracket so we can just add it directly no thinking again opening bracket good to go C good to go ah but now we have a closing bracket so let's try to be more careful this time now what do we do the first thing we do is look at the stack top we have our element C again it's not an opening bracket so let's just pop it out keep it as a intermediate state and now what do we have we have a opening bracket so we have found an opening bracket for this current closing bracket what does that mean that means that the entire highlighted expression is what we have to look at right now but look at this there was no operator that we found in the middle right there was no operator in this highlighted expression which means that there are redundant array cells that's correct so this is what it means we have found a redundant bracket and we can return true that yes indeed there are redundant brackets in this input all right so let's go ahead and take a look at the optimized solution and we'll go ahead and code this up right so this is going to be the code where we start from an empty stack again very simple and then we'll go ahead and iterate over all the characters in the input string right now as I mentioned what is the first condition the first condition is if you get a letter if you get a operator or an opening bracket that is if you get anything other than a closing bracket this is directly appended to the stack no thinking at all all right when it goes to the edge condition we have to be a bit more careful so in this condition what we'll do is we'll keep a track of the count and this count keeps a track of account of the number of operators we have seen because remember that is what is going to tell us whether a bracket or whether an expression inside of the input is redundant or not so we'll start the count from 0 and we'll say you know what since we have found this uh closing ground bracket let's just go ahead and keep on popping these elements out from the top of the stack one by one till we get a opening round bracket right till we get a opening round bracket so we'll go ahead and say now if the Pod is actually an operator that is if it's any of the plus minus star or Division if the character is any of these operators then I want you to do count plus one in other words since we have found a positive number of counts of The Operators whatever the expression is going to be is going to be a valid nonredundant expression and of course at the end of this while loop we are going to do a stack dot pop because we want to pop out this uh opening bracket we don't really have any use for this at all anyways now what do we do once we're done with this entire iteration of this while loop we're gonna check what the condition is we're gonna say if the count is zero that is if the count did not change at all in other words we did not encounter any operators if we did not encounter any operators return one we have found the case of redundancy and if not we'll just keep on going forward going forward again and again and again and if throughout the entire iteration of this entire string you find no such redundancy then you can safely return 0. that is the entire string is nonredundant right so let's go ahead and test this out it looks like it works and we'll go ahead and submit this as well cool so this gets accepted and this is it for the solution to the problem redundant braces hello everyone and welcome back let's talk about the problem minimum removed to make valid parentheses this by the way is a medium level question on lead code and we're going to use this problem to build up our solution for longest valid parentheses as well in fact this solution is going to convert that hard problem into an easy one I'm not even kidding all right let's go ahead and get started with the problem statement so we're given a string that contains opening and the closing round brackets and lowercase English letters the goal of this problem is to remove the minimum number of parentheses to make S valid so in the first case we see that there are two opening brackets and one closing bracket and we see that we have to remove any one of these opening brackets to balance these opening and the closing ones out okay pretty simple and so what I've decided to do is I've decided to remove the first opening bracket and keep the second one you can also do it the other way both of them are perfectly fine in the second case we have the input as 1337 wrapped inside of brackets in this case I have to remove no such parentheses to convert it to a valid string because it's already a valid string all right so let's go ahead and take a look at some observations the logic to build up to the solution now we already talked about this test case where we removed the first bracket but I want you to notice one more thing the question clearly mentioned that we can only remove brackets that is we have to remove the minimum number of brackets to make it a valid shrink in other words we're only going to remove brackets and never the lowercase English letters now this is important because what we can do is simplify our life a bit what we can do is look at these characters instead as indices and we can filter out all of those characters which are lowercase English letters in this way we have simplified the problem quite a lot and now we only have to worry about the brackets opening and closing all right so let's go ahead and talk about uh a couple of rules that we discussed previously first was the thing where uh why do we use a stack and when do we use a stack as soon as we see a leaf quadrant being followed we are going to use a stack and in this question is a parenthesis question so we will use the stack the second thing was how do we use it well we're going to go from the left to the right and parse the input that is for every opening bracket we see we'll go ahead and add it to the stack and for regularly every Closing one we are going to remove an opening from the stack so both of them are going to resolve each other this will make sense in a second don't worry about it and the third one is how do we implement this in this case it is better to use indices instead of elements okay because we did a filtering out operation which means that indices are going to be the way to go all right so let's go ahead and get that input set up and now we have an empty stack with this so what we'll do is we'll go ahead and start to iterate from the left to the right so first we'll go ahead and look at the element 0. all right so element at the index 0 is an opening bracket so we're going to add it directly onto the stack no questions asked then we move on and we iterate further and we find another opening bracket at the index four so we'll again add the index 4 to the stack oh by the way I am adding these indices and you have to focus on getting these indices into the stack the brackets are there just for the sake of demonstration and understanding we're actually going to only have indices in the stack not the brackets anyways then we go ahead and reiterate further and we find that we get a closing round bracket now what does this mean we have found a closing round bracket which means that it is going to satisfy the opening round bracket so this 9 is going to get satisfied with the 4. both of them mix and match together and we'll pop the element 4 out of the stack this is the reason why you see 4 and 9 in the answer make sense now we reached the end of the iteration but 0 Still Remains on the top of the stack in other words it never gets satisfied it never finds any closing bracket to resolve it so we'll leave 0 out so the minimum remove to make valid parentheses is going to remove the element 0 from the input okay let's go ahead and take a look at another example and this one will really bring forward the core of the problem so let's go ahead and start iterating from the first element we see 0 which is a closing bracket now this closing bracket is going to close an opening bracket but do we have an opening bracket on top of the stack well no we don't even have any brackets on top of the stack we don't have any brackets at all which means that this closing bracket will never get satisfied it will be alone always and forever so we are going to leave it and we're going to iterate further all right so now we get an opening bracket let's go ahead and add it to the stack pretty simple next iteration we see that we get a 4. now this four did what as soon as this 4 got an opening bracket popped it out and satisfied both of them so now both the opening and the closing brackets have satisfied each other which means both of them are essential to be a part of the solution right so let's go ahead and continue iterating now we get 6 and this is an opening bracket so let's just go ahead and add it to the stack then we get a 7 also added to the stack and then we get a 9. what do we do when we get a 9 that's right we'll pop out the 7 and now both 7 and 9 will satisfy each other at this point we have 1 4 7 and 9 which are the parentheses which satisfy each other in other words they form an essential part of the answer however 0 and 6 have to be removed right we have to remove a minimum number of brackets and this way we have found two brackets to remove from the answer okay pretty simple uh but what would happen say if I get a 10 which is a closing bracket just for uh thought process sake as soon as I get this 10 what would happen this 10 is going to satisfy the element on the top of the stack which is the element six so 10 and 6 are going to satisfy each other and so there is where we end the iteration all right let's go ahead and take a look at the optimize solution and uh okay cool let's go ahead and get started now if you notice what we have done up till now is uh have a differentiation between these blue and the green ones right the blue ones were ones that never got satisfied and the green ones were the ones which got satisfied so the first thing I'm going to do is create an array called is okay which is going to be initialized with 0 for all the values of the string in other words I'm going to say none of the elements in the original shrink ever get satisfied that is my initial assumption and I'm going to build upon that later on now I'll also have an initial stack and we'll go ahead and start iterating over all the elements inside of the string so we'll first get its index another character for every single element of the string now if the characters in opening bracket what do we do if the character is an opening bracket we add it to the stack without asking any questions now what happens when we have a closing bracket when we have a closing bracket we'll first ask the question here does the stack exist is there any opening bracket on the top of the stack because if there is what do we do if there is we will pop that element from the top of the stack and assign its index the value 1. saying that this opening bracket which we just popped out is actually a one it is okay it is a green value as we saw in the case for one and seven both of them were opening brackets and they got Satisfied by four and nine respectively so one and seven both get this one and we also assign is okay if I to one as well saying that because 4 was the one that popped out one from the top of the stack one gets satisfied but also four gets satisfied so we're going to satisfy both of them and what is the else condition what if the stack is nonexistent what if we get a closing bracket and then we realize that hey wait a second the stack is empty so we can't really close any opening bracket in other words we'll just have to continue unfortunately skipping over this current I alright so was the final lens condition if you get a opening bracket we append it to the stack if you get a closing one we check the stack for emptiness or not and figure out what to resolve but there's a final condition which says if you have English letters well go ahead and also continue because we don't want to mess with any lowercase English letters what we are only going to message we are only going to mess with the indices of the parentheses all right so at the end of this iteration is okay is the array which contains all the information it is the one which contains the information of which all are blue which already do and which one or green the green represents one and blue represents zero right so let's go ahead and iterate further now the goal of this problem is to return the string we have to return the string by removing the minimum number of parentheses Now using this is okay array we have already found out all the parentheses which are essential and which are nonessential so what we are going to do is we are going to go ahead and build the answer character by character once again remember all of this what this tag did was to store the indices of the elements and this is why the is okay thing worked out now we are going to iterate over the string once again and we are going to ask the question hey is the character a bracket or not because if it is a bracket and only if it is okay only if it has been satisfied then we added to the answer because if it's a bracket and it has not been satisfied we'll have to continue we'll have to pass over this test case now was the else condition over here if the character is a bracket then you will have to check if it's okay or not but if a character is not a bracket that is it's a lowercase English letter then by default you have to add it to the answer all right anyways at the final point of time you go ahead and just return the answer so let's go ahead and run the code for sample test cases and some of this all right cool so this is it for the solution to the problem minimum remove to make valid parentheses hello everyone and welcome back let's talk about the problem longest valid parentheses now if you haven't seen the video on minimum remove to make valid parentheses this question will seem out of the blue however if you have seen that this question is just a breeze question because we're going to use the exact same logic as we saw in the previous one all right let's go ahead and talk about the problem statement of formally and we're given a string of just opening and the closing brackets that is we only have opening and the closing around brackets the goal of this problem is to find the longest substring of valid parentheses in other words let's take an example in the first test case we have the opening and the closing brackets which form a length of two but then we have three opening brackets which never get closed in other words the longest substring of valid parentheses is just 2. now the second test case is one where we have opening and closing bracket and then we have a bunch of opening brackets the bin one opening bracket at the end gets closed now what is the longest substring of valid parentheses we have in this case two sets of the length two substring of valid parentheses since both of them are of land 2 will just return to as the answer now what can we say right away about this kind of question this kind of question is actually twofold we have to find two things first first we have to figure out what all parentheses are valid or not because once we have the valid parentheses in hand once we know which of them are valid which of them are invalid we simply have to find the longest substring of them right so this is going to be uh broken down into two parts and if you realize the answer to the first one is something we've already seen all right since there is not a lot to go on let's go ahead and just build up our logic from the previous question as with the previous one we'll set up an is okay variable that is going to be all zeros of the length n in other words it's going to say that you know what I'll assume none of the brackets opening or closing ever get satisfied all of them are zeros we'll also have an initial initialization of this track and then we'll start to iterate our all the characters in the string as before we'll check if the character is a opening bracket or not because if it is an opening bracket will just directly add it to the stack what if it's a closing bracket though in the else Condition it's a closing bracket we'll have to check if the stack exists or not that is for this current closing bracket because I've gone in dl's case for this closing bracket does the stack exist in other words is there a opening bracket is there any opening bracket that you can find which had been put on the stack now if you can find that is the case well then go ahead and make both of them satisfied that is go ahead and pop the element from the top of the stack which is going to be an opening bracket and set its value to 1 that is that opening bracket has been satisfied by this current closing bracket and obviously that also means this current losing bracket has been satisfied so we'll set is okay file to B1 and the off chance that the stack is empty and you get a closing bracket well that's just sad we can't really do anything about that I'm sorry anyways once we're done figuring out which of them which of the brackets opening or closing are valid or not we simply have to figure out the longest substring of these valid cases so what we'll do is we'll set up a count which is going to be a running count of all the values and we have a answer which is going to store the maximum of all of these counts so what we're going to do is we're going to iterate in the range of n that is we'll iterate over every single index and we'll ask the question hey is the bracket I'm looking at is the current bracket okay or not because if it is okay well that's great news whatever the count was increase its value by one why because I found the case of a valid parenthesis right so as soon as I know this current bracket is a part of a valid substring go ahead and add one to the count else else what do we do if at this point of time there is a bracket which is a stray bracket which never gets opened or never gets closed well then we unfortunately have to reset the counter from zero okay so the next step is then going to be simply taking a Max of the answer in the count because answer wants to store the maximum possible value of all the counts ever all right so this is it for the code let's go ahead and run it and we'll go ahead and submit this as well and cool this gets accepted so yeah this is it for the solution to the problem long history valid parentheses hello everyone and welcome back this is the start of a new section on calculator related questions it builds on top of our previous work on parentheses related questions we'll be discussed the exact reasons why we use a stack how we use it especially the left to right parsing method and the implementation level details that we need to take care of now what I'm going to do in this video is establish the we just need two steps that's right just two steps we need to know to solve any calculator related question in fact both of these steps individually are interview problems on their own which means that once we solve both of them both of these questions we'll be able to solve any calculator related question that is like killing three birds with two stones all right so the first step is to parse the input from the infix to the postfix notation and the second one is to evaluate the post fix notation now the first question that you should ask is wait what is the post fix notation so let's go ahead and talk about the introduction to the postfix notation first all right let's go ahead and take a simple example and let's see that we have this kind of string that we need to evaluate now the infix notation is formally defined as such in the infix notation the operator is fixed in between the operands again the operator is the focus over here and the operator is going to be fixed in between in the operands now what is the post fixed notation formally speaking postfix notation is where the operator is present after the operands now that might sound a bit unnatural given that what we have been looking at all throughout our life is the infix notation this is the simple in fixed notation over here and if I ask you the question hey how would you go about evaluating this kind of thing what would you do the first thing we'll look at is brackets so we'll evaluate everything inside of the brackets so 3 times 3 becomes 9. and so this is the expression that we have now what do we do next we realize that we have to do a division operation first which means that we'll do 9x7 C style division so 9x7 will get rounded off to 1. and now we have 0 minus 1 plus 1. and since plus and minus are of the same priority we'll simply cancel both of them out and say the final answer is nothing but zero now what have we done over here what we have done is simply apply a rule called bod Mass which stands for bracket order division multiplication addition and subtraction this is a rule that is commonly taught in high school math and is the way we evaluate any sort of input given to us however there is a small catch see if you have brackets inside of brackets those brackets inside of brackets need to be resolved first before you evaluate the brackets and if you have brackets inside of brackets inside of brackets then you resolve then you need to resolve the innermost bracket first then zoom out and then zoom out once again you can see that this sort of nesting is what can give rise to such complicated expressions and while the first one on the top is pretty easy to solve using the same in fixed notation the second one becomes much more harder and so the question arose whether we can write the expression unambiguously and we can solve it efficiently that is without having to worry about this Bond Mass rule is there a way we can write this expression and secondly is there an efficient way to solve that expression once you have written it that way this is the idea behind post fixed notation the both fixed notation simply says that the operator is present after the operands in other words if we take an example like this we have 1 2 plus it is equivalent to saying 1 plus 2. again I know this sounds unnatural but bear with me for a second because something interesting is going to happen let's see if we have 1 2 plus 3 star what will that evaluate to 1 2 plus will become 3 and then we have 3 3 star in other words we'll have 3 times 3. what we have done is one plus two inside of brackets that needs to be resolved first and then we'll do times three do you notice something if we go back the other way around we have figured out a way to write these bracketed Expressions into nonbracketed ones that is one plus two which had to be resolved first which were present inside of the brackets we found a way to write that without using the brackets how nice is that we were able to figure out a way to unambiguously write this expression all right so this is the general idea behind using a postfixed notation and so we can finally formally talk about these two steps again the first step was to convert and parse the input from the infects to the postfix notation and that is something we're going to look at in the next video and then in the next to next one we'll look at how do you evaluate the postrix notation all right so let's get started hello everyone and welcome back let's talk about how do we convert the infects to the post fix notation as we discussed the infix notation is one in where we put the operator in between the operands that is we fix the operator such as a minus between the operands such as 0 and 1. so we have something like 0 minus 1. in the post fixed notation we have the operator after the operands where we have something like 0 1 minus let's go ahead and take a look at some examples to understand this vector in the case we have 1 plus 2 in the infix notation it gets converted to 1 2 plus if we have say 5 minus 6 it gets converted to 5 6 minus and then if we have something like 1 plus 2 times 3 we have 1 2 plus 3 times wait a second uh one two sorry one plus two times three will evaluate to 1 plus 6 which is nothing but 7. but if we actually evaluate this will come out to be wrong that's because 1 2 plus will get evaluated to 3 first and then we'll have to do three times three giving us the answer nine this is in fact wrong we are doing one two plus three times which is wrong so what do we have to do instead we have to switch out the ordering of this Plus because now what we have done is we have done one two three Star Plus basically saying go ahead and multiply 2 and 3 first so 2 times 3 becomes 6 and so we'll write 1 6 Plus Now 1 6 Plus is what it's nothing but 1 plus 6 which is seven and so now we have the correct answer but if you notice what happened over here we realized something The Ordering of these plus and the star operators changed right we had one plus two times three and it becomes 1 2 sorry it became one two three Star Plus so the ordering of the plus and the star operators change although the ordering of the operands like one two three did not change there's something interesting which we'll come to very soon again all right so now we want to formally talk about how do we convert the infix notation to the postfix notation right so let's go ahead and try to work out the answer one by one so using the board Master will let me know we can say that you know what let's go ahead and do the division operation first all right so we have to do B by C first and how are we going to write d by C we're going to write it as B C slash all right pretty simple up till now then what do we do next we also realize that there's a b by c times D we have to do times D in The Next Step because that is the second operation we have to follow using the board Mass rule so what will how do we write times d well BC by forms one single operand now and so we have to multiply BC by with d BC by is one operating and D is another and so we can write BC by D star all right how do we handle the plus case and the minus case then well it's going to handle the plus one first so we have a plus this entire expression now can we handle that we can write a in the front and plus the end and then we have minus E towards the end so we can write it as e minus right so we followed the bod Mass property and we have written down the infix to the postfix notation in fact if you break it down we have something of this sort first we looked at BC slash then D star then a plus and then e minus following the board Mass rule exactly in fact what we have done here in other words is that we have somehow implicitly encoded the information of the bond Mass rule into the post fixed notation now to evaluate the post fixed notation we won't need this bodmas rule at all because we have already encoded that information in the structuring of the post fixed notation right let me go ahead and explain that further what we have done is that we looked at the bod muscle and we figured out that we have to First Look at brackets then order then Division and multiplication are the same level then addition and subtraction are the next lower level right so this is something we've implicitly encoded into the answer look at the ordering of The Operators we have slash first then star then plus and then minus I also want you to notice another thing which I brought up earlier as well The Ordering of the operands which are a b c d and e remain the same from the infix to the post fixed notation only and Only The Ordering of The Operators change it went from plus slash star minus that is it went from a completely random ordering to a welldefined ordering where we had division multiplication addition and subtraction so now the question is how do we implement this how do we make this happen using formal logic what we're going to do is we're going to go ahead and use a stack to do this let me actually run a simulation and show you how this works the first thing we'll do is we'll start to iterate from the left to the right and so let's say that we get the first element as a since this is the operand and we don't mess with the order of the operands we are just going to write it as a part of the answer directly no thinking twice you see an operand you write it in the answer that's it as simple as that what's the next step the next step is to iterate further and we see that we get a plus sign since the ordering of these operators do change later on we'll keep them in a stack for now and we'll see what to do later on right so now we add this plus to the stack then we get the element B and what do we do since b as an operand We'll add it and obtain it at the end of the post fixed answer all right cool so now we get a slash now I'm going to ask you a very important question is it okay to put this slash after this Plus or should we instead remove this plus first and add the slash later on what should we do let's think about something that is going to happen if you remember stack follows something called the default ring the last one to come in is the first one to get out and notice how the answer on the top right hand side says the answer on the top right hand says that we have to have division then multiplication then addition and subtraction that is we have to follow this highest to lowest ordering in the post fixed notation that is something that we have to encode it by default now if it means that we have to have the highest operation highest priority operators first and the lowest ones later on using this lifo notation what should be the ordering we follow in the stack again the last ones to get in will be the first ones to get out so if you want the highest ones to come first in the answer we'll have to ensure that the highest ones are the first one to leave out of the stack in other words we have to say that the stack follows the lowest to highest ordering so in fact what we have right now plus followed by a slash is okay because in the edge case because in the edge case that we ever decide to remove both of these elements first will pop out slash and then Plus which now exactly follows the ordering we want right so I think that should make a lot more sense now so let's go ahead and continue iterating we get the element C and since this is an operand We'll add it directly add it to the stack now what do we do when we get a slasher uh sorry when we get a star operation remember the board Mass rule it says the first you resolve brackets then order then Division and multiplication at the same level what does it mean for us to get a division and a multiplication right now this is nothing but going to hint us at the fact that this multiplication operator is actually going to take this division operator and kick it out because both of them are of the same priority and remember what is the ordering of the stack The Ordering of the stack goes from the lowest to the highest all right we can't allow elements of the same priority to stick in together so we'll have to kick out the Slash and only then we can add in the star again if you look at it it is still going to maintain lowest to the highest ordering now right it only happens after we kick out the Slash and if you look on the top side top right hand side we can see that you know what this is indeed the correct way to go so we're thinking about this correctly anyways let's keep on iterating further and see what happens we get a d and since this is a what since this is an operand we'll add it directly to the answer then we get a minus and now what happens the priority of minus is much lower than that of multiplication which means that this minus is going to kick out the multiplication you can think about it this way you can think that an undeserving candidate comes a lower priority element comes and it kicks out all the higher priority or the equal priority elements out of the stack it says that you know what you guys are much higher priority than me minus comes in and says you know what addition and multiplication are both either higher or equal to me so I'll kick you both out let me just go and stay in the stack so we'll go ahead and first kick out the multiplication operator and then we'll again compare it with the addition one so now we'll say okay you know what since plus and minus are both of the same priority let's go ahead and kick out plus as well then we'll add minus into the stack okay so now we can go ahead and continue iterating and we get the value e we'll just add it to the answer and then wait a second we have reached the end of the iteration right after e we have reached the end of the iteration so what do we want to do if we want to empty out the contents of the stack and since there is only one single element let's just go ahead and add this at the end so now you can go ahead and compare both of them and realize that you know what we were actually a right all of this logic worked out for us so now we want to go ahead and formalize the logic and write it in terms of code and we're going to follow the exact same things that I taught you before first things first let's create a post fix array which will return at the end and now we'll also create a stack for The Operators the stack is only ever going to store The Operators and not the operands now we want to start iterating over every single element in the infix and we're going to call this element token because it can either be operator or an operand we don't know yet now we'll ask the question hey if the token is not an operator that is if it's a letter or if it's a number or digit something like that if the token is not in the operators then what do we do hit me is that the token is actually an operand and in that case we realize that we just have to directly append it to the postfix notation we don't ask any more questions and that is it for an operand now what happens if we have an operator though then obviously we want to append this item to the stack we want to push the token onto the stack remember stack follows the lowest to highest ordering which means that we have to write one or two lines of code more and this is very important and this is something we'll come to by the way in the next section as well okay so let me explain what's going on here I'm going to say while the stack exists that is while there are elements in the stack and the priority of the element on the top of the stack is greater than the priority of the current token that is we're looking at something like a minus as the current token and the top of the stack is a star which we had a case like that before if we have a case like that then this current token of lower priority is kick out is going to kick out the element from the top of the stack and it's going to kick that element from the top of the stack we'll do stack.pop and whatever the element was kicked out is going to be appended to the post fix one directly so we are going to say while that is true while the current priority of the token is lesser than equals to the priority of the element on the top of the stack then keep on doing this for prep operation because we are strict we want to have a lowest to highest ordering we can't even allow elements of the same priority to be there because even if the priority same we're still going to make a cake operation we're going to kick that element out from the top of the stack and append it to the post fix notation all right good so this should make sense now because we have to follow the lowest to the highest ordering okay what's the last step then are we done if you remember we had the case where there was one single element minus in the stack remaining at the end so we'll actually have to handle cases like that as well and we have to say you know what while the stack exists while there are a bunch of operators in the stack go ahead and pop that element of the stack and append it to the post six now obviously in this kind of case we will only ever have one single element like that okay anyways uh all of this was to convert this kind of input as we saw on the top from the infix notation to the postfix notation but now I ask you the question is it possible to somehow include in Brackets as well because look at the inputs we have never talked about brackets up till now we've only talked about operands and operators what if there are brackets all right let's go ahead and write some more code and since brackets are of higher priority since you know in bodmas you will be always take care of brackets first let's go ahead and handle the cases of brackets in the first two conditions so the first will first thing we'll see is that if the token is an opening bracket what do we do we will append this token on top of the stack we'll say you know what this is going to start of a new expression that we need to take care of earlier on so let's go ahead and append this token on the top of the stack okay now what well we want to say you know what if the token is a closing bracket then we need to do something more as soon as we get a closing round bracket what do we want to do we want to take care of all the elements present between this opening round bracket and the closing round bracket so what we are going to do is we're going to say you know what while the stack of top while the stack top is not an opening bracket go ahead and kick out all the elements one by one so what we are going to say is everything in between of these two brackets between this opening round bracket and the closing round brackets go ahead and pop those elements from the top of the stack and keep on appending them to the post fix notation one last thing that we have to do what is the one last thing the stack top is currently now having the opening round bracket as the Stacked out why is that because that is when the while loop exists because the stack top is going to have the opening round bracket which means that we have to take care of that once again we have to do a stack.pop operation saying that you know what we don't really care about brackets in the post fix notation because that was the whole point of post fixed notation to get rid of the brackets in the weird board Mass ordering now let me ask you this one question and this is a kind of a special trick case that we need to take care of remember the board Mass rule right and what I promised at the start was that we will be able to somehow implicitly encode the information of the infix notation in the postfix notation right and we were able to do that by handling the cases of brackets separately and division multiplication addition subtraction all right but now if I ask you let's go ahead and also formally Define the priority what is that going to look like because we use this priority over here in the while loop right now how do we Define the priority well the priority will be a little bit different so obviously the order has the highest priority then division multiplication and then addition subtraction but the bracket the opening bracket will have the lowest priority why is that you ask it has a very interesting reason behind it all right let's say that we have a bunch of elements in the stack let's say there's a opening bracket and now let's say that the operator is simply a star so we have an opening bracket and a star after it now let's say that the minus comes right so what is minus going to do minus is a lower priority element so it is going to kick out the star out of the stack but at the same time we want to ensure that this minus does not kick out the opening round bracket because it's not minus his job to handle that it's the job of the closing bracket to handle that in its own while condition so we are going to have opening bracket having the lowest priority so that the minus or any other sign in fact is never able to kick it out of the stack all right so in this video we learned how to convert the infix notation to the postfix notation now I promise you in the next one we're going to look at how do we evaluate the post fix notation and that is going to be a so so much simpler than this code hello everyone and welcome back let's talk about how to evaluate the post fix notation in the previous video we looked at how do we convert the infix notation to the post fixed notation and I promised early on that the post switch notation is going to be a very easily computable way to get the answer for any calculator related question what we're going to do is very simple I'm going to create a stack and now we'll see that we're going to start iterating from the left to the right now for elements like 0 which we'll get as operands we are going to push them onto the stack without asking any questions as soon as we get another operand let's say in the case of one we are also going to the push it to the top of the stack but things get a bit more interesting when we get an operator because now what does this operator mean what is this entire 0 1 minus thing mean this means that we have to do 0 minus 1. in other words we have to pop one out of the stack we have to also pop out Zero from the stack take their negation that is do 0 minus 1 because we have gotten a current value as the negative minus sign so we have to do 0 minus 1 and then put it back into the stack right so what did we do you get an operand you add it to the stack no asking questions Twice But as soon as you get an operator go ahead and remove two values from the top of the stack do the evaluation and then add them back in okay let me continue and show you what this means so we get three this is an operand we'll add it to the stack we get another three operand add to the stack what do we do when we get a star as soon as we get a star we'll pop one value out we'll pop another value out multiply both of them since this is a star operation find the value and push this answer back onto the stack okay again what do we do when we get a 7 add this one to the stack now what do we do when we get a slash what will the be the next step since we have a slash we're going to pop out the last two elements seven and nine we're going to take the division nine by seven and this is the C style division so we'll get the answer as one so we'll get the answer as 1 and we'll push this back onto the stack and then finally we have the plus operation where we'll pull out one we're also pop out minus one add them together get the answer 0 and then push it back onto the stack at the end of this iteration one thing is guaranteed there will be only one single element inside of the stack and that will be the answer okay so what are the rules formally speaking we do two things first if you have an operand you add it to the stack else you pop the last two elements evaluate them and then add them add their result onto the stack again all right so let's go ahead and look at the code implementation of the same problem this is the problem evaluate reverse polish notation which is the same as the post fix notation on lead code all right what are we going to do first things first initialize a stack right the stack is going to be an empty list I'm also going to Define these Ops which is basically going to Define for this character for this current operator represented as a string as a character I want to do this operation I'm going to do operator dot add for minus I'm going to do the subtraction for the multiplication I'm going to do 1 and then for the division I am not going to do floor Dem right these are the two options because we have one as true div which is just a slash and the floative which is actually double slash so it might look tempting for you to do double slash in when it comes to python code although in other languages you can just do slash and get away with it in Python do not do double slash because that is floor div that does not work as intended as you want and it's going to give you issues when it comes to negative values uh I won't go into much more detail in that you can go check out some of the links down below anyways what we're going to do next is we're going to iterate over these token given in the input tokens so what was the goal we have to first figure out if it's operand or not now we'll say if the token is not in the operators that is if the token is not of plus minus multiplication or division symbols that means it's a integer value given to us so what we're going to do is we're going to convert that token to an end value and append it to the stack all right cool so now what we're going to do in the else condition the else conditions when we have these kind of operators with us so what we want to do is pop out two elements from the top of the stack do the computation and then append the result back into the stack now just a quick run through of what's Happening note that the ordering of these matters a lot we are first going to pop out N2 and then N1 again uh look at all of the simulation actually Vijaya I didn't explain it back them but is something very important look at what we have done right so as soon as we get the plus operation what do we do we first pop out this element from the top of the stack which is going to take the second place and then we're going to pop out this element which is going to take the first place so this one we currently popped out this guy is the N1 and the element on the right hand side is the N2 right this makes more sense for division as well as subtraction because they are not exactly commutative all right anyways first will pop out N2 and then will pop out N1 whatever the result is we are going to get it by using this Ops of token that is whatever this token is say it's a plus sign so we'll go ahead into this dictionary and access this operator dot add function and this is going to take into values again N1 and N2 whatever the result is we're going to append it to the stack now one last thing that we realized one last thing that we realized was that the stack is going to have only one single element at the end of this iteration which is going to be the answer so we return it at the end and uh now let's go ahead and test the code out so we'll run the code once okay looks good and we'll go ahead and submit this all right cool so this works out and uh yeah this is sort of a formal implementation of evaluating reverse polish notation by the way if this seems too fancy you can write some manual code here as well you can just say LF token is a plus sign just go ahead and do this this this and result will be nothing but N1 plus into and something like this and so you can do LF for all of these sort of cases right if that seems too fancy you can do it this way as well all right cool so this is it and I'll see you in the next one hello everyone and welcome in this video we're going to implement basic calculator one two and three all using the same exact code believe me I'm going to do a copy paste like nothing you've seen before all right so the first thing we want to do with basic calculator is realize that we have already written most of the code in these two functions post function is going to convert the infix notation to the post fixed notation and the second one is going to evaluate the post fix notation again both of these functions have been covered in separate videos of their own which each of their own intuitions observations and formal code that we wrote down in this question however we have to write one more function which is going to do the parsing or the cleaning up thing so we're going to do and create a read function which is going to take in the string and return us the infix notation all right that is the goal of this problem okay why do we do this by the way look at this the input we are given is a string and so we can have a case like 3 plus a bunch of spaces one space times 337 okay so nothing too special but you can see that this is a hard string to work with mostly because won't it be so nice if you can actually have a list of tokens that we need to focus on that is if you have something like say uh something that gave us three then something that gave us Plus then punch Then star then 337. won't it be nice if we have a infix notation laid out like this right this will make things a lot simpler because we don't have nasty spaces to deal with and all of the numbers have been dealt with that is 337 actually is considered as 337 and not three three and seven right these are some of the cases that we have to handle and so what we are going to do is convert and read the string into the infix notation so the infix notation is going to be a list which will return at the end how do we go about making this happen well we'll go ahead and write a by Loop so we'll say I equals to 0 and while I is lesser than the length of s go ahead and keep on doing some computation the first thing we'll do is clear out all the spaces so if the SFI the current character I'm looking at if it's a space well just go ahead and ignore this I don't really want to mess with this what do we do well in the case of space we simply ignore but in the case of operators we can't really do that because we have to add these individual operators to the infix notation list so what I'm going to say is if if s of I is present inside of the operators by the way these operators is the variable over here which is simply just the brackets and the multiplication division signs blah blah if the current character I'm looking at is an operator well then go ahead and add this to the infix list so I'll do infix dot append the current s of I I'll also do I plus equals to 1. all right what's the else condition vl's condition is some case where we have a digit like 2 or 234 or 345 things like that so we have to handle cases like these separately right what I'm going to do is I'm going to create a number variable which is going to be an empty string and I'm going to say you know what while the SFI dot digit is digit actually so while the SFI I'm looking at is a digit well then go ahead and append this to the number so I'll do number plus equals to the S of I and once I'm done with this oh by the way I'll also do I plus equals to 1 always and once I'm done with this iteration when the saturation stops when I get either a space or an operator I'm going to say you know what go ahead and stop at this point of time and please go ahead and do infix dot document p number one thing that we always check whenever we write these by Loops is whether s of I will actually exist or not there might be a case where this I plus 1 might take it out of the length of the string so we'll also have to say keep it limited to that while I is less than length of s and this happens then do these computations okay so we are almost done but there's one more thing that we have to keep in mind and this is sort of a well kind of a pain implementation that we have to take care of because here's the thing the minus could be used as an unary operation that is in the case of 1 and sort of minus of 2 plus 3 all of these cases like all of these cases are valid but in one of the codes we have seen previously we did not handle these unre operations so what is a hacky way around this okay this is going to be a very happy way but what we can do is we can add a 0 in front of it so as soon as we get an honorary minus we're going to do 0 minus that thing so in the case of minus 1 we'll instead write it as 0 minus 1 and instead of minus of 2 plus 3 we are going to write it as 0 minus 2 plus 3. this is going to make the rest of the implementation consistent with the logic so we'll have to say you know what uh before you do this please go ahead and check if the SFI is actually a minus sign or not because if it's a minus sign then we need to do some extra steps before we can jump into solution all right when is a character when is this minus sign and unre operated this is a ninery operator in a bunch of cases we have to say first of all if I equals 2 equals to 0 then go ahead and do infix dot append 0. that is if this minus sign is the first thing you ever get in the entire string if it is the first position in the string then you have to append a 0 before you append this current operator all right but this is not the only case all right so we can have another case where we say uh say 5 minus of minus 2. all right so this is a case where the preceding element with the element to the previous of this minus is actually an opening bracket so we'll also have to take care of this condition and say that you know what if the current minus the zerothal element is the zeroth place where an append 0 to the infix before you append the minus or we have to say or if the S of I minus 1 If the previous element If the previous character was an opening bracket then what then you have to take care to also append the zero by the way just to make sure that this I minus 1 actually exists we have to write one more condition and say that this I minus 1 this I minus 1 should be greater than equals to 0. right so pretty simple and uh yeah I think we're done now let's go ahead and run the code once oh by the way we still have to write all these functions now so the first thing we'll do is go ahead and read the S string given as the input and this will get me the infinix notation for the infix notation I'm going to convert it to the post fix notation so post fix equals to in fixed to postfix of impacts and finally I'm going to return evaluate postwix all right cool let's go ahead and test this out hopefully it works ah God damn it okay it's a typo line 20. is digit okay cool fixed again hoping that we don't have any issues let's just hope that we don't have any more issues it's going to be a pain otherwise all right I'm gonna go ahead and submit this let's hope and great we got it accepted cool so now as I promised before we're going to do a massive copy pasting thing I'm gonna control C go here and uh paste this baby over here let's go run the code once again get it accepted here all right cool looks good and once finally in the basic calculator 3 is going to do the submit directly YOLO all right cool so we get this code accepted in all the three questions just by using these simple Logics what did we do we first read the input string and we sort of cleaned it up and converted the string to a list of tokens then we went ahead and evaluated and converted the infix to the post fix notation and finally we evaluated the postrix notation all right cool uh this is it for this video and this ends the string related section of Stack questions next up we're going to look at monotonic Stacks which is more of a mathematical side of stacks all right
